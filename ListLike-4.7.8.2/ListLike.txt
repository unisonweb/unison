-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalized support for list-like structures
--   
--   Generalized support for list-like structures in Haskell.
--   
--   The ListLike module provides a common interface to the various Haskell
--   types that are list-like. Predefined interfaces include standard
--   Haskell lists, Arrays, ByteStrings, and lazy ByteStrings. Custom types
--   can easily be made ListLike instances as well.
--   
--   ListLike also provides for String-like types, such as String and
--   ByteString, for types that support input and output, and for types
--   that can handle infinite lists.
@package ListLike
@version 4.7.8.2


-- | Generic tools for data structures that can be folded.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.FoldableLL

-- | This is the primary class for structures that are to be considered
--   foldable. A minimum complete definition provides <a>foldl</a> and
--   <a>foldr</a>.
--   
--   Instances of <a>FoldableLL</a> can be folded, and can be many and
--   varied.
--   
--   These functions are used heavily in <a>Data.ListLike</a>.
class FoldableLL full item | full -> item

-- | Left-associative fold
foldl :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | Strict version of <a>foldl</a>.
foldl' :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | A variant of <a>foldl</a> with no base case. Requires at least 1 list
--   element.
foldl1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Right-associative fold
foldr :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Strict version of <a>foldr</a>
foldr' :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Like <a>foldr</a>, but with no starting value
foldr1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Combine the elements of a structure using a monoid. <tt><a>fold</a> =
--   <a>foldMap</a> id</tt>
fold :: (FoldableLL full item, Monoid item) => full -> item

-- | Map each element to a monoid, then combine the results
foldMap :: (FoldableLL full item, Monoid m) => (item -> m) -> full -> m

-- | Monadic version of left fold, similar to <a>foldM</a>.
foldM :: (Monad m, FoldableLL full item) => (a -> item -> m a) -> a -> full -> m a

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | A map in monad space, discarding results.
mapM_ :: (Monad m, FoldableLL full item) => (item -> m b) -> full -> m ()
instance Data.ListLike.FoldableLL.FoldableLL [a] a


-- | Generic operations over list-like structures
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Base

-- | The class implementing list-like functions.
--   
--   It is worth noting that types such as <a>Map</a> can be instances of
--   <a>ListLike</a>. Due to their specific ways of operating, they may not
--   behave in the expected way in some cases. For instance, <a>cons</a>
--   may not increase the size of a map if the key you have given is
--   already in the map; it will just replace the value already there.
--   
--   Implementators must define at least:
--   
--   <ul>
--   <li>singleton</li>
--   <li>head</li>
--   <li>tail</li>
--   <li>null or genericLength</li>
--   </ul>
class (IsList full, item ~ Item full, FoldableLL full item, Monoid full) => ListLike full item | full -> item

-- | The empty list
empty :: ListLike full item => full

-- | Creates a single-element list out of an element
singleton :: ListLike full item => item -> full

-- | Like (:) for lists: adds an element to the beginning of a list
cons :: ListLike full item => item -> full -> full

-- | Adds an element to the *end* of a <a>ListLike</a>.
snoc :: ListLike full item => full -> item -> full

-- | Combines two lists. Like (++).
append :: ListLike full item => full -> full -> full

-- | Extracts the first element of a <a>ListLike</a>.
head :: ListLike full item => full -> item

-- | Extract head and tail, return Nothing if empty
uncons :: ListLike full item => full -> Maybe (item, full)

-- | Extracts the last element of a <a>ListLike</a>.
last :: ListLike full item => full -> item

-- | Gives all elements after the head.
tail :: ListLike full item => full -> full

-- | All elements of the list except the last one. See also <a>inits</a>.
init :: ListLike full item => full -> full

-- | Tests whether the list is empty.
null :: ListLike full item => full -> Bool

-- | Length of the list. See also <a>genericLength</a>.
length :: ListLike full item => full -> Int

-- | Apply a function to each element, returning any other valid
--   <a>ListLike</a>. <a>rigidMap</a> will always be at least as fast, if
--   not faster, than this function and is recommended if it will work for
--   your purposes. See also <a>mapM</a>.
map :: (ListLike full item, ListLike full' item') => (item -> item') -> full -> full'

-- | Like <a>map</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits for things such as
--   ByteStrings, since it will let the ByteString use its native low-level
--   map implementation.
rigidMap :: ListLike full item => (item -> item) -> full -> full

-- | Reverse the elements in a list.
reverse :: ListLike full item => full -> full

-- | Add an item between each element in the structure
intersperse :: ListLike full item => item -> full -> full

-- | Flatten the structure.
concat :: (ListLike full item, ListLike full' full) => full' -> full

-- | Map a function over the items and concatenate the results. See also
--   <a>rigidConcatMap</a>.
concatMap :: (ListLike full item, ListLike full' item') => (item -> full') -> full -> full'

-- | Like <a>concatMap</a>, but without the possibility of changing the
--   type of the item. This can have performance benefits for some things
--   such as ByteString.
rigidConcatMap :: ListLike full item => (item -> full) -> full -> full

-- | True if any items satisfy the function
any :: ListLike full item => (item -> Bool) -> full -> Bool

-- | True if all items satisfy the function
all :: ListLike full item => (item -> Bool) -> full -> Bool

-- | The maximum value of the list
maximum :: (ListLike full item, Ord item) => full -> item

-- | The minimum value of the list
minimum :: (ListLike full item, Ord item) => full -> item

-- | Generate a structure with the specified length with every element set
--   to the item passed in. See also <a>genericReplicate</a>
replicate :: ListLike full item => Int -> item -> full

-- | Takes the first n elements of the list. See also <a>genericTake</a>.
take :: ListLike full item => Int -> full -> full

-- | Drops the first n elements of the list. See also <a>genericDrop</a>
drop :: ListLike full item => Int -> full -> full

-- | Equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>. See also
--   <a>genericSplitAt</a>.
splitAt :: ListLike full item => Int -> full -> (full, full)

-- | Returns all elements at start of list that satisfy the function.
takeWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the start of the list that satisfy the
--   function.
dropWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the end of the list that satisfy the function.
dropWhileEnd :: ListLike full item => (item -> Bool) -> full -> full

-- | The equivalent of <tt>(<a>takeWhile</a> f xs, <a>dropWhile</a> f
--   xs)</tt>
span :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The equivalent of <tt><a>span</a> (<a>not</a> . f)</tt>
break :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | Split a list into sublists, each which contains equal arguments. For
--   order-preserving types, concatenating these sublists will produce the
--   original list. See also <a>groupBy</a>.
group :: (ListLike full item, ListLike full' full, Eq item) => full -> full'

-- | All initial segments of the list, shortest first
inits :: (ListLike full item, ListLike full' full) => full -> full'

-- | All final segnemts, longest first
tails :: (ListLike full item, ListLike full' full) => full -> full'

-- | True when the first list is at the beginning of the second.
isPrefixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is at the beginning of the second.
isSuffixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is wholly containted within the second
isInfixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | Remove a prefix from a listlike if possible
stripPrefix :: (ListLike full item, Eq item) => full -> full -> Maybe full

-- | Remove a suffix from a listlike if possible
stripSuffix :: (ListLike full item, Eq item) => full -> full -> Maybe full

-- | True if the item occurs in the list
elem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | True if the item does not occur in the list
notElem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | Take a function and return the first matching element, or Nothing if
--   there is no such element.
find :: ListLike full item => (item -> Bool) -> full -> Maybe item

-- | Returns only the elements that satisfy the function.
filter :: ListLike full item => (item -> Bool) -> full -> full

-- | Returns the lists that do and do not satisfy the function. Same as
--   <tt>(<a>filter</a> p xs, <a>filter</a> (<a>not</a> . p) xs)</tt>
partition :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The element at 0-based index i. Raises an exception if i is out of
--   bounds. Like (!!) for lists.
index :: ListLike full item => full -> Int -> item

-- | Returns the index of the element, if it exists.
elemIndex :: (ListLike full item, Eq item) => item -> full -> Maybe Int

-- | Returns the indices of the matching elements. See also
--   <a>findIndices</a>
elemIndices :: (ListLike full item, Eq item, ListLike result Int) => item -> full -> result

-- | Take a function and return the index of the first matching element, or
--   Nothing if no element matches
findIndex :: ListLike full item => (item -> Bool) -> full -> Maybe Int

-- | Returns the indices of all elements satisfying the function
findIndices :: (ListLike full item, ListLike result Int) => (item -> Bool) -> full -> result

-- | Evaluate each action in the sequence and collect the results
sequence :: (ListLike full item, Applicative m, ListLike fullinp (m item)) => fullinp -> m full

-- | A map in monad space. Same as <tt><a>sequence</a> . <a>map</a></tt>
--   
--   See also <a>rigidMapM</a>
mapM :: (ListLike full item, Applicative m, ListLike full' item') => (item -> m item') -> full -> m full'

-- | Like <a>mapM</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits with some types.
rigidMapM :: (ListLike full item, Monad m) => (item -> m item) -> full -> m full

-- | Removes duplicate elements from the list. See also <a>nubBy</a>
nub :: (ListLike full item, Eq item) => full -> full

-- | Removes the first instance of the element from the list. See also
--   <a>deleteBy</a>
delete :: (ListLike full item, Eq item) => item -> full -> full

-- | List difference. Removes from the first list the first instance of
--   each element of the second list. See <tt>(\\)</tt> and
--   <a>deleteFirstsBy</a>
deleteFirsts :: (ListLike full item, Eq item) => full -> full -> full

-- | List union: the set of elements that occur in either list. Duplicate
--   elements in the first list will remain duplicate. See also
--   <a>unionBy</a>.
union :: (ListLike full item, Eq item) => full -> full -> full

-- | List intersection: the set of elements that occur in both lists. See
--   also <a>intersectBy</a>
intersect :: (ListLike full item, Eq item) => full -> full -> full

-- | Sorts the list. On data types that do not preserve ordering, or
--   enforce their own ordering, the result may not be what you expect. See
--   also <a>sortBy</a>.
sort :: (ListLike full item, Ord item) => full -> full

-- | Inserts the element at the last place where it is still less than or
--   equal to the next element. On data types that do not preserve
--   ordering, or enforce their own ordering, the result may not be what
--   you expect. On types such as maps, this may result in changing an
--   existing item. See also <a>insertBy</a>.
insert :: (ListLike full item, Ord item) => item -> full -> full

-- | Converts the structure to a list. This is logically equivolent to
--   <a>fromListLike</a>, but may have a more optimized implementation.
--   These two functions are now retired in favor of the methods of IsList,
--   but they are retained here because some instances still use this
--   implementation.
toList' :: ListLike full item => full -> [item]

-- | Generates the structure from a list.
fromList' :: ListLike full item => [item] -> full

-- | Converts one ListLike to another. See also <a>toList'</a>. Default
--   implementation is <tt>fromListLike = map id</tt>
fromListLike :: (ListLike full item, ListLike full' item) => full -> full'

-- | Generic version of <a>nub</a>
nubBy :: ListLike full item => (item -> item -> Bool) -> full -> full

-- | Generic version of <a>deleteBy</a>
deleteBy :: ListLike full item => (item -> item -> Bool) -> item -> full -> full

-- | Generic version of <a>deleteFirsts</a>
deleteFirstsBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>union</a>
unionBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>intersect</a>
intersectBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>group</a>.
groupBy :: (ListLike full item, ListLike full' full, Eq item) => (item -> item -> Bool) -> full -> full'

-- | Sort function taking a custom comparison function
sortBy :: ListLike full item => (item -> item -> Ordering) -> full -> full

-- | Like <a>insert</a>, but with a custom comparison function
insertBy :: ListLike full item => (item -> item -> Ordering) -> item -> full -> full

-- | Length of the list
genericLength :: (ListLike full item, Num a) => full -> a

-- | Generic version of <a>take</a>
genericTake :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>drop</a>
genericDrop :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>splitAt</a>
genericSplitAt :: (ListLike full item, Integral a) => a -> full -> (full, full)

-- | Generic version of <a>replicate</a>
genericReplicate :: (ListLike full item, Integral a) => a -> item -> full

-- | A version of <a>ListLike</a> with a single type parameter, the item
--   type is obtained using the <a>Item</a> type function from
--   <a>IsList</a>.
type ListOps full = (ListLike full (Item full))

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | An extension to <a>ListLike</a> for those data types that are capable
--   of dealing with infinite lists. Some <a>ListLike</a> functions are
--   capable of working with finite or infinite lists. The functions here
--   require infinite list capability in order to work at all.
class (ListLike full item) => InfiniteListLike full item | full -> item

-- | An infinite list of repeated calls of the function to args
iterate :: InfiniteListLike full item => (item -> item) -> item -> full

-- | An infinite list where each element is the same
repeat :: InfiniteListLike full item => item -> full

-- | Converts a finite list into a circular one
cycle :: InfiniteListLike full item => full -> full

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()
instance Data.ListLike.Base.ListLike [a] a


-- | String-like functions
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.IO

-- | An extension to <a>ListLike</a> for those data types that support I/O.
--   These functions mirror those in <a>System.IO</a> for the most part.
--   They also share the same names; see the comments in
--   <a>Data.ListLike</a> for help importing them.
--   
--   Note that some types may not be capable of lazy reading or writing.
--   Therefore, the usual semantics of <a>System.IO</a> functions regarding
--   laziness may or may not be available from a particular implementation.
--   
--   Minimal complete definition:
--   
--   <ul>
--   <li>hGetLine</li>
--   <li>hGetContents</li>
--   <li>hGet</li>
--   <li>hGetNonBlocking</li>
--   <li>hPutStr</li>
--   </ul>
class (ListLike full item) => ListLikeIO full item | full -> item

-- | Reads a line from the specified handle
hGetLine :: ListLikeIO full item => Handle -> IO full

-- | Read entire handle contents. May be done lazily like
--   <a>hGetContents</a>.
hGetContents :: ListLikeIO full item => Handle -> IO full

-- | Read specified number of bytes. See <a>hGet</a> for particular
--   semantics.
hGet :: ListLikeIO full item => Handle -> Int -> IO full

-- | Non-blocking read. See <a>hGetNonBlocking</a> for more.
hGetNonBlocking :: ListLikeIO full item => Handle -> Int -> IO full

-- | Writing entire data.
hPutStr :: ListLikeIO full item => Handle -> full -> IO ()

-- | Write data plus newline character.
hPutStrLn :: ListLikeIO full item => Handle -> full -> IO ()

-- | Read one line
getLine :: ListLikeIO full item => IO full

-- | Read entire content from stdin. See <a>hGetContents</a>.
getContents :: ListLikeIO full item => IO full

-- | Write data to stdout.
putStr :: ListLikeIO full item => full -> IO ()

-- | Write data plus newline character to stdout.
putStrLn :: ListLikeIO full item => full -> IO ()

-- | Interact with stdin and stdout by using a function to transform input
--   to output. May be lazy. See <a>interact</a> for more.
interact :: ListLikeIO full item => (full -> full) -> IO ()

-- | Read file. May be lazy.
readFile :: ListLikeIO full item => FilePath -> IO full

-- | Write data to file.
writeFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Append data to file.
appendFile :: ListLikeIO full item => FilePath -> full -> IO ()


-- | String-like functions
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.String

-- | An extension to <a>ListLike</a> for those data types that are similar
--   to a <a>String</a>. Minimal complete definition is <a>toString</a> and
--   <a>fromString</a>.
class IsString s => StringLike s

-- | Converts the structure to a <a>String</a>
toString :: StringLike s => s -> String

-- | Breaks a string into a list of strings
lines :: (StringLike s, ListLike full s) => s -> full

-- | Breaks a string into a list of words
words :: (StringLike s, ListLike full s) => s -> full

-- | Joins lines
unlines :: (StringLike s, ListLike full s) => full -> s

-- | Joins words
unwords :: (StringLike s, ListLike full s) => full -> s

-- | Generalize the <a>Show</a> method t return any <a>StringLike</a>.
show :: (StringLike s, Show a) => a -> s

-- | <i>Deprecated: Use fromString . toString or something more efficient
--   using local knowledge</i>
fromStringLike :: (StringLike s, StringLike s') => s -> s'

-- | Override this to avoid extra <a>String</a> conversions.
fromText :: (StringLike s, StringLike Text) => Text -> s

-- | Override this to avoid extra <a>String</a> conversions.
fromLazyText :: (StringLike s, StringLike Text) => Text -> s
fromString :: IsString a => String -> a


-- | <a>ListLike</a> instances for <a>FMList</a>
module Data.ListLike.FMList
instance Data.ListLike.FoldableLL.FoldableLL (Data.FMList.FMList a) a
instance GHC.IsList.IsList (Data.FMList.FMList a)
instance Data.ListLike.Base.ListLike (Data.FMList.FMList a) a
instance Data.ListLike.Base.InfiniteListLike (Data.FMList.FMList a) a
instance Data.String.IsString (Data.FMList.FMList GHC.Types.Char)
instance Data.ListLike.String.StringLike (Data.FMList.FMList GHC.Types.Char)
instance Control.Monad.Zip.MonadZip Data.FMList.FMList


-- | <a>ListLike</a> instances for <a>DList</a>
module Data.ListLike.DList
instance Data.ListLike.FoldableLL.FoldableLL (Data.DList.Internal.DList a) a
instance Data.ListLike.Base.ListLike (Data.DList.Internal.DList a) a
instance Data.ListLike.String.StringLike (Data.DList.Internal.DList GHC.Types.Char)


-- | Newtype wrapper for ByteString to enable a Char-based interface
--   Re-exported by <a>Data.ListLike</a>.
--   
--   Written by John Lato, jwlato@gmail.com
module Data.ListLike.CharString

-- | Newtype wrapper around Data.ByteString.Char8.ByteString, this allows
--   for ListLike instances with Char elements.
newtype CharString
CS :: ByteString -> CharString
[unCS] :: CharString -> ByteString

-- | Newtype wrapper around Data.ByteString.Lazy.Char8.ByteString, this
--   allows for ListLike instances with Char elements.
newtype CharStringLazy
CSL :: ByteString -> CharStringLazy
[unCSL] :: CharStringLazy -> ByteString
instance GHC.Base.Monoid Data.ListLike.CharString.CharString
instance GHC.Base.Semigroup Data.ListLike.CharString.CharString
instance GHC.Classes.Ord Data.ListLike.CharString.CharString
instance GHC.Classes.Eq Data.ListLike.CharString.CharString
instance GHC.Show.Show Data.ListLike.CharString.CharString
instance GHC.Read.Read Data.ListLike.CharString.CharString
instance GHC.Base.Monoid Data.ListLike.CharString.CharStringLazy
instance GHC.Base.Semigroup Data.ListLike.CharString.CharStringLazy
instance GHC.Classes.Ord Data.ListLike.CharString.CharStringLazy
instance GHC.Classes.Eq Data.ListLike.CharString.CharStringLazy
instance GHC.Show.Show Data.ListLike.CharString.CharStringLazy
instance GHC.Read.Read Data.ListLike.CharString.CharStringLazy
instance Data.ListLike.FoldableLL.FoldableLL Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance GHC.IsList.IsList Data.ListLike.CharString.CharStringLazy
instance Data.ListLike.Base.ListLike Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.ListLike.CharString.CharStringLazy GHC.Types.Char
instance Data.String.IsString Data.ListLike.CharString.CharStringLazy
instance Data.ListLike.String.StringLike Data.ListLike.CharString.CharStringLazy
instance Data.ListLike.FoldableLL.FoldableLL Data.ListLike.CharString.CharString GHC.Types.Char
instance GHC.IsList.IsList Data.ListLike.CharString.CharString
instance Data.ListLike.Base.ListLike Data.ListLike.CharString.CharString GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.ListLike.CharString.CharString GHC.Types.Char
instance Data.String.IsString Data.ListLike.CharString.CharString
instance Data.ListLike.String.StringLike Data.ListLike.CharString.CharString

module Data.ListLike.Text.Text
instance Data.ListLike.FoldableLL.FoldableLL Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.Text.Internal.Text GHC.Types.Char
instance Data.ListLike.String.StringLike Data.Text.Internal.Text

module Data.ListLike.Text.TextLazy
instance Data.ListLike.FoldableLL.FoldableLL Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.Base.ListLike Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.Text.Internal.Lazy.Text GHC.Types.Char
instance Data.ListLike.String.StringLike Data.Text.Internal.Lazy.Text

module Data.ListLike.Text.Builder
instance Data.ListLike.FoldableLL.FoldableLL Data.Text.Internal.Builder.Builder GHC.Types.Char
instance GHC.IsList.IsList Data.Text.Internal.Builder.Builder
instance Data.ListLike.Base.ListLike Data.Text.Internal.Builder.Builder GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.Text.Internal.Builder.Builder GHC.Types.Char
instance Data.ListLike.String.StringLike Data.Text.Internal.Builder.Builder
instance Control.DeepSeq.NFData Data.Text.Internal.Builder.Builder

module Data.ListLike.Text

module Data.ListLike.Chars
data Chars
B :: Builder -> Chars
T :: Text -> Chars
builder :: Chars -> Builder
instance GHC.Classes.Ord Data.ListLike.Chars.Chars
instance GHC.Classes.Eq Data.ListLike.Chars.Chars
instance GHC.Show.Show Data.ListLike.Chars.Chars
instance GHC.Base.Semigroup Data.ListLike.Chars.Chars
instance GHC.Base.Monoid Data.ListLike.Chars.Chars
instance Data.String.IsString Data.ListLike.Chars.Chars
instance Data.ListLike.FoldableLL.FoldableLL Data.ListLike.Chars.Chars GHC.Types.Char
instance GHC.IsList.IsList Data.ListLike.Chars.Chars
instance Data.ListLike.Base.ListLike Data.ListLike.Chars.Chars GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO Data.ListLike.Chars.Chars GHC.Types.Char
instance Data.ListLike.String.StringLike Data.ListLike.Chars.Chars
instance Control.DeepSeq.NFData Data.ListLike.Chars.Chars


-- | Instances of <a>ListLike</a> and related classes. Re-exported by
--   <a>Data.ListLike</a>.
module Data.ListLike.UTF8
instance Data.ListLike.FoldableLL.FoldableLL (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString) GHC.Types.Char
instance GHC.IsList.IsList (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString)
instance Data.ListLike.Base.ListLike (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString) GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString) GHC.Types.Char
instance Data.ListLike.String.StringLike (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString)
instance GHC.Base.Semigroup (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString)
instance GHC.Base.Monoid (Data.String.UTF8.UTF8 Data.ByteString.Internal.Type.ByteString)
instance Data.ListLike.FoldableLL.FoldableLL (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString) GHC.Types.Char
instance GHC.IsList.IsList (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)
instance Data.ListLike.Base.ListLike (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString) GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString) GHC.Types.Char
instance Data.ListLike.String.StringLike (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)
instance GHC.Base.Semigroup (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)
instance GHC.Base.Monoid (Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)


-- | Utilities for <a>ListLike</a> and friends. More functions similar to
--   <a>List</a> but not part of the main typeclass.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Utils

-- | Returns True if all elements are True
and :: ListLike full Bool => full -> Bool

-- | Returns True if any element is True
or :: ListLike full Bool => full -> Bool

-- | The sum of the list
sum :: (Num a, ListLike full a) => full -> a

-- | The product of the list
product :: (Num a, ListLike full a) => full -> a

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Converts a list of pairs into two separate lists of elements
unzip :: (ListLike full (itema, itemb), ListLike ra itema, ListLike rb itemb) => full -> (ra, rb)

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | Converts to a MonadPlus instance
toMonadPlus :: (MonadPlus m, ListLike full a) => full -> m (a, full)

-- | List-like destructor (like Data.Maybe.maybe)
list :: ListLike full a => b -> (a -> full -> b) -> full -> b

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
intercalate :: (ListLike a item, ListLike b a) => a -> b -> a


-- | ListLike instance for any type supporting the
--   <tt>Data.Vector.Generic</tt> interface. To avoid collisions with other
--   Vector instances, this module must be imported directly.
module Data.ListLike.Vector.Generic
instance Data.Vector.Generic.Base.Vector v a => Data.ListLike.FoldableLL.FoldableLL (v a) a
instance (GHC.IsList.IsList (v a), GHC.IsList.Item (v a) GHC.Types.~ a, GHC.Base.Monoid (v a), GHC.Classes.Eq (v a), Data.Vector.Generic.Base.Vector v a) => Data.ListLike.Base.ListLike (v a) a
instance (GHC.Classes.Eq (v GHC.Types.Char), Data.Vector.Generic.Base.Vector v GHC.Types.Char) => Data.String.IsString (v GHC.Types.Char)
instance (GHC.Classes.Eq (v GHC.Types.Char), Data.Vector.Generic.Base.Vector v GHC.Types.Char) => Data.ListLike.String.StringLike (v GHC.Types.Char)

module Data.ListLike.Vector.Storable
instance Foreign.Storable.Storable a => Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Storable.Vector a) a
instance Foreign.Storable.Storable a => Data.ListLike.Base.ListLike (Data.Vector.Storable.Vector a) a
instance Data.String.IsString (Data.Vector.Storable.Vector GHC.Types.Char)
instance Data.ListLike.String.StringLike (Data.Vector.Storable.Vector GHC.Types.Char)

module Data.ListLike.Vector.Unboxed
instance Data.Vector.Unboxed.Base.Unbox a => Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Unboxed.Base.Vector a) a
instance Data.Vector.Unboxed.Base.Unbox a => Data.ListLike.Base.ListLike (Data.Vector.Unboxed.Base.Vector a) a
instance Data.String.IsString (Data.Vector.Unboxed.Base.Vector GHC.Types.Char)
instance Data.ListLike.String.StringLike (Data.Vector.Unboxed.Base.Vector GHC.Types.Char)

module Data.ListLike.Vector.Vector
instance Data.ListLike.FoldableLL.FoldableLL (Data.Vector.Vector a) a
instance Data.ListLike.Base.ListLike (Data.Vector.Vector a) a
instance Data.String.IsString (Data.Vector.Vector GHC.Types.Char)
instance Data.ListLike.String.StringLike (Data.Vector.Vector GHC.Types.Char)


-- | <a>ListLike</a> instances for several <tt>Data.Vector</tt> types. The
--   <tt>Data.ListLike.Vector.Generic</tt> instances are not exported from
--   this module in order to prevent collisions.
module Data.ListLike.Vector


-- | Instances of <a>ListLike</a> and related classes. Re-exported by
--   <a>Data.ListLike</a>.
--   
--   Written by John Goerzen, jgoerzen@complete.org
module Data.ListLike.Instances
instance Data.ListLike.IO.ListLikeIO GHC.Base.String GHC.Types.Char
instance Data.ListLike.String.StringLike GHC.Base.String
instance Data.ListLike.Base.InfiniteListLike [a] a
instance Data.ListLike.FoldableLL.FoldableLL Data.ByteString.Internal.Type.ByteString GHC.Word.Word8
instance Data.ListLike.Base.ListLike Data.ByteString.Internal.Type.ByteString GHC.Word.Word8
instance Data.ListLike.IO.ListLikeIO Data.ByteString.Internal.Type.ByteString GHC.Word.Word8
instance Data.ListLike.FoldableLL.FoldableLL Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.Base.ListLike Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance Data.ListLike.IO.ListLikeIO Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance GHC.Ix.Ix i => Data.ListLike.FoldableLL.FoldableLL (GHC.Arr.Array i e) e
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => GHC.Base.Semigroup (GHC.Arr.Array i e)
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => GHC.Base.Monoid (GHC.Arr.Array i e)
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => GHC.IsList.IsList (GHC.Arr.Array i e)
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => Data.ListLike.Base.ListLike (GHC.Arr.Array i e) e
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => Data.String.IsString (GHC.Arr.Array i GHC.Types.Char)
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => Data.ListLike.String.StringLike (GHC.Arr.Array i GHC.Types.Char)
instance (GHC.Real.Integral i, GHC.Ix.Ix i) => Data.ListLike.IO.ListLikeIO (GHC.Arr.Array i GHC.Types.Char) GHC.Types.Char
instance Data.ListLike.IO.ListLikeIO (Data.Sequence.Internal.Seq GHC.Types.Char) GHC.Types.Char
instance Data.ListLike.String.StringLike (Data.Sequence.Internal.Seq GHC.Types.Char)
instance Data.ListLike.FoldableLL.FoldableLL (Data.Sequence.Internal.Seq a) a
instance Data.ListLike.Base.ListLike (Data.Sequence.Internal.Seq a) a


-- | Generic operations over list-like structures
--   
--   Written by John Goerzen, jgoerzen@complete.org
--   
--   Please start with the introduction at <a>Data.ListLike#intro</a>.
module Data.ListLike

-- | The empty list
empty :: ListLike full item => full

-- | Creates a single-element list out of an element
singleton :: ListLike full item => item -> full

-- | Like (:) for lists: adds an element to the beginning of a list
cons :: ListLike full item => item -> full -> full

-- | Adds an element to the *end* of a <a>ListLike</a>.
snoc :: ListLike full item => full -> item -> full

-- | Combines two lists. Like (++).
append :: ListLike full item => full -> full -> full

-- | Extract head and tail, return Nothing if empty
uncons :: ListLike full item => full -> Maybe (item, full)

-- | Extracts the first element of a <a>ListLike</a>.
head :: ListLike full item => full -> item

-- | Extracts the last element of a <a>ListLike</a>.
last :: ListLike full item => full -> item

-- | Gives all elements after the head.
tail :: ListLike full item => full -> full

-- | All elements of the list except the last one. See also <a>inits</a>.
init :: ListLike full item => full -> full

-- | Tests whether the list is empty.
null :: ListLike full item => full -> Bool

-- | Length of the list. See also <a>genericLength</a>.
length :: ListLike full item => full -> Int

-- | Apply a function to each element, returning any other valid
--   <a>ListLike</a>. <a>rigidMap</a> will always be at least as fast, if
--   not faster, than this function and is recommended if it will work for
--   your purposes. See also <a>mapM</a>.
map :: (ListLike full item, ListLike full' item') => (item -> item') -> full -> full'

-- | Like <a>map</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits for things such as
--   ByteStrings, since it will let the ByteString use its native low-level
--   map implementation.
rigidMap :: ListLike full item => (item -> item) -> full -> full

-- | Reverse the elements in a list.
reverse :: ListLike full item => full -> full

-- | Add an item between each element in the structure
intersperse :: ListLike full item => item -> full -> full

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | Converts one ListLike to another. See also <a>toList'</a>. Default
--   implementation is <tt>fromListLike = map id</tt>
fromListLike :: (ListLike full item, ListLike full' item) => full -> full'

-- | Left-associative fold
foldl :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | Strict version of <a>foldl</a>.
foldl' :: FoldableLL full item => (a -> item -> a) -> a -> full -> a

-- | A variant of <a>foldl</a> with no base case. Requires at least 1 list
--   element.
foldl1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Right-associative fold
foldr :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Strict version of <a>foldr</a>
foldr' :: FoldableLL full item => (item -> b -> b) -> b -> full -> b

-- | Like <a>foldr</a>, but with no starting value
foldr1 :: FoldableLL full item => (item -> item -> item) -> full -> item

-- | Flatten the structure.
concat :: (ListLike full item, ListLike full' full) => full' -> full

-- | Map a function over the items and concatenate the results. See also
--   <a>rigidConcatMap</a>.
concatMap :: (ListLike full item, ListLike full' item') => (item -> full') -> full -> full'

-- | Like <a>concatMap</a>, but without the possibility of changing the
--   type of the item. This can have performance benefits for some things
--   such as ByteString.
rigidConcatMap :: ListLike full item => (item -> full) -> full -> full

-- | Returns True if all elements are True
and :: ListLike full Bool => full -> Bool

-- | Returns True if any element is True
or :: ListLike full Bool => full -> Bool

-- | True if any items satisfy the function
any :: ListLike full item => (item -> Bool) -> full -> Bool

-- | True if all items satisfy the function
all :: ListLike full item => (item -> Bool) -> full -> Bool

-- | The sum of the list
sum :: (Num a, ListLike full a) => full -> a

-- | The product of the list
product :: (Num a, ListLike full a) => full -> a

-- | The maximum value of the list
maximum :: (ListLike full item, Ord item) => full -> item

-- | The minimum value of the list
minimum :: (ListLike full item, Ord item) => full -> item

-- | Combine the elements of a structure using a monoid. <tt><a>fold</a> =
--   <a>foldMap</a> id</tt>
fold :: (FoldableLL full item, Monoid item) => full -> item

-- | Map each element to a monoid, then combine the results
foldMap :: (FoldableLL full item, Monoid m) => (item -> m) -> full -> m

-- | An infinite list of repeated calls of the function to args
iterate :: InfiniteListLike full item => (item -> item) -> item -> full

-- | An infinite list where each element is the same
repeat :: InfiniteListLike full item => item -> full

-- | Generate a structure with the specified length with every element set
--   to the item passed in. See also <a>genericReplicate</a>
replicate :: ListLike full item => Int -> item -> full

-- | Converts a finite list into a circular one
cycle :: InfiniteListLike full item => full -> full

-- | Takes the first n elements of the list. See also <a>genericTake</a>.
take :: ListLike full item => Int -> full -> full

-- | Drops the first n elements of the list. See also <a>genericDrop</a>
drop :: ListLike full item => Int -> full -> full

-- | Equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>. See also
--   <a>genericSplitAt</a>.
splitAt :: ListLike full item => Int -> full -> (full, full)

-- | Returns all elements at start of list that satisfy the function.
takeWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the start of the list that satisfy the
--   function.
dropWhile :: ListLike full item => (item -> Bool) -> full -> full

-- | Drops all elements from the end of the list that satisfy the function.
dropWhileEnd :: ListLike full item => (item -> Bool) -> full -> full

-- | The equivalent of <tt>(<a>takeWhile</a> f xs, <a>dropWhile</a> f
--   xs)</tt>
span :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The equivalent of <tt><a>span</a> (<a>not</a> . f)</tt>
break :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | Split a list into sublists, each which contains equal arguments. For
--   order-preserving types, concatenating these sublists will produce the
--   original list. See also <a>groupBy</a>.
group :: (ListLike full item, ListLike full' full, Eq item) => full -> full'

-- | All initial segments of the list, shortest first
inits :: (ListLike full item, ListLike full' full) => full -> full'

-- | All final segnemts, longest first
tails :: (ListLike full item, ListLike full' full) => full -> full'

-- | True when the first list is at the beginning of the second.
isPrefixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is at the beginning of the second.
isSuffixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | True when the first list is wholly containted within the second
isInfixOf :: (ListLike full item, Eq item) => full -> full -> Bool

-- | Remove a prefix from a listlike if possible
stripPrefix :: (ListLike full item, Eq item) => full -> full -> Maybe full

-- | Remove a suffix from a listlike if possible
stripSuffix :: (ListLike full item, Eq item) => full -> full -> Maybe full

-- | True if the item occurs in the list
elem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | True if the item does not occur in the list
notElem :: (ListLike full item, Eq item) => item -> full -> Bool

-- | Take a function and return the first matching element, or Nothing if
--   there is no such element.
find :: ListLike full item => (item -> Bool) -> full -> Maybe item

-- | Returns only the elements that satisfy the function.
filter :: ListLike full item => (item -> Bool) -> full -> full

-- | Returns the lists that do and do not satisfy the function. Same as
--   <tt>(<a>filter</a> p xs, <a>filter</a> (<a>not</a> . p) xs)</tt>
partition :: ListLike full item => (item -> Bool) -> full -> (full, full)

-- | The element at 0-based index i. Raises an exception if i is out of
--   bounds. Like (!!) for lists.
index :: ListLike full item => full -> Int -> item

-- | Returns the index of the element, if it exists.
elemIndex :: (ListLike full item, Eq item) => item -> full -> Maybe Int

-- | Returns the indices of the matching elements. See also
--   <a>findIndices</a>
elemIndices :: (ListLike full item, Eq item, ListLike result Int) => item -> full -> result

-- | Take a function and return the index of the first matching element, or
--   Nothing if no element matches
findIndex :: ListLike full item => (item -> Bool) -> full -> Maybe Int

-- | Returns the indices of all elements satisfying the function
findIndices :: (ListLike full item, ListLike result Int) => (item -> Bool) -> full -> result

-- | Takes two lists and returns a list of corresponding pairs.
zip :: (ListLike full item, ListLike fullb itemb, ListLike result (item, itemb)) => full -> fullb -> result

-- | Takes two lists and combines them with a custom combining function
zipWith :: (ListLike full item, ListLike fullb itemb, ListLike result resultitem) => (item -> itemb -> resultitem) -> full -> fullb -> result

-- | Converts a list of pairs into two separate lists of elements
unzip :: (ListLike full (itema, itemb), ListLike ra itema, ListLike rb itemb) => full -> (ra, rb)

-- | Evaluate each action in the sequence and collect the results
sequence :: (ListLike full item, Applicative m, ListLike fullinp (m item)) => fullinp -> m full

-- | Evaluate each action, ignoring the results. Same as <tt><a>mapM_</a>
--   <a>id</a></tt>.
sequence_ :: (Monad m, FoldableLL full (m item)) => full -> m ()

-- | A map in monad space. Same as <tt><a>sequence</a> . <a>map</a></tt>
--   
--   See also <a>rigidMapM</a>
mapM :: (ListLike full item, Applicative m, ListLike full' item') => (item -> m item') -> full -> m full'

-- | Like <a>mapM</a>, but without the possibility of changing the type of
--   the item. This can have performance benefits with some types.
rigidMapM :: (ListLike full item, Monad m) => (item -> m item) -> full -> m full

-- | A map in monad space, discarding results.
mapM_ :: (Monad m, FoldableLL full item) => (item -> m b) -> full -> m ()

-- | An extension to <a>ListLike</a> for those data types that support I/O.
--   These functions mirror those in <a>System.IO</a> for the most part.
--   They also share the same names; see the comments in
--   <a>Data.ListLike</a> for help importing them.
--   
--   Note that some types may not be capable of lazy reading or writing.
--   Therefore, the usual semantics of <a>System.IO</a> functions regarding
--   laziness may or may not be available from a particular implementation.
--   
--   Minimal complete definition:
--   
--   <ul>
--   <li>hGetLine</li>
--   <li>hGetContents</li>
--   <li>hGet</li>
--   <li>hGetNonBlocking</li>
--   <li>hPutStr</li>
--   </ul>
class (ListLike full item) => ListLikeIO full item | full -> item

-- | Reads a line from the specified handle
hGetLine :: ListLikeIO full item => Handle -> IO full

-- | Read entire handle contents. May be done lazily like
--   <a>hGetContents</a>.
hGetContents :: ListLikeIO full item => Handle -> IO full

-- | Read specified number of bytes. See <a>hGet</a> for particular
--   semantics.
hGet :: ListLikeIO full item => Handle -> Int -> IO full

-- | Non-blocking read. See <a>hGetNonBlocking</a> for more.
hGetNonBlocking :: ListLikeIO full item => Handle -> Int -> IO full

-- | Writing entire data.
hPutStr :: ListLikeIO full item => Handle -> full -> IO ()

-- | Write data plus newline character.
hPutStrLn :: ListLikeIO full item => Handle -> full -> IO ()

-- | Read one line
getLine :: ListLikeIO full item => IO full

-- | Read entire content from stdin. See <a>hGetContents</a>.
getContents :: ListLikeIO full item => IO full

-- | Write data to stdout.
putStr :: ListLikeIO full item => full -> IO ()

-- | Write data plus newline character to stdout.
putStrLn :: ListLikeIO full item => full -> IO ()

-- | Interact with stdin and stdout by using a function to transform input
--   to output. May be lazy. See <a>interact</a> for more.
interact :: ListLikeIO full item => (full -> full) -> IO ()

-- | Read file. May be lazy.
readFile :: ListLikeIO full item => FilePath -> IO full

-- | Write data to file.
writeFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Append data to file.
appendFile :: ListLikeIO full item => FilePath -> full -> IO ()

-- | Converts the structure to a <a>String</a>
toString :: StringLike s => s -> String
fromString :: IsString a => String -> a

-- | Breaks a string into a list of strings
lines :: (StringLike s, ListLike full s) => s -> full

-- | Breaks a string into a list of words
words :: (StringLike s, ListLike full s) => s -> full

-- | Generalize the <a>Show</a> method t return any <a>StringLike</a>.
show :: (StringLike s, Show a) => a -> s

-- | <i>Deprecated: Use fromString . toString or something more efficient
--   using local knowledge</i>
fromStringLike :: (StringLike s, StringLike s') => s -> s'

-- | Override this to avoid extra <a>String</a> conversions.
fromText :: (StringLike s, StringLike Text) => Text -> s

-- | Override this to avoid extra <a>String</a> conversions.
fromLazyText :: (StringLike s, StringLike Text) => Text -> s

-- | Removes duplicate elements from the list. See also <a>nubBy</a>
nub :: (ListLike full item, Eq item) => full -> full

-- | Removes the first instance of the element from the list. See also
--   <a>deleteBy</a>
delete :: (ListLike full item, Eq item) => item -> full -> full

-- | List difference. Removes from the first list the first instance of
--   each element of the second list. See <tt>(\\)</tt> and
--   <a>deleteFirstsBy</a>
deleteFirsts :: (ListLike full item, Eq item) => full -> full -> full

-- | List union: the set of elements that occur in either list. Duplicate
--   elements in the first list will remain duplicate. See also
--   <a>unionBy</a>.
union :: (ListLike full item, Eq item) => full -> full -> full

-- | List intersection: the set of elements that occur in both lists. See
--   also <a>intersectBy</a>
intersect :: (ListLike full item, Eq item) => full -> full -> full

-- | Sorts the list. On data types that do not preserve ordering, or
--   enforce their own ordering, the result may not be what you expect. See
--   also <a>sortBy</a>.
sort :: (ListLike full item, Ord item) => full -> full

-- | Inserts the element at the last place where it is still less than or
--   equal to the next element. On data types that do not preserve
--   ordering, or enforce their own ordering, the result may not be what
--   you expect. On types such as maps, this may result in changing an
--   existing item. See also <a>insertBy</a>.
insert :: (ListLike full item, Ord item) => item -> full -> full

-- | Generic version of <a>nub</a>
nubBy :: ListLike full item => (item -> item -> Bool) -> full -> full

-- | Generic version of <a>deleteBy</a>
deleteBy :: ListLike full item => (item -> item -> Bool) -> item -> full -> full

-- | Generic version of <a>deleteFirsts</a>
deleteFirstsBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>union</a>
unionBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>intersect</a>
intersectBy :: ListLike full item => (item -> item -> Bool) -> full -> full -> full

-- | Generic version of <a>group</a>.
groupBy :: (ListLike full item, ListLike full' full, Eq item) => (item -> item -> Bool) -> full -> full'

-- | Sort function taking a custom comparison function
sortBy :: ListLike full item => (item -> item -> Ordering) -> full -> full

-- | Like <a>insert</a>, but with a custom comparison function
insertBy :: ListLike full item => (item -> item -> Ordering) -> item -> full -> full

-- | Length of the list
genericLength :: (ListLike full item, Num a) => full -> a

-- | Generic version of <a>take</a>
genericTake :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>drop</a>
genericDrop :: (ListLike full item, Integral a) => a -> full -> full

-- | Generic version of <a>splitAt</a>
genericSplitAt :: (ListLike full item, Integral a) => a -> full -> (full, full)

-- | Generic version of <a>replicate</a>
genericReplicate :: (ListLike full item, Integral a) => a -> item -> full
data Chars
B :: Builder -> Chars
T :: Text -> Chars

-- | Newtype wrapper around Data.ByteString.Char8.ByteString, this allows
--   for ListLike instances with Char elements.
newtype CharString
CS :: ByteString -> CharString
[unCS] :: CharString -> ByteString

-- | Newtype wrapper around Data.ByteString.Lazy.Char8.ByteString, this
--   allows for ListLike instances with Char elements.
newtype CharStringLazy
CSL :: ByteString -> CharStringLazy
[unCSL] :: CharStringLazy -> ByteString

-- | The class implementing list-like functions.
--   
--   It is worth noting that types such as <a>Map</a> can be instances of
--   <a>ListLike</a>. Due to their specific ways of operating, they may not
--   behave in the expected way in some cases. For instance, <a>cons</a>
--   may not increase the size of a map if the key you have given is
--   already in the map; it will just replace the value already there.
--   
--   Implementators must define at least:
--   
--   <ul>
--   <li>singleton</li>
--   <li>head</li>
--   <li>tail</li>
--   <li>null or genericLength</li>
--   </ul>
class (IsList full, item ~ Item full, FoldableLL full item, Monoid full) => ListLike full item | full -> item

-- | A version of <a>ListLike</a> with a single type parameter, the item
--   type is obtained using the <a>Item</a> type function from
--   <a>IsList</a>.
type ListOps full = (ListLike full (Item full))

-- | This is the primary class for structures that are to be considered
--   foldable. A minimum complete definition provides <a>foldl</a> and
--   <a>foldr</a>.
--   
--   Instances of <a>FoldableLL</a> can be folded, and can be many and
--   varied.
--   
--   These functions are used heavily in <a>Data.ListLike</a>.
class FoldableLL full item | full -> item

-- | An extension to <a>ListLike</a> for those data types that are similar
--   to a <a>String</a>. Minimal complete definition is <a>toString</a> and
--   <a>fromString</a>.
class IsString s => StringLike s

-- | An extension to <a>ListLike</a> for those data types that are capable
--   of dealing with infinite lists. Some <a>ListLike</a> functions are
--   capable of working with finite or infinite lists. The functions here
--   require infinite list capability in order to work at all.
class (ListLike full item) => InfiniteListLike full item | full -> item
