<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="annot"><span class="hs-comment">{-|
Module: Text.Regex.TDFA
Copyright: (c) Chris Kuklewicz 2007-2009
SPDX-License-Identifier: BSD-3-Clause
Maintainer: Andreas Abel
Stability: stable

The &quot;Text.Regex.TDFA&quot; module provides a backend for regular
expressions. It provides instances for the classes defined and
documented in &quot;Text.Regex.Base&quot; and re-exported by this module.  If
you import this along with other backends then you should do so with
qualified imports (with renaming for convenience).

This regex-tdfa package implements, correctly, POSIX extended regular
expressions.  It is highly unlikely that the @regex-posix@ package on
your operating system is correct, see
&lt;http://www.haskell.org/haskellwiki/Regex_Posix&gt; for examples of your
OS's bugs.

= Importing and using

Declare a dependency on the @regex-tdfa@ library in your @.cabal@ file:

&gt; build-depends: regex-tdfa ^&gt;= 1.3.2

In Haskell modules where you want to use regexes simply @import@ /this/ module:

@
import &quot;Text.Regex.TDFA&quot;
@

= Basics

&gt;&gt;&gt; let emailRegex = &quot;[a-zA-Z0-9+._-]+\\@[-a-zA-Z]+\\.[a-z]+&quot;
&gt;&gt;&gt; &quot;my email is first-name.lastname_1974@e-mail.com&quot; =~ emailRegex :: Bool
True

&gt;&gt;&gt; &quot;invalid@mail@com&quot; =~ emailRegex :: Bool
False

&gt;&gt;&gt; &quot;invalid@mail.COM&quot; =~ emailRegex :: Bool
False

&gt;&gt;&gt; &quot;#@invalid.com&quot; =~ emailRegex :: Bool
False

@
/-- non-monadic/
&#955;&gt; \&lt;to-match-against\&gt; '=~' \&lt;regex\&gt;

/-- monadic, uses 'fail' on lack of match/
&#955;&gt; \&lt;to-match-against\&gt; '=~~' \&lt;regex\&gt;
@

('=~') and ('=~~') are polymorphic in their return type. This is so that
regex-tdfa can pick the most efficient way to give you your result based on
what you need. For instance, if all you want is to check whether the regex
matched or not, there's no need to allocate a result string. If you only want
the first match, rather than all the matches, then the matching engine can stop
after finding a single hit.

This does mean, though, that you may sometimes have to explicitly specify the
type you want, especially if you're trying things out at the REPL.

= Common use cases

== Get the first match

@
/-- returns empty string if no match/
a '=~' b :: String  /-- or ByteString, or Text.../
@

&gt;&gt;&gt; &quot;alexis-de-tocqueville&quot; =~ &quot;[a-z]+&quot; :: String
&quot;alexis&quot;

&gt;&gt;&gt; &quot;alexis-de-tocqueville&quot; =~ &quot;[0-9]+&quot; :: String
&quot;&quot;

== Check if it matched at all

@
a '=~' b :: Bool
@

&gt;&gt;&gt; &quot;alexis-de-tocqueville&quot; =~ &quot;[a-z]+&quot; :: Bool
True

== Get first match + text before/after

@
/-- if no match, will just return whole/
/-- string in the first element of the tuple/
a =~ b :: (String, String, String)
@

&gt;&gt;&gt; &quot;alexis-de-tocqueville&quot; =~ &quot;de&quot; :: (String, String, String)
(&quot;alexis-&quot;,&quot;de&quot;,&quot;-tocqueville&quot;)

&gt;&gt;&gt; &quot;alexis-de-tocqueville&quot; =~ &quot;kant&quot; :: (String, String, String)
(&quot;alexis-de-tocqueville&quot;,&quot;&quot;,&quot;&quot;)

== Get first match + submatches

@
/-- same as above, but also returns a list of just submatches./
/-- submatch list is empty if regex doesn't match at all/
a '=~' b :: (String, String, String, [String])
@

&gt;&gt;&gt; &quot;div[attr=1234]&quot; =~ &quot;div\\[([a-z]+)=([^]]+)\\]&quot; :: (String, String, String, [String])
(&quot;&quot;,&quot;div[attr=1234]&quot;,&quot;&quot;,[&quot;attr&quot;,&quot;1234&quot;])

== Get /all/ matches

@
/-- can also return Data.Array instead of List/
'getAllTextMatches' (a '=~' b) :: [String]
@

&gt;&gt;&gt; getAllTextMatches (&quot;john anne yifan&quot; =~ &quot;[a-z]+&quot;) :: [String]
[&quot;john&quot;,&quot;anne&quot;,&quot;yifan&quot;]

&gt;&gt;&gt; getAllTextMatches (&quot;* - . a + z&quot; =~ &quot;[--z]+&quot;) :: [String]
[&quot;-&quot;,&quot;.&quot;,&quot;a&quot;,&quot;z&quot;]

= Feature support

This package does provide captured parenthesized subexpressions.

Depending on the text being searched this package supports Unicode.
The @[Char]@, @Text@, @Text.Lazy@, and @(Seq Char)@ text types support Unicode.  The @ByteString@
and @ByteString.Lazy@ text types only support ASCII.

As of version 1.1.1 the following GNU extensions are recognized, all
anchors:

* \\\` at beginning of entire text
* \\\' at end of entire text
* \\\&lt; at beginning of word
* \\\&gt; at end of word
* \\b at either beginning or end of word
* \\B at neither beginning nor end of word

The above are controlled by the 'newSyntax' Bool in 'CompOption'.

Where the &quot;word&quot; boundaries means between characters that are and are
not in the [:word:] character class which contains [a-zA-Z0-9_].  Note
that \\\&lt; and \\b may match before the entire text and \\\&gt; and \\b may
match at the end of the entire text.

There is no locale support, so collating elements like [.ch.] are
simply ignored and equivalence classes like [=a=] are converted to
just [a].  The character classes like [:alnum:] are supported over
ASCII only, valid classes are alnum, digit, punct, alpha, graph,
space, blank, lower, upper, cntrl, print, xdigit, word.

&gt;&gt;&gt; getAllTextMatches (&quot;john anne yifan&quot; =~ &quot;[[:lower:]]+&quot;) :: [String]
[&quot;john&quot;,&quot;anne&quot;,&quot;yifan&quot;]


This package does not provide &quot;basic&quot; regular expressions.  This
package does not provide back references inside regular expressions.

The package does not provide Perl style regular expressions.  Please
look at the &lt;http://hackage.haskell.org/package/regex-pcre regex-pcre&gt;
and &lt;http://hackage.haskell.org/package/pcre-light pcre-light&gt; packages instead.

This package does not provide find-and-replace.

= Avoiding backslashes

If you find yourself writing a lot of regexes, take a look at
&lt;http://hackage.haskell.org/package/raw-strings-qq raw-strings-qq&gt;. It'll
let you write regexes without needing to escape all your backslashes.

@
\{\-\# LANGUAGE QuasiQuotes \#\-\}

import Text.RawString.QQ
import Text.Regex.TDFA

&#955;&gt; &quot;2 * (3 + 1) / 4&quot; '=~' [r|\\([^)]+\\)|] :: String
&quot;(3 + 1)&quot;
@

-}</span></span><span>
</span><span id="line-188"></span><span>
</span><span id="line-189"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Regex.TDFA</span><span class="hs-special">(</span><span class="annot"><a href="Text.Regex.TDFA.html#getVersion_Text_Regex_TDFA"><span class="hs-identifier">getVersion_Text_Regex_TDFA</span></a></span><span>
</span><span id="line-190"></span><span>                      </span><span class="hs-special">,</span><span class="annot"><a href="Text.Regex.TDFA.html#%3D~"><span class="hs-operator">(=~)</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Text.Regex.TDFA.html#%3D~~"><span class="hs-operator">(=~~)</span></a></span><span>
</span><span id="line-191"></span><span>                      </span><span class="hs-special">,</span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html"><span class="hs-identifier">Text.Regex.TDFA.Common</span></a></span><span>
</span><span id="line-192"></span><span>                      </span><span class="hs-special">,</span><span class="hs-keyword">module</span><span> </span><span class="annot"><span class="hs-identifier">Text.Regex.Base</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Fail</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Fail</span></span><span>
</span><span id="line-195"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Version</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Version</span></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Text.Regex.Base</span></span><span>
</span><span id="line-197"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.String.html"><span class="hs-identifier">Text.Regex.TDFA.String</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.ByteString.html"><span class="hs-identifier">Text.Regex.TDFA.ByteString</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.ByteString.Lazy.html"><span class="hs-identifier">Text.Regex.TDFA.ByteString.Lazy</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Text.html"><span class="hs-identifier">Text.Regex.TDFA.Text</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Text.Lazy.html"><span class="hs-identifier">Text.Regex.TDFA.Text.Lazy</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-202"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Sequence.html"><span class="hs-identifier">Text.Regex.TDFA.Sequence</span></a></span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html"><span class="hs-identifier">Text.Regex.TDFA.Common</span></a></span><span class="hs-special">(</span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier">Regex</span></a></span><span class="hs-special">,</span><span class="annot"><a href="Text.Regex.TDFA.Common.html#CompOption"><span class="hs-identifier">CompOption</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span class="annot"><a href="Text.Regex.TDFA.Common.html#ExecOption"><span class="hs-identifier">ExecOption</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-204"></span><span class="hs-comment">--import Text.Regex.TDFA.Wrap(Regex,CompOption(..),ExecOption(..),(=~),(=~~))</span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Paths_regex_tdfa.html"><span class="hs-identifier">Paths_regex_tdfa</span></a></span><span class="hs-special">(</span><span class="annot"><a href="Paths_regex_tdfa.html#version"><span class="hs-identifier">version</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span>
</span><span id="line-208"></span><span class="annot"><a href="Text.Regex.TDFA.html#getVersion_Text_Regex_TDFA"><span class="hs-identifier hs-type">getVersion_Text_Regex_TDFA</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Version</span></span><span>
</span><span id="line-209"></span><span id="getVersion_Text_Regex_TDFA"><span class="annot"><span class="annottext">getVersion_Text_Regex_TDFA :: Version
</span><a href="Text.Regex.TDFA.html#getVersion_Text_Regex_TDFA"><span class="hs-identifier hs-var hs-var">getVersion_Text_Regex_TDFA</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Version
</span><a href="Paths_regex_tdfa.html#version"><span class="hs-identifier hs-var">version</span></a></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span>
</span><span id="line-212"></span><span class="hs-comment">-- | This is the pure functional matching operator.  If the target</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- cannot be produced then some empty result will be returned.  If</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- there is an error in processing, then 'error' will be called.</span><span>
</span><span id="line-215"></span><span id="local-6989586621679115846"><span id="local-6989586621679115848"><span id="local-6989586621679115849"><span class="annot"><a href="Text.Regex.TDFA.html#%3D~"><span class="hs-operator hs-type">(=~)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">RegexMaker</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#CompOption"><span class="hs-identifier hs-type">CompOption</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#ExecOption"><span class="hs-identifier hs-type">ExecOption</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115846"><span class="hs-identifier hs-type">source</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">RegexContext</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115848"><span class="hs-identifier hs-type">source1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115849"><span class="hs-identifier hs-type">target</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115848"><span class="hs-identifier hs-type">source1</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115846"><span class="hs-identifier hs-type">source</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115849"><span class="hs-identifier hs-type">target</span></a></span></span></span></span><span>
</span><span id="line-217"></span><span id="%3D~"><span class="annot"><span class="annottext">=~ :: forall source source1 target.
(RegexMaker Regex CompOption ExecOption source,
 RegexContext Regex source1 target) =&gt;
source1 -&gt; source -&gt; target
</span><a href="Text.Regex.TDFA.html#%3D~"><span class="hs-operator hs-var hs-var">(=~)</span></a></span></span><span> </span><span id="local-6989586621679115890"><span class="annot"><span class="annottext">source1
</span><a href="#local-6989586621679115890"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679115891"><span class="annot"><span class="annottext">source
</span><a href="#local-6989586621679115891"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679115854"><span class="annot"><a href="#local-6989586621679115892"><span class="hs-identifier hs-type">make</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RegexMaker</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#CompOption"><span class="hs-identifier hs-type">CompOption</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#ExecOption"><span class="hs-identifier hs-type">ExecOption</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115854"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115854"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span></span><span>
</span><span id="line-218"></span><span>               </span><span id="local-6989586621679115892"><span class="annot"><span class="annottext">make :: forall a. RegexMaker Regex CompOption ExecOption a =&gt; a -&gt; Regex
</span><a href="#local-6989586621679115892"><span class="hs-identifier hs-var hs-var">make</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Regex
forall regex compOpt execOpt source.
RegexMaker regex compOpt execOpt source =&gt;
source -&gt; regex
</span><span class="hs-identifier hs-var">makeRegex</span></span><span>
</span><span id="line-219"></span><span>           </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Regex -&gt; source1 -&gt; target
forall regex source target.
RegexContext regex source target =&gt;
regex -&gt; source -&gt; target
</span><span class="hs-identifier hs-var">match</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">source -&gt; Regex
forall a. RegexMaker Regex CompOption ExecOption a =&gt; a -&gt; Regex
</span><a href="#local-6989586621679115892"><span class="hs-identifier hs-var">make</span></a></span><span> </span><span class="annot"><span class="annottext">source
</span><a href="#local-6989586621679115891"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">source1
</span><a href="#local-6989586621679115890"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="hs-comment">-- | This is the monadic matching operator.  If a single match fails,</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- then 'fail' will be called.</span><span>
</span><span id="line-223"></span><span id="local-6989586621679115863"><span id="local-6989586621679115864"><span id="local-6989586621679115865"><span id="local-6989586621679115866"><span class="annot"><a href="Text.Regex.TDFA.html#%3D~~"><span class="hs-operator hs-type">(=~~)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">RegexMaker</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#CompOption"><span class="hs-identifier hs-type">CompOption</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#ExecOption"><span class="hs-identifier hs-type">ExecOption</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115863"><span class="hs-identifier hs-type">source</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">RegexContext</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115864"><span class="hs-identifier hs-type">source1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115865"><span class="hs-identifier hs-type">target</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679115866"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-224"></span><span>      </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115864"><span class="hs-identifier hs-type">source1</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115863"><span class="hs-identifier hs-type">source</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115866"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115865"><span class="hs-identifier hs-type">target</span></a></span></span></span></span></span><span>
</span><span id="line-225"></span><span id="%3D~~"><span class="annot"><span class="annottext">=~~ :: forall source source1 target (m :: * -&gt; *).
(RegexMaker Regex CompOption ExecOption source,
 RegexContext Regex source1 target, MonadFail m) =&gt;
source1 -&gt; source -&gt; m target
</span><a href="Text.Regex.TDFA.html#%3D~~"><span class="hs-operator hs-var hs-var">(=~~)</span></a></span></span><span> </span><span id="local-6989586621679115907"><span class="annot"><span class="annottext">source1
</span><a href="#local-6989586621679115907"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679115908"><span class="annot"><span class="annottext">source
</span><a href="#local-6989586621679115908"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679115872"><span id="local-6989586621679115873"><span class="annot"><a href="#local-6989586621679115909"><span class="hs-identifier hs-type">make</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">RegexMaker</span></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#CompOption"><span class="hs-identifier hs-type">CompOption</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#ExecOption"><span class="hs-identifier hs-type">ExecOption</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679115872"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="annot"><a href="#local-6989586621679115873"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115872"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679115873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="Text.Regex.TDFA.Common.html#Regex"><span class="hs-identifier hs-type">Regex</span></a></span></span></span><span>
</span><span id="line-226"></span><span>                   </span><span id="local-6989586621679115909"><span class="annot"><span class="annottext">make :: forall a (m :: * -&gt; *).
(RegexMaker Regex CompOption ExecOption a, MonadFail m) =&gt;
a -&gt; m Regex
</span><a href="#local-6989586621679115909"><span class="hs-identifier hs-var hs-var">make</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Regex
forall regex compOpt execOpt source (m :: * -&gt; *).
(RegexMaker regex compOpt execOpt source, MonadFail m) =&gt;
source -&gt; m regex
forall (m :: * -&gt; *). MonadFail m =&gt; a -&gt; m Regex
</span><span class="hs-identifier hs-var">makeRegexM</span></span><span>
</span><span id="line-227"></span><span>               </span><span id="local-6989586621679115915"><span class="annot"><span class="annottext">Regex
</span><a href="#local-6989586621679115915"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">source -&gt; m Regex
forall a (m :: * -&gt; *).
(RegexMaker Regex CompOption ExecOption a, MonadFail m) =&gt;
a -&gt; m Regex
</span><a href="#local-6989586621679115909"><span class="hs-identifier hs-var">make</span></a></span><span> </span><span class="annot"><span class="annottext">source
</span><a href="#local-6989586621679115908"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-228"></span><span>               </span><span class="annot"><span class="annottext">Regex -&gt; source1 -&gt; m target
forall regex source target (m :: * -&gt; *).
(RegexContext regex source target, MonadFail m) =&gt;
regex -&gt; source -&gt; m target
forall (m :: * -&gt; *). MonadFail m =&gt; Regex -&gt; source1 -&gt; m target
</span><span class="hs-identifier hs-var">matchM</span></span><span> </span><span class="annot"><span class="annottext">Regex
</span><a href="#local-6989586621679115915"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">source1
</span><a href="#local-6989586621679115907"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-229"></span></pre></body></html>