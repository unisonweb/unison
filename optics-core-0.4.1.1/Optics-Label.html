<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Optics.Label</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">optics-core-0.4.1.1: Optics as an abstract interface: core definitions</span><ul class="links" id="page-menu"><li><a href="src/Optics.Label.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Optics.Label</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">How to use labels as optics to make working with Haskell's records more convenient</a><ul><li><a href="#g:2">The problem</a></li><li><a href="#g:3">The solution</a></li><li><a href="#g:4">The result</a></li></ul></li><li><a href="#g:5">Sample usage</a></li><li><a href="#g:6">Technical details</a><ul><li><a href="#g:7"><code>LabelOptic</code> type class</a></li><li><a href="#g:8">Structure of <code>LabelOptic</code> instances</a></li><li><a href="#g:9">Explanation of functional dependencies</a></li></ul></li><li><a href="#section.orphans">Orphan instances</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Overloaded labels are a solution to Haskell's namespace problem for records.
 The <code>-XOverloadedLabels</code> extension allows a new expression syntax for labels,
 a prefix <code>#</code> sign followed by an identifier, e.g. <code>#foo</code>.  These expressions
 can then be given an interpretation that depends on the type at which they
 are used and the text of the label.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="#t:LabelOptic">LabelOptic</a> (name :: <a href="../base-4.18.2.1/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) k s t a b | name s -&gt; k a, name t -&gt; k b, name s b -&gt; t, name t a -&gt; s <span class="keyword">where</span><ul class="subs"><li><a href="#v:labelOptic">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:LabelOptic-39-">LabelOptic'</a> name k s a = <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s s a a</li><li class="src short"><span class="keyword">class</span> <a href="../base-4.18.2.1/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a> a =&gt; <a href="#t:GenericLabelOptics">GenericLabelOptics</a> a <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:HasGenericLabelOptics">HasGenericLabelOptics</a> a :: <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li></ul></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>How to use labels as optics to make working with Haskell's records more convenient</h1></a><a href="#g:2" id="g:2"><h2>The problem</h2></a><div class="doc"><p>Standard Haskell records are a common source of frustration amongst seasoned
 Haskell programmers. Their main issues are:</p><ol><li value="1">Inability to define multiple data types sharing field names in the same
     module.</li><li value="2">Pollution of global namespace as every field accessor is also a top-level
     function.</li><li value="3">Clunky update syntax, especially when nested fields get involved.</li></ol><p>Over the years multiple language extensions were proposed and implemented to
 alleviate these issues. We're quite close to having a reasonable solution
 with the following trifecta:</p><ul><li><code><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/duplicate_record_fields.html">DuplicateRecordFields</a></code> - introduced in GHC 8.0.1, addresses (1)</li><li><code><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/field_selectors.html">NoFieldSelectors</a></code> and <code><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_record_dot.html">OverloadedRecordDot</a></code> - introduced in GHC 9.2.1, addresses (2)</li><li><code><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/overloaded_record_update.html">OverloadedRecordUpdate</a></code> - restricted version introduced in GHC 9.2.1, addresses (3)</li></ul><p>It needs to be noted however that <code>OverloadedRecordUpdate</code> is not yet usable
 out of the box as it requires the user to enable <code>RebindableSyntax</code> and
 provide their own <code>HasField</code> class.</p><p>Is there no hope then for people who would like to work with records in a
 reasonable way without waiting? Not necessarily, as by following a couple of
 simple patterns we can get pretty much the same (and more) features with
 labels as optics, just with a slightly more verbose syntax.</p></div><a href="#g:3" id="g:3"><h2>The solution</h2></a><div class="doc"><h3>Prefixless fields with <code>DuplicateRecordFields</code></h3><p>We necessarily want field names to be prefixless, i.e. <code>field</code> to be a field
 name and <code>#field</code> to be an overloaded label that becomes an optic refering to
 this field in the appropriate context.  With this approach we get working
 autocompletion and jump-to-definition in editors supporting <code>ctags</code>/<code>etags</code>
 in combination with <code><a href="https://hackage.haskell.org/package/ghc-tags">ghc-tags</a></code>,
 both of which (especially the latter) are very important for developer's
 productivity in real-world code bases.</p><p>Let's look at data types defined with this approach in mind:</p><pre>{-# LANGUAGE DuplicateRecordFields #-}

import Data.Time

data User = User { id     :: Int
                 , name   :: String
                 , joined :: UTCTime
                 , movies :: [Movie]
                 }

data Movie = Movie { id          :: Int
                   , name        :: String
                   , releaseDate :: UTCTime
                   }
</pre><p>Then appropriate <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances can be either written by hand,
 seamlessly derived via generic representation (see the
 <a href="Optics-Label.html#usage">Sample usage</a> section for more details)
 or generated with Template Haskell functions
 (defined in
 <a href="https://hackage.haskell.org/package/optics-th/docs/Optics-TH.html">Optics.TH</a>
 module from <a href="https://hackage.haskell.org/package/optics-th">optics-th</a>
 package) with</p><pre>makeFieldLabelsNoPrefix ''User
makeFieldLabelsNoPrefix ''Movie
</pre><p>Generally speaking, both techniques trade blows in terms of compile time and
 run time resources. Generic optics are a bit slower to compile without
 optimizations than Template Haskell generated ones and their updating part
 might be slightly slower for larger data types with GHC &lt; 9.2. On the other
 hand, generic optics are much more developer friendly.</p><p><em>Note:</em> there exists a similar approach that involves prefixing field names
 (either with the underscore or name of the data type) and generation of
 lenses as ordinary functions so that <code>prefixField</code> is the ordinary field name
 and <code>field</code> is the lens referencing it. The drawback of such solution is
 inability to get working jump-to-definition for field names, which makes
 navigation in unfamiliar code bases significantly harder, so it's not
 recommended.</p><h3>Emulation of <code>NoFieldSelectors</code></h3><p>Prefixless fields (especially ones with common names such as <code>id</code> or <code>name</code>)
 leak into global namespace as accessor functions and can generate a lot of
 name clashes. If you can't use GHC &gt;= 9.2 and take advantage of the
 <code>NoFieldSelectors</code> language extension, this can be alleviated by splitting
 modules defining types into two, namely:</p><ol><li value="1">A private one that exports full type definitions, i.e. with their fields
     and constructors.</li><li value="2">A public one that exports only constructors (or no constructors at all if
     the data type in question is opaque).</li></ol><p>There is no notion of private and public modules within a single cabal
 target, but we can hint at it e.g. by naming the public module <code>T</code> and
 private <code>T.Internal</code>.</p><p>An example:</p><p>Private module:</p><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
module User.Internal (User(..)) where

import Optics.TH

data User = User { id   :: Int
                 , name :: String
                 }

makeFieldLabelsNoPrefix ''User

...
</pre><p>Public module:</p><pre>module User (User(User)) where

import User.Internal

...
</pre><p>Then, whenever we're dealing with a value of type <code>User</code> and want to read or
 modify its fields, we can use corresponding labels without having to import
 <code>User.Internal</code>. Importing <code>User</code> is enough because it provides appropriate
 <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances through <code>User.Internal</code> which enables labels to be
 interpreted as optics in the appropriate context.</p><p><em>Note:</em> if you plan to completely hide (some of) the fields of a data type,
 you need to skip defining the corresponding <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instances for them
 (in case you want fields to be read only, you can make the optic kind of the
 coresponding <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> <code><a href="Optics-Getter.html#t:A_Getter" title="Optics.Getter">A_Getter</a></code> instead of <code><a href="Optics-IxLens.html#t:A_Lens" title="Optics.IxLens">A_Lens</a></code>). It's because
 Haskell makes it impossible to selectively hide instances, so once a
 <code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> instance is defined, it'll always be possible to use a label
 that desugars to its usage whenever a module with its definition is
 (transitively) imported.</p><pre>{-# LANGUAGE OverloadedLabels #-}

import Optics
import User

greetUser :: User -&gt; String
greetUser user = &quot;Hello &quot; ++ user ^. #name ++ &quot;!&quot;

addSurname :: String -&gt; User -&gt; User
addSurname surname user = user &amp; #name %~ (++ &quot; &quot; ++ surname)
</pre><p>But what if we want to create a new <code>User</code> with the record syntax? Importing
 <code>User</code> module is not sufficient since it doesn't export <code>User</code>'s
 fields. However, if we import <code>User.Internal</code> <em>fully qualified</em> and make use
 of the fact that field names used within the record syntax don't have to be
 prefixed when <code>DisambiguateRecordFields</code> language extension is enabled, it
 works out:</p><pre>{-# LANGUAGE DisambiguateRecordFields #-}

import User
import qualified User.Internal

newUser :: User
newUser = User { id   = 1     -- not User.Internal.id
               , name = &quot;Ian&quot; -- not User.Internal.name
               }
</pre><p>This way top-level field accessor functions stay in their own qualified
 namespace and don't generate name clashes, yet they can be used without
 prefix within the record syntax.</p></div><a href="#g:4" id="g:4"><h2>The result</h2></a><div class="doc"><p>When we follow the above conventions for data types in our application, we
 get:</p><ol><li value="1">Prefixless field names that don't pollute global namespace (with the
     internal module qualification trick).</li><li value="2">Working tags based jump-to-definition for field names (as <code>field</code> is the
     ordinary field, whereas <code>#field</code> is the lens referencing it).</li><li value="3">The full power of optics at our disposal, should we ever need it.</li></ol></div><a href="#g:5" id="g:5"><h1>Sample usage</h1></a><div class="doc"><p><a id="usage"></a></p><p>An example showing how overloaded labels can be used as optics for fields of
 types having a <code><a href="../base-4.18.2.1/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a></code> instance.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDeriveAnyClass
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDeriveGeneric
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDuplicateRecordFields
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedLabels
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import GHC.Generics (Generic)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Pet
  = Cat  { name :: String, age :: Int, lazy :: Bool }
  | Fish { name :: String, age :: Int, lazy :: Bool }
  deriving (Show, Generic)
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Human = Human
  { name :: String
  , age  :: Integer
  , pets :: [Pet]
  } deriving (Show, Generic)
:}
</pre><p><em>Note:</em> Generic deriving of optics works well on a moderate scale, but for
 ubiquitous usage (and in production in general) we recommend generating them
 with Template Haskell as it scales better in terms of compilation time. For
 more details see <code>makeFieldLabelsNoPrefix</code> from
 <a href="https://hackage.haskell.org/package/optics-th/docs/Optics-TH.html">Optics.TH</a>
 in the <a href="https://hackage.haskell.org/package/optics-th">optics-th</a> package.</p><p>Here is some test data:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>peter :: Human
peter = Human { name = &quot;Peter&quot;
              , age  = 13
              , pets = [ Fish { name = &quot;Goldie&quot;
                              , age  = 1
                              , lazy = False
                              }
                       , Cat { name = &quot;Loopy&quot;
                             , age  = 3
                             , lazy = False
                             }
                       , Cat { name = &quot;Sparky&quot;
                             , age  = 2
                             , lazy = True
                             }
                       ]
             }
:}
</pre><p>Now we can ask for Peter's name:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter ^. #name
</code></strong>&quot;Peter&quot;
</pre><p>or for names of his pets:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter ^.. #pets % folded % #name
</code></strong>[&quot;Goldie&quot;,&quot;Loopy&quot;,&quot;Sparky&quot;]
</pre><p>We can check whether any of his pets is lazy:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>orOf (#pets % folded % #lazy) peter
</code></strong>True
</pre><p>or how things might be be a year from now:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter &amp; #age %~ (+1) &amp; #pets % mapped % #age %~ (+1)
</code></strong>Human {name = &quot;Peter&quot;, age = 14, pets = [Fish {name = &quot;Goldie&quot;, age = 2, lazy = False},Cat {name = &quot;Loopy&quot;, age = 4, lazy = False},Cat {name = &quot;Sparky&quot;, age = 3, lazy = True}]}
</pre><p>Perhaps Peter is going on vacation and needs to leave his pets at home:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>peter &amp; #pets .~ []
</code></strong>Human {name = &quot;Peter&quot;, age = 13, pets = []}
</pre></div><a href="#g:6" id="g:6"><h1>Technical details</h1></a><a href="#g:7" id="g:7"><h2><code>LabelOptic</code> type class</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:LabelOptic" class="def">LabelOptic</a> (name :: <a href="../base-4.18.2.1/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) k s t a b | name s -&gt; k a, name t -&gt; k b, name s b -&gt; t, name t a -&gt; s <span class="keyword">where</span> <a href="src/Optics.Label.html#LabelOptic" class="link">Source</a> <a href="#t:LabelOptic" class="selflink">#</a></p><div class="doc"><p>Support for overloaded labels as optics.</p><p>An overloaded label <code>#foo</code> can be used as an optic if there is an instance
 <code><code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> &quot;foo&quot; k s t a b</code>.</p><p>Alternatively, if both <code>s</code> and <code>t</code> have a <code><a href="../base-4.18.2.1/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a></code> (<code><a href="Optics-Label.html#t:GenericLabelOptics" title="Optics.Label">GenericLabelOptics</a></code> if
 <code>explicit-generic-labels</code> flag is enabled) instance, a total field of <code>s</code> is
 accessible by a label <code>#field</code> of kind <code><a href="Optics-IxLens.html#t:A_Lens" title="Optics.IxLens">A_Lens</a></code>, whereas its constructor by a
 label <code>#_Constructor</code> of kind <code><a href="Optics-Prism.html#t:A_Prism" title="Optics.Prism">A_Prism</a></code>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:labelOptic" class="def">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b <a href="src/Optics.Label.html#labelOptic" class="link">Source</a> <a href="#v:labelOptic" class="selflink">#</a></p><div class="doc"><p>Used to interpret overloaded label syntax.  An overloaded label <code>#foo</code>
 corresponds to <code><code><a href="Optics-Label.html#v:labelOptic" title="Optics.Label">labelOptic</a></code> @&quot;foo&quot;</code>.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:LabelOptic">Instances</h4><details id="i:LabelOptic" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:LabelOptic:LabelOptic:1"></span> GenericLabelOpticContext repDefined name k s t a b =&gt; <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s t a b</span> <a href="src/Optics.Label.html#line-522" class="link">Source</a> <a href="#t:LabelOptic" class="selflink">#</a></td><td class="doc"><p>If no instance matches, try to use <code><a href="../base-4.18.2.1/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a></code> machinery for field access.</p><p>For more information have a look at <code><a href="Optics-Generic.html#v:gfield" title="Optics.Generic">gfield</a></code> and
 <code><a href="Optics-Generic.html#v:gconstructor" title="Optics.Generic">gconstructor</a></code>.</p><p><em>Since: 0.4</em></p></td></tr><tr><td colspan="2"><details id="i:ic:LabelOptic:LabelOptic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Optics-Label.html">Optics.Label</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:labelOptic">labelOptic</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a> s t a b <a href="src/Optics.Label.html#labelOptic" class="link">Source</a> <a href="#v:labelOptic" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LabelOptic-39-" class="def">LabelOptic'</a> name k s a = <a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s s a a <a href="src/Optics.Label.html#LabelOptic%27" class="link">Source</a> <a href="#t:LabelOptic-39-" class="selflink">#</a></p><div class="doc"><p>Type synonym for a type-preserving optic as overloaded label.</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.18.2.1/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a> a =&gt; <a id="t:GenericLabelOptics" class="def">GenericLabelOptics</a> a <a href="src/Optics.Label.html#GenericLabelOptics" class="link">Source</a> <a href="#t:GenericLabelOptics" class="selflink">#</a></p><div class="doc"><p>If the <code>explicit-generic-labels</code> Cabal flag is enabled, only types with
 this instance (which can be trivially derived with <code>DeriveAnyClass</code>
 extension) will be able to use labels as generic optics with a specific type.</p><p>It's an option for application developers to disable implicit fallback to
 generic optics for more control.</p><p>Libraries using generic labels with their data types should derive this
 instance for compatibility with the <code>explicit-generic-labels</code> flag.</p><p><em>Note:</em> the flag <code>explicit-generic-labels</code> is disabled by default. Enabling
 it is generally unsupported as it might lead to compilation errors of
 dependencies relying on implicit fallback to generic optics.</p><p><em>Since: 0.4</em></p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:HasGenericLabelOptics" class="def">HasGenericLabelOptics</a> a :: <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Optics.Label.html#HasGenericLabelOptics" class="link">Source</a> <a href="#t:HasGenericLabelOptics" class="selflink">#</a></p> <div class="subs default"><p class="caption"></p><p class="src"><span class="keyword">type</span> <a href="Optics-Label.html#t:HasGenericLabelOptics" title="Optics.Label">HasGenericLabelOptics</a> a = '<a href="../base-4.18.2.1/Data-Bool.html#v:True" title="Data.Bool">True</a></p></div></div></div><a href="#g:8" id="g:8"><h2>Structure of <code>LabelOptic</code> instances</h2></a><div class="doc"><p><a id="structure"></a></p><p>You might wonder why instances generated with Template Haskell have the
 following form:</p><pre>instance (k ~ A_Lens, a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic &quot;pets&quot; k Human Human a b where
  ...
</pre><p>instead of</p><pre>instance LabelOptic &quot;pets&quot; A_Lens Human Human [Pet] [Pet] where
  ...
</pre><p>The reason is that using the first form ensures that it is enough for GHC to
 match on the instance if either <code>s</code> or <code>t</code> is known (as equality constraints
 are solved after the instance matches), which not only makes type inference
 better, but also allows it to generate better error messages.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XDataKinds
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XFlexibleInstances
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XMultiParamTypeClasses
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XTypeFamilies
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XUndecidableInstances
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Pet = Dog { name :: String }
         | Cat { name :: String }
  deriving Show
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Human1 = Human1 { pets :: [Pet] }
  deriving Show
instance LabelOptic &quot;pets&quot; A_Lens Human1 Human1 [Pet] [Pet] where
  labelOptic = lensVL $ \f (Human1 pets) -&gt; Human1 &lt;$&gt; f pets
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>data Human2 = Human2 { pets :: [Pet] }
 deriving Show
instance (k ~ A_Lens, a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic &quot;pets&quot; k Human2 Human2 a b where
  labelOptic = lensVL $ \f (Human2 pets) -&gt; Human2 &lt;$&gt; f pets
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let human1 = Human1 [Dog &quot;Lucky&quot;]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let human2 = Human2 [Cat &quot;Sleepy&quot;]
</code></strong></pre><p>Let's have a look how these two instance definitions differ.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human1 &amp; #pets .~ []
</code></strong>...
...No instance for LabelOptic &quot;pets&quot; &#8216;A_Lens&#8217; &#8216;Human1&#8217; &#8216;()&#8217; &#8216;[Pet]&#8217; &#8216;[a0]&#8217;
...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human2 &amp; #pets .~ []
</code></strong>Human2 {pets = []}
</pre><p>That's because an empty list doesn't have a type <code>[Pet]</code>, it has a type <code>[r]</code>
 and GHC doesn't have enough information to match on the instance we
 provided. We'd need to either annotate the list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human1 &amp; #pets .~ ([] :: [Pet])
</code></strong>Human1 {pets = []}
</pre><p>or the result type:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human1 &amp; #pets .~ [] :: Human1
</code></strong>Human1 {pets = []}
</pre><p>both of which are a nuisance.</p><p>Here are more examples of confusing error messages if the instance for
 <code>LabelOptic &quot;pets&quot;</code> is written without type equalities:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human1 ^. #pets :: Char
</code></strong>...
...No instance for LabelOptic &quot;pets&quot; &#8216;A_Lens&#8217; &#8216;Human1&#8217; &#8216;Human1&#8217; &#8216;Char&#8217; &#8216;Char&#8217;
...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human1 &amp; #pets .~ 'x'
</code></strong>...
...No instance for LabelOptic &quot;pets&quot; &#8216;A_Lens&#8217; &#8216;Human1&#8217; &#8216;Human1&#8217; &#8216;[Pet]&#8217; &#8216;Char&#8217;
...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let pets = #pets :: Iso' Human1 [Pet]
</code></strong>...
...No instance for LabelOptic &quot;pets&quot; &#8216;An_Iso&#8217; &#8216;Human1&#8217; &#8216;Human1&#8217; &#8216;[Pet]&#8217; &#8216;[Pet]&#8217;
...
</pre><p>If we use the second form, error messages become much more accurate:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human2 ^. #pets :: Char
</code></strong>...
...Couldn't match type &#8216;Char&#8217; with &#8216;[Pet]&#8217;
...  arising from the overloaded label &#8216;#pets&#8217;
...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>human2 &amp; #pets .~ 'x'
</code></strong>...
...Couldn't match type &#8216;Char&#8217; with &#8216;[Pet]&#8217;
...  arising from the overloaded label &#8216;#pets&#8217;
...
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let pets = #pets :: Iso' Human2 [Pet]
</code></strong>...
...Couldn't match type &#8216;An_Iso&#8217; with &#8216;A_Lens&#8217;
...  arising from the overloaded label &#8216;#pets&#8217;
...
</pre></div><a href="#g:9" id="g:9"><h2>Explanation of functional dependencies</h2></a><div class="doc"><p><code><a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a></code> uses the following functional dependencies to guarantee good
 type inference:</p><ol><li value="1"><code>name s -&gt; k a</code> (the optic for the field <code>name</code> in <code>s</code> is of type <code>k</code> and
 focuses on <code>a</code>)</li><li value="2"><code>name t -&gt; k b</code> (the optic for the field <code>name</code> in <code>t</code> is of type <code>k</code> and
 focuses on <code>b</code>)</li><li value="3"><code>name s b -&gt; t</code> (replacing the field <code>name</code> in <code>s</code> with <code>b</code> yields <code>t</code>)</li><li value="4"><code>name t a -&gt; s</code> (replacing the field <code>name</code> in <code>t</code> with <code>a</code> yields <code>s</code>)</li></ol><p>Dependencies (1) and (2) ensure that when we compose two optics, the middle
 type is unambiguous.</p><p>Dependencies (3) and (4) ensure that when we perform a chain of updates, the
 middle type is unambiguous.</p></div><h1>Orphan instances</h1><div id="section.orphans"><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:o:ic:IsLabel:IsLabel:1"></span> (<a href="Optics-Label.html#t:LabelOptic" title="Optics.Label">LabelOptic</a> name k s t a b, is <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Optics-Optic.html#t:NoIx" title="Optics.Optic">NoIx</a>) =&gt; <a href="../base-4.18.2.1/GHC-OverloadedLabels.html#t:IsLabel" title="GHC.OverloadedLabels">IsLabel</a> name (<a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k is s t a b)</span> <a href="src/Optics.Label.html#line-605" class="link">Source</a> <a href="#v:-36-fIsLabelnameOptic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:o:ic:IsLabel:IsLabel:1"><summary class="hide-when-js-enabled">Instance details</summary><p></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromLabel">fromLabel</a> :: <a href="Optics-Optic.html#t:Optic" title="Optics.Optic">Optic</a> k is s t a b <a href="#v:fromLabel" class="selflink">#</a></p></div></details></td></tr></table></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>