-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optics as an abstract interface: core definitions
--   
--   This package makes it possible to define and use Lenses, Traversals,
--   Prisms and other optics, using an abstract interface.
--   
--   This variant provides core definitions with a minimal dependency
--   footprint. See the <tt><a>optics</a></tt> package (and its
--   dependencies) for documentation and the "batteries-included" variant.
@package optics-core
@version 0.4.1.1


-- | Classes for co- and contravariant bifunctors.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Bi

-- | Class for (covariant) bifunctors.
class Bifunctor p
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p i a c -> p i b d
first :: Bifunctor p => (a -> b) -> p i a c -> p i b c
second :: Bifunctor p => (c -> d) -> p i a c -> p i a d

-- | Class for contravariant bifunctors.
class Bicontravariant p
contrabimap :: Bicontravariant p => (b -> a) -> (d -> c) -> p i a c -> p i b d
contrafirst :: Bicontravariant p => (b -> a) -> p i a c -> p i b c
contrasecond :: Bicontravariant p => (c -> b) -> p i a b -> p i a c

-- | If <tt>p</tt> is a <a>Profunctor</a> and a <a>Bifunctor</a> then its
--   left parameter must be phantom.
lphantom :: (Profunctor p, Bifunctor p) => p i a c -> p i b c

-- | If <tt>p</tt> is a <a>Profunctor</a> and <a>Bicontravariant</a> then
--   its right parameter must be phantom.
rphantom :: (Profunctor p, Bicontravariant p) => p i c a -> p i c b
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.Forget r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.ForgetM r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.IxForget r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.IxForgetM r)
instance Optics.Internal.Bi.Bifunctor Data.Profunctor.Indexed.Tagged


-- | Internal implementation details of indexed optics.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Indexed.Classes


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Magic

-- | How about a magic trick? I'm gonna make the coverage condition
--   disappear.
class Dysfunctional field k s t a b | field s -> k t a b, field t -> k s a b
class TypeInferenceLoop msg1 msg2 msg3 field k s t a b | field s -> k t a b, field t -> k s a b
instance forall k1 k2 k3 k4 k5 k6 (field :: k1) (k7 :: k2) (s :: k3) (t :: k4) (a :: k5) (b :: k6). Optics.Internal.Magic.TypeInferenceLoop "Type inference for the local binding failed. Write the type" "signature yourself or disable monomorphism restriction with" "NoMonomorphismRestriction LANGUAGE pragma so GHC infers it." field k7 s t a b => Optics.Internal.Magic.Dysfunctional field k7 s t a b
instance forall k1 k2 k3 k4 k5 k6 k7 k8 k9 (msg1 :: k1) (msg2 :: k2) (msg3 :: k3) (field :: k4) (k10 :: k5) (s :: k6) (t :: k7) (a :: k8) (b :: k9). Optics.Internal.Magic.TypeInferenceLoop msg1 msg2 msg3 field k10 s t a b => Optics.Internal.Magic.TypeInferenceLoop msg1 msg2 msg3 field k10 s t a b


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.TypeLevel

-- | A list of index types, used for indexed optics.
type IxList = [Type]

-- | An alias for an empty index-list
type NoIx = ('[] :: IxList)

-- | Singleton index list
type WithIx i = ('[i] :: IxList)
type family ShowSymbolWithOrigin symbol origin :: ErrorMessage
type family ShowSymbolsWithOrigin (fs :: [(Symbol, Symbol)]) :: ErrorMessage
type family ShowOperators (ops :: [Symbol]) :: ErrorMessage
type family AppendEliminations a b
type family ShowEliminations forms :: ErrorMessage

-- | Reverse a type-level list.
type family Reverse (xs :: [k]) (acc :: [k]) :: [k]

-- | Curry a type-level list.
--   
--   In pseudo (dependent-)Haskell:
--   
--   <pre>
--   <a>Curry</a> xs y = <a>foldr</a> (-&gt;) y xs
--   </pre>
type family Curry (xs :: IxList) (y :: Type) :: Type

-- | Append two type-level lists together.
type family Append (xs :: [k]) (ys :: [k]) :: [k]

-- | Class that is inhabited by all type-level lists <tt>xs</tt>, providing
--   the ability to compose a function under <tt><a>Curry</a> xs</tt>.
class CurryCompose xs

-- | Compose a function under <tt><a>Curry</a> xs</tt>. This generalises
--   <tt>(<a>.</a>)</tt> (aka <a>fmap</a> for <tt>(-&gt;)</tt>) to work for
--   curried functions with one argument for each type in the list.
composeN :: CurryCompose xs => (i -> j) -> Curry xs i -> Curry xs j

-- | Tagged version of 'Data.Type.Equality.(:~:)' for carrying evidence
--   that two index lists in a curried form are equal.
data IxEq i is js
[IxEq] :: IxEq i is is

-- | In pseudo (dependent-)Haskell, provide a witness
--   
--   <pre>
--   foldr f (foldr f init xs) ys = foldr f init (ys ++ xs)
--      where f = (-&gt;)
--   </pre>
class AppendIndices xs ys ks | xs ys -> ks
appendIndices :: AppendIndices xs ys ks => IxEq i (Curry xs (Curry ys i)) (Curry ks i)

-- | If lhs is <a>Right</a>, return it. Otherwise check rhs.
type family FirstRight (m1 :: Either e a) (m2 :: Either e a) :: Either e a
type family FromRight (def :: b) (e :: Either a b) :: b
type family IsLeft (e :: Either a b) :: Bool

-- | Show a custom type error if <tt>p</tt> is true.
type family When (p :: Bool) (err :: Constraint) :: Constraint

-- | Show a custom type error if <tt>p</tt> is false (or stuck).
type family Unless (p :: Bool) (err :: Constraint) :: Constraint

-- | Use with <a>Unless</a> to detect stuck (undefined) type families.
type family Defined (f :: k) :: Bool

-- | Show a type surrounded by quote marks.
type family QuoteType (x :: t) :: ErrorMessage

-- | Show a symbol surrounded by quote marks.
type family QuoteSymbol (x :: Symbol) :: ErrorMessage
type family ToOrdinal (n :: Nat) :: ErrorMessage

-- | Derive the shape of <tt>a</tt> from the shape of <tt>b</tt>.
class HasShapeOf (a :: k) (b :: k)
instance forall k1 k2 (fa :: k1) (f :: k2 -> k1) (a :: k2) (g :: k2 -> k1) (b :: k2). (fa GHC.Types.~ f a, Optics.Internal.Optic.TypeLevel.HasShapeOf f g) => Optics.Internal.Optic.TypeLevel.HasShapeOf fa (g b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => Optics.Internal.Optic.TypeLevel.HasShapeOf a b
instance (xs GHC.Types.~ zs) => Optics.Internal.Optic.TypeLevel.AppendIndices xs '[] zs
instance (ys GHC.Types.~ zs) => Optics.Internal.Optic.TypeLevel.AppendIndices '[] ys zs
instance Optics.Internal.Optic.TypeLevel.AppendIndices xs ys ks => Optics.Internal.Optic.TypeLevel.AppendIndices (x : xs) ys (x : ks)
instance Optics.Internal.Optic.TypeLevel.CurryCompose '[]
instance Optics.Internal.Optic.TypeLevel.CurryCompose xs => Optics.Internal.Optic.TypeLevel.CurryCompose (x : xs)


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Generic.TypeLevel

-- | A map that allows reaching a specific field in a generic
--   representation of a data type. Computed up front by generic optics for
--   early error reporting and efficient data traversal.
data PathTree e
PathTree :: PathTree e -> PathTree e -> PathTree e
PathLeaf :: Either e [Path] -> PathTree e
data Path
PathLeft :: Path
PathRight :: Path

-- | Compute paths to a field with a specific name.
type family GetFieldPaths s (name :: Symbol) g :: PathTree Symbol

-- | Compute path to a constructor in a sum or a field in a product with a
--   specific name.
type family GetNamePath (name :: Symbol) g (acc :: [Path]) :: Either Symbol [Path]

-- | Compute paths to a field at a specific position.
type family GetPositionPaths s (pos :: Nat) g :: PathTree (Nat, Nat)

-- | Compute path to a constructor in a sum or a field in a product at a
--   specific position.
type family GetPositionPath (pos :: Nat) g (k :: Nat) (acc :: [Path]) :: Either (Nat, Nat) [Path]

-- | Generate bogus equality constraints that attempt to unify generic
--   representations with this type in case there is an error such as
--   missing field, constructor etc. so these huge types don't leak into
--   error messages.
type family HideReps (g :: Type -> Type) (h :: Type -> Type) :: Constraint

-- | Check if any leaf in the tree has a '[Path]'.
type family AnyHasPath (path :: PathTree e) :: Bool
type family NoGenericError t


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.Types

-- | Kind for types used as optic tags, such as <a>A_Lens</a>.
type OpticKind = Type

-- | Tag for an iso.
data An_Iso :: OpticKind

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Tag for a prism.
data A_Prism :: OpticKind

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Tag for a setter.
data A_Setter :: OpticKind

-- | Tag for a reversed prism.
data A_ReversedPrism :: OpticKind

-- | Tag for a getter.
data A_Getter :: OpticKind

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind

-- | Tag for a fold.
data A_Fold :: OpticKind

-- | Tag for a reversed lens.
data A_ReversedLens :: OpticKind

-- | Tag for a review.
data A_Review :: OpticKind

-- | Mapping tag types <tt>k</tt> to constraints on <tt>p</tt>.
--   
--   Using this type family we define the constraints that the various
--   flavours of optics have to fulfill.
type family Constraints (k :: OpticKind) (p :: Type -> Type -> Type -> Type) :: Constraint


-- | Instances to implement the subtyping hierarchy between optics.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.Subtyping

-- | Subtyping relationship between kinds of optics.
--   
--   An instance of <tt><a>Is</a> k l</tt> means that any <tt><a>Optic</a>
--   k</tt> can be used as an <tt><a>Optic</a> l</tt>. For example, we have
--   an <tt><a>Is</a> <a>A_Lens</a> <a>A_Traversal</a></tt> instance, but
--   not <tt><a>Is</a> <a>A_Traversal</a> <a>A_Lens</a></tt>.
--   
--   This class needs instances for all possible combinations of tags.
class Is k l

-- | Witness of the subtyping relationship.
implies :: Is k l => (Constraints k p => r) -> Constraints l p => r
type family EliminationForms (k :: OpticKind)
type AffineFoldEliminations = '( '[ '("preview", "Optics.AffineFold")], '["(^?)"])
type AffineTraversalEliminations = AffineFoldEliminations `AppendEliminations` SetterEliminations
type FoldEliminations = '( '[ '("traverseOf_", "Optics.Fold"), '("foldMapOf", "Optics.Fold"), '("toListOf", "Optics.Fold")], '["(^..)"])
type GetterEliminations = '( '[ '("view", "Optics.Getter")], '["(^.)"])
type IsoEliminations = GetterEliminations `AppendEliminations` ReviewEliminations `AppendEliminations` SetterEliminations
type LensEliminations = GetterEliminations `AppendEliminations` SetterEliminations
type PrismEliminations = AffineFoldEliminations `AppendEliminations` ReviewEliminations `AppendEliminations` SetterEliminations
type ReviewEliminations = '( '[ '("review", "Optics.Review")], '["(#)"])
type SetterEliminations = '( '[ '("over", "Optics.Setter"), '("set", "Optics.Setter")], '["(%~)", "(.~)"])
type TraversalEliminations = '( '[ '("traverseOf", "Optics.Traversal")], '[]) `AppendEliminations` FoldEliminations `AppendEliminations` SetterEliminations

-- | Computes the least upper bound of two optics kinds.
--   
--   In presence of a <tt>JoinKinds k l m</tt> constraint <tt>Optic m</tt>
--   represents the least upper bound of an <tt>Optic k</tt> and an
--   <tt>Optic l</tt>. This means in particular that composition of an
--   <tt>Optic k</tt> and an <tt>Optic k</tt> will yield an <tt>Optic
--   m</tt>.
class JoinKinds k l m | k l -> m
joinKinds :: JoinKinds k l m => ((Constraints k p, Constraints l p) => r) -> Constraints m p => r
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_Iso) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedLens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedLens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedPrism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Review k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedLens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.A_ReversedLens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedLens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.A_Review k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedPrism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_ReversedPrism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Prism) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_ReversedLens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Review k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Review Optics.Internal.Optic.Types.A_Review k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Review Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Review Optics.Internal.Optic.Types.A_ReversedLens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Review) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Review Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Lens) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Getter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineTraversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_AffineFold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Traversal) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_Fold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_ReversedPrism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_Getter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.An_AffineFold k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Fold) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Fold Optics.Internal.Optic.Types.A_Traversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.A_Setter k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.An_Iso k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.A_Prism k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.A_Lens k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.An_AffineTraversal k
instance (k GHC.Types.~ Optics.Internal.Optic.Types.A_Setter) => Optics.Internal.Optic.Subtyping.JoinKinds Optics.Internal.Optic.Types.A_Setter Optics.Internal.Optic.Types.A_Traversal k
instance (Optics.Internal.Optic.Subtyping.JoinKinds k l m, (TypeError ...)) => Optics.Internal.Optic.Subtyping.JoinKinds k l m
instance (TypeError ...) => Optics.Internal.Optic.Subtyping.Is k l
instance Optics.Internal.Optic.Subtyping.Is k k
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedLens
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedPrism
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Prism
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Lens
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Setter


-- | Core optic types and subtyping machinery.
--   
--   This module contains the core <a>Optic</a> types, and the underlying
--   machinery that we need in order to implement the subtyping between
--   various different flavours of optics.
--   
--   The composition operator for optics is also defined here.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic

-- | Wrapper newtype for the whole family of optics.
--   
--   The first parameter <tt>k</tt> identifies the particular optic kind
--   (e.g. <a>A_Lens</a> or <a>A_Traversal</a>).
--   
--   The parameter <tt>is</tt> is a list of types available as indices.
--   This will typically be <a>NoIx</a> for unindexed optics, or
--   <a>WithIx</a> for optics with a single index. See the "Indexed optics"
--   section of the overview documentation in the <tt>Optics</tt> module of
--   the main <tt>optics</tt> package for more details.
--   
--   The parameters <tt>s</tt> and <tt>t</tt> represent the "big"
--   structure, whereas <tt>a</tt> and <tt>b</tt> represent the "small"
--   structure.
newtype Optic (k :: OpticKind) (is :: IxList) s t a b
Optic :: (forall p i. Profunctor p => Optic_ k p i (Curry is i) s t a b) -> Optic (k :: OpticKind) (is :: IxList) s t a b

-- | Common special case of <a>Optic</a> where source and target types are
--   equal.
--   
--   Here, we need only one "big" and one "small" type. For lenses, this
--   means that in the restricted form we cannot do type-changing updates.
type Optic' k is s a = Optic k is s s a a

-- | Type representing the various kinds of optics.
--   
--   The tag parameter <tt>k</tt> is translated into constraints on
--   <tt>p</tt> via the type family <a>Constraints</a>.
type Optic_ k p i j s t a b = Constraints k p => Optic__ p i j s t a b

-- | Optic internally as a profunctor transformation.
type Optic__ p i j s t a b = p i a b -> p j s t

-- | Strip the newtype wrapper off.
getOptic :: Profunctor p => Optic k is s t a b -> Optic_ k p i (Curry is i) s t a b

-- | Explicit cast from one optic flavour to another.
--   
--   The resulting optic kind is given in the first type argument, so you
--   can use TypeApplications to set it. For example
--   
--   <pre>
--   <a>castOptic</a> @<a>A_Lens</a> o
--   </pre>
--   
--   turns <tt>o</tt> into a <a>Lens</a>.
--   
--   This is the identity function, modulo some constraint jiggery-pokery.
castOptic :: forall destKind srcKind is s t a b. Is srcKind destKind => Optic srcKind is s t a b -> Optic destKind is s t a b

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: forall k l m is js ks s t u v a b. (JoinKinds k l m, AppendIndices is js ks) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two optics of the same flavour.
--   
--   Normally you can simply use (<a>%</a>) instead, but this may be useful
--   to help type inference if the type of one of the optics is otherwise
--   under-constrained.
(%%) :: forall k is js ks s t u v a b. AppendIndices is js ks => Optic k is s t u v -> Optic k js u v a b -> Optic k ks s t a b
infixl 9 %%

-- | Flipped function application, specialised to optics and binding
--   tightly.
--   
--   Useful for post-composing optics transformations:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (\i s -&gt; length s &lt;= i)) ["", "a","abc"]
--   ["","a"]
--   </pre>
(%&) :: Optic k is s t a b -> (Optic k is s t a b -> Optic l js s' t' a' b') -> Optic l js s' t' a' b'
infixl 9 %&


-- | Internal implementation details of indexed setters.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxSetter

-- | Internal implementation of <a>imapped</a>.
imapped__ :: (Mapping p, FunctorWithIndex i f) => Optic__ p j (i -> j) (f a) (f b) a b


-- | Internal implementation details of indexed optics.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Indexed

-- | Show useful error message when a function expects optics without
--   indices.
class is ~ NoIx => AcceptsEmptyIndices (f :: Symbol) (is :: IxList)

-- | Check whether a list of indices is not empty and generate sensible
--   error message if it's not.
class NonEmptyIndices (is :: IxList)

-- | Generate sensible error messages in case a user tries to pass either
--   an unindexed optic or indexed optic with unflattened indices where
--   indexed optic with a single index is expected.
class is ~ '[i] => HasSingleIndex (is :: IxList) (i :: Type)
type family ShowTypes (types :: [Type]) :: ErrorMessage
data IntT f a
IntT :: {-# UNPACK #-} !Int -> f a -> IntT f a
unIntT :: IntT f a -> f a
newtype Indexing f a
Indexing :: (Int -> IntT f a) -> Indexing f a
[runIndexing] :: Indexing f a -> Int -> IntT f a

-- | Index a traversal by position of visited elements.
indexing :: ((a -> Indexing f b) -> s -> Indexing f t) -> (Int -> a -> f b) -> s -> f t

-- | Construct a conjoined indexed optic that provides a separate code path
--   when used without indices. Useful for defining indexed optics that are
--   as efficient as their unindexed equivalents when used without indices.
--   
--   <i>Note:</i> <tt><a>conjoined</a> f g</tt> is well-defined if and only
--   if <tt>f ≡ <a>noIx</a> g</tt>.
conjoined :: is `HasSingleIndex` i => Optic k NoIx s t a b -> Optic k is s t a b -> Optic k is s t a b
instance GHC.Base.Functor f => GHC.Base.Functor (Optics.Internal.Indexed.Indexing f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Optics.Internal.Indexed.Indexing f)
instance ((TypeError ...), is GHC.Types.~ '[i1, i2], is GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2] i
instance ((TypeError ...), is GHC.Types.~ '[i1, i2, i3], is GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3] i
instance ((TypeError ...), is GHC.Types.~ '[i1, i2, i3, i4], is GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3, i4] i
instance ((TypeError ...), is GHC.Types.~ '[i1, i2, i3, i4, i5], is GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3, i4, i5] i
instance ((TypeError ...), is GHC.Types.~ (i1 : i2 : i3 : i4 : i5 : i6 : is'), is GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex (i1 : i2 : i3 : i4 : i5 : i6 : is') i
instance Optics.Internal.Indexed.HasSingleIndex '[i] i
instance ((TypeError ...), '[] GHC.Types.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[] i
instance (TypeError ...) => Optics.Internal.Indexed.NonEmptyIndices '[]
instance Optics.Internal.Indexed.NonEmptyIndices (x : xs)
instance ((TypeError ...), (x : xs) GHC.Types.~ Optics.Internal.Optic.TypeLevel.NoIx) => Optics.Internal.Indexed.AcceptsEmptyIndices f (x : xs)
instance Optics.Internal.Indexed.AcceptsEmptyIndices f '[]


-- | Internal implementation details of folds.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Fold

-- | Internal implementation of <a>foldVL</a>.
foldVL__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (a -> f u) -> s -> f v) -> Optic__ p i i s t a b

-- | Internal implementation of <a>folded</a>.
folded__ :: (Bicontravariant p, Traversing p, Foldable f) => Optic__ p i i (f a) (f b) a b

-- | Internal implementation of <a>foldring</a>.
foldring__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (a -> f u -> f u) -> f v -> s -> f w) -> Optic__ p i i s t a b

-- | Used for <a>headOf</a> and <a>iheadOf</a>.
data Leftmost a
LPure :: Leftmost a
LLeaf :: a -> Leftmost a
LStep :: Leftmost a -> Leftmost a

-- | Extract the <a>Leftmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getLeftmost :: Leftmost a -> Maybe a

-- | Used for <a>lastOf</a> and <a>ilastOf</a>.
data Rightmost a
RPure :: Rightmost a
RLeaf :: a -> Rightmost a
RStep :: Rightmost a -> Rightmost a

-- | Extract the <a>Rightmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getRightmost :: Rightmost a -> Maybe a
instance GHC.Base.Semigroup (Optics.Internal.Fold.Rightmost a)
instance GHC.Base.Monoid (Optics.Internal.Fold.Rightmost a)
instance GHC.Base.Semigroup (Optics.Internal.Fold.Leftmost a)
instance GHC.Base.Monoid (Optics.Internal.Fold.Leftmost a)


-- | Internal implementation details of indexed folds.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxFold

-- | Internal implementation of <a>ifoldVL</a>.
ifoldVL__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (i -> a -> f u) -> s -> f v) -> Optic__ p j (i -> j) s t a b

-- | Internal implementation of <a>ifolded</a>.
ifolded__ :: (Bicontravariant p, Traversing p, FoldableWithIndex i f) => Optic__ p j (i -> j) (f a) t a b

-- | Internal implementation of <a>ifoldring</a>.
ifoldring__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (i -> a -> f u -> f u) -> f v -> s -> f w) -> Optic__ p j (i -> j) s t a b


-- | A <a>Getter</a> is simply a function considered as an <a>Optic</a>.
--   
--   Given a function <tt>f :: S -&gt; A</tt>, we can convert it into a
--   <tt><a>Getter</a> S A</tt> using <a>to</a>, and convert back to a
--   function using <a>view</a>.
--   
--   This is typically useful not when you have functions/<a>Getter</a>s
--   alone, but when you are composing multiple <a>Optic</a>s to produce a
--   <a>Getter</a>.
module Optics.Getter

-- | Type synonym for a getter.
type Getter s a = Optic' A_Getter NoIx s a

-- | Build a getter from a function.
to :: (s -> a) -> Getter s a

-- | View the value pointed to by a getter.
--   
--   If you want to <a>view</a> a type-modifying optic that is
--   insufficiently polymorphic to be type-preserving, use <a>getting</a>.
view :: Is k A_Getter => Optic' k is s a -> s -> a

-- | View the function of the value pointed to by a getter.
views :: Is k A_Getter => Optic' k is s a -> (a -> r) -> s -> r

-- | Tag for a getter.
data A_Getter :: OpticKind


-- | This module defines operations to <a>coerce</a> the type parameters of
--   optics to a representationally equal type. For example, if we have
--   
--   <pre>
--   newtype MkInt = MkInt Int
--   </pre>
--   
--   and
--   
--   <pre>
--   l :: Lens' S Int
--   </pre>
--   
--   then
--   
--   <pre>
--   coerceA @Int @MkInt l :: Lens' S MkInt
--   </pre>
module Optics.Coerce

-- | Lift <a>coerce</a> to the <tt>s</tt> parameter of an optic.
coerceS :: Coercible s s' => Optic k is s t a b -> Optic k is s' t a b

-- | Lift <a>coerce</a> to the <tt>t</tt> parameter of an optic.
coerceT :: Coercible t t' => Optic k is s t a b -> Optic k is s t' a b

-- | Lift <a>coerce</a> to the <tt>a</tt> parameter of an optic.
coerceA :: Coercible a a' => Optic k is s t a b -> Optic k is s t a' b

-- | Lift <a>coerce</a> to the <tt>b</tt> parameter of an optic.
coerceB :: Coercible b b' => Optic k is s t a b -> Optic k is s t a b'


-- | An <a>AffineTraversal</a> is a <a>Traversal</a> that applies to at
--   most one element.
--   
--   These arise most frequently as the composition of a <a>Lens</a> with a
--   <a>Prism</a>.
module Optics.AffineTraversal

-- | Type synonym for a type-modifying affine traversal.
type AffineTraversal s t a b = Optic An_AffineTraversal NoIx s t a b

-- | Type synonym for a type-preserving affine traversal.
type AffineTraversal' s a = Optic' An_AffineTraversal NoIx s a

-- | Build an affine traversal from a matcher and an updater.
--   
--   If you want to build an <a>AffineTraversal</a> from the van Laarhoven
--   representation, use <a>atraversalVL</a>.
atraversal :: (s -> Either t a) -> (s -> b -> t) -> AffineTraversal s t a b

-- | Retrieve the value targeted by an <a>AffineTraversal</a> or return the
--   original value while allowing the type to change if it does not match.
--   
--   <pre>
--   <a>preview</a> o ≡ <a>either</a> (<a>const</a> <a>Nothing</a>) <a>id</a> . <a>matching</a> o
--   </pre>
matching :: Is k An_AffineTraversal => Optic k is s t a b -> s -> Either t a

-- | Filter result(s) of a traversal that don't satisfy a predicate.
--   
--   <i>Note:</i> This is <i>not</i> a legal <a>Traversal</a>, unless you
--   are very careful not to invalidate the predicate on the target.
--   
--   As a counter example, consider that given <tt>evens =
--   <a>unsafeFiltered</a> <a>even</a></tt> the second <a>Traversal</a> law
--   is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   For a safe variant see <a>indices</a> (or <a>filtered</a> for
--   read-only optics).
unsafeFiltered :: (a -> Bool) -> AffineTraversal' a a

-- | Work with an affine traversal as a matcher and an updater.
withAffineTraversal :: Is k An_AffineTraversal => Optic k is s t a b -> ((s -> Either t a) -> (s -> b -> t) -> r) -> r

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven affine traversal.
--   
--   Note: this isn't exactly van Laarhoven representation as there is no
--   <tt>Pointed</tt> class (which would be a superclass of
--   <a>Applicative</a> that contains <a>pure</a> but not
--   <a>&lt;*&gt;</a>). You can interpret the first argument as a
--   dictionary of <tt>Pointed</tt> that supplies the <tt>point</tt>
--   function (i.e. the implementation of <a>pure</a>).
--   
--   A <a>TraversalVL</a> has <a>Applicative</a> available and hence can
--   combine the effects arising from multiple elements using
--   <a>&lt;*&gt;</a>. In contrast, an <a>AffineTraversalVL</a> has no way
--   to combine effects from multiple elements, so it must act on at most
--   one element. (It can act on none at all thanks to the availability of
--   <tt>point</tt>.)
type AffineTraversalVL s t a b = forall f. Functor f => (forall r. r -> f r) -> (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven affine traversal.
type AffineTraversalVL' s a = AffineTraversalVL s s a a

-- | Build an affine traversal from the van Laarhoven representation.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   azSnd = atraversalVL $ \point f ab@(a, b) -&gt;
--     if a &gt;= 'a' &amp;&amp; a &lt;= 'z'
--     then (a, ) &lt;$&gt; f b
--     else point ab
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview azSnd ('a', "Hi")
--   Just "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview azSnd ('@', "Hi")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over azSnd (++ "!!!") ('f', "Hi")
--   ('f',"Hi!!!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set azSnd "Bye" ('Y', "Hi")
--   ('Y',"Hi")
--   </pre>
atraversalVL :: AffineTraversalVL s t a b -> AffineTraversal s t a b

-- | Traverse over the target of an <a>AffineTraversal</a> and compute a
--   <a>Functor</a>-based answer.
atraverseOf :: (Is k An_AffineTraversal, Functor f) => Optic k is s t a b -> (forall r. r -> f r) -> (a -> f b) -> s -> f t


module Data.Typeable.Optics

-- | An <a>AffineTraversal'</a> for working with a <a>cast</a> of a
--   <a>Typeable</a> value.
_cast :: (Typeable s, Typeable a) => AffineTraversal' s a

-- | An <a>AffineTraversal'</a> for working with a <a>gcast</a> of a
--   <a>Typeable</a> value.
_gcast :: (Typeable s, Typeable a) => AffineTraversal' (c s) (c a)


-- | An <a>AffineFold</a> is a <a>Fold</a> that contains at most one
--   element, or a <a>Getter</a> where the function may be partial.
module Optics.AffineFold

-- | Type synonym for an affine fold.
type AffineFold s a = Optic' An_AffineFold NoIx s a

-- | Create an <a>AffineFold</a> from a partial function.
--   
--   <pre>
--   &gt;&gt;&gt; preview (afolding listToMaybe) "foo"
--   Just 'f'
--   </pre>
afolding :: (s -> Maybe a) -> AffineFold s a

-- | Retrieve the value targeted by an <a>AffineFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let _Right = prism Right $ either (Left . Left) Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview _Right (Right 'x')
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview _Right (Left 'y')
--   Nothing
--   </pre>
preview :: Is k An_AffineFold => Optic' k is s a -> s -> Maybe a

-- | Retrieve a function of the value targeted by an <a>AffineFold</a>.
previews :: Is k An_AffineFold => Optic' k is s a -> (a -> r) -> s -> Maybe r

-- | Obtain an <a>AffineFold</a> by lifting <tt>traverse_</tt> like
--   function.
--   
--   <pre>
--   <a>afoldVL</a> <a>.</a> <a>atraverseOf_</a> ≡ <a>id</a>
--   <a>atraverseOf_</a> <a>.</a> <a>afoldVL</a> ≡ <a>id</a>
--   </pre>
afoldVL :: (forall f. Functor f => (forall r. r -> f r) -> (a -> f u) -> s -> f v) -> AffineFold s a

-- | Filter result(s) of a fold that don't satisfy a predicate.
filtered :: (a -> Bool) -> AffineFold a a

-- | Traverse over the target of an <a>AffineFold</a>, computing a
--   <a>Functor</a>-based answer, but unlike <a>atraverseOf</a> do not
--   construct a new structure.
atraverseOf_ :: (Is k An_AffineFold, Functor f) => Optic' k is s a -> (forall r. r -> f r) -> (a -> f u) -> s -> f ()

-- | Check to see if this <a>AffineFold</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Just Nothing
--   True
--   </pre>
--   
--   The negation of this operator is <a>is</a> from
--   <a>Optics.Core.Extras</a>.
isn't :: Is k An_AffineFold => Optic' k is s a -> s -> Bool

-- | Try the first <a>AffineFold</a>. If it returns no entry, try the
--   second one.
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 1 % re _Left `afailing` ix 2 % re _Right) [0,1,2,3]
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 42 % re _Left `afailing` ix 2 % re _Right) [0,1,2,3]
--   Just (Right 2)
--   </pre>
afailing :: (Is k An_AffineFold, Is l An_AffineFold) => Optic' k is s a -> Optic' l js s a -> AffineFold s a
infixl 3 `afailing`

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind


-- | Internal implementation details of setters.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Setter

-- | Internal implementation of <a>mapped</a>.
mapped__ :: (Mapping p, Functor f) => Optic__ p i i (f a) (f b) a b


-- | Internal implementation details of indexed traversals.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxTraversal

-- | Internal implementation of <a>itraversed</a>.
itraversed__ :: (Traversing p, TraversableWithIndex i f) => Optic__ p j (i -> j) (f a) (f b) a b


-- | Internal implementation details of traversals.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Traversal

-- | Internal implementation of <a>traversed</a>.
traversed__ :: (Traversing p, Traversable f) => Optic__ p i i (f a) (f b) a b


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Utils
data Identity' a
Identity' :: {-# UNPACK #-} !() -> a -> Identity' a

-- | Mark a value for evaluation to whnf.
--   
--   This allows us to, when applying a setter to a structure, evaluate
--   only the parts that we modify. If an optic focuses on multiple
--   targets, Applicative instance of Identity' makes sure that we force
--   evaluation of all of them, but we leave anything else alone.
wrapIdentity' :: a -> Identity' a
unwrapIdentity' :: Identity' a -> a

-- | Helper for <a>traverseOf_</a> and the like for better efficiency than
--   the foldr-based version.
--   
--   Note that the argument <tt>a</tt> of the result should not be used.
newtype Traversed f a
Traversed :: f a -> Traversed f a
runTraversed :: Functor f => Traversed f a -> f ()

-- | Helper for <a>failing</a> family to visit the first fold only once.
data OrT f a
OrT :: !Bool -> f a -> OrT f a

-- | Wrap the applicative action in <a>OrT</a> so that we know later that
--   it was executed.
wrapOrT :: f a -> OrT f a

-- | Composition operator where the first argument must be an identity
--   function up to representational equivalence (e.g. a newtype wrapper or
--   unwrapper), and will be ignored at runtime.
(#.) :: Coercible b c => (b -> c) -> (a -> b) -> a -> c
infixr 9 #.

-- | Composition operator where the second argument must be an identity
--   function up to representational equivalence (e.g. a newtype wrapper or
--   unwrapper), and will be ignored at runtime.
(.#) :: Coercible a b => (b -> c) -> (a -> b) -> a -> c
infixl 8 .#

-- | <a>uncurry</a> with no lazy pattern matching for more efficient code.
uncurry' :: (a -> b -> c) -> (a, b) -> c
instance GHC.Base.Functor Optics.Internal.Utils.Identity'
instance GHC.Base.Functor f => GHC.Base.Functor (Optics.Internal.Utils.OrT f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Optics.Internal.Utils.OrT f)
instance GHC.Base.Applicative f => GHC.Base.Semigroup (Optics.Internal.Utils.Traversed f a)
instance GHC.Base.Applicative f => GHC.Base.Monoid (Optics.Internal.Utils.Traversed f a)
instance GHC.Base.Applicative Optics.Internal.Utils.Identity'
instance Data.Profunctor.Indexed.Mapping (Data.Profunctor.Indexed.Star Optics.Internal.Utils.Identity')
instance Data.Profunctor.Indexed.Mapping (Data.Profunctor.Indexed.IxStar Optics.Internal.Utils.Identity')


-- | A <tt><a>Fold</a> S A</tt> has the ability to extract some number of
--   elements of type <tt>A</tt> from a container of type <tt>S</tt>. For
--   example, <a>toListOf</a> can be used to obtain the contained elements
--   as a list. Unlike a <a>Traversal</a>, there is no way to set or update
--   elements.
--   
--   This can be seen as a generalisation of <a>traverse_</a>, where the
--   type <tt>S</tt> does not need to be a type constructor with <tt>A</tt>
--   as the last parameter.
--   
--   A close relative is the <a>AffineFold</a>, which is a <a>Fold</a> that
--   contains at most one element.
module Optics.Fold

-- | Type synonym for a fold.
type Fold s a = Optic' A_Fold NoIx s a

-- | Obtain a <a>Fold</a> by lifting <a>traverse_</a> like function.
--   
--   <pre>
--   <a>foldVL</a> <a>.</a> <a>traverseOf_</a> ≡ <a>id</a>
--   <a>traverseOf_</a> <a>.</a> <a>foldVL</a> ≡ <a>id</a>
--   </pre>
foldVL :: (forall f. Applicative f => (a -> f u) -> s -> f v) -> Fold s a

-- | Combine the results of a fold using a monoid.
foldOf :: (Is k A_Fold, Monoid a) => Optic' k is s a -> s -> a

-- | Fold via embedding into a monoid.
foldMapOf :: (Is k A_Fold, Monoid m) => Optic' k is s a -> (a -> m) -> s -> m

-- | Fold right-associatively.
foldrOf :: Is k A_Fold => Optic' k is s a -> (a -> r -> r) -> r -> s -> r

-- | Fold left-associatively, and strictly.
foldlOf' :: Is k A_Fold => Optic' k is s a -> (r -> a -> r) -> r -> s -> r

-- | Fold to a list.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (_1 % folded % _Right) ([Right 'h', Left 5, Right 'i'], "bye")
--   "hi"
--   </pre>
toListOf :: Is k A_Fold => Optic' k is s a -> s -> [a]

-- | Evaluate each action in a structure observed by a <a>Fold</a> from
--   left to right, ignoring the results.
--   
--   <pre>
--   <a>sequenceA_</a> ≡ <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ each (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
sequenceOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s (f a) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold</a>, computing an
--   <a>Applicative</a>-based answer, but unlike <a>traverseOf</a> do not
--   construct a new structure. <a>traverseOf_</a> generalizes
--   <a>traverse_</a> to work over any <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ each putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a> ≡ <a>traverseOf_</a> <a>folded</a>
--   </pre>
traverseOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s a -> (a -> f r) -> s -> f ()

-- | A version of <a>traverseOf_</a> with the arguments flipped.
forOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s a -> s -> (a -> f r) -> f ()

-- | Fold via the <a>Foldable</a> class.
folded :: Foldable f => Fold (f a) a

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (folding tail) [1,2,3,4]
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a

-- | Obtain a <a>Fold</a> by lifting <a>foldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (foldring foldr) [1,2,3,4]
--   [1,2,3,4]
--   </pre>
foldring :: (forall f. Applicative f => (a -> f u -> f u) -> f v -> s -> f w) -> Fold s a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a> ≡ <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (unfolded $ \b -&gt; if b == 0 then Nothing else Just (b, b - 1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (s -> Maybe (a, s)) -> Fold s a

-- | Check to see if this optic matches 1 or more entries.
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
has :: Is k A_Fold => Optic' k is s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Is k A_Fold => Optic' k is s a -> s -> Bool

-- | Retrieve the first entry of a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; headOf folded [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headOf each (1,2)
--   Just 1
--   </pre>
headOf :: Is k A_Fold => Optic' k is s a -> s -> Maybe a

-- | Retrieve the last entry of a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf folded [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf each (1,2)
--   Just 2
--   </pre>
lastOf :: Is k A_Fold => Optic' k is s a -> s -> Maybe a

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf each (True, False)
--   False
--   
--   &gt;&gt;&gt; andOf each (True, True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a> ≡ <a>andOf</a> <a>folded</a>
--   </pre>
andOf :: Is k A_Fold => Optic' k is s Bool -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf each (True, False)
--   True
--   
--   &gt;&gt;&gt; orOf each (False, False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a> ≡ <a>orOf</a> <a>folded</a>
--   </pre>
orOf :: Is k A_Fold => Optic' k is s Bool -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf each (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
allOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf each (=='x') ('x','y')
--   True
--   </pre>
anyOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> only if no targets of a <a>Fold</a> satisfy a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; noneOf each (not . isn't _Nothing) (Just 3, Just 4, Just 5)
--   True
--   
--   &gt;&gt;&gt; noneOf (folded % folded) (&lt;10) [[13,99,20],[3,71,42]]
--   False
--   </pre>
noneOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Calculate the <a>Product</a> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf each (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a> ≡ <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt>\o -&gt; <a>getProduct</a> <a>.</a>
--   <a>foldMapOf</a> o <a>Product</a></tt>.
productOf :: (Is k A_Fold, Num a) => Optic' k is s a -> s -> a

-- | Calculate the <a>Sum</a> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf each (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded % each) [(1,2),(3,4)]
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a> ≡ <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt>\o -&gt; <a>getSum</a> <a>.</a>
--   <a>foldMapOf</a> o <a>Sum</a></tt>
sumOf :: (Is k A_Fold, Num a) => Optic' k is s a -> s -> a

-- | The sum of a collection of actions.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>asum</a> ≡ <a>asumOf</a> <a>folded</a>
--   </pre>
asumOf :: (Is k A_Fold, Alternative f) => Optic' k is s (f a) -> s -> f a

-- | The sum of a collection of actions.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a> ≡ <a>msumOf</a> <a>folded</a>
--   </pre>
msumOf :: (Is k A_Fold, MonadPlus m) => Optic' k is s (m a) -> s -> m a

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf each "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a> ≡ <a>elemOf</a> <a>folded</a>
--   </pre>
elemOf :: (Is k A_Fold, Eq a) => Optic' k is s a -> a -> s -> Bool

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a> ≡ <a>notElemOf</a> <a>folded</a>
--   </pre>
notElemOf :: (Is k A_Fold, Eq a) => Optic' k is s a -> a -> s -> Bool

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a> ≡ <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf folded [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (folded % folded) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
lengthOf :: Is k A_Fold => Optic' k is s a -> s -> Int

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf folded [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf folded []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded % filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <a>maximum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt>\o -&gt; <a>getMax</a> .
--   <a>foldMapOf</a> o <a>Max</a></tt> has lazier semantics but could leak
--   memory.
maximumOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf folded [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf folded []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded % filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>minimum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt>\o -&gt; <a>getMin</a> .
--   <a>foldMapOf</a> o <a>Min</a></tt> has lazier semantics but could leak
--   memory.
minimumOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Maybe a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>
--   according to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf folded (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
maximumByOf :: Is k A_Fold => Optic' k is s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>
--   according to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf folded (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <a>minimumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
minimumByOf :: Is k A_Fold => Optic' k is s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | The <a>findOf</a> function takes a <a>Fold</a>, a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>find</a> ≡ <a>findOf</a> <a>folded</a>
--   </pre>
findOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Maybe a

-- | The <a>findMOf</a> function takes a <a>Fold</a>, a monadic predicate
--   and a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each (\x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each (\x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   </pre>
findMOf :: (Is k A_Fold, Monad m) => Optic' k is s a -> (a -> m Bool) -> s -> m (Maybe a)

-- | The <a>lookupOf</a> function takes a <a>Fold</a>, a key, and a
--   structure containing key/value pairs. It returns the first value
--   corresponding to the given key. This function generalizes
--   <a>lookup</a> to work on an arbitrary <a>Fold</a> instead of lists.
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 4 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 2 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'a'
--   </pre>
lookupOf :: (Is k A_Fold, Eq a) => Optic' k is s (a, v) -> a -> s -> Maybe v

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including
--   itself.
universeOf :: Is k A_Fold => Optic' k is a a -> a -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself.
cosmosOf :: forall k is a. Is k A_Fold => Optic' k is a a -> Fold a a

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
paraOf :: Is k A_Fold => Optic' k is a a -> (a -> [r] -> r) -> a -> r

-- | Convert a fold to an <a>AffineFold</a> that visits the first element
--   of the original fold.
--   
--   For the traversal version see <a>singular</a>.
pre :: Is k A_Fold => Optic' k is s a -> AffineFold s a

-- | This allows you to traverse the elements of a <a>Fold</a> in the
--   opposite order.
backwards_ :: Is k A_Fold => Optic' k is s a -> Fold s a

-- | Return entries of the first <a>Fold</a>, then the second one.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (_1 % ix 0 `summing` _2 % ix 1) ([1,2], [4,7,1])
--   [1,7]
--   </pre>
--   
--   For the traversal version see <a>adjoin</a>.
summing :: (Is k A_Fold, Is l A_Fold) => Optic' k is s a -> Optic' l js s a -> Fold s a
infixr 6 `summing`

-- | Try the first <a>Fold</a>. If it returns no entries, try the second
--   one.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ix 1 `failing` ix 0) [4,7]
--   [7]
--   
--   &gt;&gt;&gt; toListOf (ix 1 `failing` ix 0) [4]
--   [4]
--   </pre>
failing :: (Is k A_Fold, Is l A_Fold) => Optic' k is s a -> Optic' l js s a -> Fold s a
infixl 3 `failing`

-- | Tag for a fold.
data A_Fold :: OpticKind


-- | An <a>IxAffineFold</a> is an indexed version of an <a>AffineFold</a>.
--   See the "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxAffineFold

-- | Type synonym for an indexed affine fold.
type IxAffineFold i s a = Optic' An_AffineFold (WithIx i) s a

-- | Create an <a>IxAffineFold</a> from a partial function.
iafolding :: (s -> Maybe (i, a)) -> IxAffineFold i s a

-- | Retrieve the value along with its index targeted by an
--   <a>IxAffineFold</a>.
ipreview :: (Is k An_AffineFold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Retrieve a function of the value and its index targeted by an
--   <a>IxAffineFold</a>.
ipreviews :: (Is k An_AffineFold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r) -> s -> Maybe r

-- | Obtain an <a>IxAffineFold</a> by lifting <tt>itraverse_</tt> like
--   function.
--   
--   <pre>
--   <tt>aifoldVL</tt> <a>.</a> <a>iatraverseOf_</a> ≡ <a>id</a>
--   <tt>aitraverseOf_</tt> <a>.</a> <a>iafoldVL</a> ≡ <a>id</a>
--   </pre>
iafoldVL :: (forall f. Functor f => (forall r. r -> f r) -> (i -> a -> f u) -> s -> f v) -> IxAffineFold i s a

-- | Traverse over the target of an <a>IxAffineFold</a>, computing a
--   <a>Functor</a>-based answer, but unlike <a>iatraverseOf</a> do not
--   construct a new structure.
iatraverseOf_ :: (Is k An_AffineFold, Functor f, is `HasSingleIndex` i) => Optic' k is s a -> (forall r. r -> f r) -> (i -> a -> f u) -> s -> f ()

-- | Obtain a potentially empty <a>IxAffineFold</a> by taking the element
--   from another <a>AffineFold</a> and using it as an index.
filteredBy :: Is k An_AffineFold => Optic' k is a i -> IxAffineFold i a a

-- | Try the first <a>IxAffineFold</a>. If it returns no entry, try the
--   second one.
iafailing :: (Is k An_AffineFold, Is l An_AffineFold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxAffineFold i s a
infixl 3 `iafailing`

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind


-- | An <a>IxAffineTraversal</a> is an indexed version of an
--   <a>AffineTraversal</a>. See the "Indexed optics" section of the
--   overview documentation in the <tt>Optics</tt> module of the main
--   <tt>optics</tt> package for more details on indexed optics.
module Optics.IxAffineTraversal

-- | Type synonym for a type-modifying indexed affine traversal.
type IxAffineTraversal i s t a b = Optic An_AffineTraversal (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed affine traversal.
type IxAffineTraversal' i s a = Optic' An_AffineTraversal (WithIx i) s a

-- | Build an indexed affine traversal from a matcher and an updater.
--   
--   If you want to build an <a>IxAffineTraversal</a> from the van
--   Laarhoven representation, use <a>iatraversalVL</a>.
iatraversal :: (s -> Either t (i, a)) -> (s -> b -> t) -> IxAffineTraversal i s t a b

-- | Obtain a potentially empty <a>IxAffineTraversal</a> by taking the
--   element from another <a>AffineFold</a> and using it as an index.
--   
--   <ul>
--   <li>- <i>Note:</i> This is <i>not</i> a legal <a>IxTraversal</a>,
--   unless you are very careful not to invalidate the predicate on the
--   target (see <a>unsafeFiltered</a> for more details).</li>
--   </ul>
unsafeFilteredBy :: Is k An_AffineFold => Optic' k is a i -> IxAffineTraversal' i a a

-- | This is the trivial empty <a>IxAffineTraversal</a>, i.e. the optic
--   that targets no substructures.
--   
--   This is the identity element when a <a>Fold</a>, <a>AffineFold</a>,
--   <a>IxFold</a>, <a>IxAffineFold</a>, <a>Traversal</a> or
--   <a>IxTraversal</a> is viewed as a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: IxAffineTraversal i s s a b

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed affine
--   traversal.
--   
--   Note: this isn't exactly van Laarhoven representation as there is no
--   <tt>Pointed</tt> class (which would be a superclass of
--   <a>Applicative</a> that contains <a>pure</a> but not
--   <a>&lt;*&gt;</a>). You can interpret the first argument as a
--   dictionary of <tt>Pointed</tt> that supplies the <tt>point</tt>
--   function (i.e. the implementation of <a>pure</a>).
type IxAffineTraversalVL i s t a b = forall f. Functor f => (forall r. r -> f r) -> (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed affine
--   traversal.
type IxAffineTraversalVL' i s a = IxAffineTraversalVL i s s a a

-- | Build an indexed affine traversal from the van Laarhoven
--   representation.
iatraversalVL :: IxAffineTraversalVL i s t a b -> IxAffineTraversal i s t a b

-- | Traverse over the target of an <a>IxAffineTraversal</a> and compute a
--   <a>Functor</a>-based answer.
iatraverseOf :: (Is k An_AffineTraversal, Functor f, is `HasSingleIndex` i) => Optic k is s t a b -> (forall r. r -> f r) -> (i -> a -> f b) -> s -> f t


-- | An <a>IxFold</a> is an indexed version of a <a>Fold</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxFold

-- | Type synonym for an indexed fold.
type IxFold i s a = Optic' A_Fold (WithIx i) s a

-- | Obtain an indexed fold by lifting <a>itraverse_</a> like function.
--   
--   <pre>
--   <a>ifoldVL</a> <a>.</a> <a>itraverseOf_</a> ≡ <a>id</a>
--   <a>itraverseOf_</a> <a>.</a> <a>ifoldVL</a> ≡ <a>id</a>
--   </pre>
ifoldVL :: (forall f. Applicative f => (i -> a -> f u) -> s -> f v) -> IxFold i s a

-- | Fold with index via embedding into a monoid.
ifoldMapOf :: (Is k A_Fold, Monoid m, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> m) -> s -> m

-- | Fold with index right-associatively.
ifoldrOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold with index left-associatively, and strictly.
ifoldlOf' :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Fold with index to a list.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (folded % ifolded) ["abc", "def"]
--   [(0,'a'),(1,'b'),(2,'c'),(0,'d'),(1,'e'),(2,'f')]
--   </pre>
--   
--   <i>Note:</i> currently indexed optics can be used as non-indexed.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (folded % ifolded) ["abc", "def"]
--   "abcdef"
--   </pre>
itoListOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> [(i, a)]

-- | Traverse over all of the targets of an <a>IxFold</a>, computing an
--   <a>Applicative</a>-based answer, but unlike <a>itraverseOf</a> do not
--   construct a new structure.
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ each (curry print) ("hello","world")
--   (0,"hello")
--   (1,"world")
--   </pre>
itraverseOf_ :: (Is k A_Fold, Applicative f, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> f r) -> s -> f ()

-- | A version of <a>itraverseOf_</a> with the arguments flipped.
iforOf_ :: (Is k A_Fold, Applicative f, is `HasSingleIndex` i) => Optic' k is s a -> s -> (i -> a -> f r) -> f ()

-- | Indexed fold via <a>FoldableWithIndex</a> class.
ifolded :: FoldableWithIndex i f => IxFold i (f a) a

-- | Obtain an <a>IxFold</a> by lifting an operation that returns a
--   <a>FoldableWithIndex</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into an <a>IxFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolding words) "how are you"
--   [(0,"how"),(1,"are"),(2,"you")]
--   </pre>
ifolding :: FoldableWithIndex i f => (s -> f a) -> IxFold i s a

-- | Obtain an <a>IxFold</a> by lifting <a>ifoldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifoldring ifoldr) "hello"
--   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
ifoldring :: (forall f. Applicative f => (i -> a -> f u -> f u) -> f v -> s -> f w) -> IxFold i s a

-- | Retrieve the first entry of an <a>IxFold</a> along with its index.
--   
--   <pre>
--   &gt;&gt;&gt; iheadOf ifolded [1..10]
--   Just (0,1)
--   </pre>
iheadOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Retrieve the last entry of an <a>IxFold</a> along with its index.
--   
--   <pre>
--   &gt;&gt;&gt; ilastOf ifolded [1..10]
--   Just (9,10)
--   </pre>
ilastOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Return whether or not any element viewed through an <a>IxFold</a>
--   satisfies a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> o ≡ <a>ianyOf</a> o <a>.</a> <a>const</a>
--   </pre>
ianyOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an <a>IxFold</a>
--   satisfy a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> o ≡ <a>iallOf</a> o <a>.</a> <a>const</a>
--   </pre>
iallOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not none of the elements viewed through an
--   <a>IxFold</a> satisfy a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> o ≡ <a>inoneOf</a> o <a>.</a> <a>const</a>
--   </pre>
inoneOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | The <a>ifindOf</a> function takes an <a>IxFold</a>, a predicate that
--   is also supplied the index, a structure and returns the left-most
--   element of the structure along with its index matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
ifindOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Maybe (i, a)

-- | The <a>ifindMOf</a> function takes an <a>IxFold</a>, a monadic
--   predicate that is also supplied the index, a structure and returns in
--   the monad the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
ifindMOf :: (Is k A_Fold, Monad m, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> m Bool) -> s -> m (Maybe (i, a))

-- | Convert an indexed fold to an <a>IxAffineFold</a> that visits the
--   first element of the original fold.
--   
--   For the traversal version see <a>isingular</a>.
ipre :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> IxAffineFold i s a

-- | Filter results of an <a>IxFold</a> that don't satisfy a predicate.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (&gt;)) [3,2,1,0]
--   [1,0]
--   </pre>
ifiltered :: (Is k A_Fold, is `HasSingleIndex` i) => (i -> a -> Bool) -> Optic' k is s a -> IxFold i s a

-- | This allows you to traverse the elements of an <a>IxFold</a> in the
--   opposite order.
ibackwards_ :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> IxFold i s a

-- | Return entries of the first <a>IxFold</a>, then the second one.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded `isumming` ibackwards_ ifolded) ["a","b"]
--   [(0,"a"),(1,"b"),(1,"b"),(0,"a")]
--   </pre>
--   
--   For the traversal version see <a>iadjoin</a>.
isumming :: (Is k A_Fold, Is l A_Fold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxFold i s a
infixr 6 `isumming`

-- | Try the first <a>IxFold</a>. If it returns no entries, try the second
--   one.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (_1 % ifolded `ifailing` _2 % ifolded) (["a"], ["b","c"])
--   [(0,"a")]
--   
--   &gt;&gt;&gt; itoListOf (_1 % ifolded `ifailing` _2 % ifolded) ([], ["b","c"])
--   [(0,"b"),(1,"c")]
--   </pre>
ifailing :: (Is k A_Fold, Is l A_Fold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxFold i s a
infixl 3 `ifailing`

-- | Tag for a fold.
data A_Fold :: OpticKind

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b


-- | An <a>IxGetter</a> is an indexed version of a <a>Getter</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxGetter

-- | Type synonym for an indexed getter.
type IxGetter i s a = Optic' A_Getter (WithIx i) s a

-- | Build an indexed getter from a function.
--   
--   <pre>
--   &gt;&gt;&gt; iview (ito id) ('i', 'x')
--   ('i','x')
--   </pre>
ito :: (s -> (i, a)) -> IxGetter i s a

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>equality</a>.
selfIndex :: IxGetter a a a

-- | View the value pointed to by an indexed getter.
iview :: (Is k A_Getter, is `HasSingleIndex` i) => Optic' k is s a -> s -> (i, a)

-- | View the function of the value pointed to by an indexed getter.
iviews :: (Is k A_Getter, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r) -> s -> r

-- | Tag for a getter.
data A_Getter :: OpticKind


-- | An <a>IxLens</a> is an indexed version of a <a>Lens</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxLens

-- | Type synonym for a type-modifying indexed lens.
type IxLens i s t a b = Optic A_Lens (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed lens.
type IxLens' i s a = Optic' A_Lens (WithIx i) s a

-- | Build an indexed lens from a getter and a setter.
--   
--   If you want to build an <a>IxLens</a> from the van Laarhoven
--   representation, use <a>ilensVL</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IxLens i s t a b

-- | Focus on both sides of an <a>Either</a>.
chosen :: IxLens (Either () ()) (Either a a) (Either b b) a b

-- | There is an indexed field for every type in the <a>Void</a>.
--   
--   <pre>
--   &gt;&gt;&gt; set (mapped % devoid) 1 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (_Just % devoid) abs Nothing
--   Nothing
--   </pre>
devoid :: IxLens' i Void a

-- | Indexed <tt>_1</tt> with other half of a pair as an index.
--   
--   See <a>isnd</a> for examples.
ifst :: IxLens i (a, i) (b, i) a b

-- | Indexed <tt>_2</tt> with other half of a pair as an index. Specialized
--   version of <tt>itraversed</tt> to pairs, which can be <a>IxLens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iview isnd ('a', True)
--   ('a',True)
--   </pre>
--   
--   That is not possible with <tt>itraversed</tt>, because it is an
--   <tt>IxTraversal</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :t itraversed :: IxTraversal i (i, a) (i, b) a b
--   itraversed :: IxTraversal i (i, a) (i, b) a b
--     :: IxTraversal i (i, a) (i, b) a b
--   </pre>
isnd :: IxLens i (i, a) (i, b) a b

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed lens.
type IxLensVL i s t a b = forall f. Functor f => (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed lens.
type IxLensVL' i s a = IxLensVL i s s a a

-- | Build an indexed lens from the van Laarhoven representation.
ilensVL :: IxLensVL i s t a b -> IxLens i s t a b

-- | Convert an indexed lens to its van Laarhoven representation.
toIxLensVL :: (Is k A_Lens, is `HasSingleIndex` i) => Optic k is s t a b -> IxLensVL i s t a b

-- | Work with an indexed lens in the van Laarhoven representation.
withIxLensVL :: (Is k A_Lens, is `HasSingleIndex` i) => Optic k is s t a b -> (IxLensVL i s t a b -> r) -> r


-- | An <a>IxSetter</a> is an indexed version of a <a>Setter</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxSetter

-- | Type synonym for a type-modifying indexed setter.
type IxSetter i s t a b = Optic A_Setter (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed setter.
type IxSetter' i s a = Optic' A_Setter (WithIx i) s a

-- | Build an indexed setter from a function to modify the element(s).
isets :: ((i -> a -> b) -> s -> t) -> IxSetter i s t a b

-- | Apply an indexed setter as a modifier.
iover :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> t

-- | Indexed setter via the <a>FunctorWithIndex</a> class.
--   
--   <pre>
--   <a>iover</a> <a>imapped</a> ≡ <a>imap</a>
--   </pre>
imapped :: FunctorWithIndex i f => IxSetter i (f a) (f b) a b

-- | Apply an indexed setter.
--   
--   <pre>
--   <a>iset</a> o f ≡ <a>iover</a> o (i _ -&gt; f i)
--   </pre>
iset :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> b) -> s -> t

-- | Apply an indexed setter, strictly.
iset' :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> b) -> s -> t

-- | Apply an indexed setter as a modifier, strictly.
iover' :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> t

-- | Tag for a setter.
data A_Setter :: OpticKind

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b


-- | A <a>Lens</a> is a generalised or first-class field.
--   
--   If we have a value <tt>s :: S</tt>, and a <tt>l :: <a>Lens'</a> S
--   A</tt>, we can <i>get</i> the "field value" of type <tt>A</tt> using
--   <tt><a>view</a> l s</tt>. We can also <i>update</i> (or <i>put</i> or
--   <i>set</i>) the value using <a>over</a> (or <a>set</a>).
--   
--   For example, given the following definitions:
--   
--   <pre>
--   &gt;&gt;&gt; data Human = Human { _name :: String, _location :: String } deriving Show
--   
--   &gt;&gt;&gt; let human = Human "Bob" "London"
--   </pre>
--   
--   we can make a <a>Lens</a> for <tt>_name</tt> field:
--   
--   <pre>
--   &gt;&gt;&gt; let name = lens _name $ \s x -&gt; s { _name = x }
--   </pre>
--   
--   which we can use as a <a>Getter</a>:
--   
--   <pre>
--   &gt;&gt;&gt; view name human
--   "Bob"
--   </pre>
--   
--   or a <a>Setter</a>:
--   
--   <pre>
--   &gt;&gt;&gt; set name "Robert" human
--   Human {_name = "Robert", _location = "London"}
--   </pre>
module Optics.Lens

-- | Type synonym for a type-modifying lens.
type Lens s t a b = Optic A_Lens NoIx s t a b

-- | Type synonym for a type-preserving lens.
type Lens' s a = Optic' A_Lens NoIx s a

-- | Build a lens from a getter and a setter, which must respect the
--   well-formedness laws.
--   
--   If you want to build a <a>Lens</a> from the van Laarhoven
--   representation, use <a>lensVL</a>.
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Strict version of <a>equality</a>.
--   
--   Useful for strictifying optics with lazy (irrefutable) pattern
--   matching by precomposition, e.g.
--   
--   <pre>
--   <a>_1'</a> = <a>equality'</a> % <a>_1</a>
--   </pre>
equality' :: Lens a b a b

-- | Make a <a>Lens</a> from two other lenses by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left 'a', Right 'b') ^. alongside chosen chosen
--   ('a','b')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left 'a', Right 'b') &amp; alongside chosen chosen .~ ('c','d')
--   (Left 'c',Right 'd')
--   </pre>
alongside :: (Is k A_Lens, Is l A_Lens) => Optic k is s t a b -> Optic l js s' t' a' b' -> Lens (s, s') (t, t') (a, a') (b, b')

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; view united "hello"
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set united () "hello"
--   "hello"
--   </pre>
united :: Lens' a ()

-- | Work with a lens as a getter and a setter.
--   
--   <pre>
--   <a>withLens</a> (<a>lens</a> f g) k ≡ k f g
--   </pre>
withLens :: Is k A_Lens => Optic k is s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven lens.
type LensVL s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven lens.
type LensVL' s a = LensVL s s a a

-- | Build a lens from the van Laarhoven representation.
lensVL :: LensVL s t a b -> Lens s t a b

-- | Convert a lens to the van Laarhoven representation.
toLensVL :: Is k A_Lens => Optic k is s t a b -> LensVL s t a b

-- | Work with a lens in the van Laarhoven representation.
withLensVL :: Is k A_Lens => Optic k is s t a b -> (LensVL s t a b -> r) -> r


-- | This module defines optics for manipulating <a>Tree</a>s.
module Data.Tree.Optics

-- | A <a>Lens</a> that focuses on the root of a <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; view root $ Node 42 []
--   42
--   </pre>
root :: Lens' (Tree a) a

-- | A <a>Lens</a> returning the direct descendants of the root of a
--   <a>Tree</a>
--   
--   <pre>
--   <a>view</a> <a>branches</a> ≡ <a>subForest</a>
--   </pre>
branches :: Lens' (Tree a) [Tree a]


-- | This module provides core definitions:
--   
--   <ul>
--   <li>an opaque <a>Optic</a> type, which is parameterised over a type
--   representing an optic kind (instantiated with tag types such as
--   <a>A_Lens</a>);</li>
--   <li>the optic composition operator (<a>%</a>);</li>
--   <li>the subtyping relation <a>Is</a> with an accompanying
--   <a>castOptic</a> function to convert an optic kind;</li>
--   <li>the <a>JoinKinds</a> class used to find the optic kind resulting
--   from a composition.</li>
--   </ul>
--   
--   Each optic kind is identified by a "tag type" (such as <a>A_Lens</a>),
--   which is an empty data type. The type of the actual optics (such as
--   <a>Lens</a>) is obtained by applying <a>Optic</a> to the tag type.
--   
--   See the <tt>Optics</tt> module in the main <tt>optics</tt> package for
--   overview documentation.
module Optics.Optic

-- | Kind for types used as optic tags, such as <a>A_Lens</a>.
type OpticKind = Type

-- | Wrapper newtype for the whole family of optics.
--   
--   The first parameter <tt>k</tt> identifies the particular optic kind
--   (e.g. <a>A_Lens</a> or <a>A_Traversal</a>).
--   
--   The parameter <tt>is</tt> is a list of types available as indices.
--   This will typically be <a>NoIx</a> for unindexed optics, or
--   <a>WithIx</a> for optics with a single index. See the "Indexed optics"
--   section of the overview documentation in the <tt>Optics</tt> module of
--   the main <tt>optics</tt> package for more details.
--   
--   The parameters <tt>s</tt> and <tt>t</tt> represent the "big"
--   structure, whereas <tt>a</tt> and <tt>b</tt> represent the "small"
--   structure.
data Optic (k :: OpticKind) (is :: IxList) s t a b

-- | Common special case of <a>Optic</a> where source and target types are
--   equal.
--   
--   Here, we need only one "big" and one "small" type. For lenses, this
--   means that in the restricted form we cannot do type-changing updates.
type Optic' k is s a = Optic k is s s a a

-- | Explicit cast from one optic flavour to another.
--   
--   The resulting optic kind is given in the first type argument, so you
--   can use TypeApplications to set it. For example
--   
--   <pre>
--   <a>castOptic</a> @<a>A_Lens</a> o
--   </pre>
--   
--   turns <tt>o</tt> into a <a>Lens</a>.
--   
--   This is the identity function, modulo some constraint jiggery-pokery.
castOptic :: forall destKind srcKind is s t a b. Is srcKind destKind => Optic srcKind is s t a b -> Optic destKind is s t a b

-- | Subtyping relationship between kinds of optics.
--   
--   An instance of <tt><a>Is</a> k l</tt> means that any <tt><a>Optic</a>
--   k</tt> can be used as an <tt><a>Optic</a> l</tt>. For example, we have
--   an <tt><a>Is</a> <a>A_Lens</a> <a>A_Traversal</a></tt> instance, but
--   not <tt><a>Is</a> <a>A_Traversal</a> <a>A_Lens</a></tt>.
--   
--   This class needs instances for all possible combinations of tags.
class Is k l

-- | Computes the least upper bound of two optics kinds.
--   
--   In presence of a <tt>JoinKinds k l m</tt> constraint <tt>Optic m</tt>
--   represents the least upper bound of an <tt>Optic k</tt> and an
--   <tt>Optic l</tt>. This means in particular that composition of an
--   <tt>Optic k</tt> and an <tt>Optic k</tt> will yield an <tt>Optic
--   m</tt>.
class JoinKinds k l m | k l -> m

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: forall k l m is js ks s t u v a b. (JoinKinds k l m, AppendIndices is js ks) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two optics of the same flavour.
--   
--   Normally you can simply use (<a>%</a>) instead, but this may be useful
--   to help type inference if the type of one of the optics is otherwise
--   under-constrained.
(%%) :: forall k is js ks s t u v a b. AppendIndices is js ks => Optic k is s t u v -> Optic k js u v a b -> Optic k ks s t a b
infixl 9 %%

-- | Flipped function application, specialised to optics and binding
--   tightly.
--   
--   Useful for post-composing optics transformations:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (\i s -&gt; length s &lt;= i)) ["", "a","abc"]
--   ["","a"]
--   </pre>
(%&) :: Optic k is s t a b -> (Optic k is s t a b -> Optic l js s' t' a' b') -> Optic l js s' t' a' b'
infixl 9 %&

-- | A list of index types, used for indexed optics.
type IxList = [Type]

-- | An alias for an empty index-list
type NoIx = ('[] :: IxList)

-- | Singleton index list
type WithIx i = ('[i] :: IxList)

-- | In pseudo (dependent-)Haskell, provide a witness
--   
--   <pre>
--   foldr f (foldr f init xs) ys = foldr f init (ys ++ xs)
--      where f = (-&gt;)
--   </pre>
class AppendIndices xs ys ks | xs ys -> ks

-- | Check whether a list of indices is not empty and generate sensible
--   error message if it's not.
class NonEmptyIndices (is :: IxList)

-- | Generate sensible error messages in case a user tries to pass either
--   an unindexed optic or indexed optic with unflattened indices where
--   indexed optic with a single index is expected.
class is ~ '[i] => HasSingleIndex (is :: IxList) (i :: Type)

-- | Show useful error message when a function expects optics without
--   indices.
class is ~ NoIx => AcceptsEmptyIndices (f :: Symbol) (is :: IxList)

-- | Curry a type-level list.
--   
--   In pseudo (dependent-)Haskell:
--   
--   <pre>
--   <a>Curry</a> xs y = <a>foldr</a> (-&gt;) y xs
--   </pre>
type family Curry (xs :: IxList) (y :: Type) :: Type

-- | Class that is inhabited by all type-level lists <tt>xs</tt>, providing
--   the ability to compose a function under <tt><a>Curry</a> xs</tt>.
class CurryCompose xs

-- | Compose a function under <tt><a>Curry</a> xs</tt>. This generalises
--   <tt>(<a>.</a>)</tt> (aka <a>fmap</a> for <tt>(-&gt;)</tt>) to work for
--   curried functions with one argument for each type in the list.
composeN :: CurryCompose xs => (i -> j) -> Curry xs i -> Curry xs j

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

module Optics.Core.Extras

-- | Check to see if this <a>AffineFold</a> matches.
--   
--   <pre>
--   &gt;&gt;&gt; is _Just Nothing
--   False
--   </pre>
is :: Is k An_AffineFold => Optic' k is s a -> s -> Bool


-- | This module exists to provide documentation for lenses for working
--   with <a>Map</a>, which might otherwise be obscured by their
--   genericity.
--   
--   <a>Map</a> is an instance of <a>At</a> and provides <a>at</a> as a
--   lens on values at keys:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1, "world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 1 .~ Just "world"
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 0 .~ Just "hello"
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in a
--   <a>Map</a>, thanks to indexed traversals, folds and setters.
--   
--   <pre>
--   &gt;&gt;&gt; iover imapped const $ Map.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMapOf ifolded (\i _ -&gt; Sum i) $ Map.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ ifolded (curry print) $ Map.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf ifolded $ Map.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(2, "Earth")] &amp; ix 2 %~ ("New " ++)
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) Map.empty
--   Nothing
--   </pre>
module Data.Map.Optics

-- | Construct a map from an <a>IxFold</a>.
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurrences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a',"alpha"),('b', "beta")]
--   fromList [('a',"alpha"),('b',"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (ifolded &lt;%&gt; ifolded) ["foo", "bar"]
--   fromList [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a', "hello"), ('b', "world"), ('a', "dummy")]
--   fromList [('a',"hello"),('b',"world")]
--   </pre>
toMapOf :: (Is k A_Fold, is `HasSingleIndex` i, Ord i) => Optic' k is s a -> s -> Map i a

-- | Focus on the largest key smaller than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (lt 'b') (++ "!")
--   fromList [('a',"hi!"),('b',"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (lt 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Nothing
--   </pre>
lt :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the smallest key greater than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (gt 'b') (++ "!")
--   fromList [('a',"hi"),('b',"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (gt 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Just ('b','y')
--   </pre>
gt :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the largest key smaller or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (le 'b') (++ "!")
--   fromList [('a',"hi"),('b',"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (le 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Just ('a','x')
--   </pre>
le :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the smallest key greater or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('c', "there")] &amp; over (ge 'b') (++ "!")
--   fromList [('a',"hi"),('c',"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (ge 'b') $ Map.fromList [('a', 'x'), ('c', 'y')]
--   Just ('c','y')
--   </pre>
ge :: Ord k => k -> IxAffineTraversal' k (Map k v) v


-- | <a>IntMap</a> is an instance of <a>At</a> and provides <a>at</a> as a
--   lens on values at keys:
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.empty &amp; at 1 .~ Just "world"
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.empty &amp; at 0 .~ Just "hello"
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in an
--   <a>IntMap</a>, thanks to indexed traversals, folds and setters.
--   
--   <pre>
--   &gt;&gt;&gt; iover imapped const $ IntMap.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMapOf ifolded (\i _ -&gt; Sum i) $ IntMap.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ ifolded (curry print) $ IntMap.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf ifolded $ IntMap.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(2, "Earth")] &amp; ix 2 %~ ("New " ++)
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) IntMap.empty
--   Nothing
--   </pre>
module Data.IntMap.Optics

-- | Construct a map from an <a>IxFold</a>.
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurrences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [(1,"alpha"),(2, "beta")]
--   fromList [(1,"alpha"),(2,"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (icompose (\a b -&gt; 10*a+b) $ ifolded % ifolded) ["foo", "bar"]
--   fromList [(0,'f'),(1,'o'),(2,'o'),(10,'b'),(11,'a'),(12,'r')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [(1, "hello"), (2, "world"), (1, "dummy")]
--   fromList [(1,"hello"),(2,"world")]
--   </pre>
toMapOf :: (Is k A_Fold, is `HasSingleIndex` Int) => Optic' k is s a -> s -> IntMap a

-- | Focus on the largest key smaller than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (lt 2) (++ "!")
--   fromList [(1,"hi!"),(2,"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (lt 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Nothing
--   </pre>
lt :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the smallest key greater than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (gt 2) (++ "!")
--   fromList [(1,"hi"),(2,"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (gt 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Just (2,'y')
--   </pre>
gt :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the largest key smaller or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (le 2) (++ "!")
--   fromList [(1,"hi"),(2,"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (le 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Just (1,'x')
--   </pre>
le :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the smallest key greater or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (3, "there")] &amp; over (ge 2) (++ "!")
--   fromList [(1,"hi"),(3,"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (ge 2) $ IntMap.fromList [(1, 'x'), (3, 'y')]
--   Just (3,'y')
--   </pre>
ge :: Int -> IxAffineTraversal' Int (IntMap v) v


-- | A <a>Prism</a> generalises the notion of a constructor (just as a
--   <a>Lens</a> generalises the notion of a field).
module Optics.Prism

-- | Type synonym for a type-modifying prism.
type Prism s t a b = Optic A_Prism NoIx s t a b

-- | Type synonym for a type-preserving prism.
type Prism' s a = Optic' A_Prism NoIx s a

-- | Build a prism from a constructor and a matcher, which must respect the
--   well-formedness laws.
--   
--   If you want to build a <a>Prism</a> from the van Laarhoven
--   representation, use <tt>prismVL</tt> from the <tt>optics-vl</tt>
--   package.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing, an example where the value is the empty
--   list and the predicate checks that a list is empty (same as
--   <a>_Empty</a> with the <a>AsEmpty</a> list instance):
--   
--   <pre>
--   &gt;&gt;&gt; nearly [] null # ()
--   []
--   
--   &gt;&gt;&gt; [1,2,3,4] ^? nearly [] null
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>nearly</a> [] <a>null</a> :: <a>Prism'</a> [a] ()
--   </pre>
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x ≡ a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()

-- | Work with a <a>Prism</a> as a constructor and a matcher.
withPrism :: Is k A_Prism => Optic k is s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: Is k A_Prism => Optic k is s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: (Is k A_Prism, Is l A_Prism) => Optic k is s t a b -> Optic l is u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | Lift a <a>Prism</a> through a <a>Traversable</a> functor, giving a
--   <a>Prism</a> that matches only if all the elements of the container
--   match the <a>Prism</a>.
below :: (Is k A_Prism, Traversable f) => Optic' k is s a -> Prism' (f s) (f a)

-- | Tag for a prism.
data A_Prism :: OpticKind


-- | This module defines <a>Prism</a>s for the constructors of the
--   <a>Maybe</a> datatype.
module Data.Maybe.Optics

-- | A <a>Prism</a> that matches on the <a>Nothing</a> constructor of
--   <a>Maybe</a>.
_Nothing :: Prism' (Maybe a) ()

-- | A <a>Prism</a> that matches on the <a>Just</a> constructor of
--   <a>Maybe</a>.
_Just :: Prism (Maybe a) (Maybe b) a b

-- | Shortcut for <tt><a>%</a> <a>_Just</a> <a>%</a></tt>.
--   
--   Useful for composing lenses of <a>Maybe</a> type.
(%?) :: (AppendIndices is js ks, JoinKinds k A_Prism k', JoinKinds k' l m) => Optic k is s t (Maybe u) (Maybe v) -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %?


-- | Additional optics for manipulating lists are present more generically
--   in this package.
--   
--   The <a>Ixed</a> class allows traversing the element at a specific list
--   index.
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 4
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 4 .~ 2
--   [0,1,2,3,2,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 14
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 14 .~ 2
--   [0,1,2,3,4,5]
--   </pre>
--   
--   The <a>Cons</a> and <a>AsEmpty</a> classes provide <a>Prism</a>s for
--   list constructors.
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^? _Cons
--   Just (1,[2,3,4,5,6,7,8,9,10])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Cons
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Empty
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Cons # (1, _Empty # ()) :: [Int]
--   [1]
--   </pre>
--   
--   Additionally, <a>Snoc</a> provides a <a>Prism</a> for accessing the
--   end of a list. Note that this <a>Prism</a> always will need to
--   traverse the whole list.
--   
--   <pre>
--   &gt;&gt;&gt; [1..5] ^? _Snoc
--   Just ([1,2,3,4],5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Snoc # ([1,2],5)
--   [1,2,5]
--   </pre>
--   
--   Finally, it's possible to traverse, fold over, and map over
--   index-value pairs thanks to instances of <a>TraversableWithIndex</a>,
--   <a>FoldableWithIndex</a>, and <a>FunctorWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; imap (,) "Hello"
--   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap replicate "Hello"
--   "ellllloooo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverse_ (curry print) "Hello"
--   (0,'H')
--   (1,'e')
--   (2,'l')
--   (3,'l')
--   (4,'o')
--   </pre>
module Data.List.Optics

-- | A <a>Prism</a> stripping a prefix from a list when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Eq a => [a] -> Prism' [a] [a]

-- | A <a>Prism</a> stripping a suffix from a list when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Eq a => [a] -> Prism' [a] [a]


-- | This module defines <a>Prism</a>s for the constructors of the
--   <a>Either</a> datatype.
module Data.Either.Optics

-- | A <a>Prism</a> that matches on the <a>Left</a> constructor of
--   <a>Either</a>.
_Left :: Prism (Either a b) (Either c b) a c

-- | A <a>Prism</a> that matches on the <a>Right</a> constructor of
--   <a>Either</a>.
_Right :: Prism (Either a b) (Either a c) b c


-- | Some optics can be reversed with <a>re</a>. This is mainly useful to
--   invert <a>Iso</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let _Identity = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view (_1 % re _Identity) ('x', "yz")
--   Identity 'x'
--   </pre>
--   
--   Yet we can use a <a>Lens</a> as a <a>Review</a> too:
--   
--   <pre>
--   &gt;&gt;&gt; review (re _1) ('x', "yz")
--   'x'
--   </pre>
--   
--   In the following diagram, red arrows illustrate how <a>re</a>
--   transforms optics. The <a>ReversedLens</a> and <a>ReversedPrism</a>
--   optic kinds are backwards versions of <a>Lens</a> and <a>Prism</a>
--   respectively, and are present so that <tt><a>re</a> . <a>re</a></tt>
--   does not change the optic kind.
--   
module Optics.Re

-- | Class for optics that can be <a>re</a>versed.
class ReversibleOptic k where {
    
    -- | Injective type family that maps an optic kind to the optic kind
    --   produced by <a>re</a>versing it.
    --   
    --   <pre>
    --   <a>ReversedOptic</a> <a>An_Iso</a>            = <a>An_Iso</a>
    --   <a>ReversedOptic</a> <a>A_Prism</a>           = <a>A_ReversedPrism</a>
    --   <a>ReversedOptic</a> <a>A_ReversedPrism</a>   = <a>A_Prism</a>
    --   <a>ReversedOptic</a> <a>A_Lens</a>            = <a>A_ReversedLens</a>
    --   <a>ReversedOptic</a> <a>A_ReversedLens</a>    = <a>A_Lens</a>
    --   <a>ReversedOptic</a> <a>A_Getter</a>          = <a>A_Review</a>
    --   <a>ReversedOptic</a> <a>A_Review</a>          = <a>A_Getter</a>
    --   </pre>
    type ReversedOptic k = r | r -> k;
}

-- | Reverses optics, turning around <a>Iso</a> into <a>Iso</a>,
--   <a>Prism</a> into <a>ReversedPrism</a> (and back), <a>Lens</a> into
--   <a>ReversedLens</a> (and back) and <a>Getter</a> into <a>Review</a>
--   (and back).
re :: (ReversibleOptic k, "re" `AcceptsEmptyIndices` is) => Optic k is s t a b -> Optic (ReversedOptic k) is b a t s
instance Data.Profunctor.Indexed.Profunctor p => Data.Profunctor.Indexed.Profunctor (Optics.Re.Re p s t)
instance Optics.Internal.Bi.Bicontravariant p => Optics.Internal.Bi.Bifunctor (Optics.Re.Re p s t)
instance Optics.Internal.Bi.Bifunctor p => Optics.Internal.Bi.Bicontravariant (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Strong p => Data.Profunctor.Indexed.Costrong (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Costrong p => Data.Profunctor.Indexed.Strong (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Choice p => Data.Profunctor.Indexed.Cochoice (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Cochoice p => Data.Profunctor.Indexed.Choice (Optics.Re.Re p s t)
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.An_Iso
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Prism
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_ReversedPrism
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Lens
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_ReversedLens
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Getter
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Review


-- | This module defines <a>getting</a>, which turns a read-write optic
--   into its read-only counterpart.
module Optics.ReadOnly

-- | Class for read-write optics that have their read-only counterparts.
class ToReadOnly k s t a b where {
    type ReadOnlyOptic k :: OpticKind;
}

-- | Turn read-write optic into its read-only counterpart (or leave
--   read-only optics as-is).
--   
--   This is useful when you have an <tt>optic :: <a>Optic</a> k is s t a
--   b</tt> of read-write kind <tt>k</tt> such that <tt>s</tt>, <tt>t</tt>,
--   <tt>a</tt>, <tt>b</tt> are rigid, there is no evidence that <tt>s ~
--   t</tt> and <tt>a ~ b</tt> and you want to pass <tt>optic</tt> to one
--   of the functions that accept read-only optic kinds.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; let fstIntToChar = _1 :: Lens (Int, r) (Char, r) Int Char
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t view fstIntToChar
--   ...
--   ...Couldn't match type ‘Char’ with ‘Int’
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t view (getting fstIntToChar)
--   view (getting fstIntToChar) :: (Int, r) -&gt; Int
--   </pre>
getting :: ToReadOnly k s t a b => Optic k is s t a b -> Optic' (ReadOnlyOptic k) is s a
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_Iso s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Lens s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Prism s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_AffineTraversal s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Traversal s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_ReversedPrism s t a b
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Getter s t a b
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_AffineFold s t a b
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Fold s t a b


-- | A <a>ReversedLens</a> is a backwards <a>Lens</a>, i.e. a
--   <tt><a>ReversedLens</a> s t a b</tt> is equivalent to a
--   <tt><a>Lens</a> b a t s</tt>. These are typically produced by calling
--   <a>re</a> on a <a>Lens</a>. They are distinguished from a
--   <a>Review</a> so that <tt><a>re</a> . <a>re</a></tt> on a <a>Lens</a>
--   returns a <a>Lens</a>.
module Optics.ReversedLens

-- | Type synonym for a type-modifying reversed lens.
type ReversedLens s t a b = Optic A_ReversedLens NoIx s t a b

-- | Type synonym for a type-preserving reversed lens.
type ReversedLens' t b = Optic' A_ReversedLens NoIx t b

-- | Tag for a reversed lens.
data A_ReversedLens :: OpticKind


-- | A <a>ReversedPrism</a> is a backwards <a>Prism</a>, i.e. a
--   <tt><a>ReversedPrism</a> s t a b</tt> is equivalent to a
--   <tt><a>Prism</a> b a t s</tt>. These are typically produced by calling
--   <a>re</a> on a <a>Prism</a>. They are distinguished from a
--   <a>Getter</a> so that <tt><a>re</a> . <a>re</a></tt> on a <a>Prism</a>
--   returns a <a>Prism</a>.
module Optics.ReversedPrism

-- | Type synonym for a type-modifying reversed prism.
type ReversedPrism s t a b = Optic A_ReversedPrism NoIx s t a b

-- | Type synonym for a type-preserving reversed prism.
type ReversedPrism' s a = Optic' A_ReversedPrism NoIx s a

-- | Tag for a reversed prism.
data A_ReversedPrism :: OpticKind


-- | A <a>Review</a> is a backwards <a>Getter</a>, i.e. a <tt><a>Review</a>
--   T B</tt> is just a function <tt>B -&gt; T</tt>.
module Optics.Review

-- | Type synonym for a review.
type Review t b = Optic' A_Review NoIx t b

-- | An analogue of <a>to</a> for reviews.
unto :: (b -> t) -> Review t b

-- | Retrieve the value targeted by a <a>Review</a>.
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "hi"
--   Left "hi"
--   </pre>
review :: Is k A_Review => Optic' k is t b -> b -> t

-- | Tag for a review.
data A_Review :: OpticKind


-- | An <a>Iso</a>morphism expresses the fact that two types have the same
--   structure, and hence can be converted from one to the other in either
--   direction.
module Optics.Iso

-- | Type synonym for a type-modifying iso.
type Iso s t a b = Optic An_Iso NoIx s t a b

-- | Type synonym for a type-preserving iso.
type Iso' s a = Optic' An_Iso NoIx s a

-- | Build an iso from a pair of inverse functions.
--   
--   If you want to build an <a>Iso</a> from the van Laarhoven
--   representation, use <tt>isoVL</tt> from the <tt>optics-vl</tt>
--   package.
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Capture type constraints as an isomorphism.
--   
--   <i>Note:</i> This is the identity optic:
--   
--   <pre>
--   &gt;&gt;&gt; :t view equality
--   view equality :: a -&gt; a
--   </pre>
equality :: (s ~ a, t ~ b) => Iso s t a b

-- | Proof of reflexivity.
simple :: Iso' a a

-- | Data types that are representationally equal are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; view coerced 'x' :: Identity Char
--   Identity 'x'
--   </pre>
coerced :: (Coercible s a, Coercible t b) => Iso s t a b

-- | Type-preserving version of <a>coerced</a> with type parameters
--   rearranged for TypeApplications.
--   
--   <pre>
--   &gt;&gt;&gt; newtype MkInt = MkInt Int deriving Show
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (coercedTo @Int) (*3) (MkInt 2)
--   MkInt 6
--   </pre>
coercedTo :: forall a s. Coercible s a => Iso' s a

-- | Special case of <a>coerced</a> for trivial newtype wrappers.
--   
--   <pre>
--   &gt;&gt;&gt; over (coerced1 @Identity) (++ "bar") (Identity "foo")
--   Identity "foobar"
--   </pre>
coerced1 :: forall f s a. (Coercible s (f s), Coercible a (f a)) => Iso (f s) (f a) s a

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" % non 0 %~ (+2)
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" % non 0 %~ (subtract 1)
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" % non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" % non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" % non Map.empty % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % non Map.empty % at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" % non' _Empty % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % non' _Empty % at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: Prism' a () -> Iso' (Maybe a) a

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   <pre>
--   <a>anon</a> a ≡ <a>non'</a> <a>.</a> <a>nearly</a> a
--   </pre>
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" % anon Map.empty Map.null % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % anon Map.empty Map.null % at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>re</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (view uncurried (+)) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; (view flipped (,)) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a> ≡ <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a

-- | This class provides for symmetric bifunctors.
class Bifunctor p => Swapped p

-- | <pre>
--   <a>swapped</a> <a>.</a> <a>swapped</a> ≡ <a>id</a>
--   <a>first</a> f <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>second</a> f
--   <a>second</a> g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>first</a> g
--   <a>bimap</a> f g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>bimap</a> g f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view swapped (1,2)
--   (2,1)
--   </pre>
swapped :: Swapped p => Iso (p a b) (p c d) (p b a) (p d c)

-- | Extract the two components of an isomorphism.
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Based on <tt>ala</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum) foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler type:
--   
--   <pre>
--   au :: <a>Iso</a> s t a b -&gt; ((b -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; a
--   </pre>
au :: Functor f => Iso s t a b -> ((b -> t) -> f s) -> f a

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a> ≡ <a>over</a> <a>.</a> <a>re</a>
--   </pre>
under :: Iso s t a b -> (t -> s) -> b -> a

-- | Tag for an iso.
data An_Iso :: OpticKind
instance Optics.Iso.Swapped (,)
instance Optics.Iso.Swapped Data.Either.Either


-- | This module defines <a>mapping</a>, which turns an <tt><a>Optic'</a> k
--   <a>NoIx</a> s a</tt> into an <tt><a>Optic'</a> (<a>MappedOptic</a> k)
--   <a>NoIx</a> (f s) (f a)</tt>, in other words optic operating on values
--   in a <a>Functor</a>.
module Optics.Mapping

-- | Class for optics supporting <a>mapping</a> through a <a>Functor</a>.
class MappingOptic k f g s t a b where {
    
    -- | Type family that maps an optic to the optic kind produced by
    --   <a>mapping</a> using it.
    type MappedOptic k;
}

-- | The <a>mapping</a> can be used to lift optic through a <a>Functor</a>.
--   
--   <pre>
--   <a>mapping</a> :: <a>Iso</a>    s t a b -&gt; <a>Iso</a>    (f s) (g t) (f a) (g b)
--   <a>mapping</a> :: <a>Lens</a>   s   a   -&gt; <a>Getter</a> (f s)       (f a)
--   <a>mapping</a> :: <a>Getter</a> s   a   -&gt; <a>Getter</a> (f s)       (f a)
--   <a>mapping</a> :: <a>Prism</a>    t   b -&gt; <a>Review</a>       (g t)       (g b)
--   <a>mapping</a> :: <a>Review</a>   t   b -&gt; <a>Review</a>       (g t)       (g b)
--   </pre>
mapping :: (MappingOptic k f g s t a b, "mapping" `AcceptsEmptyIndices` is) => Optic k is s t a b -> Optic (MappedOptic k) is (f s) (g t) (f a) (g b)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.An_Iso f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_Getter f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_ReversedPrism f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_Lens f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_Review f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_Prism f g s t a b
instance (GHC.Base.Functor f, f GHC.Types.~ g, s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Mapping.MappingOptic Optics.Internal.Optic.Types.A_ReversedLens f g s t a b


-- | This module defines the <a>AsEmpty</a> class, which provides a
--   <a>Prism</a> for a type that may be <a>_Empty</a>.
--   
--   Note that orphan instances for this class are defined in the
--   <tt>Optics.Empty</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
module Optics.Empty.Core

-- | Class for types that may be <a>_Empty</a>.
class AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()

-- | Pattern synonym for matching on any type with an <a>AsEmpty</a>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
pattern Empty :: forall a. AsEmpty a => a
instance Optics.Empty.Core.AsEmpty GHC.Types.Ordering
instance Optics.Empty.Core.AsEmpty ()
instance Optics.Empty.Core.AsEmpty Data.Semigroup.Internal.Any
instance Optics.Empty.Core.AsEmpty Data.Semigroup.Internal.All
instance Optics.Empty.Core.AsEmpty GHC.Event.Internal.Types.Event
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Product a)
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Sum a)
instance Optics.Empty.Core.AsEmpty (GHC.Maybe.Maybe a)
instance Optics.Empty.Core.AsEmpty (Data.Monoid.Last a)
instance Optics.Empty.Core.AsEmpty (Data.Monoid.First a)
instance Optics.Empty.Core.AsEmpty a => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Dual a)
instance (Optics.Empty.Core.AsEmpty a, Optics.Empty.Core.AsEmpty b) => Optics.Empty.Core.AsEmpty (a, b)
instance (Optics.Empty.Core.AsEmpty a, Optics.Empty.Core.AsEmpty b, Optics.Empty.Core.AsEmpty c) => Optics.Empty.Core.AsEmpty (a, b, c)
instance Optics.Empty.Core.AsEmpty [a]
instance Optics.Empty.Core.AsEmpty (Control.Applicative.ZipList a)
instance Optics.Empty.Core.AsEmpty (Data.Map.Internal.Map k a)
instance Optics.Empty.Core.AsEmpty (Data.IntMap.Internal.IntMap a)
instance Optics.Empty.Core.AsEmpty (Data.Set.Internal.Set a)
instance Optics.Empty.Core.AsEmpty Data.IntSet.Internal.IntSet
instance Optics.Empty.Core.AsEmpty (Data.Sequence.Internal.Seq a)


-- | A <tt><a>Setter</a> S T A B</tt> has the ability to lift a function of
--   type <tt>A -&gt; B</tt> <a>over</a> a function of type <tt>S -&gt;
--   T</tt>, applying the function to update all the <tt>A</tt>s contained
--   in <tt>S</tt>. This can be used to <a>set</a> all the <tt>A</tt>s to a
--   single value (by lifting a constant function).
--   
--   This can be seen as a generalisation of <a>fmap</a>, where the type
--   <tt>S</tt> does not need to be a type constructor with <tt>A</tt> as
--   its last parameter.
module Optics.Setter

-- | Type synonym for a type-modifying setter.
type Setter s t a b = Optic A_Setter NoIx s t a b

-- | Type synonym for a type-preserving setter.
type Setter' s a = Optic' A_Setter NoIx s a

-- | Build a setter from a function to modify the element(s), which must
--   respect the well-formedness laws.
sets :: ((a -> b) -> s -> t) -> Setter s t a b

-- | Apply a setter as a modifier.
over :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t

-- | Create a <a>Setter</a> for a <a>Functor</a>.
--   
--   <pre>
--   <a>over</a> <a>mapped</a> ≡ <a>fmap</a>
--   </pre>
mapped :: Functor f => Setter (f a) (f b) a b

-- | Apply a setter.
--   
--   <pre>
--   <a>set</a> o v ≡ <a>over</a> o (<a>const</a> v)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _1 'x' ('y', 'z')
--   ('x','z')
--   </pre>
set :: Is k A_Setter => Optic k is s t a b -> b -> s -> t

-- | Apply a setter, strictly.
--   
--   TODO DOC: what exactly is the strictness property?
set' :: Is k A_Setter => Optic k is s t a b -> b -> s -> t

-- | Apply a setter as a modifier, strictly.
--   
--   TODO DOC: what exactly is the strictness property?
--   
--   Example:
--   
--   <pre>
--   f :: Int -&gt; (Int, a) -&gt; (Int, a)
--   f k acc
--     | k &gt; 0     = f (k - 1) $ <a>over'</a> <a>_1</a> (+1) acc
--     | otherwise = acc
--   </pre>
--   
--   runs in constant space, but would result in a space leak if used with
--   <a>over</a>.
--   
--   Note that replacing <a>$</a> with <a>$!</a> or <a>_1</a> with
--   <a>_1'</a> (which amount to the same thing) doesn't help when
--   <a>over</a> is used, because the first coordinate of a pair is never
--   forced.
over' :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewriteOf l r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<tt>universeOf</tt> l (<a>rewriteOf</a> l r x))
--   </pre>
--   
--   Usually <a>transformOf</a> is more appropriate, but <a>rewriteOf</a>
--   can give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <tt>&lt;|&gt;</tt> g a</tt> which performs both rewrites until a fixed
--   point.
rewriteOf :: Is k A_Setter => Optic k is a b a b -> (b -> Maybe a) -> a -> b

-- | Transform every element by recursively applying a given <a>Setter</a>
--   in a bottom-up manner.
transformOf :: Is k A_Setter => Optic k is a b a b -> (b -> b) -> a -> b

-- | Tag for a setter.
data A_Setter :: OpticKind


-- | Defines some infix operators for optics operations. This is a
--   deliberately small collection.
--   
--   If you like operators, you may also wish to import
--   <tt>Optics.State.Operators</tt> from the <tt>optics-extra</tt>
--   package.
module Optics.Operators

-- | Flipped infix version of <a>view</a>.
(^.) :: Is k A_Getter => s -> Optic' k is s a -> a
infixl 8 ^.

-- | Flipped infix version of <a>toListOf</a>.
(^..) :: Is k A_Fold => s -> Optic' k is s a -> [a]
infixl 8 ^..

-- | Flipped infix version of <a>preview</a>.
(^?) :: Is k An_AffineFold => s -> Optic' k is s a -> Maybe a
infixl 8 ^?

-- | Infix version of <a>review</a>.
(#) :: Is k A_Review => Optic' k is t b -> b -> t
infixr 8 #

-- | Infix version of <a>over</a>.
(%~) :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Infix version of <a>over'</a>.
(%!~) :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t
infixr 4 %!~

-- | Infix version of <a>set</a>.
(.~) :: Is k A_Setter => Optic k is s t a b -> b -> s -> t
infixr 4 .~

-- | Infix version of <a>set'</a>.
(!~) :: Is k A_Setter => Optic k is s t a b -> b -> s -> t
infixr 4 !~

-- | Set the target of a <a>Setter</a> to <a>Just</a> a value.
--   
--   <pre>
--   o <a>?~</a> b ≡ <a>set</a> o (<a>Just</a> b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; equality ?~ 'x'
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ 'x'
--   fromList [(3,'x')]
--   </pre>
(?~) :: Is k A_Setter => Optic k is s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Strict version of (<a>?~</a>).
(?!~) :: Is k A_Setter => Optic k is s t a (Maybe b) -> b -> s -> t
infixr 4 ?!~


module Optics.Operators.Unsafe

-- | Perform an *UNSAFE* <a>head</a> of an affine fold assuming that it is
--   there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^?! _head
--   *** Exception: (^?!): empty affine fold
--   ...
--   </pre>
(^?!) :: (HasCallStack, Is k An_AffineFold) => s -> Optic' k is s a -> a
infixl 8 ^?!


-- | This module provides optics for <a>Map</a> and <a>Set</a>-like
--   containers, including an <a>AffineTraversal</a> to traverse a key in a
--   map or an element of a sequence:
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 1) ['a','b','c']
--   Just 'b'
--   </pre>
--   
--   a <a>Lens</a> to get, set or delete a key in a map:
--   
--   <pre>
--   &gt;&gt;&gt; set (at 0) (Just 'b') (Map.fromList [(0, 'a')])
--   fromList [(0,'b')]
--   </pre>
--   
--   and a <a>Lens</a> to insert or remove an element of a set:
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
--   
--   The <tt>Optics.At</tt> module from <tt>optics-extra</tt> provides
--   additional instances of the classes defined here.
module Optics.At.Core

-- | Type family that takes a key-value container type and returns the type
--   of keys (indices) into the container, for example <tt><a>Index</a>
--   (<a>Map</a> k a) ~ k</tt>. This is shared by <a>Ixed</a>, <a>At</a>
--   and <a>Contains</a>.
type family Index (s :: Type) :: Type

-- | Type family that takes a key-value container type and returns the type
--   of values stored in the container, for example <tt><a>IxValue</a>
--   (<a>Map</a> k a) ~ a</tt>. This is shared by both <a>Ixed</a> and
--   <a>At</a>.
type family IxValue (m :: Type) :: Type

-- | Provides a simple <a>AffineTraversal</a> lets you traverse the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class Ixed m where {
    
    -- | Type family that takes a key-value container type and returns the kind
    --   of optic to index into it. For most containers, it's
    --   <a>An_AffineTraversal</a>, <tt>Representable</tt> (Naperian)
    --   containers it is <a>A_Lens</a>, and multi-maps would have
    --   <tt>A_Traversal</tt>.
    type IxKind (m :: Type) :: OpticKind;
    type IxKind m = An_AffineTraversal;
}

-- | <i>NB:</i> Setting the value of this <a>AffineTraversal</a> will only
--   set the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; ix 2 %~ (*10)
--   [1,2,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" &amp; ix 2 .~ 'e'
--   "abed"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? ix 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Optic' (IxKind m) NoIx m (IxValue m)

-- | <i>NB:</i> Setting the value of this <a>AffineTraversal</a> will only
--   set the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; ix 2 %~ (*10)
--   [1,2,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" &amp; ix 2 .~ 'e'
--   "abed"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? ix 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? ix 2
--   Nothing
--   </pre>
ix :: (Ixed m, At m, IxKind m ~ An_AffineTraversal) => Index m -> Optic' (IxKind m) NoIx m (IxValue m)

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> AffineTraversal' m (IxValue m)

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>%</a> <a>_Just</a>
--   </pre>
class (Ixed m, IxKind m ~ An_AffineTraversal) => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> Usage of this function might introduce space leaks if
--   you're not careful to make sure that values put inside the <a>Just</a>
--   constructor are evaluated. To force the values and avoid such leaks,
--   use <a>at'</a> instead.
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <tt>Array</tt>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Version of <a>at</a> strict in the value inside the <a>Just</a>
--   constructor.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (at () .~ Just (error "oops") $ Nothing) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' () .~ Just (error "oops") $ Nothing) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at ()) (Just $ error "oops") `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at' ()) (Just $ error "oops") `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   It also works as expected for other data structures:
--   
--   <pre>
--   &gt;&gt;&gt; (at 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
at' :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k <a>.~</a> Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>. Instances are provided for <a>Set</a>-like containers
--   only.
class Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool
instance GHC.Classes.Eq e => Optics.At.Core.Ixed (e -> a)
instance Optics.At.Core.Ixed (GHC.Maybe.Maybe a)
instance Optics.At.Core.Ixed [a]
instance Optics.At.Core.Ixed (GHC.Base.NonEmpty a)
instance Optics.At.Core.Ixed (Data.Functor.Identity.Identity a)
instance Optics.At.Core.Ixed (Data.Tree.Tree a)
instance Optics.At.Core.Ixed (Data.Sequence.Internal.Seq a)
instance Optics.At.Core.Ixed (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Optics.At.Core.Ixed (Data.Map.Internal.Map k a)
instance GHC.Classes.Ord k => Optics.At.Core.Ixed (Data.Set.Internal.Set k)
instance Optics.At.Core.Ixed Data.IntSet.Internal.IntSet
instance GHC.Ix.Ix i => Optics.At.Core.Ixed (GHC.Arr.Array i e)
instance (Data.Array.Base.IArray Data.Array.Base.UArray e, GHC.Ix.Ix i) => Optics.At.Core.Ixed (Data.Array.Base.UArray i e)
instance (a0 GHC.Types.~ a1) => Optics.At.Core.Ixed (a0, a1)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2) => Optics.At.Core.Ixed (a0, a1, a2)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3) => Optics.At.Core.Ixed (a0, a1, a2, a3)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3, a0 GHC.Types.~ a4) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3, a0 GHC.Types.~ a4, a0 GHC.Types.~ a5) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3, a0 GHC.Types.~ a4, a0 GHC.Types.~ a5, a0 GHC.Types.~ a6) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3, a0 GHC.Types.~ a4, a0 GHC.Types.~ a5, a0 GHC.Types.~ a6, a0 GHC.Types.~ a7) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6, a7)
instance (a0 GHC.Types.~ a1, a0 GHC.Types.~ a2, a0 GHC.Types.~ a3, a0 GHC.Types.~ a4, a0 GHC.Types.~ a5, a0 GHC.Types.~ a6, a0 GHC.Types.~ a7, a0 GHC.Types.~ a8) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6, a7, a8)
instance Optics.At.Core.At (GHC.Maybe.Maybe a)
instance Optics.At.Core.At (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Optics.At.Core.At (Data.Map.Internal.Map k a)
instance Optics.At.Core.At Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord k => Optics.At.Core.At (Data.Set.Internal.Set k)
instance Optics.At.Core.Contains Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord a => Optics.At.Core.Contains (Data.Set.Internal.Set a)


module Optics.Arrow
class Arrow arr => ArrowOptic k arr

-- | Turn an optic into an arrow transformer.
overA :: ArrowOptic k arr => Optic k is s t a b -> arr a b -> arr s t

-- | Run an arrow command and use the output to set all the targets of an
--   optic to the result.
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
assignA :: (Is k A_Setter, Arrow arr) => Optic k is s t a b -> arr s b -> arr s t
instance Control.Arrow.Arrow arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.An_Iso arr
instance Control.Arrow.Arrow arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.A_Lens arr
instance Control.Arrow.ArrowChoice arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.A_Prism arr
instance Control.Arrow.ArrowChoice arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.An_AffineTraversal arr
instance Control.Category.Category p => Control.Category.Category (Optics.Arrow.WrappedArrow p i)
instance Control.Arrow.Arrow p => Control.Arrow.Arrow (Optics.Arrow.WrappedArrow p i)
instance Control.Arrow.Arrow p => Data.Profunctor.Indexed.Profunctor (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.Arrow p => Data.Profunctor.Indexed.Strong (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.ArrowChoice p => Data.Profunctor.Indexed.Choice (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.ArrowChoice p => Data.Profunctor.Indexed.Visiting (Optics.Arrow.WrappedArrow p)


-- | This module defines optics for constructing and manipulating finite
--   <a>Set</a>s.
module Data.Set.Optics

-- | This <a>Setter</a> can be used to change the type of a <a>Set</a> by
--   mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <a>Set</a>, but
--   you can manipulate it by reading using <a>folded</a> and reindexing it
--   via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (Set.fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Ord b => Setter (Set a) (Set b) a b

-- | Construct a set from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
setOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Set a


-- | This module defines optics for constructing and manipulating finite
--   <a>IntSet</a>s.
module Data.IntSet.Optics

-- | IntSet isn't Foldable, but this <a>Fold</a> can be used to access the
--   members of an <a>IntSet</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf members $ setOf folded [1,2,3,4]
--   10
--   </pre>
members :: Fold IntSet Int

-- | This <a>Setter</a> can be used to change the type of a <a>IntSet</a>
--   by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for an <a>IntSet</a>,
--   but you can manipulate it by reading using <a>folded</a> and
--   reindexing it via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (IntSet.fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Setter' IntSet Int

-- | Construct an <a>IntSet</a> from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded [1,2,3,4]
--   fromList [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
setOf :: Is k A_Fold => Optic' k is s Int -> s -> IntSet


-- | A <a>Traversal</a> lifts an effectful operation on elements to act on
--   structures containing those elements.
--   
--   That is, given a function <tt>op :: A -&gt; F B</tt> where <tt>F</tt>
--   is <a>Applicative</a>, a <tt><a>Traversal</a> S T A B</tt> can produce
--   a function <tt>S -&gt; F T</tt> that applies <tt>op</tt> to all the
--   <tt>A</tt>s contained in the <tt>S</tt>.
--   
--   This can be seen as a generalisation of <a>traverse</a>, where the
--   type <tt>S</tt> does not need to be a type constructor with <tt>A</tt>
--   as the last parameter.
--   
--   A <a>Lens</a> is a <a>Traversal</a> that acts on a single value.
--   
--   A close relative is the <a>AffineTraversal</a>, which is a
--   <a>Traversal</a> that acts on at most one value.
module Optics.Traversal

-- | Type synonym for a type-modifying traversal.
type Traversal s t a b = Optic A_Traversal NoIx s t a b

-- | Type synonym for a type-preserving traversal.
type Traversal' s a = Optic' A_Traversal NoIx s a

-- | Build a traversal from the van Laarhoven representation.
--   
--   <pre>
--   <a>traversalVL</a> <a>.</a> <a>traverseOf</a> ≡ <a>id</a>
--   <a>traverseOf</a> <a>.</a> <a>traversalVL</a> ≡ <a>id</a>
--   </pre>
traversalVL :: TraversalVL s t a b -> Traversal s t a b

-- | Map each element of a structure targeted by a <a>Traversal</a>,
--   evaluate these actions from left to right, and collect the results.
traverseOf :: (Is k A_Traversal, Applicative f) => Optic k is s t a b -> (a -> f b) -> s -> f t

-- | Construct a <a>Traversal</a> via the <a>Traversable</a> class.
--   
--   <pre>
--   <a>traverseOf</a> <a>traversed</a> = <a>traverse</a>
--   </pre>
traversed :: Traversable t => Traversal (t a) (t b) a b

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   <i>Note:</i> for traversing a pair or an <a>Either</a> it's better to
--   use <a>each</a> and <a>chosen</a> respectively to reduce potential for
--   bugs due to too much polymorphism.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both %~ (*10)
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldOf both ("hello","world")
--   "helloworld"
--   </pre>
both :: Bitraversable r => Traversal (r a a) (r b b) a b

-- | A version of <a>traverseOf</a> with the arguments flipped.
forOf :: (Is k A_Traversal, Applicative f) => Optic k is s t a b -> s -> (a -> f b) -> f t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a> ≡ <a>sequenceOf</a> <a>traversed</a> ≡ <a>traverse</a> <a>id</a>
--   <a>sequenceOf</a> o ≡ <a>traverseOf</a> o <a>id</a>
--   </pre>
sequenceOf :: (Is k A_Traversal, Applicative f) => Optic k is s t (f b) b -> s -> f t

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traversed [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a> ≡ <a>transposeOf</a> <a>traverse</a>
--   </pre>
transposeOf :: Is k A_Traversal => Optic k is s t [a] a -> s -> [t]

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>mapAccumROf</a> <a>traversed</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
mapAccumROf :: Is k A_Traversal => Optic k is s t a b -> (acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
mapAccumLOf :: Is k A_Traversal => Optic k is s t a b -> (acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>scanr1</a> ≡ <a>scanr1Of</a> <a>traversed</a>
--   </pre>
scanr1Of :: Is k A_Traversal => Optic k is s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>scanl1</a> ≡ <a>scanl1Of</a> <a>traversed</a>
--   </pre>
scanl1Of :: Is k A_Traversal => Optic k is s t a a -> (a -> a -> a) -> s -> t

-- | Rewrite by applying a monadic rule everywhere you recursing with a
--   user-specified <a>Traversal</a>.
--   
--   Ensures that the rule cannot be applied anywhere in the result.
rewriteMOf :: (Is k A_Traversal, Monad m) => Optic k is a b a b -> (b -> m (Maybe a)) -> a -> m b

-- | Transform every element in a tree using a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
transformMOf :: (Is k A_Traversal, Monad m) => Optic k is a b a b -> (b -> m b) -> a -> m b

-- | Try to map a function over this <a>Traversal</a>, returning Nothing if
--   the traversal has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4)
--   Just (Right 8)
--   </pre>
failover :: Is k A_Traversal => Optic k is s t a b -> (a -> b) -> s -> Maybe t

-- | Version of <a>failover</a> strict in the application of <tt>f</tt>.
failover' :: Is k A_Traversal => Optic k is s t a b -> (a -> b) -> s -> Maybe t

-- | This allows you to <a>traverse</a> the elements of a traversal in the
--   opposite order.
backwards :: Is k A_Traversal => Optic k is s t a b -> Traversal s t a b

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a>.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['x','y','z']
--   ('x','y','z')
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['w','x','y','z']
--   ('w','x','y')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['x','y']
--   ('x','y','c')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('b', 'a', 'd', 'c') &amp; partsOf each %~ sort
--   ('a','b','c','d')
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
partsOf :: forall k is s t a. Is k A_Traversal => Optic k is s t a a -> Lens s t [a] [a]

-- | Convert a traversal to an <a>AffineTraversal</a> that visits the first
--   element of the original traversal.
--   
--   For the fold version see <a>pre</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "foo" &amp; singular traversed .~ 'z'
--   "zoo"
--   </pre>
singular :: forall k is s a. Is k A_Traversal => Optic' k is s a -> AffineTraversal' s a

-- | Combine two disjoint traversals into one.
--   
--   <pre>
--   &gt;&gt;&gt; over (_1 % _Just `adjoin` _2 % _Right) not (Just True, Right False)
--   (Just False,Right True)
--   </pre>
--   
--   <i>Note:</i> if the argument traversals are not disjoint, the result
--   will not respect the <a>Traversal</a> laws, because it will visit the
--   same element multiple times. See section 7 of <a>Understanding
--   Idiomatic Traversals Backwards and Forwards</a> by Bird et al. for why
--   this is illegal.
--   
--   <pre>
--   &gt;&gt;&gt; view (partsOf (each `adjoin` _1)) ('x','y')
--   "xyx"
--   
--   &gt;&gt;&gt; set (partsOf (each `adjoin` _1)) "abc" ('x','y')
--   ('c','b')
--   </pre>
--   
--   For the <a>Fold</a> version see <a>summing</a>.
adjoin :: (Is k A_Traversal, Is l A_Traversal) => Optic' k is s a -> Optic' l js s a -> Traversal' s a
infixr 6 `adjoin`

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven traversal.
type TraversalVL s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven traversal.
type TraversalVL' s a = TraversalVL s s a a


-- | An <a>IxTraversal</a> is an indexed version of a <a>Traversal</a>. See
--   the "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxTraversal

-- | Type synonym for a type-modifying indexed traversal.
type IxTraversal i s t a b = Optic A_Traversal (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed traversal.
type IxTraversal' i s a = Optic' A_Traversal (WithIx i) s a

-- | Build an indexed traversal from the van Laarhoven representation.
--   
--   <pre>
--   <a>itraversalVL</a> <a>.</a> <a>itraverseOf</a> ≡ <a>id</a>
--   <a>itraverseOf</a> <a>.</a> <a>itraversalVL</a> ≡ <a>id</a>
--   </pre>
itraversalVL :: IxTraversalVL i s t a b -> IxTraversal i s t a b

-- | Map each element of a structure targeted by an <a>IxTraversal</a>
--   (supplying the index), evaluate these actions from left to right, and
--   collect the results.
--   
--   This yields the van Laarhoven representation of an indexed traversal.
itraverseOf :: (Is k A_Traversal, Applicative f, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> f b) -> s -> f t

-- | Indexed traversal via the <a>TraversableWithIndex</a> class.
--   
--   <pre>
--   <a>itraverseOf</a> <a>itraversed</a> ≡ <a>itraverse</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iover (itraversed &lt;%&gt; itraversed) (,) ["ab", "cd"]
--   [[((0,0),'a'),((0,1),'b')],[((1,0),'c'),((1,1),'d')]]
--   </pre>
itraversed :: TraversableWithIndex i f => IxTraversal i (f a) (f b) a b

-- | This is the trivial empty <a>IxAffineTraversal</a>, i.e. the optic
--   that targets no substructures.
--   
--   This is the identity element when a <a>Fold</a>, <a>AffineFold</a>,
--   <a>IxFold</a>, <a>IxAffineFold</a>, <a>Traversal</a> or
--   <a>IxTraversal</a> is viewed as a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: IxAffineTraversal i s s a b

-- | Traverse selected elements of a <a>Traversal</a> where their ordinal
--   positions match a predicate.
elementsOf :: Is k A_Traversal => Optic k is s t a a -> (Int -> Bool) -> IxTraversal Int s t a a

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a> ≡ <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: Traversable f => (Int -> Bool) -> IxTraversal' Int (f a) a

-- | Traverse the <i>nth</i> element of a <a>Traversal</a> if it exists.
elementOf :: Is k A_Traversal => Optic' k is s a -> Int -> IxAffineTraversal' Int s a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a> ≡ <a>elementOf</a> <a>traversed</a>
--   </pre>
element :: Traversable f => Int -> IxAffineTraversal' Int (f a) a

-- | A version of <a>itraverseOf</a> with the arguments flipped.
iforOf :: (Is k A_Traversal, Applicative f, is `HasSingleIndex` i) => Optic k is s t a b -> s -> (i -> a -> f b) -> f t

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IxTraversal</a>.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> o ≡ <a>imapAccumLOf</a> o <a>.</a> <a>const</a>
--   </pre>
imapAccumLOf :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IxTraversal</a>.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> o ≡ <a>imapAccumROf</a> o <a>.</a> <a>const</a>
--   </pre>
imapAccumROf :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>IxTraversal</a>.
iscanl1Of :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> (i -> a -> a -> a) -> s -> t

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>IxTraversal</a>.
iscanr1Of :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> (i -> a -> a -> a) -> s -> t

-- | Try to map a function which uses the index over this
--   <a>IxTraversal</a>, returning <a>Nothing</a> if the <a>IxTraversal</a>
--   has no targets.
ifailover :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> Maybe t

-- | Version of <a>ifailover</a> strict in the application of the function.
ifailover' :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> Maybe t

-- | Filter results of an <a>IxTraversal</a> that don't satisfy a predicate
--   on the indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (itraversed %&amp; indices even) "foobar"
--   "foa"
--   </pre>
indices :: (Is k A_Traversal, is `HasSingleIndex` i) => (i -> Bool) -> Optic k is s t a a -> IxTraversal i s t a a

-- | This allows you to <a>traverse</a> the elements of an indexed
--   traversal in the opposite order.
ibackwards :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> IxTraversal i s t a b

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its indices.
ipartsOf :: forall k is i s t a. (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> IxLens [i] s t [a] [a]

-- | Convert an indexed traversal to an <a>IxAffineTraversal</a> that
--   visits the first element of the original traversal.
--   
--   For the fold version see <a>ipre</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; iover (isingular itraversed) (-)
--   [-1,2,3]
--   </pre>
isingular :: forall k is i s a. (Is k A_Traversal, is `HasSingleIndex` i) => Optic' k is s a -> IxAffineTraversal' i s a

-- | Combine two disjoint indexed traversals into one.
--   
--   <pre>
--   &gt;&gt;&gt; iover (_1 % itraversed `iadjoin` _2 % itraversed) (+) ([0, 0, 0], (3, 5))
--   ([0,1,2],(3,8))
--   </pre>
--   
--   <i>Note:</i> if the argument traversals are not disjoint, the result
--   will not respect the <a>IxTraversal</a> laws, because it will visit
--   the same element multiple times. See section 7 of <a>Understanding
--   Idiomatic Traversals Backwards and Forwards</a> by Bird et al. for why
--   this is illegal.
--   
--   <pre>
--   &gt;&gt;&gt; iview (ipartsOf (each `iadjoin` each)) ("x","y")
--   ([0,1,0,1],["x","y","x","y"])
--   
--   &gt;&gt;&gt; iset (ipartsOf (each `iadjoin` each)) (const ["a","b","c","d"]) ("x","y")
--   ("c","d")
--   </pre>
--   
--   For the <a>IxFold</a> version see <a>isumming</a>.
iadjoin :: (Is k A_Traversal, Is l A_Traversal, is `HasSingleIndex` i) => Optic' k is s a -> Optic' l is s a -> IxTraversal' i s a
infixr 6 `iadjoin`

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed traversal.
type IxTraversalVL i s t a b = forall f. Applicative f => (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed traversal.
type IxTraversalVL' i s a = IxTraversalVL i s s a a

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)


-- | This module defines the <a>Each</a> class, which provides an
--   <a>IxTraversal</a> that extracts <a>each</a> element of a (potentially
--   monomorphic) container.
--   
--   Note that orphan instances for this class are defined in the
--   <tt>Optics.Each</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
module Optics.Each.Core

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   <pre>
--   &gt;&gt;&gt; over each (*10) (1,2,3)
--   (10,20,30)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iover each (\i a -&gt; a*10 + succ i) (1,2,3)
--   (11,22,33)
--   </pre>
class Each i s t a b | s -> i a, t -> i b, s b -> t, t a -> s
each :: Each i s t a b => IxTraversal i s t a b
each :: (Each i s t a b, TraversableWithIndex i g, s ~ g a, t ~ g b) => IxTraversal i s t a b
instance (a GHC.Types.~ a1, b GHC.Types.~ b1) => Optics.Each.Core.Each GHC.Types.Int (a, a1) (b, b1) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, b GHC.Types.~ b1, b GHC.Types.~ b2) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2) (b, b1, b2) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3) (b, b1, b2, b3) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4) (b, b1, b2, b3, b4) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5) (b, b1, b2, b3, b4, b5) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6) (b, b1, b2, b3, b4, b5, b6) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7) (b, b1, b2, b3, b4, b5, b6, b7) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7, b GHC.Types.~ b8) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7, a8) (b, b1, b2, b3, b4, b5, b6, b7, b8) a b
instance (a GHC.Types.~ a1, a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8, a GHC.Types.~ a9, b GHC.Types.~ b1, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7, b GHC.Types.~ b8, b GHC.Types.~ b9) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7, a8, a9) (b, b1, b2, b3, b4, b5, b6, b7, b8, b9) a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Optics.Each.Core.Each (Data.Either.Either () ()) (Data.Either.Either a a') (Data.Either.Either b b') a b
instance Optics.Each.Core.Each (Data.Either.Either () ()) (Data.Complex.Complex a) (Data.Complex.Complex b) a b
instance (k GHC.Types.~ k') => Optics.Each.Core.Each k (Data.Map.Internal.Map k a) (Data.Map.Internal.Map k' b) a b
instance Optics.Each.Core.Each GHC.Types.Int (Data.IntMap.Internal.IntMap a) (Data.IntMap.Internal.IntMap b) a b
instance Optics.Each.Core.Each GHC.Types.Int [a] [b] a b
instance Optics.Each.Core.Each GHC.Types.Int (GHC.Base.NonEmpty a) (GHC.Base.NonEmpty b) a b
instance Optics.Each.Core.Each () (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance Optics.Each.Core.Each () (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe b) a b
instance Optics.Each.Core.Each GHC.Types.Int (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Optics.Each.Core.Each [GHC.Types.Int] (Data.Tree.Tree a) (Data.Tree.Tree b) a b
instance (GHC.Ix.Ix i, i GHC.Types.~ j) => Optics.Each.Core.Each i (GHC.Arr.Array i a) (GHC.Arr.Array j b) a b

module Optics.Internal.Generic

-- | Convert from the data type to its representation (or back)
--   
--   <pre>
--   &gt;&gt;&gt; view (generic % re generic) "hello" :: String
--   "hello"
--   </pre>
generic :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b y)

-- | Convert from the data type to its representation (or back)
generic1 :: (Generic1 f, Generic1 g) => Iso (f x) (g y) (Rep1 f x) (Rep1 g y)
_V1 :: Lens (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism ((a :+: c) t) ((b :+: c) t) (a t) (b t)
_R1 :: Prism ((c :+: a) t) ((c :+: b) t) (a t) (b t)
class GFieldImpl (name :: Symbol) s t a b | name s -> a
gfieldImpl :: GFieldImpl name s t a b => Lens s t a b
class GSetFieldSum (path :: PathTree Symbol) g h b | path h -> b, path g b -> h
gsetFieldSum :: GSetFieldSum path g h b => g x -> b -> h x
class GSetFieldProd (path :: [Path]) g h b | path h -> b, path g b -> h
gsetFieldProd :: GSetFieldProd path g h b => g x -> b -> h x
class GAffineFieldImpl (repDefined :: Bool) (name :: Symbol) s t a b | name s -> a
gafieldImpl :: GAffineFieldImpl repDefined name s t a b => AffineTraversal s t a b
class GAffineFieldSum (path :: PathTree Symbol) g h a b
gafieldSum :: GAffineFieldSum path g h a b => AffineTraversalVL (g x) (h x) a b
class GFieldProd (path :: [Path]) g h a b | path g -> a, path h -> b, path g b -> h, path h a -> g
gfieldProd :: GFieldProd path g h a b => LensVL (g x) (h x) a b
class GPositionImpl (repDefined :: Bool) (n :: Nat) s t a b | n s -> a
gpositionImpl :: GPositionImpl repDefined n s t a b => Lens s t a b
class GPositionSum (path :: PathTree (Nat, Nat)) g h a b | path g -> a, path h -> b, path g b -> h, path h a -> g
gpositionSum :: GPositionSum path g h a b => LensVL (g x) (h x) a b
class GConstructorImpl (repDefined :: Bool) (name :: Symbol) s t a b | name s -> a
gconstructorImpl :: GConstructorImpl repDefined name s t a b => Prism s t a b
class GConstructorSum (path :: [Path]) g h a b | path g -> a, path h -> b, path g b -> h, path h a -> g
gconstructorSum :: GConstructorSum path g h a b => Prism (g x) (h x) a b
class GConstructorTuple g h a b | g -> a, h -> b, g b -> h, h a -> g
gconstructorTuple :: GConstructorTuple g h a b => Iso (g x) (h x) a b
class GPlateImpl g a
gplateImpl :: GPlateImpl g a => TraversalVL' (g x) a
class GPlateInner (repDefined :: Bool) s a
gplateInner :: GPlateInner repDefined s a => TraversalVL' s a
instance Optics.Internal.Generic.GPlateInner (Optics.Internal.Optic.TypeLevel.Defined (GHC.Generics.Rep b)) b a => Optics.Internal.Generic.GPlateImpl (GHC.Generics.K1 i b) a
instance (GHC.Generics.Generic s, Optics.Internal.Generic.GPlateImpl (GHC.Generics.Rep s) a) => Optics.Internal.Generic.GPlateInner 'GHC.Types.True s a
instance Optics.Internal.Generic.GPlateInner repNotDefined s a
instance Optics.Internal.Generic.GPlateImpl f a => Optics.Internal.Generic.GPlateImpl (GHC.Generics.M1 i c f) a
instance (Optics.Internal.Generic.GPlateImpl f a, Optics.Internal.Generic.GPlateImpl g a) => Optics.Internal.Generic.GPlateImpl (f GHC.Generics.:+: g) a
instance (Optics.Internal.Generic.GPlateImpl f a, Optics.Internal.Generic.GPlateImpl g a) => Optics.Internal.Generic.GPlateImpl (f GHC.Generics.:*: g) a
instance Optics.Internal.Generic.GPlateImpl (GHC.Generics.K1 i a) a
instance Optics.Internal.Generic.GPlateImpl GHC.Generics.U1 a
instance Optics.Internal.Generic.GPlateImpl GHC.Generics.V1 a
instance Optics.Internal.Generic.GPlateImpl (GHC.Generics.URec b) a
instance (r GHC.Types.~ a, s GHC.Types.~ b) => Optics.Internal.Generic.GConstructorTuple (Optics.Internal.Generic.F m a) (Optics.Internal.Generic.F m b) r s
instance (r GHC.Types.~ (a1, a2), s GHC.Types.~ (b1, b2)) => Optics.Internal.Generic.GConstructorTuple (Optics.Internal.Generic.F m1 a1 GHC.Generics.:*: Optics.Internal.Generic.F m2 a2) (Optics.Internal.Generic.F m1 b1 GHC.Generics.:*: Optics.Internal.Generic.F m2 b2) r s
instance (r GHC.Types.~ (a1, a2, a3), s GHC.Types.~ (b1, b2, b3)) => Optics.Internal.Generic.GConstructorTuple (Optics.Internal.Generic.F m1 a1 GHC.Generics.:*: (Optics.Internal.Generic.F m2 a2 GHC.Generics.:*: Optics.Internal.Generic.F m3 a3)) (Optics.Internal.Generic.F m1 b1 GHC.Generics.:*: (Optics.Internal.Generic.F m2 b2 GHC.Generics.:*: Optics.Internal.Generic.F m3 b3)) r s
instance (r GHC.Types.~ (a1, a2, a3, a4), s GHC.Types.~ (b1, b2, b3, b4)) => Optics.Internal.Generic.GConstructorTuple ((Optics.Internal.Generic.F m1 a1 GHC.Generics.:*: Optics.Internal.Generic.F m2 a2) GHC.Generics.:*: (Optics.Internal.Generic.F m3 a3 GHC.Generics.:*: Optics.Internal.Generic.F m4 a4)) ((Optics.Internal.Generic.F m1 b1 GHC.Generics.:*: Optics.Internal.Generic.F m2 b2) GHC.Generics.:*: (Optics.Internal.Generic.F m3 b3 GHC.Generics.:*: Optics.Internal.Generic.F m4 b4)) r s
instance (r GHC.Types.~ (a1, a2, a3, a4, a5), s GHC.Types.~ (b1, b2, b3, b4, b5)) => Optics.Internal.Generic.GConstructorTuple ((Optics.Internal.Generic.F m1 a1 GHC.Generics.:*: Optics.Internal.Generic.F m2 a2) GHC.Generics.:*: (Optics.Internal.Generic.F m3 a3 GHC.Generics.:*: (Optics.Internal.Generic.F m4 a4 GHC.Generics.:*: Optics.Internal.Generic.F m5 a5))) ((Optics.Internal.Generic.F m1 b1 GHC.Generics.:*: Optics.Internal.Generic.F m2 b2) GHC.Generics.:*: (Optics.Internal.Generic.F m3 b3 GHC.Generics.:*: (Optics.Internal.Generic.F m4 b4 GHC.Generics.:*: Optics.Internal.Generic.F m5 b5))) r s
instance Optics.Internal.Generic.GConstructorTuple g h a b => Optics.Internal.Generic.GConstructorSum '[] (GHC.Generics.M1 GHC.Generics.C m g) (GHC.Generics.M1 GHC.Generics.C m h) a b
instance (Optics.Internal.Magic.Dysfunctional () () g h a b, (TypeError ...)) => Optics.Internal.Generic.GConstructorTuple g h a b
instance (a GHC.Types.~ (), b GHC.Types.~ ()) => Optics.Internal.Generic.GConstructorTuple GHC.Generics.U1 GHC.Generics.U1 a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, epath GHC.Types.~ Optics.Internal.Generic.TypeLevel.GetNamePath name (GHC.Generics.Rep s) '[], path GHC.Types.~ Optics.Internal.Optic.TypeLevel.FromRight (TypeError ...) epath, Optics.Internal.Optic.TypeLevel.When (Optics.Internal.Optic.TypeLevel.IsLeft epath) (Optics.Internal.Generic.TypeLevel.HideReps (GHC.Generics.Rep s) (GHC.Generics.Rep t)), Optics.Internal.Generic.GConstructorSum path (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Optics.Internal.Generic.GConstructorImpl 'GHC.Types.True name s t a b
instance Optics.Internal.Generic.GConstructorSum path g h a b => Optics.Internal.Generic.GConstructorSum path (GHC.Generics.M1 GHC.Generics.D m g) (GHC.Generics.M1 GHC.Generics.D m h) a b
instance Optics.Internal.Generic.GConstructorSum path g1 h1 a b => Optics.Internal.Generic.GConstructorSum ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: g2) a b
instance (Optics.Internal.Generic.GConstructorSum path g1 h1 a b, g2 GHC.Types.~ h2) => Optics.Internal.Generic.GConstructorSum ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: h2) a b
instance Optics.Internal.Generic.GConstructorSum path g2 h2 a b => Optics.Internal.Generic.GConstructorSum ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:+: g2) (g1 GHC.Generics.:+: h2) a b
instance (Optics.Internal.Generic.GConstructorSum path g2 h2 a b, g1 GHC.Types.~ h1) => Optics.Internal.Generic.GConstructorSum ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: h2) a b
instance (path GHC.Types.~ Optics.Internal.Generic.GPositionPath con epath, Optics.Internal.Optic.TypeLevel.When (Optics.Internal.Optic.TypeLevel.IsLeft epath) (Optics.Internal.Generic.TypeLevel.HideReps g h), Optics.Internal.Generic.GFieldProd path g h a b) => Optics.Internal.Generic.GPositionSum ('Optics.Internal.Generic.TypeLevel.PathLeaf epath) (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons con fix hs) g) (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons con fix hs) h) a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, path GHC.Types.~ Data.Type.Bool.If (n Data.Type.Ord.<=? 0) (TypeError ...) (Optics.Internal.Generic.TypeLevel.GetPositionPaths s n (GHC.Generics.Rep s)), Optics.Internal.Optic.TypeLevel.When (n Data.Type.Ord.<=? 0) (Optics.Internal.Generic.TypeLevel.HideReps (GHC.Generics.Rep s) (GHC.Generics.Rep t)), Optics.Internal.Generic.GPositionSum path (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Optics.Internal.Generic.GPositionImpl 'GHC.Types.True n s t a b
instance Optics.Internal.Generic.GPositionSum path g h a b => Optics.Internal.Generic.GPositionSum path (GHC.Generics.M1 GHC.Generics.D m g) (GHC.Generics.M1 GHC.Generics.D m h) a b
instance (Optics.Internal.Generic.GPositionSum path1 g1 h1 a b, Optics.Internal.Generic.GPositionSum path2 g2 h2 a b) => Optics.Internal.Generic.GPositionSum ('Optics.Internal.Generic.TypeLevel.PathTree path1 path2) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: h2) a b
instance Optics.Internal.Generic.GFieldProd prodPath g h a b => Optics.Internal.Generic.GAffineFieldMaybe ('Data.Either.Right prodPath) g h a b
instance Optics.Internal.Generic.GFieldProd path g1 h1 a b => Optics.Internal.Generic.GFieldProd ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: g2) a b
instance (Optics.Internal.Generic.GFieldProd path g1 h1 a b, g2 GHC.Types.~ h2) => Optics.Internal.Generic.GFieldProd ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: h2) a b
instance Optics.Internal.Generic.GFieldProd path g2 h2 a b => Optics.Internal.Generic.GFieldProd ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:*: g2) (g1 GHC.Generics.:*: h2) a b
instance (Optics.Internal.Generic.GFieldProd path g2 h2 a b, g1 GHC.Types.~ h1) => Optics.Internal.Generic.GFieldProd ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: h2) a b
instance (r GHC.Types.~ a, s GHC.Types.~ b) => Optics.Internal.Generic.GFieldProd '[] (GHC.Generics.M1 GHC.Generics.S m (GHC.Generics.Rec0 a)) (GHC.Generics.M1 GHC.Generics.S m (GHC.Generics.Rec0 b)) r s
instance Optics.Internal.Generic.GAffineFieldMaybe epath g h a b => Optics.Internal.Generic.GAffineFieldSum ('Optics.Internal.Generic.TypeLevel.PathLeaf epath) (GHC.Generics.M1 GHC.Generics.C m g) (GHC.Generics.M1 GHC.Generics.C m h) a b
instance (g GHC.Types.~ h) => Optics.Internal.Generic.GAffineFieldMaybe ('Data.Either.Left name) g h a b
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, path GHC.Types.~ Optics.Internal.Generic.TypeLevel.GetFieldPaths s name (GHC.Generics.Rep s), GHC.Records.HasField name s a, Optics.Internal.Optic.TypeLevel.Unless (Optics.Internal.Generic.TypeLevel.AnyHasPath path) (TypeError ...), Optics.Internal.Generic.GAffineFieldSum path (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b) => Optics.Internal.Generic.GAffineFieldImpl 'GHC.Types.True name s t a b
instance Optics.Internal.Generic.GAffineFieldSum path g h a b => Optics.Internal.Generic.GAffineFieldSum path (GHC.Generics.M1 GHC.Generics.D m g) (GHC.Generics.M1 GHC.Generics.D m h) a b
instance (Optics.Internal.Generic.GAffineFieldSum path1 g1 h1 a b, Optics.Internal.Generic.GAffineFieldSum path2 g2 h2 a b) => Optics.Internal.Generic.GAffineFieldSum ('Optics.Internal.Generic.TypeLevel.PathTree path1 path2) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: h2) a b
instance (path GHC.Types.~ Optics.Internal.Generic.GSetFieldPath con epath, Optics.Internal.Optic.TypeLevel.When (Optics.Internal.Optic.TypeLevel.IsLeft epath) (Optics.Internal.Generic.TypeLevel.HideReps g h), Optics.Internal.Generic.GSetFieldProd path g h b) => Optics.Internal.Generic.GSetFieldSum ('Optics.Internal.Generic.TypeLevel.PathLeaf epath) (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons con fix hs) g) (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons con fix hs) h) b
instance Optics.Internal.Generic.GSetFieldProd path g1 h1 b => Optics.Internal.Generic.GSetFieldProd ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: g2) b
instance (Optics.Internal.Generic.GSetFieldProd path g1 h1 b, g2 GHC.Types.~ h2) => Optics.Internal.Generic.GSetFieldProd ('Optics.Internal.Generic.TypeLevel.PathLeft : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: h2) b
instance Optics.Internal.Generic.GSetFieldProd path g2 h2 b => Optics.Internal.Generic.GSetFieldProd ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:*: g2) (g1 GHC.Generics.:*: h2) b
instance (Optics.Internal.Generic.GSetFieldProd path g2 h2 b, g1 GHC.Types.~ h1) => Optics.Internal.Generic.GSetFieldProd ('Optics.Internal.Generic.TypeLevel.PathRight : path) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: h2) b
instance (r GHC.Types.~ b) => Optics.Internal.Generic.GSetFieldProd '[] (GHC.Generics.M1 GHC.Generics.S m (GHC.Generics.Rec0 a)) (GHC.Generics.M1 GHC.Generics.S m (GHC.Generics.Rec0 b)) r
instance (GHC.Generics.Generic s, GHC.Generics.Generic t, path GHC.Types.~ Optics.Internal.Generic.TypeLevel.GetFieldPaths s name (GHC.Generics.Rep s), GHC.Records.HasField name s a, Optics.Internal.Generic.GSetFieldSum path (GHC.Generics.Rep s) (GHC.Generics.Rep t) b) => Optics.Internal.Generic.GFieldImpl name s t a b
instance Optics.Internal.Generic.GSetFieldSum path g h b => Optics.Internal.Generic.GSetFieldSum path (GHC.Generics.M1 GHC.Generics.D m g) (GHC.Generics.M1 GHC.Generics.D m h) b
instance (Optics.Internal.Generic.GSetFieldSum path1 g1 h1 b, Optics.Internal.Generic.GSetFieldSum path2 g2 h2 b) => Optics.Internal.Generic.GSetFieldSum ('Optics.Internal.Generic.TypeLevel.PathTree path1 path2) (g1 GHC.Generics.:+: g2) (h1 GHC.Generics.:+: h2) b


-- | Overloaded labels are a solution to Haskell's namespace problem for
--   records. The <tt>-XOverloadedLabels</tt> extension allows a new
--   expression syntax for labels, a prefix <tt>#</tt> sign followed by an
--   identifier, e.g. <tt>#foo</tt>. These expressions can then be given an
--   interpretation that depends on the type at which they are used and the
--   text of the label.
module Optics.Label

-- | Support for overloaded labels as optics.
--   
--   An overloaded label <tt>#foo</tt> can be used as an optic if there is
--   an instance <tt><a>LabelOptic</a> "foo" k s t a b</tt>.
--   
--   Alternatively, if both <tt>s</tt> and <tt>t</tt> have a <a>Generic</a>
--   (<a>GenericLabelOptics</a> if <tt>explicit-generic-labels</tt> flag is
--   enabled) instance, a total field of <tt>s</tt> is accessible by a
--   label <tt>#field</tt> of kind <a>A_Lens</a>, whereas its constructor
--   by a label <tt>#_Constructor</tt> of kind <a>A_Prism</a>.
class LabelOptic (name :: Symbol) k s t a b | name s -> k a, name t -> k b, name s b -> t, name t a -> s

-- | Used to interpret overloaded label syntax. An overloaded label
--   <tt>#foo</tt> corresponds to <tt><a>labelOptic</a> @"foo"</tt>.
labelOptic :: LabelOptic name k s t a b => Optic k NoIx s t a b

-- | Type synonym for a type-preserving optic as overloaded label.
type LabelOptic' name k s a = LabelOptic name k s s a a

-- | If the <tt>explicit-generic-labels</tt> Cabal flag is enabled, only
--   types with this instance (which can be trivially derived with
--   <tt>DeriveAnyClass</tt> extension) will be able to use labels as
--   generic optics with a specific type.
--   
--   It's an option for application developers to disable implicit fallback
--   to generic optics for more control.
--   
--   Libraries using generic labels with their data types should derive
--   this instance for compatibility with the
--   <tt>explicit-generic-labels</tt> flag.
--   
--   <i>Note:</i> the flag <tt>explicit-generic-labels</tt> is disabled by
--   default. Enabling it is generally unsupported as it might lead to
--   compilation errors of dependencies relying on implicit fallback to
--   generic optics.
class Generic a => GenericLabelOptics a where {
    type HasGenericLabelOptics a :: Bool;
    type HasGenericLabelOptics a = 'True;
}
instance Optics.Label.GenericLabelOpticContext repDefined name k s t a b => Optics.Label.LabelOptic name k s t a b
instance Optics.Internal.Generic.GFieldImpl name s t a b => Optics.Label.GenericOptic repDefined name Optics.Internal.Optic.Types.A_Lens s t a b
instance (Optics.Internal.Generic.GConstructorImpl repDefined name s t a b, _name GHC.Types.~ GHC.TypeLits.AppendSymbol "_" name) => Optics.Label.GenericOptic repDefined _name Optics.Internal.Optic.Types.A_Prism s t a b
instance (k GHC.Types.~ Optics.Internal.Optic.Types.An_Iso, a GHC.Types.~ Optics.Label.Void0, b GHC.Types.~ Optics.Label.Void0) => Optics.Label.LabelOptic name k Optics.Label.Void0 Optics.Label.Void0 a b
instance (Optics.Label.LabelOptic name k s t a b, is GHC.Types.~ Optics.Internal.Optic.TypeLevel.NoIx) => GHC.OverloadedLabels.IsLabel name (Optics.Internal.Optic.Optic k is s t a b)


-- | <i>Note:</i> <a>GHC.Generics</a> exports a number of names that
--   collide with <a>Optics</a> (at least <a>to</a>).
--   
--   You can use hiding of imports to mitigate this to an extent. The
--   following imports represent a fair compromise for user code:
--   
--   <pre>
--   import <a>Optics</a>
--   import <a>GHC.Generics</a> hiding (to)
--   import <a>GHC.Generics.Optics</a>
--   </pre>
--   
--   You can use <a>generic</a> to replace <a>from</a> and <a>to</a> from
--   <a>GHC.Generics</a>.
module GHC.Generics.Optics

-- | Convert from the data type to its representation (or back)
--   
--   <pre>
--   &gt;&gt;&gt; view (generic % re generic) "hello" :: String
--   "hello"
--   </pre>
generic :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b y)

-- | Convert from the data type to its representation (or back)
generic1 :: (Generic1 f, Generic1 g) => Iso (f x) (g y) (Rep1 f x) (Rep1 g y)
_V1 :: Lens (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism ((a :+: c) t) ((b :+: c) t) (a t) (b t)
_R1 :: Prism ((c :+: a) t) ((c :+: b) t) (a t) (b t)


-- | This module defines basic functionality for indexed optics. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details.
module Optics.Indexed.Core

-- | Class for optic kinds that can have indices.
class IxOptic k s t a b

-- | Convert an indexed optic to its unindexed equivalent.
noIx :: (IxOptic k s t a b, NonEmptyIndices is) => Optic k is s t a b -> Optic k NoIx s t a b

-- | Construct a conjoined indexed optic that provides a separate code path
--   when used without indices. Useful for defining indexed optics that are
--   as efficient as their unindexed equivalents when used without indices.
--   
--   <i>Note:</i> <tt><a>conjoined</a> f g</tt> is well-defined if and only
--   if <tt>f ≡ <a>noIx</a> g</tt>.
conjoined :: is `HasSingleIndex` i => Optic k NoIx s t a b -> Optic k is s t a b -> Optic k is s t a b

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: forall k l m is js ks s t u v a b. (JoinKinds k l m, AppendIndices is js ks) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two indexed optics. Their indices are composed as a pair.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;%&gt; ifolded) ["foo", "bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
(<%>) :: (JoinKinds k l m, IxOptic m s t a b, is `HasSingleIndex` i, js `HasSingleIndex` j) => Optic k is s t u v -> Optic l js u v a b -> Optic m (WithIx (i, j)) s t a b
infixl 9 <%>

-- | Compose two indexed optics and drop indices of the left one. (If you
--   want to compose a non-indexed and an indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&gt; ifolded) ["foo", "bar"]
--   [(0,'f'),(1,'o'),(2,'o'),(0,'b'),(1,'a'),(2,'r')]
--   </pre>
(%>) :: (JoinKinds k l m, IxOptic k s t u v, NonEmptyIndices is) => Optic k is s t u v -> Optic l js u v a b -> Optic m js s t a b
infixl 9 %>

-- | Compose two indexed optics and drop indices of the right one. (If you
--   want to compose an indexed and a non-indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;% ifolded) ["foo", "bar"]
--   [(0,'f'),(0,'o'),(0,'o'),(1,'b'),(1,'a'),(1,'r')]
--   </pre>
(<%) :: (JoinKinds k l m, IxOptic l u v a b, NonEmptyIndices js) => Optic k is s t u v -> Optic l js u v a b -> Optic m is s t a b
infixl 9 <%

-- | Remap the index.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (reindexed succ ifolded) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&amp; reindexed succ) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
reindexed :: is `HasSingleIndex` i => (i -> j) -> Optic k is s t a b -> Optic k (WithIx j) s t a b

-- | Flatten indices obtained from two indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded %&amp; icompose (,)) ["foo","bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
icompose :: (i -> j -> ix) -> Optic k '[i, j] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from three indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded % ifolded %&amp; icompose3 (,,)) [["foo","bar"],["xyz"]]
--   [((0,0,0),'f'),((0,0,1),'o'),((0,0,2),'o'),((0,1,0),'b'),((0,1,1),'a'),((0,1,2),'r'),((1,0,0),'x'),((1,0,1),'y'),((1,0,2),'z')]
--   </pre>
icompose3 :: (i1 -> i2 -> i3 -> ix) -> Optic k '[i1, i2, i3] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from four indexed optics.
icompose4 :: (i1 -> i2 -> i3 -> i4 -> ix) -> Optic k '[i1, i2, i3, i4] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from five indexed optics.
icompose5 :: (i1 -> i2 -> i3 -> i4 -> i5 -> ix) -> Optic k '[i1, i2, i3, i4, i5] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from arbitrary number of indexed optics.
icomposeN :: forall k i is s t a b. (CurryCompose is, NonEmptyIndices is) => Curry is i -> Optic k is s t a b -> Optic k (WithIx i) s t a b

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <tt>traverse_</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>traverse_</tt> l = <a>itraverse</a> <a>.</a> <tt>const</tt>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <tt>for_</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>for_</tt> a ≡ <a>ifor_</a> a <a>.</a> <tt>const</tt>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <tt>toList</tt> is more flexible in what it accepts.
--   
--   <pre>
--   <tt>toList</tt> ≡ <a>map</a> <tt>snd</tt> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <tt>.</tt> <tt>const</tt>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Getter s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Lens s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.An_AffineTraversal s t a b
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.An_AffineFold s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Traversal s t a b
instance (s GHC.Types.~ t, a GHC.Types.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Fold s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Setter s t a b


-- | This module provides, for data types having a <a>Generic</a> instance,
--   a way to focus on:
--   
--   <ul>
--   <li>their named total fields via <a>gfield</a>,</li>
--   <li>their named partial fields via <a>gafield</a>,</li>
--   <li>their constructors via <a>gconstructor</a>,</li>
--   <li>their fields at a specific position via <a>gposition</a>,</li>
--   <li>their fields of a specific type via <a>gplate</a>.</li>
--   </ul>
--   
--   <i>Note:</i> <a>gfield</a> and <a>gconstructor</a> are supported by
--   <a>labelOptic</a> and can be used with a consise syntax via
--   <tt>OverloadedLabels</tt>.
--   
--   If you're looking for optics for working with a generic representation
--   of a data type, there's <a>GHC.Generics.Optics</a>.
module Optics.Generic

-- | Focus on a field <tt>name</tt> of type <tt>a</tt> within a type
--   <tt>s</tt> using its <a>Generic</a> instance.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data User a
--     = User { name :: String
--            , age  :: a
--            }
--     | LazyUser { name :: String
--                , age  :: a
--                , lazy :: Bool
--                }
--     deriving (Show, Generic)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let user = User "Tom" 32 :: User Int
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; user ^. gfield @"name"
--   "Tom"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; user ^. gfield @"age"
--   32
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; user ^. gfield @"salary"
--   ...
--   ...Data constructor ‘User’ doesn't have a field named ‘salary’
--   ...In the...
--   ...
--   </pre>
--   
--   Only total fields are accessible (for partial ones see
--   <a>gafield</a>):
--   
--   <pre>
--   &gt;&gt;&gt; user ^. gfield @"lazy"
--   ...
--   ...Data constructor ‘User’ doesn't have a field named ‘lazy’
--   ...In the...
--   ...
--   </pre>
--   
--   Type changing updates are supported:
--   
--   <pre>
--   &gt;&gt;&gt; user &amp; gfield @"age" .~ ()
--   User {name = "Tom", age = ()}
--   </pre>
--   
--   Types without a <a>Generic</a> instance are not supported:
--   
--   <pre>
--   &gt;&gt;&gt; NoG 'x' ^. gfield @"any"
--   ...
--   ...Type ‘NoG’ doesn't have a Generic instance
--   ...In the...
--   ...
--   </pre>
--   
--   <i>Note:</i> <a>gfield</a> is supported by <a>labelOptic</a> and can
--   be used with a concise syntax via <tt>OverloadedLabels</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; user ^. #name
--   "Tom"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; user &amp; #age %~ (+1)
--   User {name = "Tom", age = 33}
--   </pre>
class GField (name :: Symbol) s t a b | name s -> t a b, name t -> s a b
gfield :: GField name s t a b => Lens s t a b

-- | Focus on a possibly partial field <tt>name</tt> of type <tt>a</tt>
--   within a type <tt>s</tt> using its <a>Generic</a> instance.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data Fish = Herring { name :: String }
--             | Tuna    { name :: String, sleeping :: Bool }
--     deriving Generic
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let herring = Herring { name = "Henry" }
--   
--   &gt;&gt;&gt; let tuna    = Tuna { name = "Tony", sleeping = True }
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; herring ^? gafield @"name"
--   Just "Henry"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; herring ^? gafield @"sleeping"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tuna ^? gafield @"sleeping"
--   Just True
--   </pre>
--   
--   Types without a <a>Generic</a> instance are not supported:
--   
--   <pre>
--   &gt;&gt;&gt; NoG 'x' ^? gafield @"any"
--   ...
--   ...Type ‘NoG’ doesn't have a Generic instance
--   ...In the...
--   ...
--   </pre>
--   
--   <i>Note:</i> trying to access a field that doesn't exist in any data
--   constructor results in an error:
--   
--   <pre>
--   &gt;&gt;&gt; tuna ^? gafield @"salary"
--   ...
--   ...Type ‘Fish’ doesn't have a field named ‘salary’
--   ...In the...
--   ...
--   </pre>
class GAffineField (name :: Symbol) s t a b | name s -> t a b, name t -> s a b
gafield :: GAffineField name s t a b => AffineTraversal s t a b

-- | Focus on a field at position <tt>n</tt> of type <tt>a</tt> within a
--   type <tt>s</tt> using its <a>Generic</a> instance.
--   
--   <pre>
--   &gt;&gt;&gt; ('a', 'b', 'c') ^. gposition @2
--   'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a', 'b') &amp; gposition @1 .~ "hi" &amp; gposition @2 .~ "there"
--   ("hi","there")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a', 'b', 'c') ^. gposition @4
--   ...
--   ...Data constructor ‘(,,)’ has 3 fields, 4th requested
--   ...In the...
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; () ^. gposition @1
--   ...
--   ...Data constructor ‘()’ has no fields, 1st requested
--   ...In the...
--   ...
--   </pre>
--   
--   Types without a <a>Generic</a> instance are not supported:
--   
--   <pre>
--   &gt;&gt;&gt; NoG 'x' ^. gposition @1
--   ...
--   ...Type ‘NoG’ doesn't have a Generic instance
--   ...In the...
--   ...
--   </pre>
--   
--   <i>Note:</i> Positions start from <tt>1</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', 'b') ^. gposition @0
--   ...
--   ...There is no 0th position
--   ...In the...
--   ...
--   </pre>
class GPosition (n :: Nat) s t a b | n s -> t a b, n t -> s a b
gposition :: GPosition n s t a b => Lens s t a b

-- | Focus on a constructor <tt>name</tt> of a type <tt>s</tt> using its
--   <a>Generic</a> instance.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   data Animal = Dog { name :: String, age :: Int }
--               | Cat { name :: String, purrs :: Bool }
--     deriving (Show, Generic)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let dog = Dog "Sparky" 2
--   
--   &gt;&gt;&gt; let cat = Cat "Cuddly" True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? gconstructor @"Dog"
--   Just ("Sparky",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? gconstructor @"Cat"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat &amp; gconstructor @"Cat" % _2 %~ not
--   Cat {name = "Cuddly", purrs = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog &amp; gconstructor @"Cat" % _1 .~ "Merry"
--   Dog {name = "Sparky", age = 2}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? gconstructor @"Parrot"
--   ...
--   ...Type ‘Animal’ doesn't have a constructor named ‘Parrot’
--   ...In the...
--   ...
--   </pre>
--   
--   Types without a <a>Generic</a> instance are not supported:
--   
--   <pre>
--   &gt;&gt;&gt; NoG 'x' ^. gconstructor @"NoG"
--   ...
--   ...Type ‘NoG’ doesn't have a Generic instance
--   ...In the...
--   ...
--   </pre>
--   
--   <i>Note:</i> <a>gconstructor</a> is supported by <a>labelOptic</a> and
--   can be used with a concise syntax via <tt>OverloadedLabels</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? #_Dog
--   Just ("Sparky",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat &amp; #_Cat % _1 .~ "Merry"
--   Cat {name = "Merry", purrs = True}
--   </pre>
class GConstructor (name :: Symbol) s t a b | name s -> t a b, name t -> s a b
gconstructor :: GConstructor name s t a b => Prism s t a b

-- | Traverse occurrences of a type <tt>a</tt> within a type <tt>s</tt>
--   using its <a>Generic</a> instance.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (gplate @Char) ('h', ((), 'e', Just 'l'), "lo")
--   "hello"
--   </pre>
--   
--   If <tt>a</tt> occurs recursively in its own definition, only outermost
--   occurrences of <tt>a</tt> within <tt>s</tt> will be traversed:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (gplate @String) ("one","two")
--   ["one","two"]
--   </pre>
--   
--   <i>Note:</i> types without a <a>Generic</a> instance in scope when
--   <a>GPlate</a> class constraint is resolved will not be entered during
--   the traversal.
--   
--   <pre>
--   &gt;&gt;&gt; let noG = (NoG 'n', (Just 'i', "c"), 'e')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (gplate @Char) noG
--   "ice"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deriving instance Generic NoG
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (gplate @Char) noG
--   "nice"
--   </pre>
class GPlate a s
gplate :: GPlate a s => Traversal' s a
instance Optics.Generic.GPlateContext a s => Optics.Generic.GPlate a s
instance Optics.Generic.GPlate a Optics.Generic.Void0
instance Optics.Generic.GPlate Optics.Generic.Void0 a
instance Optics.Generic.GConstructorContext repDefined name s t a b => Optics.Generic.GConstructor name s t a b
instance (a GHC.Types.~ Optics.Generic.Void0, b GHC.Types.~ Optics.Generic.Void0) => Optics.Generic.GConstructor name Optics.Generic.Void0 Optics.Generic.Void0 a b
instance Optics.Generic.GPositionContext repDefined n s t a b => Optics.Generic.GPosition n s t a b
instance (a GHC.Types.~ Optics.Generic.Void0, b GHC.Types.~ Optics.Generic.Void0) => Optics.Generic.GPosition name Optics.Generic.Void0 Optics.Generic.Void0 a b
instance Optics.Generic.GAFieldContext repDefined name s t a b => Optics.Generic.GAffineField name s t a b
instance (a GHC.Types.~ Optics.Generic.Void0, b GHC.Types.~ Optics.Generic.Void0) => Optics.Generic.GAffineField name Optics.Generic.Void0 Optics.Generic.Void0 a b
instance Optics.Generic.GFieldContext name s t a b => Optics.Generic.GField name s t a b
instance (a GHC.Types.~ Optics.Generic.Void0, b GHC.Types.~ Optics.Generic.Void0) => Optics.Generic.GField name Optics.Generic.Void0 Optics.Generic.Void0 a b


-- | This module defines <a>Lens</a>es for the fields of tuple types. These
--   are overloaded using the <a>Field1</a> to <a>Field9</a> typeclasses,
--   so that <a>_1</a> can be used as a <a>Lens</a> for the first field of
--   a tuple with any number of fields (up to the maximum supported tuple
--   size, which is currently 9). For example:
--   
--   <pre>
--   &gt;&gt;&gt; view _1 ('a','b','c')
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _3 True ('a','b','c')
--   ('a','b',True)
--   </pre>
--   
--   If a datatype has a <tt>Generic</tt> instance, the corresponding
--   <tt>FieldN</tt> instances can be defined using their default methods:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; import GHC.Generics (Generic)
--   
--   &gt;&gt;&gt; data T a b = MkT a Int b deriving (Generic, Show)
--   
--   &gt;&gt;&gt; instance Field1 (T a c) (T b c) a b
--   
--   &gt;&gt;&gt; instance Field2 (T a b) (T a b) Int Int
--   
--   &gt;&gt;&gt; instance Field3 (T c a) (T c b) a b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _3 'x' (MkT False 1 ())
--   MkT False 1 'x'
--   </pre>
--   
--   For a generalization of this pattern see <a>GPosition</a>.
module Data.Tuple.Optics

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) ^. _1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 %~ (+41)
--   (42,2,3,4,5)
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) ^. _1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 %~ (+41)
--   (42,2,3,4,5)
--   </pre>
_1 :: (Field1 s t a b, GPosition 1 s t a b) => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 %~ (*3)
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _2 print (1,2)
--   2
--   (1,())
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 %~ (*3)
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _2 print (1,2)
--   2
--   (1,())
--   </pre>
_2 :: (Field2 s t a b, GPosition 2 s t a b) => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 3rd field of a tuple.
_3 :: Field3 s t a b => Lens s t a b

-- | Access the 3rd field of a tuple.
_3 :: (Field3 s t a b, GPosition 3 s t a b) => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 4th field of a tuple.
_4 :: Field4 s t a b => Lens s t a b

-- | Access the 4th field of a tuple.
_4 :: (Field4 s t a b, GPosition 4 s t a b) => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 5th field of a tuple.
_5 :: Field5 s t a b => Lens s t a b

-- | Access the 5th field of a tuple.
_5 :: (Field5 s t a b, GPosition 5 s t a b) => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 6th field of a tuple.
_6 :: Field6 s t a b => Lens s t a b

-- | Access the 6th field of a tuple.
_6 :: (Field6 s t a b, GPosition 6 s t a b) => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 7th field of a tuple.
_7 :: Field7 s t a b => Lens s t a b

-- | Access the 7th field of a tuple.
_7 :: (Field7 s t a b, GPosition 7 s t a b) => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 8th field of a tuple.
_8 :: Field8 s t a b => Lens s t a b

-- | Access the 8th field of a tuple.
_8 :: (Field8 s t a b, GPosition 8 s t a b) => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 9th field of a tuple.
_9 :: Field9 s t a b => Lens s t a b

-- | Access the 9th field of a tuple.
_9 :: (Field9 s t a b, GPosition 9 s t a b) => Lens s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b
instance Data.Tuple.Optics.Field9 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h, i') i i'
instance Data.Tuple.Optics.Field8 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g, h') h h'
instance Data.Tuple.Optics.Field8 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h', i) h h'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g) (a, b, c, d, e, f, g') g g'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g', h) g g'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g', h, i) g g'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f) (a, b, c, d, e, f') f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g) (a, b, c, d, e, f', g) f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f', g, h) f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f', g, h, i) f f'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e) (a, b, c, d, e') e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f) (a, b, c, d, e', f) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g) (a, b, c, d, e', f, g) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g, h) (a, b, c, d, e', f, g, h) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e', f, g, h, i) e e'
instance Data.Tuple.Optics.Field4 (a, b, c, d) (a, b, c, d') d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f) (a, b, c, d', e, f) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g) (a, b, c, d', e, f, g) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g, h) (a, b, c, d', e, f, g, h) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g, h, i) (a, b, c, d', e, f, g, h, i) d d'
instance Data.Tuple.Optics.Field3 (a, b, c) (a, b, c') c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d) (a, b, c', d) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f) (a, b, c', d, e, f) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g) (a, b, c', d, e, f, g) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g, h) (a, b, c', d, e, f, g, h) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g, h, i) (a, b, c', d, e, f, g, h, i) c c'
instance Data.Tuple.Optics.Field2 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f g' a) (g a) (g' a)
instance Data.Tuple.Optics.Field2 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f g' p) (g p) (g' p)
instance Data.Tuple.Optics.Field2 (a, b) (a, b') b b'
instance Data.Tuple.Optics.Field2 (a, b, c) (a, b', c) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d) (a, b', c, d) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f) (a, b', c, d, e, f) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g) (a, b', c, d, e, f, g) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g, h) (a, b', c, d, e, f, g, h) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g, h, i) (a, b', c, d, e, f, g, h, i) b b'
instance Data.Tuple.Optics.Field1 (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance Data.Tuple.Optics.Field1 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f' g a) (f a) (f' a)
instance Data.Tuple.Optics.Field1 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f' g p) (f p) (f' p)
instance Data.Tuple.Optics.Field1 (a, b) (a', b) a a'
instance Data.Tuple.Optics.Field1 (a, b, c) (a', b, c) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d) (a', b, c, d) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f) (a', b, c, d, e, f) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g) (a', b, c, d, e, f, g) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g, h) (a', b, c, d, e, f, g, h) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g, h, i) (a', b, c, d, e, f, g, h, i) a a'


-- | This module defines the <a>Cons</a> and <a>Snoc</a> classes, which
--   provide <a>Prism</a>s for the leftmost and rightmost elements of a
--   container, respectively.
--   
--   Note that orphan instances for these classes are defined in the
--   <tt>Optics.Cons</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
module Optics.Cons.Core

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (Vector a) (Vector b) (a, Vector a) (b, Vector b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> Text (<a>Char</a>, Text)
--   <a>_Cons</a> :: <a>Prism'</a> ByteString (<a>Word8</a>, ByteString)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;| "bc"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| [2, 3]
--   [1,2,3]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' ""
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' "bc"
--   "abc"
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | An <a>AffineTraversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _head
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" &amp; _head .~ 'd'
--   "dbc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _head %~ (*10)
--   [10,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ absurd
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
_head :: Cons s s a a => AffineTraversal' s a

-- | An <a>AffineTraversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _tail .~ "cde"
--   "acde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4,5] &amp; _tail % traversed %~ (*10)
--   [1,20,30,40,50]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _tail
--   Just "bc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _tail
--   Just "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _tail
--   Nothing
--   </pre>
_tail :: Cons s s a a => AffineTraversal' s s

-- | Pattern synonym for matching on the leftmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (x :&lt; _) -&gt; x
--   'a'
--   </pre>
pattern (:<) :: forall s a. Cons s s a a => a -> s -> s
infixr 5 :<

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "" |&gt; 'a'
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "bc" |&gt; 'a'
--   "bca"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc "hello" '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc "hello!"
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc ""
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | An <a>AffineTraversal</a> reading and replacing all but the a last
--   element of a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? _init
--   Just "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _init .~ "cde"
--   "cdeb"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; _init % traversed %~ (*10)
--   [10,20,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _init
--   Just "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _init
--   Nothing
--   </pre>
_init :: Snoc s s a a => AffineTraversal' s s

-- | An <a>AffineTraversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _last
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _last %~ (+1)
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
_last :: Snoc s s a a => AffineTraversal' s a

-- | Pattern synonym for matching on the rightmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (_ :&gt; x) -&gt; x
--   'c'
--   </pre>
pattern (:>) :: forall s a. Snoc s s a a => s -> a -> s
infixl 5 :>
instance Optics.Cons.Core.Snoc [a] [b] a b
instance Optics.Cons.Core.Snoc (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Optics.Cons.Core.Snoc (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Optics.Cons.Core.Cons [a] [b] a b
instance Optics.Cons.Core.Cons (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Optics.Cons.Core.Cons (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b


module Numeric.Optics

-- | A prism that shows and reads integers in base-2 through base-36
--   
--   Note: This is an improper prism, since leading 0s are stripped when
--   reading.
--   
--   <pre>
--   &gt;&gt;&gt; "100" ^? base 16
--   Just 256
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1767707668033969 ^. re (base 36)
--   "helloworld"
--   </pre>
base :: (HasCallStack, Integral a) => Int -> Prism' String a

-- | This <a>Prism</a> can be used to model the fact that every
--   <a>Integral</a> type is a subset of <a>Integer</a>.
--   
--   Embedding through the <a>Prism</a> only succeeds if the <a>Integer</a>
--   would pass through unmodified when re-extracted.
integral :: (Integral a, Integral b) => Prism Integer Integer a b

-- | <pre>
--   <a>binary</a> = <a>base</a> 2
--   </pre>
binary :: Integral a => Prism' String a

-- | <pre>
--   <a>octal</a> = <a>base</a> 8
--   </pre>
octal :: Integral a => Prism' String a

-- | <pre>
--   <a>decimal</a> = <a>base</a> 10
--   </pre>
decimal :: Integral a => Prism' String a

-- | <pre>
--   <a>hex</a> = <a>base</a> 16
--   </pre>
hex :: Integral a => Prism' String a

-- | <pre>
--   <a>adding</a> n = <a>iso</a> (+n) (subtract n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3] ^.. traversed % adding 1000
--   [1001,1002,1003]
--   </pre>
adding :: Num a => a -> Iso' a a

-- | <pre>
--   <a>subtracting</a> n = <a>iso</a> (subtract n) ((+n)
--   <a>subtracting</a> n = <a>re</a> (<a>adding</a> n)
--   </pre>
subtracting :: Num a => a -> Iso' a a

-- | <pre>
--   <a>multiplying</a> n = iso (*n) (/n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; multiplying 1000 %~ (+3)
--   5.003
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fahrenheit = multiplying (9/5) % adding 32 in 230 ^. re fahrenheit
--   110.0
--   </pre>
multiplying :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>dividing</a> n = <a>iso</a> (/n) (*n)
--   <a>dividing</a> n = <a>re</a> (<a>multiplying</a> n)
--   </pre>
--   
--   Note: This errors for n = 0
dividing :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>exponentiating</a> n = <a>iso</a> (**n) (**recip n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum % re (exponentiating 2)) (foldMapOf each) (3,4) == 5
--   True
--   </pre>
exponentiating :: (Floating a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>negated</a> = <a>iso</a> <a>negate</a> <a>negate</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum % negated) (foldMapOf each) (3,4) == 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum) (foldMapOf (each % negated)) (3,4) == -7
--   True
--   </pre>
negated :: Num a => Iso' a a

-- | Pattern synonym that can be used to construct or pattern match on an
--   <a>Integer</a> as if it were of any <a>Integral</a> type.
pattern Integral :: forall a. Integral a => a -> Integer


-- | See the <tt>Optics</tt> module in the main <tt>optics</tt> package for
--   overview documentation.
module Optics.Core


-- | This module defines optics for constructing and manipulating finite
--   <a>Seq</a>s.
module Data.Sequence.Optics

-- | A <a>Seq</a> is isomorphic to a <a>ViewL</a>
--   
--   <pre>
--   <tt>viewl</tt> m ≡ m <a>^.</a> <a>viewL</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3] ^. viewL
--   1 :&lt; fromList [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewL
--   EmptyL
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyL ^. re viewL
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewL $ 1 Seq.:&lt; Seq.fromList [2,3]
--   fromList [1,2,3]
--   </pre>
viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)

-- | A <a>Seq</a> is isomorphic to a <a>ViewR</a>
--   
--   <pre>
--   <tt>viewr</tt> m ≡ m <a>^.</a> <a>viewR</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3] ^. viewR
--   fromList [1,2] :&gt; 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewR
--   EmptyR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyR ^. re viewR
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewR $ Seq.fromList [1,2] Seq.:&gt; 3
--   fromList [1,2,3]
--   </pre>
viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)

-- | Traverse all the elements numbered from <tt>i</tt> to <tt>j</tt> of a
--   <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] &amp; sliced 1 3 %~ (*10)
--   fromList [1,20,30,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] ^.. sliced 1 3
--   [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] &amp; sliced 1 3 .~ 0
--   fromList [1,0,0,4,5]
--   </pre>
sliced :: Int -> Int -> IxTraversal' Int (Seq a) a

-- | Traverse the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] ^.. slicedTo 2
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] &amp; slicedTo 2 %~ (*10)
--   fromList [10,20,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,4,5,6] &amp; slicedTo 10 .~ 0
--   fromList [0,0,0,0,0]
--   </pre>
slicedTo :: Int -> IxTraversal' Int (Seq a) a

-- | Traverse all but the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] ^.. slicedFrom 2
--   [3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] &amp; slicedFrom 2 %~ (*10)
--   fromList [1,2,30,40,50]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3,4,5] &amp; slicedFrom 10 .~ 0
--   fromList [1,2,3,4,5]
--   </pre>
slicedFrom :: Int -> IxTraversal' Int (Seq a) a

-- | Construct a <a>Seq</a> from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; seqOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; seqOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
seqOf :: Is k A_Fold => Optic' k is s a -> s -> Seq a
