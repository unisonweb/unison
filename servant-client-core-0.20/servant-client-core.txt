-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core functionality and class for client function generation for servant APIs
--   
--   This library provides backend-agnostic generation of client functions.
--   For more information, see the README.
@package servant-client-core
@version 0.20

module Servant.Client.Core.BaseUrl

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
newtype InvalidBaseUrlException
InvalidBaseUrlException :: String -> InvalidBaseUrlException
instance Data.Data.Data Servant.Client.Core.BaseUrl.Scheme
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.BaseUrl.Scheme
instance GHC.Generics.Generic Servant.Client.Core.BaseUrl.Scheme
instance GHC.Classes.Ord Servant.Client.Core.BaseUrl.Scheme
instance GHC.Classes.Eq Servant.Client.Core.BaseUrl.Scheme
instance GHC.Show.Show Servant.Client.Core.BaseUrl.Scheme
instance Data.Data.Data Servant.Client.Core.BaseUrl.BaseUrl
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.BaseUrl.BaseUrl
instance GHC.Generics.Generic Servant.Client.Core.BaseUrl.BaseUrl
instance GHC.Classes.Ord Servant.Client.Core.BaseUrl.BaseUrl
instance GHC.Show.Show Servant.Client.Core.BaseUrl.BaseUrl
instance GHC.Show.Show Servant.Client.Core.BaseUrl.InvalidBaseUrlException
instance GHC.Exception.Type.Exception Servant.Client.Core.BaseUrl.InvalidBaseUrlException
instance Control.DeepSeq.NFData Servant.Client.Core.BaseUrl.BaseUrl
instance GHC.Classes.Eq Servant.Client.Core.BaseUrl.BaseUrl
instance Data.Aeson.Types.ToJSON.ToJSON Servant.Client.Core.BaseUrl.BaseUrl
instance Data.Aeson.Types.FromJSON.FromJSON Servant.Client.Core.BaseUrl.BaseUrl
instance Data.Aeson.Types.ToJSON.ToJSONKey Servant.Client.Core.BaseUrl.BaseUrl
instance Data.Aeson.Types.FromJSON.FromJSONKey Servant.Client.Core.BaseUrl.BaseUrl

module Servant.Client.Core.Request
type Request = RequestF RequestBody Builder
data RequestF body path
Request :: path -> Seq QueryItem -> Maybe (body, MediaType) -> Seq MediaType -> Seq Header -> HttpVersion -> Method -> RequestF body path
[requestPath] :: RequestF body path -> path
[requestQueryString] :: RequestF body path -> Seq QueryItem
[requestBody] :: RequestF body path -> Maybe (body, MediaType)
[requestAccept] :: RequestF body path -> Seq MediaType
[requestHeaders] :: RequestF body path -> Seq Header
[requestHttpVersion] :: RequestF body path -> HttpVersion
[requestMethod] :: RequestF body path -> Method

-- | The request body. R replica of the <tt>http-client</tt>
--   <tt>RequestBody</tt>.
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodySource :: SourceIO ByteString -> RequestBody
defaultRequest :: Request

-- | Add header to the request being constructed.
addHeader :: ToHttpApiData a => HeaderName -> a -> Request -> Request

-- | Append extra path to the request being constructed.
--   
--   Warning: This function assumes that the path fragment is already
--   URL-encoded.
appendToPath :: Builder -> Request -> Request

-- | Append a query parameter to the request being constructed.
appendToQueryString :: Text -> Maybe ByteString -> Request -> Request

-- | Encode a query parameter value.
encodeQueryParamValue :: ToHttpApiData a => a -> ByteString

-- | Set body and media type of the request being constructed.
setRequestBody :: RequestBody -> MediaType -> Request -> Request

-- | Set body and media type of the request being constructed.
--   
--   The body is set to the given bytestring using the
--   <a>RequestBodyLBS</a> constructor.
setRequestBodyLBS :: ByteString -> MediaType -> Request -> Request
instance Data.Traversable.Traversable (Servant.Client.Core.Request.RequestF body)
instance Data.Foldable.Foldable (Servant.Client.Core.Request.RequestF body)
instance GHC.Base.Functor (Servant.Client.Core.Request.RequestF body)
instance (GHC.Classes.Eq path, GHC.Classes.Eq body) => GHC.Classes.Eq (Servant.Client.Core.Request.RequestF body path)
instance GHC.Generics.Generic (Servant.Client.Core.Request.RequestF body path)
instance GHC.Generics.Generic Servant.Client.Core.Request.RequestBody
instance GHC.Show.Show Servant.Client.Core.Request.RequestBody
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Servant.Client.Core.Request.RequestF a b)
instance Data.Bifunctor.Bifunctor Servant.Client.Core.Request.RequestF
instance Data.Bifoldable.Bifoldable Servant.Client.Core.Request.RequestF
instance Data.Bitraversable.Bitraversable Servant.Client.Core.Request.RequestF
instance (Control.DeepSeq.NFData path, Control.DeepSeq.NFData body) => Control.DeepSeq.NFData (Servant.Client.Core.Request.RequestF body path)


-- | Basic Authentication for clients
module Servant.Client.Core.BasicAuth

-- | Authenticate a request using Basic Authentication
basicAuthReq :: BasicAuthData -> Request -> Request


-- | Authentication for clients
module Servant.Client.Core.Auth

-- | For a resource protected by authentication (e.g. AuthProtect), we need
--   to provide the client with some data used to add authentication data
--   to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
type family AuthClientData a :: *

-- | For better type inference and to avoid usage of a data family, we
--   newtype wrap the combination of some <a>AuthClientData</a> and a
--   function to add authentication data to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
newtype AuthenticatedRequest a
AuthenticatedRequest :: (AuthClientData a, AuthClientData a -> Request -> Request) -> AuthenticatedRequest a
[unAuthReq] :: AuthenticatedRequest a -> (AuthClientData a, AuthClientData a -> Request -> Request)

-- | Handy helper to avoid wrapping datatypes in tuples everywhere.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
mkAuthenticatedRequest :: AuthClientData a -> (AuthClientData a -> Request -> Request) -> AuthenticatedRequest a

module Servant.Client.Core.Response
type Response = ResponseF ByteString
type StreamingResponse = ResponseF (SourceIO ByteString)
data ResponseF a
Response :: Status -> Seq Header -> HttpVersion -> a -> ResponseF a
[responseStatusCode] :: ResponseF a -> Status
[responseHeaders] :: ResponseF a -> Seq Header
[responseHttpVersion] :: ResponseF a -> HttpVersion
[responseBody] :: ResponseF a -> a
instance Data.Traversable.Traversable Servant.Client.Core.Response.ResponseF
instance Data.Foldable.Foldable Servant.Client.Core.Response.ResponseF
instance GHC.Base.Functor Servant.Client.Core.Response.ResponseF
instance GHC.Generics.Generic (Servant.Client.Core.Response.ResponseF a)
instance GHC.Show.Show a => GHC.Show.Show (Servant.Client.Core.Response.ResponseF a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Servant.Client.Core.Response.ResponseF a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Servant.Client.Core.Response.ResponseF a)

module Servant.Client.Core.ClientError

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ClientError

-- | The server returned an error response including the failing request.
--   <a>requestPath</a> includes the <a>BaseUrl</a> and the path of the
--   request.
FailureResponse :: RequestF () (BaseUrl, ByteString) -> Response -> ClientError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ClientError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ClientError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ClientError

-- | There was a connection error, and no response was received
ConnectionError :: SomeException -> ClientError
instance GHC.Generics.Generic Servant.Client.Core.ClientError.ClientError
instance GHC.Show.Show Servant.Client.Core.ClientError.ClientError
instance GHC.Classes.Eq Servant.Client.Core.ClientError.ClientError
instance GHC.Exception.Type.Exception Servant.Client.Core.ClientError.ClientError
instance Control.DeepSeq.NFData Servant.Client.Core.ClientError.ClientError


-- | Types for possible backends to run client-side <a>RequestF</a> queries
module Servant.Client.Core.RunClient
class Monad m => RunClient m

-- | How to make a request, with an optional list of status codes to not
--   throw exceptions for (default: [200..299]).
runRequestAcceptStatus :: RunClient m => Maybe [Status] -> Request -> m Response
throwClientError :: RunClient m => ClientError -> m a

-- | How to make a request.
runRequest :: RunClient m => Request -> m Response
class RunClient m => RunStreamingClient m
withStreamingRequest :: RunStreamingClient m => Request -> (StreamingResponse -> IO a) -> m a

-- | <a>ClientF</a> cannot stream.
--   
--   Compare to <a>RunClient</a>.
data ClientF a
RunRequest :: Request -> (Response -> a) -> ClientF a
Throw :: ClientError -> ClientF a
instance GHC.Base.Functor Servant.Client.Core.RunClient.ClientF
instance (Servant.Client.Core.RunClient.ClientF GHC.Types.~ f) => Servant.Client.Core.RunClient.RunClient (Control.Monad.Free.Free f)

module Servant.Client.Core.HasClient

-- | <a>clientIn</a> allows you to produce operations to query an API from
--   a client within a <a>RunClient</a> monad.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   clientM :: Proxy ClientM
--   clientM = Proxy
--   
--   getAllBooks :: ClientM [Book]
--   postNewBook :: Book -&gt; ClientM Book
--   (getAllBooks :&lt;|&gt; postNewBook) = myApi `clientIn` clientM
--   </pre>
clientIn :: HasClient m api => Proxy api -> Proxy m -> Client m api

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient

-- | A type that specifies that an API record contains a client
--   implementation.
data AsClientT (m :: * -> *)

-- | Helper to make code using records of clients more readable.
--   
--   Can be mixed with (/:) for supplying arguments.
--   
--   Example:
--   
--   <pre>
--   type Api = NamedRoutes RootApi
--   
--   data RootApi mode = RootApi
--     { subApi :: mode :- NamedRoutes SubApi
--     , …
--     } deriving Generic
--   
--   data SubApi mode = SubApi
--     { endpoint :: mode :- Get '[JSON] Person
--     , …
--     } deriving Generic
--   
--   api :: Proxy API
--   api = Proxy
--   
--   rootClient :: RootApi (AsClientT ClientM)
--   rootClient = client api
--   
--   endpointClient :: ClientM Person
--   endpointClient = client // subApi // endpoint
--   </pre>
(//) :: a -> (a -> b) -> b
infixl 1 //

-- | Convenience function for supplying arguments to client functions when
--   working with records of clients.
--   
--   Intended to be used in conjunction with <a>(//)</a>.
--   
--   Example:
--   
--   <pre>
--   type Api = NamedRoutes RootApi
--   
--   data RootApi mode = RootApi
--     { subApi :: mode :- Capture "token" String :&gt; NamedRoutes SubApi
--     , hello :: mode :- Capture "name" String :&gt; Get '[JSON] String
--     , …
--     } deriving Generic
--   
--   data SubApi mode = SubApi
--     { endpoint :: mode :- Get '[JSON] Person
--     , …
--     } deriving Generic
--   
--   api :: Proxy API
--   api = Proxy
--   
--   rootClient :: RootApi (AsClientT ClientM)
--   rootClient = client api
--   
--   hello :: String -&gt; ClientM String
--   hello name = rootClient // hello /: name
--   
--   endpointClient :: ClientM Person
--   endpointClient = client // subApi /: "foobar123" // endpoint
--   </pre>
(/:) :: (a -> b -> c) -> b -> a -> c
infixl 2 /:

-- | Convenience function to apply a function to an unknown union element
--   using a type class. All elements of the union must have instances in
--   the type class, and the function is applied unconditionally.
--   
--   See also: <a>matchUnion</a>.
foldMapUnion :: forall c a (as :: [Type]). All c as => Proxy c -> (forall x. c x => x -> a) -> Union as -> a

-- | Convenience function to extract a union element using <tt>cast</tt>,
--   ie. return the value if the selected type happens to be the actual
--   type of the union in this value, or <a>Nothing</a> otherwise.
--   
--   See also: <a>foldMapUnion</a>.
matchUnion :: forall a (as :: [Type]). IsMember a as => Union as -> Maybe a
instance GHC.Enum.Enum Servant.Client.Core.HasClient.EmptyClient
instance GHC.Enum.Bounded Servant.Client.Core.HasClient.EmptyClient
instance GHC.Show.Show Servant.Client.Core.HasClient.EmptyClient
instance GHC.Classes.Eq Servant.Client.Core.HasClient.EmptyClient
instance GHC.Show.Show Servant.Client.Core.HasClient.ClientParseError
instance GHC.Classes.Eq Servant.Client.Core.HasClient.ClientParseError
instance Servant.Client.Core.HasClient.GClientConstraints api m => Servant.Client.Core.HasClient.GClient api m
instance (forall (n :: * -> *). Servant.Client.Core.HasClient.GClient api n, Servant.Client.Core.HasClient.HasClient m (Servant.API.Generic.ToServantApi api), Servant.Client.Core.RunClient.RunClient m, Servant.API.TypeErrors.ErrorIfNoGeneric api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.NamedRoutes.NamedRoutes api)
instance Servant.API.Generic.GenericMode (Servant.Client.Core.HasClient.AsClientT m)
instance Servant.API.ContentTypes.AllMimeUnrender cts a => Servant.Client.Core.HasClient.UnrenderResponse cts a
instance (Servant.Client.Core.HasClient.UnrenderResponse cts a, Servant.API.ResponseHeaders.BuildHeadersTo h) => Servant.Client.Core.HasClient.UnrenderResponse cts (Servant.API.ResponseHeaders.Headers h a)
instance Servant.Client.Core.HasClient.UnrenderResponse cts a => Servant.Client.Core.HasClient.UnrenderResponse cts (Servant.API.UVerb.WithStatus n a)
instance (Servant.Client.Core.RunClient.RunClient m, contentTypes GHC.Types.~ (contentType : otherContentTypes), as GHC.Types.~ (a : as'), Servant.API.ContentTypes.AllMime contentTypes, Servant.API.Verbs.ReflectMethod method, Data.SOP.Constraint.All (Servant.Client.Core.HasClient.UnrenderResponse contentTypes) as, Data.SOP.Constraint.All Servant.API.UVerb.HasStatus as, Servant.API.UVerb.HasStatuses as', Servant.API.UVerb.Union.Unique (Servant.API.UVerb.Statuses as)) => Servant.Client.Core.HasClient.HasClient m (Servant.API.UVerb.UVerb method contentTypes as)
instance Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Empty.EmptyAPI
instance (Servant.Client.Core.HasClient.HasClient m a, Servant.Client.Core.HasClient.HasClient m b) => Servant.Client.Core.HasClient.HasClient m (a Servant.API.Alternative.:<|> b)
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.HasClient.HasClient m sublayout) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Capture.CaptureAll capture a Servant.API.Sub.:> sublayout)
instance forall k1 (m :: * -> *) ct a (method :: k1) (cts' :: [*]) (cts :: [*]) (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.Verbs.ReflectMethod method, cts' GHC.Types.~ (ct : cts), GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a)
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.TypeNats.Nat) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts Servant.API.ContentTypes.NoContent)
instance forall k1 (m :: * -> *) (method :: k1). (Servant.Client.Core.RunClient.RunClient m, Servant.API.Verbs.ReflectMethod method) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.NoContentVerb method)
instance forall k1 (m :: * -> *) ct a (ls :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1) (cts' :: [*]) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.ResponseHeaders.BuildHeadersTo ls, GHC.TypeNats.KnownNat status, Servant.API.Verbs.ReflectMethod method, cts' GHC.Types.~ (ct : cts)) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' (Servant.API.ResponseHeaders.Headers ls a))
instance forall k1 (m :: * -> *) (ls :: [*]) (method :: k1) (status :: GHC.TypeNats.Nat) (cts :: [*]). (Servant.Client.Core.RunClient.RunClient m, Servant.API.ResponseHeaders.BuildHeadersTo ls, Servant.API.Verbs.ReflectMethod method, GHC.TypeNats.KnownNat status) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts (Servant.API.ResponseHeaders.Headers ls Servant.API.ContentTypes.NoContent))
instance forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Stream.Stream method status framing ct a)
instance forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (hs :: [*]) (status :: GHC.TypeNats.Nat). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a, Servant.API.ResponseHeaders.BuildHeadersTo hs) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Stream.Stream method status framing ct (Servant.API.ResponseHeaders.Headers hs a))
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.HasClient.HasClient m api, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods)) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.Description.Summary desc Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.Description.Description desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.HasClient.HasClient m api, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods)) => Servant.Client.Core.HasClient.HasClient m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.QueryParam.QueryParams sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api)
instance Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Raw.Raw
instance Servant.Client.Core.RunClient.RunClient m => Servant.Client.Core.HasClient.HasClient m Servant.API.Raw.RawM
instance (Servant.API.ContentTypes.MimeRender ct a, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api)
instance (Servant.Client.Core.HasClient.HasClient m api, Servant.API.ContentTypes.MimeRender ctype chunk, Servant.API.Stream.FramingRender framing, Servant.API.Stream.ToSourceIO chunk a) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Stream.StreamBody' mods framing ctype a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol path, Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (path Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Data.Vault.Lazy.Vault Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m subapi => Servant.Client.Core.HasClient.HasClient m (Servant.API.WithNamedContext.WithNamedContext name context subapi)
instance Servant.Client.Core.HasClient.HasClient m subapi => Servant.Client.Core.HasClient.HasClient m (Servant.API.WithResource.WithResource res Servant.API.Sub.:> subapi)
instance forall k (m :: * -> *) api (tag :: k). Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api)
instance (Servant.API.TypeLevel.AtLeastOneFragment api, Servant.API.TypeLevel.FragmentUnique (Servant.API.Fragment.Fragment a Servant.API.Sub.:> api), Servant.Client.Core.HasClient.HasClient m api) => Servant.Client.Core.HasClient.HasClient m (Servant.API.Fragment.Fragment a Servant.API.Sub.:> api)
instance Servant.Client.Core.HasClient.HasClient m api => Servant.Client.Core.HasClient.HasClient m (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api)
instance forall (m :: * -> *) a b (arr :: a -> b) sub. (Servant.Client.Core.RunClient.RunClient m, (TypeError ...)) => Servant.Client.Core.HasClient.HasClient m (arr Servant.API.Sub.:> sub)
instance forall k (m :: * -> *) (ty :: k) sub. (Servant.Client.Core.RunClient.RunClient m, (TypeError ...)) => Servant.Client.Core.HasClient.HasClient m (ty Servant.API.Sub.:> sub)
instance (Servant.Client.Core.RunClient.RunClient m, (TypeError ...)) => Servant.Client.Core.HasClient.HasClient m api


-- | This module is a utility for <tt>servant-client-core</tt> backend
--   writers. It contains all the functionality from
--   <tt>servant-client-core</tt> that should be re-exported.
module Servant.Client.Core.Reexport

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api

-- | Convenience function to apply a function to an unknown union element
--   using a type class. All elements of the union must have instances in
--   the type class, and the function is applied unconditionally.
--   
--   See also: <a>matchUnion</a>.
foldMapUnion :: forall c a (as :: [Type]). All c as => Proxy c -> (forall x. c x => x -> a) -> Union as -> a

-- | Convenience function to extract a union element using <tt>cast</tt>,
--   ie. return the value if the selected type happens to be the actual
--   type of the union in this value, or <a>Nothing</a> otherwise.
--   
--   See also: <a>foldMapUnion</a>.
matchUnion :: forall a (as :: [Type]). IsMember a as => Union as -> Maybe a

-- | A type that specifies that an API record contains a client
--   implementation.
data AsClientT (m :: * -> *)

-- | Helper to make code using records of clients more readable.
--   
--   Can be mixed with (/:) for supplying arguments.
--   
--   Example:
--   
--   <pre>
--   type Api = NamedRoutes RootApi
--   
--   data RootApi mode = RootApi
--     { subApi :: mode :- NamedRoutes SubApi
--     , …
--     } deriving Generic
--   
--   data SubApi mode = SubApi
--     { endpoint :: mode :- Get '[JSON] Person
--     , …
--     } deriving Generic
--   
--   api :: Proxy API
--   api = Proxy
--   
--   rootClient :: RootApi (AsClientT ClientM)
--   rootClient = client api
--   
--   endpointClient :: ClientM Person
--   endpointClient = client // subApi // endpoint
--   </pre>
(//) :: a -> (a -> b) -> b
infixl 1 //

-- | Convenience function for supplying arguments to client functions when
--   working with records of clients.
--   
--   Intended to be used in conjunction with <a>(//)</a>.
--   
--   Example:
--   
--   <pre>
--   type Api = NamedRoutes RootApi
--   
--   data RootApi mode = RootApi
--     { subApi :: mode :- Capture "token" String :&gt; NamedRoutes SubApi
--     , hello :: mode :- Capture "name" String :&gt; Get '[JSON] String
--     , …
--     } deriving Generic
--   
--   data SubApi mode = SubApi
--     { endpoint :: mode :- Get '[JSON] Person
--     , …
--     } deriving Generic
--   
--   api :: Proxy API
--   api = Proxy
--   
--   rootClient :: RootApi (AsClientT ClientM)
--   rootClient = client api
--   
--   hello :: String -&gt; ClientM String
--   hello name = rootClient // hello /: name
--   
--   endpointClient :: ClientM Person
--   endpointClient = client // subApi /: "foobar123" // endpoint
--   </pre>
(/:) :: (a -> b -> c) -> b -> a -> c
infixl 2 /:
type Response = ResponseF ByteString
type StreamingResponse = ResponseF (SourceIO ByteString)
data ResponseF a
Response :: Status -> Seq Header -> HttpVersion -> a -> ResponseF a
[responseStatusCode] :: ResponseF a -> Status
[responseHeaders] :: ResponseF a -> Seq Header
[responseHttpVersion] :: ResponseF a -> HttpVersion
[responseBody] :: ResponseF a -> a

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ClientError

-- | The server returned an error response including the failing request.
--   <a>requestPath</a> includes the <a>BaseUrl</a> and the path of the
--   request.
FailureResponse :: RequestF () (BaseUrl, ByteString) -> Response -> ClientError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ClientError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ClientError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ClientError

-- | There was a connection error, and no response was received
ConnectionError :: SomeException -> ClientError

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
data InvalidBaseUrlException


-- | This module provides backend-agnostic functionality for generating
--   clients from <tt>servant</tt> APIs. By "backend," we mean something
--   that concretely executes the request, such as:
--   
--   <ul>
--   <li>The <tt>http-client</tt> library</li>
--   <li>The <tt>haxl</tt> library</li>
--   <li>GHCJS via FFI</li>
--   </ul>
--   
--   etc.
--   
--   Each backend is encapsulated in a monad that is an instance of the
--   <a>RunClient</a> class.
--   
--   This library is primarily of interest to backend-writers and
--   combinator-writers. For more information, see the README.md
module Servant.Client.Core

-- | <a>clientIn</a> allows you to produce operations to query an API from
--   a client within a <a>RunClient</a> monad.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   clientM :: Proxy ClientM
--   clientM = Proxy
--   
--   getAllBooks :: ClientM [Book]
--   postNewBook :: Book -&gt; ClientM Book
--   (getAllBooks :&lt;|&gt; postNewBook) = myApi `clientIn` clientM
--   </pre>
clientIn :: HasClient m api => Proxy api -> Proxy m -> Client m api

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api

-- | Convenience function to apply a function to an unknown union element
--   using a type class. All elements of the union must have instances in
--   the type class, and the function is applied unconditionally.
--   
--   See also: <a>matchUnion</a>.
foldMapUnion :: forall c a (as :: [Type]). All c as => Proxy c -> (forall x. c x => x -> a) -> Union as -> a

-- | Convenience function to extract a union element using <tt>cast</tt>,
--   ie. return the value if the selected type happens to be the actual
--   type of the union in this value, or <a>Nothing</a> otherwise.
--   
--   See also: <a>foldMapUnion</a>.
matchUnion :: forall a (as :: [Type]). IsMember a as => Union as -> Maybe a
type Request = RequestF RequestBody Builder
data RequestF body path
Request :: path -> Seq QueryItem -> Maybe (body, MediaType) -> Seq MediaType -> Seq Header -> HttpVersion -> Method -> RequestF body path
[requestPath] :: RequestF body path -> path
[requestQueryString] :: RequestF body path -> Seq QueryItem
[requestBody] :: RequestF body path -> Maybe (body, MediaType)
[requestAccept] :: RequestF body path -> Seq MediaType
[requestHeaders] :: RequestF body path -> Seq Header
[requestHttpVersion] :: RequestF body path -> HttpVersion
[requestMethod] :: RequestF body path -> Method
defaultRequest :: Request

-- | The request body. R replica of the <tt>http-client</tt>
--   <tt>RequestBody</tt>.
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodySource :: SourceIO ByteString -> RequestBody

-- | Handy helper to avoid wrapping datatypes in tuples everywhere.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
mkAuthenticatedRequest :: AuthClientData a -> (AuthClientData a -> Request -> Request) -> AuthenticatedRequest a

-- | Authenticate a request using Basic Authentication
basicAuthReq :: BasicAuthData -> Request -> Request

-- | For better type inference and to avoid usage of a data family, we
--   newtype wrap the combination of some <a>AuthClientData</a> and a
--   function to add authentication data to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
newtype AuthenticatedRequest a
AuthenticatedRequest :: (AuthClientData a, AuthClientData a -> Request -> Request) -> AuthenticatedRequest a
[unAuthReq] :: AuthenticatedRequest a -> (AuthClientData a, AuthClientData a -> Request -> Request)

-- | For a resource protected by authentication (e.g. AuthProtect), we need
--   to provide the client with some data used to add authentication data
--   to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
type family AuthClientData a :: *

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ClientError

-- | The server returned an error response including the failing request.
--   <a>requestPath</a> includes the <a>BaseUrl</a> and the path of the
--   request.
FailureResponse :: RequestF () (BaseUrl, ByteString) -> Response -> ClientError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ClientError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ClientError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ClientError

-- | There was a connection error, and no response was received
ConnectionError :: SomeException -> ClientError

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient
type Response = ResponseF ByteString
data ResponseF a
Response :: Status -> Seq Header -> HttpVersion -> a -> ResponseF a
[responseStatusCode] :: ResponseF a -> Status
[responseHeaders] :: ResponseF a -> Seq Header
[responseHttpVersion] :: ResponseF a -> HttpVersion
[responseBody] :: ResponseF a -> a
class Monad m => RunClient m

-- | How to make a request, with an optional list of status codes to not
--   throw exceptions for (default: [200..299]).
runRequestAcceptStatus :: RunClient m => Maybe [Status] -> Request -> m Response
throwClientError :: RunClient m => ClientError -> m a

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
newtype InvalidBaseUrlException
InvalidBaseUrlException :: String -> InvalidBaseUrlException
class RunClient m => RunStreamingClient m
withStreamingRequest :: RunStreamingClient m => Request -> (StreamingResponse -> IO a) -> m a
type StreamingResponse = ResponseF (SourceIO ByteString)

-- | Add header to the request being constructed.
addHeader :: ToHttpApiData a => HeaderName -> a -> Request -> Request

-- | Append a query parameter to the request being constructed.
appendToQueryString :: Text -> Maybe ByteString -> Request -> Request

-- | Append extra path to the request being constructed.
--   
--   Warning: This function assumes that the path fragment is already
--   URL-encoded.
appendToPath :: Builder -> Request -> Request

-- | Set body and media type of the request being constructed.
--   
--   The body is set to the given bytestring using the
--   <a>RequestBodyLBS</a> constructor.
setRequestBodyLBS :: ByteString -> MediaType -> Request -> Request

-- | Set body and media type of the request being constructed.
setRequestBody :: RequestBody -> MediaType -> Request -> Request

-- | Encode a query parameter value.
encodeQueryParamValue :: ToHttpApiData a => a -> ByteString

module Servant.Client.Free
client :: HasClient (Free ClientF) api => Proxy api -> Client (Free ClientF) api

-- | <a>ClientF</a> cannot stream.
--   
--   Compare to <a>RunClient</a>.
data ClientF a
RunRequest :: Request -> (Response -> a) -> ClientF a
Throw :: ClientError -> ClientF a

module Servant.Client.Generic

-- | A type that specifies that an API record contains a client
--   implementation.
data AsClientT (m :: * -> *)

-- | Generate a record of client functions.
genericClient :: forall routes m. (HasClient m (ToServantApi routes), GenericServant routes (AsClientT m), Client m (ToServantApi routes) ~ ToServant routes (AsClientT m)) => routes (AsClientT m)

-- | <a>genericClient</a> but with <a>hoistClientMonad</a> in between.
genericClientHoist :: forall routes m n. (HasClient m (ToServantApi routes), GenericServant routes (AsClientT n), Client n (ToServantApi routes) ~ ToServant routes (AsClientT n)) => (forall x. m x -> n x) -> routes (AsClientT n)
