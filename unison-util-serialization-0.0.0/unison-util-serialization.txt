-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util-serialization
@version 0.0.0

module U.Util.Serialization
type Get a = forall m. (MonadGet m) => m a
type Put a = forall m. (MonadPut m) => a -> m ()
data Format a
Format :: Get a -> Put a -> Format a
[get] :: Format a -> Get a
[put] :: Format a -> Put a
debug :: Bool
getFromBytes :: Get a -> ByteString -> Maybe a
getFromFile :: MonadIO m => Get a -> FilePath -> m (Maybe a)
getFromFile' :: MonadIO m => Get a -> FilePath -> m (Either String a)
putBytes :: Put a -> a -> ByteString
putWithParentDirs :: MonadIO m => Put a -> FilePath -> a -> m ()
putVarInt :: (MonadPut m, Integral a, Bits a) => a -> m ()
getVarInt :: (MonadGet m, Num b, Bits b) => m b
putText :: MonadPut m => Text -> m ()
getText :: MonadGet m => m Text
skipText :: MonadGet m => m ()
putShortText :: MonadPut m => ShortText -> m ()
getShortText :: MonadGet m => m ShortText

-- | the <tt>binary</tt> package has a native version of this, which may be
--   more efficient by a constant factor
putShortByteString :: MonadPut m => ShortByteString -> m ()

-- | the <tt>binary</tt> package has a native version of this, which may be
--   more efficient by a constant factor
getShortByteString :: MonadGet m => Int -> m ShortByteString
putFoldable :: (Foldable f, MonadPut m) => (a -> m ()) -> f a -> m ()
getList :: MonadGet m => m a -> m [a]
getListLength :: MonadGet m => m Int
getVector :: MonadGet m => m a -> m (Vector a)
skipVector :: MonadGet m => m a -> m ()
getSequence :: MonadGet m => m a -> m (Seq a)
getSet :: (MonadGet m, Ord a) => m a -> m (Set a)
putMap :: MonadPut m => (a -> m ()) -> (b -> m ()) -> Map a b -> m ()
addToExistingMap :: (MonadGet m, Ord a) => m a -> m b -> Map a b -> m (Map a b)
getMap :: (MonadGet m, Ord a) => m a -> m b -> m (Map a b)
getFramedByteString :: MonadGet m => m ByteString
getRemainingByteString :: MonadGet m => m ByteString
getFramed :: MonadGet m => Get a -> m a
putFramedByteString :: MonadPut m => ByteString -> m ()
putFramed :: MonadPut m => Put a -> a -> m ()
skipFramed :: MonadGet m => m ()
putFramedArray :: (MonadPut m, Foldable f) => Put a -> f a -> m ()
getFramedArray :: MonadGet m => m a -> m (Vector a)

-- | Look up a 0-based index in a framed array, O(num array elements),
--   because it reads the start indices for all elements first. This could
--   be skipped if the indices had a fixed size instead of varint
lookupFramedArray :: MonadGet m => m a -> Int -> m (Maybe a)
lengthFramedArray :: MonadGet m => m Word64
unsafeFramedArrayLookup :: MonadGet m => m a -> Int -> m a
putPair :: MonadPut m => (a -> m ()) -> (b -> m ()) -> (a, b) -> m ()
getPair :: MonadGet m => m a -> m b -> m (a, b)
getTuple3 :: MonadGet m => m a -> m b -> m c -> m (a, b, c)
