<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Rank2Types
           , MultiParamTypeClasses
           , FunctionalDependencies
           , TypeOperators
           , UndecidableInstances #-}</span><span>
</span><span id="line-6"></span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 702
</span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if __GLASGOW_HASKELL__ &gt;= 708
</span><span class="hs-pragma">{-# LANGUAGE EmptyCase #-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-15"></span><span class="hs-comment">-------------------------------------------------------------------------------------------</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Copyright 	: 2008-2013 Edward Kmett</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- License	: BSD</span><span>
</span><span id="line-19"></span><span class="hs-comment">--</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- Maintainer	: Edward Kmett &lt;ekmett@gmail.com&gt;</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- Stability	: experimental</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- Portability	: rank 2 types, MPTCs, fundeps</span><span>
</span><span id="line-23"></span><span class="hs-comment">--</span><span>
</span><span id="line-24"></span><span class="hs-comment">-------------------------------------------------------------------------------------------</span><span>
</span><span id="line-25"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Functor.Adjunction</span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier">Adjunction</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#adjuncted"><span class="hs-identifier">adjuncted</span></a></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#tabulateAdjunction"><span class="hs-identifier">tabulateAdjunction</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#indexAdjunction"><span class="hs-identifier">indexAdjunction</span></a></span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#zapWithAdjunction"><span class="hs-identifier">zapWithAdjunction</span></a></span><span>
</span><span id="line-31"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#zipR"><span class="hs-identifier">zipR</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#unzipR"><span class="hs-identifier">unzipR</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#unabsurdL"><span class="hs-identifier">unabsurdL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#absurdL"><span class="hs-identifier">absurdL</span></a></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#cozipL"><span class="hs-identifier">cozipL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#uncozipL"><span class="hs-identifier">uncozipL</span></a></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#extractL"><span class="hs-identifier">extractL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#duplicateL"><span class="hs-identifier">duplicateL</span></a></span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#splitL"><span class="hs-identifier">splitL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#unsplitL"><span class="hs-identifier">unsplitL</span></a></span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 710
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Applicative</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Arrow</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&amp;&amp;&amp;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(|||)</span></span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Free</span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 707
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Monad.Instances</span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Identity</span></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Reader</span></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Writer</span></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Comonad</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Comonad.Cofree</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Comonad.Trans.Env</span></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Comonad.Trans.Traced</span></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Identity</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Compose</span></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Product</span></span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Functor.Rep.html"><span class="hs-identifier">Data.Functor.Rep</span></a></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor.Sum</span></span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Profunctor</span></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Void</span></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-comment">-- | An adjunction between Hask and Hask.</span><span>
</span><span id="line-64"></span><span class="hs-comment">--</span><span>
</span><span id="line-65"></span><span class="hs-comment">-- Minimal definition: both 'unit' and 'counit' or both 'leftAdjunct'</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- and 'rightAdjunct', subject to the constraints imposed by the</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- default definitions that the following laws should hold.</span><span>
</span><span id="line-68"></span><span class="hs-comment">--</span><span>
</span><span id="line-69"></span><span class="hs-comment">-- &gt; unit = leftAdjunct id</span><span>
</span><span id="line-70"></span><span class="hs-comment">-- &gt; counit = rightAdjunct id</span><span>
</span><span id="line-71"></span><span class="hs-comment">-- &gt; leftAdjunct f = fmap f . unit</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- &gt; rightAdjunct f = counit . fmap f</span><span>
</span><span id="line-73"></span><span class="hs-comment">--</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- Any implementation is required to ensure that 'leftAdjunct' and</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- 'rightAdjunct' witness an isomorphism from @Nat (f a, b)@ to</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- @Nat (a, g b)@</span><span>
</span><span id="line-77"></span><span class="hs-comment">--</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- &gt; rightAdjunct unit = id</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- &gt; leftAdjunct counit = id</span><span>
</span><span id="line-80"></span><span class="hs-keyword">class</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Rep.html#Representable"><span class="hs-identifier hs-type">Representable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-81"></span><span>      </span><span id="Adjunction"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-var">Adjunction</span></a></span></span><span> </span><span id="local-6989586621679086059"><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span></span><span> </span><span id="local-6989586621679086060"><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-keyword">where</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 708
</span><span>  </span><span class="hs-pragma">{-# MINIMAL</span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#unit"><span class="hs-pragma hs-type">unit</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-pragma hs-type">counit</span></a></span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">|</span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-pragma hs-type">leftAdjunct</span></a></span><span class="hs-pragma">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-pragma hs-type">rightAdjunct</span></a></span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span class="hs-cpp">
#endif
</span><span>  </span><span id="unit"><span class="annot"><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-type">unit</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679086063"><span class="annot"><a href="#local-6989586621679086063"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086063"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-86"></span><span>  </span><span id="counit"><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-type">counit</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679086068"><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086068"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086068"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-87"></span><span>  </span><span id="leftAdjunct"><span class="annot"><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-type">leftAdjunct</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679086065"><span id="local-6989586621679086066"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086065"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086066"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086065"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086066"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-88"></span><span>  </span><span id="rightAdjunct"><span class="annot"><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-type">rightAdjunct</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679086070"><span id="local-6989586621679086071"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086070"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086060"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086071"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086059"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086070"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086071"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span>  </span><span id="local-6989586621679086471"><span class="annot"><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var">unit</span></a></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; f a) -&gt; a -&gt; u (f a)
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; f a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span></span><span>
</span><span id="line-91"></span><span>  </span><span id="local-6989586621679086474"><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var">counit</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(u a -&gt; u a) -&gt; f (u a) -&gt; a
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">u a -&gt; u a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span></span><span>
</span><span id="line-92"></span><span>  </span><span id="local-6989586621679086476"><span class="annot"><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var hs-var">leftAdjunct</span></a></span><span> </span><span id="local-6989586621679086484"><span class="annot"><span class="annottext">f a -&gt; b
</span><a href="#local-6989586621679086484"><span class="hs-identifier hs-var">f</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; b) -&gt; u (f a) -&gt; u b
forall a b. (a -&gt; b) -&gt; u a -&gt; u b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; b
</span><a href="#local-6989586621679086484"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(u (f a) -&gt; u b) -&gt; (a -&gt; u (f a)) -&gt; a -&gt; u b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; u (f a)
forall a. a -&gt; u (f a)
forall (f :: * -&gt; *) (u :: * -&gt; *) a.
Adjunction f u =&gt;
a -&gt; u (f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var">unit</span></a></span></span><span>
</span><span id="line-93"></span><span>  </span><span id="local-6989586621679086486"><span class="annot"><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var hs-var">rightAdjunct</span></a></span><span> </span><span id="local-6989586621679086490"><span class="annot"><span class="annottext">a -&gt; u b
</span><a href="#local-6989586621679086490"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f (u b) -&gt; b
forall a. f (u a) -&gt; a
forall (f :: * -&gt; *) (u :: * -&gt; *) a.
Adjunction f u =&gt;
f (u a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var">counit</span></a></span><span> </span><span class="annot"><span class="annottext">(f (u b) -&gt; b) -&gt; (f a -&gt; f (u b)) -&gt; f a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; u b) -&gt; f a -&gt; f (u b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; u b
</span><a href="#local-6989586621679086490"><span class="hs-identifier hs-var">f</span></a></span></span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span class="hs-comment">-- | 'leftAdjunct' and 'rightAdjunct' form two halves of an isomorphism.</span><span>
</span><span id="line-96"></span><span class="hs-comment">--</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- This can be used with the combinators from the @lens@ package.</span><span>
</span><span id="line-98"></span><span class="hs-comment">--</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- @'adjuncted' :: 'Adjunction' f u =&gt; 'Iso'' (f a -&gt; b) (a -&gt; u b)@</span><span>
</span><span id="line-100"></span><span id="local-6989586621679086085"><span id="local-6989586621679086086"><span id="local-6989586621679086087"><span id="local-6989586621679086089"><span id="local-6989586621679086090"><span id="local-6989586621679086091"><span id="local-6989586621679086092"><span id="local-6989586621679086093"><span class="annot"><a href="Data.Functor.Adjunction.html#adjuncted"><span class="hs-identifier hs-type">adjuncted</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086085"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086086"><span class="hs-identifier hs-type">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Profunctor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086087"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086089"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086087"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086090"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086086"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086091"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086089"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086092"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086086"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086093"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086087"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086085"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086090"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086091"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086089"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086085"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086092"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086093"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span></span></span></span></span></span><span>
</span><span id="line-102"></span><span id="adjuncted"><span class="annot"><span class="annottext">adjuncted :: forall (f :: * -&gt; *) (u :: * -&gt; *) (p :: * -&gt; * -&gt; *) (g :: * -&gt; *)
       a b c d.
(Adjunction f u, Profunctor p, Functor g) =&gt;
p (a -&gt; u b) (g (c -&gt; u d)) -&gt; p (f a -&gt; b) (g (f c -&gt; d))
</span><a href="Data.Functor.Adjunction.html#adjuncted"><span class="hs-identifier hs-var hs-var">adjuncted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((f a -&gt; b) -&gt; a -&gt; u b)
-&gt; (g (c -&gt; u d) -&gt; g (f c -&gt; d))
-&gt; p (a -&gt; u b) (g (c -&gt; u d))
-&gt; p (f a -&gt; b) (g (f c -&gt; d))
forall a b c d. (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d
forall (p :: * -&gt; * -&gt; *) a b c d.
Profunctor p =&gt;
(a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d
</span><span class="hs-identifier hs-var">dimap</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; b) -&gt; a -&gt; u b
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((c -&gt; u d) -&gt; f c -&gt; d) -&gt; g (c -&gt; u d) -&gt; g (f c -&gt; d)
forall a b. (a -&gt; b) -&gt; g a -&gt; g b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">(c -&gt; u d) -&gt; f c -&gt; d
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-103"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#adjuncted"><span class="hs-pragma hs-type">adjuncted</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="hs-comment">-- | Every right adjoint is representable by its left adjoint</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- applied to a unit element</span><span>
</span><span id="line-107"></span><span class="hs-comment">--</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- Use this definition and the primitives in</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- Data.Functor.Representable to meet the requirements of the</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- superclasses of Representable.</span><span>
</span><span id="line-111"></span><span id="local-6989586621679086107"><span id="local-6989586621679086108"><span id="local-6989586621679086109"><span class="annot"><a href="Data.Functor.Adjunction.html#tabulateAdjunction"><span class="hs-identifier hs-type">tabulateAdjunction</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086107"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086108"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086107"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086109"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086108"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086109"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-112"></span><span id="tabulateAdjunction"><span class="annot"><span class="annottext">tabulateAdjunction :: forall (f :: * -&gt; *) (u :: * -&gt; *) b.
Adjunction f u =&gt;
(f () -&gt; b) -&gt; u b
</span><a href="Data.Functor.Adjunction.html#tabulateAdjunction"><span class="hs-identifier hs-var hs-var">tabulateAdjunction</span></a></span></span><span> </span><span id="local-6989586621679086501"><span class="annot"><span class="annottext">f () -&gt; b
</span><a href="#local-6989586621679086501"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f () -&gt; b) -&gt; () -&gt; u b
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f () -&gt; b
</span><a href="#local-6989586621679086501"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="hs-comment">-- | This definition admits a default definition for the</span><span>
</span><span id="line-115"></span><span class="hs-comment">-- 'index' method of 'Index&quot;, one of the superclasses of</span><span>
</span><span id="line-116"></span><span class="hs-comment">-- Representable.</span><span>
</span><span id="line-117"></span><span id="local-6989586621679086113"><span id="local-6989586621679086114"><span id="local-6989586621679086115"><span id="local-6989586621679086116"><span class="annot"><a href="Data.Functor.Adjunction.html#indexAdjunction"><span class="hs-identifier hs-type">indexAdjunction</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086113"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086114"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086114"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086115"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086113"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086116"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086115"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-118"></span><span id="indexAdjunction"><span class="annot"><span class="annottext">indexAdjunction :: forall (f :: * -&gt; *) (u :: * -&gt; *) b a.
Adjunction f u =&gt;
u b -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#indexAdjunction"><span class="hs-identifier hs-var hs-var">indexAdjunction</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; u b) -&gt; f a -&gt; b
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">((a -&gt; u b) -&gt; f a -&gt; b) -&gt; (u b -&gt; a -&gt; u b) -&gt; u b -&gt; f a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">u b -&gt; a -&gt; u b
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span>
</span><span id="line-119"></span><span>
</span><span id="line-120"></span><span id="local-6989586621679086123"><span id="local-6989586621679086124"><span id="local-6989586621679086125"><span id="local-6989586621679086126"><span id="local-6989586621679086127"><span class="annot"><a href="Data.Functor.Adjunction.html#zapWithAdjunction"><span class="hs-identifier hs-type">zapWithAdjunction</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086123"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086124"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086125"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086126"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086127"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086124"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086125"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086123"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086126"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086127"><span class="hs-identifier hs-type">c</span></a></span></span></span></span></span></span><span>
</span><span id="line-121"></span><span id="zapWithAdjunction"><span class="annot"><span class="annottext">zapWithAdjunction :: forall (f :: * -&gt; *) (u :: * -&gt; *) a b c.
Adjunction f u =&gt;
(a -&gt; b -&gt; c) -&gt; u a -&gt; f b -&gt; c
</span><a href="Data.Functor.Adjunction.html#zapWithAdjunction"><span class="hs-identifier hs-var hs-var">zapWithAdjunction</span></a></span></span><span> </span><span id="local-6989586621679086512"><span class="annot"><span class="annottext">a -&gt; b -&gt; c
</span><a href="#local-6989586621679086512"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679086513"><span class="annot"><span class="annottext">u a
</span><a href="#local-6989586621679086513"><span class="hs-identifier hs-var">ua</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b -&gt; u c) -&gt; f b -&gt; c
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679086514"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679086514"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a -&gt; c) -&gt; u a -&gt; u c
forall a b. (a -&gt; b) -&gt; u a -&gt; u b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; b -&gt; c
</span><a href="#local-6989586621679086512"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679086514"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">u a
</span><a href="#local-6989586621679086513"><span class="hs-identifier hs-var">ua</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span id="local-6989586621679086136"><span id="local-6989586621679086137"><span id="local-6989586621679086138"><span class="annot"><a href="Data.Functor.Adjunction.html#splitL"><span class="hs-identifier hs-type">splitL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086136"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086137"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086136"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086138"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086138"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086136"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-124"></span><span id="splitL"><span class="annot"><span class="annottext">splitL :: forall (f :: * -&gt; *) (u :: * -&gt; *) a.
Adjunction f u =&gt;
f a -&gt; (a, f ())
</span><a href="Data.Functor.Adjunction.html#splitL"><span class="hs-identifier hs-var hs-var">splitL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; u (a, f ())) -&gt; f a -&gt; (a, f ())
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((f () -&gt; (a, f ())) -&gt; () -&gt; u (a, f ()))
-&gt; () -&gt; (f () -&gt; (a, f ())) -&gt; u (a, f ())
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">(f () -&gt; (a, f ())) -&gt; () -&gt; u (a, f ())
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((f () -&gt; (a, f ())) -&gt; u (a, f ()))
-&gt; (a -&gt; f () -&gt; (a, f ())) -&gt; a -&gt; u (a, f ())
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span id="local-6989586621679086144"><span id="local-6989586621679086145"><span class="annot"><a href="Data.Functor.Adjunction.html#unsplitL"><span class="hs-identifier hs-type">unsplitL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086144"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086145"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086144"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086144"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086145"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-127"></span><span id="unsplitL"><span class="annot"><span class="annottext">unsplitL :: forall (f :: * -&gt; *) a. Functor f =&gt; a -&gt; f () -&gt; f a
</span><a href="Data.Functor.Adjunction.html#unsplitL"><span class="hs-identifier hs-var hs-var">unsplitL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; f () -&gt; f a
forall a b. a -&gt; f b -&gt; f a
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">(&lt;$)</span></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span id="local-6989586621679086150"><span id="local-6989586621679086151"><span id="local-6989586621679086152"><span class="annot"><a href="Data.Functor.Adjunction.html#extractL"><span class="hs-identifier hs-type">extractL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086150"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086151"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086150"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086152"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086152"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-130"></span><span id="extractL"><span class="annot"><span class="annottext">extractL :: forall (f :: * -&gt; *) (u :: * -&gt; *) a. Adjunction f u =&gt; f a -&gt; a
</span><a href="Data.Functor.Adjunction.html#extractL"><span class="hs-identifier hs-var hs-var">extractL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, f ()) -&gt; a
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">((a, f ()) -&gt; a) -&gt; (f a -&gt; (a, f ())) -&gt; f a -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">f a -&gt; (a, f ())
forall (f :: * -&gt; *) (u :: * -&gt; *) a.
Adjunction f u =&gt;
f a -&gt; (a, f ())
</span><a href="Data.Functor.Adjunction.html#splitL"><span class="hs-identifier hs-var">splitL</span></a></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span id="local-6989586621679086158"><span id="local-6989586621679086159"><span id="local-6989586621679086160"><span class="annot"><a href="Data.Functor.Adjunction.html#duplicateL"><span class="hs-identifier hs-type">duplicateL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086158"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086159"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086158"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086160"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086158"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086158"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086160"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-133"></span><span id="duplicateL"><span class="annot"><span class="annottext">duplicateL :: forall (f :: * -&gt; *) (u :: * -&gt; *) a.
Adjunction f u =&gt;
f a -&gt; f (f a)
</span><a href="Data.Functor.Adjunction.html#duplicateL"><span class="hs-identifier hs-var hs-var">duplicateL</span></a></span></span><span> </span><span id="local-6989586621679086528"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679086528"><span class="hs-keyword hs-var">as</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679086528"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; f a -&gt; f (f a)
forall a b. a -&gt; f b -&gt; f a
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679086528"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-comment">-- | A right adjoint functor admits an intrinsic</span><span>
</span><span id="line-136"></span><span class="hs-comment">-- notion of zipping</span><span>
</span><span id="line-137"></span><span id="local-6989586621679086164"><span id="local-6989586621679086165"><span id="local-6989586621679086166"><span id="local-6989586621679086167"><span class="annot"><a href="Data.Functor.Adjunction.html#zipR"><span class="hs-identifier hs-type">zipR</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086164"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086165"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086165"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086166"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086165"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086167"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086165"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086166"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086167"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-138"></span><span id="zipR"><span class="annot"><span class="annottext">zipR :: forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(u a, u b) -&gt; u (a, b)
</span><a href="Data.Functor.Adjunction.html#zipR"><span class="hs-identifier hs-var hs-var">zipR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f (u a, u b) -&gt; (a, b)) -&gt; (u a, u b) -&gt; u (a, b)
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((u a, u b) -&gt; u a) -&gt; f (u a, u b) -&gt; a
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">(u a, u b) -&gt; u a
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">(f (u a, u b) -&gt; a)
-&gt; (f (u a, u b) -&gt; b) -&gt; f (u a, u b) -&gt; (a, b)
forall b c c'. (b -&gt; c) -&gt; (b -&gt; c') -&gt; b -&gt; (c, c')
forall (a :: * -&gt; * -&gt; *) b c c'.
Arrow a =&gt;
a b c -&gt; a b c' -&gt; a b (c, c')
</span><span class="hs-operator hs-var">&amp;&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">((u a, u b) -&gt; u b) -&gt; f (u a, u b) -&gt; b
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">(u a, u b) -&gt; u b
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="annot"><span class="hs-comment">-- | Every functor in Haskell permits unzipping</span></span><span>
</span><span id="line-141"></span><span id="local-6989586621679086179"><span id="local-6989586621679086180"><span id="local-6989586621679086181"><span class="annot"><a href="Data.Functor.Adjunction.html#unzipR"><span class="hs-identifier hs-type">unzipR</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086179"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086179"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086180"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086181"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086179"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086180"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679086179"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086181"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-142"></span><span id="unzipR"><span class="annot"><span class="annottext">unzipR :: forall (u :: * -&gt; *) a b. Functor u =&gt; u (a, b) -&gt; (u a, u b)
</span><a href="Data.Functor.Adjunction.html#unzipR"><span class="hs-identifier hs-var hs-var">unzipR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a, b) -&gt; a) -&gt; u (a, b) -&gt; u a
forall a b. (a -&gt; b) -&gt; u a -&gt; u b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">(a, b) -&gt; a
forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">(u (a, b) -&gt; u a) -&gt; (u (a, b) -&gt; u b) -&gt; u (a, b) -&gt; (u a, u b)
forall b c c'. (b -&gt; c) -&gt; (b -&gt; c') -&gt; b -&gt; (c, c')
forall (a :: * -&gt; * -&gt; *) b c c'.
Arrow a =&gt;
a b c -&gt; a b c' -&gt; a b (c, c')
</span><span class="hs-operator hs-var">&amp;&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">((a, b) -&gt; b) -&gt; u (a, b) -&gt; u b
forall a b. (a -&gt; b) -&gt; u a -&gt; u b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">(a, b) -&gt; b
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span id="local-6989586621679086185"><span class="annot"><a href="Data.Functor.Adjunction.html#absurdL"><span class="hs-identifier hs-type">absurdL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086185"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span></span><span>
</span><span id="line-145"></span><span id="absurdL"><span class="annot"><span class="annottext">absurdL :: forall (f :: * -&gt; *). Void -&gt; f Void
</span><a href="Data.Functor.Adjunction.html#absurdL"><span class="hs-identifier hs-var hs-var">absurdL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Void -&gt; f Void
forall a. Void -&gt; a
</span><span class="hs-identifier hs-var">absurd</span></span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="annot"><span class="hs-comment">-- | A left adjoint must be inhabited, or we can derive bottom.</span></span><span>
</span><span id="line-148"></span><span id="local-6989586621679086188"><span id="local-6989586621679086189"><span class="annot"><a href="Data.Functor.Adjunction.html#unabsurdL"><span class="hs-identifier hs-type">unabsurdL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086188"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086189"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086188"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Void</span></span></span></span><span>
</span><span id="line-149"></span><span id="unabsurdL"><span class="annot"><span class="annottext">unabsurdL :: forall (f :: * -&gt; *) (u :: * -&gt; *).
Adjunction f u =&gt;
f Void -&gt; Void
</span><a href="Data.Functor.Adjunction.html#unabsurdL"><span class="hs-identifier hs-var hs-var">unabsurdL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Void -&gt; u Void) -&gt; f Void -&gt; Void
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">Void -&gt; u Void
forall a. Void -&gt; a
</span><span class="hs-identifier hs-var">absurd</span></span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="annot"><span class="hs-comment">-- | And a left adjoint must be inhabited by exactly one element</span></span><span>
</span><span id="line-152"></span><span id="local-6989586621679086192"><span id="local-6989586621679086193"><span id="local-6989586621679086194"><span id="local-6989586621679086195"><span class="annot"><a href="Data.Functor.Adjunction.html#cozipL"><span class="hs-identifier hs-type">cozipL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086193"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679086194"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086195"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086194"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086192"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086195"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-153"></span><span id="cozipL"><span class="annot"><span class="annottext">cozipL :: forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
f (Either a b) -&gt; Either (f a) (f b)
</span><a href="Data.Functor.Adjunction.html#cozipL"><span class="hs-identifier hs-var hs-var">cozipL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Either a b -&gt; u (Either (f a) (f b)))
-&gt; f (Either a b) -&gt; Either (f a) (f b)
forall a b. (a -&gt; u b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; Either (f a) (f b)) -&gt; a -&gt; u (Either (f a) (f b))
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; Either (f a) (f b)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; u (Either (f a) (f b)))
-&gt; (b -&gt; u (Either (f a) (f b)))
-&gt; Either a b
-&gt; u (Either (f a) (f b))
forall b d c. (b -&gt; d) -&gt; (c -&gt; d) -&gt; Either b c -&gt; d
forall (a :: * -&gt; * -&gt; *) b d c.
ArrowChoice a =&gt;
a b d -&gt; a c d -&gt; a (Either b c) d
</span><span class="hs-operator hs-var">|||</span></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Either (f a) (f b)) -&gt; b -&gt; u (Either (f a) (f b))
forall a b. (f a -&gt; b) -&gt; a -&gt; u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f b -&gt; Either (f a) (f b)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span class="hs-special">)</span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="annot"><span class="hs-comment">-- | Every functor in Haskell permits 'uncozipping'</span></span><span>
</span><span id="line-156"></span><span id="local-6989586621679086207"><span id="local-6989586621679086208"><span id="local-6989586621679086209"><span class="annot"><a href="Data.Functor.Adjunction.html#uncozipL"><span class="hs-identifier hs-type">uncozipL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679086207"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086207"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086208"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086207"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086209"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086207"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679086208"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086209"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-157"></span><span id="uncozipL"><span class="annot"><span class="annottext">uncozipL :: forall (f :: * -&gt; *) a b.
Functor f =&gt;
Either (f a) (f b) -&gt; f (Either a b)
</span><a href="Data.Functor.Adjunction.html#uncozipL"><span class="hs-identifier hs-var hs-var">uncozipL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Either a b) -&gt; f a -&gt; f (Either a b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Either a b
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; f (Either a b))
-&gt; (f b -&gt; f (Either a b)) -&gt; Either (f a) (f b) -&gt; f (Either a b)
forall b d c. (b -&gt; d) -&gt; (c -&gt; d) -&gt; Either b c -&gt; d
forall (a :: * -&gt; * -&gt; *) b d c.
ArrowChoice a =&gt;
a b d -&gt; a c d -&gt; a (Either b c) d
</span><span class="hs-operator hs-var">|||</span></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Either a b) -&gt; f b -&gt; f (Either a b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Either a b
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-comment">-- Requires deprecated Impredicative types</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- limitR :: Adjunction f u =&gt; (forall a. u a) -&gt; u (forall a. a)</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- limitR = leftAdjunct (rightAdjunct (\(x :: forall a. a) -&gt; x))</span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086214"><span id="local-6989586621679086560"><span id="local-6989586621679086564"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679086214"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-glyph">-&gt;</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679086214"><span class="hs-identifier hs-type">e</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-164"></span><span>  </span><span id="local-6989586621679086569"><span class="annot"><span class="annottext">leftAdjunct :: forall a b. ((e, a) -&gt; b) -&gt; a -&gt; e -&gt; b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">leftAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086570"><span class="annot"><span class="annottext">(e, a) -&gt; b
</span><a href="#local-6989586621679086570"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679086571"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086571"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679086572"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086572"><span class="hs-identifier hs-var">e</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(e, a) -&gt; b
</span><a href="#local-6989586621679086570"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086572"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086571"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span><span>  </span><span id="local-6989586621679086573"><span class="annot"><span class="annottext">rightAdjunct :: forall a b. (a -&gt; e -&gt; b) -&gt; (e, a) -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">rightAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086574"><span class="annot"><span class="annottext">a -&gt; e -&gt; b
</span><a href="#local-6989586621679086574"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679086575"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086575"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679086576"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086576"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; e -&gt; b
</span><a href="#local-6989586621679086574"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086576"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086575"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086584"><span id="local-6989586621679086588"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Identity</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Identity</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-168"></span><span>  </span><span id="local-6989586621679086592"><span class="annot"><span class="annottext">leftAdjunct :: forall a b. (Identity a -&gt; b) -&gt; a -&gt; Identity b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">leftAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086593"><span class="annot"><span class="annottext">Identity a -&gt; b
</span><a href="#local-6989586621679086593"><span class="hs-identifier hs-var">f</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Identity b
forall a. a -&gt; Identity a
</span><span class="hs-identifier hs-var">Identity</span></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Identity b) -&gt; (a -&gt; b) -&gt; a -&gt; Identity b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Identity a -&gt; b
</span><a href="#local-6989586621679086593"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Identity a -&gt; b) -&gt; (a -&gt; Identity a) -&gt; a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Identity a
forall a. a -&gt; Identity a
</span><span class="hs-identifier hs-var">Identity</span></span><span>
</span><span id="line-169"></span><span>  </span><span id="local-6989586621679086595"><span class="annot"><span class="annottext">rightAdjunct :: forall a b. (a -&gt; Identity b) -&gt; Identity a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">rightAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086596"><span class="annot"><span class="annottext">a -&gt; Identity b
</span><a href="#local-6989586621679086596"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Identity b -&gt; b
forall a. Identity a -&gt; a
</span><span class="hs-identifier hs-var">runIdentity</span></span><span> </span><span class="annot"><span class="annottext">(Identity b -&gt; b) -&gt; (Identity a -&gt; Identity b) -&gt; Identity a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Identity b
</span><a href="#local-6989586621679086596"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Identity b) -&gt; (Identity a -&gt; a) -&gt; Identity a -&gt; Identity b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Identity a -&gt; a
forall a. Identity a -&gt; a
</span><span class="hs-identifier hs-var">runIdentity</span></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086231"><span id="local-6989586621679086232"><span id="local-6989586621679086610"><span id="local-6989586621679086614"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086231"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086232"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-172"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IdentityT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086231"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IdentityT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086232"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679086617"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; IdentityT g (IdentityT f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">g (IdentityT f a) -&gt; IdentityT g (IdentityT f a)
forall {k} (f :: k -&gt; *) (a :: k). f a -&gt; IdentityT f a
</span><span class="hs-identifier hs-var">IdentityT</span></span><span> </span><span class="annot"><span class="annottext">(g (IdentityT f a) -&gt; IdentityT g (IdentityT f a))
-&gt; (a -&gt; g (IdentityT f a)) -&gt; a -&gt; IdentityT g (IdentityT f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; IdentityT f a) -&gt; a -&gt; g (IdentityT f a)
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; IdentityT f a
forall {k} (f :: k -&gt; *) (a :: k). f a -&gt; IdentityT f a
</span><span class="hs-identifier hs-var">IdentityT</span></span><span>
</span><span id="line-174"></span><span>  </span><span id="local-6989586621679086620"><span class="annot"><span class="annottext">counit :: forall a. IdentityT f (IdentityT g a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(IdentityT g a -&gt; g a) -&gt; f (IdentityT g a) -&gt; a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">IdentityT g a -&gt; g a
forall {k} (f :: k -&gt; *) (a :: k). IdentityT f a -&gt; f a
</span><span class="hs-identifier hs-var">runIdentityT</span></span><span> </span><span class="annot"><span class="annottext">(f (IdentityT g a) -&gt; a)
-&gt; (IdentityT f (IdentityT g a) -&gt; f (IdentityT g a))
-&gt; IdentityT f (IdentityT g a)
-&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">IdentityT f (IdentityT g a) -&gt; f (IdentityT g a)
forall {k} (f :: k -&gt; *) (a :: k). IdentityT f a -&gt; f a
</span><span class="hs-identifier hs-var">runIdentityT</span></span><span>
</span><span id="line-175"></span><span>
</span><span id="line-176"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086250"><span id="local-6989586621679086251"><span id="local-6989586621679086252"><span id="local-6989586621679086634"><span id="local-6989586621679086638"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086250"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086251"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-177"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EnvT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086252"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086250"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ReaderT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086252"><span class="hs-identifier hs-type">e</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086251"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-178"></span><span>  </span><span id="local-6989586621679086643"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; ReaderT e m (EnvT e w a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(e -&gt; m (EnvT e w a)) -&gt; ReaderT e m (EnvT e w a)
forall r (m :: * -&gt; *) a. (r -&gt; m a) -&gt; ReaderT r m a
</span><span class="hs-identifier hs-var">ReaderT</span></span><span> </span><span class="annot"><span class="annottext">((e -&gt; m (EnvT e w a)) -&gt; ReaderT e m (EnvT e w a))
-&gt; (a -&gt; e -&gt; m (EnvT e w a)) -&gt; a -&gt; ReaderT e m (EnvT e w a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(((w a -&gt; EnvT e w a) -&gt; m (EnvT e w a))
 -&gt; (e -&gt; w a -&gt; EnvT e w a) -&gt; e -&gt; m (EnvT e w a))
-&gt; (e -&gt; w a -&gt; EnvT e w a)
-&gt; ((w a -&gt; EnvT e w a) -&gt; m (EnvT e w a))
-&gt; e
-&gt; m (EnvT e w a)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">((w a -&gt; EnvT e w a) -&gt; m (EnvT e w a))
-&gt; (e -&gt; w a -&gt; EnvT e w a) -&gt; e -&gt; m (EnvT e w a)
forall a b. (a -&gt; b) -&gt; (e -&gt; a) -&gt; e -&gt; b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">e -&gt; w a -&gt; EnvT e w a
forall e (w :: * -&gt; *) a. e -&gt; w a -&gt; EnvT e w a
</span><span class="hs-identifier hs-var">EnvT</span></span><span> </span><span class="annot"><span class="annottext">(((w a -&gt; EnvT e w a) -&gt; m (EnvT e w a)) -&gt; e -&gt; m (EnvT e w a))
-&gt; (a -&gt; (w a -&gt; EnvT e w a) -&gt; m (EnvT e w a))
-&gt; a
-&gt; e
-&gt; m (EnvT e w a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((w a -&gt; EnvT e w a) -&gt; a -&gt; m (EnvT e w a))
-&gt; a -&gt; (w a -&gt; EnvT e w a) -&gt; m (EnvT e w a)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">(w a -&gt; EnvT e w a) -&gt; a -&gt; m (EnvT e w a)
forall a b. (w a -&gt; b) -&gt; a -&gt; m b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span>
</span><span id="line-179"></span><span>  </span><span id="local-6989586621679086647"><span class="annot"><span class="annottext">counit :: forall a. EnvT e w (ReaderT e m a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EnvT</span></span><span> </span><span id="local-6989586621679086648"><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086648"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span id="local-6989586621679086649"><span class="annot"><span class="annottext">w (ReaderT e m a)
</span><a href="#local-6989586621679086649"><span class="hs-identifier hs-var">w</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ReaderT e m a -&gt; m a) -&gt; w (ReaderT e m a) -&gt; a
forall a b. (a -&gt; m b) -&gt; w a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ReaderT e m a -&gt; e -&gt; m a) -&gt; e -&gt; ReaderT e m a -&gt; m a
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">ReaderT e m a -&gt; e -&gt; m a
forall r (m :: * -&gt; *) a. ReaderT r m a -&gt; r -&gt; m a
</span><span class="hs-identifier hs-var">runReaderT</span></span><span> </span><span class="annot"><span class="annottext">e
</span><a href="#local-6989586621679086648"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">w (ReaderT e m a)
</span><a href="#local-6989586621679086649"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086274"><span id="local-6989586621679086275"><span id="local-6989586621679086276"><span id="local-6989586621679086663"><span id="local-6989586621679086667"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086274"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086275"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-182"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">WriterT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086276"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086274"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TracedT</span></span><span> </span><span class="annot"><a href="#local-6989586621679086276"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086275"><span class="hs-identifier hs-type">w</span></a></span><span class="hs-special">)</span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-183"></span><span>  </span><span id="local-6989586621679086673"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; TracedT s w (WriterT s m a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">w (s -&gt; WriterT s m a) -&gt; TracedT s w (WriterT s m a)
forall m (w :: * -&gt; *) a. w (m -&gt; a) -&gt; TracedT m w a
</span><span class="hs-identifier hs-var">TracedT</span></span><span> </span><span class="annot"><span class="annottext">(w (s -&gt; WriterT s m a) -&gt; TracedT s w (WriterT s m a))
-&gt; (a -&gt; w (s -&gt; WriterT s m a))
-&gt; a
-&gt; TracedT s w (WriterT s m a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(m a -&gt; s -&gt; WriterT s m a) -&gt; a -&gt; w (s -&gt; WriterT s m a)
forall a b. (m a -&gt; b) -&gt; a -&gt; w b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679086675"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679086675"><span class="hs-identifier hs-var">ma</span></a></span></span><span> </span><span id="local-6989586621679086676"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679086676"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (a, s) -&gt; WriterT s m a
forall w (m :: * -&gt; *) a. m (a, w) -&gt; WriterT w m a
</span><span class="hs-identifier hs-var">WriterT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; (a, s)) -&gt; m a -&gt; m (a, s)
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679086678"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086678"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086678"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679086676"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679086675"><span class="hs-identifier hs-var">ma</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-184"></span><span>  </span><span id="local-6989586621679086681"><span class="annot"><span class="annottext">counit :: forall a. WriterT s m (TracedT s w a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((TracedT s w a, s) -&gt; w a) -&gt; m (TracedT s w a, s) -&gt; a
forall a b. (a -&gt; w b) -&gt; m a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679086682"><span class="annot"><span class="annottext">TracedT s w a
</span><a href="#local-6989586621679086682"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679086683"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679086683"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(s -&gt; a) -&gt; s -&gt; a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679086683"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((s -&gt; a) -&gt; a) -&gt; w (s -&gt; a) -&gt; w a
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">TracedT s w a -&gt; w (s -&gt; a)
forall m (w :: * -&gt; *) a. TracedT m w a -&gt; w (m -&gt; a)
</span><span class="hs-identifier hs-var">runTracedT</span></span><span> </span><span class="annot"><span class="annottext">TracedT s w a
</span><a href="#local-6989586621679086682"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (TracedT s w a, s) -&gt; a)
-&gt; (WriterT s m (TracedT s w a) -&gt; m (TracedT s w a, s))
-&gt; WriterT s m (TracedT s w a)
-&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">WriterT s m (TracedT s w a) -&gt; m (TracedT s w a, s)
forall w (m :: * -&gt; *) a. WriterT w m a -&gt; m (a, w)
</span><span class="hs-identifier hs-var">runWriterT</span></span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086306"><span id="local-6989586621679086307"><span id="local-6989586621679086308"><span id="local-6989586621679086309"><span id="local-6989586621679086702"><span id="local-6989586621679086706"><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086306"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086307"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086308"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086309"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-187"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Compose</span></span><span> </span><span class="annot"><a href="#local-6989586621679086308"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086306"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Compose</span></span><span> </span><span class="annot"><a href="#local-6989586621679086307"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086309"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-188"></span><span>  </span><span id="local-6989586621679086710"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; Compose g g' (Compose f' f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">g (g' (Compose f' f a)) -&gt; Compose g g' (Compose f' f a)
forall {k} {k1} (f :: k -&gt; *) (g :: k1 -&gt; k) (a :: k1).
f (g a) -&gt; Compose f g a
</span><span class="hs-identifier hs-var">Compose</span></span><span> </span><span class="annot"><span class="annottext">(g (g' (Compose f' f a)) -&gt; Compose g g' (Compose f' f a))
-&gt; (a -&gt; g (g' (Compose f' f a)))
-&gt; a
-&gt; Compose g g' (Compose f' f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; g' (Compose f' f a)) -&gt; a -&gt; g (g' (Compose f' f a))
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f' (f a) -&gt; Compose f' f a) -&gt; f a -&gt; g' (Compose f' f a)
forall a b. (f' a -&gt; b) -&gt; a -&gt; g' b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f' (f a) -&gt; Compose f' f a
forall {k} {k1} (f :: k -&gt; *) (g :: k1 -&gt; k) (a :: k1).
f (g a) -&gt; Compose f g a
</span><span class="hs-identifier hs-var">Compose</span></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>  </span><span id="local-6989586621679086714"><span class="annot"><span class="annottext">counit :: forall a. Compose f' f (Compose g g' a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f (Compose g g' a) -&gt; g' a) -&gt; f' (f (Compose g g' a)) -&gt; a
forall a b. (a -&gt; g' b) -&gt; f' a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Compose g g' a -&gt; g (g' a)) -&gt; f (Compose g g' a) -&gt; g' a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">Compose g g' a -&gt; g (g' a)
forall {k1} {k2} (f :: k1 -&gt; *) (g :: k2 -&gt; k1) (a :: k2).
Compose f g a -&gt; f (g a)
</span><span class="hs-identifier hs-var">getCompose</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f' (f (Compose g g' a)) -&gt; a)
-&gt; (Compose f' f (Compose g g' a) -&gt; f' (f (Compose g g' a)))
-&gt; Compose f' f (Compose g g' a)
-&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Compose f' f (Compose g g' a) -&gt; f' (f (Compose g g' a))
forall {k1} {k2} (f :: k1 -&gt; *) (g :: k2 -&gt; k1) (a :: k2).
Compose f g a -&gt; f (g a)
</span><span class="hs-identifier hs-var">getCompose</span></span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086332"><span id="local-6989586621679086333"><span id="local-6989586621679086334"><span id="local-6989586621679086335"><span id="local-6989586621679086731"><span id="local-6989586621679086735"><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086332"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086333"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086334"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086335"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-192"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Sum</span></span><span> </span><span class="annot"><a href="#local-6989586621679086332"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086334"><span class="hs-identifier hs-type">f'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Product</span></span><span> </span><span class="annot"><a href="#local-6989586621679086333"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086335"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-193"></span><span>  </span><span id="local-6989586621679086739"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; Product g g' (Sum f f' a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span> </span><span id="local-6989586621679086740"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086740"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">g (Sum f f' a) -&gt; g' (Sum f f' a) -&gt; Product g g' (Sum f f' a)
forall {k} (f :: k -&gt; *) (g :: k -&gt; *) (a :: k).
f a -&gt; g a -&gt; Product f g a
</span><span class="hs-identifier hs-var">Pair</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f a -&gt; Sum f f' a) -&gt; a -&gt; g (Sum f f' a)
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; Sum f f' a
forall {k} (f :: k -&gt; *) (g :: k -&gt; *) (a :: k). f a -&gt; Sum f g a
</span><span class="hs-identifier hs-var">InL</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086740"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f' a -&gt; Sum f f' a) -&gt; a -&gt; g' (Sum f f' a)
forall a b. (f' a -&gt; b) -&gt; a -&gt; g' b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f' a -&gt; Sum f f' a
forall {k} (f :: k -&gt; *) (g :: k -&gt; *) (a :: k). g a -&gt; Sum f g a
</span><span class="hs-identifier hs-var">InR</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086740"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>  </span><span id="local-6989586621679086746"><span class="annot"><span class="annottext">counit :: forall a. Sum f f' (Product g g' a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InL</span></span><span> </span><span id="local-6989586621679086747"><span class="annot"><span class="annottext">f (Product g g' a)
</span><a href="#local-6989586621679086747"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Product g g' a -&gt; g a) -&gt; f (Product g g' a) -&gt; a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Pair</span></span><span> </span><span id="local-6989586621679086748"><span class="annot"><span class="annottext">g a
</span><a href="#local-6989586621679086748"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">g' a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">g a
</span><a href="#local-6989586621679086748"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f (Product g g' a)
</span><a href="#local-6989586621679086747"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-195"></span><span>  </span><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var">counit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InR</span></span><span> </span><span id="local-6989586621679086749"><span class="annot"><span class="annottext">f' (Product g g' a)
</span><a href="#local-6989586621679086749"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Product g g' a -&gt; g' a) -&gt; f' (Product g g' a) -&gt; a
forall a b. (a -&gt; g' b) -&gt; f' a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Pair</span></span><span> </span><span class="annot"><span class="annottext">g a
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679086750"><span class="annot"><span class="annottext">g' a
</span><a href="#local-6989586621679086750"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">g' a
</span><a href="#local-6989586621679086750"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f' (Product g g' a)
</span><a href="#local-6989586621679086749"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086352"><span id="local-6989586621679086353"><span id="local-6989586621679086763"><span id="local-6989586621679086767"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086352"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086353"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-198"></span><span>         </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Free</span></span><span> </span><span class="annot"><a href="#local-6989586621679086352"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Cofree</span></span><span> </span><span class="annot"><a href="#local-6989586621679086353"><span class="hs-identifier hs-type">u</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-199"></span><span>  </span><span id="local-6989586621679086778"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; Cofree u (Free f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span> </span><span id="local-6989586621679086779"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086779"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Free f a
forall a. a -&gt; Free f a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086779"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Free f a -&gt; u (Cofree u (Free f a)) -&gt; Cofree u (Free f a)
forall (f :: * -&gt; *) a. a -&gt; f (Cofree f a) -&gt; Cofree f a
</span><span class="hs-operator hs-var">:&lt;</span></span><span> </span><span class="annot"><span class="annottext">(f () -&gt; Cofree u (Free f a)) -&gt; u (Cofree u (Free f a))
forall (f :: * -&gt; *) (u :: * -&gt; *) b.
Adjunction f u =&gt;
(f () -&gt; b) -&gt; u b
</span><a href="Data.Functor.Adjunction.html#tabulateAdjunction"><span class="hs-identifier hs-var">tabulateAdjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679086781"><span class="annot"><span class="annottext">f ()
</span><a href="#local-6989586621679086781"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Free f a -&gt; Free f a) -&gt; a -&gt; Cofree u (Free f a)
forall a b. (Free f a -&gt; b) -&gt; a -&gt; Cofree u b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (Free f a) -&gt; Free f a
forall a. f (Free f a) -&gt; Free f a
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
MonadFree f m =&gt;
f (m a) -&gt; m a
</span><span class="hs-identifier hs-var">wrap</span></span><span> </span><span class="annot"><span class="annottext">(f (Free f a) -&gt; Free f a)
-&gt; (Free f a -&gt; f (Free f a)) -&gt; Free f a -&gt; Free f a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Free f a -&gt; f () -&gt; f (Free f a))
-&gt; f () -&gt; Free f a -&gt; f (Free f a)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Free f a -&gt; f () -&gt; f (Free f a)
forall (f :: * -&gt; *) a. Functor f =&gt; a -&gt; f () -&gt; f a
</span><a href="Data.Functor.Adjunction.html#unsplitL"><span class="hs-identifier hs-var">unsplitL</span></a></span><span> </span><span class="annot"><span class="annottext">f ()
</span><a href="#local-6989586621679086781"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086779"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>  </span><span id="local-6989586621679086790"><span class="annot"><span class="annottext">counit :: forall a. Free f (Cofree u a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Pure</span></span><span> </span><span id="local-6989586621679086792"><span class="annot"><span class="annottext">Cofree u a
</span><a href="#local-6989586621679086792"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cofree u a -&gt; a
forall a. Cofree u a -&gt; a
forall (w :: * -&gt; *) a. Comonad w =&gt; w a -&gt; a
</span><span class="hs-identifier hs-var">extract</span></span><span> </span><span class="annot"><span class="annottext">Cofree u a
</span><a href="#local-6989586621679086792"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-201"></span><span>  </span><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var">counit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Free</span></span><span> </span><span id="local-6989586621679086795"><span class="annot"><span class="annottext">f (Free f (Cofree u a))
</span><a href="#local-6989586621679086795"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Cofree u a -&gt; Cofree u a) -&gt; Free f (Cofree u a) -&gt; a
forall a b. (a -&gt; Cofree u b) -&gt; Free f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(u (Cofree u a) -&gt; f (Free f (Cofree u a)) -&gt; Cofree u a)
-&gt; f (Free f (Cofree u a)) -&gt; u (Cofree u a) -&gt; Cofree u a
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">u (Cofree u a) -&gt; f (Free f (Cofree u a)) -&gt; Cofree u a
forall (f :: * -&gt; *) (u :: * -&gt; *) b a.
Adjunction f u =&gt;
u b -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#indexAdjunction"><span class="hs-identifier hs-var">indexAdjunction</span></a></span><span> </span><span class="annot"><span class="annottext">f (Free f (Cofree u a))
</span><a href="#local-6989586621679086795"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">(u (Cofree u a) -&gt; Cofree u a)
-&gt; (Cofree u a -&gt; u (Cofree u a)) -&gt; Cofree u a -&gt; Cofree u a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Cofree u a -&gt; u (Cofree u a)
forall a. Cofree u a -&gt; u (Cofree u a)
forall (f :: * -&gt; *) (w :: * -&gt; *) a.
ComonadCofree f w =&gt;
w a -&gt; f (w a)
</span><span class="hs-identifier hs-var">unwrap</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">f (Free f (Cofree u a)) -&gt; Free f (Cofree u a)
forall (f :: * -&gt; *) (u :: * -&gt; *) a. Adjunction f u =&gt; f a -&gt; a
</span><a href="Data.Functor.Adjunction.html#extractL"><span class="hs-identifier hs-var">extractL</span></a></span><span> </span><span class="annot"><span class="annottext">f (Free f (Cofree u a))
</span><a href="#local-6989586621679086795"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-202"></span><span>
</span><span id="line-203"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086806"><span id="local-6989586621679086810"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">V1</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">U1</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-204"></span><span>  </span><span id="local-6989586621679086812"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; U1 (V1 a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">U1 (V1 a)
forall k (p :: k). U1 p
</span><span class="hs-identifier hs-var">U1</span></span><span>
</span><span id="line-205"></span><span>  </span><span id="local-6989586621679086814"><span class="annot"><span class="annottext">counit :: forall a. V1 (U1 a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">V1 (U1 a) -&gt; a
forall a b. V1 a -&gt; b
</span><a href="Data.Functor.Adjunction.html#absurdV1"><span class="hs-identifier hs-var">absurdV1</span></a></span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span id="local-6989586621679086379"><span id="local-6989586621679086380"><span class="annot"><a href="Data.Functor.Adjunction.html#absurdV1"><span class="hs-identifier hs-type">absurdV1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">V1</span></span><span> </span><span class="annot"><a href="#local-6989586621679086379"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679086380"><span class="hs-identifier hs-type">b</span></a></span></span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 708
</span><span id="absurdV1"><span class="annot"><span class="annottext">absurdV1 :: forall a b. V1 a -&gt; b
</span><a href="Data.Functor.Adjunction.html#absurdV1"><span class="hs-identifier hs-var hs-var">absurdV1</span></a></span></span><span> </span><span id="local-6989586621679086816"><span class="annot"><span class="annottext">V1 a
</span><a href="#local-6989586621679086816"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">V1 a
</span><a href="#local-6989586621679086816"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">absurdV1</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">seq</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">undefined</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-214"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086824"><span id="local-6989586621679086828"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Par1</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Par1</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-215"></span><span>  </span><span id="local-6989586621679086832"><span class="annot"><span class="annottext">leftAdjunct :: forall a b. (Par1 a -&gt; b) -&gt; a -&gt; Par1 b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">leftAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086833"><span class="annot"><span class="annottext">Par1 a -&gt; b
</span><a href="#local-6989586621679086833"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Par1 b
forall p. p -&gt; Par1 p
</span><span class="hs-identifier hs-var">Par1</span></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Par1 b) -&gt; (a -&gt; b) -&gt; a -&gt; Par1 b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Par1 a -&gt; b
</span><a href="#local-6989586621679086833"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Par1 a -&gt; b) -&gt; (a -&gt; Par1 a) -&gt; a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Par1 a
forall p. p -&gt; Par1 p
</span><span class="hs-identifier hs-var">Par1</span></span><span>
</span><span id="line-216"></span><span>  </span><span id="local-6989586621679086835"><span class="annot"><span class="annottext">rightAdjunct :: forall a b. (a -&gt; Par1 b) -&gt; Par1 a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var hs-var hs-var hs-var">rightAdjunct</span></a></span></span><span> </span><span id="local-6989586621679086836"><span class="annot"><span class="annottext">a -&gt; Par1 b
</span><a href="#local-6989586621679086836"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Par1 b -&gt; b
forall p. Par1 p -&gt; p
</span><span class="hs-identifier hs-var">unPar1</span></span><span> </span><span class="annot"><span class="annottext">(Par1 b -&gt; b) -&gt; (Par1 a -&gt; Par1 b) -&gt; Par1 a -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Par1 b
</span><a href="#local-6989586621679086836"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Par1 b) -&gt; (Par1 a -&gt; a) -&gt; Par1 a -&gt; Par1 b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Par1 a -&gt; a
forall p. Par1 p -&gt; p
</span><span class="hs-identifier hs-var">unPar1</span></span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086393"><span id="local-6989586621679086394"><span id="local-6989586621679086850"><span id="local-6989586621679086854"><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086393"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086394"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Rec1</span></span><span> </span><span class="annot"><a href="#local-6989586621679086393"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Rec1</span></span><span> </span><span class="annot"><a href="#local-6989586621679086394"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-219"></span><span>  </span><span id="local-6989586621679086857"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; Rec1 g (Rec1 f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">g (Rec1 f a) -&gt; Rec1 g (Rec1 f a)
forall k (f :: k -&gt; *) (p :: k). f p -&gt; Rec1 f p
</span><span class="hs-identifier hs-var">Rec1</span></span><span> </span><span class="annot"><span class="annottext">(g (Rec1 f a) -&gt; Rec1 g (Rec1 f a))
-&gt; (a -&gt; g (Rec1 f a)) -&gt; a -&gt; Rec1 g (Rec1 f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; Rec1 f a) -&gt; a -&gt; g (Rec1 f a)
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; Rec1 f a
forall k (f :: k -&gt; *) (p :: k). f p -&gt; Rec1 f p
</span><span class="hs-identifier hs-var">Rec1</span></span><span>
</span><span id="line-220"></span><span>  </span><span id="local-6989586621679086860"><span class="annot"><span class="annottext">counit :: forall a. Rec1 f (Rec1 g a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Rec1 g a -&gt; g a) -&gt; f (Rec1 g a) -&gt; a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">Rec1 g a -&gt; g a
forall k (f :: k -&gt; *) (p :: k). Rec1 f p -&gt; f p
</span><span class="hs-identifier hs-var">unRec1</span></span><span> </span><span class="annot"><span class="annottext">(f (Rec1 g a) -&gt; a)
-&gt; (Rec1 f (Rec1 g a) -&gt; f (Rec1 g a)) -&gt; Rec1 f (Rec1 g a) -&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Rec1 f (Rec1 g a) -&gt; f (Rec1 g a)
forall k (f :: k -&gt; *) (p :: k). Rec1 f p -&gt; f p
</span><span class="hs-identifier hs-var">unRec1</span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="hs-comment">-- @i@ and @c@ indexes have to be the same due functional dependency.</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- But we want them to be different, therefore we rather not define this instance</span><span>
</span><span id="line-224"></span><span class="hs-comment">{-
instance Adjunction f g =&gt; Adjunction (M1 i c f) (M1 i c g) where
  unit   = M1 . leftAdjunct M1
  counit = rightAdjunct unM1 . unM1
-}</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086411"><span id="local-6989586621679086412"><span id="local-6989586621679086413"><span id="local-6989586621679086414"><span id="local-6989586621679086877"><span id="local-6989586621679086881"><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086411"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086412"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086413"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086414"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086413"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:.:</span></span><span> </span><span class="annot"><a href="#local-6989586621679086411"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086412"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:.:</span></span><span> </span><span class="annot"><a href="#local-6989586621679086414"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-231"></span><span>  </span><span id="local-6989586621679086885"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; (:.:) g g' ((:.:) f' f a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">g (g' ((:.:) f' f a)) -&gt; (:.:) g g' ((:.:) f' f a)
forall k2 k1 (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (p :: k1).
f (g p) -&gt; (:.:) f g p
</span><span class="hs-identifier hs-var">Comp1</span></span><span> </span><span class="annot"><span class="annottext">(g (g' ((:.:) f' f a)) -&gt; (:.:) g g' ((:.:) f' f a))
-&gt; (a -&gt; g (g' ((:.:) f' f a))) -&gt; a -&gt; (:.:) g g' ((:.:) f' f a)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(f a -&gt; g' ((:.:) f' f a)) -&gt; a -&gt; g (g' ((:.:) f' f a))
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(f' (f a) -&gt; (:.:) f' f a) -&gt; f a -&gt; g' ((:.:) f' f a)
forall a b. (f' a -&gt; b) -&gt; a -&gt; g' b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f' (f a) -&gt; (:.:) f' f a
forall k2 k1 (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (p :: k1).
f (g p) -&gt; (:.:) f g p
</span><span class="hs-identifier hs-var">Comp1</span></span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span>  </span><span id="local-6989586621679086889"><span class="annot"><span class="annottext">counit :: forall a. (:.:) f' f ((:.:) g g' a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f ((:.:) g g' a) -&gt; g' a) -&gt; f' (f ((:.:) g g' a)) -&gt; a
forall a b. (a -&gt; g' b) -&gt; f' a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((:.:) g g' a -&gt; g (g' a)) -&gt; f ((:.:) g g' a) -&gt; g' a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">(:.:) g g' a -&gt; g (g' a)
forall k2 k1 (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (p :: k1).
(:.:) f g p -&gt; f (g p)
</span><span class="hs-identifier hs-var">unComp1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f' (f ((:.:) g g' a)) -&gt; a)
-&gt; ((:.:) f' f ((:.:) g g' a) -&gt; f' (f ((:.:) g g' a)))
-&gt; (:.:) f' f ((:.:) g g' a)
-&gt; a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(:.:) f' f ((:.:) g g' a) -&gt; f' (f ((:.:) g g' a))
forall k2 k1 (f :: k2 -&gt; *) (g :: k1 -&gt; k2) (p :: k1).
(:.:) f g p -&gt; f (g p)
</span><span class="hs-identifier hs-var">unComp1</span></span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679086435"><span id="local-6989586621679086436"><span id="local-6989586621679086437"><span id="local-6989586621679086438"><span id="local-6989586621679086906"><span id="local-6989586621679086910"><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086435"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086436"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086437"><span class="hs-identifier hs-type">f'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679086438"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Functor.Adjunction.html#Adjunction"><span class="hs-identifier hs-type">Adjunction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086435"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:+:</span></span><span> </span><span class="annot"><a href="#local-6989586621679086437"><span class="hs-identifier hs-type">f'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679086436"><span class="hs-identifier hs-type">g</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">:*:</span></span><span> </span><span class="annot"><a href="#local-6989586621679086438"><span class="hs-identifier hs-type">g'</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-235"></span><span>  </span><span id="local-6989586621679086914"><span class="annot"><span class="annottext">unit :: forall a. a -&gt; (:*:) g g' ((:+:) f f' a)
</span><a href="Data.Functor.Adjunction.html#unit"><span class="hs-keyword hs-var hs-var hs-var hs-var">unit</span></a></span></span><span> </span><span id="local-6989586621679086915"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086915"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; (:+:) f f' a) -&gt; a -&gt; g ((:+:) f f' a)
forall a b. (f a -&gt; b) -&gt; a -&gt; g b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; (:+:) f f' a
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). f p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">L1</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086915"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">g ((:+:) f f' a) -&gt; g' ((:+:) f f' a) -&gt; (:*:) g g' ((:+:) f f' a)
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k).
f p -&gt; g p -&gt; (:*:) f g p
</span><span class="hs-operator hs-var">:*:</span></span><span> </span><span class="annot"><span class="annottext">(f' a -&gt; (:+:) f f' a) -&gt; a -&gt; g' ((:+:) f f' a)
forall a b. (f' a -&gt; b) -&gt; a -&gt; g' b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(f a -&gt; b) -&gt; a -&gt; u b
</span><a href="Data.Functor.Adjunction.html#leftAdjunct"><span class="hs-identifier hs-var">leftAdjunct</span></a></span><span> </span><span class="annot"><span class="annottext">f' a -&gt; (:+:) f f' a
forall k (f :: k -&gt; *) (g :: k -&gt; *) (p :: k). g p -&gt; (:+:) f g p
</span><span class="hs-identifier hs-var">R1</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679086915"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-236"></span><span>  </span><span id="local-6989586621679086921"><span class="annot"><span class="annottext">counit :: forall a. (:+:) f f' ((:*:) g g' a) -&gt; a
</span><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var hs-var hs-var hs-var">counit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">L1</span></span><span> </span><span id="local-6989586621679086922"><span class="annot"><span class="annottext">f ((:*:) g g' a)
</span><a href="#local-6989586621679086922"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((:*:) g g' a -&gt; g a) -&gt; f ((:*:) g g' a) -&gt; a
forall a b. (a -&gt; g b) -&gt; f a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679086923"><span class="annot"><span class="annottext">g a
</span><a href="#local-6989586621679086923"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:*:</span></span><span> </span><span class="annot"><span class="annottext">g' a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">g a
</span><a href="#local-6989586621679086923"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f ((:*:) g g' a)
</span><a href="#local-6989586621679086922"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-237"></span><span>  </span><span class="annot"><a href="Data.Functor.Adjunction.html#counit"><span class="hs-identifier hs-var">counit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">R1</span></span><span> </span><span id="local-6989586621679086924"><span class="annot"><span class="annottext">f' ((:*:) g g' a)
</span><a href="#local-6989586621679086924"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((:*:) g g' a -&gt; g' a) -&gt; f' ((:*:) g g' a) -&gt; a
forall a b. (a -&gt; g' b) -&gt; f' a -&gt; b
forall (f :: * -&gt; *) (u :: * -&gt; *) a b.
Adjunction f u =&gt;
(a -&gt; u b) -&gt; f a -&gt; b
</span><a href="Data.Functor.Adjunction.html#rightAdjunct"><span class="hs-identifier hs-var">rightAdjunct</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><span class="annottext">g a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:*:</span></span><span> </span><span id="local-6989586621679086925"><span class="annot"><span class="annottext">g' a
</span><a href="#local-6989586621679086925"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">g' a
</span><a href="#local-6989586621679086925"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f' ((:*:) g g' a)
</span><a href="#local-6989586621679086924"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-238"></span></pre></body></html>