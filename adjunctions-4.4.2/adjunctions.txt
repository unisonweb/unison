-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Adjunctions and representable functors
--   
--   Adjunctions and representable functors.
@package adjunctions
@version 4.4.2


-- | <pre>
--   Cont r ~ Contravariant.Adjoint (Op r) (Op r)
--   Conts r ~ Contravariant.AdjointT (Op r) (Op r)
--   ContsT r w m ~ Contravariant.AdjointT (Op (m r)) (Op (m r)) w
--   </pre>
module Control.Monad.Trans.Conts
type Cont r = ContsT r Identity Identity
cont :: ((a -> r) -> r) -> Cont r a
runCont :: Cont r a -> (a -> r) -> r
type Conts r w = ContsT r w Identity
runConts :: Functor w => Conts r w a -> w (a -> r) -> r
conts :: Functor w => (w (a -> r) -> r) -> Conts r w a
newtype ContsT r w m a
ContsT :: (w (a -> m r) -> m r) -> ContsT r w m a
[runContsT] :: ContsT r w m a -> w (a -> m r) -> m r
callCC :: Comonad w => ((a -> ContsT r w m b) -> ContsT r w m a) -> ContsT r w m a
instance GHC.Base.Functor w => GHC.Base.Functor (Control.Monad.Trans.Conts.ContsT r w m)
instance Control.Comonad.Comonad w => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Conts.ContsT r w m)
instance Control.Comonad.Comonad w => GHC.Base.Applicative (Control.Monad.Trans.Conts.ContsT r w m)
instance Control.Comonad.Comonad w => GHC.Base.Monad (Control.Monad.Trans.Conts.ContsT r w m)
instance Control.Comonad.Comonad w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Conts.ContsT r w)


-- | Representable contravariant endofunctors over the category of Haskell
--   types are isomorphic to <tt>(_ -&gt; r)</tt> and resemble mappings to
--   a fixed range.
module Data.Functor.Contravariant.Rep

-- | A <a>Contravariant</a> functor <tt>f</tt> is <a>Representable</a> if
--   <a>tabulate</a> and <a>index</a> witness an isomorphism to <tt>(_
--   -&gt; Rep f)</tt>.
--   
--   <pre>
--   <a>tabulate</a> . <a>index</a> ≡ id
--   <a>index</a> . <a>tabulate</a> ≡ id
--   </pre>
class Contravariant f => Representable f where {
    type Rep f :: *;
}

-- | <pre>
--   <a>contramap</a> f (<a>tabulate</a> g) = <a>tabulate</a> (g . f)
--   </pre>
tabulate :: Representable f => (a -> Rep f) -> f a
index :: Representable f => f a -> a -> Rep f

-- | <pre>
--   <a>contramapWithRep</a> f p ≡ <a>tabulate</a> $ <a>either</a> (<a>index</a> p) <a>id</a> . f
--   </pre>
contramapWithRep :: Representable f => (b -> Either a (Rep f)) -> f a -> f b

-- | <a>tabulate</a> and <a>index</a> form two halves of an isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>tabulated</a> :: <a>Representable</a> f =&gt; <tt>Iso'</tt> (a -&gt; <a>Rep</a> f) (f a)
--   </pre>
tabulated :: (Representable f, Representable g, Profunctor p, Functor h) => p (f a) (h (g b)) -> p (a -> Rep f) (h (b -> Rep g))
contramapRep :: Representable f => (a -> b) -> f b -> f a
instance Data.Functor.Contravariant.Rep.Representable Data.Proxy.Proxy
instance Data.Functor.Contravariant.Rep.Representable (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Rep.Representable Data.Functor.Contravariant.Predicate
instance (Data.Functor.Contravariant.Rep.Representable f, Data.Functor.Contravariant.Rep.Representable g) => Data.Functor.Contravariant.Rep.Representable (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Rep.Representable GHC.Generics.U1
instance (Data.Functor.Contravariant.Rep.Representable f, Data.Functor.Contravariant.Rep.Representable g) => Data.Functor.Contravariant.Rep.Representable (f GHC.Generics.:*: g)


module Data.Functor.Contravariant.Adjunction

-- | An adjunction from <tt>Hask^op</tt> to <tt>Hask</tt>
--   
--   <pre>
--   <a>Op</a> (f a) b ~ <tt>Hask</tt> a (g b)
--   </pre>
--   
--   <pre>
--   <a>rightAdjunct</a> <a>unit</a> = <a>id</a>
--   <a>leftAdjunct</a> <a>counit</a> = <a>id</a>
--   </pre>
--   
--   Any adjunction from <tt>Hask</tt> to <tt>Hask^op</tt> would indirectly
--   permit <tt>unsafePerformIO</tt>, and therefore does not exist.
class (Contravariant f, Representable g) => Adjunction f g | f -> g, g -> f
unit :: Adjunction f g => a -> g (f a)
counit :: Adjunction f g => a -> f (g a)
leftAdjunct :: Adjunction f g => (b -> f a) -> a -> g b
rightAdjunct :: Adjunction f g => (a -> g b) -> b -> f a

-- | <a>leftAdjunct</a> and <a>rightAdjunct</a> form two halves of an
--   isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>adjuncted</a> :: <a>Adjunction</a> f g =&gt; <tt>Iso'</tt> (b -&gt; f a) (a -&gt; g b)
--   </pre>
adjuncted :: (Adjunction f g, Profunctor p, Functor h) => p (a -> g b) (h (c -> g d)) -> p (b -> f a) (h (d -> f c))

-- | Represent a <a>Contravariant</a> functor that has a left adjoint
contrarepAdjunction :: Adjunction f g => (a -> f ()) -> g a
coindexAdjunction :: Adjunction f g => g a -> a -> f ()
instance Data.Functor.Contravariant.Adjunction.Adjunction (Data.Functor.Contravariant.Op r) (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Adjunction.Adjunction Data.Functor.Contravariant.Predicate Data.Functor.Contravariant.Predicate


-- | Uses a contravariant adjunction:
--   
--   f -| g : Hask^op -&gt; Hask
--   
--   to build a <a>Comonad</a> to <a>Monad</a> transformer. Sadly, the dual
--   construction, which builds a <a>Comonad</a> out of a <a>Monad</a>, is
--   uninhabited, because any <a>Adjunction</a> of the form
--   
--   <pre>
--   f -| g : Hask -&gt; Hask^op
--   </pre>
--   
--   would trivially admit unsafePerformIO.
module Control.Monad.Trans.Contravariant.Adjoint
type Adjoint f g = AdjointT f g Identity
runAdjoint :: Contravariant g => Adjoint f g a -> g (f a)
adjoint :: Contravariant g => g (f a) -> Adjoint f g a
newtype AdjointT f g w a
AdjointT :: g (w (f a)) -> AdjointT f g w a
[runAdjointT] :: AdjointT f g w a -> g (w (f a))
instance (Data.Functor.Contravariant.Adjunction.Adjunction f g, GHC.Base.Functor w) => GHC.Base.Functor (Control.Monad.Trans.Contravariant.Adjoint.AdjointT f g w)
instance (Data.Functor.Contravariant.Adjunction.Adjunction f g, Control.Comonad.Comonad w) => GHC.Base.Applicative (Control.Monad.Trans.Contravariant.Adjoint.AdjointT f g w)
instance (Data.Functor.Contravariant.Adjunction.Adjunction f g, Control.Comonad.Comonad w) => GHC.Base.Monad (Control.Monad.Trans.Contravariant.Adjoint.AdjointT f g w)


-- | Representable endofunctors over the category of Haskell types are
--   isomorphic to the reader monad and so inherit a very large number of
--   properties for free.
module Data.Functor.Rep

-- | A <a>Functor</a> <tt>f</tt> is <a>Representable</a> if <a>tabulate</a>
--   and <a>index</a> witness an isomorphism to <tt>(-&gt;) x</tt>.
--   
--   Every <a>Distributive</a> <a>Functor</a> is actually
--   <a>Representable</a>.
--   
--   Every <a>Representable</a> <a>Functor</a> from Hask to Hask is a right
--   adjoint.
--   
--   <pre>
--   <a>tabulate</a> . <a>index</a>  ≡ id
--   <a>index</a> . <a>tabulate</a>  ≡ id
--   <a>tabulate</a> . <a>return</a> ≡ <a>return</a>
--   </pre>
class Distributive f => Representable f where {
    
    -- | If no definition is provided, this will default to <a>GRep</a>.
    type Rep f :: *;
    type Rep f = GRep f;
}

-- | <pre>
--   <a>fmap</a> f . <a>tabulate</a> ≡ <a>tabulate</a> . <a>fmap</a> f
--   </pre>
--   
--   If no definition is provided, this will default to <a>gtabulate</a>.
tabulate :: Representable f => (Rep f -> a) -> f a

-- | <pre>
--   <a>fmap</a> f . <a>tabulate</a> ≡ <a>tabulate</a> . <a>fmap</a> f
--   </pre>
--   
--   If no definition is provided, this will default to <a>gtabulate</a>.
tabulate :: (Representable f, Generic1 f, GRep f ~ Rep f, GTabulate (Rep1 f)) => (Rep f -> a) -> f a

-- | If no definition is provided, this will default to <a>gindex</a>.
index :: Representable f => f a -> Rep f -> a

-- | If no definition is provided, this will default to <a>gindex</a>.
index :: (Representable f, Generic1 f, GRep f ~ Rep f, GIndex (Rep1 f)) => f a -> Rep f -> a

-- | <a>tabulate</a> and <a>index</a> form two halves of an isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>tabulated</a> :: <a>Representable</a> f =&gt; <tt>Iso'</tt> (<a>Rep</a> f -&gt; a) (f a)
--   </pre>
tabulated :: (Representable f, Representable g, Profunctor p, Functor h) => p (f a) (h (g b)) -> p (Rep f -> a) (h (Rep g -> b))
newtype Co f a
Co :: f a -> Co f a
[unCo] :: Co f a -> f a
fmapRep :: Representable f => (a -> b) -> f a -> f b
distributeRep :: (Representable f, Functor w) => w (f a) -> f (w a)
collectRep :: (Representable f, Functor w) => (a -> f b) -> w a -> f (w b)
apRep :: Representable f => f (a -> b) -> f a -> f b
pureRep :: Representable f => a -> f a
liftR2 :: Representable f => (a -> b -> c) -> f a -> f b -> f c
liftR3 :: Representable f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
bindRep :: Representable f => f a -> (a -> f b) -> f b
mfixRep :: Representable f => (a -> f a) -> f a
mzipRep :: Representable f => f a -> f b -> f (a, b)
mzipWithRep :: Representable f => (a -> b -> c) -> f a -> f b -> f c
askRep :: Representable f => f (Rep f)
localRep :: Representable f => (Rep f -> Rep f) -> f a -> f a
duplicatedRep :: (Representable f, Semigroup (Rep f)) => f a -> f (f a)
extendedRep :: (Representable f, Semigroup (Rep f)) => (f a -> b) -> f a -> f b
duplicateRep :: (Representable f, Monoid (Rep f)) => f a -> f (f a)
extendRep :: (Representable f, Monoid (Rep f)) => (f a -> b) -> f a -> f b
extractRep :: (Representable f, Monoid (Rep f)) => f a -> a
duplicateRepBy :: Representable f => (Rep f -> Rep f -> Rep f) -> f a -> f (f a)
extendRepBy :: Representable f => (Rep f -> Rep f -> Rep f) -> (f a -> b) -> f a -> f b
extractRepBy :: Representable f => Rep f -> f a -> a
imapRep :: Representable r => (Rep r -> a -> a') -> r a -> r a'
ifoldMapRep :: forall r m a. (Representable r, Foldable r, Monoid m) => (Rep r -> a -> m) -> r a -> m
itraverseRep :: forall r f a a'. (Representable r, Traversable r, Applicative f) => (Rep r -> a -> f a') -> r a -> f (r a')

-- | A default implementation of <a>Rep</a> for a datatype that is an
--   instance of <a>Generic1</a>. This is usually composed of
--   <a>Either</a>, tuples, unit tuples, and underlying <a>Rep</a> values.
--   For instance, if you have:
--   
--   <pre>
--   data Foo a = MkFoo a (Bar a) (Baz (Quux a)) deriving (<a>Functor</a>, <a>Generic1</a>)
--   instance <a>Representable</a> Foo
--   </pre>
--   
--   Then you'll get:
--   
--   <pre>
--   <a>GRep</a> Foo = Either () (Either (<a>WrappedRep</a> Bar) (<a>WrappedRep</a> Baz, <a>WrappedRep</a> Quux))
--   </pre>
--   
--   (See the Haddocks for <a>WrappedRep</a> for an explanation of its
--   purpose.)
type GRep f = GRep' (Rep1 f)

-- | A default implementation of <a>index</a> in terms of <a>GRep</a>.
gindex :: (Generic1 f, GRep f ~ Rep f, GIndex (Rep1 f)) => f a -> Rep f -> a

-- | A default implementation of <a>tabulate</a> in terms of <a>GRep</a>.
gtabulate :: (Generic1 f, GRep f ~ Rep f, GTabulate (Rep1 f)) => (Rep f -> a) -> f a

-- | On the surface, <tt>WrappedRec</tt> is a simple wrapper around
--   <a>Rep</a>. But it plays a very important role: it prevents generic
--   <a>Representable</a> instances for recursive types from sending the
--   typechecker into an infinite loop. Consider the following datatype:
--   
--   <pre>
--   data Stream a = a :&lt; Stream a deriving (<a>Functor</a>, <a>Generic1</a>)
--   instance <a>Representable</a> Stream
--   </pre>
--   
--   With <a>WrappedRep</a>, we have its <a>Rep</a> being:
--   
--   <pre>
--   <a>Rep</a> Stream = <a>Either</a> () (<a>WrappedRep</a> Stream)
--   </pre>
--   
--   If <a>WrappedRep</a> didn't exist, it would be:
--   
--   <pre>
--   <a>Rep</a> Stream = Either () (Either () (Either () ...))
--   </pre>
--   
--   An infinite type! <a>WrappedRep</a> breaks the potentially infinite
--   loop.
newtype WrappedRep f
WrapRep :: Rep f -> WrappedRep f
[unwrapRep] :: WrappedRep f -> Rep f
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable w => Data.Functor.Rep.Representable (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable f => Data.Functor.Bind.Class.Apply (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable f => GHC.Base.Applicative (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable f => Data.Distributive.Distributive (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable f => Data.Functor.Bind.Class.Bind (Data.Functor.Rep.Co f)
instance Data.Functor.Rep.Representable f => GHC.Base.Monad (Data.Functor.Rep.Co f)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Rep f GHC.Types.~ a) => Control.Monad.Reader.Class.MonadReader a (Data.Functor.Rep.Co f)
instance (Data.Functor.Rep.Representable f, GHC.Base.Semigroup (Data.Functor.Rep.Rep f)) => Data.Functor.Extend.Extend (Data.Functor.Rep.Co f)
instance (Data.Functor.Rep.Representable f, GHC.Base.Monoid (Data.Functor.Rep.Rep f)) => Control.Comonad.Comonad (Data.Functor.Rep.Co f)
instance Control.Comonad.Trans.Class.ComonadTrans Data.Functor.Rep.Co
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.GTabulate g) => Data.Functor.Rep.GTabulate (f GHC.Generics.:.: g)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.GIndex g) => Data.Functor.Rep.GIndex (f GHC.Generics.:.: g)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.GTabulate (GHC.Generics.Rec1 f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.GIndex (GHC.Generics.Rec1 f)
instance Data.Functor.Rep.Representable Data.Proxy.Proxy
instance Data.Functor.Rep.Representable Data.Functor.Identity.Identity
instance Data.Functor.Rep.Representable (Data.Tagged.Tagged t)
instance Data.Functor.Rep.Representable m => Data.Functor.Rep.Representable (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Rep.Representable ((->) e)
instance Data.Functor.Rep.Representable m => Data.Functor.Rep.Representable (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable g) => Data.Functor.Rep.Representable (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable g) => Data.Functor.Rep.Representable (Data.Functor.Product.Product f g)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Control.Comonad.Cofree.Cofree f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Rep.Representable Data.Semigroup.Internal.Dual
instance Data.Functor.Rep.Representable Data.Semigroup.Internal.Product
instance Data.Functor.Rep.Representable Data.Semigroup.Internal.Sum
instance Data.Functor.Rep.Representable Data.Complex.Complex
instance Data.Functor.Rep.Representable GHC.Generics.U1
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable g) => Data.Functor.Rep.Representable (f GHC.Generics.:*: g)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable g) => Data.Functor.Rep.Representable (f GHC.Generics.:.: g)
instance Data.Functor.Rep.Representable GHC.Generics.Par1
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (GHC.Generics.Rec1 f)
instance Data.Functor.Rep.Representable f => Data.Functor.Rep.Representable (GHC.Generics.M1 i c f)
instance (Data.Functor.Rep.GIndex f, Data.Functor.Rep.GIndex g) => Data.Functor.Rep.GIndex (f GHC.Generics.:*: g)
instance Data.Functor.Rep.GIndex GHC.Generics.Par1
instance Data.Functor.Rep.GIndex f => Data.Functor.Rep.GIndex (GHC.Generics.M1 i c f)
instance (Data.Functor.Rep.GTabulate f, Data.Functor.Rep.GTabulate g) => Data.Functor.Rep.GTabulate (f GHC.Generics.:*: g)
instance Data.Functor.Rep.GTabulate GHC.Generics.Par1
instance Data.Functor.Rep.GTabulate f => Data.Functor.Rep.GTabulate (GHC.Generics.M1 i c f)


module Data.Functor.Adjunction

-- | An adjunction between Hask and Hask.
--   
--   Minimal definition: both <a>unit</a> and <a>counit</a> or both
--   <a>leftAdjunct</a> and <a>rightAdjunct</a>, subject to the constraints
--   imposed by the default definitions that the following laws should
--   hold.
--   
--   <pre>
--   unit = leftAdjunct id
--   counit = rightAdjunct id
--   leftAdjunct f = fmap f . unit
--   rightAdjunct f = counit . fmap f
--   </pre>
--   
--   Any implementation is required to ensure that <a>leftAdjunct</a> and
--   <a>rightAdjunct</a> witness an isomorphism from <tt>Nat (f a, b)</tt>
--   to <tt>Nat (a, g b)</tt>
--   
--   <pre>
--   rightAdjunct unit = id
--   leftAdjunct counit = id
--   </pre>
class (Functor f, Representable u) => Adjunction f u | f -> u, u -> f
unit :: Adjunction f u => a -> u (f a)
counit :: Adjunction f u => f (u a) -> a
leftAdjunct :: Adjunction f u => (f a -> b) -> a -> u b
rightAdjunct :: Adjunction f u => (a -> u b) -> f a -> b

-- | <a>leftAdjunct</a> and <a>rightAdjunct</a> form two halves of an
--   isomorphism.
--   
--   This can be used with the combinators from the <tt>lens</tt> package.
--   
--   <pre>
--   <a>adjuncted</a> :: <a>Adjunction</a> f u =&gt; <tt>Iso'</tt> (f a -&gt; b) (a -&gt; u b)
--   </pre>
adjuncted :: (Adjunction f u, Profunctor p, Functor g) => p (a -> u b) (g (c -> u d)) -> p (f a -> b) (g (f c -> d))

-- | Every right adjoint is representable by its left adjoint applied to a
--   unit element
--   
--   Use this definition and the primitives in Data.Functor.Representable
--   to meet the requirements of the superclasses of Representable.
tabulateAdjunction :: Adjunction f u => (f () -> b) -> u b

-- | This definition admits a default definition for the <a>index</a>
--   method of 'Index", one of the superclasses of Representable.
indexAdjunction :: Adjunction f u => u b -> f a -> b
zapWithAdjunction :: Adjunction f u => (a -> b -> c) -> u a -> f b -> c

-- | A right adjoint functor admits an intrinsic notion of zipping
zipR :: Adjunction f u => (u a, u b) -> u (a, b)

-- | Every functor in Haskell permits unzipping
unzipR :: Functor u => u (a, b) -> (u a, u b)

-- | A left adjoint must be inhabited, or we can derive bottom.
unabsurdL :: Adjunction f u => f Void -> Void
absurdL :: Void -> f Void

-- | And a left adjoint must be inhabited by exactly one element
cozipL :: Adjunction f u => f (Either a b) -> Either (f a) (f b)

-- | Every functor in Haskell permits <tt>uncozipping</tt>
uncozipL :: Functor f => Either (f a) (f b) -> f (Either a b)
extractL :: Adjunction f u => f a -> a
duplicateL :: Adjunction f u => f a -> f (f a)
splitL :: Adjunction f u => f a -> (a, f ())
unsplitL :: Functor f => a -> f () -> f a
instance Data.Functor.Adjunction.Adjunction ((,) e) ((->) e)
instance Data.Functor.Adjunction.Adjunction Data.Functor.Identity.Identity Data.Functor.Identity.Identity
instance Data.Functor.Adjunction.Adjunction f g => Data.Functor.Adjunction.Adjunction (Control.Monad.Trans.Identity.IdentityT f) (Control.Monad.Trans.Identity.IdentityT g)
instance Data.Functor.Adjunction.Adjunction w m => Data.Functor.Adjunction.Adjunction (Control.Comonad.Trans.Env.EnvT e w) (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Functor.Adjunction.Adjunction m w => Data.Functor.Adjunction.Adjunction (Control.Monad.Trans.Writer.Lazy.WriterT s m) (Control.Comonad.Trans.Traced.TracedT s w)
instance (Data.Functor.Adjunction.Adjunction f g, Data.Functor.Adjunction.Adjunction f' g') => Data.Functor.Adjunction.Adjunction (Data.Functor.Compose.Compose f' f) (Data.Functor.Compose.Compose g g')
instance (Data.Functor.Adjunction.Adjunction f g, Data.Functor.Adjunction.Adjunction f' g') => Data.Functor.Adjunction.Adjunction (Data.Functor.Sum.Sum f f') (Data.Functor.Product.Product g g')
instance Data.Functor.Adjunction.Adjunction f u => Data.Functor.Adjunction.Adjunction (Control.Monad.Free.Free f) (Control.Comonad.Cofree.Cofree u)
instance Data.Functor.Adjunction.Adjunction GHC.Generics.V1 GHC.Generics.U1
instance Data.Functor.Adjunction.Adjunction GHC.Generics.Par1 GHC.Generics.Par1
instance Data.Functor.Adjunction.Adjunction f g => Data.Functor.Adjunction.Adjunction (GHC.Generics.Rec1 f) (GHC.Generics.Rec1 g)
instance (Data.Functor.Adjunction.Adjunction f g, Data.Functor.Adjunction.Adjunction f' g') => Data.Functor.Adjunction.Adjunction (f' GHC.Generics.:.: f) (g GHC.Generics.:.: g')
instance (Data.Functor.Adjunction.Adjunction f g, Data.Functor.Adjunction.Adjunction f' g') => Data.Functor.Adjunction.Adjunction (f GHC.Generics.:+: f') (g GHC.Generics.:*: g')


module Control.Monad.Trans.Adjoint
type Adjoint f g = AdjointT f g Identity
runAdjoint :: Functor g => Adjoint f g a -> g (f a)
adjoint :: Functor g => g (f a) -> Adjoint f g a
newtype AdjointT f g m a
AdjointT :: g (m (f a)) -> AdjointT f g m a
[runAdjointT] :: AdjointT f g m a -> g (m (f a))
instance (Data.Functor.Adjunction.Adjunction f g, GHC.Base.Monad m) => GHC.Base.Functor (Control.Monad.Trans.Adjoint.AdjointT f g m)
instance (Data.Functor.Adjunction.Adjunction f g, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Adjoint.AdjointT f g m)
instance (Data.Functor.Adjunction.Adjunction f g, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Adjoint.AdjointT f g m)
instance (Data.Functor.Adjunction.Adjunction f g, Data.Traversable.Traversable f) => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Adjoint.AdjointT f g)


module Control.Comonad.Trans.Adjoint
type Adjoint f g = AdjointT f g Identity
runAdjoint :: Functor f => Adjoint f g a -> f (g a)
adjoint :: Functor f => f (g a) -> Adjoint f g a
newtype AdjointT f g w a
AdjointT :: f (w (g a)) -> AdjointT f g w a
[runAdjointT] :: AdjointT f g w a -> f (w (g a))
instance (Data.Functor.Adjunction.Adjunction f g, GHC.Base.Functor w) => GHC.Base.Functor (Control.Comonad.Trans.Adjoint.AdjointT f g w)
instance (Data.Functor.Adjunction.Adjunction f g, Data.Functor.Extend.Extend w) => Data.Functor.Extend.Extend (Control.Comonad.Trans.Adjoint.AdjointT f g w)
instance (Data.Functor.Adjunction.Adjunction f g, Control.Comonad.Comonad w) => Control.Comonad.Comonad (Control.Comonad.Trans.Adjoint.AdjointT f g w)
instance (Data.Functor.Adjunction.Adjunction f g, Data.Distributive.Distributive g) => Control.Comonad.Trans.Class.ComonadTrans (Control.Comonad.Trans.Adjoint.AdjointT f g)


-- | A generalized State monad, parameterized by a Representable functor.
--   The representation of that functor serves as the state.
module Control.Monad.Representable.State

-- | A memoized state monad parameterized by a representable functor
--   <tt>g</tt>, where the representatation of <tt>g</tt>, <tt>Rep g</tt>
--   is the state to carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State g = StateT g Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: Representable g => State g a -> Rep g -> (a, Rep g)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: Representable g => State g a -> Rep g -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: Representable g => State g a -> Rep g -> Rep g

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: Functor g => ((a, Rep g) -> (b, Rep g)) -> State g a -> State g b

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>g</tt> - A representable functor used to memoize results for a
--   state <tt>Rep g</tt></li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT g m a
StateT :: g (m (a, Rep g)) -> StateT g m a
[getStateT] :: StateT g m a -> g (m (a, Rep g))
stateT :: Representable g => (Rep g -> m (a, Rep g)) -> StateT g m a
runStateT :: Representable g => StateT g m a -> Rep g -> m (a, Rep g)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: (Representable g, Monad m) => StateT g m a -> Rep g -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: (Representable g, Monad m) => StateT g m a -> Rep g -> m (Rep g)
mapStateT :: Functor g => (m (a, Rep g) -> n (b, Rep g)) -> StateT g m a -> StateT g n b

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: Representable g => ((((a, Rep g) -> m (b, Rep g)) -> m (a, Rep g)) -> m (a, Rep g)) -> ((a -> StateT g m b) -> StateT g m a) -> StateT g m a

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the laws of a monad transformer.
liftCallCC' :: Representable g => ((((a, Rep g) -> m (b, Rep g)) -> m (a, Rep g)) -> m (a, Rep g)) -> ((a -> StateT g m b) -> StateT g m a) -> StateT g m a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a
instance (GHC.Base.Functor g, GHC.Base.Functor m) => GHC.Base.Functor (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, Data.Functor.Bind.Class.Bind m) => Data.Functor.Bind.Class.Apply (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, Data.Functor.Bind.Class.Bind m) => Data.Functor.Bind.Class.Bind (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Representable.State.StateT g m)
instance Data.Functor.Rep.Representable f => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Representable.State.StateT f)
instance Data.Functor.Rep.Representable f => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Representable.State.StateT f)
instance (Data.Functor.Rep.Representable g, GHC.Base.Monad m, Data.Functor.Rep.Rep g GHC.Types.~ s) => Control.Monad.State.Class.MonadState s (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, Control.Monad.Reader.Class.MonadReader e m) => Control.Monad.Reader.Class.MonadReader e (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Representable.State.StateT g m)
instance (Data.Functor.Rep.Representable g, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Representable.State.StateT g m)
instance (GHC.Base.Functor f, Data.Functor.Rep.Representable g, Control.Monad.Free.Class.MonadFree f m) => Control.Monad.Free.Class.MonadFree f (Control.Monad.Representable.State.StateT g m)


-- | Representable functors on Hask are all monads, because they are
--   isomorphic to a <a>Reader</a> monad.
module Control.Monad.Representable.Reader
type Reader f = ReaderT f Identity
runReader :: Representable f => Reader f b -> Rep f -> b
newtype ReaderT f m b
ReaderT :: f (m b) -> ReaderT f m b
[getReaderT] :: ReaderT f m b -> f (m b)
readerT :: Representable f => (Rep f -> m b) -> ReaderT f m b
runReaderT :: Representable f => ReaderT f m b -> Rep f -> m b

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a
instance (GHC.Base.Functor f, GHC.Base.Functor m) => GHC.Base.Functor (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable m) => Data.Functor.Rep.Representable (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Bind.Class.Apply m) => Data.Functor.Bind.Class.Apply (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Bind.Class.Bind m) => Data.Functor.Bind.Class.Bind (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Representable.Reader.ReaderT f m)
instance Data.Functor.Rep.Representable f => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Representable.Reader.ReaderT f)
instance (Data.Functor.Rep.Representable f, Data.Distributive.Distributive m) => Data.Distributive.Distributive (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable m, GHC.Base.Semigroup (Data.Functor.Rep.Rep f), GHC.Base.Semigroup (Data.Functor.Rep.Rep m)) => Data.Functor.Extend.Extend (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Data.Functor.Rep.Representable m, GHC.Base.Monoid (Data.Functor.Rep.Rep f), GHC.Base.Monoid (Data.Functor.Rep.Rep m)) => Control.Comonad.Comonad (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Functor.Rep.Representable f, Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable m) => Data.Foldable.Foldable (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 m) => Data.Foldable1.Foldable1 (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable m) => Data.Traversable.Traversable (Control.Monad.Representable.Reader.ReaderT f m)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 m) => Data.Semigroup.Traversable.Class.Traversable1 (Control.Monad.Representable.Reader.ReaderT f m)


-- | This is a generalized <a>Store</a> <a>Comonad</a>, parameterized by a
--   <a>Representable</a> <a>Functor</a>. The representation of that
--   <a>Functor</a> serves as the index of the store.
--   
--   This can be useful if the representable functor serves to memoize its
--   contents and will be inspected often.
module Control.Comonad.Representable.Store

-- | A memoized store comonad parameterized by a representable functor
--   <tt>g</tt>, where the representatation of <tt>g</tt>, <tt>Rep g</tt>
--   is the index of the store.
type Store g = StoreT g Identity

-- | Construct a store comonad computation from a function and a current
--   index. (The inverse of <a>runStore</a>.)
store :: Representable g => (Rep g -> a) -> Rep g -> Store g a

-- | Unwrap a store comonad computation as a function and a current index.
--   (The inverse of <a>store</a>.)
runStore :: Representable g => Store g a -> (Rep g -> a, Rep g)

-- | A store transformer comonad parameterized by:
--   
--   <ul>
--   <li><tt>g</tt> - A representable functor used to memoize results for
--   an index <tt>Rep g</tt></li>
--   <li><tt>w</tt> - The inner comonad.</li>
--   </ul>
data StoreT g w a
StoreT :: w (g a) -> Rep g -> StoreT g w a
storeT :: (Functor w, Representable g) => w (Rep g -> a) -> Rep g -> StoreT g w a
runStoreT :: (Functor w, Representable g) => StoreT g w a -> (w (Rep g -> a), Rep g)
class Comonad w => ComonadStore s (w :: Type -> Type) | w -> s
pos :: ComonadStore s w => w a -> s
peek :: ComonadStore s w => s -> w a -> a
peeks :: ComonadStore s w => (s -> s) -> w a -> a
seek :: ComonadStore s w => s -> w a -> w a
seeks :: ComonadStore s w => (s -> s) -> w a -> w a
experiment :: (ComonadStore s w, Functor f) => (s -> f s) -> w a -> f a
instance (Control.Comonad.Comonad w, Data.Functor.Rep.Representable g, Data.Functor.Rep.Rep g GHC.Types.~ s) => Control.Comonad.Store.Class.ComonadStore s (Control.Comonad.Representable.Store.StoreT g w)
instance (GHC.Base.Functor w, GHC.Base.Functor g) => GHC.Base.Functor (Control.Comonad.Representable.Store.StoreT g w)
instance (Data.Functor.Bind.Class.Apply w, GHC.Base.Semigroup (Data.Functor.Rep.Rep g), Data.Functor.Rep.Representable g) => Data.Functor.Bind.Class.Apply (Control.Comonad.Representable.Store.StoreT g w)
instance (Control.Comonad.ComonadApply w, GHC.Base.Semigroup (Data.Functor.Rep.Rep g), Data.Functor.Rep.Representable g) => Control.Comonad.ComonadApply (Control.Comonad.Representable.Store.StoreT g w)
instance (GHC.Base.Applicative w, GHC.Base.Monoid (Data.Functor.Rep.Rep g), Data.Functor.Rep.Representable g) => GHC.Base.Applicative (Control.Comonad.Representable.Store.StoreT g w)
instance (Data.Functor.Extend.Extend w, Data.Functor.Rep.Representable g) => Data.Functor.Extend.Extend (Control.Comonad.Representable.Store.StoreT g w)
instance (Control.Comonad.Comonad w, Data.Functor.Rep.Representable g) => Control.Comonad.Comonad (Control.Comonad.Representable.Store.StoreT g w)
instance Data.Functor.Rep.Representable g => Control.Comonad.Trans.Class.ComonadTrans (Control.Comonad.Representable.Store.StoreT g)
instance Control.Comonad.Hoist.Class.ComonadHoist (Control.Comonad.Representable.Store.StoreT g)
instance (Control.Comonad.Traced.Class.ComonadTraced m w, Data.Functor.Rep.Representable g) => Control.Comonad.Traced.Class.ComonadTraced m (Control.Comonad.Representable.Store.StoreT g w)
instance (Control.Comonad.Env.Class.ComonadEnv m w, Data.Functor.Rep.Representable g) => Control.Comonad.Env.Class.ComonadEnv m (Control.Comonad.Representable.Store.StoreT g w)
instance (Data.Functor.Rep.Representable g, Control.Comonad.Cofree.Class.ComonadCofree f w) => Control.Comonad.Cofree.Class.ComonadCofree f (Control.Comonad.Representable.Store.StoreT g w)
