-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support library for Template Haskell
--   
--   This package provides modules containing facilities for manipulating
--   Haskell source code using Template Haskell.
--   
--   See <a>http://www.haskell.org/haskellwiki/Template_Haskell</a> for
--   more information.
@package template-haskell
@version 2.20.0.0


-- | Language extensions known to GHC
module Language.Haskell.TH.LanguageExtensions

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data () => Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr Specificity] -> Cxt -> Type -> Type

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;type&gt;
--   </pre>
ForallVisT :: [TyVarBndr ()] -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
PromotedInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
PromotedUInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <tt>(,)</tt>, <tt>(,,)</tt>, etc.
TupleT :: Int -> Type

-- | <tt>(#,#)</tt>, <tt>(#,,#)</tt>, etc.
UnboxedTupleT :: Int -> Type

-- | <tt>(#|#)</tt>, <tt>(#||#)</tt>, etc.
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   %n -&gt;
--   </pre>
--   
--   Generalised arrow type with multiplicity argument
MulArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <tt>'()</tt>, <tt>'(,)</tt>, <tt>'(,,)</tt>, etc.
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   '(:)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <tt>0</tt>, <tt>1</tt>, <tt>2</tt>, etc.
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type

-- | Obtained from <a>reifyModule</a> and <a>thisModule</a>.
data Module
Module :: PkgName -> ModName -> Module

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness annotations that the
--   compiler chooses for a data constructor field, which may be different
--   from what is written in source code.
--   
--   Note that non-unpacked strict fields are assigned <a>DecidedLazy</a>
--   when a bang would be inappropriate, such as the field of a newtype
--   constructor and fields that have an unlifted type.
--   
--   See <a>reifyConStrictness</a> for more information.
data DecidedStrictness

-- | Field inferred to not have a bang.
DecidedLazy :: DecidedStrictness

-- | Field inferred to have a bang.
DecidedStrict :: DecidedStrictness

-- | Field inferred to be unpacked.
DecidedUnpack :: DecidedStrictness

-- | <a>SourceStrictness</a> corresponds to strictness annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness

-- | <a>SourceUnpackedness</a> corresponds to unpack annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness
data Fixity
Fixity :: Int -> FixityDirection -> Fixity

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
--   
--   Multiplicity annotations for data types are currently not supported in
--   Template Haskell (i.e. all fields represented by Template Haskell will
--   be linear).
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr Specificity] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
newtype Q a
Q :: (forall m. Quasi m => m a) -> Q a
[unQ] :: Q a -> forall m. Quasi m => m a

-- | The <a>Quote</a> class implements the minimal interface which is
--   necessary for desugaring quotations.
--   
--   <ul>
--   <li>The <tt>Monad m</tt> superclass is needed to stitch together the
--   different AST fragments.</li>
--   <li><a>newName</a> is used when desugaring binding structures such as
--   lambdas to generate fresh names.</li>
--   </ul>
--   
--   Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m
--   Exp`
--   
--   For many years the type of a quotation was fixed to be `Q Exp` but by
--   more precisely specifying the minimal interface it enables the
--   <a>Exp</a> to be extracted purely from the quotation without
--   interacting with <a>Q</a>.
class Monad m => Quote m

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--       nm1 &lt;- newName "x"
--       let nm2 = <a>mkName</a> "x"
--       return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--      )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: Quote m => String -> m Name
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> describes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | Represents an expression which has type <tt>a</tt>. Built on top of
--   <a>Exp</a>, typed expressions allow for type-safe splicing via:
--   
--   <ul>
--   <li>typed quotes, written as <tt>[|| ... ||]</tt> where <tt>...</tt>
--   is an expression; if that expression has type <tt>a</tt>, then the
--   quotation has type <tt><a>Q</a> (<a>TExp</a> a)</tt></li>
--   <li>typed splices inside of typed quotes, written as <tt>$$(...)</tt>
--   where <tt>...</tt> is an arbitrary expression of type <tt><a>Q</a>
--   (<a>TExp</a> a)</tt></li>
--   </ul>
--   
--   Traditional expression quotes and splices let us construct ill-typed
--   expressions:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [| True == $( [| "foo" |] ) |]
--   GHC.Types.True GHC.Classes.== "foo"
--   
--   &gt;&gt;&gt; GHC.Types.True GHC.Classes.== "foo"
--   &lt;interactive&gt; error:
--       • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
--       • In the second argument of ‘(==)’, namely ‘"foo"’
--         In the expression: True == "foo"
--         In an equation for ‘it’: it = True == "foo"
--   </pre>
--   
--   With typed expressions, the type error occurs when <i>constructing</i>
--   the Template Haskell expression:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [|| True == $$( [|| "foo" ||] ) ||]
--   &lt;interactive&gt; error:
--       • Couldn't match type ‘[Char]’ with ‘Bool’
--         Expected type: Q (TExp Bool)
--           Actual type: Q (TExp [Char])
--       • In the Template Haskell quotation [|| "foo" ||]
--         In the expression: [|| "foo" ||]
--         In the Template Haskell splice $$([|| "foo" ||])
--   </pre>
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
newtype TExp (a :: TYPE (r :: RuntimeRep))
TExp :: Exp -> TExp (a :: TYPE (r :: RuntimeRep))

-- | Underlying untyped Template Haskell expression
[unType] :: TExp (a :: TYPE (r :: RuntimeRep)) -> Exp
newtype Code m (a :: TYPE (r :: RuntimeRep))
Code :: m (TExp a) -> Code m (a :: TYPE (r :: RuntimeRep))

-- | Underlying monadic value
[examineCode] :: Code m (a :: TYPE (r :: RuntimeRep)) -> m (TExp a)

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
Name :: OccName -> NameFlavour -> Name
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type data T x = A x | B (T x) }
--   </pre>
TypeDataD :: Name -> [TyVarBndr ()] -> Maybe Kind -> [Con] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr ()] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr ()] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { type TypeRep :: k -&gt; Type }
--   </pre>
KiSigD :: Name -> Kind -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { default (Integer, Double) }
--   </pre>
DefaultD :: [Type] -> Dec

-- | pragmas
PragmaD :: Pragma -> Dec

-- | data families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
DataFamilyD :: Name -> [TyVarBndr ()] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | open type families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | Pattern Synonyms
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
OpaqueP :: Name -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr ()] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr ()] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr ()] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { \cases m1; m2 }
--   </pre>
LamCasesE :: [Clause] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (1,)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   TupE [Just (LitE (IntegerL 1)),Nothing]
--   </pre>
TupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (# 'c', #)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   UnboxedTupE [Just (LitE (CharL 'c')),Nothing]
--   </pre>
UnboxedTupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <tt>{ do { p &lt;- e1; e2 } }</tt> or a qualified do if the module
--   name is present
DoE :: Maybe ModName -> [Stmt] -> Exp

-- | <tt>{ mdo { x &lt;- e1 y; y &lt;- e2 x; } }</tt> or a qualified mdo if
--   the module name is present
MDoE :: Maybe ModName -> [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp

-- | <tt>{ exp.field }</tt> ( Overloaded Record Dot )
GetFieldE :: Exp -> String -> Exp

-- | <tt>(.x)</tt> or <tt>(.x.y)</tt> (Record projections)
ProjectionE :: NonEmpty String -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type <a>Addr#</a>
StringPrimL :: [Word8] -> Lit

-- | Some raw bytes, type <a>Addr#</a>:
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 @ty1 p1 p2} = e
--   </pre>
ConP :: Name -> [Type] -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data TyVarBndr flag

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> flag -> TyVarBndr flag

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> flag -> Kind -> TyVarBndr flag
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | <tt>'C'</tt>, @since 4.16.0.0
CharTyLit :: Char -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = -- | @(Eq a, Ord b)@ [Pred]

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
data Specificity

-- | <pre>
--   a
--   </pre>
SpecifiedSpec :: Specificity

-- | <pre>
--   {a}
--   </pre>
InferredSpec :: Specificity

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr () -> FamilyResultSig

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type
type BangType = (Bang, Type)
type VarBangType = (Name, Bang, Type)

-- | A location at which to attach Haddock documentation. Note that adding
--   documentation to a <a>Name</a> defined oustide of the current module
--   will cause an error.
data DocLoc

-- | At the current module's header.
ModuleDoc :: DocLoc

-- | At a declaration, not necessarily top level.
DeclDoc :: Name -> DocLoc

-- | At a specific argument of a function, indexed by its position.
ArgDoc :: Name -> Int -> DocLoc

-- | At a class or family instance.
InstDoc :: Type -> DocLoc

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>, and pick an arbitrary
--   one if multiple choices are available.
Incoherent :: Overlap

-- | <tt>Uniq</tt> is used by GHC to distinguish names from each other.
type Uniq = Integer
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: !Uniq -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: !Uniq -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs

-- | Raw bytes embedded into the binary.
--   
--   Avoid using Bytes constructor directly as it is likely to change in
--   the future. Use helpers such as <tt>mkBytes</tt> in
--   Language.Haskell.TH.Lib instead.
data Bytes
Bytes :: ForeignPtr Word8 -> Word -> Word -> Bytes

-- | Pointer to the data
[bytesPtr] :: Bytes -> ForeignPtr Word8

-- | Offset from the pointer
[bytesOffset] :: Bytes -> Word

-- | Number of bytes
[bytesSize] :: Bytes -> Word
class (MonadIO m, MonadFail m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyFixity :: Quasi m => Name -> m (Maybe Fixity)
qReifyType :: Quasi m => Name -> m Type
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qReifyConStrictness :: Quasi m => Name -> m [DecidedStrictness]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qGetPackageRoot :: Quasi m => m FilePath
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTempFile :: Quasi m => String -> m FilePath
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddForeignFilePath :: Quasi m => ForeignSrcLang -> String -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qAddCorePlugin :: Quasi m => String -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
qIsExtEnabled :: Quasi m => Extension -> m Bool
qExtsEnabled :: Quasi m => m [Extension]
qPutDoc :: Quasi m => DocLoc -> String -> m ()
qGetDoc :: Quasi m => DocLoc -> m (Maybe String)

-- | A <a>Lift</a> instance can have any of its values turned into a
--   Template Haskell expression. This is needed when a value used within a
--   Template Haskell quotation is bound outside the Oxford brackets
--   (<tt>[| ... |]</tt> or <tt>[|| ... ||]</tt>) but not at the top level.
--   As an example:
--   
--   <pre>
--   add1 :: Int -&gt; Q (TExp Int)
--   add1 x = [|| x + 1 ||]
--   </pre>
--   
--   Template Haskell has no way of knowing what value <tt>x</tt> will take
--   on at splice-time, so it requires the type of <tt>x</tt> to be an
--   instance of <a>Lift</a>.
--   
--   A <a>Lift</a> instance must satisfy <tt>$(lift x) ≡ x</tt> and
--   <tt>$$(liftTyped x) ≡ x</tt> for all <tt>x</tt>, where <tt>$(...)</tt>
--   and <tt>$$(...)</tt> are Template Haskell splices. It is additionally
--   expected that <tt><a>lift</a> x ≡ <a>unTypeQ</a> (<a>liftTyped</a>
--   x)</tt>.
--   
--   <a>Lift</a> instances can be derived automatically by use of the
--   <tt>-XDeriveLift</tt> GHC language extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveLift #-}
--   module Foo where
--   
--   import Language.Haskell.TH.Syntax
--   
--   data Bar a = Bar1 a (Bar a) | Bar2 String
--     deriving Lift
--   </pre>
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
class Lift (t :: TYPE r)

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: (Lift t, Quote m) => t -> m Exp

-- | Turn a value into a Template Haskell expression, suitable for use in a
--   splice.
lift :: (Lift t, r ~ 'BoxedRep 'Lifted, Quote m) => t -> m Exp

-- | Turn a value into a Template Haskell typed expression, suitable for
--   use in a typed splice.
liftTyped :: (Lift t, Quote m) => t -> Code m t
newtype ModName
ModName :: String -> ModName
newtype PkgName
PkgName :: String -> PkgName
newtype OccName
OccName :: String -> OccName
type CharPos = -- | Line and character position (Int, Int)

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>StrictType</a> has been
--   replaced by <a>BangType</a>.
type StrictType = BangType

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>VarStrictType</a> has
--   been replaced by <a>VarBangType</a>.
type VarStrictType = VarBangType

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a
runQ :: Quasi m => Q a -> m a

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | The location at which this computation is spliced.
location :: Q Loc

-- | <a>reify</a> looks up information about the <a>Name</a>. It will fail
--   with a compile error if the <a>Name</a> is not visible. A <a>Name</a>
--   is visible if it is imported or defined in a prior top-level
--   declaration group. See the documentation for
--   <a>newDeclarationGroup</a> for more details.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | Template Haskell is capable of reifying information about types and
--   terms defined in previous declaration groups. Top-level declaration
--   splices break up declaration groups.
--   
--   For an example, consider this code block. We define a datatype
--   <tt>X</tt> and then try to call <a>reify</a> on the datatype.
--   
--   <pre>
--   module Check where
--   
--   data X = X
--       deriving Eq
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   This code fails to compile, noting that <tt>X</tt> is not available
--   for reification at the site of <a>reify</a>. We can fix this by
--   creating a new declaration group using an empty top-level splice:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   $(pure [])
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   We provide <a>newDeclarationGroup</a> as a means of documenting this
--   behavior and providing a name for the pattern.
--   
--   Since top level splices infer the presence of the <tt>$( ... )</tt>
--   brackets, we can also write:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   newDeclarationGroup
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
newDeclarationGroup :: Q [Dec]

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyType nm</tt> attempts to find the type or kind of
--   <tt>nm</tt>. For example, <tt>reifyType 'not</tt> returns <tt>Bool
--   -&gt; Bool</tt>, and <tt>reifyType ''Bool</tt> returns <tt>Type</tt>.
--   This works even if there's no explicit signature and the type or kind
--   is inferred.
reifyType :: Name -> Q Type

-- | <tt>reifyInstances nm tys</tt> returns a list of all visible instances
--   (see below for "visible") of <tt>nm tys</tt>. That is, if <tt>nm</tt>
--   is the name of a type class, then all instances of this class at the
--   types <tt>tys</tt> are returned. Alternatively, if <tt>nm</tt> is the
--   name of a data family or type family, all instances of this family at
--   the types <tt>tys</tt> are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
--   
--   In principle, the *visible* instances are * all instances defined in a
--   prior top-level declaration group (see docs on
--   <tt>newDeclarationGroup</tt>), or * all instances defined in any
--   module transitively imported by the module being compiled
--   
--   However, actually searching all modules transitively below the one
--   being compiled is unreasonably expensive, so <tt>reifyInstances</tt>
--   will report only the instance for modules that GHC has had some cause
--   to visit during this compilation. This is a shortcoming:
--   <tt>reifyInstances</tt> might fail to report instances for a type that
--   is otherwise unusued, or instances defined in a different component.
--   You can work around this shortcoming by explicitly importing the
--   modules whose instances you want to be visible. GHC issue
--   <a>#20529</a> has some discussion around this.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
--   
--   If you're confused by an instance not being visible despite being
--   defined in the same module and above the splice in question, see the
--   docs for <a>newDeclarationGroup</a> for a possible explanation.
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters (both visible and invisible) of the tycon <tt>nm</tt>.
--   Fails if <tt>nm</tt> cannot be found or is not a tycon. The returned
--   list should never contain <a>InferR</a>.
--   
--   An invisible parameter to a tycon is often a kind parameter. For
--   example, if we have
--   
--   <pre>
--   type Proxy :: forall k. k -&gt; Type
--   data Proxy a = MkProxy
--   </pre>
--   
--   and <tt>reifyRoles Proxy</tt>, we will get <tt>[<a>NominalR</a>,
--   <a>PhantomR</a>]</tt>. The <a>NominalR</a> is the role of the
--   invisible <tt>k</tt> parameter. Kind parameters are always nominal.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | Extract the untyped representation from the typed representation
unTypeCode :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => Code m a -> m Exp

-- | Unsafely convert an untyped code representation into a typed code
--   representation.
unsafeCodeCoerce :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => m Exp -> Code m a

-- | Modify the ambient monad used during code generation. For example, you
--   can use <a>hoistCode</a> to handle a state effect: <tt> handleState ::
--   Code (StateT Int Q) a -&gt; Code Q a handleState = hoistCode (flip
--   runState 0) </tt>
hoistCode :: forall m n (r :: RuntimeRep) (a :: TYPE r). Monad m => (forall x. m x -> n x) -> Code m a -> Code n a

-- | Variant of (&gt;&gt;=) which allows effectful computations to be
--   injected into code generation.
bindCode :: forall m a (r :: RuntimeRep) (b :: TYPE r). Monad m => m a -> (a -> Code m b) -> Code m b

-- | Variant of (&gt;&gt;) which allows effectful computations to be
--   injected into code generation.
bindCode_ :: forall m a (r :: RuntimeRep) (b :: TYPE r). Monad m => m a -> Code m b -> Code m b

-- | A useful combinator for embedding monadic actions into <a>Code</a>
--   <tt> myCode :: ... =&gt; Code m a myCode = joinCode $ do x &lt;-
--   someSideEffect return (makeCodeWith x) </tt>
joinCode :: forall m (r :: RuntimeRep) (a :: TYPE r). Monad m => m (Code m a) -> Code m a

-- | Lift a monadic action producing code into the typed <a>Code</a>
--   representation
liftCode :: forall (r :: RuntimeRep) (a :: TYPE r) m. m (TExp a) -> Code m a

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Add Haddock documentation to the specified location. This will
--   overwrite any documentation at the location if it already exists. This
--   will reify the specified name, so it must be in scope when you call
--   it. If you want to add documentation to something that you are
--   currently splicing, you can use <a>addModFinalizer</a> e.g.
--   
--   <pre>
--   do
--     let nm = mkName "x"
--     addModFinalizer $ putDoc (DeclDoc nm) "Hello"
--     [d| $(varP nm) = 42 |]
--   </pre>
--   
--   The helper functions <tt>withDecDoc</tt> and <tt>withDecsDoc</tt> will
--   do this for you, as will the <tt>funD_doc</tt> and other <tt>_doc</tt>
--   combinators. You most likely want to have the <tt>-haddock</tt> flag
--   turned on when using this. Adding documentation to anything outside of
--   the current module will cause an error.
putDoc :: DocLoc -> String -> Q ()

-- | Retreives the Haddock documentation at the specified location, if one
--   exists. It can be used to read documentation on things defined outside
--   of the current module, provided that those modules were compiled with
--   the <tt>-haddock</tt> flag.
getDoc :: DocLoc -> Q (Maybe String)
showName' :: NameIs -> Name -> String

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: forall m a k q. (Quote m, Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data b => b -> Maybe (m q)) -> a -> m q

-- | <a>dataToExpQ</a> converts a value to a <a>Exp</a> representation of
--   the same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Exp)) -> a -> m Exp

-- | <a>dataToPatQ</a> converts a value to a <a>Pat</a> representation of
--   the same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Pat)) -> a -> m Pat
newNameIO :: String -> IO Name
badIO :: String -> IO a
counter :: IORef Uniq

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Discard the type annotation and produce a plain Template Haskell
--   expression
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
unTypeQ :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => m (TExp a) -> m Exp

-- | Annotate the Template Haskell expression with a type
--   
--   This is unsafe because GHC cannot check for you that the expression
--   really does have the type you claim it has.
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
unsafeTExpCoerce :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => m Exp -> m (TExp a)
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Get the package root for the current package which is being compiled.
--   This can be set explicitly with the -package-root flag but is normally
--   just the current working directory.
--   
--   The motivation for this flag is to provide a principled means to
--   remove the assumption from splices that they will be executed in the
--   directory where the cabal file resides. Projects such as
--   haskell-language-server can't and don't change directory when
--   compiling files but instead set the -package-root flag appropiately.
getPackageRoot :: Q FilePath

-- | The input is a filepath, which if relative is offset by the package
--   root.
makeRelativeToProject :: FilePath -> Q FilePath

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | Obtain a temporary file path with the given suffix. The compiler will
--   delete this file after compilation.
addTempFile :: String -> Q FilePath

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()


-- | <i>Deprecated: Use <a>addForeignSource</a> instead</i>
addForeignFile :: ForeignSrcLang -> String -> Q ()

-- | Emit a foreign file which will be compiled and linked to the object
--   for the current module. Currently only languages that can be compiled
--   with the C compiler are supported, and the flags passed as part of
--   -optc will be also applied to the C compiler invocation that will
--   compile them.
--   
--   Note that for non-C languages (for example C++) <tt>extern
--   <a>C</a></tt> directives must be used to get symbols that we can
--   access from Haskell.
--   
--   To get better errors, it is recommended to use #line pragmas when
--   emitting C files, e.g.
--   
--   <pre>
--   {-# LANGUAGE CPP #-}
--   ...
--   addForeignSource LangC $ unlines
--     [ "#line " ++ show (819 + 1) ++ " " ++ show "libraries/template-haskell/Language/Haskell/TH/Syntax.hs"
--     , ...
--     ]
--   </pre>
addForeignSource :: ForeignSrcLang -> String -> Q ()

-- | Same as <a>addForeignSource</a>, but expects to receive a path
--   pointing to the foreign file instead of a <a>String</a> of its
--   contents. Consider using this in conjunction with <a>addTempFile</a>.
--   
--   This is a good alternative to <a>addForeignSource</a> when you are
--   trying to directly link in an object file.
addForeignFilePath :: ForeignSrcLang -> FilePath -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
--   
--   The finalizer is given the local type environment at the splice point.
--   Thus <a>reify</a> is able to find the local definitions when executed
--   inside the finalizer.
addModFinalizer :: Q () -> Q ()

-- | Adds a core plugin to the compilation pipeline.
--   
--   <tt>addCorePlugin m</tt> has almost the same effect as passing
--   <tt>-fplugin=m</tt> to ghc in the command line. The major difference
--   is that the plugin module <tt>m</tt> must not belong to the current
--   package. When TH executes, it is too late to tell the compiler that we
--   needed to compile first a plugin module in the current package.
addCorePlugin :: String -> Q ()

-- | Get state from the <a>Q</a> monad. Note that the state is local to the
--   Haskell module in which the Template Haskell expression is executed.
getQ :: Typeable a => Q (Maybe a)

-- | Replace the state in the <a>Q</a> monad. Note that the state is local
--   to the Haskell module in which the Template Haskell expression is
--   executed.
putQ :: Typeable a => a -> Q ()
sequenceQ :: forall m. Monad m => forall a. [m a] -> m [a]
trueName :: Name
falseName :: Name
addrToByteArrayName :: Name
mkNameG_v :: String -> String -> String -> Name
addrToByteArray :: Int -> Addr# -> ByteArray
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
liftString :: Quote m => String -> m Exp
nonemptyName :: Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
oneName :: Name
manyName :: Name
mkOccName :: String -> OccName
mkPkgName :: String -> PkgName
mkModName :: String -> ModName
mkNameG_d :: String -> String -> String -> Name
showName :: Name -> String

-- | <a>liftData</a> is a variant of <a>lift</a> in the <a>Lift</a> type
--   class which works for any type with a <a>Data</a> instance.
liftData :: (Quote m, Data a) => a -> m Exp
modString :: ModName -> String
pkgString :: PkgName -> String
occString :: OccName -> String
thenCmp :: Ordering -> Ordering -> Ordering

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Only used internally
mkNameQ :: String -> String -> Name
mkNameS :: String -> Name
mkNameG_tc :: String -> String -> String -> Name
mk_tup_name :: Int -> NameSpace -> Bool -> Name
eqBytes :: Bytes -> Bytes -> Bool
compareBytes :: Bytes -> Bytes -> Ordering
memcmp :: Ptr a -> Ptr b -> CSize -> IO CInt
cmpEq :: Ordering -> Bool

-- | Foreign formats supported by GHC via TH
data () => ForeignSrcLang

-- | C
LangC :: ForeignSrcLang

-- | C++
LangCxx :: ForeignSrcLang

-- | Objective C
LangObjc :: ForeignSrcLang

-- | Objective C++
LangObjcxx :: ForeignSrcLang

-- | Assembly language (.s)
LangAsm :: ForeignSrcLang

-- | JavaScript
LangJs :: ForeignSrcLang

-- | Object (.o)
RawObject :: ForeignSrcLang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModName
instance Data.Data.Data Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModName
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PkgName
instance Data.Data.Data Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PkgName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PkgName
instance GHC.Show.Show Language.Haskell.TH.Syntax.PkgName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Module
instance Data.Data.Data Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Module
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Module
instance GHC.Show.Show Language.Haskell.TH.Syntax.Module
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.OccName
instance Data.Data.Data Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.OccName
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.OccName
instance GHC.Show.Show Language.Haskell.TH.Syntax.OccName
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameSpace
instance Data.Data.Data Language.Haskell.TH.Syntax.NameSpace
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameSpace
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameSpace
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Show.Show Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.NameFlavour
instance Data.Data.Data Language.Haskell.TH.Syntax.NameFlavour
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Name
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Name
instance Data.Data.Data Language.Haskell.TH.Syntax.Name
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Loc
instance Data.Data.Data Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Loc
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Loc
instance GHC.Show.Show Language.Haskell.TH.Syntax.Loc
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.ModuleInfo
instance Data.Data.Data Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Show.Show Language.Haskell.TH.Syntax.ModuleInfo
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FixityDirection
instance Data.Data.Data Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Show.Show Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FixityDirection
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Fixity
instance Data.Data.Data Language.Haskell.TH.Syntax.Fixity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Fixity
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Fixity
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bytes
instance Data.Data.Data Language.Haskell.TH.Syntax.Bytes
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Lit
instance Data.Data.Data Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Lit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Lit
instance GHC.Show.Show Language.Haskell.TH.Syntax.Lit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Overlap
instance Data.Data.Data Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Overlap
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Overlap
instance GHC.Show.Show Language.Haskell.TH.Syntax.Overlap
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FunDep
instance Data.Data.Data Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FunDep
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FunDep
instance GHC.Show.Show Language.Haskell.TH.Syntax.FunDep
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Callconv
instance Data.Data.Data Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Callconv
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Callconv
instance GHC.Show.Show Language.Haskell.TH.Syntax.Callconv
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Safety
instance Data.Data.Data Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Safety
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Safety
instance GHC.Show.Show Language.Haskell.TH.Syntax.Safety
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Inline
instance Data.Data.Data Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Inline
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Inline
instance GHC.Show.Show Language.Haskell.TH.Syntax.Inline
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleMatch
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleMatch
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Phases
instance Data.Data.Data Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Phases
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Phases
instance GHC.Show.Show Language.Haskell.TH.Syntax.Phases
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnTarget
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnTarget
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceUnpackedness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceUnpackedness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.SourceStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.SourceStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DecidedStrictness
instance Data.Data.Data Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Show.Show Language.Haskell.TH.Syntax.DecidedStrictness
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Bang
instance Data.Data.Data Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bang
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bang
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bang
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynArgs
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynArgs
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Specificity
instance Data.Data.Data Language.Haskell.TH.Syntax.Specificity
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Specificity
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Specificity
instance GHC.Show.Show Language.Haskell.TH.Syntax.Specificity
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.InjectivityAnn
instance Data.Data.Data Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Show.Show Language.Haskell.TH.Syntax.InjectivityAnn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TyLit
instance Data.Data.Data Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TyLit
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TyLit
instance GHC.Show.Show Language.Haskell.TH.Syntax.TyLit
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Role
instance Data.Data.Data Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Role
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Role
instance GHC.Show.Show Language.Haskell.TH.Syntax.Role
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.AnnLookup
instance Data.Data.Data Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Show.Show Language.Haskell.TH.Syntax.AnnLookup
instance GHC.Base.Functor Language.Haskell.TH.Syntax.TyVarBndr
instance GHC.Generics.Generic (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance Data.Data.Data flag => Data.Data.Data (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance GHC.Classes.Ord flag => GHC.Classes.Ord (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance GHC.Classes.Eq flag => GHC.Classes.Eq (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance GHC.Show.Show flag => GHC.Show.Show (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Type
instance Data.Data.Data Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Type
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Type
instance GHC.Show.Show Language.Haskell.TH.Syntax.Type
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.FamilyResultSig
instance Data.Data.Data Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Show.Show Language.Haskell.TH.Syntax.FamilyResultSig
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TypeFamilyHead
instance Data.Data.Data Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Show.Show Language.Haskell.TH.Syntax.TypeFamilyHead
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Con
instance Data.Data.Data Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Con
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Con
instance GHC.Show.Show Language.Haskell.TH.Syntax.Con
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.RuleBndr
instance Data.Data.Data Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Show.Show Language.Haskell.TH.Syntax.RuleBndr
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Foreign
instance Data.Data.Data Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Foreign
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Foreign
instance GHC.Show.Show Language.Haskell.TH.Syntax.Foreign
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.TySynEqn
instance Data.Data.Data Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Show.Show Language.Haskell.TH.Syntax.TySynEqn
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivStrategy
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivStrategy
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DerivClause
instance Data.Data.Data Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DerivClause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DerivClause
instance GHC.Show.Show Language.Haskell.TH.Syntax.DerivClause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pragma
instance Data.Data.Data Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pragma
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pragma
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pragma
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Pat
instance Data.Data.Data Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Pat
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Pat
instance GHC.Show.Show Language.Haskell.TH.Syntax.Pat
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Match
instance Data.Data.Data Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Match
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Match
instance GHC.Show.Show Language.Haskell.TH.Syntax.Match
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Range
instance Data.Data.Data Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Range
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Range
instance GHC.Show.Show Language.Haskell.TH.Syntax.Range
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Exp
instance Data.Data.Data Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Exp
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Exp
instance GHC.Show.Show Language.Haskell.TH.Syntax.Exp
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Stmt
instance Data.Data.Data Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Stmt
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Stmt
instance GHC.Show.Show Language.Haskell.TH.Syntax.Stmt
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Guard
instance Data.Data.Data Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Guard
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Guard
instance GHC.Show.Show Language.Haskell.TH.Syntax.Guard
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Body
instance Data.Data.Data Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Body
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Body
instance GHC.Show.Show Language.Haskell.TH.Syntax.Body
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Clause
instance Data.Data.Data Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Clause
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Clause
instance GHC.Show.Show Language.Haskell.TH.Syntax.Clause
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.PatSynDir
instance Data.Data.Data Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Show.Show Language.Haskell.TH.Syntax.PatSynDir
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Dec
instance Data.Data.Data Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Dec
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Dec
instance GHC.Show.Show Language.Haskell.TH.Syntax.Dec
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.Info
instance Data.Data.Data Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Info
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Info
instance GHC.Show.Show Language.Haskell.TH.Syntax.Info
instance GHC.Generics.Generic Language.Haskell.TH.Syntax.DocLoc
instance Data.Data.Data Language.Haskell.TH.Syntax.DocLoc
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.DocLoc
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.DocLoc
instance GHC.Show.Show Language.Haskell.TH.Syntax.DocLoc
instance Language.Haskell.TH.Syntax.Quasi GHC.Types.IO
instance GHC.Base.Monad Language.Haskell.TH.Syntax.Q
instance Control.Monad.Fail.MonadFail Language.Haskell.TH.Syntax.Q
instance GHC.Base.Functor Language.Haskell.TH.Syntax.Q
instance GHC.Base.Applicative Language.Haskell.TH.Syntax.Q
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Language.Haskell.TH.Syntax.Q a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Language.Haskell.TH.Syntax.Q a)
instance Control.Monad.Fix.MonadFix Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Quote Language.Haskell.TH.Syntax.Q
instance Control.Monad.IO.Class.MonadIO Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Quasi Language.Haskell.TH.Syntax.Q
instance Language.Haskell.TH.Syntax.Lift GHC.Num.Integer.Integer
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Int
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Int#
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int8
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int16
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int32
instance Language.Haskell.TH.Syntax.Lift GHC.Int.Int64
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Word#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Word
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word8
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word16
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word32
instance Language.Haskell.TH.Syntax.Lift GHC.Word.Word64
instance Language.Haskell.TH.Syntax.Lift GHC.Num.Natural.Natural
instance GHC.Real.Integral a => Language.Haskell.TH.Syntax.Lift (GHC.Real.Ratio a)
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Float
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Float#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Double
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Double#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Char
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Char#
instance Language.Haskell.TH.Syntax.Lift GHC.Types.Bool
instance Language.Haskell.TH.Syntax.Lift GHC.Prim.Addr#
instance Language.Haskell.TH.Syntax.Lift Data.Array.Byte.ByteArray
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Maybe.Maybe a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (Data.Either.Either a b)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift [a]
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (GHC.Base.NonEmpty a)
instance Language.Haskell.TH.Syntax.Lift GHC.Base.Void
instance Language.Haskell.TH.Syntax.Lift ()
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (a, b)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (a, b, c)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (a, b, c, d)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (a, b, c, d, e, f, g)
instance Language.Haskell.TH.Syntax.Lift (# #)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (# a #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (# a, b #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (# a, b, c #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e, f #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (# a, b, c, d, e, f, g #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b) => Language.Haskell.TH.Syntax.Lift (# a | b #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c) => Language.Haskell.TH.Syntax.Lift (# a | b | c #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e | f #)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift b, Language.Haskell.TH.Syntax.Lift c, Language.Haskell.TH.Syntax.Lift d, Language.Haskell.TH.Syntax.Lift e, Language.Haskell.TH.Syntax.Lift f, Language.Haskell.TH.Syntax.Lift g) => Language.Haskell.TH.Syntax.Lift (# a | b | c | d | e | f | g #)
instance GHC.Show.Show Language.Haskell.TH.Syntax.Bytes
instance GHC.Classes.Eq Language.Haskell.TH.Syntax.Bytes
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Bytes
instance Language.Haskell.TH.Syntax.Quote GHC.Types.IO
instance GHC.Classes.Ord Language.Haskell.TH.Syntax.Name
instance GHC.Show.Show Language.Haskell.TH.Syntax.Name


-- | Template Haskell supports quasiquoting, which permits users to
--   construct program fragments by directly writing concrete syntax. A
--   quasiquoter is essentially a function with takes a string to a
--   Template Haskell AST. This module defines the <a>QuasiQuoter</a>
--   datatype, which specifies a quasiquoter <tt>q</tt> which can be
--   invoked using the syntax <tt>[q| ... string to parse ... |]</tt> when
--   the <tt>QuasiQuotes</tt> language extension is enabled, and some
--   utility functions for manipulating quasiquoters. Nota bene: this
--   package does not define any parsers, that is up to you.
module Language.Haskell.TH.Quote

-- | The <a>QuasiQuoter</a> type, a value <tt>q</tt> of this type can be
--   used in the syntax <tt>[q| ... string to parse ...|]</tt>. In fact,
--   for convenience, a <a>QuasiQuoter</a> actually defines multiple
--   quasiquoters to be used in different splice contexts; if you are only
--   interested in defining a quasiquoter to be used for expressions, you
--   would define a <a>QuasiQuoter</a> with only <a>quoteExp</a>, and leave
--   the other fields stubbed out with errors.
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter

-- | Quasi-quoter for expressions, invoked by quotes like <tt>lhs =
--   $[q|...]</tt>
[quoteExp] :: QuasiQuoter -> String -> Q Exp

-- | Quasi-quoter for patterns, invoked by quotes like <tt>f $[q|...] =
--   rhs</tt>
[quotePat] :: QuasiQuoter -> String -> Q Pat

-- | Quasi-quoter for types, invoked by quotes like <tt>f :: $[q|...]</tt>
[quoteType] :: QuasiQuoter -> String -> Q Type

-- | Quasi-quoter for declarations, invoked by top-level quotes
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f|foo.s|] will take input from file
--   <tt>"foo.s"</tt> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter

-- | <a>dataToQa</a> is an internal utility function for constructing
--   generic conversion functions from types with <a>Data</a> instances to
--   various quasi-quoting representations. See the source of
--   <a>dataToExpQ</a> and <a>dataToPatQ</a> for two example usages:
--   <tt>mkCon</tt>, <tt>mkLit</tt> and <tt>appQ</tt> are overloadable to
--   account for different syntax for expressions and patterns;
--   <tt>antiQ</tt> allows you to override type-specific cases, a common
--   usage is just <tt>const Nothing</tt>, which results in no overloading.
dataToQa :: forall m a k q. (Quote m, Data a) => (Name -> k) -> (Lit -> m q) -> (k -> [m q] -> m q) -> (forall b. Data b => b -> Maybe (m q)) -> a -> m q

-- | <a>dataToExpQ</a> converts a value to a <a>Exp</a> representation of
--   the same value, in the SYB style. It is generalized to take a function
--   override type-specific cases; see <a>liftData</a> for a more commonly
--   used variant.
dataToExpQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Exp)) -> a -> m Exp

-- | <a>dataToPatQ</a> converts a value to a <a>Pat</a> representation of
--   the same value, in the SYB style. It takes a function to handle
--   type-specific cases, alternatively, pass <tt>const Nothing</tt> to get
--   default behavior.
dataToPatQ :: (Quote m, Data a) => (forall b. Data b => b -> Maybe (m Pat)) -> a -> m Pat


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a
empty :: Doc
semi :: Doc
comma :: Doc
colon :: Doc
dcolon :: Doc
space :: Doc
equals :: Doc
arrow :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc
(<>) :: Doc -> Doc -> Doc
infixl 6 <>
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>
hcat :: [Doc] -> Doc
hsep :: [Doc] -> Doc
($$) :: Doc -> Doc -> Doc
infixl 5 $$
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$
vcat :: [Doc] -> Doc
sep :: [Doc] -> Doc
cat :: [Doc] -> Doc
fsep :: [Doc] -> Doc
fcat :: [Doc] -> Doc
nest :: Int -> Doc -> Doc
hang :: Doc -> Int -> Doc -> Doc
punctuate :: Doc -> [Doc] -> [Doc]
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance GHC.Show.Show Language.Haskell.TH.PprLib.Doc
instance GHC.Base.Functor Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Applicative Language.Haskell.TH.PprLib.PprM
instance GHC.Base.Monad Language.Haskell.TH.PprLib.PprM


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
opPrec :: Precedence
unopPrec :: Precedence
funPrec :: Precedence
qualPrec :: Precedence
sigPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc

-- | Pretty prints a pattern synonym type signature
pprPatSynSig :: Name -> PatSynType -> Doc

-- | Pretty prints a pattern synonym's type; follows the usual conventions
--   to print a pattern synonym type compactly, yet unambiguously. See the
--   note on <a>PatSynType</a> and the section on pattern synonyms in the
--   GHC user's guide for more information.
pprPatSynType :: PatSynType -> Doc
pprPrefixOcc :: Name -> Doc
isSymOcc :: Name -> Bool
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprMatchPat :: Pat -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprClause :: Bool -> Clause -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_deriv_strategy :: DerivStrategy -> Doc
ppr_overlap :: Overlap -> Doc
ppr_data :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> [Con] -> [DerivClause] -> Doc
ppr_newtype :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> Con -> [DerivClause] -> Doc
ppr_type_data :: Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> [Con] -> [DerivClause] -> Doc
ppr_typedef :: String -> Doc -> Cxt -> Maybe Name -> Doc -> Maybe Kind -> [Con] -> [DerivClause] -> Doc
ppr_deriv_clause :: DerivClause -> Doc
ppr_tySyn :: Doc -> Maybe Name -> Doc -> Type -> Doc
ppr_tf_head :: TypeFamilyHead -> Doc
ppr_bndrs :: PprFlag flag => Maybe [TyVarBndr flag] -> Doc
commaSepApplied :: [Name] -> Doc
pprForall :: [TyVarBndr Specificity] -> Cxt -> Doc
pprForallVis :: [TyVarBndr ()] -> Cxt -> Doc
pprForall' :: PprFlag flag => ForallVisFlag -> [TyVarBndr flag] -> Cxt -> Doc
pprRecFields :: [(Name, Strict, Type)] -> Type -> Doc
pprGadtRHS :: [(Strict, Type)] -> Type -> Doc
pprVarBangType :: VarBangType -> Doc
pprBangType :: BangType -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>pprVarBangType</a> instead.</i>
pprVarStrictType :: (Name, Strict, Type) -> Doc

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>pprBangType</a> instead.</i>
pprStrictType :: (Strict, Type) -> Doc
pprType :: Precedence -> Type -> Doc
pprParendType :: Type -> Doc
pprInfixT :: Precedence -> Type -> Doc
pprParendTypeArg :: TypeArg -> Doc
isStarT :: Type -> Bool
pprTyApp :: Precedence -> (Type, [TypeArg]) -> Doc
fromTANormal :: TypeArg -> Maybe Type
pprFunArgType :: Type -> Doc
data ForallVisFlag
ForallVis :: ForallVisFlag
ForallInvis :: ForallVisFlag
data TypeArg
TANormal :: Type -> TypeArg
TyArg :: Kind -> TypeArg
split :: Type -> (Type, [TypeArg])
pprTyLit :: TyLit -> Doc
class PprFlag flag
pprTyVarBndr :: PprFlag flag => TyVarBndr flag -> Doc
pprCxt :: Cxt -> Doc
ppr_cxt_preds :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
sepWith :: Doc -> (a -> Doc) -> [a] -> Doc
commaSep :: Ppr a => [a] -> Doc
commaSepWith :: (a -> Doc) -> [a] -> Doc
semiSep :: Ppr a => [a] -> Doc
semiSepWith :: (a -> Doc) -> [a] -> Doc
unboxedSumBars :: Doc -> SumAlt -> SumArity -> Doc
bar :: Doc
instance GHC.Show.Show Language.Haskell.TH.Ppr.ForallVisFlag
instance Language.Haskell.TH.Ppr.PprFlag ()
instance Language.Haskell.TH.Ppr.PprFlag Language.Haskell.TH.Syntax.Specificity
instance Language.Haskell.TH.Ppr.PprFlag flag => Language.Haskell.TH.Ppr.Ppr (Language.Haskell.TH.Syntax.TyVarBndr flag)
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Ppr.TypeArg
instance Language.Haskell.TH.Ppr.Ppr a => Language.Haskell.TH.Ppr.Ppr [a]
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Info
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Module
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.ModuleInfo
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Exp
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Stmt
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Match
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Lit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pat
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Dec
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FunDep
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.FamilyResultSig
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.InjectivityAnn
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Pragma
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Inline
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleMatch
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Phases
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.RuleBndr
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Clause
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynDir
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.PatSynArgs
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Bang
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceUnpackedness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.SourceStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.DecidedStrictness
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.TyLit
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Role
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Range
instance Language.Haskell.TH.Ppr.Ppr Language.Haskell.TH.Syntax.Loc


-- | Language.Haskell.TH.Lib.Internal exposes some additional functionality
--   that is used internally in GHC's integration with Template Haskell.
--   This is not a part of the public API, and as such, there are no API
--   guarantees for this module from version to version.
module Language.Haskell.TH.Lib.Internal

-- | Representation-polymorphic since <i>template-haskell-2.17.0.0</i>.
type TExpQ a = Q (TExp a)
type CodeQ = Code Q
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type Decs = [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type Role = Role
type InjectivityAnn = InjectivityAnn
type TyVarBndrUnit = TyVarBndr ()
type TyVarBndrSpec = TyVarBndr Specificity
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
charPrimL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
bytesPrimL :: Bytes -> Lit
rationalL :: Rational -> Lit
litP :: Quote m => Lit -> m Pat
varP :: Quote m => Name -> m Pat
tupP :: Quote m => [m Pat] -> m Pat
unboxedTupP :: Quote m => [m Pat] -> m Pat
unboxedSumP :: Quote m => m Pat -> SumAlt -> SumArity -> m Pat
conP :: Quote m => Name -> [m Type] -> [m Pat] -> m Pat
infixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
uInfixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
parensP :: Quote m => m Pat -> m Pat
tildeP :: Quote m => m Pat -> m Pat
bangP :: Quote m => m Pat -> m Pat
asP :: Quote m => Name -> m Pat -> m Pat
wildP :: Quote m => m Pat
recP :: Quote m => Name -> [m FieldPat] -> m Pat
listP :: Quote m => [m Pat] -> m Pat
sigP :: Quote m => m Pat -> m Type -> m Pat
viewP :: Quote m => m Exp -> m Pat -> m Pat
fieldPat :: Quote m => Name -> m Pat -> m FieldPat
bindS :: Quote m => m Pat -> m Exp -> m Stmt
letS :: Quote m => [m Dec] -> m Stmt
noBindS :: Quote m => m Exp -> m Stmt
parS :: Quote m => [[m Stmt]] -> m Stmt
recS :: Quote m => [m Stmt] -> m Stmt
fromR :: Quote m => m Exp -> m Range
fromThenR :: Quote m => m Exp -> m Exp -> m Range
fromToR :: Quote m => m Exp -> m Exp -> m Range
fromThenToR :: Quote m => m Exp -> m Exp -> m Exp -> m Range
normalB :: Quote m => m Exp -> m Body
guardedB :: Quote m => [m (Guard, Exp)] -> m Body
normalG :: Quote m => m Exp -> m Guard
normalGE :: Quote m => m Exp -> m Exp -> m (Guard, Exp)
patG :: Quote m => [m Stmt] -> m Guard
patGE :: Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)

-- | Use with <a>caseE</a>
match :: Quote m => m Pat -> m Body -> [m Dec] -> m Match

-- | Use with <a>funD</a>
clause :: Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause

-- | Dynamically binding a variable (unhygenic)
dyn :: Quote m => String -> m Exp
varE :: Quote m => Name -> m Exp
conE :: Quote m => Name -> m Exp
litE :: Quote m => Lit -> m Exp
appE :: Quote m => m Exp -> m Exp -> m Exp
appTypeE :: Quote m => m Exp -> m Type -> m Exp
parensE :: Quote m => m Exp -> m Exp
uInfixE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
infixE :: Quote m => Maybe (m Exp) -> m Exp -> Maybe (m Exp) -> m Exp
infixApp :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
sectionL :: Quote m => m Exp -> m Exp -> m Exp
sectionR :: Quote m => m Exp -> m Exp -> m Exp
lamE :: Quote m => [m Pat] -> m Exp -> m Exp

-- | Single-arg lambda
lam1E :: Quote m => m Pat -> m Exp -> m Exp

-- | Lambda-case (<tt>case</tt>)
lamCaseE :: Quote m => [m Match] -> m Exp

-- | Lambda-cases (<tt>cases</tt>)
lamCasesE :: Quote m => [m Clause] -> m Exp
tupE :: Quote m => [Maybe (m Exp)] -> m Exp
unboxedTupE :: Quote m => [Maybe (m Exp)] -> m Exp
unboxedSumE :: Quote m => m Exp -> SumAlt -> SumArity -> m Exp
condE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
multiIfE :: Quote m => [m (Guard, Exp)] -> m Exp
letE :: Quote m => [m Dec] -> m Exp -> m Exp
caseE :: Quote m => m Exp -> [m Match] -> m Exp
doE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
mdoE :: Quote m => Maybe ModName -> [m Stmt] -> m Exp
compE :: Quote m => [m Stmt] -> m Exp
arithSeqE :: Quote m => m Range -> m Exp
listE :: Quote m => [m Exp] -> m Exp
sigE :: Quote m => m Exp -> m Type -> m Exp
recConE :: Quote m => Name -> [m (Name, Exp)] -> m Exp
recUpdE :: Quote m => m Exp -> [m (Name, Exp)] -> m Exp
stringE :: Quote m => String -> m Exp
fieldExp :: Quote m => Name -> m Exp -> m (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: Quote m => m Exp -> m Exp
unboundVarE :: Quote m => Name -> m Exp
labelE :: Quote m => String -> m Exp
implicitParamVarE :: Quote m => String -> m Exp
getFieldE :: Quote m => m Exp -> String -> m Exp
projectionE :: Quote m => NonEmpty String -> m Exp
fromE :: Quote m => m Exp -> m Exp
fromThenE :: Quote m => m Exp -> m Exp -> m Exp
fromToE :: Quote m => m Exp -> m Exp -> m Exp
fromThenToE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
valD :: Quote m => m Pat -> m Body -> [m Dec] -> m Dec
funD :: Quote m => Name -> [m Clause] -> m Dec
tySynD :: Quote m => Name -> [m (TyVarBndr ())] -> m Type -> m Dec
dataD :: Quote m => m Cxt -> Name -> [m (TyVarBndr ())] -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
newtypeD :: Quote m => m Cxt -> Name -> [m (TyVarBndr ())] -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
typeDataD :: Quote m => Name -> [m (TyVarBndr ())] -> Maybe (m Kind) -> [m Con] -> m Dec
classD :: Quote m => m Cxt -> Name -> [m (TyVarBndr ())] -> [FunDep] -> [m Dec] -> m Dec
instanceD :: Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
instanceWithOverlapD :: Quote m => Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec
sigD :: Quote m => Name -> m Type -> m Dec
kiSigD :: Quote m => Name -> m Kind -> m Dec
forImpD :: Quote m => Callconv -> Safety -> String -> Name -> m Type -> m Dec
infixLD :: Quote m => Int -> Name -> m Dec
infixRD :: Quote m => Int -> Name -> m Dec
infixND :: Quote m => Int -> Name -> m Dec
defaultD :: Quote m => [m Type] -> m Dec
pragInlD :: Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
pragOpaqueD :: Quote m => Name -> m Dec
pragSpecD :: Quote m => Name -> m Type -> Phases -> m Dec
pragSpecInlD :: Quote m => Name -> m Type -> Inline -> Phases -> m Dec
pragSpecInstD :: Quote m => m Type -> m Dec
pragRuleD :: Quote m => String -> Maybe [m (TyVarBndr ())] -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
pragAnnD :: Quote m => AnnTarget -> m Exp -> m Dec
pragLineD :: Quote m => Int -> String -> m Dec
pragCompleteD :: Quote m => [Name] -> Maybe Name -> m Dec
dataInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> [m Con] -> [m DerivClause] -> m Dec
newtypeInstD :: Quote m => m Cxt -> Maybe [m (TyVarBndr ())] -> m Type -> Maybe (m Kind) -> m Con -> [m DerivClause] -> m Dec
tySynInstD :: Quote m => m TySynEqn -> m Dec
dataFamilyD :: Quote m => Name -> [m (TyVarBndr ())] -> Maybe (m Kind) -> m Dec
openTypeFamilyD :: Quote m => Name -> [m (TyVarBndr ())] -> m FamilyResultSig -> Maybe InjectivityAnn -> m Dec
closedTypeFamilyD :: Quote m => Name -> [m (TyVarBndr ())] -> m FamilyResultSig -> Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
roleAnnotD :: Quote m => Name -> [Role] -> m Dec
standaloneDerivD :: Quote m => m Cxt -> m Type -> m Dec
standaloneDerivWithStrategyD :: Quote m => Maybe (m DerivStrategy) -> m Cxt -> m Type -> m Dec
defaultSigD :: Quote m => Name -> m Type -> m Dec

-- | Pattern synonym declaration
patSynD :: Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec

-- | Pattern synonym type signature
patSynSigD :: Quote m => Name -> m Type -> m Dec

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: Quote m => String -> m Exp -> m Dec
tySynEqn :: Quote m => Maybe [m (TyVarBndr ())] -> m Type -> m Type -> m TySynEqn
cxt :: Quote m => [m Pred] -> m Cxt
derivClause :: Quote m => Maybe (m DerivStrategy) -> [m Pred] -> m DerivClause
stockStrategy :: Quote m => m DerivStrategy
anyclassStrategy :: Quote m => m DerivStrategy
newtypeStrategy :: Quote m => m DerivStrategy
viaStrategy :: Quote m => m Type -> m DerivStrategy
normalC :: Quote m => Name -> [m BangType] -> m Con
recC :: Quote m => Name -> [m VarBangType] -> m Con
infixC :: Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
forallC :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Con -> m Con
gadtC :: Quote m => [Name] -> [m StrictType] -> m Type -> m Con
recGadtC :: Quote m => [Name] -> [m VarStrictType] -> m Type -> m Con
forallT :: Quote m => [m (TyVarBndr Specificity)] -> m Cxt -> m Type -> m Type
forallVisT :: Quote m => [m (TyVarBndr ())] -> m Type -> m Type
varT :: Quote m => Name -> m Type
conT :: Quote m => Name -> m Type
infixT :: Quote m => m Type -> Name -> m Type -> m Type
uInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedUInfixT :: Quote m => m Type -> Name -> m Type -> m Type
parensT :: Quote m => m Type -> m Type
appT :: Quote m => m Type -> m Type -> m Type
appKindT :: Quote m => m Type -> m Kind -> m Type
arrowT :: Quote m => m Type
mulArrowT :: Quote m => m Type
listT :: Quote m => m Type
litT :: Quote m => m TyLit -> m Type
tupleT :: Quote m => Int -> m Type
unboxedTupleT :: Quote m => Int -> m Type
unboxedSumT :: Quote m => SumArity -> m Type
sigT :: Quote m => m Type -> m Kind -> m Type
equalityT :: Quote m => m Type
wildCardT :: Quote m => m Type
implicitParamT :: Quote m => String -> m Type -> m Type

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Quote m => Name -> [m Type] -> m Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: Quote m => m Type -> m Type -> m Pred
promotedT :: Quote m => Name -> m Type
promotedTupleT :: Quote m => Int -> m Type
promotedNilT :: Quote m => m Type
promotedConsT :: Quote m => m Type
noSourceUnpackedness :: Quote m => m SourceUnpackedness
sourceNoUnpack :: Quote m => m SourceUnpackedness
sourceUnpack :: Quote m => m SourceUnpackedness
noSourceStrictness :: Quote m => m SourceStrictness
sourceLazy :: Quote m => m SourceStrictness
sourceStrict :: Quote m => m SourceStrictness

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Quote m => m Strict
bang :: Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
bangType :: Quote m => m Bang -> m Type -> m BangType
varBangType :: Quote m => Name -> m BangType -> m VarBangType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Quote m => m Strict -> m Type -> m StrictType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Quote m => Name -> m StrictType -> m VarStrictType
numTyLit :: Quote m => Integer -> m TyLit
strTyLit :: Quote m => String -> m TyLit
charTyLit :: Quote m => Char -> m TyLit
plainTV :: Quote m => Name -> m (TyVarBndr ())
plainInvisTV :: Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
kindedTV :: Quote m => Name -> m Kind -> m (TyVarBndr ())
kindedInvisTV :: Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
specifiedSpec :: Specificity
inferredSpec :: Specificity
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Quote m => m Kind
constraintK :: Quote m => m Kind
noSig :: Quote m => m FamilyResultSig
kindSig :: Quote m => m Kind -> m FamilyResultSig
tyVarSig :: Quote m => m (TyVarBndr ()) -> m FamilyResultSig
injectivityAnn :: Name -> [Name] -> InjectivityAnn
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Quote m => Name -> m RuleBndr
typedRuleVar :: Quote m => Name -> m Type -> m RuleBndr
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
unidir :: Quote m => m PatSynDir
implBidir :: Quote m => m PatSynDir
explBidir :: Quote m => [m Clause] -> m PatSynDir
prefixPatSyn :: Quote m => [Name] -> m PatSynArgs
recordPatSyn :: Quote m => [Name] -> m PatSynArgs
infixPatSyn :: Quote m => Name -> Name -> m PatSynArgs
appsE :: Quote m => [m Exp] -> m Exp

-- | pure the Module at the place of splicing. Can be used as an input for
--   <a>reifyModule</a>.
thisModule :: Q Module

-- | Attaches Haddock documentation to the declaration provided. Unlike
--   <a>putDoc</a>, the names do not need to be in scope when calling this
--   function so it can be used for quoted declarations and anything else
--   currently being spliced. Not all declarations can have documentation
--   attached to them. For those that can't, <a>withDecDoc</a> will return
--   it unchanged without any side effects.
withDecDoc :: String -> Q Dec -> Q Dec

-- | Variant of <a>withDecDoc</a> that applies the same documentation to
--   multiple declarations. Useful for documenting quoted declarations.
withDecsDoc :: String -> Q [Dec] -> Q [Dec]

-- | Variant of <a>funD</a> that attaches Haddock documentation.
funD_doc :: Name -> [Q Clause] -> Maybe String -> [Maybe String] -> Q Dec

-- | Variant of <a>dataD</a> that attaches Haddock documentation.
dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeD</a> that attaches Haddock documentation.
newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>typeDataD</a> that attaches Haddock documentation.
typeDataD_doc :: Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> Maybe String -> Q Dec

-- | Variant of <a>dataInstD</a> that attaches Haddock documentation.
dataInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeInstD</a> that attaches Haddock documentation.
newtypeInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>patSynD</a> that attaches Haddock documentation.
patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> Maybe String -> [Maybe String] -> Q Dec

-- | Document a data/newtype constructor with its arguments.
docCons :: (Q Con, Maybe String, [Maybe String]) -> Q ()


-- | Language.Haskell.TH.Lib contains lots of useful helper functions for
--   generating and manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type ExpQ = Q Exp

-- | Representation-polymorphic since <i>template-haskell-2.17.0.0</i>.
type TExpQ a = Q (TExp a)
type CodeQ = Code Q
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type KindQ = Q Kind
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type DerivClauseQ = Q DerivClause
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type SourceStrictnessQ = Q SourceStrictness
type SourceUnpackednessQ = Q SourceUnpackedness
type BangQ = Q Bang
type BangTypeQ = Q BangType
type VarBangTypeQ = Q VarBangType
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type PatSynDirQ = Q PatSynDir
type PatSynArgsQ = Q PatSynArgs
type FamilyResultSigQ = Q FamilyResultSig
type DerivStrategyQ = Q DerivStrategy
type TyVarBndrUnit = TyVarBndr ()
type TyVarBndrSpec = TyVarBndr Specificity
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
charPrimL :: Char -> Lit
bytesPrimL :: Bytes -> Lit

-- | Create a Bytes datatype representing raw bytes to be embedded into the
--   program/library binary.
mkBytes :: ForeignPtr Word8 -> Word -> Word -> Bytes
litP :: Quote m => Lit -> m Pat
varP :: Quote m => Name -> m Pat
tupP :: Quote m => [m Pat] -> m Pat
unboxedTupP :: Quote m => [m Pat] -> m Pat
unboxedSumP :: Quote m => m Pat -> SumAlt -> SumArity -> m Pat
conP :: Quote m => Name -> [m Pat] -> m Pat
uInfixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
parensP :: Quote m => m Pat -> m Pat
infixP :: Quote m => m Pat -> Name -> m Pat -> m Pat
tildeP :: Quote m => m Pat -> m Pat
bangP :: Quote m => m Pat -> m Pat
asP :: Quote m => Name -> m Pat -> m Pat
wildP :: Quote m => m Pat
recP :: Quote m => Name -> [m FieldPat] -> m Pat
listP :: Quote m => [m Pat] -> m Pat
sigP :: Quote m => m Pat -> m Type -> m Pat
viewP :: Quote m => m Exp -> m Pat -> m Pat
fieldPat :: Quote m => Name -> m Pat -> m FieldPat
normalB :: Quote m => m Exp -> m Body
guardedB :: Quote m => [m (Guard, Exp)] -> m Body
normalG :: Quote m => m Exp -> m Guard
normalGE :: Quote m => m Exp -> m Exp -> m (Guard, Exp)
patG :: Quote m => [m Stmt] -> m Guard
patGE :: Quote m => [m Stmt] -> m Exp -> m (Guard, Exp)

-- | Use with <a>caseE</a>
match :: Quote m => m Pat -> m Body -> [m Dec] -> m Match

-- | Use with <a>funD</a>
clause :: Quote m => [m Pat] -> m Body -> [m Dec] -> m Clause

-- | Dynamically binding a variable (unhygenic)
dyn :: Quote m => String -> m Exp
varE :: Quote m => Name -> m Exp
unboundVarE :: Quote m => Name -> m Exp
labelE :: Quote m => String -> m Exp
implicitParamVarE :: Quote m => String -> m Exp
conE :: Quote m => Name -> m Exp
litE :: Quote m => Lit -> m Exp

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: Quote m => m Exp -> m Exp
appE :: Quote m => m Exp -> m Exp -> m Exp
appTypeE :: Quote m => m Exp -> m Type -> m Exp
uInfixE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
parensE :: Quote m => m Exp -> m Exp
infixE :: Quote m => Maybe (m Exp) -> m Exp -> Maybe (m Exp) -> m Exp
infixApp :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
sectionL :: Quote m => m Exp -> m Exp -> m Exp
sectionR :: Quote m => m Exp -> m Exp -> m Exp
lamE :: Quote m => [m Pat] -> m Exp -> m Exp

-- | Single-arg lambda
lam1E :: Quote m => m Pat -> m Exp -> m Exp

-- | Lambda-case (<tt>case</tt>)
lamCaseE :: Quote m => [m Match] -> m Exp

-- | Lambda-cases (<tt>cases</tt>)
lamCasesE :: Quote m => [m Clause] -> m Exp
tupE :: Quote m => [m Exp] -> m Exp
unboxedTupE :: Quote m => [m Exp] -> m Exp
unboxedSumE :: Quote m => m Exp -> SumAlt -> SumArity -> m Exp
condE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
multiIfE :: Quote m => [m (Guard, Exp)] -> m Exp
letE :: Quote m => [m Dec] -> m Exp -> m Exp
caseE :: Quote m => m Exp -> [m Match] -> m Exp
appsE :: Quote m => [m Exp] -> m Exp
listE :: Quote m => [m Exp] -> m Exp
sigE :: Quote m => m Exp -> m Type -> m Exp
recConE :: Quote m => Name -> [m (Name, Exp)] -> m Exp
recUpdE :: Quote m => m Exp -> [m (Name, Exp)] -> m Exp
stringE :: Quote m => String -> m Exp
fieldExp :: Quote m => Name -> m Exp -> m (Name, Exp)
getFieldE :: Quote m => m Exp -> String -> m Exp
projectionE :: Quote m => NonEmpty String -> m Exp
fromE :: Quote m => m Exp -> m Exp
fromThenE :: Quote m => m Exp -> m Exp -> m Exp
fromToE :: Quote m => m Exp -> m Exp -> m Exp
fromThenToE :: Quote m => m Exp -> m Exp -> m Exp -> m Exp
arithSeqE :: Quote m => m Range -> m Exp
fromR :: Quote m => m Exp -> m Range
fromThenR :: Quote m => m Exp -> m Exp -> m Range
fromToR :: Quote m => m Exp -> m Exp -> m Range
fromThenToR :: Quote m => m Exp -> m Exp -> m Exp -> m Range
doE :: Quote m => [m Stmt] -> m Exp
mdoE :: Quote m => [m Stmt] -> m Exp
compE :: Quote m => [m Stmt] -> m Exp
bindS :: Quote m => m Pat -> m Exp -> m Stmt
letS :: Quote m => [m Dec] -> m Stmt
noBindS :: Quote m => m Exp -> m Stmt
parS :: Quote m => [[m Stmt]] -> m Stmt
recS :: Quote m => [m Stmt] -> m Stmt
forallT :: Quote m => [TyVarBndr Specificity] -> m Cxt -> m Type -> m Type
forallVisT :: Quote m => [m (TyVarBndr ())] -> m Type -> m Type
varT :: Quote m => Name -> m Type
conT :: Quote m => Name -> m Type
appT :: Quote m => m Type -> m Type -> m Type
appKindT :: Quote m => m Type -> m Kind -> m Type
arrowT :: Quote m => m Type
mulArrowT :: Quote m => m Type
infixT :: Quote m => m Type -> Name -> m Type -> m Type
uInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedInfixT :: Quote m => m Type -> Name -> m Type -> m Type
promotedUInfixT :: Quote m => m Type -> Name -> m Type -> m Type
parensT :: Quote m => m Type -> m Type
equalityT :: Quote m => m Type
listT :: Quote m => m Type
tupleT :: Quote m => Int -> m Type
unboxedTupleT :: Quote m => Int -> m Type
unboxedSumT :: Quote m => SumArity -> m Type
sigT :: Quote m => m Type -> Kind -> m Type
litT :: Quote m => m TyLit -> m Type
wildCardT :: Quote m => m Type
promotedT :: Quote m => Name -> m Type
promotedTupleT :: Quote m => Int -> m Type
promotedNilT :: Quote m => m Type
promotedConsT :: Quote m => m Type
implicitParamT :: Quote m => String -> m Type -> m Type
numTyLit :: Quote m => Integer -> m TyLit
strTyLit :: Quote m => String -> m TyLit
charTyLit :: Quote m => Char -> m TyLit
noSourceUnpackedness :: Quote m => m SourceUnpackedness
sourceNoUnpack :: Quote m => m SourceUnpackedness
sourceUnpack :: Quote m => m SourceUnpackedness
noSourceStrictness :: Quote m => m SourceStrictness
sourceLazy :: Quote m => m SourceStrictness
sourceStrict :: Quote m => m SourceStrictness

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness sourceStrict'</i>
isStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang noSourceUnpackedness noSourceStrictness'</i>
notStrict :: Quote m => m Strict

-- | <i>Deprecated: Use <a>bang</a>. See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.0</a>. Example
--   usage: 'bang sourceUnpack sourceStrict'</i>
unpacked :: Quote m => m Strict
bang :: Quote m => m SourceUnpackedness -> m SourceStrictness -> m Bang
bangType :: Quote m => m Bang -> m Type -> m BangType
varBangType :: Quote m => Name -> m BangType -> m VarBangType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>StrictType</a> has been replaced by <a>BangType</a>. Please use
--   <a>bangType</a> instead.</i>
strictType :: Quote m => m Strict -> m Type -> m StrictType

-- | <i>Deprecated: As of <tt>template-haskell-2.11.0.0</tt>,
--   <a>VarStrictType</a> has been replaced by <a>VarBangType</a>. Please
--   use <a>varBangType</a> instead.</i>
varStrictType :: Quote m => Name -> m StrictType -> m VarStrictType
cxt :: Quote m => [m Pred] -> m Cxt

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Quote m => Name -> [m Type] -> m Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: Quote m => m Type -> m Type -> m Pred
normalC :: Quote m => Name -> [m BangType] -> m Con
recC :: Quote m => Name -> [m VarBangType] -> m Con
infixC :: Quote m => m (Bang, Type) -> Name -> m (Bang, Type) -> m Con
forallC :: Quote m => [TyVarBndr Specificity] -> m Cxt -> m Con -> m Con
gadtC :: Quote m => [Name] -> [m StrictType] -> m Type -> m Con
recGadtC :: Quote m => [Name] -> [m VarStrictType] -> m Type -> m Con
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
plainTV :: Name -> TyVarBndr ()
kindedTV :: Name -> Kind -> TyVarBndr ()
plainInvisTV :: Quote m => Name -> Specificity -> m (TyVarBndr Specificity)
kindedInvisTV :: Quote m => Name -> Specificity -> m Kind -> m (TyVarBndr Specificity)
specifiedSpec :: Specificity
inferredSpec :: Specificity
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: Quote m => m Pat -> m Body -> [m Dec] -> m Dec
funD :: Quote m => Name -> [m Clause] -> m Dec
tySynD :: Quote m => Name -> [TyVarBndr ()] -> m Type -> m Dec
dataD :: Quote m => m Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
newtypeD :: Quote m => m Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> m Con -> [m DerivClause] -> m Dec
typeDataD :: Quote m => Name -> [TyVarBndr ()] -> Maybe Kind -> [m Con] -> m Dec
derivClause :: Quote m => Maybe DerivStrategy -> [m Pred] -> m DerivClause

-- | A single <tt>deriving</tt> clause at the end of a datatype.
data DerivClause

-- | <pre>
--   { deriving stock (Eq, Ord) }
--   </pre>
DerivClause :: Maybe DerivStrategy -> Cxt -> DerivClause
stockStrategy :: Quote m => m DerivStrategy
anyclassStrategy :: Quote m => m DerivStrategy
newtypeStrategy :: Quote m => m DerivStrategy
viaStrategy :: Quote m => m Type -> m DerivStrategy

-- | What the user explicitly requests when deriving an instance.
data DerivStrategy

-- | A "standard" derived instance
StockStrategy :: DerivStrategy

-- | <pre>
--   -XDeriveAnyClass
--   </pre>
AnyclassStrategy :: DerivStrategy

-- | <pre>
--   -XGeneralizedNewtypeDeriving
--   </pre>
NewtypeStrategy :: DerivStrategy

-- | <pre>
--   -XDerivingVia
--   </pre>
ViaStrategy :: Type -> DerivStrategy
classD :: Quote m => m Cxt -> Name -> [TyVarBndr ()] -> [FunDep] -> [m Dec] -> m Dec
instanceD :: Quote m => m Cxt -> m Type -> [m Dec] -> m Dec
instanceWithOverlapD :: Quote m => Maybe Overlap -> m Cxt -> m Type -> [m Dec] -> m Dec

-- | Varieties of allowed instance overlap.
data Overlap

-- | May be overlapped by more specific instances
Overlappable :: Overlap

-- | May overlap a more general instance
Overlapping :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>
Overlaps :: Overlap

-- | Both <a>Overlapping</a> and <a>Overlappable</a>, and pick an arbitrary
--   one if multiple choices are available.
Incoherent :: Overlap
sigD :: Quote m => Name -> m Type -> m Dec
kiSigD :: Quote m => Name -> m Kind -> m Dec
standaloneDerivD :: Quote m => m Cxt -> m Type -> m Dec
standaloneDerivWithStrategyD :: Quote m => Maybe DerivStrategy -> m Cxt -> m Type -> m Dec
defaultSigD :: Quote m => Name -> m Type -> m Dec
roleAnnotD :: Quote m => Name -> [Role] -> m Dec
dataFamilyD :: Quote m => Name -> [TyVarBndr ()] -> Maybe Kind -> m Dec
openTypeFamilyD :: Quote m => Name -> [TyVarBndr ()] -> FamilyResultSig -> Maybe InjectivityAnn -> m Dec
closedTypeFamilyD :: Quote m => Name -> [TyVarBndr ()] -> FamilyResultSig -> Maybe InjectivityAnn -> [m TySynEqn] -> m Dec
dataInstD :: Quote m => m Cxt -> Name -> [m Type] -> Maybe Kind -> [m Con] -> [m DerivClause] -> m Dec
newtypeInstD :: Quote m => m Cxt -> Name -> [m Type] -> Maybe Kind -> m Con -> [m DerivClause] -> m Dec
tySynInstD :: Quote m => m TySynEqn -> m Dec
tySynEqn :: Quote m => Maybe [TyVarBndr ()] -> m Type -> m Type -> m TySynEqn
injectivityAnn :: Name -> [Name] -> InjectivityAnn
noSig :: FamilyResultSig
kindSig :: Kind -> FamilyResultSig
tyVarSig :: TyVarBndr () -> FamilyResultSig
infixLD :: Quote m => Int -> Name -> m Dec
infixRD :: Quote m => Int -> Name -> m Dec
infixND :: Quote m => Int -> Name -> m Dec
defaultD :: Quote m => [m Type] -> m Dec
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
forImpD :: Quote m => Callconv -> Safety -> String -> Name -> m Type -> m Dec
funDep :: [Name] -> [Name] -> FunDep
ruleVar :: Quote m => Name -> m RuleBndr
typedRuleVar :: Quote m => Name -> m Type -> m RuleBndr
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
pragInlD :: Quote m => Name -> Inline -> RuleMatch -> Phases -> m Dec
pragSpecD :: Quote m => Name -> m Type -> Phases -> m Dec
pragSpecInlD :: Quote m => Name -> m Type -> Inline -> Phases -> m Dec
pragSpecInstD :: Quote m => m Type -> m Dec
pragRuleD :: Quote m => String -> [m RuleBndr] -> m Exp -> m Exp -> Phases -> m Dec
pragAnnD :: Quote m => AnnTarget -> m Exp -> m Dec
pragLineD :: Quote m => Int -> String -> m Dec
pragCompleteD :: Quote m => [Name] -> Maybe Name -> m Dec

-- | Pattern synonym declaration
patSynD :: Quote m => Name -> m PatSynArgs -> m PatSynDir -> m Pat -> m Dec

-- | Pattern synonym type signature
patSynSigD :: Quote m => Name -> m Type -> m Dec
unidir :: Quote m => m PatSynDir
implBidir :: Quote m => m PatSynDir
explBidir :: Quote m => [m Clause] -> m PatSynDir
prefixPatSyn :: Quote m => [Name] -> m PatSynArgs
infixPatSyn :: Quote m => Name -> Name -> m PatSynArgs
recordPatSyn :: Quote m => [Name] -> m PatSynArgs

-- | Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
implicitParamBindD :: Quote m => String -> m Exp -> m Dec

-- | pure the Module at the place of splicing. Can be used as an input for
--   <a>reifyModule</a>.
thisModule :: Q Module

-- | Attaches Haddock documentation to the declaration provided. Unlike
--   <a>putDoc</a>, the names do not need to be in scope when calling this
--   function so it can be used for quoted declarations and anything else
--   currently being spliced. Not all declarations can have documentation
--   attached to them. For those that can't, <a>withDecDoc</a> will return
--   it unchanged without any side effects.
withDecDoc :: String -> Q Dec -> Q Dec

-- | Variant of <a>withDecDoc</a> that applies the same documentation to
--   multiple declarations. Useful for documenting quoted declarations.
withDecsDoc :: String -> Q [Dec] -> Q [Dec]

-- | Variant of <a>funD</a> that attaches Haddock documentation.
funD_doc :: Name -> [Q Clause] -> Maybe String -> [Maybe String] -> Q Dec

-- | Variant of <a>dataD</a> that attaches Haddock documentation.
dataD_doc :: Q Cxt -> Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeD</a> that attaches Haddock documentation.
newtypeD_doc :: Q Cxt -> Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>typeDataD</a> that attaches Haddock documentation.
typeDataD_doc :: Name -> [Q (TyVarBndr ())] -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> Maybe String -> Q Dec

-- | Variant of <a>dataInstD</a> that attaches Haddock documentation.
dataInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> [(Q Con, Maybe String, [Maybe String])] -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>newtypeInstD</a> that attaches Haddock documentation.
newtypeInstD_doc :: Q Cxt -> Maybe [Q (TyVarBndr ())] -> Q Type -> Maybe (Q Kind) -> (Q Con, Maybe String, [Maybe String]) -> [Q DerivClause] -> Maybe String -> Q Dec

-- | Variant of <a>patSynD</a> that attaches Haddock documentation.
patSynD_doc :: Name -> Q PatSynArgs -> Q PatSynDir -> Q Pat -> Maybe String -> [Maybe String] -> Q Dec


-- | This module exists to work nicely with the QualifiedDo extension.
--   
--   <pre>
--   import qualified Language.Haskell.TH.CodeDo as Code
--   
--   myExample :: Monad m =&gt; Code m a -&gt; Code m a -&gt; Code m a
--   myExample opt1 opt2 =
--     Code.do
--      x &lt;- someSideEffect               -- This one is of type `M Bool`
--      if x then opt1 else opt2
--   </pre>
module Language.Haskell.TH.CodeDo

-- | Module over monad operator for <a>Code</a>
(>>=) :: Monad m => m a -> (a -> Code m b) -> Code m b
(>>) :: Monad m => m a -> Code m b -> Code m b


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>https://wiki.haskell.org/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | The <a>Quote</a> class implements the minimal interface which is
--   necessary for desugaring quotations.
--   
--   <ul>
--   <li>The <tt>Monad m</tt> superclass is needed to stitch together the
--   different AST fragments.</li>
--   <li><a>newName</a> is used when desugaring binding structures such as
--   lambdas to generate fresh names.</li>
--   </ul>
--   
--   Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m
--   Exp`
--   
--   For many years the type of a quotation was fixed to be `Q Exp` but by
--   more precisely specifying the minimal interface it enables the
--   <a>Exp</a> to be extracted purely from the quotation without
--   interacting with <a>Q</a>.
class Monad m => Quote m

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--       nm1 &lt;- newName "x"
--       let nm2 = <a>mkName</a> "x"
--       return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--      )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: Quote m => String -> m Name

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>. It will fail
--   with a compile error if the <a>Name</a> is not visible. A <a>Name</a>
--   is visible if it is imported or defined in a prior top-level
--   declaration group. See the documentation for
--   <a>newDeclarationGroup</a> for more details.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <a>thisModule</a>.
reifyModule :: Module -> Q ModuleInfo

-- | Template Haskell is capable of reifying information about types and
--   terms defined in previous declaration groups. Top-level declaration
--   splices break up declaration groups.
--   
--   For an example, consider this code block. We define a datatype
--   <tt>X</tt> and then try to call <a>reify</a> on the datatype.
--   
--   <pre>
--   module Check where
--   
--   data X = X
--       deriving Eq
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   This code fails to compile, noting that <tt>X</tt> is not available
--   for reification at the site of <a>reify</a>. We can fix this by
--   creating a new declaration group using an empty top-level splice:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   $(pure [])
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
--   
--   We provide <a>newDeclarationGroup</a> as a means of documenting this
--   behavior and providing a name for the pattern.
--   
--   Since top level splices infer the presence of the <tt>$( ... )</tt>
--   brackets, we can also write:
--   
--   <pre>
--   data X = X
--       deriving Eq
--   
--   newDeclarationGroup
--   
--   $(do
--       info &lt;- reify ''X
--       runIO $ print info
--    )
--   </pre>
newDeclarationGroup :: Q [Dec]

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
ClassI :: Dec -> [InstanceDec] -> Info

-- | A class method
ClassOpI :: Name -> Type -> ParentName -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate. At present,
--   this reified declaration will never have derived instances attached to
--   it (if you wish to check for an instance, see <a>reifyInstances</a>).
TyConI :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
FamilyI :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
PrimTyConI :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
DataConI :: Name -> Type -> ParentName -> Info

-- | A pattern synonym
PatSynI :: Name -> PatSynType -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable - including the RHS of the declaration - or
--   else <tt>Nothing</tt>, in the case where the RHS is unavailable to the
--   compiler. At present, this value is <i>always</i> <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
VarI :: Name -> Type -> Maybe Dec -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
TyVarI :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
ModuleInfo :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> describes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>UnboxedSumE</a> and <a>UnboxedSumP</a>, the number associated
--   with a particular data constructor. <a>SumAlt</a>s are one-indexed and
--   should never exceed the value of its corresponding <a>SumArity</a>.
--   For example:
--   
--   <ul>
--   <li><tt>(#_|#)</tt> has <a>SumAlt</a> 1 (out of a total
--   <a>SumArity</a> of 2)</li>
--   <li><tt>(#|_#)</tt> has <a>SumAlt</a> 2 (out of a total
--   <a>SumArity</a> of 2)</li>
--   </ul>
type SumAlt = Int

-- | In <a>UnboxedSumE</a>, <a>UnboxedSumT</a>, and <a>UnboxedSumP</a>, the
--   total number of <a>SumAlt</a>s. For example, <tt>(#|#)</tt> has a
--   <a>SumArity</a> of 2.
type SumArity = Int

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | The language extensions known to GHC.
--   
--   Note that there is an orphan <tt>Binary</tt> instance for this type
--   supplied by the <a>GHC.LanguageExtensions</a> module provided by
--   <tt>ghc-boot</tt>. We can't provide here as this would require adding
--   transitive dependencies to the <tt>template-haskell</tt> package,
--   which must have a minimal dependency set.
data () => Extension
Cpp :: Extension
OverlappingInstances :: Extension
UndecidableInstances :: Extension
IncoherentInstances :: Extension
UndecidableSuperClasses :: Extension
MonomorphismRestriction :: Extension
MonoLocalBinds :: Extension
DeepSubsumption :: Extension
RelaxedPolyRec :: Extension
ExtendedDefaultRules :: Extension
ForeignFunctionInterface :: Extension
UnliftedFFITypes :: Extension
InterruptibleFFI :: Extension
CApiFFI :: Extension
GHCForeignImportPrim :: Extension
JavaScriptFFI :: Extension
ParallelArrays :: Extension
Arrows :: Extension
TemplateHaskell :: Extension
TemplateHaskellQuotes :: Extension
QualifiedDo :: Extension
QuasiQuotes :: Extension
ImplicitParams :: Extension
ImplicitPrelude :: Extension
ScopedTypeVariables :: Extension
AllowAmbiguousTypes :: Extension
UnboxedTuples :: Extension
UnboxedSums :: Extension
UnliftedNewtypes :: Extension
UnliftedDatatypes :: Extension
BangPatterns :: Extension
TypeFamilies :: Extension
TypeFamilyDependencies :: Extension
TypeInType :: Extension
OverloadedStrings :: Extension
OverloadedLists :: Extension
NumDecimals :: Extension
DisambiguateRecordFields :: Extension
RecordWildCards :: Extension
NamedFieldPuns :: Extension
ViewPatterns :: Extension
GADTs :: Extension
GADTSyntax :: Extension
NPlusKPatterns :: Extension
DoAndIfThenElse :: Extension
BlockArguments :: Extension
RebindableSyntax :: Extension
ConstraintKinds :: Extension
PolyKinds :: Extension
DataKinds :: Extension
TypeData :: Extension
InstanceSigs :: Extension
ApplicativeDo :: Extension
LinearTypes :: Extension
StandaloneDeriving :: Extension
DeriveDataTypeable :: Extension
AutoDeriveTypeable :: Extension
DeriveFunctor :: Extension
DeriveTraversable :: Extension
DeriveFoldable :: Extension
DeriveGeneric :: Extension
DefaultSignatures :: Extension
DeriveAnyClass :: Extension
DeriveLift :: Extension
DerivingStrategies :: Extension
DerivingVia :: Extension
TypeSynonymInstances :: Extension
FlexibleContexts :: Extension
FlexibleInstances :: Extension
ConstrainedClassMethods :: Extension
MultiParamTypeClasses :: Extension
NullaryTypeClasses :: Extension
FunctionalDependencies :: Extension
UnicodeSyntax :: Extension
ExistentialQuantification :: Extension
MagicHash :: Extension
EmptyDataDecls :: Extension
KindSignatures :: Extension
RoleAnnotations :: Extension
ParallelListComp :: Extension
TransformListComp :: Extension
MonadComprehensions :: Extension
GeneralizedNewtypeDeriving :: Extension
RecursiveDo :: Extension
PostfixOperators :: Extension
TupleSections :: Extension
PatternGuards :: Extension
LiberalTypeSynonyms :: Extension
RankNTypes :: Extension
ImpredicativeTypes :: Extension
TypeOperators :: Extension
ExplicitNamespaces :: Extension
PackageImports :: Extension
ExplicitForAll :: Extension
AlternativeLayoutRule :: Extension
AlternativeLayoutRuleTransitional :: Extension
DatatypeContexts :: Extension
NondecreasingIndentation :: Extension
RelaxedLayout :: Extension
TraditionalRecordSyntax :: Extension
LambdaCase :: Extension
MultiWayIf :: Extension
BinaryLiterals :: Extension
NegativeLiterals :: Extension
HexFloatLiterals :: Extension
DuplicateRecordFields :: Extension
OverloadedLabels :: Extension
EmptyCase :: Extension
PatternSynonyms :: Extension
PartialTypeSignatures :: Extension
NamedWildCards :: Extension
StaticPointers :: Extension
TypeApplications :: Extension
Strict :: Extension
StrictData :: Extension
EmptyDataDeriving :: Extension
NumericUnderscores :: Extension
QuantifiedConstraints :: Extension
StarIsType :: Extension
ImportQualifiedPost :: Extension
CUSKs :: Extension
StandaloneKindSignatures :: Extension
LexicalNegation :: Extension
FieldSelectors :: Extension
OverloadedRecordDot :: Extension
OverloadedRecordUpdate :: Extension

-- | List all enabled language extensions.
extsEnabled :: Q [Extension]

-- | Determine whether the given language extension is enabled in the
--   <a>Q</a> monad.
isExtEnabled :: Extension -> Q Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyFixity nm</tt> attempts to find a fixity declaration for
--   <tt>nm</tt>. For example, if the function <tt>foo</tt> has the fixity
--   declaration <tt>infixr 7 foo</tt>, then <tt>reifyFixity 'foo</tt>
--   would return <tt><a>Just</a> (<a>Fixity</a> 7 <a>InfixR</a>)</tt>. If
--   the function <tt>bar</tt> does not have a fixity declaration, then
--   <tt>reifyFixity 'bar</tt> returns <a>Nothing</a>, so you may assume
--   <tt>bar</tt> has <a>defaultFixity</a>.
reifyFixity :: Name -> Q (Maybe Fixity)

-- | <tt>reifyType nm</tt> attempts to find the type or kind of
--   <tt>nm</tt>. For example, <tt>reifyType 'not</tt> returns <tt>Bool
--   -&gt; Bool</tt>, and <tt>reifyType ''Bool</tt> returns <tt>Type</tt>.
--   This works even if there's no explicit signature and the type or kind
--   is inferred.
reifyType :: Name -> Q Type

-- | <tt>reifyInstances nm tys</tt> returns a list of all visible instances
--   (see below for "visible") of <tt>nm tys</tt>. That is, if <tt>nm</tt>
--   is the name of a type class, then all instances of this class at the
--   types <tt>tys</tt> are returned. Alternatively, if <tt>nm</tt> is the
--   name of a data family or type family, all instances of this family at
--   the types <tt>tys</tt> are returned.
--   
--   Note that this is a "shallow" test; the declarations returned merely
--   have instance heads which unify with <tt>nm tys</tt>, they need not
--   actually be satisfiable.
--   
--   <ul>
--   <li><tt>reifyInstances ''Eq [ <a>TupleT</a> 2 `<a>AppT</a>`
--   <a>ConT</a> ''A `<a>AppT</a>` <a>ConT</a> ''B ]</tt> contains the
--   <tt>instance (Eq a, Eq b) =&gt; Eq (a, b)</tt> regardless of whether
--   <tt>A</tt> and <tt>B</tt> themselves implement <a>Eq</a></li>
--   <li><tt>reifyInstances ''Show [ <a>VarT</a> (<a>mkName</a> "a") ]</tt>
--   produces every available instance of <a>Eq</a></li>
--   </ul>
--   
--   There is one edge case: <tt>reifyInstances ''Typeable tys</tt>
--   currently always produces an empty list (no matter what <tt>tys</tt>
--   are given).
--   
--   In principle, the *visible* instances are * all instances defined in a
--   prior top-level declaration group (see docs on
--   <tt>newDeclarationGroup</tt>), or * all instances defined in any
--   module transitively imported by the module being compiled
--   
--   However, actually searching all modules transitively below the one
--   being compiled is unreasonably expensive, so <tt>reifyInstances</tt>
--   will report only the instance for modules that GHC has had some cause
--   to visit during this compilation. This is a shortcoming:
--   <tt>reifyInstances</tt> might fail to report instances for a type that
--   is otherwise unusued, or instances defined in a different component.
--   You can work around this shortcoming by explicitly importing the
--   modules whose instances you want to be visible. GHC issue
--   <a>#20529</a> has some discussion around this.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
--   
--   If you're confused by an instance not being visible despite being
--   defined in the same module and above the splice in question, see the
--   docs for <a>newDeclarationGroup</a> for a possible explanation.
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters (both visible and invisible) of the tycon <tt>nm</tt>.
--   Fails if <tt>nm</tt> cannot be found or is not a tycon. The returned
--   list should never contain <a>InferR</a>.
--   
--   An invisible parameter to a tycon is often a kind parameter. For
--   example, if we have
--   
--   <pre>
--   type Proxy :: forall k. k -&gt; Type
--   data Proxy a = MkProxy
--   </pre>
--   
--   and <tt>reifyRoles Proxy</tt>, we will get <tt>[<a>NominalR</a>,
--   <a>PhantomR</a>]</tt>. The <a>NominalR</a> is the role of the
--   invisible <tt>k</tt> parameter. Kind parameters are always nominal.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | Annotation target for reifyAnnotations
data AnnLookup
AnnLookupModule :: Module -> AnnLookup
AnnLookupName :: Name -> AnnLookup

-- | <tt>reifyConStrictness nm</tt> looks up the strictness information for
--   the fields of the constructor with the name <tt>nm</tt>. Note that the
--   strictness information that <a>reifyConStrictness</a> returns may not
--   correspond to what is written in the source code. For example, in the
--   following data declaration:
--   
--   <pre>
--   data Pair a = Pair a a
--   </pre>
--   
--   <a>reifyConStrictness</a> would return <tt>[<a>DecidedLazy</a>,
--   DecidedLazy]</tt> under most circumstances, but it would return
--   <tt>[<a>DecidedStrict</a>, DecidedStrict]</tt> if the
--   <tt>-XStrictData</tt> language extension was enabled.
reifyConStrictness :: Name -> Q [DecidedStrictness]

-- | Represents an expression which has type <tt>a</tt>. Built on top of
--   <a>Exp</a>, typed expressions allow for type-safe splicing via:
--   
--   <ul>
--   <li>typed quotes, written as <tt>[|| ... ||]</tt> where <tt>...</tt>
--   is an expression; if that expression has type <tt>a</tt>, then the
--   quotation has type <tt><a>Q</a> (<a>TExp</a> a)</tt></li>
--   <li>typed splices inside of typed quotes, written as <tt>$$(...)</tt>
--   where <tt>...</tt> is an arbitrary expression of type <tt><a>Q</a>
--   (<a>TExp</a> a)</tt></li>
--   </ul>
--   
--   Traditional expression quotes and splices let us construct ill-typed
--   expressions:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [| True == $( [| "foo" |] ) |]
--   GHC.Types.True GHC.Classes.== "foo"
--   
--   &gt;&gt;&gt; GHC.Types.True GHC.Classes.== "foo"
--   &lt;interactive&gt; error:
--       • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
--       • In the second argument of ‘(==)’, namely ‘"foo"’
--         In the expression: True == "foo"
--         In an equation for ‘it’: it = True == "foo"
--   </pre>
--   
--   With typed expressions, the type error occurs when <i>constructing</i>
--   the Template Haskell expression:
--   
--   <pre>
--   &gt;&gt;&gt; fmap ppr $ runQ [|| True == $$( [|| "foo" ||] ) ||]
--   &lt;interactive&gt; error:
--       • Couldn't match type ‘[Char]’ with ‘Bool’
--         Expected type: Q (TExp Bool)
--           Actual type: Q (TExp [Char])
--       • In the Template Haskell quotation [|| "foo" ||]
--         In the expression: [|| "foo" ||]
--         In the Template Haskell splice $$([|| "foo" ||])
--   </pre>
--   
--   Representation-polymorphic since <i>template-haskell-2.16.0.0</i>.
data TExp (a :: TYPE (r :: RuntimeRep))

-- | Underlying untyped Template Haskell expression
unType :: TExp a -> Exp
newtype Code m (a :: TYPE (r :: RuntimeRep))
Code :: m (TExp a) -> Code m (a :: TYPE (r :: RuntimeRep))

-- | Underlying monadic value
[examineCode] :: Code m (a :: TYPE (r :: RuntimeRep)) -> m (TExp a)

-- | Extract the untyped representation from the typed representation
unTypeCode :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => Code m a -> m Exp

-- | Unsafely convert an untyped code representation into a typed code
--   representation.
unsafeCodeCoerce :: forall (r :: RuntimeRep) (a :: TYPE r) m. Quote m => m Exp -> Code m a

-- | Modify the ambient monad used during code generation. For example, you
--   can use <a>hoistCode</a> to handle a state effect: <tt> handleState ::
--   Code (StateT Int Q) a -&gt; Code Q a handleState = hoistCode (flip
--   runState 0) </tt>
hoistCode :: forall m n (r :: RuntimeRep) (a :: TYPE r). Monad m => (forall x. m x -> n x) -> Code m a -> Code n a

-- | Variant of (&gt;&gt;=) which allows effectful computations to be
--   injected into code generation.
bindCode :: forall m a (r :: RuntimeRep) (b :: TYPE r). Monad m => m a -> (a -> Code m b) -> Code m b

-- | Variant of (&gt;&gt;) which allows effectful computations to be
--   injected into code generation.
bindCode_ :: forall m a (r :: RuntimeRep) (b :: TYPE r). Monad m => m a -> Code m b -> Code m b

-- | A useful combinator for embedding monadic actions into <a>Code</a>
--   <tt> myCode :: ... =&gt; Code m a myCode = joinCode $ do x &lt;-
--   someSideEffect return (makeCodeWith x) </tt>
joinCode :: forall m (r :: RuntimeRep) (a :: TYPE r). Monad m => m (Code m a) -> Code m a

-- | Lift a monadic action producing code into the typed <a>Code</a>
--   representation
liftCode :: forall (r :: RuntimeRep) (a :: TYPE r) m. m (TExp a) -> Code m a

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <a>dyn</a> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | The name without its module prefix.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameBase ''Data.Either.Either
--   "Either"
--   
--   &gt;&gt;&gt; nameBase (mkName "foo")
--   "foo"
--   
--   &gt;&gt;&gt; nameBase (mkName "Module.foo")
--   "foo"
--   </pre>
nameBase :: Name -> String

-- | Module prefix of a name, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameModule ''Data.Either.Either
--   Just "Data.Either"
--   
--   &gt;&gt;&gt; nameModule (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; nameModule (mkName "Module.foo")
--   Just "Module"
--   </pre>
nameModule :: Name -> Maybe String

-- | A name's package, if it exists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; namePackage ''Data.Either.Either
--   Just "base"
--   
--   &gt;&gt;&gt; namePackage (mkName "foo")
--   Nothing
--   
--   &gt;&gt;&gt; namePackage (mkName "Module.foo")
--   Nothing
--   </pre>
namePackage :: Name -> Maybe String

-- | Returns whether a name represents an occurrence of a top-level
--   variable (<a>VarName</a>), data constructor (<a>DataName</a>), type
--   constructor, or type class (<a>TcClsName</a>). If we can't be sure, it
--   returns <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; nameSpace 'Prelude.id
--   Just VarName
--   
--   &gt;&gt;&gt; nameSpace (mkName "id")
--   Nothing -- only works for top-level variable names
--   
--   &gt;&gt;&gt; nameSpace 'Data.Maybe.Just
--   Just DataName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Maybe.Maybe
--   Just TcClsName
--   
--   &gt;&gt;&gt; nameSpace ''Data.Ord.Ord
--   Just TcClsName
--   </pre>
nameSpace :: Name -> Maybe NameSpace

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed sum type constructor
unboxedSumTypeName :: SumArity -> Name

-- | Unboxed sum data constructor
unboxedSumDataName :: SumAlt -> SumArity -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W Q)
--          deriving stock Eq }
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr ()] -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type data T x = A x | B (T x) }
--   </pre>
TypeDataD :: Name -> [TyVarBndr ()] -> Maybe Kind -> [Con] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr ()] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr ()] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance {-# OVERLAPS #-}
--           Show w =&gt; Show [w] where ds }
--   </pre>
InstanceD :: Maybe Overlap -> Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec

-- | <pre>
--   { type TypeRep :: k -&gt; Type }
--   </pre>
KiSigD :: Name -> Kind -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
ForeignD :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
InfixD :: Fixity -> Name -> Dec

-- | <pre>
--   { default (Integer, Double) }
--   </pre>
DefaultD :: [Type] -> Dec

-- | pragmas
PragmaD :: Pragma -> Dec

-- | data families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
DataFamilyD :: Name -> [TyVarBndr ()] -> Maybe Kind -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x]
--          = A x | B (T x)
--          deriving (Z,W)
--          deriving stock Eq }
--   </pre>
DataInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> [Con] -> [DerivClause] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x]
--           = A (B x)
--           deriving (Z,W)
--           deriving stock Eq }
--   </pre>
NewtypeInstD :: Cxt -> Maybe [TyVarBndr ()] -> Type -> Maybe Kind -> Con -> [DerivClause] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
TySynInstD :: TySynEqn -> Dec

-- | open type families (may also appear in [Dec] of <a>ClassD</a> and
--   <a>InstanceD</a>)
OpenTypeFamilyD :: TypeFamilyHead -> Dec

-- | <pre>
--   { type family F a b = (r :: *) | r -&gt; a where ... }
--   </pre>
ClosedTypeFamilyD :: TypeFamilyHead -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
RoleAnnotD :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving stock instance Ord a =&gt; Ord (Foo a) }
--   </pre>
StandaloneDerivD :: Maybe DerivStrategy -> Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
DefaultSigD :: Name -> Type -> Dec

-- | Pattern Synonyms
PatSynD :: Name -> PatSynArgs -> PatSynDir -> Pat -> Dec

-- | A pattern synonym's type signature.
PatSynSigD :: Name -> PatSynType -> Dec

-- | <pre>
--   { ?x = expr }
--   </pre>
--   
--   Implicit parameter binding declaration. Can only be used in let and
--   where clauses which consist entirely of implicit bindings.
ImplicitParamBindD :: String -> Exp -> Dec

-- | A single data constructor.
--   
--   The constructors for <a>Con</a> can roughly be divided up into two
--   categories: those for constructors with "vanilla" syntax
--   (<a>NormalC</a>, <a>RecC</a>, and <a>InfixC</a>), and those for
--   constructors with GADT syntax (<a>GadtC</a> and <a>RecGadtC</a>). The
--   <a>ForallC</a> constructor, which quantifies additional type variables
--   and class contexts, can surround either variety of constructor.
--   However, the type variables that it quantifies are different depending
--   on what constructor syntax is used:
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with vanilla syntax,
--   then the <a>ForallC</a> will only quantify <i>existential</i> type
--   variables. For example:</li>
--   </ul>
--   
--   <pre>
--   data Foo a = forall b. MkFoo a b
--   
--   </pre>
--   
--   In <tt>MkFoo</tt>, <a>ForallC</a> will quantify <tt>b</tt>, but not
--   <tt>a</tt>.
--   
--   <ul>
--   <li>If a <a>ForallC</a> surrounds a constructor with GADT syntax, then
--   the <a>ForallC</a> will quantify <i>all</i> type variables used in the
--   constructor. For example:</li>
--   </ul>
--   
--   <pre>
--   data Bar a b where
--     MkBar :: (a ~ b) =&gt; c -&gt; MkBar a b
--   
--   </pre>
--   
--   In <tt>MkBar</tt>, <a>ForallC</a> will quantify <tt>a</tt>,
--   <tt>b</tt>, and <tt>c</tt>.
--   
--   Multiplicity annotations for data types are currently not supported in
--   Template Haskell (i.e. all fields represented by Template Haskell will
--   be linear).
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [BangType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarBangType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: BangType -> Name -> BangType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr Specificity] -> Cxt -> Con -> Con

-- | <pre>
--   C :: a -&gt; b -&gt; T b Int
--   </pre>
GadtC :: [Name] -> [BangType] -> Type -> Con

-- | <pre>
--   C :: { v :: Int } -&gt; T b Int
--   </pre>
RecGadtC :: [Name] -> [VarBangType] -> Type -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause

-- | <a>SourceUnpackedness</a> corresponds to unpack annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceUnpackedness

-- | <pre>
--   C a
--   </pre>
NoSourceUnpackedness :: SourceUnpackedness

-- | <pre>
--   C { {-# NOUNPACK #-} } a
--   </pre>
SourceNoUnpack :: SourceUnpackedness

-- | <pre>
--   C { {-# UNPACK #-} } a
--   </pre>
SourceUnpack :: SourceUnpackedness

-- | <a>SourceStrictness</a> corresponds to strictness annotations found in
--   the source code.
--   
--   This may not agree with the annotations returned by
--   <a>reifyConStrictness</a>. See <a>reifyConStrictness</a> for more
--   information.
data SourceStrictness

-- | <pre>
--   C a
--   </pre>
NoSourceStrictness :: SourceStrictness

-- | <pre>
--   C {~}a
--   </pre>
SourceLazy :: SourceStrictness

-- | <pre>
--   C {!}a
--   </pre>
SourceStrict :: SourceStrictness

-- | Unlike <a>SourceStrictness</a> and <a>SourceUnpackedness</a>,
--   <a>DecidedStrictness</a> refers to the strictness annotations that the
--   compiler chooses for a data constructor field, which may be different
--   from what is written in source code.
--   
--   Note that non-unpacked strict fields are assigned <a>DecidedLazy</a>
--   when a bang would be inappropriate, such as the field of a newtype
--   constructor and fields that have an unlifted type.
--   
--   See <a>reifyConStrictness</a> for more information.
data DecidedStrictness

-- | Field inferred to not have a bang.
DecidedLazy :: DecidedStrictness

-- | Field inferred to have a bang.
DecidedStrict :: DecidedStrictness

-- | Field inferred to be unpacked.
DecidedUnpack :: DecidedStrictness
data Bang

-- | <pre>
--   C { {-# UNPACK #-} !}a
--   </pre>
Bang :: SourceUnpackedness -> SourceStrictness -> Bang

-- | As of <tt>template-haskell-2.11.0.0</tt>, <a>Strict</a> has been
--   replaced by <a>Bang</a>.
type Strict = Bang
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
CApi :: Callconv
Prim :: Callconv
JavaScript :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> Inline -> RuleMatch -> Phases -> Pragma
OpaqueP :: Name -> Pragma
SpecialiseP :: Name -> Type -> Maybe Inline -> Phases -> Pragma
SpecialiseInstP :: Type -> Pragma
RuleP :: String -> Maybe [TyVarBndr ()] -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
AnnP :: AnnTarget -> Exp -> Pragma
LineP :: Int -> String -> Pragma

-- | <pre>
--   { {-# COMPLETE C_1, ..., C_i [ :: T ] #-} }
--   </pre>
CompleteP :: [Name] -> Maybe Name -> Pragma
data Inline
NoInline :: Inline
Inline :: Inline
Inlinable :: Inline
data RuleMatch
ConLike :: RuleMatch
FunLike :: RuleMatch
data Phases
AllPhases :: Phases
FromPhase :: Int -> Phases
BeforePhase :: Int -> Phases
data RuleBndr
RuleVar :: Name -> RuleBndr
TypedRuleVar :: Name -> Type -> RuleBndr
data AnnTarget
ModuleAnnotation :: AnnTarget
TypeAnnotation :: Name -> AnnTarget
ValueAnnotation :: Name -> AnnTarget
data FunDep
FunDep :: [Name] -> [Name] -> FunDep

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type and the right-hand-side result.
--   
--   For instance, if you had the following type family:
--   
--   <pre>
--   type family Foo (a :: k) :: k where
--     forall k (a :: k). Foo @k a = a
--   </pre>
--   
--   The <tt>Foo @k a = a</tt> equation would be represented as follows:
--   
--   <pre>
--   <a>TySynEqn</a> (<a>Just</a> [<a>PlainTV</a> k, <a>KindedTV</a> a (<a>VarT</a> k)])
--              (<a>AppT</a> (<a>AppKindT</a> (<a>ConT</a> ''Foo) (<a>VarT</a> k)) (<a>VarT</a> a))
--              (<a>VarT</a> a)
--   </pre>
data TySynEqn
TySynEqn :: Maybe [TyVarBndr ()] -> Type -> Type -> TySynEqn

-- | Common elements of <a>OpenTypeFamilyD</a> and
--   <a>ClosedTypeFamilyD</a>. By analogy with "head" for type classes and
--   type class instances as defined in <i>Type classes: an exploration of
--   the design space</i>, the <tt>TypeFamilyHead</tt> is defined to be the
--   elements of the declaration between <tt>type family</tt> and
--   <tt>where</tt>.
data TypeFamilyHead
TypeFamilyHead :: Name -> [TyVarBndr ()] -> FamilyResultSig -> Maybe InjectivityAnn -> TypeFamilyHead
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | A pattern synonym's directionality.
data PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p
--   </pre>
Unidir :: PatSynDir

-- | <pre>
--   pattern P x {=} p
--   </pre>
ImplBidir :: PatSynDir

-- | <pre>
--   pattern P x {&lt;-} p where P x = e
--   </pre>
ExplBidir :: [Clause] -> PatSynDir

-- | A pattern synonym's argument type.
data PatSynArgs

-- | <pre>
--   pattern P {x y z} = p
--   </pre>
PrefixPatSyn :: [Name] -> PatSynArgs

-- | <pre>
--   pattern {x P y} = p
--   </pre>
InfixPatSyn :: Name -> Name -> PatSynArgs

-- | <pre>
--   pattern P { {x,y,z} } = p
--   </pre>
RecordPatSyn :: [Name] -> PatSynArgs
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or 'c'}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   { f @Int }
--   </pre>
AppTypeE :: Exp -> Type -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   { \ p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { \case m1; m2 }
--   </pre>
LamCaseE :: [Match] -> Exp

-- | <pre>
--   { \cases m1; m2 }
--   </pre>
LamCasesE :: [Clause] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (1,)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   TupE [Just (LitE (IntegerL 1)),Nothing]
--   </pre>
TupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (# e1,e2 #) }
--   </pre>
--   
--   The <a>Maybe</a> is necessary for handling tuple sections.
--   
--   <pre>
--   (# 'c', #)
--   </pre>
--   
--   translates to
--   
--   <pre>
--   UnboxedTupE [Just (LitE (CharL 'c')),Nothing]
--   </pre>
UnboxedTupE :: [Maybe Exp] -> Exp

-- | <pre>
--   { (#|e|#) }
--   </pre>
UnboxedSumE :: Exp -> SumAlt -> SumArity -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
MultiIfE :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let { x=e1; y=e2 } in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <tt>{ do { p &lt;- e1; e2 } }</tt> or a qualified do if the module
--   name is present
DoE :: Maybe ModName -> [Stmt] -> Exp

-- | <tt>{ mdo { x &lt;- e1 y; y &lt;- e2 x; } }</tt> or a qualified mdo if
--   the module name is present
MDoE :: Maybe ModName -> [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
StaticE :: Exp -> Exp

-- | <pre>
--   { _x }
--   </pre>
--   
--   This is used for holes or unresolved identifiers in AST quotes. Note
--   that it could either have a variable name or constructor name.
UnboundVarE :: Name -> Exp

-- | <tt>{ #x }</tt> ( Overloaded label )
LabelE :: String -> Exp

-- | <tt>{ ?x }</tt> ( Implicit parameter )
ImplicitParamVarE :: String -> Exp

-- | <tt>{ exp.field }</tt> ( Overloaded Record Dot )
GetFieldE :: Exp -> String -> Exp

-- | <tt>(.x)</tt> or <tt>(.x.y)</tt> (Record projections)
ProjectionE :: NonEmpty String -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
NormalG :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
PatG :: [Stmt] -> Guard
data Stmt

-- | <pre>
--   p &lt;- e
--   </pre>
BindS :: Pat -> Exp -> Stmt

-- | <pre>
--   { let { x=e1; y=e2 } }
--   </pre>
LetS :: [Dec] -> Stmt

-- | <pre>
--   e
--   </pre>
NoBindS :: Exp -> Stmt

-- | <tt>x &lt;- e1 | s2, s3 | s4</tt> (in <a>CompE</a>)
ParS :: [[Stmt]] -> Stmt

-- | <pre>
--   rec { s1; s2 }
--   </pre>
RecS :: [Stmt] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type <a>Addr#</a>
StringPrimL :: [Word8] -> Lit

-- | Some raw bytes, type <a>Addr#</a>:
BytesPrimL :: Bytes -> Lit
CharPrimL :: Char -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or 'c' }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { (# p1,p2 #) }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   { (#|p|#) }
--   </pre>
UnboxedSumP :: Pat -> SumAlt -> SumArity -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 @ty1 p1 p2} = e
--   </pre>
ConP :: Name -> [Type] -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; =&gt; &lt;type&gt;
--   </pre>
ForallT :: [TyVarBndr Specificity] -> Cxt -> Type -> Type

-- | <pre>
--   forall &lt;vars&gt; -&gt; &lt;type&gt;
--   </pre>
ForallVisT :: [TyVarBndr ()] -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   T @k t
--   </pre>
AppKindT :: Type -> Kind -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   'T
--   </pre>
PromotedT :: Name -> Type

-- | <pre>
--   T + T
--   </pre>
InfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T + T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
UInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
PromotedInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   T :+: T
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
PromotedUInfixT :: Type -> Name -> Type -> Type

-- | <pre>
--   (T)
--   </pre>
ParensT :: Type -> Type

-- | <tt>(,)</tt>, <tt>(,,)</tt>, etc.
TupleT :: Int -> Type

-- | <tt>(#,#)</tt>, <tt>(#,,#)</tt>, etc.
UnboxedTupleT :: Int -> Type

-- | <tt>(#|#)</tt>, <tt>(#||#)</tt>, etc.
UnboxedSumT :: SumArity -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   %n -&gt;
--   </pre>
--   
--   Generalised arrow type with multiplicity argument
MulArrowT :: Type

-- | <pre>
--   ~
--   </pre>
EqualityT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <tt>'()</tt>, <tt>'(,)</tt>, <tt>'(,,)</tt>, etc.
PromotedTupleT :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
PromotedNilT :: Type

-- | <pre>
--   '(:)
--   </pre>
PromotedConsT :: Type

-- | <pre>
--   *
--   </pre>
StarT :: Type

-- | <pre>
--   Constraint
--   </pre>
ConstraintT :: Type

-- | <tt>0</tt>, <tt>1</tt>, <tt>2</tt>, etc.
LitT :: TyLit -> Type

-- | <pre>
--   _
--   </pre>
WildCardT :: Type

-- | <pre>
--   ?x :: t
--   </pre>
ImplicitParamT :: String -> Type -> Type
data TyVarBndr flag

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> flag -> TyVarBndr flag

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> flag -> Kind -> TyVarBndr flag
data TyLit

-- | <pre>
--   2
--   </pre>
NumTyLit :: Integer -> TyLit

-- | <pre>
--   "Hello"
--   </pre>
StrTyLit :: String -> TyLit

-- | <tt>'C'</tt>, @since 4.16.0.0
CharTyLit :: Char -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = -- | @(Eq a, Ord b)@ [Pred]

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
NominalR :: Role

-- | <pre>
--   representational
--   </pre>
RepresentationalR :: Role

-- | <pre>
--   phantom
--   </pre>
PhantomR :: Role

-- | <pre>
--   _
--   </pre>
InferR :: Role
data Specificity

-- | <pre>
--   a
--   </pre>
SpecifiedSpec :: Specificity

-- | <pre>
--   {a}
--   </pre>
InferredSpec :: Specificity

-- | Type family result signature
data FamilyResultSig

-- | no signature
NoSig :: FamilyResultSig

-- | <pre>
--   k
--   </pre>
KindSig :: Kind -> FamilyResultSig

-- | <pre>
--   = r, = (r :: k)
--   </pre>
TyVarSig :: TyVarBndr () -> FamilyResultSig

-- | Injectivity annotation
data InjectivityAnn
InjectivityAnn :: Name -> [Name] -> InjectivityAnn

-- | A pattern synonym's type. Note that a pattern synonym's <i>fully</i>
--   specified type has a peculiar shape coming with two forall quantifiers
--   and two constraint contexts. For example, consider the pattern synonym
--   
--   <pre>
--   pattern P x1 x2 ... xn = &lt;some-pattern&gt;
--   </pre>
--   
--   P's complete type is of the following form
--   
--   <pre>
--   pattern P :: forall universals.   required constraints
--             =&gt; forall existentials. provided constraints
--             =&gt; t1 -&gt; t2 -&gt; ... -&gt; tn -&gt; t
--   </pre>
--   
--   consisting of four parts:
--   
--   <ol>
--   <li>the (possibly empty lists of) universally quantified type
--   variables and required constraints on them.</li>
--   <li>the (possibly empty lists of) existentially quantified type
--   variables and the provided constraints on them.</li>
--   <li>the types <tt>t1</tt>, <tt>t2</tt>, .., <tt>tn</tt> of
--   <tt>x1</tt>, <tt>x2</tt>, .., <tt>xn</tt>, respectively</li>
--   <li>the type <tt>t</tt> of <tt>&lt;some-pattern&gt;</tt>, mentioning
--   only universals.</li>
--   </ol>
--   
--   Pattern synonym types interact with TH when (a) reifying a pattern
--   synonym, (b) pretty printing, or (c) specifying a pattern synonym's
--   type signature explicitly:
--   
--   <ul>
--   <li>Reification always returns a pattern synonym's <i>fully</i>
--   specified type in abstract syntax.</li>
--   <li>Pretty printing via <a>pprPatSynType</a> abbreviates a pattern
--   synonym's type unambiguously in concrete syntax: The rule of thumb is
--   to print initial empty universals and the required context as <tt>()
--   =&gt;</tt>, if existentials and a provided context follow. If only
--   universals and their required context, but no existentials are
--   specified, only the universals and their required context are printed.
--   If both or none are specified, so both (or none) are printed.</li>
--   <li>When specifying a pattern synonym's type explicitly with
--   <a>PatSynSigD</a> either one of the universals, the existentials, or
--   their contexts may be left empty.</li>
--   </ul>
--   
--   See the GHC user's guide for more information on pattern synonyms and
--   their types:
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms</a>.
type PatSynType = Type
type BangType = (Bang, Type)
type VarBangType = (Name, Bang, Type)

-- | Add Haddock documentation to the specified location. This will
--   overwrite any documentation at the location if it already exists. This
--   will reify the specified name, so it must be in scope when you call
--   it. If you want to add documentation to something that you are
--   currently splicing, you can use <a>addModFinalizer</a> e.g.
--   
--   <pre>
--   do
--     let nm = mkName "x"
--     addModFinalizer $ putDoc (DeclDoc nm) "Hello"
--     [d| $(varP nm) = 42 |]
--   </pre>
--   
--   The helper functions <tt>withDecDoc</tt> and <tt>withDecsDoc</tt> will
--   do this for you, as will the <tt>funD_doc</tt> and other <tt>_doc</tt>
--   combinators. You most likely want to have the <tt>-haddock</tt> flag
--   turned on when using this. Adding documentation to anything outside of
--   the current module will cause an error.
putDoc :: DocLoc -> String -> Q ()

-- | Retreives the Haddock documentation at the specified location, if one
--   exists. It can be used to read documentation on things defined outside
--   of the current module, provided that those modules were compiled with
--   the <tt>-haddock</tt> flag.
getDoc :: DocLoc -> Q (Maybe String)

-- | A location at which to attach Haddock documentation. Note that adding
--   documentation to a <a>Name</a> defined oustide of the current module
--   will cause an error.
data DocLoc

-- | At the current module's header.
ModuleDoc :: DocLoc

-- | At a declaration, not necessarily top level.
DeclDoc :: Name -> DocLoc

-- | At a specific argument of a function, indexed by its position.
ArgDoc :: Name -> Int -> DocLoc

-- | At a class or family instance.
InstDoc :: Type -> DocLoc
class Ppr a
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
