-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common "Text.Regex.*" API for Regex matching
--   
--   This package does not provide the ability to do regular expression
--   matching. Instead, it provides the type classes that constitute the
--   abstract API that is implemented by <tt>regex-*</tt> backends such as:
--   
--   <ul>
--   <li><a>regex-posix</a></li>
--   <li><a>regex-parsec</a></li>
--   <li><a>regex-dfa</a></li>
--   <li><a>regex-tdfa</a></li>
--   <li><a>regex-pcre</a></li>
--   </ul>
--   
--   See also <a>https://wiki.haskell.org/Regular_expressions</a> for more
--   information.
@package regex-base
@version 0.94.0.2


-- | Classes and instances for Regex matching.
--   
--   All the <i>classes</i> are declared here, and some common type
--   aliases, and the <a>MatchResult</a> data type.
--   
--   The only <i>instances</i> here are for <a>Extract</a> <a>String</a>,
--   <a>Extract</a> <a>ByteString</a>, and <a>Extract</a> <a>Text</a>.
--   There are no data values. The <a>RegexContext</a> instances are in
--   <a>Text.Regex.Base.Context</a>, except for ones which run afoul of a
--   repeated variable (<tt><a>RegexContext</a> regex a a</tt>), which are
--   defined in each modules' String and ByteString modules.
module Text.Regex.Base.RegexLike

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | 0 based array, with 0th index indicating the full match. If the full
--   match location is not available, represent as (0,0).
type MatchArray = Array Int (MatchOffset, MatchLength)
type MatchText source = Array Int (source, (MatchOffset, MatchLength))

-- | This is the same as the type from JRegex.
data MatchResult a
MR :: a -> a -> a -> [a] -> Array Int a -> MatchResult a
[mrBefore] :: MatchResult a -> a
[mrMatch] :: MatchResult a -> a
[mrAfter] :: MatchResult a -> a
[mrSubList] :: MatchResult a -> [a]
[mrSubs] :: MatchResult a -> Array Int a

-- | Rather than carry them around separately, the options for how to
--   execute a regex are kept as part of the regex. There are two types of
--   options. Those that can only be specified at compilation time and
--   never changed are <tt>compOpt</tt>. Those that can be changed later
--   and affect how matching is performed are <tt>execOpt</tt>. The
--   actually types for these depend on the backend.
class RegexOptions regex compOpt execOpt | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt

-- | No options set at all in the backend.
blankCompOpt :: RegexOptions regex compOpt execOpt => compOpt

-- | No options set at all in the backend.
blankExecOpt :: RegexOptions regex compOpt execOpt => execOpt

-- | Reasonable options (extended, caseSensitive, multiline regex).
defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt

-- | Reasonable options (extended, caseSensitive, multiline regex).
defaultExecOpt :: RegexOptions regex compOpt execOpt => execOpt

-- | Forget old flags and use new ones.
setExecOpts :: RegexOptions regex compOpt execOpt => execOpt -> regex -> regex

-- | Retrieve the current flags.
getExecOpts :: RegexOptions regex compOpt execOpt => regex -> execOpt

-- | <tt>RegexMaker</tt> captures the creation of the compiled regular
--   expression from a source type and an option type. Methods
--   <a>makeRegexM</a> and <a>makeRegexM</a> report parse errors using
--   <tt>MonadError</tt>, usually (<tt>Either String regex</tt>).
--   
--   The <a>makeRegex</a> function has a default implementation that
--   depends on <a>makeRegexOpts</a> and uses <a>defaultCompOpt</a> and
--   <a>defaultExecOpt</a>. Similarly for <a>makeRegexM</a> and
--   <a>makeRegexOptsM</a>.
--   
--   There are also default implementaions for <a>makeRegexOpts</a> and
--   <a>makeRegexOptsM</a> in terms of each other. So a minimal instance
--   definition needs to only define one of these, hopefully
--   <a>makeRegexOptsM</a>.
class (RegexOptions regex compOpt execOpt) => RegexMaker regex compOpt execOpt source | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt

-- | Use the <a>defaultCompOpt</a> and <a>defaultExecOpt</a>.
makeRegex :: RegexMaker regex compOpt execOpt source => source -> regex

-- | Specify your own options.
makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex

-- | Use the <a>defaultCompOpt</a> and <a>defaultExecOpt</a>, reporting
--   errors with <a>fail</a>.
makeRegexM :: (RegexMaker regex compOpt execOpt source, MonadFail m) => source -> m regex

-- | Specify your own options, reporting errors with fail
makeRegexOptsM :: (RegexMaker regex compOpt execOpt source, MonadFail m) => compOpt -> execOpt -> source -> m regex

-- | RegexLike is parametrized on a regular expression type and a source
--   type to run the matching on.
--   
--   There are default implementations: <a>matchTest</a> and
--   <a>matchOnceText</a> use <a>matchOnce</a>; <a>matchCount</a> and
--   <a>matchAllText</a> use <a>matchAll</a>. Conversely, <a>matchOnce</a>
--   uses <a>matchOnceText</a> and <a>matchAll</a> uses
--   <a>matchAllText</a>. So a minimal complete instance need to provide at
--   least (<a>matchOnce</a> or <a>matchOnceText</a>) and (<a>matchAll</a>
--   or <a>matchAllText</a>). Additional definitions are often provided
--   where they will increase efficiency.
--   
--   <pre>
--   [ c | let notVowel = makeRegex "[^aeiou]" :: Regex, c &lt;- ['a'..'z'], matchTest notVowel [c]  ]
--   
--   "bcdfghjklmnpqrstvwxyz"
--   </pre>
--   
--   The strictness of these functions is instance dependent.
class (Extract source) => RegexLike regex source

-- | This returns the first match in the source (it checks the whole
--   source, not just at the start). This returns an array of
--   (offset,length) index pairs for the match and captured substrings. The
--   offset is 0-based. A (-1) for an offset means a failure to match. The
--   lower bound of the array is 0, and the 0th element is the
--   (offset,length) for the whole match.
matchOnce :: RegexLike regex source => regex -> source -> Maybe MatchArray

-- | <tt>matchAll</tt> returns a list of matches. The matches are in order
--   and do not overlap. If any match succeeds but has 0 length then this
--   will be the last match in the list.
matchAll :: RegexLike regex source => regex -> source -> [MatchArray]

-- | <tt>matchCount</tt> returns the number of non-overlapping matches
--   returned by <tt>matchAll</tt>.
matchCount :: RegexLike regex source => regex -> source -> Int

-- | <tt>matchTest</tt> returns <tt>True</tt> if there is a match somewhere
--   in the source (it checks the whole source not just at the start).
matchTest :: RegexLike regex source => regex -> source -> Bool

-- | This is <tt>matchAll</tt> with the actual subsections of the source
--   instead of just the (offset,length) information.
matchAllText :: RegexLike regex source => regex -> source -> [MatchText source]

-- | This can return a tuple of three items: the source before the match,
--   an array of the match and captured substrings (with their indices),
--   and the source after the match.
matchOnceText :: RegexLike regex source => regex -> source -> Maybe (source, MatchText source, source)

-- | <tt>RegexContext</tt> is the polymorphic interface to do matching.
--   Since <tt>target</tt> is polymorphic you may need to supply the type
--   explicitly in contexts where it cannot be inferred.
--   
--   The monadic <a>matchM</a> version uses <a>fail</a> to report when the
--   <tt>regex</tt> has no match in <tt>source</tt>. Two examples:
--   
--   Here the contest <a>Bool</a> is inferred:
--   
--   <pre>
--   [ c | let notVowel = makeRegex "[^aeiou]" :: Regex, c &lt;- ['a'..'z'], match notVowel [c]  ]
--   
--   "bcdfghjklmnpqrstvwxyz"
--   </pre>
--   
--   Here the context <tt>[String]</tt> must be supplied:
--   
--   <pre>
--   let notVowel = (makeRegex "[^aeiou]" :: Regex )
--   in do { c &lt;- ['a'..'z'] ; matchM notVowel [c] } :: [String]
--   
--   ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"]
--   </pre>
class (RegexLike regex source) => RegexContext regex source target
match :: RegexContext regex source target => regex -> source -> target
matchM :: (RegexContext regex source target, MonadFail m) => regex -> source -> m target

-- | Extract allows for indexing operations on <a>String</a> or
--   <tt>ByteString</tt>.
class Extract source

-- | <tt>before</tt> is a renamed <a>take</a>.
before :: Extract source => Int -> source -> source

-- | <tt>after</tt> is a renamed <a>drop</a>.
after :: Extract source => Int -> source -> source

-- | When there is no match, this can construct an empty data value.
empty :: Extract source => source

-- | <tt>extract</tt> takes an offset and length, and has this default
--   implementation:
--   
--   <pre>
--   extract (off, len) source = before len (after off source)
--   </pre>
extract :: Extract source => (Int, Int) -> source -> source

-- | Used in results of <a>RegexContext</a> instances.
newtype AllSubmatches f b
AllSubmatches :: f b -> AllSubmatches f b
[getAllSubmatches] :: AllSubmatches f b -> f b

-- | Used in results of <a>RegexContext</a> instances.
newtype AllTextSubmatches f b
AllTextSubmatches :: f b -> AllTextSubmatches f b
[getAllTextSubmatches] :: AllTextSubmatches f b -> f b

-- | Used in results of <a>RegexContext</a> instances.
newtype AllMatches f b
AllMatches :: f b -> AllMatches f b
[getAllMatches] :: AllMatches f b -> f b

-- | Used in results of <a>RegexContext</a> instances.
newtype AllTextMatches f b
AllTextMatches :: f b -> AllTextMatches f b
[getAllTextMatches] :: AllTextMatches f b -> f b
instance Text.Regex.Base.RegexLike.Extract GHC.Base.String
instance Text.Regex.Base.RegexLike.Extract Data.ByteString.Internal.Type.ByteString
instance Text.Regex.Base.RegexLike.Extract Data.ByteString.Lazy.Internal.ByteString
instance Text.Regex.Base.RegexLike.Extract (Data.Sequence.Internal.Seq a)
instance Text.Regex.Base.RegexLike.Extract Data.Text.Internal.Text
instance Text.Regex.Base.RegexLike.Extract Data.Text.Internal.Lazy.Text


-- | This is a module of instances of <a>RegexContext</a> (defined in
--   <a>Text.Regex.Base.RegexLike</a>). Nothing else is exported. This is
--   usually imported via the <a>Text.Regex.Base</a> convenience package
--   which itself is re-exported from newer <tt>Text.Regex.XXX</tt> modules
--   provided by the different <tt>regex-xxx</tt> backends.
--   
--   These instances work for all the supported types and backends
--   interchangeably. These instances provide the different results that
--   can be gotten from a <a>match</a> or <a>matchM</a> operation (often
--   via the <tt>=~</tt> and <tt>=~~</tt> operators with combine
--   <tt>makeRegex</tt> with <a>match</a> and <a>matchM</a> respectively).
--   This module name is <tt>Context</tt> because they operators are
--   context dependent: use them in a context that expects an <a>Int</a>
--   and you get a count of matches, use them in a <a>Bool</a> context and
--   get <a>True</a> if there is a match, etc.
--   
--   <tt><a>RegexContext</a> a b c</tt> takes a regular expression suppied
--   in a type <tt>a</tt> generated by <tt>RegexMaker</tt> and a target
--   text supplied in type <tt>b</tt> to a result type <tt>c</tt> using the
--   <a>match</a> class function. The <a>matchM</a> class function works
--   like <a>match</a> unless there is no match found, in which case it
--   calls <a>fail</a> in the (arbitrary) monad context.
--   
--   There are a few type synonyms from <a>Text.Regex.Base.RegexLike</a>
--   that are used here:
--   
--   <pre>
--   -- | 0 based index from start of source, or (-1) for unused
--   type MatchOffset = Int
--   -- | non-negative length of a match
--   type MatchLength = Int
--   type MatchArray = Array Int (MatchOffset, MatchLength)
--   type MatchText source = Array Int (source, (MatchOffset, MatchLength))
--   </pre>
--   
--   There are also a few newtypes that used to prevent any possible
--   overlap of types, which were not needed for GHC's late overlap
--   detection but are needed for use in Hugs.
--   
--   <pre>
--   newtype AllSubmatches     f b = AllSubmatches     { getAllSubmatches     :: f b }
--   newtype AllTextSubmatches f b = AllTextSubmatches { getAllTextSubmatches :: f b }
--   newtype AllMatches        f b = AllMatches        { getAllMatches        :: f b }
--   newtype AllTextMatches    f b = AllTextMatches    { getAllTextMatches    :: f b }
--   </pre>
--   
--   The newtypes' <tt>f</tt> parameters are the containers, usually
--   <tt>[]</tt> or <tt>Array Int</tt>, (where the arrays all have lower
--   bound 0).
--   
--   The two <tt>Submatches</tt> newtypes return only information on the
--   first match. The other two newtypes return information on all the
--   non-overlapping matches. The two <tt>Text</tt> newtypes are used to
--   mark result types that contain the same type as the target text.
--   
--   Where provided, noncaptured submatches will have a <a>MatchOffset</a>
--   of (-1) and non-negative otherwise. The semantics of submatches depend
--   on the backend and its compile and execution options. Where provided,
--   <a>MatchLength</a> will always be non-negative. Arrays with no
--   elements are returned with bounds of (1,0). Arrays with elements will
--   have a lower bound of 0.
--   
--   XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX
--   
--   These are for finding the first match in the target text:
--   
--   <tt> <a>RegexContext</a> a b Bool </tt>: Whether there is any match or
--   not.
--   
--   <tt> <a>RegexContext</a> a b () </tt>: Useful as a guard with
--   <tt>matchM</tt> or <tt>=~~</tt> in a monad, since failure to match
--   calls <a>fail</a>.
--   
--   <tt> <a>RegexContext</a> a b b </tt>: This returns the text of the
--   whole match. It will return <a>empty</a> from the <a>Extract</a> type
--   class if there is no match. These are defined in each backend module,
--   but documented here for convenience.
--   
--   <tt> <a>RegexContext</a> a b (<a>MatchOffset</a>, <a>MatchLength</a>)
--   </tt>: This returns the initial index and length of the whole match.
--   MatchLength will always be non-negative, and 0 for a failed match.
--   
--   <tt> <a>RegexContext</a> a b (<a>MatchResult</a> b) </tt>: The
--   <a>MatchResult</a> structure with details for the match. This is the
--   structure copied from the old <tt>JRegex</tt> pacakge.
--   
--   <tt> <a>RegexContext</a> a b (b, b, b) </tt>: The text before the
--   match, the text of the match, the text after the match
--   
--   <tt> <a>RegexContext</a> a b (b, <a>MatchText</a> b, b) </tt>: The
--   text before the match, the details of the match, and the text after
--   the match
--   
--   <tt> <a>RegexContext</a> a b (b, b, b, [b]) </tt>: The text before the
--   match, the text of the match, the text after the match, and a list of
--   the text of the 1st and higher sub-parts of the match. This is the
--   same return value as used in the old <tt>Text.Regex</tt> API.
--   
--   Two containers of the submatch offset information:
--   
--   <tt> <a>RegexContext</a> a b <a>MatchArray</a> </tt>: Array of
--   <tt>(<a>MatchOffset</a>, <a>MatchLength</a>)</tt> for all the sub
--   matches. The whole match is at the intial 0th index. Noncaptured
--   submatches will have a <tt><a>MatchOffset</a></tt> of (-1) The array
--   will have no elements and bounds (1,0) if there is no match.
--   
--   <tt> <a>RegexContext</a> a b (<a>AllSubmatches</a> []
--   (<a>MatchOffset</a>, <a>MatchLength</a>) </tt>: List of
--   <tt>(<a>MatchOffset</a>, <a>MatchLength</a>)</tt> The whole match is
--   the first element, the rest are the submatches (if any) in order. The
--   list is empty if there is no match.
--   
--   Two containers of the submatch text and offset information:
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextSubmatches</a> (Array Int) (b, (<a>MatchOffset</a>, <a>MatchLength</a>)))
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextSubmatches</a> [] (b, (<a>MatchOffset</a>, <a>MatchLength</a>)))
--   </pre>
--   
--   Two containers of the submatch text information:
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextSubmatches</a> [] b)
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextSubmatches</a> (Array Int) b)
--   </pre>
--   
--   These instances are for all the matches (non-overlapping). Note that
--   backends are supposed to supply <a>RegexLike</a> instances for which
--   the default <a>matchAll</a> and <a>matchAllText</a> stop searching
--   after returning any successful but empty match.
--   
--   <tt> <a>RegexContext</a> a b Int </tt>: The number of matches,
--   non-negative.
--   
--   Two containers for locations of all matches:
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllMatches</a> [] (<a>MatchOffset</a>, <a>MatchLength</a>))
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllMatches</a> (Array Int) (<a>MatchOffset</a>, <a>MatchLength</a>))
--   </pre>
--   
--   Two containers for the locations of all matches and their submatches:
--   
--   <pre>
--   <a>RegexContext</a> a b [<a>MatchArray</a>]
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllMatches</a> (Array Int) <a>MatchArray</a>)
--   </pre>
--   
--   Two containers for the text and locations of all matches and their
--   submatches:
--   
--   <pre>
--   <a>RegexContext</a> a b [<a>MatchText</a> b]
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextMatches</a> (Array Int) (<a>MatchText</a> b))
--   </pre>
--   
--   Two containers for text of all matches: <tt> <a>RegexContext</a> a b
--   (<a>AllTextMatches</a> [] b) </tt>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextMatches</a> (Array Int) b)
--   </pre>
--   
--   Four containers for text of all matches and their submatches:
--   
--   <pre>
--   <a>RegexContext</a> a b [[b]]
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextMatches</a> (Array Int) [b])
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextMatches</a> [] (Array Int b))
--   </pre>
--   
--   <pre>
--   <a>RegexContext</a> a b (<a>AllTextMatches</a> (Array Int) (Array Int b))
--   </pre>
--   
--   Unused matches are <a>empty</a> (defined via <a>Extract</a>)
module Text.Regex.Base.Context
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b GHC.Types.Bool
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b ()
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b GHC.Types.Int
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.MatchResult b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, Text.Regex.Base.RegexLike.MatchText b, b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, b, b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, b, b, [b])
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b Text.Regex.Base.RegexLike.MatchArray
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllSubmatches [] (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches (GHC.Arr.Array GHC.Types.Int) (b, (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches [] (b, (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches [] b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches (GHC.Arr.Array GHC.Types.Int) b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches [] (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches (GHC.Arr.Array GHC.Types.Int) (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [Text.Regex.Base.RegexLike.MatchArray]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches (GHC.Arr.Array GHC.Types.Int) Text.Regex.Base.RegexLike.MatchArray)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [Text.Regex.Base.RegexLike.MatchText b]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) (Text.Regex.Base.RegexLike.MatchText b))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches [] b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [[b]]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) [b])
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches [] (GHC.Arr.Array GHC.Types.Int b))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) (GHC.Arr.Array GHC.Types.Int b))


-- | Classes and instances for Regex matching.
--   
--   This module merely imports and re-exports the common part of the new
--   api: <a>Text.Regex.Base.RegexLike</a> and
--   <a>Text.Regex.Base.Context</a>.
--   
--   To see what result types the instances of RegexContext can produce,
--   please read the <a>Text.Regex.Base.Context</a> haddock documentation.
--   
--   This does not provide any of the backends, just the common interface
--   they all use. The modules which provide the backends and their cabal
--   packages are:
--   
--   <ul>
--   <li><tt><a>Text.Regex.Posix</a></tt> from <a>regex-posix</a></li>
--   <li><tt><a>Text.Regex</a></tt> from <a>regex-compat</a> (uses
--   <a>regex-posix</a>)</li>
--   <li><tt><a>Text.Regex.Parsec</a></tt> from <a>regex-parsec</a></li>
--   <li><tt><a>Text.Regex.DFA</a></tt> from <a>regex-dfa</a></li>
--   <li><tt><a>Text.Regex.PCRE</a></tt> from <a>regex-pcre</a></li>
--   <li><tt><a>Test.Regex.TRE</a></tt> from <a>regex-tre</a></li>
--   </ul>
--   
--   In fact, just importing one of the backends is adequate, you do not
--   also need to import this module.
--   
--   <h2>Example</h2>
--   
--   The code
--   
--   <pre>
--   import Text.Regex.Base
--   import Text.Regex.Posix ((=~),(=~~)) -- or TDFA or PCRE or ...
--   
--   main = do
--       print b
--       print c
--       print d
--     where
--       b :: Bool
--       b = ("abaca" =~ "(.)a")
--       c :: [MatchArray]
--       c = ("abaca" =~ "(.)a")
--       d :: Maybe (String,String,String,[String])
--       d = ("abaca" =~~ "(.)a")
--   </pre>
--   
--   will output
--   
--   <pre>
--   True
--   [array (0,1) [(0,(1,2)),(1,(1,1))],array (0,1) [(0,(3,2)),(1,(3,1))]]
--   Just ("a","ba","ca",["b"])
--   </pre>
module Text.Regex.Base
getVersion_Text_Regex_Base :: Version


-- | Helper functions for defining certain instances of
--   <a>RegexContext</a>. These help when defining instances of
--   <a>RegexContext</a> with repeated types:
--   
--   <pre>
--   instance (RegexLike regex source) =&gt; RegexContext regex source source where
--   </pre>
--   
--   runs into overlapping restrictions. To avoid this I have each backend
--   define, for its own <tt>Regex</tt> type:
--   
--   <pre>
--   instance RegexContext Regex String String where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
--   
--   <pre>
--   instance RegexContext Regex ByteString ByteString where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
--   
--   <pre>
--   instance RegexContext Regex Text Text where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
module Text.Regex.Base.Impl
polymatch :: RegexLike a b => a -> b -> b
polymatchM :: (RegexLike a b, MonadFail m) => a -> b -> m b
