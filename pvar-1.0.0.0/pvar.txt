-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mutable variable with primitive values
--   
--   Mutable variable <a>PVar</a> that is backed by a single value
--   <a>MutableByteArray</a>
@package pvar
@version 1.0.0.0


module Data.Primitive.PVar.Unsafe

-- | Mutable variable with primitive value.
data PVar a s
PVar :: MutableByteArray# s -> PVar a s

-- | Create a mutable variable in unpinned and unititialized memory
rawPVar :: forall a m s. (MonadPrim s m, Prim a) => m (PVar a s)

-- | Create a mutable variable in pinned memory with uninitialized memory.
rawPinnedPVar :: forall a m s. (MonadPrim s m, Prim a) => m (PVar a s)

-- | Create a mutable variable in pinned uninitialized memory.
rawAlignedPinnedPVar :: forall a m s. (MonadPrim s m, Prim a) => m (PVar a s)

-- | Create a mutable variable in pinned uninitialized memory using
--   Storable interface for getting the number of bytes for memory
--   allocation.
rawStorablePVar :: forall a m s. (MonadPrim s m, Storable a) => m (PVar a s)

-- | Create a mutable variable in pinned uninitialized memory using
--   Storable interface for getting the number of bytes for memory
--   allocation and alignement.
rawAlignedStorablePVar :: forall a m s. (MonadPrim s m, Storable a) => m (PVar a s)

-- | Use <a>Storable</a> reading functionality inside the
--   <tt>PrimMonad</tt>.
peekPrim :: (Storable a, MonadPrim s m) => Ptr a -> m a

-- | Use <a>Storable</a> wrting functionality inside the
--   <tt>PrimMonad</tt>.
pokePrim :: (Storable a, MonadPrim s m) => Ptr a -> a -> m ()

-- | Extract the address to the mutable variable, but only if it is backed
--   by pinned memory. It is unsafe because even for pinned memory memory
--   can be deallocated if associated <a>PVar</a> goes out of scope. Use
--   <a>withPtrPVar</a> or <a>toForeignPtr</a> instead.
toPtrPVar :: PVar a s -> Maybe (Ptr a)

-- | Get the address to the contents. This is highly unsafe, espcially if
--   memory is not pinned
unsafeToPtrPVar :: PVar a s -> Ptr a

-- | Convert <a>PVar</a> into a <a>ForeignPtr</a>, very unsafe if not
--   backed by pinned memory.
unsafeToForeignPtrPVar :: PVar a s -> ForeignPtr a

-- | Reset contents of a mutable variable to zero.
zeroPVar :: (MonadPrim s m, Prim a) => PVar a s -> m ()

-- | Get the size of the mutable variable in bytes as an unpacked integer
sizeOfPVar# :: forall a s. Prim a => PVar a s -> Int#

-- | Get the alignment of the mutable variable in bytes as an unpacked
--   integer
alignmentPVar# :: forall a s. Prim a => PVar a s -> Int#

-- | Fill the contents of mutable variable with byte <tt>c</tt>
setPVar# :: (MonadPrim s m, Prim a) => PVar a s -> Int# -> m ()

-- | Using <a>casIntArray#</a> perform atomic modification of an integer
--   element in a <a>MutableByteArray#</a>. Implies a full memory barrier.
atomicModifyIntArray# :: MutableByteArray# d -> Int# -> (Int# -> (# Int#, b #)) -> State# d -> (# State# d, b #)

-- | Uses <a>casIntArray#</a> to perform atomic modification of an integer
--   element in a <a>MutableByteArray#</a>. Implies a full memory barrier.
atomicModifyIntArray_# :: MutableByteArray# d -> Int# -> (Int# -> Int#) -> State# d -> State# d

-- | Copy the value from a frozen <a>ByteArray</a> into a mutable variable
--   at specified index. Index of array is not checked and can result in an
--   unchecked exception when incorrect
copyFromByteArrayPVar :: (MonadPrim s m, Prim a) => ByteArray -> Int -> PVar a s -> m ()

-- | Copy the value from MutableByteArray at specified index into the
--   mutable variable. Index of array is not checked and can result in an
--   unchecked exception when incorrect
copyFromMutableByteArrayPVar :: (MonadPrim s m, Prim a) => MutableByteArray s -> Int -> PVar a s -> m ()

-- | Copy the value from a mutable variable into a mutable array at the
--   specified index. Index of array is not checked and can result in an
--   unchecked exception when incorrect
copyPVarToMutableByteArray :: (MonadPrim s m, Prim a) => PVar a s -> MutableByteArray s -> Int -> m ()

-- | Check whether or not the <a>ByteArray</a> is pinned.
--   
--   <i><b>Note</b></i> - This function uses GHC built-in functions for GHC
--   8.2 and newer, but for older versions it fallsback onto custom
--   implementation.
isByteArrayPinned :: ByteArray -> Bool

-- | Check whether or not the <a>MutableByteArray</a> is pinned.
--   
--   <i><b>Note</b></i> - This function uses GHC built-in functions for GHC
--   8.2 and newer, but for older versions it fallsback onto custom
--   implementation.
isMutableByteArrayPinned :: MutableByteArray s -> Bool

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move during
--   GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# d -> Int#

-- | Show the type name
showsType :: Typeable t => proxy t -> ShowS

-- | Unwrap the primitive <a>Int</a>
unI# :: Int -> Int#


module Data.Primitive.PVar

-- | Mutable variable with primitive value.
data PVar a s

-- | Synonym for <a>RealWorld</a>
type RW = RealWorld

-- | Create a mutable variable in unpinned memory (i.e. GC can move it)
--   with an initial value. This is a prefered way to create a mutable
--   variable, since it will not contribute to memory fragmentation. For
--   pinned memory versions see <a>newPinnedPVar</a> and
--   <a>newAlignedPinnedPVar</a>
newPVar :: (MonadPrim s m, Prim a) => a -> m (PVar a s)

-- | Run an <a>ST</a> action on a mutable variable.
withPVarST :: Prim p => p -> (forall s. PVar p s -> ST s a) -> a

-- | Read a value from a mutable variable
readPVar :: (MonadPrim s m, Prim a) => PVar a s -> m a

-- | Write a value into a mutable variable
writePVar :: (MonadPrim s m, Prim a) => PVar a s -> a -> m ()

-- | Apply a pure function to the contents of a mutable variable. Returns
--   the artifact of computation.
modifyPVar :: (MonadPrim s m, Prim a) => PVar a s -> (a -> (a, b)) -> m b

-- | Apply a pure function to the contents of a mutable variable.
modifyPVar_ :: (MonadPrim s m, Prim a) => PVar a s -> (a -> a) -> m ()

-- | Apply a pure function to the contents of a mutable variable. Returns
--   the old value.
fetchModifyPVar :: (MonadPrim s m, Prim a) => PVar a s -> (a -> a) -> m a

-- | Apply a pure function to the contents of a mutable variable. Returns
--   the new value.
modifyFetchPVar :: (MonadPrim s m, Prim a) => PVar a s -> (a -> a) -> m a

-- | Apply a monadic action to the contents of a mutable variable. Returns
--   the artifact of computation.
modifyPVarM :: (MonadPrim s m, Prim a) => PVar a s -> (a -> m (a, b)) -> m b

-- | Apply a monadic action to the contents of a mutable variable.
modifyPVarM_ :: (MonadPrim s m, Prim a) => PVar a s -> (a -> m a) -> m ()

-- | Apply a monadic action to the contents of a mutable variable. Returns
--   the old value.
fetchModifyPVarM :: (MonadPrim s m, Prim a) => PVar a s -> (a -> m a) -> m a

-- | Apply a monadic action to the contents of a mutable variable. Returns
--   the new value.
modifyFetchPVarM :: (MonadPrim s m, Prim a) => PVar a s -> (a -> m a) -> m a

-- | Swap contents of two mutable variables.
swapPVars_ :: (MonadPrim s m, Prim a) => PVar a s -> PVar a s -> m ()

-- | Swap contents of two mutable variables. Returns their old values.
swapPVars :: (MonadPrim s m, Prim a) => PVar a s -> PVar a s -> m (a, a)

-- | Copy contents of one mutable variable <a>PVar</a> into another
copyPVar :: (MonadPrim s m, Prim a) => PVar a s -> PVar a s -> m ()

-- | Size in bytes of a value stored inside the mutable variable.
--   <a>PVar</a> itself is neither accessed nor evaluated.
sizeOfPVar :: Prim a => PVar a s -> Int

-- | Alignment in bytes of the value stored inside of the mutable variable.
--   <a>PVar</a> itself is neither accessed nor evaluated.
alignmentPVar :: Prim a => PVar a s -> Int

-- | Create a mutable variable in pinned memory with an initial value.
newPinnedPVar :: (MonadPrim s m, Prim a) => a -> m (PVar a s)

-- | Create a mutable variable in pinned memory with an initial value and
--   aligned according to its <a>alignment</a>
newAlignedPinnedPVar :: (MonadPrim s m, Prim a) => a -> m (PVar a s)

-- | Apply an action to the <a>Ptr</a> that references the mutable
--   variable, but only if it is backed by pinned memory, cause otherwise
--   it would be unsafe.
withPtrPVar :: (MonadPrim s m, Prim a) => PVar a n -> (Ptr a -> m b) -> m (Maybe b)

-- | Apply an action to the newly allocated <a>PVar</a> and to the
--   <a>Ptr</a> that references it. Memory allocated with number of bytes
--   specified by <tt><a>sizeOf</a> a</tt> is allocated and pinned,
--   therefore it is safe to operate directly with the pointer as well as
--   over FFI. Returning the pointer from the supplied action would be very
--   unsafe, therefore return the <a>PVar</a> if you still need it
--   afterwards, garbage collector will cleanup the memory when it is no
--   longer needed.
withStorablePVar :: (MonadPrim s m, Storable a) => a -> (PVar a s -> Ptr a -> m b) -> m b

-- | Same <a>withStorablePVar</a>, except memory is aligned according to
--   <a>alignment</a>.
withAlignedStorablePVar :: (MonadPrim s m, Storable a) => a -> (PVar a s -> Ptr a -> m b) -> m b

-- | Copy contents of a mutable variable <a>PVar</a> into a pointer
--   <a>Ptr</a>
copyPVarToPtr :: (MonadPrim s m, Prim a) => PVar a s -> Ptr a -> m ()

-- | Convert <a>PVar</a> into a <a>ForeignPtr</a>, but only if it is backed
--   by pinned memory.
toForeignPtrPVar :: PVar a s -> Maybe (ForeignPtr a)

-- | Check if <a>PVar</a> is backed by pinned memory or not
isPinnedPVar :: PVar a s -> Bool

-- | Use <a>Storable</a> reading functionality inside the
--   <tt>PrimMonad</tt>.
peekPrim :: (Storable a, MonadPrim s m) => Ptr a -> m a

-- | Use <a>Storable</a> wrting functionality inside the
--   <tt>PrimMonad</tt>.
pokePrim :: (Storable a, MonadPrim s m) => Ptr a -> a -> m ()

-- | Apply a function to an integer element of a <a>PVar</a> atomically.
--   Implies a full memory barrier.
atomicModifyIntPVar :: MonadPrim s m => PVar Int s -> (Int -> (Int, a)) -> m a

-- | Apply a function to an integer element of a <a>PVar</a> atomically.
--   Returns the old value. Implies a full memory barrier.
atomicModifyIntPVar_ :: MonadPrim s m => PVar Int s -> (Int -> Int) -> m ()

-- | Apply a function to an integer element of a <a>PVar</a> atomically.
--   Implies a full memory barrier. Returns the new value.
atomicFetchModifyIntPVar :: MonadPrim s m => PVar Int s -> (Int -> Int) -> m Int

-- | Apply a function to an integer element of a <a>PVar</a> atomically.
--   Implies a full memory barrier. Returns the new value.
atomicModifyFetchIntPVar :: MonadPrim s m => PVar Int s -> (Int -> Int) -> m Int

-- | Read a value from <a>PVar</a> atomically. Implies a full memory
--   barrier.
atomicReadIntPVar :: MonadPrim s m => PVar Int s -> m Int

-- | Write a value into an <a>PVar</a> atomically. Implies a full memory
--   barrier.
atomicWriteIntPVar :: MonadPrim s m => PVar Int s -> Int -> m ()

-- | Compare and swap. This is also a function that is used to implement
--   <a>atomicModifyIntPVar</a>. Implies a full memory barrier.
casIntPVar :: MonadPrim s m => PVar Int s -> Int -> Int -> m Int

-- | Add two numbers, corresponds to <tt>(<a>+</a>)</tt> done atomically.
--   Returns the previous value of the mutable variable. Implies a full
--   memory barrier.
atomicAddIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Subtract two numbers, corresponds to <tt>(<a>-</a>)</tt> done
--   atomically. Returns the previous value of the mutable variable.
--   Implies a full memory barrier.
atomicSubIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Binary conjuction (AND), corresponds to <tt>(<a>.&amp;.</a>)</tt> done
--   atomically. Returns the previous value of the mutable variable.
--   Implies a full memory barrier.
atomicAndIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Binary negation of conjuction (NAND), corresponds to <tt>\x y -&gt;
--   <a>complement</a> (x <a>.&amp;.</a> y)</tt> done atomically. Returns
--   the previous value of the mutable variable. Implies a full memory
--   barrier.
atomicNandIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Binary disjunction (OR), corresponds to <tt>(<a>.|.</a>)</tt> done
--   atomically. Returns the previous value of the mutable variable.
--   Implies a full memory barrier.
atomicOrIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Binary exclusive disjunction (XOR), corresponds to <tt><a>xor</a></tt>
--   done atomically. Returns the previous value of the mutable variable.
--   Implies a full memory barrier.
atomicXorIntPVar :: MonadPrim s m => PVar Int s -> Int -> m Int

-- | Binary negation (NOT), corresponds to ones' <tt><a>complement</a></tt>
--   done atomically. Returns the previous value of the mutable variable.
--   Implies a full memory barrier.
atomicNotIntPVar :: MonadPrim s m => PVar Int s -> m Int

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class () => Prim a

-- | <tt>PrimMonad'</tt>s state token type can be annoying to handle in
--   constraints. This typeclass lets users (visually) notice
--   <a>PrimState</a> equality constraints less, by witnessing that <tt>s ~
--   <a>PrimState</a> m</tt>.
class (PrimMonad m, s ~ PrimState m) => MonadPrim s (m :: Type -> Type)

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type.
    type family PrimState (m :: Type -> Type);
}

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Size of values of type <tt>a</tt>. The argument is not used.
--   
--   This function has existed since 0.1, but was moved from
--   <a>Primitive</a> to <a>Types</a> in version 0.6.3.0.
sizeOf :: Prim a => a -> Int

-- | Alignment of values of type <tt>a</tt>. The argument is not used.
--   
--   This function has existed since 0.1, but was moved from
--   <a>Primitive</a> to <a>Types</a> in version 0.6.3.0.
alignment :: Prim a => a -> Int

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data () => ST s a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()
