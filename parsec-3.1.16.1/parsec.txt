-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic parser combinators
--   
--   Parsec is designed from scratch as an industrial-strength parser
--   library. It is simple, safe, well documented (on the package
--   homepage), has extensive libraries, good error messages, and is fast.
--   It is defined as a monad transformer that can be stacked on arbitrary
--   monads, and it is also parametric in the input stream type.
--   
--   The main entry point is the <a>Text.Parsec</a> module which provides
--   defaults for parsing <a>Char</a>acter data.
--   
--   The <a>Text.ParserCombinators.Parsec</a> module hierarchy contains the
--   legacy <tt>parsec-2</tt> API and may be removed at some point in the
--   future.
@package parsec
@version 3.1.16.1


-- | Textual source positions.
module Text.Parsec.Pos
type SourceName = String
type Line = Int
type Column = Int

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, line number
--   and column number.
newPos :: SourceName -> Line -> Column -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, and line
--   number and column number set to 1, the upper left.
initialPos :: SourceName -> SourcePos

-- | Update a source position given a character. If the character is a
--   newline ('\n') or carriage return ('\r') the line number is
--   incremented by 1. If the character is a tab ('t') the column number is
--   incremented to the nearest 8'th column, ie. <tt>column + 8 -
--   ((column-1) `mod` 8)</tt>. In all other cases, the column is
--   incremented by 1.
updatePosChar :: SourcePos -> Char -> SourcePos

-- | The expression <tt>updatePosString pos s</tt> updates the source
--   position <tt>pos</tt> by calling <a>updatePosChar</a> on every
--   character in <tt>s</tt>, ie. <tt>foldl updatePosChar pos string</tt>.
updatePosString :: SourcePos -> String -> SourcePos
instance Data.Data.Data Text.Parsec.Pos.SourcePos
instance GHC.Classes.Ord Text.Parsec.Pos.SourcePos
instance GHC.Classes.Eq Text.Parsec.Pos.SourcePos
instance GHC.Show.Show Text.Parsec.Pos.SourcePos


-- | Parse errors
module Text.Parsec.Error

-- | This abstract data type represents parse error messages. There are
--   four kinds of messages:
--   
--   <pre>
--   data Message = SysUnExpect String
--                | UnExpect String
--                | Expect String
--                | Message String
--   </pre>
--   
--   The fine distinction between different kinds of parse errors allows
--   the system to generate quite good error messages for the user. It also
--   allows error messages that are formatted in different languages. Each
--   kind of message is generated by different combinators:
--   
--   <ul>
--   <li>A <a>SysUnExpect</a> message is automatically generated by the
--   <a>satisfy</a> combinator. The argument is the unexpected input.</li>
--   <li>A <a>UnExpect</a> message is generated by the <a>unexpected</a>
--   combinator. The argument describes the unexpected item.</li>
--   <li>A <a>Expect</a> message is generated by the <a>&lt;?&gt;</a>
--   combinator. The argument describes the expected item.</li>
--   <li>A <a>Message</a> message is generated by the <a>fail</a>
--   combinator. The argument is some general parser message.</li>
--   </ul>
data Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
Expect :: !String -> Message
Message :: !String -> Message

-- | Extract the message string from an error message
messageString :: Message -> String

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> and <a>Eq</a> classes.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | Extracts the list of error messages from the parse error
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError
instance GHC.Show.Show Text.Parsec.Error.ParseError
instance GHC.Classes.Eq Text.Parsec.Error.ParseError
instance GHC.Enum.Enum Text.Parsec.Error.Message
instance GHC.Classes.Eq Text.Parsec.Error.Message
instance GHC.Classes.Ord Text.Parsec.Error.Message


-- | The primitive parser combinators.
module Text.Parsec.Prim
unknownError :: State s u -> ParseError
sysUnExpectError :: String -> SourcePos -> Reply s u a

-- | The parser <tt>unexpected msg</tt> always fails with an unexpected
--   error message <tt>msg</tt> without consuming any input.
--   
--   The parsers <a>fail</a>, (<a>&lt;?&gt;</a>) and <tt>unexpected</tt>
--   are the three parsers used to generate error messages. Of these, only
--   (<a>&lt;?&gt;</a>) is commonly used. For an example of the use of
--   <tt>unexpected</tt>, see the definition of <a>notFollowedBy</a>.
unexpected :: Stream s m t => String -> ParsecT s u m a

-- | ParserT monad transformer and Parser type
--   
--   <tt>ParsecT s u m a</tt> is a parser with stream type <tt>s</tt>, user
--   state type <tt>u</tt>, underlying monad <tt>m</tt> and return type
--   <tt>a</tt>. Parsec is strict in the user state. If this is
--   undesirable, simply use a data type like <tt>data Box a = Box a</tt>
--   and the state type <tt>Box YourStateType</tt> to add a level of
--   indirection.
data ParsecT s u m a

-- | Low-level unpacking of the ParsecT type. To run your parser, please
--   look to runPT, runP, runParserT, runParser and other such functions.
runParsecT :: Monad m => ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))

-- | Low-level creation of the ParsecT type. You really shouldn't have to
--   do this.
mkPT :: Monad m => (State s u -> m (Consumed (m (Reply s u a)))) -> ParsecT s u m a
type Parsec s u = ParsecT s u Identity
data Consumed a
Consumed :: a -> Consumed a
Empty :: !a -> Consumed a
data Reply s u a
Ok :: a -> !State s u -> ParseError -> Reply s u a
Error :: ParseError -> Reply s u a
data State s u
State :: s -> !SourcePos -> !u -> State s u
[stateInput] :: State s u -> s
[statePos] :: State s u -> !SourcePos
[stateUser] :: State s u -> !u
parsecMap :: (a -> b) -> ParsecT s u m a -> ParsecT s u m b
parserReturn :: a -> ParsecT s u m a
parserBind :: ParsecT s u m a -> (a -> ParsecT s u m b) -> ParsecT s u m b
mergeErrorReply :: ParseError -> Reply s u a -> Reply s u a
parserFail :: String -> ParsecT s u m a

-- | <tt>parserZero</tt> always fails without consuming any input.
--   <tt>parserZero</tt> is defined equal to the <a>mzero</a> member of the
--   <a>MonadPlus</a> class and to the <a>empty</a> member of the
--   <a>Alternative</a> class.
parserZero :: ParsecT s u m a
parserPlus :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>p &lt;?&gt; msg</tt> behaves as parser <tt>p</tt>, but
--   whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces expect error messages with the expect error
--   message <tt>msg</tt>.
--   
--   This is normally used at the end of a set alternatives where we want
--   to return an error message in terms of a higher level construct rather
--   than returning all possible characters. For example, if the
--   <tt>expr</tt> parser from the <a>try</a> example would fail, the error
--   message is: '...: expecting expression'. Without the
--   <tt>(&lt;?&gt;)</tt> combinator, the message would be like '...:
--   expecting "let" or letter', which is less friendly.
(<?>) :: ParsecT s u m a -> String -> ParsecT s u m a
infix 0 <?>

-- | This combinator implements choice. The parser <tt>p &lt;|&gt; q</tt>
--   first applies <tt>p</tt>. If it succeeds, the value of <tt>p</tt> is
--   returned. If <tt>p</tt> fails <i>without consuming any input</i>,
--   parser <tt>q</tt> is tried. This combinator is defined equal to the
--   <a>mplus</a> member of the <a>MonadPlus</a> class and the
--   (<a>&lt;|&gt;</a>) member of <a>Alternative</a>.
--   
--   The parser is called <i>predictive</i> since <tt>q</tt> is only tried
--   when parser <tt>p</tt> didn't consume any input (i.e.. the look ahead
--   is 1). This non-backtracking behaviour allows for both an efficient
--   implementation of the parser combinators and the generation of good
--   error messages.
(<|>) :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
infixr 1 <|>

-- | A synonym for <tt>&lt;?&gt;</tt>, but as a function instead of an
--   operator.
label :: ParsecT s u m a -> String -> ParsecT s u m a
labels :: ParsecT s u m a -> [String] -> ParsecT s u m a

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
--   
--   If <tt>p</tt> fails and consumes some input, so does
--   <tt>lookAhead</tt>. Combine with <a>try</a> if this is undesirable.
lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a

-- | An instance of <tt>Stream</tt> has stream type <tt>s</tt>, underlying
--   monad <tt>m</tt> and token type <tt>t</tt> determined by the stream
--   
--   Some rough guidelines for a "correct" instance of Stream:
--   
--   <ul>
--   <li>unfoldM uncons gives the [t] corresponding to the stream</li>
--   <li>A <tt>Stream</tt> instance is responsible for maintaining the
--   "position within the stream" in the stream state <tt>s</tt>. This is
--   trivial unless you are using the monad in a non-trivial way.</li>
--   </ul>
class (Monad m) => Stream s m t | s -> t
uncons :: Stream s m t => s -> m (Maybe (t, s))
tokens :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]

-- | Like <a>tokens</a>, but doesn't consume matching prefix.
tokens' :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]

-- | The parser <tt>try p</tt> behaves like parser <tt>p</tt>, except that
--   it pretends that it hasn't consumed any input when an error occurs.
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   when the first parser failed while consuming input.
--   
--   The <tt>try</tt> combinator can for example be used to distinguish
--   identifiers and reserved words. Both reserved words and identifiers
--   are a sequence of letters. Whenever we expect a certain reserved word
--   where we can also expect an identifier we have to use the <tt>try</tt>
--   combinator. Suppose we write:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ string "let"; ... }
--   identifier  = many1 letter
--   </pre>
--   
--   If the user writes "lexical", the parser fails with: <tt>unexpected
--   'x', expecting 't' in "let"</tt>. Indeed, since the (<a>&lt;|&gt;</a>)
--   combinator only tries alternatives when the first alternative hasn't
--   consumed input, the <tt>identifier</tt> parser is never tried (because
--   the prefix "le" of the <tt>string "let"</tt> parser is already
--   consumed). The right behaviour can be obtained by adding the
--   <tt>try</tt> combinator:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ try (string "let"); ... }
--   identifier  = many1 letter
--   </pre>
try :: ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>token showTok posFromTok testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The source position of the <tt>t</tt>
--   should be returned by <tt>posFromTok t</tt> and the token can be shown
--   using <tt>showTok t</tt>.
--   
--   This combinator is expressed in terms of <a>tokenPrim</a>. It is used
--   to accept user defined token streams. For example, suppose that we
--   have a stream of basic tokens tupled with source positions. We can
--   then define a parser that accepts single tokens as:
--   
--   <pre>
--   mytoken x
--     = token showTok posFromTok testTok
--     where
--       showTok (pos,t)     = show t
--       posFromTok (pos,t)  = pos
--       testTok (pos,t)     = if x == t then Just t else Nothing
--   </pre>
token :: Stream s Identity t => (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a

-- | The parser <tt>tokenPrim showTok nextPos testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The token can be shown using
--   <tt>showTok t</tt>. The position of the <i>next</i> token should be
--   returned when <tt>nextPos</tt> is called with the current source
--   position <tt>pos</tt>, the current token <tt>t</tt> and the rest of
--   the tokens <tt>toks</tt>, <tt>nextPos pos t toks</tt>.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <a>char</a> parser could be implemented as:
--   
--   <pre>
--   char c
--     = tokenPrim showChar nextPos testChar
--     where
--       showChar x        = "'" ++ x ++ "'"
--       testChar x        = if x == c then Just x else Nothing
--       nextPos pos x xs  = updatePosChar pos x
--   </pre>
tokenPrim :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> (t -> Maybe a) -> ParsecT s u m a
tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a

-- | <tt>many p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   identifier  = do{ c  &lt;- letter
--                   ; cs &lt;- many (alphaNum &lt;|&gt; char '_')
--                   ; return (c:cs)
--                   }
--   </pre>
many :: ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
--   
--   <pre>
--   spaces  = skipMany space
--   </pre>
skipMany :: ParsecT s u m a -> ParsecT s u m ()
manyAccum :: (a -> [a] -> [a]) -> ParsecT s u m a -> ParsecT s u m [a]
runPT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a

-- | The most general way to run a parser. <tt>runParserT p state filePath
--   input</tt> runs parser <tt>p</tt> on the input list of tokens
--   <tt>input</tt>, obtained from source <tt>filePath</tt> with the
--   initial user state <tt>st</tt>. The <tt>filePath</tt> is only used in
--   error messages and may be the empty string. Returns a computation in
--   the underlying monad <tt>m</tt> that return either a <a>ParseError</a>
--   (<a>Left</a>) or a value of type <tt>a</tt> (<a>Right</a>).
runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)

-- | The most general way to run a parser over the Identity monad.
--   <tt>runParser p state filePath input</tt> runs parser <tt>p</tt> on
--   the input list of tokens <tt>input</tt>, obtained from source
--   <tt>filePath</tt> with the initial user state <tt>st</tt>. The
--   <tt>filePath</tt> is only used in error messages and may be the empty
--   string. Returns either a <a>ParseError</a> (<a>Left</a>) or a value of
--   type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p fname
--     = do{ input &lt;- readFile fname
--         ; return (runParser p () fname input)
--         }
--   </pre>
runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a

-- | <tt>parse p filePath input</tt> runs a parser <tt>p</tt> over Identity
--   without user state. The <tt>filePath</tt> is only used in error
--   messages and may be the empty string. Returns either a
--   <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   main    = case (parse numbers "" "11, 2, 43") of
--              Left err  -&gt; print err
--              Right xs  -&gt; print (sum xs)
--   
--   numbers = commaSep integer
--   </pre>
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()

-- | Returns the current source position. See also <a>SourcePos</a>.
getPosition :: Monad m => ParsecT s u m SourcePos

-- | Returns the current input
getInput :: Monad m => ParsecT s u m s

-- | <tt>setPosition pos</tt> sets the current source position to
--   <tt>pos</tt>.
setPosition :: Monad m => SourcePos -> ParsecT s u m ()

-- | <tt>setInput input</tt> continues parsing with <tt>input</tt>. The
--   <a>getInput</a> and <tt>setInput</tt> functions can for example be
--   used to deal with #include files.
setInput :: Monad m => s -> ParsecT s u m ()

-- | Returns the full parser state as a <a>State</a> record.
getParserState :: Monad m => ParsecT s u m (State s u)

-- | <tt>setParserState st</tt> set the full parser state to <tt>st</tt>.
setParserState :: Monad m => State s u -> ParsecT s u m (State s u)

-- | <tt>updateParserState f</tt> applies function <tt>f</tt> to the parser
--   state.
updateParserState :: (State s u -> State s u) -> ParsecT s u m (State s u)

-- | Returns the current user state.
getState :: Monad m => ParsecT s u m u

-- | <tt>putState st</tt> set the user state to <tt>st</tt>.
putState :: Monad m => u -> ParsecT s u m ()

-- | <tt>modifyState f</tt> applies function <tt>f</tt> to the user state.
--   Suppose that we want to count identifiers in a source, we could use
--   the user state as:
--   
--   <pre>
--   expr  = do{ x &lt;- identifier
--             ; modifyState (+1)
--             ; return (Id x)
--             }
--   </pre>
modifyState :: Monad m => (u -> u) -> ParsecT s u m ()

-- | An alias for putState for backwards compatibility.
setState :: Monad m => u -> ParsecT s u m ()

-- | An alias for modifyState for backwards compatibility.
updateState :: Monad m => (u -> u) -> ParsecT s u m ()
instance GHC.Base.Monad m => Text.Parsec.Prim.Stream [tok] m tok
instance GHC.Base.Monad m => Text.Parsec.Prim.Stream Data.ByteString.Lazy.Internal.ByteString m GHC.Types.Char
instance GHC.Base.Monad m => Text.Parsec.Prim.Stream Data.ByteString.Internal.Type.ByteString m GHC.Types.Char
instance GHC.Base.Monad m => Text.Parsec.Prim.Stream Data.Text.Internal.Text m GHC.Types.Char
instance GHC.Base.Monad m => Text.Parsec.Prim.Stream Data.Text.Internal.Lazy.Text m GHC.Types.Char
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Text.Parsec.Prim.ParsecT s u m a)
instance (GHC.Base.Monoid a, GHC.Base.Semigroup (Text.Parsec.Prim.ParsecT s u m a)) => GHC.Base.Monoid (Text.Parsec.Prim.ParsecT s u m a)
instance GHC.Base.Functor (Text.Parsec.Prim.ParsecT s u m)
instance GHC.Base.Applicative (Text.Parsec.Prim.ParsecT s u m)
instance GHC.Base.Alternative (Text.Parsec.Prim.ParsecT s u m)
instance GHC.Base.Monad (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Fail.MonadFail (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Text.Parsec.Prim.ParsecT s' u m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Text.Parsec.Prim.ParsecT s u m)
instance GHC.Base.MonadPlus (Text.Parsec.Prim.ParsecT s u m)
instance Control.Monad.Trans.Class.MonadTrans (Text.Parsec.Prim.ParsecT s u)
instance GHC.Base.Functor (Text.Parsec.Prim.Reply s u)
instance GHC.Base.Functor Text.Parsec.Prim.Consumed


-- | Commonly used generic combinators.
--   
--   See also the <a>parser-combinators</a> package for additional (and
--   generalised) combinators.
module Text.Parsec.Combinator

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (do{ d &lt;- digit
--                           ; return (digitToInt d)
--                           })
--   </pre>
option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>optionMaybe p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it return <a>Nothing</a>, otherwise it
--   returns <a>Just</a> the value returned by <tt>p</tt>.
optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)

-- | <tt>optional p</tt> tries to apply parser <tt>p</tt>. It will parse
--   <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>.
optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>skipMany1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipMany1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>many1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>chainl p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainl1 p op</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. This parser can for
--   example be used to eliminate left recursion which typically occurs in
--   expression grammars.
--   
--   <pre>
--   expr    = term   `chainl1` addop
--   term    = factor `chainl1` mulop
--   factor  = parens expr &lt;|&gt; integer
--   
--   mulop   =   do{ symbol "*"; return (*)   }
--           &lt;|&gt; do{ symbol "/"; return (div) }
--   
--   addop   =   do{ symbol "+"; return (+) }
--           &lt;|&gt; do{ symbol "-"; return (-) }
--   </pre>
chainl1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | <tt>chainr p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainr1 p op x</tt> parses <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: (Stream s m t, Show t) => ParsecT s u m ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
--   
--   <b>NOTE</b>: Currently, <a>notFollowedBy</a> exhibits surprising
--   behaviour when applied to a parser <tt>p</tt> that doesn't consume any
--   input; specifically
--   
--   <ul>
--   <li><tt><a>notFollowedBy</a> . <a>notFollowedBy</a></tt> is <i>not</i>
--   equivalent to <a>lookAhead</a>, and</li>
--   <li><tt><a>notFollowedBy</a> <a>eof</a></tt> <i>never</i> fails.</li>
--   </ul>
--   
--   See <a>haskell/parsec#8</a> for more details.
notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
--   
--   If <tt>p</tt> fails and consumes some input, so does
--   <tt>lookAhead</tt>. Combine with <a>try</a> if this is undesirable.
lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: (Stream s m t, Show t) => ParsecT s u m t

-- | <tt>parserTrace label</tt> is an impure function, implemented with
--   <a>Debug.Trace</a> that prints to the console the remaining parser
--   state at the time it is invoked. It is intended to be used for
--   debugging parsers by inspecting their intermediate states.
--   
--   <pre>
--   *&gt; parseTest (oneOf "aeiou"  &gt;&gt; parserTrace "label") "atest"
--   label: "test"
--   ...
--   </pre>
parserTrace :: (Show t, Stream s m t) => String -> ParsecT s u m ()

-- | <tt>parserTraced label p</tt> is an impure function, implemented with
--   <a>Debug.Trace</a> that prints to the console the remaining parser
--   state at the time it is invoked. It then continues to apply parser
--   <tt>p</tt>, and if <tt>p</tt> fails will indicate that the label has
--   been backtracked. It is intended to be used for debugging parsers by
--   inspecting their intermediate states.
--   
--   <pre>
--   *&gt;  parseTest (oneOf "aeiou"  &gt;&gt; parserTraced "label" (oneOf "nope")) "atest"
--   label: "test"
--   label backtracked
--   parse error at (line 1, column 2):
--   ...
--   </pre>
parserTraced :: (Stream s m t, Show t) => String -> ParsecT s u m b -> ParsecT s u m b


-- | A helper module to parse "expressions". Builds a parser given a table
--   of operators and associativities.
module Text.Parsec.Expr

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc

-- | This data type specifies operators that work on values of type
--   <tt>a</tt>. An operator is either binary infix or unary prefix or
--   postfix. A binary operator has also an associated associativity.
data Operator s u m a
Infix :: ParsecT s u m (a -> a -> a) -> Assoc -> Operator s u m a
Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
Postfix :: ParsecT s u m (a -> a) -> Operator s u m a

-- | An <tt>OperatorTable s u m a</tt> is a list of <tt>Operator s u m
--   a</tt> lists. The list is ordered in descending precedence. All
--   operators in one list have the same precedence (but may have a
--   different associativity).
type OperatorTable s u m a = [[Operator s u m a]]

-- | <tt>buildExpressionParser table term</tt> builds an expression parser
--   for terms <tt>term</tt> with operators from <tt>table</tt>, taking the
--   associativity and precedence specified in <tt>table</tt> into account.
--   Prefix and postfix operators of the same precedence can only occur
--   once (i.e. <tt>--2</tt> is not allowed if <tt>-</tt> is prefix
--   negate). Prefix and postfix operators of the same precedence associate
--   to the left (i.e. if <tt>++</tt> is postfix increment, than
--   <tt>-2++</tt> equals <tt>-1</tt>, not <tt>-3</tt>).
--   
--   The <tt>buildExpressionParser</tt> takes care of all the complexity
--   involved in building expression parser. Here is an example of an
--   expression parser that handles prefix signs, postfix increment and
--   basic arithmetic.
--   
--   <pre>
--   expr    = buildExpressionParser table term
--           &lt;?&gt; "expression"
--   
--   term    =  parens expr
--           &lt;|&gt; natural
--           &lt;?&gt; "simple expression"
--   
--   table   = [ [prefix "-" negate, prefix "+" id ]
--             , [postfix "++" (+1)]
--             , [binary "*" (*) AssocLeft, binary "/" (div) AssocLeft ]
--             , [binary "+" (+) AssocLeft, binary "-" (-)   AssocLeft ]
--             ]
--   
--   binary  name fun assoc = Infix (do{ reservedOp name; return fun }) assoc
--   prefix  name fun       = Prefix (do{ reservedOp name; return fun })
--   postfix name fun       = Postfix (do{ reservedOp name; return fun })
--   </pre>
buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a


-- | Commonly used character parsers.
module Text.Parsec.Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: Stream s m Char => ParsecT s u m ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Stream s m Char => ParsecT s u m Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: Stream s m Char => ParsecT s u m Char

-- | Parses a carriage return character ('\r') followed by a newline
--   character ('\n'). Returns a newline character.
crlf :: Stream s m Char => ParsecT s u m Char

-- | Parses a CRLF (see <a>crlf</a>) or LF (see <a>newline</a>)
--   end-of-line. Returns a newline character ('\n').
--   
--   <pre>
--   endOfLine = newline &lt;|&gt; crlf
--   </pre>
endOfLine :: Stream s m Char => ParsecT s u m Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: Stream s m Char => ParsecT s u m Char

-- | Parses an upper case letter (according to <a>isUpper</a>). Returns the
--   parsed character.
upper :: Stream s m Char => ParsecT s u m Char

-- | Parses a lower case character (according to <a>isLower</a>). Returns
--   the parsed character.
lower :: Stream s m Char => ParsecT s u m Char

-- | Parses a alphabetic or numeric Unicode characters according to
--   <a>isAlphaNum</a>. Returns the parsed character.
--   
--   Note that numeric digits outside the ASCII range (such as arabic-indic
--   digits like e.g. "Ù¤" or <tt>U+0664</tt>), as well as numeric
--   characters which aren't digits, are parsed by this function but not by
--   <a>digit</a>.
alphaNum :: Stream s m Char => ParsecT s u m Char

-- | Parses an alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters according to <a>isAlpha</a>). Returns the parsed character.
letter :: Stream s m Char => ParsecT s u m Char

-- | Parses an ASCII digit. Returns the parsed character.
digit :: Stream s m Char => ParsecT s u m Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Stream s m Char => ParsecT s u m Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: Stream s m Char => ParsecT s u m Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <pre>
--   semiColon  = char ';'
--   </pre>
char :: Stream s m Char => Char -> ParsecT s u m Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Stream s m Char => ParsecT s u m Char

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char

-- | <tt><a>string</a> s</tt> parses a sequence of characters given by
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div"
--               &lt;|&gt; string "mod"
--   </pre>
--   
--   Consider using <a>string'</a>.
string :: Stream s m Char => String -> ParsecT s u m String

-- | <tt><a>string'</a> s</tt> parses a sequence of characters given by
--   <tt>s</tt>. Doesn't consume matching prefix.
--   
--   <pre>
--   carOrCdr    =   string' "car"
--               &lt;|&gt; string' "cdr"
--   </pre>
string' :: Stream s m Char => String -> ParsecT s u m String


-- | Convenience definitions for working with lazy <a>ByteString</a>s.
module Text.Parsec.ByteString.Lazy
type Parser = Parsec ByteString ()
type GenParser t st = Parsec ByteString st

-- | <tt>parseFromFile p filePath</tt> runs a lazy bytestring parser
--   <tt>p</tt> on the input read from <tt>filePath</tt> using
--   <a>readFile</a>. Returns either a <a>ParseError</a> (<a>Left</a>) or a
--   value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)


-- | Convenience definitions for working with <a>ByteString</a>s.
module Text.Parsec.ByteString
type Parser = Parsec ByteString ()
type GenParser t st = Parsec ByteString st

-- | <tt>parseFromFile p filePath</tt> runs a strict bytestring parser
--   <tt>p</tt> on the input read from <tt>filePath</tt> using
--   <a>readFile</a>. Returns either a <a>ParseError</a> (<a>Left</a>) or a
--   value of type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)


-- | This module includes everything you need to get started writing a
--   parser.
--   
--   By default this module is set up to parse character data. If you'd
--   like to parse the result of your own tokenizer you should start with
--   the following imports:
--   
--   <pre>
--   import Text.Parsec.Prim
--   import Text.Parsec.Combinator
--   </pre>
--   
--   Then you can implement your own version of <a>satisfy</a> on top of
--   the <a>tokenPrim</a> primitive.
module Text.Parsec

-- | ParserT monad transformer and Parser type
--   
--   <tt>ParsecT s u m a</tt> is a parser with stream type <tt>s</tt>, user
--   state type <tt>u</tt>, underlying monad <tt>m</tt> and return type
--   <tt>a</tt>. Parsec is strict in the user state. If this is
--   undesirable, simply use a data type like <tt>data Box a = Box a</tt>
--   and the state type <tt>Box YourStateType</tt> to add a level of
--   indirection.
data ParsecT s u m a
type Parsec s u = ParsecT s u Identity

-- | The parser <tt>token showTok posFromTok testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The source position of the <tt>t</tt>
--   should be returned by <tt>posFromTok t</tt> and the token can be shown
--   using <tt>showTok t</tt>.
--   
--   This combinator is expressed in terms of <a>tokenPrim</a>. It is used
--   to accept user defined token streams. For example, suppose that we
--   have a stream of basic tokens tupled with source positions. We can
--   then define a parser that accepts single tokens as:
--   
--   <pre>
--   mytoken x
--     = token showTok posFromTok testTok
--     where
--       showTok (pos,t)     = show t
--       posFromTok (pos,t)  = pos
--       testTok (pos,t)     = if x == t then Just t else Nothing
--   </pre>
token :: Stream s Identity t => (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a
tokens :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]

-- | The most general way to run a parser. <tt>runParserT p state filePath
--   input</tt> runs parser <tt>p</tt> on the input list of tokens
--   <tt>input</tt>, obtained from source <tt>filePath</tt> with the
--   initial user state <tt>st</tt>. The <tt>filePath</tt> is only used in
--   error messages and may be the empty string. Returns a computation in
--   the underlying monad <tt>m</tt> that return either a <a>ParseError</a>
--   (<a>Left</a>) or a value of type <tt>a</tt> (<a>Right</a>).
runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)

-- | The most general way to run a parser over the Identity monad.
--   <tt>runParser p state filePath input</tt> runs parser <tt>p</tt> on
--   the input list of tokens <tt>input</tt>, obtained from source
--   <tt>filePath</tt> with the initial user state <tt>st</tt>. The
--   <tt>filePath</tt> is only used in error messages and may be the empty
--   string. Returns either a <a>ParseError</a> (<a>Left</a>) or a value of
--   type <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   parseFromFile p fname
--     = do{ input &lt;- readFile fname
--         ; return (runParser p () fname input)
--         }
--   </pre>
runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a

-- | <tt>parse p filePath input</tt> runs a parser <tt>p</tt> over Identity
--   without user state. The <tt>filePath</tt> is only used in error
--   messages and may be the empty string. Returns either a
--   <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   main    = case (parse numbers "" "11, 2, 43") of
--              Left err  -&gt; print err
--              Right xs  -&gt; print (sum xs)
--   
--   numbers = commaSep integer
--   </pre>
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()

-- | Returns the current source position. See also <a>SourcePos</a>.
getPosition :: Monad m => ParsecT s u m SourcePos

-- | Returns the current input
getInput :: Monad m => ParsecT s u m s

-- | Returns the current user state.
getState :: Monad m => ParsecT s u m u

-- | <tt>putState st</tt> set the user state to <tt>st</tt>.
putState :: Monad m => u -> ParsecT s u m ()

-- | <tt>modifyState f</tt> applies function <tt>f</tt> to the user state.
--   Suppose that we want to count identifiers in a source, we could use
--   the user state as:
--   
--   <pre>
--   expr  = do{ x &lt;- identifier
--             ; modifyState (+1)
--             ; return (Id x)
--             }
--   </pre>
modifyState :: Monad m => (u -> u) -> ParsecT s u m ()

-- | This combinator implements choice. The parser <tt>p &lt;|&gt; q</tt>
--   first applies <tt>p</tt>. If it succeeds, the value of <tt>p</tt> is
--   returned. If <tt>p</tt> fails <i>without consuming any input</i>,
--   parser <tt>q</tt> is tried. This combinator is defined equal to the
--   <a>mplus</a> member of the <a>MonadPlus</a> class and the
--   (<a>&lt;|&gt;</a>) member of <a>Alternative</a>.
--   
--   The parser is called <i>predictive</i> since <tt>q</tt> is only tried
--   when parser <tt>p</tt> didn't consume any input (i.e.. the look ahead
--   is 1). This non-backtracking behaviour allows for both an efficient
--   implementation of the parser combinators and the generation of good
--   error messages.
(<|>) :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
infixr 1 <|>

-- | The parser <tt>p &lt;?&gt; msg</tt> behaves as parser <tt>p</tt>, but
--   whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces expect error messages with the expect error
--   message <tt>msg</tt>.
--   
--   This is normally used at the end of a set alternatives where we want
--   to return an error message in terms of a higher level construct rather
--   than returning all possible characters. For example, if the
--   <tt>expr</tt> parser from the <a>try</a> example would fail, the error
--   message is: '...: expecting expression'. Without the
--   <tt>(&lt;?&gt;)</tt> combinator, the message would be like '...:
--   expecting "let" or letter', which is less friendly.
(<?>) :: ParsecT s u m a -> String -> ParsecT s u m a
infix 0 <?>

-- | A synonym for <tt>&lt;?&gt;</tt>, but as a function instead of an
--   operator.
label :: ParsecT s u m a -> String -> ParsecT s u m a
labels :: ParsecT s u m a -> [String] -> ParsecT s u m a

-- | The parser <tt>try p</tt> behaves like parser <tt>p</tt>, except that
--   it pretends that it hasn't consumed any input when an error occurs.
--   
--   This combinator is used whenever arbitrary look ahead is needed. Since
--   it pretends that it hasn't consumed any input when <tt>p</tt> fails,
--   the (<a>&lt;|&gt;</a>) combinator will try its second alternative even
--   when the first parser failed while consuming input.
--   
--   The <tt>try</tt> combinator can for example be used to distinguish
--   identifiers and reserved words. Both reserved words and identifiers
--   are a sequence of letters. Whenever we expect a certain reserved word
--   where we can also expect an identifier we have to use the <tt>try</tt>
--   combinator. Suppose we write:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ string "let"; ... }
--   identifier  = many1 letter
--   </pre>
--   
--   If the user writes "lexical", the parser fails with: <tt>unexpected
--   'x', expecting 't' in "let"</tt>. Indeed, since the (<a>&lt;|&gt;</a>)
--   combinator only tries alternatives when the first alternative hasn't
--   consumed input, the <tt>identifier</tt> parser is never tried (because
--   the prefix "le" of the <tt>string "let"</tt> parser is already
--   consumed). The right behaviour can be obtained by adding the
--   <tt>try</tt> combinator:
--   
--   <pre>
--   expr        = letExpr &lt;|&gt; identifier &lt;?&gt; "expression"
--   
--   letExpr     = do{ try (string "let"); ... }
--   identifier  = many1 letter
--   </pre>
try :: ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>unexpected msg</tt> always fails with an unexpected
--   error message <tt>msg</tt> without consuming any input.
--   
--   The parsers <a>fail</a>, (<a>&lt;?&gt;</a>) and <tt>unexpected</tt>
--   are the three parsers used to generate error messages. Of these, only
--   (<a>&lt;?&gt;</a>) is commonly used. For an example of the use of
--   <tt>unexpected</tt>, see the definition of <a>notFollowedBy</a>.
unexpected :: Stream s m t => String -> ParsecT s u m a

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a

-- | <tt>many p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   identifier  = do{ c  &lt;- letter
--                   ; cs &lt;- many (alphaNum &lt;|&gt; char '_')
--                   ; return (c:cs)
--                   }
--   </pre>
many :: ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>many1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
--   
--   <pre>
--   spaces  = skipMany space
--   </pre>
skipMany :: ParsecT s u m a -> ParsecT s u m ()

-- | <tt>skipMany1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipMany1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (do{ d &lt;- digit
--                           ; return (digitToInt d)
--                           })
--   </pre>
option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>optionMaybe p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it return <a>Nothing</a>, otherwise it
--   returns <a>Just</a> the value returned by <tt>p</tt>.
optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)

-- | <tt>optional p</tt> tries to apply parser <tt>p</tt>. It will parse
--   <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>.
optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>chainl p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainl1 p op</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. This parser can for
--   example be used to eliminate left recursion which typically occurs in
--   expression grammars.
--   
--   <pre>
--   expr    = term   `chainl1` addop
--   term    = factor `chainl1` mulop
--   factor  = parens expr &lt;|&gt; integer
--   
--   mulop   =   do{ symbol "*"; return (*)   }
--           &lt;|&gt; do{ symbol "/"; return (div) }
--   
--   addop   =   do{ symbol "+"; return (+) }
--           &lt;|&gt; do{ symbol "-"; return (-) }
--   </pre>
chainl1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | <tt>chainr p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainr1 p op x</tt> parses <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: (Stream s m t, Show t) => ParsecT s u m ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
--   
--   <b>NOTE</b>: Currently, <a>notFollowedBy</a> exhibits surprising
--   behaviour when applied to a parser <tt>p</tt> that doesn't consume any
--   input; specifically
--   
--   <ul>
--   <li><tt><a>notFollowedBy</a> . <a>notFollowedBy</a></tt> is <i>not</i>
--   equivalent to <a>lookAhead</a>, and</li>
--   <li><tt><a>notFollowedBy</a> <a>eof</a></tt> <i>never</i> fails.</li>
--   </ul>
--   
--   See <a>haskell/parsec#8</a> for more details.
notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
--   
--   If <tt>p</tt> fails and consumes some input, so does
--   <tt>lookAhead</tt>. Combine with <a>try</a> if this is undesirable.
lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: (Stream s m t, Show t) => ParsecT s u m t

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> and <a>Eq</a> classes.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos
type SourceName = String
type Line = Int
type Column = Int

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos

-- | <tt>parserTrace label</tt> is an impure function, implemented with
--   <a>Debug.Trace</a> that prints to the console the remaining parser
--   state at the time it is invoked. It is intended to be used for
--   debugging parsers by inspecting their intermediate states.
--   
--   <pre>
--   *&gt; parseTest (oneOf "aeiou"  &gt;&gt; parserTrace "label") "atest"
--   label: "test"
--   ...
--   </pre>
parserTrace :: (Show t, Stream s m t) => String -> ParsecT s u m ()

-- | <tt>parserTraced label p</tt> is an impure function, implemented with
--   <a>Debug.Trace</a> that prints to the console the remaining parser
--   state at the time it is invoked. It then continues to apply parser
--   <tt>p</tt>, and if <tt>p</tt> fails will indicate that the label has
--   been backtracked. It is intended to be used for debugging parsers by
--   inspecting their intermediate states.
--   
--   <pre>
--   *&gt;  parseTest (oneOf "aeiou"  &gt;&gt; parserTraced "label" (oneOf "nope")) "atest"
--   label: "test"
--   label backtracked
--   parse error at (line 1, column 2):
--   ...
--   </pre>
parserTraced :: (Stream s m t, Show t) => String -> ParsecT s u m b -> ParsecT s u m b
manyAccum :: (a -> [a] -> [a]) -> ParsecT s u m a -> ParsecT s u m [a]

-- | The parser <tt>tokenPrim showTok nextPos testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The token can be shown using
--   <tt>showTok t</tt>. The position of the <i>next</i> token should be
--   returned when <tt>nextPos</tt> is called with the current source
--   position <tt>pos</tt>, the current token <tt>t</tt> and the rest of
--   the tokens <tt>toks</tt>, <tt>nextPos pos t toks</tt>.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <a>char</a> parser could be implemented as:
--   
--   <pre>
--   char c
--     = tokenPrim showChar nextPos testChar
--     where
--       showChar x        = "'" ++ x ++ "'"
--       testChar x        = if x == c then Just x else Nothing
--       nextPos pos x xs  = updatePosChar pos x
--   </pre>
tokenPrim :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> (t -> Maybe a) -> ParsecT s u m a
tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
runPT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
unknownError :: State s u -> ParseError
sysUnExpectError :: String -> SourcePos -> Reply s u a
mergeErrorReply :: ParseError -> Reply s u a -> Reply s u a

-- | Returns the full parser state as a <a>State</a> record.
getParserState :: Monad m => ParsecT s u m (State s u)

-- | <tt>setParserState st</tt> set the full parser state to <tt>st</tt>.
setParserState :: Monad m => State s u -> ParsecT s u m (State s u)

-- | <tt>updateParserState f</tt> applies function <tt>f</tt> to the parser
--   state.
updateParserState :: (State s u -> State s u) -> ParsecT s u m (State s u)

-- | An instance of <tt>Stream</tt> has stream type <tt>s</tt>, underlying
--   monad <tt>m</tt> and token type <tt>t</tt> determined by the stream
--   
--   Some rough guidelines for a "correct" instance of Stream:
--   
--   <ul>
--   <li>unfoldM uncons gives the [t] corresponding to the stream</li>
--   <li>A <tt>Stream</tt> instance is responsible for maintaining the
--   "position within the stream" in the stream state <tt>s</tt>. This is
--   trivial unless you are using the monad in a non-trivial way.</li>
--   </ul>
class (Monad m) => Stream s m t | s -> t
uncons :: Stream s m t => s -> m (Maybe (t, s))

-- | Low-level unpacking of the ParsecT type. To run your parser, please
--   look to runPT, runP, runParserT, runParser and other such functions.
runParsecT :: Monad m => ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))

-- | Low-level creation of the ParsecT type. You really shouldn't have to
--   do this.
mkPT :: Monad m => (State s u -> m (Consumed (m (Reply s u a)))) -> ParsecT s u m a
runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
data Consumed a
Consumed :: a -> Consumed a
Empty :: !a -> Consumed a
data Reply s u a
Ok :: a -> !State s u -> ParseError -> Reply s u a
Error :: ParseError -> Reply s u a
data State s u
State :: s -> !SourcePos -> !u -> State s u
[stateInput] :: State s u -> s
[statePos] :: State s u -> !SourcePos
[stateUser] :: State s u -> !u

-- | <tt>setPosition pos</tt> sets the current source position to
--   <tt>pos</tt>.
setPosition :: Monad m => SourcePos -> ParsecT s u m ()

-- | <tt>setInput input</tt> continues parsing with <tt>input</tt>. The
--   <a>getInput</a> and <tt>setInput</tt> functions can for example be
--   used to deal with #include files.
setInput :: Monad m => s -> ParsecT s u m ()

-- | An alias for putState for backwards compatibility.
setState :: Monad m => u -> ParsecT s u m ()

-- | An alias for modifyState for backwards compatibility.
updateState :: Monad m => (u -> u) -> ParsecT s u m ()
parsecMap :: (a -> b) -> ParsecT s u m a -> ParsecT s u m b
parserReturn :: a -> ParsecT s u m a
parserBind :: ParsecT s u m a -> (a -> ParsecT s u m b) -> ParsecT s u m b
parserFail :: String -> ParsecT s u m a

-- | <tt>parserZero</tt> always fails without consuming any input.
--   <tt>parserZero</tt> is defined equal to the <a>mzero</a> member of the
--   <a>MonadPlus</a> class and to the <a>empty</a> member of the
--   <a>Alternative</a> class.
parserZero :: ParsecT s u m a
parserPlus :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a


-- | This module implements permutation parsers. The algorithm used is
--   fairly complex since we push the type system to its limits :-) The
--   algorithm is described in:
--   
--   <i>Parsing Permutation Phrases,</i> by Arthur Baars, Andres Loh and
--   Doaitse Swierstra. Published as a functional pearl at the Haskell
--   Workshop 2001.
--   
--   From the abstract:
--   
--   A permutation phrase is a sequence of elements (possibly of different
--   types) in which each element occurs exactly once and the order is
--   irrelevant. Some of the permutable elements may be optional.
module Text.Parsec.Perm

-- | Provided for backwards compatibility. The tok type is ignored.
type PermParser tok st a = StreamPermParser String st a

-- | The type <tt>StreamPermParser s st a</tt> denotes a permutation parser
--   that, when converted by the <a>permute</a> function, parses <tt>s</tt>
--   streams with user state <tt>st</tt> and returns a value of type
--   <tt>a</tt> on success.
--   
--   Normally, a permutation parser is first build with special operators
--   like (<a>&lt;||&gt;</a>) and than transformed into a normal parser
--   using <a>permute</a>.
data StreamPermParser s st a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",many1 (char 'a'))
--                          &lt;||&gt; char 'b'
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> Parsec s st a -> StreamPermParser s st b
infixl 1 <||>

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
infixl 2 <$$>

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
infixl 1 <|?>

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
infixl 2 <$?>


-- | Make Strings an instance of <a>Stream</a> with <a>Char</a> token type.
module Text.Parsec.String
type Parser = Parsec String ()
type GenParser tok st = Parsec [tok] st

-- | <tt>parseFromFile p filePath</tt> runs a string parser <tt>p</tt> on
--   the input read from <tt>filePath</tt> using <a>readFile</a>. Returns
--   either a <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)


-- | Convenience definitions for working with <a>Text</a>.
module Text.Parsec.Text
type Parser = Parsec Text ()
type GenParser st = Parsec Text st

-- | <tt>parseFromFile p filePath</tt> runs a strict text parser <tt>p</tt>
--   on the input read from <tt>filePath</tt> using <a>readFile</a>.
--   Returns either a <a>ParseError</a> (<a>Left</a>) or a value of type
--   <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)


-- | Convenience definitions for working with lazy <a>Text</a>.
module Text.Parsec.Text.Lazy
type Parser = Parsec Text ()
type GenParser st = Parsec Text st

-- | <tt>parseFromFile p filePath</tt> runs a strict text parser <tt>p</tt>
--   on the input read from <tt>filePath</tt> using <a>readFile</a>.
--   Returns either a <a>ParseError</a> (<a>Left</a>) or a value of type
--   <tt>a</tt> (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)


-- | A helper module to parse lexical elements (tokens). See
--   <a>makeTokenParser</a> for a description of how to use it.
module Text.Parsec.Token
type LanguageDef st = GenLanguageDef String st Identity

-- | The <tt>GenLanguageDef</tt> type is a record that contains all
--   parameterizable features of the <a>Text.Parsec.Token</a> module. The
--   module <a>Text.Parsec.Language</a> contains some default definitions.
data GenLanguageDef s u m
LanguageDef :: String -> String -> String -> Bool -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> [String] -> [String] -> Bool -> GenLanguageDef s u m

-- | Describes the start of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "/*".
[commentStart] :: GenLanguageDef s u m -> String

-- | Describes the end of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "*/".
[commentEnd] :: GenLanguageDef s u m -> String

-- | Describes the start of a line comment. Use the empty string if the
--   language doesn't support line comments. For example "//".
[commentLine] :: GenLanguageDef s u m -> String

-- | Set to <a>True</a> if the language supports nested block comments.
[nestedComments] :: GenLanguageDef s u m -> Bool

-- | This parser should accept any start characters of identifiers. For
--   example <tt>letter &lt;|&gt; char '_'</tt>.
[identStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of identifiers.
--   For example <tt>alphaNum &lt;|&gt; char '_'</tt>.
[identLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any start characters of operators. For
--   example <tt>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</tt>
[opStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of operators. Note
--   that this parser should even be defined if the language doesn't
--   support user-defined operators, or otherwise the <a>reservedOp</a>
--   parser won't work correctly.
[opLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | The list of reserved identifiers.
[reservedNames] :: GenLanguageDef s u m -> [String]

-- | The list of reserved operators.
[reservedOpNames] :: GenLanguageDef s u m -> [String]

-- | Set to <a>True</a> if the language is case sensitive.
[caseSensitive] :: GenLanguageDef s u m -> Bool
type TokenParser st = GenTokenParser String st Identity

-- | The type of the record that holds lexical parsers that work on
--   <tt>s</tt> streams with state <tt>u</tt> over a monad <tt>m</tt>.
data GenTokenParser s u m
TokenParser :: ParsecT s u m String -> (String -> ParsecT s u m ()) -> ParsecT s u m String -> (String -> ParsecT s u m ()) -> ParsecT s u m Char -> ParsecT s u m String -> ParsecT s u m Integer -> ParsecT s u m Integer -> ParsecT s u m Double -> ParsecT s u m (Either Integer Double) -> ParsecT s u m Integer -> ParsecT s u m Integer -> ParsecT s u m Integer -> (String -> ParsecT s u m String) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> ParsecT s u m () -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> ParsecT s u m String -> ParsecT s u m String -> ParsecT s u m String -> ParsecT s u m String -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> GenTokenParser s u m

-- | This lexeme parser parses a legal identifier. Returns the identifier
--   string. This parser will fail on identifiers that are reserved words.
--   Legal identifier (start) characters and reserved words are defined in
--   the <a>LanguageDef</a> that is passed to <a>makeTokenParser</a>. An
--   <tt>identifier</tt> is treated as a single token using <a>try</a>.
[identifier] :: GenTokenParser s u m -> ParsecT s u m String

-- | The lexeme parser <tt>reserved name</tt> parses <tt>symbol name</tt>,
--   but it also checks that the <tt>name</tt> is not a prefix of a valid
--   identifier. A <tt>reserved</tt> word is treated as a single token
--   using <a>try</a>.
[reserved] :: GenTokenParser s u m -> String -> ParsecT s u m ()

-- | This lexeme parser parses a legal operator. Returns the name of the
--   operator. This parser will fail on any operators that are reserved
--   operators. Legal operator (start) characters and reserved operators
--   are defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>. An <tt>operator</tt> is treated as a single
--   token using <a>try</a>.
[operator] :: GenTokenParser s u m -> ParsecT s u m String

-- | The lexeme parser <tt>reservedOp name</tt> parses <tt>symbol
--   name</tt>, but it also checks that the <tt>name</tt> is not a prefix
--   of a valid operator. A <tt>reservedOp</tt> is treated as a single
--   token using <a>try</a>.
[reservedOp] :: GenTokenParser s u m -> String -> ParsecT s u m ()

-- | This lexeme parser parses a single literal character. Returns the
--   literal character value. This parsers deals correctly with escape
--   sequences. The literal character is parsed according to the grammar
--   rules defined in the Haskell report (which matches most programming
--   languages quite closely).
[charLiteral] :: GenTokenParser s u m -> ParsecT s u m Char

-- | This lexeme parser parses a literal string. Returns the literal string
--   value. This parsers deals correctly with escape sequences and gaps.
--   The literal string is parsed according to the grammar rules defined in
--   the Haskell report (which matches most programming languages quite
--   closely).
[stringLiteral] :: GenTokenParser s u m -> ParsecT s u m String

-- | This lexeme parser parses a natural number (a non-negative whole
--   number). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
[natural] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | This lexeme parser parses an integer (a whole number). This parser is
--   like <a>natural</a> except that it can be prefixed with sign (i.e. '-'
--   or '+'). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
[integer] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | This lexeme parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
[float] :: GenTokenParser s u m -> ParsecT s u m Double

-- | This lexeme parser parses either <a>natural</a> or a <a>float</a>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
[naturalOrFloat] :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)

-- | Parses a non-negative whole number in the decimal system. Returns the
--   value of the number.
[decimal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Parses a non-negative whole number in the hexadecimal system. The
--   number should be prefixed with "x" or "X". Returns the value of the
--   number.
[hexadecimal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Parses a non-negative whole number in the octal system. The number
--   should be prefixed with "o" or "O". Returns the value of the number.
[octal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Lexeme parser <tt>symbol s</tt> parses <a>string</a> <tt>s</tt> and
--   skips trailing white space.
[symbol] :: GenTokenParser s u m -> String -> ParsecT s u m String

-- | <tt>lexeme p</tt> first applies parser <tt>p</tt> and then the
--   <a>whiteSpace</a> parser, returning the value of <tt>p</tt>. Every
--   lexical token (lexeme) is defined using <tt>lexeme</tt>, this way
--   every parse starts at a point without white space. Parsers that use
--   <tt>lexeme</tt> are called <i>lexeme</i> parsers in this document.
--   
--   The only point where the <a>whiteSpace</a> parser should be called
--   explicitly is the start of the main parser in order to skip any
--   leading white space.
--   
--   <pre>
--   mainParser  = do{ whiteSpace
--                    ; ds &lt;- many (lexeme digit)
--                    ; eof
--                    ; return (sum ds)
--                    }
--   </pre>
[lexeme] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Parses any white space. White space consists of <i>zero</i> or more
--   occurrences of a <a>space</a>, a line comment or a block (multi line)
--   comment. Block comments may be nested. How comments are started and
--   ended is defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>.
[whiteSpace] :: GenTokenParser s u m -> ParsecT s u m ()

-- | Lexeme parser <tt>parens p</tt> parses <tt>p</tt> enclosed in
--   parenthesis, returning the value of <tt>p</tt>.
[parens] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>braces p</tt> parses <tt>p</tt> enclosed in braces
--   ('{' and '}'), returning the value of <tt>p</tt>.
[braces] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>angles p</tt> parses <tt>p</tt> enclosed in angle
--   brackets ('&lt;' and '&gt;'), returning the value of <tt>p</tt>.
[angles] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>brackets p</tt> parses <tt>p</tt> enclosed in
--   brackets ('[' and ']'), returning the value of <tt>p</tt>.
[brackets] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | DEPRECATED: Use <a>brackets</a>.
[squares] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser |semi| parses the character ';' and skips any trailing
--   white space. Returns the string ";".
[semi] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>comma</tt> parses the character ',' and skips any
--   trailing white space. Returns the string ",".
[comma] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>colon</tt> parses the character ':' and skips any
--   trailing white space. Returns the string ":".
[colon] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>dot</tt> parses the character '.' and skips any
--   trailing white space. Returns the string ".".
[dot] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>semiSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
[semiSep] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>semiSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
[semiSep1] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>commaSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
[commaSep] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>commaSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
[commaSep1] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | The expression <tt>makeTokenParser language</tt> creates a
--   <a>GenTokenParser</a> record that contains lexical parsers that are
--   defined using the definitions in the <tt>language</tt> record.
--   
--   The use of this function is quite stylized - one imports the
--   appropriate language definition and selects the lexical parsers that
--   are needed from the resulting <a>GenTokenParser</a>.
--   
--   <pre>
--   module Main where
--   
--   import Text.Parsec
--   import qualified Text.Parsec.Token as P
--   import Text.Parsec.Language (haskellDef)
--   
--   -- The parser
--   ...
--   
--   expr  =   parens expr
--         &lt;|&gt; identifier
--         &lt;|&gt; ...
--   
--   
--   -- The lexer
--   lexer       = P.makeTokenParser haskellDef
--   
--   parens      = P.parens lexer
--   braces      = P.braces lexer
--   identifier  = P.identifier lexer
--   reserved    = P.reserved lexer
--   ...
--   </pre>
makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m


-- | A helper module that defines some language definitions that can be
--   used to instantiate a token parser (see <a>Text.Parsec.Token</a>).
module Text.Parsec.Language

-- | The language definition for the Haskell language.
haskellDef :: LanguageDef st

-- | A lexer for the Haskell language.
haskell :: TokenParser st

-- | The language definition for the language Mondrian.
mondrianDef :: LanguageDef st

-- | A lexer for the Mondrian language.
mondrian :: TokenParser st

-- | This is the most minimal token definition. It is recommended to use
--   this definition as the basis for other definitions. <tt>emptyDef</tt>
--   has no reserved names or operators, is case sensitive and doesn't
--   accept comments, identifiers or operators.
emptyDef :: LanguageDef st

-- | This is a minimal token definition for Haskell style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
haskellStyle :: LanguageDef st

-- | This is a minimal token definition for Java style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
javaStyle :: LanguageDef st
type LanguageDef st = GenLanguageDef String st Identity

-- | The <tt>GenLanguageDef</tt> type is a record that contains all
--   parameterizable features of the <a>Text.Parsec.Token</a> module. The
--   module <a>Text.Parsec.Language</a> contains some default definitions.
data GenLanguageDef s u m


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Char
type CharParser st = GenParser Char st

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: Stream s m Char => ParsecT s u m ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Stream s m Char => ParsecT s u m Char

-- | Parses a newline character ('\n'). Returns a newline character.
newline :: Stream s m Char => ParsecT s u m Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: Stream s m Char => ParsecT s u m Char

-- | Parses an upper case letter (according to <a>isUpper</a>). Returns the
--   parsed character.
upper :: Stream s m Char => ParsecT s u m Char

-- | Parses a lower case character (according to <a>isLower</a>). Returns
--   the parsed character.
lower :: Stream s m Char => ParsecT s u m Char

-- | Parses a alphabetic or numeric Unicode characters according to
--   <a>isAlphaNum</a>. Returns the parsed character.
--   
--   Note that numeric digits outside the ASCII range (such as arabic-indic
--   digits like e.g. "Ù¤" or <tt>U+0664</tt>), as well as numeric
--   characters which aren't digits, are parsed by this function but not by
--   <a>digit</a>.
alphaNum :: Stream s m Char => ParsecT s u m Char

-- | Parses an alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters according to <a>isAlpha</a>). Returns the parsed character.
letter :: Stream s m Char => ParsecT s u m Char

-- | Parses an ASCII digit. Returns the parsed character.
digit :: Stream s m Char => ParsecT s u m Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Stream s m Char => ParsecT s u m Char

-- | Parses an octal digit (a character between '0' and '7'). Returns the
--   parsed character.
octDigit :: Stream s m Char => ParsecT s u m Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <pre>
--   semiColon  = char ';'
--   </pre>
char :: Stream s m Char => Char -> ParsecT s u m Char

-- | <tt><a>string</a> s</tt> parses a sequence of characters given by
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div"
--               &lt;|&gt; string "mod"
--   </pre>
--   
--   Consider using <a>string'</a>.
string :: Stream s m Char => String -> ParsecT s u m String

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Stream s m Char => ParsecT s u m Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Combinator

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt>. If
--   <tt>n</tt> is smaller or equal to zero, the parser equals to
--   <tt>return []</tt>. Returns a list of <tt>n</tt> values returned by
--   <tt>p</tt>.
count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and <tt>close</tt>. Returns the value returned by
--   <tt>p</tt>.
--   
--   <pre>
--   braces  = between (symbol "{") (symbol "}")
--   </pre>
between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (do{ d &lt;- digit
--                           ; return (digitToInt d)
--                           })
--   </pre>
option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a

-- | <tt>optionMaybe p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it return <a>Nothing</a>, otherwise it
--   returns <a>Just</a> the value returned by <tt>p</tt>.
optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)

-- | <tt>optional p</tt> tries to apply parser <tt>p</tt>. It will parse
--   <tt>p</tt> or nothing. It only fails if <tt>p</tt> fails after
--   consuming input. It discards the result of <tt>p</tt>.
optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>skipMany1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipMany1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>many1 p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>sepBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (symbol ",")
--   </pre>
sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
--   
--   <pre>
--   cStatements  = cStatement `endBy` semi
--   </pre>
endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>endBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and ended by <tt>sep</tt>. Returns a list of
--   values returned by <tt>p</tt>.
endBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy p sep</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>, ie.
--   haskell style statements. Returns a list of values returned by
--   <tt>p</tt>.
--   
--   <pre>
--   haskellStatements  = haskellStatement `sepEndBy` semi
--   </pre>
sepEndBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>sepEndBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated and optionally ended by <tt>sep</tt>. Returns a
--   list of values returned by <tt>p</tt>.
sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]

-- | <tt>chainl p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt>. Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are zero
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainl1 p op</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>left</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. This parser can for
--   example be used to eliminate left recursion which typically occurs in
--   expression grammars.
--   
--   <pre>
--   expr    = term   `chainl1` addop
--   term    = factor `chainl1` mulop
--   factor  = parens expr &lt;|&gt; integer
--   
--   mulop   =   do{ symbol "*"; return (*)   }
--           &lt;|&gt; do{ symbol "/"; return (div) }
--   
--   addop   =   do{ symbol "+"; return (+) }
--           &lt;|&gt; do{ symbol "-"; return (-) }
--   </pre>
chainl1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | <tt>chainr p op x</tt> parses <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>op</tt> Returns a value obtained by a
--   <i>right</i> associative application of all functions returned by
--   <tt>op</tt> to the values returned by <tt>p</tt>. If there are no
--   occurrences of <tt>p</tt>, the value <tt>x</tt> is returned.
chainr :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a

-- | <tt>chainr1 p op x</tt> parses <i>one</i> or more occurrences of |p|,
--   separated by <tt>op</tt> Returns a value obtained by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt> to
--   the values returned by <tt>p</tt>.
chainr1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m a

-- | This parser only succeeds at the end of the input. This is not a
--   primitive parser but it is defined using <a>notFollowedBy</a>.
--   
--   <pre>
--   eof  = notFollowedBy anyToken &lt;?&gt; "end of input"
--   </pre>
eof :: (Stream s m t, Show t) => ParsecT s u m ()

-- | <tt>notFollowedBy p</tt> only succeeds when parser <tt>p</tt> fails.
--   This parser does not consume any input. This parser can be used to
--   implement the 'longest match' rule. For example, when recognizing
--   keywords (for example <tt>let</tt>), we want to make sure that a
--   keyword is not followed by a legal identifier character, in which case
--   the keyword is actually an identifier (for example <tt>lets</tt>). We
--   can program this behaviour as follows:
--   
--   <pre>
--   keywordLet  = try (do{ string "let"
--                        ; notFollowedBy alphaNum
--                        })
--   </pre>
--   
--   <b>NOTE</b>: Currently, <a>notFollowedBy</a> exhibits surprising
--   behaviour when applied to a parser <tt>p</tt> that doesn't consume any
--   input; specifically
--   
--   <ul>
--   <li><tt><a>notFollowedBy</a> . <a>notFollowedBy</a></tt> is <i>not</i>
--   equivalent to <a>lookAhead</a>, and</li>
--   <li><tt><a>notFollowedBy</a> <a>eof</a></tt> <i>never</i> fails.</li>
--   </ul>
--   
--   See <a>haskell/parsec#8</a> for more details.
notFollowedBy :: (Stream s m t, Show a) => ParsecT s u m a -> ParsecT s u m ()

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>. This parser can be used to scan comments:
--   
--   <pre>
--   simpleComment   = do{ string "&lt;!--"
--                       ; manyTill anyChar (try (string "--&gt;"))
--                       }
--   </pre>
--   
--   Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>, and therefore the use of the <a>try</a> combinator.
manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]

-- | <tt>lookAhead p</tt> parses <tt>p</tt> without consuming any input.
--   
--   If <tt>p</tt> fails and consumes some input, so does
--   <tt>lookAhead</tt>. Combine with <a>try</a> if this is undesirable.
lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a

-- | The parser <tt>anyToken</tt> accepts any kind of token. It is for
--   example used to implement <a>eof</a>. Returns the accepted token.
anyToken :: (Stream s m t, Show t) => ParsecT s u m t


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Error

-- | This abstract data type represents parse error messages. There are
--   four kinds of messages:
--   
--   <pre>
--   data Message = SysUnExpect String
--                | UnExpect String
--                | Expect String
--                | Message String
--   </pre>
--   
--   The fine distinction between different kinds of parse errors allows
--   the system to generate quite good error messages for the user. It also
--   allows error messages that are formatted in different languages. Each
--   kind of message is generated by different combinators:
--   
--   <ul>
--   <li>A <a>SysUnExpect</a> message is automatically generated by the
--   <a>satisfy</a> combinator. The argument is the unexpected input.</li>
--   <li>A <a>UnExpect</a> message is generated by the <a>unexpected</a>
--   combinator. The argument describes the unexpected item.</li>
--   <li>A <a>Expect</a> message is generated by the <a>&lt;?&gt;</a>
--   combinator. The argument describes the expected item.</li>
--   <li>A <a>Message</a> message is generated by the <a>fail</a>
--   combinator. The argument is some general parser message.</li>
--   </ul>
data Message
SysUnExpect :: !String -> Message
UnExpect :: !String -> Message
Expect :: !String -> Message
Message :: !String -> Message

-- | Extract the message string from an error message
messageString :: Message -> String
messageCompare :: Message -> Message -> Ordering
messageEq :: Message -> Message -> Bool

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> and <a>Eq</a> classes.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | Extracts the list of error messages from the parse error
errorMessages :: ParseError -> [Message]
errorIsUnknown :: ParseError -> Bool
showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
newErrorMessage :: Message -> SourcePos -> ParseError
newErrorUnknown :: SourcePos -> ParseError
addErrorMessage :: Message -> ParseError -> ParseError
setErrorPos :: SourcePos -> ParseError -> ParseError
setErrorMessage :: Message -> ParseError -> ParseError
mergeError :: ParseError -> ParseError -> ParseError


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Language

-- | The language definition for the Haskell language.
haskellDef :: LanguageDef st

-- | A lexer for the Haskell language.
haskell :: TokenParser st

-- | The language definition for the language Mondrian.
mondrianDef :: LanguageDef st

-- | A lexer for the Mondrian language.
mondrian :: TokenParser st

-- | This is the most minimal token definition. It is recommended to use
--   this definition as the basis for other definitions. <tt>emptyDef</tt>
--   has no reserved names or operators, is case sensitive and doesn't
--   accept comments, identifiers or operators.
emptyDef :: LanguageDef st

-- | This is a minimal token definition for Haskell style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
haskellStyle :: LanguageDef st

-- | This is a minimal token definition for Java style languages. It
--   defines the style of comments, valid identifiers and case sensitivity.
--   It does not define any reserved words or operators.
javaStyle :: LanguageDef st
type LanguageDef st = GenLanguageDef String st Identity

-- | The <tt>GenLanguageDef</tt> type is a record that contains all
--   parameterizable features of the <a>Text.Parsec.Token</a> module. The
--   module <a>Text.Parsec.Language</a> contains some default definitions.
data GenLanguageDef s u m
LanguageDef :: String -> String -> String -> Bool -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> [String] -> [String] -> Bool -> GenLanguageDef s u m

-- | Describes the start of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "/*".
[commentStart] :: GenLanguageDef s u m -> String

-- | Describes the end of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "*/".
[commentEnd] :: GenLanguageDef s u m -> String

-- | Describes the start of a line comment. Use the empty string if the
--   language doesn't support line comments. For example "//".
[commentLine] :: GenLanguageDef s u m -> String

-- | Set to <a>True</a> if the language supports nested block comments.
[nestedComments] :: GenLanguageDef s u m -> Bool

-- | This parser should accept any start characters of identifiers. For
--   example <tt>letter &lt;|&gt; char '_'</tt>.
[identStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of identifiers.
--   For example <tt>alphaNum &lt;|&gt; char '_'</tt>.
[identLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any start characters of operators. For
--   example <tt>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</tt>
[opStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of operators. Note
--   that this parser should even be defined if the language doesn't
--   support user-defined operators, or otherwise the <a>reservedOp</a>
--   parser won't work correctly.
[opLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | The list of reserved identifiers.
[reservedNames] :: GenLanguageDef s u m -> [String]

-- | The list of reserved operators.
[reservedOpNames] :: GenLanguageDef s u m -> [String]

-- | Set to <a>True</a> if the language is case sensitive.
[caseSensitive] :: GenLanguageDef s u m -> Bool


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Perm

-- | Provided for backwards compatibility. The tok type is ignored.
type PermParser tok st a = StreamPermParser String st a

-- | The parser <tt>permute perm</tt> parses a permutation of parser
--   described by <tt>perm</tt>. For example, suppose we want to parse a
--   permutation of: an optional string of <tt>a</tt>'s, the character
--   <tt>b</tt> and an optional <tt>c</tt>. This can be described by:
--   
--   <pre>
--   test  = permute (tuple &lt;$?&gt; ("",many1 (char 'a'))
--                          &lt;||&gt; char 'b'
--                          &lt;|?&gt; ('_',char 'c'))
--         where
--           tuple a b c  = (a,b,c)
--   </pre>
permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a

-- | The expression <tt>perm &lt;||&gt; p</tt> adds parser <tt>p</tt> to
--   the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is not
--   allowed to accept empty input - use the optional combinator
--   (<a>&lt;|?&gt;</a>) instead. Returns a new permutation parser that
--   includes <tt>p</tt>.
(<||>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> Parsec s st a -> StreamPermParser s st b
infixl 1 <||>

-- | The expression <tt>f &lt;$$&gt; p</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is not allowed to accept
--   empty input - use the optional combinator (<a>&lt;$?&gt;</a>) instead.
--   
--   If the function <tt>f</tt> takes more than one parameter, the type
--   variable <tt>b</tt> is instantiated to a functional type which
--   combines nicely with the adds parser <tt>p</tt> to the
--   (<a>&lt;||&gt;</a>) combinator. This results in stylized code where a
--   permutation parser starts with a combining function <tt>f</tt>
--   followed by the parsers. The function <tt>f</tt> gets its parameters
--   in the order in which the parsers are specified, but actual input can
--   be in any order.
(<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
infixl 2 <$$>

-- | The expression <tt>perm &lt;||&gt; (x,p)</tt> adds parser <tt>p</tt>
--   to the permutation parser <tt>perm</tt>. The parser <tt>p</tt> is
--   optional - if it can not be applied, the default value <tt>x</tt> will
--   be used instead. Returns a new permutation parser that includes the
--   optional parser <tt>p</tt>.
(<|?>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
infixl 1 <|?>

-- | The expression <tt>f &lt;$?&gt; (x,p)</tt> creates a fresh permutation
--   parser consisting of parser <tt>p</tt>. The the final result of the
--   permutation parser is the function <tt>f</tt> applied to the return
--   value of <tt>p</tt>. The parser <tt>p</tt> is optional - if it can not
--   be applied, the default value <tt>x</tt> will be used instead.
(<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
infixl 2 <$?>


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Pos
type SourceName = String
type Line = Int
type Column = Int

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, line number
--   and column number.
newPos :: SourceName -> Line -> Column -> SourcePos

-- | Create a new <a>SourcePos</a> with the given source name, and line
--   number and column number set to 1, the upper left.
initialPos :: SourceName -> SourcePos

-- | Update a source position given a character. If the character is a
--   newline ('\n') or carriage return ('\r') the line number is
--   incremented by 1. If the character is a tab ('t') the column number is
--   incremented to the nearest 8'th column, ie. <tt>column + 8 -
--   ((column-1) `mod` 8)</tt>. In all other cases, the column is
--   incremented by 1.
updatePosChar :: SourcePos -> Char -> SourcePos

-- | The expression <tt>updatePosString pos s</tt> updates the source
--   position <tt>pos</tt> by calling <a>updatePosChar</a> on every
--   character in <tt>s</tt>, ie. <tt>foldl updatePosChar pos string</tt>.
updatePosString :: SourcePos -> String -> SourcePos


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Prim

-- | The parser <tt>p &lt;?&gt; msg</tt> behaves as parser <tt>p</tt>, but
--   whenever the parser <tt>p</tt> fails <i>without consuming any
--   input</i>, it replaces expect error messages with the expect error
--   message <tt>msg</tt>.
--   
--   This is normally used at the end of a set alternatives where we want
--   to return an error message in terms of a higher level construct rather
--   than returning all possible characters. For example, if the
--   <tt>expr</tt> parser from the <a>try</a> example would fail, the error
--   message is: '...: expecting expression'. Without the
--   <tt>(&lt;?&gt;)</tt> combinator, the message would be like '...:
--   expecting "let" or letter', which is less friendly.
(<?>) :: ParsecT s u m a -> String -> ParsecT s u m a
infix 0 <?>

-- | This combinator implements choice. The parser <tt>p &lt;|&gt; q</tt>
--   first applies <tt>p</tt>. If it succeeds, the value of <tt>p</tt> is
--   returned. If <tt>p</tt> fails <i>without consuming any input</i>,
--   parser <tt>q</tt> is tried. This combinator is defined equal to the
--   <a>mplus</a> member of the <a>MonadPlus</a> class and the
--   (<a>&lt;|&gt;</a>) member of <a>Alternative</a>.
--   
--   The parser is called <i>predictive</i> since <tt>q</tt> is only tried
--   when parser <tt>p</tt> didn't consume any input (i.e.. the look ahead
--   is 1). This non-backtracking behaviour allows for both an efficient
--   implementation of the parser combinators and the generation of good
--   error messages.
(<|>) :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
infixr 1 <|>
type Parser = Parsec String ()
type GenParser tok st = Parsec [tok] st
runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a

-- | <tt>parse p filePath input</tt> runs a parser <tt>p</tt> over Identity
--   without user state. The <tt>filePath</tt> is only used in error
--   messages and may be the empty string. Returns either a
--   <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   main    = case (parse numbers "" "11, 2, 43") of
--              Left err  -&gt; print err
--              Right xs  -&gt; print (sum xs)
--   
--   numbers = commaSep integer
--   </pre>
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

-- | <tt>parseFromFile p filePath</tt> runs a string parser <tt>p</tt> on
--   the input read from <tt>filePath</tt> using <a>readFile</a>. Returns
--   either a <a>ParseError</a> (<a>Left</a>) or a value of type <tt>a</tt>
--   (<a>Right</a>).
--   
--   <pre>
--   main    = do{ result &lt;- parseFromFile numbers "digits.txt"
--               ; case result of
--                   Left err  -&gt; print err
--                   Right xs  -&gt; print (sum xs)
--               }
--   </pre>
parseFromFile :: Parser a -> FilePath -> IO (Either ParseError a)

-- | The expression <tt>parseTest p input</tt> applies a parser <tt>p</tt>
--   against input <tt>input</tt> and prints the result to stdout. Used for
--   testing parsers.
parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()

-- | The parser <tt>token showTok posFromTok testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The source position of the <tt>t</tt>
--   should be returned by <tt>posFromTok t</tt> and the token can be shown
--   using <tt>showTok t</tt>.
--   
--   This combinator is expressed in terms of <a>tokenPrim</a>. It is used
--   to accept user defined token streams. For example, suppose that we
--   have a stream of basic tokens tupled with source positions. We can
--   then define a parser that accepts single tokens as:
--   
--   <pre>
--   mytoken x
--     = token showTok posFromTok testTok
--     where
--       showTok (pos,t)     = show t
--       posFromTok (pos,t)  = pos
--       testTok (pos,t)     = if x == t then Just t else Nothing
--   </pre>
token :: Stream s Identity t => (t -> String) -> (t -> SourcePos) -> (t -> Maybe a) -> Parsec s u a
tokens :: (Stream s m t, Eq t) => ([t] -> String) -> (SourcePos -> [t] -> SourcePos) -> [t] -> ParsecT s u m [t]

-- | The parser <tt>tokenPrim showTok nextPos testTok</tt> accepts a token
--   <tt>t</tt> with result <tt>x</tt> when the function <tt>testTok t</tt>
--   returns <tt><a>Just</a> x</tt>. The token can be shown using
--   <tt>showTok t</tt>. The position of the <i>next</i> token should be
--   returned when <tt>nextPos</tt> is called with the current source
--   position <tt>pos</tt>, the current token <tt>t</tt> and the rest of
--   the tokens <tt>toks</tt>, <tt>nextPos pos t toks</tt>.
--   
--   This is the most primitive combinator for accepting tokens. For
--   example, the <a>char</a> parser could be implemented as:
--   
--   <pre>
--   char c
--     = tokenPrim showChar nextPos testChar
--     where
--       showChar x        = "'" ++ x ++ "'"
--       testChar x        = if x == c then Just x else Nothing
--       nextPos pos x xs  = updatePosChar pos x
--   </pre>
tokenPrim :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> (t -> Maybe a) -> ParsecT s u m a
tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
try :: GenParser tok st a -> GenParser tok st a

-- | A synonym for <tt>&lt;?&gt;</tt>, but as a function instead of an
--   operator.
label :: ParsecT s u m a -> String -> ParsecT s u m a
labels :: ParsecT s u m a -> [String] -> ParsecT s u m a

-- | The parser <tt>unexpected msg</tt> always fails with an unexpected
--   error message <tt>msg</tt> without consuming any input.
--   
--   The parsers <a>fail</a>, (<a>&lt;?&gt;</a>) and <tt>unexpected</tt>
--   are the three parsers used to generate error messages. Of these, only
--   (<a>&lt;?&gt;</a>) is commonly used. For an example of the use of
--   <tt>unexpected</tt>, see the definition of <a>notFollowedBy</a>.
unexpected :: Stream s m t => String -> ParsecT s u m a
pzero :: GenParser tok st a

-- | <tt>many p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   identifier  = do{ c  &lt;- letter
--                   ; cs &lt;- many (alphaNum &lt;|&gt; char '_')
--                   ; return (c:cs)
--                   }
--   </pre>
many :: ParsecT s u m a -> ParsecT s u m [a]

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
--   
--   <pre>
--   spaces  = skipMany space
--   </pre>
skipMany :: ParsecT s u m a -> ParsecT s u m ()

-- | Returns the current user state.
getState :: Monad m => ParsecT s u m u

-- | An alias for putState for backwards compatibility.
setState :: Monad m => u -> ParsecT s u m ()

-- | An alias for modifyState for backwards compatibility.
updateState :: Monad m => (u -> u) -> ParsecT s u m ()

-- | Returns the current source position. See also <a>SourcePos</a>.
getPosition :: Monad m => ParsecT s u m SourcePos

-- | <tt>setPosition pos</tt> sets the current source position to
--   <tt>pos</tt>.
setPosition :: Monad m => SourcePos -> ParsecT s u m ()

-- | Returns the current input
getInput :: Monad m => ParsecT s u m s

-- | <tt>setInput input</tt> continues parsing with <tt>input</tt>. The
--   <a>getInput</a> and <tt>setInput</tt> functions can for example be
--   used to deal with #include files.
setInput :: Monad m => s -> ParsecT s u m ()
data State s u
State :: s -> !SourcePos -> !u -> State s u
[stateInput] :: State s u -> s
[statePos] :: State s u -> !SourcePos
[stateUser] :: State s u -> !u

-- | Returns the full parser state as a <a>State</a> record.
getParserState :: Monad m => ParsecT s u m (State s u)

-- | <tt>setParserState st</tt> set the full parser state to <tt>st</tt>.
setParserState :: Monad m => State s u -> ParsecT s u m (State s u)


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> and <a>Eq</a> classes.
data ParseError

-- | Extracts the source position from the parse error
errorPos :: ParseError -> SourcePos

-- | The abstract data type <tt>SourcePos</tt> represents source positions.
--   It contains the name of the source (i.e. file name), a line number and
--   a column number. <tt>SourcePos</tt> is an instance of the <a>Show</a>,
--   <a>Eq</a> and <a>Ord</a> class.
data SourcePos
type SourceName = String
type Line = Int
type Column = Int

-- | Extracts the name of the source from a source position.
sourceName :: SourcePos -> SourceName

-- | Extracts the line number from a source position.
sourceLine :: SourcePos -> Line

-- | Extracts the column number from a source position.
sourceColumn :: SourcePos -> Column

-- | Increments the line number of a source position.
incSourceLine :: SourcePos -> Line -> SourcePos

-- | Increments the column number of a source position.
incSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the line number of a source position.
setSourceLine :: SourcePos -> Line -> SourcePos

-- | Set the column number of a source position.
setSourceColumn :: SourcePos -> Column -> SourcePos

-- | Set the name of the source.
setSourceName :: SourcePos -> SourceName -> SourcePos


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Expr

-- | This data type specifies the associativity of operators: left, right
--   or none.
data Assoc
AssocNone :: Assoc
AssocLeft :: Assoc
AssocRight :: Assoc
data Operator tok st a
Infix :: GenParser tok st (a -> a -> a) -> Assoc -> Operator tok st a
Prefix :: GenParser tok st (a -> a) -> Operator tok st a
Postfix :: GenParser tok st (a -> a) -> Operator tok st a
type OperatorTable tok st a = [[Operator tok st a]]
buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a


-- | Parsec compatibility module
module Text.ParserCombinators.Parsec.Token
type LanguageDef st = GenLanguageDef String st Identity

-- | The <tt>GenLanguageDef</tt> type is a record that contains all
--   parameterizable features of the <a>Text.Parsec.Token</a> module. The
--   module <a>Text.Parsec.Language</a> contains some default definitions.
data GenLanguageDef s u m
LanguageDef :: String -> String -> String -> Bool -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> ParsecT s u m Char -> [String] -> [String] -> Bool -> GenLanguageDef s u m

-- | Describes the start of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "/*".
[commentStart] :: GenLanguageDef s u m -> String

-- | Describes the end of a block comment. Use the empty string if the
--   language doesn't support block comments. For example "*/".
[commentEnd] :: GenLanguageDef s u m -> String

-- | Describes the start of a line comment. Use the empty string if the
--   language doesn't support line comments. For example "//".
[commentLine] :: GenLanguageDef s u m -> String

-- | Set to <a>True</a> if the language supports nested block comments.
[nestedComments] :: GenLanguageDef s u m -> Bool

-- | This parser should accept any start characters of identifiers. For
--   example <tt>letter &lt;|&gt; char '_'</tt>.
[identStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of identifiers.
--   For example <tt>alphaNum &lt;|&gt; char '_'</tt>.
[identLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any start characters of operators. For
--   example <tt>oneOf ":!#$%&amp;*+./&lt;=&gt;?@\\^|-~"</tt>
[opStart] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | This parser should accept any legal tail characters of operators. Note
--   that this parser should even be defined if the language doesn't
--   support user-defined operators, or otherwise the <a>reservedOp</a>
--   parser won't work correctly.
[opLetter] :: GenLanguageDef s u m -> ParsecT s u m Char

-- | The list of reserved identifiers.
[reservedNames] :: GenLanguageDef s u m -> [String]

-- | The list of reserved operators.
[reservedOpNames] :: GenLanguageDef s u m -> [String]

-- | Set to <a>True</a> if the language is case sensitive.
[caseSensitive] :: GenLanguageDef s u m -> Bool
type TokenParser st = GenTokenParser String st Identity

-- | The type of the record that holds lexical parsers that work on
--   <tt>s</tt> streams with state <tt>u</tt> over a monad <tt>m</tt>.
data GenTokenParser s u m
TokenParser :: ParsecT s u m String -> (String -> ParsecT s u m ()) -> ParsecT s u m String -> (String -> ParsecT s u m ()) -> ParsecT s u m Char -> ParsecT s u m String -> ParsecT s u m Integer -> ParsecT s u m Integer -> ParsecT s u m Double -> ParsecT s u m (Either Integer Double) -> ParsecT s u m Integer -> ParsecT s u m Integer -> ParsecT s u m Integer -> (String -> ParsecT s u m String) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> ParsecT s u m () -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> (forall a. ParsecT s u m a -> ParsecT s u m a) -> ParsecT s u m String -> ParsecT s u m String -> ParsecT s u m String -> ParsecT s u m String -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> (forall a. ParsecT s u m a -> ParsecT s u m [a]) -> GenTokenParser s u m

-- | This lexeme parser parses a legal identifier. Returns the identifier
--   string. This parser will fail on identifiers that are reserved words.
--   Legal identifier (start) characters and reserved words are defined in
--   the <a>LanguageDef</a> that is passed to <a>makeTokenParser</a>. An
--   <tt>identifier</tt> is treated as a single token using <a>try</a>.
[identifier] :: GenTokenParser s u m -> ParsecT s u m String

-- | The lexeme parser <tt>reserved name</tt> parses <tt>symbol name</tt>,
--   but it also checks that the <tt>name</tt> is not a prefix of a valid
--   identifier. A <tt>reserved</tt> word is treated as a single token
--   using <a>try</a>.
[reserved] :: GenTokenParser s u m -> String -> ParsecT s u m ()

-- | This lexeme parser parses a legal operator. Returns the name of the
--   operator. This parser will fail on any operators that are reserved
--   operators. Legal operator (start) characters and reserved operators
--   are defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>. An <tt>operator</tt> is treated as a single
--   token using <a>try</a>.
[operator] :: GenTokenParser s u m -> ParsecT s u m String

-- | The lexeme parser <tt>reservedOp name</tt> parses <tt>symbol
--   name</tt>, but it also checks that the <tt>name</tt> is not a prefix
--   of a valid operator. A <tt>reservedOp</tt> is treated as a single
--   token using <a>try</a>.
[reservedOp] :: GenTokenParser s u m -> String -> ParsecT s u m ()

-- | This lexeme parser parses a single literal character. Returns the
--   literal character value. This parsers deals correctly with escape
--   sequences. The literal character is parsed according to the grammar
--   rules defined in the Haskell report (which matches most programming
--   languages quite closely).
[charLiteral] :: GenTokenParser s u m -> ParsecT s u m Char

-- | This lexeme parser parses a literal string. Returns the literal string
--   value. This parsers deals correctly with escape sequences and gaps.
--   The literal string is parsed according to the grammar rules defined in
--   the Haskell report (which matches most programming languages quite
--   closely).
[stringLiteral] :: GenTokenParser s u m -> ParsecT s u m String

-- | This lexeme parser parses a natural number (a non-negative whole
--   number). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
[natural] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | This lexeme parser parses an integer (a whole number). This parser is
--   like <a>natural</a> except that it can be prefixed with sign (i.e. '-'
--   or '+'). Returns the value of the number. The number can be specified
--   in <a>decimal</a>, <a>hexadecimal</a> or <a>octal</a>. The number is
--   parsed according to the grammar rules in the Haskell report.
[integer] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | This lexeme parser parses a floating point value. Returns the value of
--   the number. The number is parsed according to the grammar rules
--   defined in the Haskell report.
[float] :: GenTokenParser s u m -> ParsecT s u m Double

-- | This lexeme parser parses either <a>natural</a> or a <a>float</a>.
--   Returns the value of the number. This parsers deals with any overlap
--   in the grammar rules for naturals and floats. The number is parsed
--   according to the grammar rules defined in the Haskell report.
[naturalOrFloat] :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)

-- | Parses a non-negative whole number in the decimal system. Returns the
--   value of the number.
[decimal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Parses a non-negative whole number in the hexadecimal system. The
--   number should be prefixed with "x" or "X". Returns the value of the
--   number.
[hexadecimal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Parses a non-negative whole number in the octal system. The number
--   should be prefixed with "o" or "O". Returns the value of the number.
[octal] :: GenTokenParser s u m -> ParsecT s u m Integer

-- | Lexeme parser <tt>symbol s</tt> parses <a>string</a> <tt>s</tt> and
--   skips trailing white space.
[symbol] :: GenTokenParser s u m -> String -> ParsecT s u m String

-- | <tt>lexeme p</tt> first applies parser <tt>p</tt> and then the
--   <a>whiteSpace</a> parser, returning the value of <tt>p</tt>. Every
--   lexical token (lexeme) is defined using <tt>lexeme</tt>, this way
--   every parse starts at a point without white space. Parsers that use
--   <tt>lexeme</tt> are called <i>lexeme</i> parsers in this document.
--   
--   The only point where the <a>whiteSpace</a> parser should be called
--   explicitly is the start of the main parser in order to skip any
--   leading white space.
--   
--   <pre>
--   mainParser  = do{ whiteSpace
--                    ; ds &lt;- many (lexeme digit)
--                    ; eof
--                    ; return (sum ds)
--                    }
--   </pre>
[lexeme] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Parses any white space. White space consists of <i>zero</i> or more
--   occurrences of a <a>space</a>, a line comment or a block (multi line)
--   comment. Block comments may be nested. How comments are started and
--   ended is defined in the <a>LanguageDef</a> that is passed to
--   <a>makeTokenParser</a>.
[whiteSpace] :: GenTokenParser s u m -> ParsecT s u m ()

-- | Lexeme parser <tt>parens p</tt> parses <tt>p</tt> enclosed in
--   parenthesis, returning the value of <tt>p</tt>.
[parens] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>braces p</tt> parses <tt>p</tt> enclosed in braces
--   ('{' and '}'), returning the value of <tt>p</tt>.
[braces] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>angles p</tt> parses <tt>p</tt> enclosed in angle
--   brackets ('&lt;' and '&gt;'), returning the value of <tt>p</tt>.
[angles] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser <tt>brackets p</tt> parses <tt>p</tt> enclosed in
--   brackets ('[' and ']'), returning the value of <tt>p</tt>.
[brackets] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | DEPRECATED: Use <a>brackets</a>.
[squares] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m a

-- | Lexeme parser |semi| parses the character ';' and skips any trailing
--   white space. Returns the string ";".
[semi] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>comma</tt> parses the character ',' and skips any
--   trailing white space. Returns the string ",".
[comma] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>colon</tt> parses the character ':' and skips any
--   trailing white space. Returns the string ":".
[colon] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>dot</tt> parses the character '.' and skips any
--   trailing white space. Returns the string ".".
[dot] :: GenTokenParser s u m -> ParsecT s u m String

-- | Lexeme parser <tt>semiSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
[semiSep] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>semiSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>semi</a>. Returns a list of
--   values returned by <tt>p</tt>.
[semiSep1] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>commaSep p</tt> parses <i>zero</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
[commaSep] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | Lexeme parser <tt>commaSep1 p</tt> parses <i>one</i> or more
--   occurrences of <tt>p</tt> separated by <a>comma</a>. Returns a list of
--   values returned by <tt>p</tt>.
[commaSep1] :: GenTokenParser s u m -> forall a. ParsecT s u m a -> ParsecT s u m [a]

-- | The expression <tt>makeTokenParser language</tt> creates a
--   <a>GenTokenParser</a> record that contains lexical parsers that are
--   defined using the definitions in the <tt>language</tt> record.
--   
--   The use of this function is quite stylized - one imports the
--   appropriate language definition and selects the lexical parsers that
--   are needed from the resulting <a>GenTokenParser</a>.
--   
--   <pre>
--   module Main where
--   
--   import Text.Parsec
--   import qualified Text.Parsec.Token as P
--   import Text.Parsec.Language (haskellDef)
--   
--   -- The parser
--   ...
--   
--   expr  =   parens expr
--         &lt;|&gt; identifier
--         &lt;|&gt; ...
--   
--   
--   -- The lexer
--   lexer       = P.makeTokenParser haskellDef
--   
--   parens      = P.parens lexer
--   braces      = P.braces lexer
--   identifier  = P.identifier lexer
--   reserved    = P.reserved lexer
--   ...
--   </pre>
makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m
