-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mid-Level SQLite client library
--   
--   Mid-level SQLite client library, based on postgresql-simple.
--   
--   Main documentation (with examples): <a>Database.SQLite.Simple</a>
--   
--   You can view the project page at
--   <a>http://github.com/nurpax/sqlite-simple</a> for more information.
@package sqlite-simple
@version 0.4.19.0


-- | The <a>Ok</a> type is a simple error handler, basically equivalent to
--   <tt>Either [SomeException]</tt>.
--   
--   One of the primary reasons why this type was introduced is that
--   <tt>Either SomeException</tt> had not been provided an instance for
--   <a>Alternative</a>, and it would have been a bad idea to provide an
--   orphaned instance for a commonly-used type and typeclass included in
--   <tt>base</tt>.
--   
--   Extending the failure case to a list of <a>SomeException</a>s enables
--   a more sensible <a>Alternative</a> instance definitions:
--   <a>&lt;|&gt;</a> concatenates the list of exceptions when both cases
--   fail, and <a>empty</a> is defined as 'Errors []'. Though
--   <a>&lt;|&gt;</a> one could pick one of two exceptions, and throw away
--   the other, and have <a>empty</a> provide a generic exception, this
--   avoids cases where <a>empty</a> overrides a more informative exception
--   and allows you to see all the different ways your computation has
--   failed.
module Database.SQLite.Simple.Ok
data Ok a
Errors :: [SomeException] -> Ok a
Ok :: !a -> Ok a

-- | a way to reify a list of exceptions into a single exception
newtype ManyErrors
ManyErrors :: [SomeException] -> ManyErrors
instance GHC.Base.Functor Database.SQLite.Simple.Ok.Ok
instance GHC.Show.Show a => GHC.Show.Show (Database.SQLite.Simple.Ok.Ok a)
instance GHC.Show.Show Database.SQLite.Simple.Ok.ManyErrors
instance GHC.Exception.Type.Exception Database.SQLite.Simple.Ok.ManyErrors
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.SQLite.Simple.Ok.Ok a)
instance GHC.Base.Applicative Database.SQLite.Simple.Ok.Ok
instance GHC.Base.Alternative Database.SQLite.Simple.Ok.Ok
instance GHC.Base.MonadPlus Database.SQLite.Simple.Ok.Ok
instance GHC.Base.Monad Database.SQLite.Simple.Ok.Ok
instance Control.Monad.Fail.MonadFail Database.SQLite.Simple.Ok.Ok
instance Control.Monad.Catch.MonadThrow Database.SQLite.Simple.Ok.Ok


-- | Internal bits. This interface is less stable and can change at any
--   time. In particular this means that while the rest of the
--   sqlite-simple package endeavors to follow the package versioning
--   policy, this module does not. Also, at the moment there are things in
--   here that aren't particularly internal and are exported elsewhere;
--   these will eventually disappear from this module.
module Database.SQLite.Simple.Internal

-- | Connection to an open database.
--   
--   You can use <a>connectionHandle</a> to gain access to the underlying
--   <a>http://hackage.haskell.org/package/direct-sqlite</a> connection.
--   This may be useful if you need to access some direct-sqlite
--   functionality that's not exposed in the sqlite-simple API. This should
--   be a safe thing to do although mixing both APIs is discouraged.
data Connection
Connection :: {-# UNPACK #-} !Database -> {-# UNPACK #-} !IORef Word64 -> Connection
[connectionHandle] :: Connection -> {-# UNPACK #-} !Database
[connectionTempNameCounter] :: Connection -> {-# UNPACK #-} !IORef Word64
data ColumnOutOfBounds
ColumnOutOfBounds :: !Int -> ColumnOutOfBounds
[errorColumnIndex] :: ColumnOutOfBounds -> !Int

-- | A Field represents metadata about a particular field
data Field
Field :: SQLData -> {-# UNPACK #-} !Int -> Field
[result] :: Field -> SQLData
[column] :: Field -> {-# UNPACK #-} !Int
newtype RowParseRO
RowParseRO :: Int -> RowParseRO
[nColumns] :: RowParseRO -> Int
newtype RowParser a
RP :: ReaderT RowParseRO (StateT (Int, [SQLData]) Ok) a -> RowParser a
[unRP] :: RowParser a -> ReaderT RowParseRO (StateT (Int, [SQLData]) Ok) a
gettypename :: SQLData -> ByteString
instance GHC.Show.Show Database.SQLite.Simple.Internal.ColumnOutOfBounds
instance GHC.Classes.Eq Database.SQLite.Simple.Internal.ColumnOutOfBounds
instance GHC.Base.MonadPlus Database.SQLite.Simple.Internal.RowParser
instance GHC.Base.Monad Database.SQLite.Simple.Internal.RowParser
instance GHC.Base.Alternative Database.SQLite.Simple.Internal.RowParser
instance GHC.Base.Applicative Database.SQLite.Simple.Internal.RowParser
instance GHC.Base.Functor Database.SQLite.Simple.Internal.RowParser
instance GHC.Exception.Type.Exception Database.SQLite.Simple.Internal.ColumnOutOfBounds


-- | Adapted from Leon P Smith's code for SQLite.
--   
--   See <a>http://sqlite.org/lang_datefunc.html</a> for date formats used
--   in SQLite.
module Database.SQLite.Simple.Time.Implementation
parseUTCTime :: Text -> Either String UTCTime
parseDay :: Text -> Either String Day

-- | Output YYYY-MM-DD HH:MM:SS with an optional .SSS fraction part.
--   Explicit timezone attribute is not appended as per SQLite3's datetime
--   conventions.
utcTimeToBuilder :: UTCTime -> Builder
dayToBuilder :: Day -> Builder
timeOfDayToBuilder :: TimeOfDay -> Builder
timeZoneToBuilder :: TimeZone -> Builder


-- | Conversions to/from Haskell <tt>UTCTime</tt> and <tt>Day</tt> types
--   for SQLite3. Offers better performance than direct use of time
--   package's <a>read</a>/<a>show</a> functionality.
--   
--   The parsers are heavily adapted for the specific variant of ISO 8601
--   that SQLite uses, and the printers attempt to duplicate this syntax.
module Database.SQLite.Simple.Time


-- | Top-level module for sqlite-simple.
module Database.SQLite.Simple.Types

-- | A placeholder for the SQL <tt>NULL</tt> value.
data Null
Null :: Null

-- | The 1-tuple type or single-value "collection".
--   
--   This type is structurally equivalent to the <a>Identity</a> type, but
--   its intent is more about serving as the anonymous 1-tuple type missing
--   from Haskell for attaching typeclass instances.
--   
--   Parameter usage example:
--   
--   <pre>
--   encodeSomething (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result usage example:
--   
--   <pre>
--   xs &lt;- decodeSomething
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype () => Only a
Only :: a -> Only a
[fromOnly] :: Only a -> a

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.SQLite.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <tt>Text</tt>, and literal Haskell strings
--   that contain Unicode characters will be correctly transformed to
--   UTF-8.
newtype Query
Query :: Text -> Query
[fromQuery] :: Query -> Text

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data h :. t
(:.) :: h -> t -> (:.) h t
infixr 3 :.
infixr 3 :.
instance GHC.Show.Show Database.SQLite.Simple.Types.Null
instance GHC.Read.Read Database.SQLite.Simple.Types.Null
instance GHC.Classes.Ord Database.SQLite.Simple.Types.Query
instance GHC.Classes.Eq Database.SQLite.Simple.Types.Query
instance (GHC.Read.Read h, GHC.Read.Read t) => GHC.Read.Read (h Database.SQLite.Simple.Types.:. t)
instance (GHC.Show.Show h, GHC.Show.Show t) => GHC.Show.Show (h Database.SQLite.Simple.Types.:. t)
instance (GHC.Classes.Ord h, GHC.Classes.Ord t) => GHC.Classes.Ord (h Database.SQLite.Simple.Types.:. t)
instance (GHC.Classes.Eq h, GHC.Classes.Eq t) => GHC.Classes.Eq (h Database.SQLite.Simple.Types.:. t)
instance GHC.Show.Show Database.SQLite.Simple.Types.Query
instance GHC.Read.Read Database.SQLite.Simple.Types.Query
instance Data.String.IsString Database.SQLite.Simple.Types.Query
instance GHC.Base.Semigroup Database.SQLite.Simple.Types.Query
instance GHC.Base.Monoid Database.SQLite.Simple.Types.Query
instance GHC.Classes.Eq Database.SQLite.Simple.Types.Null


-- | The <a>ToField</a> typeclass, for rendering a parameter to an SQLite
--   value to be bound as a SQL query parameter.
module Database.SQLite.Simple.ToField

-- | A type that may be used as a single parameter to a SQL query.
class ToField a

-- | Prepare a value for substitution into a query string.
toField :: ToField a => a -> SQLData
instance Database.SQLite.Simple.ToField.ToField Database.SQLite3.SQLData
instance Database.SQLite.Simple.ToField.ToField a => Database.SQLite.Simple.ToField.ToField (GHC.Maybe.Maybe a)
instance Database.SQLite.Simple.ToField.ToField Database.SQLite.Simple.Types.Null
instance Database.SQLite.Simple.ToField.ToField GHC.Types.Bool
instance Database.SQLite.Simple.ToField.ToField GHC.Int.Int8
instance Database.SQLite.Simple.ToField.ToField GHC.Int.Int16
instance Database.SQLite.Simple.ToField.ToField GHC.Int.Int32
instance Database.SQLite.Simple.ToField.ToField GHC.Types.Int
instance Database.SQLite.Simple.ToField.ToField GHC.Int.Int64
instance Database.SQLite.Simple.ToField.ToField GHC.Num.Integer.Integer
instance Database.SQLite.Simple.ToField.ToField GHC.Word.Word8
instance Database.SQLite.Simple.ToField.ToField GHC.Word.Word16
instance Database.SQLite.Simple.ToField.ToField GHC.Word.Word32
instance Database.SQLite.Simple.ToField.ToField GHC.Types.Word
instance Database.SQLite.Simple.ToField.ToField GHC.Word.Word64
instance Database.SQLite.Simple.ToField.ToField GHC.Types.Float
instance Database.SQLite.Simple.ToField.ToField GHC.Types.Double
instance Database.SQLite.Simple.ToField.ToField Data.ByteString.Internal.Type.ByteString
instance Database.SQLite.Simple.ToField.ToField Data.ByteString.Lazy.Internal.ByteString
instance Database.SQLite.Simple.ToField.ToField Data.Text.Internal.Text
instance Database.SQLite.Simple.ToField.ToField [GHC.Types.Char]
instance Database.SQLite.Simple.ToField.ToField Data.Text.Internal.Lazy.Text
instance Database.SQLite.Simple.ToField.ToField Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.SQLite.Simple.ToField.ToField Data.Time.Calendar.Days.Day


-- | The <a>ToRow</a> typeclass, for rendering a collection of parameters
--   to a SQL query.
--   
--   Predefined instances are provided for tuples containing up to ten
--   elements.
module Database.SQLite.Simple.ToRow

-- | Generic derivation of <a>ToRow</a>. For details about what can be
--   derived refer to <a>GFromRow</a>.
class GToRow f
gtoRow :: GToRow f => f a -> [SQLData]

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>ToRow</a>. Refer to the documentation
--   for <a>FromRow</a> to see how this can be done.
class ToRow a

-- | <a>ToField</a> a collection of values.
toRow :: ToRow a => a -> [SQLData]

-- | <a>ToField</a> a collection of values.
toRow :: (ToRow a, Generic a) => GToRow (Rep a) => a -> [SQLData]
instance Database.SQLite.Simple.ToRow.ToRow ()
instance Database.SQLite.Simple.ToField.ToField a => Database.SQLite.Simple.ToRow.ToRow (Data.Tuple.Only.Only a)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b) => Database.SQLite.Simple.ToRow.ToRow (a, b)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c) => Database.SQLite.Simple.ToRow.ToRow (a, b, c)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e, Database.SQLite.Simple.ToField.ToField f) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e, f)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e, Database.SQLite.Simple.ToField.ToField f, Database.SQLite.Simple.ToField.ToField g) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e, f, g)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e, Database.SQLite.Simple.ToField.ToField f, Database.SQLite.Simple.ToField.ToField g, Database.SQLite.Simple.ToField.ToField h) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e, f, g, h)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e, Database.SQLite.Simple.ToField.ToField f, Database.SQLite.Simple.ToField.ToField g, Database.SQLite.Simple.ToField.ToField h, Database.SQLite.Simple.ToField.ToField i) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e, f, g, h, i)
instance (Database.SQLite.Simple.ToField.ToField a, Database.SQLite.Simple.ToField.ToField b, Database.SQLite.Simple.ToField.ToField c, Database.SQLite.Simple.ToField.ToField d, Database.SQLite.Simple.ToField.ToField e, Database.SQLite.Simple.ToField.ToField f, Database.SQLite.Simple.ToField.ToField g, Database.SQLite.Simple.ToField.ToField h, Database.SQLite.Simple.ToField.ToField i, Database.SQLite.Simple.ToField.ToField j) => Database.SQLite.Simple.ToRow.ToRow (a, b, c, d, e, f, g, h, i, j)
instance Database.SQLite.Simple.ToField.ToField a => Database.SQLite.Simple.ToRow.ToRow [a]
instance (Database.SQLite.Simple.ToRow.ToRow a, Database.SQLite.Simple.ToRow.ToRow b) => Database.SQLite.Simple.ToRow.ToRow (a Database.SQLite.Simple.Types.:. b)
instance Database.SQLite.Simple.ToRow.GToRow GHC.Generics.U1
instance Database.SQLite.Simple.ToField.ToField a => Database.SQLite.Simple.ToRow.GToRow (GHC.Generics.K1 i a)
instance (Database.SQLite.Simple.ToRow.GToRow a, Database.SQLite.Simple.ToRow.GToRow b) => Database.SQLite.Simple.ToRow.GToRow (a GHC.Generics.:*: b)
instance Database.SQLite.Simple.ToRow.GToRow a => Database.SQLite.Simple.ToRow.GToRow (GHC.Generics.M1 i c a)


-- | The <a>sql</a> quasiquoter, for writing large <tt>SQL</tt> statements.
module Database.SQLite.Simple.QQ

-- | A quasiquoter for writing big <tt>SQL</tt> queries.
--   
--   One should consider turning on the <tt>-XQuasiQuotes</tt> pragma in
--   that module:
--   
--   <pre>
--   {-# LANGUAGE QuasiQuotes #-}
--   
--   myQuery = query conn [sql|
--       SELECT
--         *
--       FROM
--         users
--       WHERE jobTitle = ?
--       |] jobTitle
--   </pre>
sql :: QuasiQuoter


-- | The <a>FromField</a> typeclass, for converting a single value in a row
--   returned by a SQL query into a more useful Haskell representation.
--   
--   A Haskell numeric type is considered to be compatible with all SQLite
--   numeric types that are less accurate than it. For instance, the
--   Haskell <a>Double</a> type is compatible with the SQLite's 32-bit
--   <tt>Int</tt> type because it can represent a <tt>Int</tt> exactly. On
--   the other hand, since a <a>Double</a> might lose precision if
--   representing a 64-bit <tt>BigInt</tt>, the two are <i>not</i>
--   considered compatible.
module Database.SQLite.Simple.FromField

-- | A type that may be converted from a SQL type.
class FromField a

-- | Convert a SQL value to a Haskell value.
--   
--   Returns a list of exceptions if the conversion fails. In the case of
--   library instances, this will usually be a single <a>ResultError</a>,
--   but may be a <tt>UnicodeException</tt>.
--   
--   Implementations of <a>fromField</a> should not retain any references
--   to the <a>Field</a> nor the <a>ByteString</a> arguments after the
--   result has been evaluated to WHNF. Such a reference causes the entire
--   <tt>LibPQ.<a>Result</a></tt> to be retained.
--   
--   For example, the instance for <a>ByteString</a> uses <a>copy</a> to
--   avoid such a reference, and that using bytestring functions such as
--   <a>drop</a> and <a>takeWhile</a> alone will also trigger this memory
--   leak.
fromField :: FromField a => FieldParser a
type FieldParser a = Field -> Ok a

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError

-- | The SQL and Haskell types are not compatible.
Incompatible :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | A SQL <tt>NULL</tt> was encountered when the Haskell type did not
--   permit it.
UnexpectedNull :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | The SQL value could not be parsed, or could not be represented as a
--   valid Haskell value, or an unexpected low-level error occurred (e.g.
--   mismatch between metadata and actual data in a row).
ConversionFailed :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | A Field represents metadata about a particular field
data Field

-- | Return the actual SQL data for a database field. This allows
--   user-defined <a>FromField</a> instances to access the SQL data
--   associated with a field being parsed.
fieldData :: Field -> SQLData

-- | Given one of the constructors from <a>ResultError</a>, the field, and
--   an <a>errMessage</a>, this fills in the other fields in the exception
--   value and returns it in a 'Left . SomeException' constructor.
returnError :: forall a err. (Typeable a, Exception err) => (String -> String -> String -> err) -> Field -> String -> Ok a
instance GHC.Show.Show Database.SQLite.Simple.FromField.ResultError
instance GHC.Classes.Eq Database.SQLite.Simple.FromField.ResultError
instance Database.SQLite.Simple.FromField.FromField a => Database.SQLite.Simple.FromField.FromField (GHC.Maybe.Maybe a)
instance Database.SQLite.Simple.FromField.FromField Database.SQLite.Simple.Types.Null
instance Database.SQLite.Simple.FromField.FromField GHC.Int.Int8
instance Database.SQLite.Simple.FromField.FromField GHC.Int.Int16
instance Database.SQLite.Simple.FromField.FromField GHC.Int.Int32
instance Database.SQLite.Simple.FromField.FromField GHC.Types.Int
instance Database.SQLite.Simple.FromField.FromField GHC.Int.Int64
instance Database.SQLite.Simple.FromField.FromField GHC.Num.Integer.Integer
instance Database.SQLite.Simple.FromField.FromField GHC.Word.Word8
instance Database.SQLite.Simple.FromField.FromField GHC.Word.Word16
instance Database.SQLite.Simple.FromField.FromField GHC.Word.Word32
instance Database.SQLite.Simple.FromField.FromField GHC.Word.Word64
instance Database.SQLite.Simple.FromField.FromField GHC.Types.Word
instance Database.SQLite.Simple.FromField.FromField GHC.Types.Double
instance Database.SQLite.Simple.FromField.FromField GHC.Types.Float
instance Database.SQLite.Simple.FromField.FromField GHC.Types.Bool
instance Database.SQLite.Simple.FromField.FromField Data.Text.Internal.Text
instance Database.SQLite.Simple.FromField.FromField Data.Text.Internal.Lazy.Text
instance Database.SQLite.Simple.FromField.FromField [GHC.Types.Char]
instance Database.SQLite.Simple.FromField.FromField Data.ByteString.Internal.Type.ByteString
instance Database.SQLite.Simple.FromField.FromField Data.ByteString.Lazy.Internal.ByteString
instance Database.SQLite.Simple.FromField.FromField Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.SQLite.Simple.FromField.FromField Data.Time.Calendar.Days.Day
instance Database.SQLite.Simple.FromField.FromField Database.SQLite3.SQLData
instance GHC.Exception.Type.Exception Database.SQLite.Simple.FromField.ResultError


-- | The <a>FromRow</a> typeclass, for converting a row of results returned
--   by a SQL query into a more useful Haskell representation.
--   
--   Predefined instances are provided for tuples containing up to ten
--   elements.
module Database.SQLite.Simple.FromRow

-- | Generic derivation of <a>FromRow</a>.
--   
--   Instantiating <a>FromRow</a> can in some cases be quite tedious.
--   Luckily we can derive it generically in some cases where the type at
--   hand has a <a>Generic</a> instance. The current implementation only
--   works for a (n-ary) product types. So we would not be able to e.g.
--   derive a <a>FromRow</a> instance for
--   
--   <pre>
--   data Bool = True | False
--   </pre>
--   
--   We <i>can</i>, however, derive a generic instance for the
--   <tt>User</tt> type (see the example in <a>FromRow</a>).
class GFromRow f
gfromRow :: GFromRow f => RowParser (f a)

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   <pre>
--   data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where
--       fromRow = User &lt;$&gt; <a>field</a> &lt;*&gt; <a>field</a>
--   </pre>
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
--   
--   <h3>Generic implementation</h3>
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>FromRow</a>. With a <a>Generic</a>
--   instance for <tt>User</tt>, the example above could be written:
--   
--   <pre>
--   instance <a>FromRow</a> User where
--   </pre>
--   
--   With <tt>-XDeriveAnyClass -XDerivingStrategies</tt> the same can be
--   written:
--   
--   <pre>
--   deriving anyclass instance <a>FromRow</a> User
--   </pre>
--   
--   For more details refer to <a>GFromRow</a>.
class FromRow a
fromRow :: FromRow a => RowParser a
fromRow :: (FromRow a, Generic a) => GFromRow (Rep a) => RowParser a
data RowParser a
field :: FromField a => RowParser a
fieldWith :: FieldParser a -> RowParser a
numFieldsRemaining :: RowParser Int
instance Database.SQLite.Simple.FromField.FromField a => Database.SQLite.Simple.FromRow.FromRow (Data.Tuple.Only.Only a)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b) => Database.SQLite.Simple.FromRow.FromRow (a, b)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c) => Database.SQLite.Simple.FromRow.FromRow (a, b, c)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e, Database.SQLite.Simple.FromField.FromField f) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e, f)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e, Database.SQLite.Simple.FromField.FromField f, Database.SQLite.Simple.FromField.FromField g) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e, f, g)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e, Database.SQLite.Simple.FromField.FromField f, Database.SQLite.Simple.FromField.FromField g, Database.SQLite.Simple.FromField.FromField h) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e, f, g, h)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e, Database.SQLite.Simple.FromField.FromField f, Database.SQLite.Simple.FromField.FromField g, Database.SQLite.Simple.FromField.FromField h, Database.SQLite.Simple.FromField.FromField i) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e, f, g, h, i)
instance (Database.SQLite.Simple.FromField.FromField a, Database.SQLite.Simple.FromField.FromField b, Database.SQLite.Simple.FromField.FromField c, Database.SQLite.Simple.FromField.FromField d, Database.SQLite.Simple.FromField.FromField e, Database.SQLite.Simple.FromField.FromField f, Database.SQLite.Simple.FromField.FromField g, Database.SQLite.Simple.FromField.FromField h, Database.SQLite.Simple.FromField.FromField i, Database.SQLite.Simple.FromField.FromField j) => Database.SQLite.Simple.FromRow.FromRow (a, b, c, d, e, f, g, h, i, j)
instance Database.SQLite.Simple.FromField.FromField a => Database.SQLite.Simple.FromRow.FromRow [a]
instance (Database.SQLite.Simple.FromRow.FromRow a, Database.SQLite.Simple.FromRow.FromRow b) => Database.SQLite.Simple.FromRow.FromRow (a Database.SQLite.Simple.Types.:. b)
instance Database.SQLite.Simple.FromRow.GFromRow GHC.Generics.U1
instance Database.SQLite.Simple.FromField.FromField a => Database.SQLite.Simple.FromRow.GFromRow (GHC.Generics.K1 i a)
instance Database.SQLite.Simple.FromRow.GFromRow a => Database.SQLite.Simple.FromRow.GFromRow (GHC.Generics.M1 i c a)
instance (Database.SQLite.Simple.FromRow.GFromRow a, Database.SQLite.Simple.FromRow.GFromRow b) => Database.SQLite.Simple.FromRow.GFromRow (a GHC.Generics.:*: b)


module Database.SQLite.Simple

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.SQLite.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <tt>Text</tt>, and literal Haskell strings
--   that contain Unicode characters will be correctly transformed to
--   UTF-8.
newtype Query
Query :: Text -> Query
[fromQuery] :: Query -> Text

-- | Connection to an open database.
--   
--   You can use <a>connectionHandle</a> to gain access to the underlying
--   <a>http://hackage.haskell.org/package/direct-sqlite</a> connection.
--   This may be useful if you need to access some direct-sqlite
--   functionality that's not exposed in the sqlite-simple API. This should
--   be a safe thing to do although mixing both APIs is discouraged.
data Connection
Connection :: {-# UNPACK #-} !Database -> {-# UNPACK #-} !IORef Word64 -> Connection
[connectionHandle] :: Connection -> {-# UNPACK #-} !Database
[connectionTempNameCounter] :: Connection -> {-# UNPACK #-} !IORef Word64

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>ToRow</a>. Refer to the documentation
--   for <a>FromRow</a> to see how this can be done.
class ToRow a

-- | <a>ToField</a> a collection of values.
toRow :: ToRow a => a -> [SQLData]

-- | <a>ToField</a> a collection of values.
toRow :: (ToRow a, Generic a) => GToRow (Rep a) => a -> [SQLData]

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   <pre>
--   data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where
--       fromRow = User &lt;$&gt; <a>field</a> &lt;*&gt; <a>field</a>
--   </pre>
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
--   
--   <h3>Generic implementation</h3>
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>FromRow</a>. With a <a>Generic</a>
--   instance for <tt>User</tt>, the example above could be written:
--   
--   <pre>
--   instance <a>FromRow</a> User where
--   </pre>
--   
--   With <tt>-XDeriveAnyClass -XDerivingStrategies</tt> the same can be
--   written:
--   
--   <pre>
--   deriving anyclass instance <a>FromRow</a> User
--   </pre>
--   
--   For more details refer to <a>GFromRow</a>.
class FromRow a
fromRow :: FromRow a => RowParser a
fromRow :: (FromRow a, Generic a) => GFromRow (Rep a) => RowParser a

-- | The 1-tuple type or single-value "collection".
--   
--   This type is structurally equivalent to the <a>Identity</a> type, but
--   its intent is more about serving as the anonymous 1-tuple type missing
--   from Haskell for attaching typeclass instances.
--   
--   Parameter usage example:
--   
--   <pre>
--   encodeSomething (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result usage example:
--   
--   <pre>
--   xs &lt;- decodeSomething
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype () => Only a
Only :: a -> Only a
[fromOnly] :: Only a -> a

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data h :. t
(:.) :: h -> t -> (:.) h t
infixr 3 :.
infixr 3 :.
data () => SQLData
SQLInteger :: !Int64 -> SQLData
SQLFloat :: !Double -> SQLData
SQLText :: !Text -> SQLData
SQLBlob :: !ByteString -> SQLData
SQLNull :: SQLData

-- | An SQLite prepared statement.
newtype Statement
Statement :: Statement -> Statement
[unStatement] :: Statement -> Statement

-- | Index of a column in a result set. Column indices start from 0.
newtype ColumnIndex
ColumnIndex :: ColumnIndex -> ColumnIndex
data NamedParam
[:=] :: ToField v => Text -> v -> NamedParam
infixr 3 :=

-- | Open a database connection to a given file. Will throw an exception if
--   it cannot connect.
--   
--   Every <a>open</a> must be closed with a call to <a>close</a>.
--   
--   If you specify ":memory:" or an empty string as the input filename,
--   then a private, temporary in-memory database is created for the
--   connection. This database will vanish when you close the connection.
open :: String -> IO Connection

-- | Close a database connection.
close :: Connection -> IO ()

-- | Opens a database connection, executes an action using this connection,
--   and closes the connection, even in the presence of exceptions.
withConnection :: String -> (Connection -> IO a) -> IO a

-- | <a>http://www.sqlite.org/c3ref/profile.html</a>
--   
--   Enable/disable tracing of SQL execution. Tracing can be disabled by
--   setting <a>Nothing</a> as the logger callback.
--   
--   Warning: If the logger callback throws an exception, your whole
--   program may crash. Enable only for debugging!
setTrace :: Connection -> Maybe (Text -> IO ()) -> IO ()

-- | Perform a <tt>SELECT</tt> or other SQL query that is expected to
--   return results. All results are retrieved and converted before this
--   function returns.
--   
--   When processing large results, this function will consume a lot of
--   client-side memory. Consider using <a>fold</a> instead.
--   
--   Exceptions that may be thrown:
--   
--   <ul>
--   <li><a>FormatError</a>: the query string mismatched with given
--   arguments.</li>
--   <li><a>ResultError</a>: result conversion failed.</li>
--   </ul>
query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]

-- | A version of <a>query</a> that does not perform query substitution.
query_ :: FromRow r => Connection -> Query -> IO [r]

-- | A version of <a>query</a> that takes an explicit <a>RowParser</a>.
queryWith :: ToRow q => RowParser r -> Connection -> Query -> q -> IO [r]

-- | A version of <a>query</a> that does not perform query substitution and
--   takes an explicit <a>RowParser</a>.
queryWith_ :: RowParser r -> Connection -> Query -> IO [r]

-- | A version of <a>query</a> where the query parameters (placeholders)
--   are named.
--   
--   Example:
--   
--   <pre>
--   r &lt;- <a>queryNamed</a> c "SELECT * FROM posts WHERE id=:id AND date&gt;=:date" [":id" <a>:=</a> postId, ":date" <a>:=</a> afterDate]
--   </pre>
queryNamed :: FromRow r => Connection -> Query -> [NamedParam] -> IO [r]

-- | Returns the rowid of the most recent successful INSERT on the given
--   database connection.
--   
--   See also <a>http://www.sqlite.org/c3ref/last_insert_rowid.html</a>.
lastInsertRowId :: Connection -> IO Int64

-- | <a>http://www.sqlite.org/c3ref/changes.html</a>
--   
--   Return the number of rows that were changed, inserted, or deleted by
--   the most recent <tt>INSERT</tt>, <tt>DELETE</tt>, or <tt>UPDATE</tt>
--   statement.
changes :: Connection -> IO Int

-- | <a>http://www.sqlite.org/c3ref/total_changes.html</a>
--   
--   Return the total number of row changes caused by <tt>INSERT</tt>,
--   <tt>DELETE</tt>, or <tt>UPDATE</tt> statements since the
--   <tt>Database</tt> was opened.
totalChanges :: Connection -> IO Int

-- | Perform a <tt>SELECT</tt> or other SQL query that is expected to
--   return results. Results are converted and fed into the <tt>action</tt>
--   callback as they are being retrieved from the database.
--   
--   This allows gives the possibility of processing results in constant
--   space (for instance writing them to disk).
--   
--   Exceptions that may be thrown:
--   
--   <ul>
--   <li><a>FormatError</a>: the query string mismatched with given
--   arguments.</li>
--   <li><a>ResultError</a>: result conversion failed.</li>
--   </ul>
fold :: (FromRow row, ToRow params) => Connection -> Query -> params -> a -> (a -> row -> IO a) -> IO a

-- | A version of <a>fold</a> which does not perform parameter
--   substitution.
fold_ :: FromRow row => Connection -> Query -> a -> (a -> row -> IO a) -> IO a

-- | A version of <a>fold</a> where the query parameters (placeholders) are
--   named.
foldNamed :: FromRow row => Connection -> Query -> [NamedParam] -> a -> (a -> row -> IO a) -> IO a

-- | Execute an <tt>INSERT</tt>, <tt>UPDATE</tt>, or other SQL query that
--   is not expected to return results.
--   
--   Throws <a>FormatError</a> if the query could not be formatted
--   correctly.
execute :: ToRow q => Connection -> Query -> q -> IO ()

-- | A version of <a>execute</a> that does not perform query substitution.
execute_ :: Connection -> Query -> IO ()

-- | Execute a multi-row <tt>INSERT</tt>, <tt>UPDATE</tt>, or other SQL
--   query that is not expected to return results.
--   
--   Throws <a>FormatError</a> if the query could not be formatted
--   correctly.
executeMany :: ToRow q => Connection -> Query -> [q] -> IO ()

-- | A version of <a>execute</a> where the query parameters (placeholders)
--   are named.
executeNamed :: Connection -> Query -> [NamedParam] -> IO ()
field :: FromField a => RowParser a

-- | Run an IO action inside a SQL transaction started with <tt>BEGIN
--   TRANSACTION</tt>. If the action throws any kind of an exception, the
--   transaction will be rolled back with <tt>ROLLBACK TRANSACTION</tt>.
--   Otherwise the results are committed with <tt>COMMIT TRANSACTION</tt>.
withTransaction :: Connection -> IO a -> IO a

-- | Run an IO action inside a SQL transaction started with <tt>BEGIN
--   IMMEDIATE TRANSACTION</tt>, which immediately blocks all other
--   database connections from writing. The default SQLite3 <tt>BEGIN
--   TRANSACTION</tt> does not acquire the write lock on <tt>BEGIN</tt> nor
--   on <tt>SELECT</tt> but waits until you try to change data. If the
--   action throws any kind of an exception, the transaction will be rolled
--   back with <tt>ROLLBACK TRANSACTION</tt>. Otherwise the results are
--   committed with <tt>COMMIT TRANSACTION</tt>.
withImmediateTransaction :: Connection -> IO a -> IO a

-- | Run an IO action inside a SQL transaction started with <tt>BEGIN
--   EXCLUSIVE TRANSACTION</tt>, which immediately blocks all other
--   database connections from writing, and other connections from reading
--   (exception: read_uncommitted connections are allowed to read.) If the
--   action throws any kind of an exception, the transaction will be rolled
--   back with <tt>ROLLBACK TRANSACTION</tt>. Otherwise the results are
--   committed with <tt>COMMIT TRANSACTION</tt>.
withExclusiveTransaction :: Connection -> IO a -> IO a

-- | Run an IO action inside an SQLite <tt>SAVEPOINT</tt>. If the action
--   throws any kind of an exception, the transaction will be rolled back
--   to the savepoint with <tt>ROLLBACK TO</tt>. Otherwise the results are
--   released to the outer transaction if any with <tt>RELEASE</tt>.
--   
--   See <a>https://sqlite.org/lang_savepoint.html</a> for a full
--   description of savepoint semantics.
withSavepoint :: Connection -> IO a -> IO a

-- | Opens a prepared statement. A prepared statement must always be closed
--   with a corresponding call to <a>closeStatement</a> before closing the
--   connection. Use <a>nextRow</a> to iterate on the values returned. Once
--   <a>nextRow</a> returns <a>Nothing</a>, you need to invoke <a>reset</a>
--   before reexecuting the statement again with <a>nextRow</a>.
openStatement :: Connection -> Query -> IO Statement

-- | Closes a prepared statement.
closeStatement :: Statement -> IO ()

-- | Opens a prepared statement, executes an action using this statement,
--   and closes the statement, even in the presence of exceptions.
withStatement :: Connection -> Query -> (Statement -> IO a) -> IO a

-- | Binds parameters to a prepared statement. Once <a>nextRow</a> returns
--   <a>Nothing</a>, the statement must be reset with the <a>reset</a>
--   function before it can be executed again by calling <a>nextRow</a>.
bind :: ToRow params => Statement -> params -> IO ()

-- | Binds named parameters to a prepared statement.
bindNamed :: Statement -> [NamedParam] -> IO ()

-- | Resets a statement. This does not reset bound parameters, if any, but
--   allows the statement to be reexecuted again by invoking
--   <a>nextRow</a>.
reset :: Statement -> IO ()

-- | Return the name of a particular column in the result set of a
--   <a>Statement</a>. Throws an <a>ArrayException</a> if the colum index
--   is out of bounds.
--   
--   <a>http://www.sqlite.org/c3ref/column_name.html</a>
columnName :: Statement -> ColumnIndex -> IO Text

-- | Return number of columns in the query
columnCount :: Statement -> IO ColumnIndex

-- | Binds parameters to a prepared statement, and <a>reset</a>s the
--   statement when the callback completes, even in the presence of
--   exceptions.
--   
--   Use <a>withBind</a> to reuse prepared statements. Because it
--   <a>reset</a>s the statement <i>after</i> each usage, it avoids a
--   pitfall involving implicit transactions. SQLite creates an implicit
--   transaction if you don't say <tt>BEGIN</tt> explicitly, and does not
--   commit it until all active statements are finished with either
--   <a>reset</a> or <a>closeStatement</a>.
withBind :: ToRow params => Statement -> params -> IO a -> IO a

-- | Extracts the next row from the prepared statement.
nextRow :: FromRow r => Statement -> IO (Maybe r)

-- | Exception thrown if a <a>Query</a> was malformed. This may occur if
--   the number of '<tt>?</tt>' characters in the query string does not
--   match the number of parameters provided.
data FormatError
FormatError :: String -> Query -> [String] -> FormatError
[fmtMessage] :: FormatError -> String
[fmtQuery] :: FormatError -> Query
[fmtParams] :: FormatError -> [String]

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError

-- | The SQL and Haskell types are not compatible.
Incompatible :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | A SQL <tt>NULL</tt> was encountered when the Haskell type did not
--   permit it.
UnexpectedNull :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | The SQL value could not be parsed, or could not be represented as a
--   valid Haskell value, or an unexpected low-level error occurred (e.g.
--   mismatch between metadata and actual data in a row).
ConversionFailed :: String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | Exception thrown when SQLite3 reports an error.
--   
--   direct-sqlite may throw other types of exceptions if you misuse the
--   API.
data () => SQLError
SQLError :: !Error -> Text -> Text -> SQLError

-- | Error code returned by API call
[sqlError] :: SQLError -> !Error

-- | Text describing the error
[sqlErrorDetails] :: SQLError -> Text

-- | Indicates what action produced this error, e.g. <tt>exec "SELECT *
--   FROM foo"</tt>
[sqlErrorContext] :: SQLError -> Text

-- | <a>https://www.sqlite.org/c3ref/c_abort.html</a>
--   <a>https://www.sqlite.org/c3ref/c_abort_rollback.html</a>
data () => Error

-- | Successful result
ErrorOK :: Error

-- | SQL error or missing database
ErrorError :: Error

-- | Internal logic error in SQLite
ErrorInternal :: Error

-- | Access permission denied
ErrorPermission :: Error

-- | Callback routine requested an abort
ErrorAbort :: Error

-- | The database file is locked
ErrorBusy :: Error

-- | A table in the database is locked
ErrorLocked :: Error

-- | A <tt>malloc()</tt> failed
ErrorNoMemory :: Error

-- | Attempt to write a readonly database
ErrorReadOnly :: Error

-- | Operation terminated by <tt>sqlite3_interrupt()</tt>
ErrorInterrupt :: Error

-- | Some kind of disk I/O error occurred
ErrorIO :: Error

-- | The database disk image is malformed
ErrorCorrupt :: Error

-- | Unknown opcode in <tt>sqlite3_file_control()</tt>
ErrorNotFound :: Error

-- | Insertion failed because database is full
ErrorFull :: Error

-- | Unable to open the database file
ErrorCan'tOpen :: Error

-- | Database lock protocol error
ErrorProtocol :: Error

-- | Database is empty
ErrorEmpty :: Error

-- | The database schema changed
ErrorSchema :: Error

-- | String or BLOB exceeds size limit
ErrorTooBig :: Error

-- | Abort due to constraint violation
ErrorConstraint :: Error

-- | Data type mismatch
ErrorMismatch :: Error

-- | Library used incorrectly
ErrorMisuse :: Error

-- | Uses OS features not supported on host
ErrorNoLargeFileSupport :: Error

-- | Authorization denied
ErrorAuthorization :: Error

-- | Auxiliary database format error
ErrorFormat :: Error

-- | 2nd parameter to sqlite3_bind out of range
ErrorRange :: Error

-- | File opened that is not a database file
ErrorNotADatabase :: Error

-- | Notifications from sqlite3_log()
ErrorNotice :: Error

-- | Warnings from sqlite3_log()
ErrorWarning :: Error

-- | <tt>sqlite3_step()</tt> has another row ready
ErrorRow :: Error

-- | <tt>sqlite3_step()</tt> has finished executing
ErrorDone :: Error
ErrorErrorMissingCollatingSquence :: Error
ErrorErrorRetry :: Error
ErrorErrorSnapshot :: Error
ErrorIORead :: Error
ErrorIOShortRead :: Error
ErrorIOWrite :: Error
ErrorIOFsync :: Error
ErrorIODirectoryFsync :: Error
ErrorIOTruncate :: Error
ErrorIOFstat :: Error
ErrorIOUnlock :: Error
ErrorIOReadLock :: Error
ErrorIOBlocked :: Error
ErrorIODelete :: Error
ErrorIONoMemory :: Error
ErrorIOAccess :: Error
ErrorIOCheckReservedLock :: Error
ErrorIOLock :: Error
ErrorIOClose :: Error
ErrorIODirectoryClose :: Error
ErrorIOShmOpen :: Error
ErrorIOShmSize :: Error
ErrorIOShmLock :: Error
ErrorIOShmMap :: Error
ErrorIOSeek :: Error
ErrorIODeleteNoEntity :: Error
ErrorIOMmap :: Error
ErrorIOGetTempPath :: Error
ErrorIOConvertedPath :: Error
ErrorIOVNode :: Error
ErrorIOAuth :: Error
ErrorIOBeginAtomic :: Error
ErrorIOCommitAtomic :: Error
ErrorIORollbackAtomic :: Error
ErrorIOData :: Error
ErrorIOCorruptFilesystem :: Error
ErrorLockedSharedCache :: Error
ErrorLockedVirtualTable :: Error
ErrorBusyRecovery :: Error
ErrorBusySnapshot :: Error
ErrorBusyTimeout :: Error
ErrorCan'tOpenNotTempDirectory :: Error
ErrorCan'tOpenIsDirectory :: Error
ErrorCan'tOpenFullPath :: Error
ErrorCan'tOpenConvertedPath :: Error
ErrorCan'tOpenDirtyWriteAheadLog :: Error
ErrorCan'tOpenSymlink :: Error
ErrorCorruptVirtualTable :: Error
ErrorCorruptSequence :: Error
ErrorCorruptIndex :: Error
ErrorReadOnlyRecovery :: Error
ErrorReadOnlyCan'tLock :: Error
ErrorReadOnlyRollback :: Error
ErrorReadOnlyDatabaseMoved :: Error
ErrorReadOnlyCan'tInit :: Error
ErrorReadOnlyDirectory :: Error
ErrorAbortRollback :: Error
ErrorConstraintCheck :: Error
ErrorConstraintCommitHook :: Error
ErrorConstraintForeignKey :: Error
ErrorConstraintFunction :: Error
ErrorConstraintNotNull :: Error
ErrorConstraintPrimaryKey :: Error
ErrorConstraintTrigger :: Error
ErrorConstraintUnique :: Error
ErrorConstraintVirtualTable :: Error
ErrorConstraintRowId :: Error
ErrorConstraintPinned :: Error
ErrorConstraintDataType :: Error
ErrorNoticeRecoverWriteAheadLog :: Error
ErrorNoticeRecoverRollback :: Error
ErrorWarningAutoIndex :: Error
ErrorAuthUser :: Error
ErrorOkLoadPermanently :: Error
instance GHC.Real.Integral Database.SQLite.Simple.ColumnIndex
instance GHC.Real.Real Database.SQLite.Simple.ColumnIndex
instance GHC.Num.Num Database.SQLite.Simple.ColumnIndex
instance GHC.Enum.Enum Database.SQLite.Simple.ColumnIndex
instance GHC.Classes.Ord Database.SQLite.Simple.ColumnIndex
instance GHC.Classes.Eq Database.SQLite.Simple.ColumnIndex
instance GHC.Show.Show Database.SQLite.Simple.FormatError
instance GHC.Classes.Eq Database.SQLite.Simple.FormatError
instance GHC.Exception.Type.Exception Database.SQLite.Simple.FormatError
instance GHC.Show.Show Database.SQLite.Simple.NamedParam

module Database.SQLite.Simple.Function
class Function a
createFunction :: forall f. Function f => Connection -> Text -> f -> IO (Either Error ())
deleteFunction :: Connection -> Text -> IO (Either Error ())
instance Database.SQLite.Simple.ToField.ToField a => Database.SQLite.Simple.Function.Function a
instance Database.SQLite.Simple.Function.Function a => Database.SQLite.Simple.Function.Function (GHC.Types.IO a)
instance (Database.SQLite.Simple.Function.Function r, Database.SQLite.Simple.FromField.FromField f) => Database.SQLite.Simple.Function.Function (f -> r)
