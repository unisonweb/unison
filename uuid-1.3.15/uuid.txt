-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | For creating, comparing, parsing and printing Universally Unique Identifiers
--   
--   This library is useful for creating, comparing, parsing and printing
--   Universally Unique Identifiers.
--   
--   See <a>http://en.wikipedia.org/wiki/UUID</a> for the general idea.
@package uuid
@version 1.3.15


-- | This library is useful for comparing, parsing and printing Universally
--   Unique Identifiers. See <a>http://en.wikipedia.org/wiki/UUID</a> for
--   the general idea. See <a>http://tools.ietf.org/html/rfc4122</a> for
--   the specification.
--   
--   <ul>
--   <li>Use <a>nextRandom</a> to generate secure random UUIDs, and your
--   favorite instance of <a>Random</a> for faster but insecure generation
--   of UUIDs.</li>
--   <li>We have an implementation of generating a UUID from the hardware
--   MAC address and current system time in <a>Data.UUID.V1</a>.</li>
--   <li>For name-based generation of UUIDs using SHA-1 hashing see
--   <a>Data.UUID.V5</a>.</li>
--   </ul>
module Data.UUID

-- | Type representing <a>Universally Unique Identifiers (UUID)</a> as
--   specified in <a>RFC 4122</a>.
data () => UUID

-- | Convert a UUID into a hypenated string using lower-case letters.
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; toString &lt;$&gt; fromString "550e8400-e29b-41d4-a716-446655440000"
--   Just "550e8400-e29b-41d4-a716-446655440000"
--   </pre>
toString :: UUID -> String

-- | If the passed in <a>String</a> can be parsed as a <a>UUID</a>, it will
--   be. The hyphens may not be omitted. Example:
--   
--   <pre>
--   &gt;&gt;&gt; fromString "c2cc10e1-57d6-4b6f-9899-38d972112d8c"
--   Just c2cc10e1-57d6-4b6f-9899-38d972112d8c
--   </pre>
--   
--   Hex digits may be upper or lower-case.
fromString :: String -> Maybe UUID

-- | Convert a UUID into a hyphentated string using lower-case letters.
toText :: UUID -> Text

-- | If the passed in <a>Text</a> can be parsed as an ASCII representation
--   of a <a>UUID</a>, it will be. The hyphens may not be omitted.
fromText :: Text -> Maybe UUID

-- | Convert a UUID into a hyphentated string using lower-case letters,
--   packed as ASCII bytes into <a>ByteString</a>.
--   
--   This should be equivalent to <a>toString</a> with <a>pack</a>.
toASCIIBytes :: UUID -> ByteString

-- | If the passed in <a>ByteString</a> can be parsed as an ASCII
--   representation of a <a>UUID</a>, it will be. The hyphens may not be
--   omitted.
--   
--   This should be equivalent to <a>fromString</a> with <a>unpack</a>.
fromASCIIBytes :: ByteString -> Maybe UUID

-- | Similar to <a>toASCIIBytes</a> except we produce a lazy
--   <a>ByteString</a>.
toLazyASCIIBytes :: UUID -> ByteString

-- | Similar to <a>fromASCIIBytes</a> except parses from a lazy
--   <a>ByteString</a>.
fromLazyASCIIBytes :: ByteString -> Maybe UUID

-- | Encode a UUID into a <tt>ByteString</tt> in network order.
--   
--   This uses the same encoding as the <a>Binary</a> instance.
toByteString :: UUID -> ByteString

-- | Extract a UUID from a <tt>ByteString</tt> in network byte order. The
--   argument must be 16 bytes long, otherwise <a>Nothing</a> is returned.
fromByteString :: ByteString -> Maybe UUID

-- | Convert a <a>UUID</a> into a sequence of <a>Word32</a> values. Useful
--   for when you need to serialize a UUID and neither <a>Storable</a> nor
--   <a>Binary</a> are appropriate.
--   
--   <pre>
--   &gt;&gt;&gt; toWords &lt;$&gt; fromString "550e8400-e29b-41d4-a716-446655440000"
--   Just (1427014656,3801825748,2803254374,1430519808)
--   </pre>
--   
--   See also <a>toWords64</a>.
--   
--   <i>Since: <tt>uuid-1.2.2</tt></i>
toWords :: UUID -> (Word32, Word32, Word32, Word32)

-- | Create a <a>UUID</a> from a sequence of <a>Word32</a>. The inverse of
--   <a>toWords</a>. Useful when you need a total function for constructing
--   <a>UUID</a> values.
--   
--   See also <a>fromWords64</a>.
--   
--   <i>Since: <tt>uuid-1.2.2</tt></i>
fromWords :: Word32 -> Word32 -> Word32 -> Word32 -> UUID

-- | Convert a <a>UUID</a> into a pair of <a>Word64</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; toWords64 &lt;$&gt; fromString "550e8400-e29b-41d4-a716-446655440000"
--   Just (6128981282234515924,12039885860129472512)
--   </pre>
--   
--   See also <a>toWords</a>.
toWords64 :: UUID -> (Word64, Word64)

-- | Create a <a>UUID</a> from a pair of <a>Word64</a>s.
--   
--   Inverse of <a>toWords64</a>. See also <a>fromWords</a>.
fromWords64 :: Word64 -> Word64 -> UUID

-- | Returns true if the passed-in UUID is the <a>nil</a> UUID.
null :: UUID -> Bool

-- | The <a>nil</a> UUID, as defined in <a>RFC 4122</a>. It is a UUID of
--   all zeros. <tt><a>null</a> u</tt> <i>iff</i> <tt><tt>u</tt> ==
--   <a>nil</a></tt>.
nil :: UUID


-- | RFC 4122 Version 1 UUID state machine.
--   
--   The generated UUID is based on the hardware MAC address and the system
--   clock.
--   
--   If we cannot lookup the MAC address we seed the generator with a
--   psuedo-random number.
module Data.UUID.V1

-- | Returns a new UUID derived from the local hardware MAC address and the
--   current system time. Is generated according to the Version 1 UUID
--   specified in RFC 4122.
--   
--   Returns <a>Nothing</a> if you request UUIDs too quickly.
nextUUID :: IO (Maybe UUID)
instance GHC.Show.Show Data.UUID.V1.State
instance Data.UUID.Types.Internal.Builder.ByteSource Data.UUID.V1.MACSource


-- | you need to use this module, you should probably be using
--   <a>Data.UUID.V5</a>, which offers the same sort of functionality as
--   this module except implemented with SHA-1 hashing.
--   
--   This module implements Version 3 UUIDs as specified in RFC 4122.
--   
--   These UUIDs identify an object within a namespace, and are
--   deterministic.
--   
--   The namespace is identified by a UUID. Several sample namespaces are
--   enclosed.
module Data.UUID.V3

-- | Generate a <a>UUID</a> within the specified namespace out of the given
--   object.
--   
--   Uses an MD5 hash. The UUID is built from first 128 bits of the hash of
--   the namespace UUID and the name (as a series of Word8).
generateNamed :: UUID -> [Word8] -> UUID

-- | The namespace for DNS addresses
namespaceDNS :: UUID

-- | The namespace for URLs
namespaceURL :: UUID

-- | The namespace for ISO OIDs
namespaceOID :: UUID

-- | The namespace for X.500 DNs
namespaceX500 :: UUID


-- | This module implements Version 4 UUIDs as specified in RFC 4122.
--   
--   These UUIDs are generated from a pseddo-random generator. We use
--   <a>getEntropy</a> method from <a>entropy</a> package, which should
--   provide cryptographically secure random data.
module Data.UUID.V4

-- | Generate a crytographically secure, random UUID. Introduced in version
--   1.2.6.
nextRandom :: IO UUID


-- | This module implements Version 5 UUIDs as specified in RFC 4122.
--   
--   These UUIDs identify an object within a namespace, and are
--   deterministic.
--   
--   The namespace is identified by a UUID. Several sample namespaces are
--   enclosed.
module Data.UUID.V5

-- | Generate a <a>UUID</a> within the specified namespace out of the given
--   object.
--   
--   Uses a SHA1 hash. The UUID is built from first 128 bits of the hash of
--   the namespace UUID and the name (as a series of Word8).
generateNamed :: UUID -> [Word8] -> UUID

-- | The namespace for DNS addresses
namespaceDNS :: UUID

-- | The namespace for URLs
namespaceURL :: UUID

-- | The namespace for ISO OIDs
namespaceOID :: UUID

-- | The namespace for X.500 DNs
namespaceX500 :: UUID

module Data.UUID.Util
data () => UnpackedUUID
UnpackedUUID :: Word32 -> Word16 -> Word16 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> UnpackedUUID
[time_low] :: UnpackedUUID -> Word32
[time_mid] :: UnpackedUUID -> Word16
[time_hi_and_version] :: UnpackedUUID -> Word16
[clock_seq_hi_res] :: UnpackedUUID -> Word8
[clock_seq_low] :: UnpackedUUID -> Word8
[node_0] :: UnpackedUUID -> Word8
[node_1] :: UnpackedUUID -> Word8
[node_2] :: UnpackedUUID -> Word8
[node_3] :: UnpackedUUID -> Word8
[node_4] :: UnpackedUUID -> Word8
[node_5] :: UnpackedUUID -> Word8
unpack :: UUID -> UnpackedUUID
pack :: UnpackedUUID -> UUID
version :: UUID -> Int
extractMac :: UUID -> Maybe MAC
extractTime :: UUID -> Maybe Int64
setTime :: (Integral a, Bits a) => UUID -> a -> Maybe UUID
