-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-cli
@version 0.0.0

module Compat
onWindows :: Bool

-- | Constructs a default interrupt handler which builds an interrupt
--   handler which throws a UserInterrupt exception to the thread in which
--   the setup was initially called.
defaultInterruptHandler :: IO (IO ())

-- | Replaces any existing interrupt handlers with the provided IO action
--   while the provided action is running, restoring any existing handlers
--   afterwards.
withInterruptHandler :: IO () -> IO a -> IO a

module Stats
newtype RtsStatsPath
RtsStatsPath :: FilePath -> RtsStatsPath
recordRtsStats :: RtsStatsPath -> IO a -> IO a
instance Data.String.IsString Stats.RtsStatsPath
instance GHC.Classes.Eq Stats.RtsStatsPath
instance GHC.Show.Show Stats.RtsStatsPath


-- | A collection of file system utilities that appear to be missing from
--   Directory, FilePath, Prelude, etc. Some of these may overlap with
--   MissingH but the versions here will probably be more simplistic.
--   Furthermore, this library is focused on this one thing and not a whole
--   bunch of things.
module System.Path

-- | Returns a list of nodes in a tree via a depth-first walk.
mtreeList :: Monad m => (a -> m [a]) -> a -> m [a]

-- | Recursively list the contents of a directory. Depth-first.
fileList :: FilePath -> IO [FilePath]

-- | Walk a directory depth-first. Similar to Python's os.walk and
--   fs.core/walk from the fs Clojure library.
walkDir :: FilePath -> IO [Directory]

-- | Copy a directory recursively. Moves every file, creates every
--   directory.
copyDir :: FilePath -> FilePath -> IO ()

-- | Given a root path, a new root path, and a path to be changed, removes
--   the old root from the path and replaces it with to.
replaceRoot :: FilePath -> FilePath -> FilePath -> FilePath

-- | Given a root (prefix), remove it from a path. This is useful for
--   getting the filename and subdirs of a path inside of a root.
removeRoot :: FilePath -> FilePath -> FilePath

-- | We can use this data type to represent the pieces of a directory.
data Directory

-- | The path of the directory itself.
($sel:dirPath:Directory) :: Directory -> FilePath

-- | All subdirectories of this directory.
($sel:subDirs:Directory) :: Directory -> [FilePath]

-- | All files contained in this directory.
($sel:files:Directory) :: Directory -> [FilePath]

-- | Creates a Directory instance from a FilePath.
createDir :: FilePath -> IO Directory

-- | Remove useless paths from a list of paths.
filterUseless :: [FilePath] -> [FilePath]
instance GHC.Show.Show System.Path.Directory

module Unison.Auth.Types
data DiscoveryDoc
DiscoveryDoc :: URI -> URI -> URI -> URI -> DiscoveryDoc
[$sel:issuer:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:authorizationEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:tokenEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:userInfoEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
data Tokens
Tokens :: AccessToken -> Maybe IDToken -> Maybe RefreshToken -> TokenType -> NominalDiffTime -> Scopes -> Tokens
[$sel:accessToken:Tokens] :: Tokens -> AccessToken
[$sel:idToken:Tokens] :: Tokens -> Maybe IDToken
[$sel:refreshToken:Tokens] :: Tokens -> Maybe RefreshToken
[$sel:tokenType:Tokens] :: Tokens -> TokenType
[$sel:expiresIn:Tokens] :: Tokens -> NominalDiffTime
[$sel:scopes:Tokens] :: Tokens -> Scopes
data Credentials
Credentials :: Map ProfileName (Map CodeserverId CodeserverCredentials) -> ProfileName -> Credentials
[$sel:credentials:Credentials] :: Credentials -> Map ProfileName (Map CodeserverId CodeserverCredentials)
[$sel:activeProfile:Credentials] :: Credentials -> ProfileName
type Code = Text
type AccessToken = Text
type RefreshToken = Text
type IDToken = Text
type OAuthState = ByteString
type PKCEVerifier = ByteString
type PKCEChallenge = ByteString
type ProfileName = Text
data CredentialFailure
ReauthRequired :: CodeserverId -> CredentialFailure
CredentialParseFailure :: FilePath -> Text -> CredentialFailure
InvalidDiscoveryDocument :: URI -> Text -> CredentialFailure
InvalidJWT :: Text -> CredentialFailure
RefreshFailure :: Text -> CredentialFailure
InvalidTokenResponse :: URI -> Text -> CredentialFailure
InvalidHost :: CodeserverURI -> CredentialFailure
FailedToFetchUserInfo :: URI -> Text -> CredentialFailure

-- | Credentials for a specific codeserver
data CodeserverCredentials
CodeserverCredentials :: Tokens -> UTCTime -> URI -> UserInfo -> CodeserverCredentials
[$sel:tokens:CodeserverCredentials] :: CodeserverCredentials -> Tokens
[$sel:fetchTime:CodeserverCredentials] :: CodeserverCredentials -> UTCTime
[$sel:discoveryURI:CodeserverCredentials] :: CodeserverCredentials -> URI
[$sel:userInfo:CodeserverCredentials] :: CodeserverCredentials -> UserInfo
data UserInfo
UserInfo :: Text -> Maybe Text -> Text -> UserInfo
[$sel:userId:UserInfo] :: UserInfo -> Text
[$sel:name:UserInfo] :: UserInfo -> Maybe Text
[$sel:handle:UserInfo] :: UserInfo -> Text
getCodeserverCredentials :: CodeserverId -> Credentials -> Either CredentialFailure CodeserverCredentials
setCodeserverCredentials :: CodeserverId -> CodeserverCredentials -> Credentials -> Credentials
codeserverCredentials :: URI -> Tokens -> UTCTime -> UserInfo -> CodeserverCredentials
emptyCredentials :: Credentials
instance GHC.Exception.Type.Exception Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Eq Unison.Auth.Types.CredentialFailure
instance GHC.Show.Show Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Ord Unison.Auth.Types.Scopes
instance GHC.Classes.Eq Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.DiscoveryDoc
instance GHC.Show.Show Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.Tokens
instance GHC.Generics.Generic Unison.Auth.Types.UserInfo
instance GHC.Classes.Eq Unison.Auth.Types.UserInfo
instance GHC.Show.Show Unison.Auth.Types.UserInfo
instance GHC.Classes.Eq Unison.Auth.Types.CodeserverCredentials
instance GHC.Classes.Eq Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.URIParam
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.DiscoveryDoc
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Scopes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Scopes

module Unison.Auth.Discovery
discoveryURIForCodeserver :: CodeserverURI -> URI
fetchDiscoveryDoc :: MonadIO m => URI -> m (Either CredentialFailure DiscoveryDoc)

module Unison.Auth.CredentialFile

-- | Atomically update the credential storage file. Creates an empty file
--   automatically if one doesn't exist.
atomicallyModifyCredentialsFile :: MonadIO m => (Credentials -> Credentials) -> m Credentials

module Unison.Auth.CredentialManager

-- | Saves credentials to the active profile.
saveCredentials :: MonadUnliftIO m => CredentialManager -> CodeserverId -> CodeserverCredentials -> m ()

-- | A <a>CredentialManager</a> knows how to load, save, and cache
--   credentials. It's thread-safe and safe for use across multiple UCM
--   clients. Note: Currently the in-memory cache is _not_ updated if a
--   different UCM updates the credentials file, however this shouldn't
--   pose any problems, since auth will still be refreshed if we encounter
--   any auth failures on requests.
data CredentialManager
newCredentialManager :: MonadIO m => m CredentialManager
getCredentials :: MonadIO m => CredentialManager -> CodeserverId -> m (Either CredentialFailure CodeserverCredentials)

-- | Checks whether CodeserverCredentials are expired.
isExpired :: MonadIO m => CodeserverCredentials -> m Bool

module Unison.Auth.UserInfo

-- | Get user info for an authenticated user.
getUserInfo :: MonadIO m => DiscoveryDoc -> AccessToken -> m (Either CredentialFailure UserInfo)
decodeUserInfo :: ByteString -> Either String UserInfo

module Unison.Auth.Tokens

-- | Given a <a>CodeserverId</a>, provide a valid <a>AccessToken</a> for
--   the associated host. The TokenProvider may automatically refresh
--   access tokens if we have a refresh token.
type TokenProvider = CodeserverId -> IO (Either CredentialFailure AccessToken)

-- | Creates a <a>TokenProvider</a> using the given
--   <a>CredentialManager</a>
newTokenProvider :: CredentialManager -> TokenProvider

-- | Don't yet support automatically refreshing tokens.
--   
--   Specification:
--   <a>https://datatracker.ietf.org/doc/html/rfc6749#section-6</a>
performTokenRefresh :: MonadIO m => DiscoveryDoc -> Tokens -> m (Either CredentialFailure Tokens)


-- | Common types related to merge, pulled down far enough to be imported
--   by all interested parties.
module Unison.Cli.MergeTypes

-- | What are we merging in?
data MergeSource
MergeSource'LocalProjectBranch :: !ProjectAndBranch ProjectName ProjectBranchName -> MergeSource
MergeSource'RemoteProjectBranch :: !ProjectAndBranch ProjectName ProjectBranchName -> MergeSource
MergeSource'RemoteLooseCode :: !ReadShareLooseCode -> MergeSource
type MergeTarget = ProjectAndBranch ProjectName ProjectBranchName

-- | "Alice and Bob"
data MergeSourceAndTarget
MergeSourceAndTarget :: !MergeTarget -> !MergeSource -> MergeSourceAndTarget
[$sel:alice:MergeSourceAndTarget] :: MergeSourceAndTarget -> !MergeTarget
[$sel:bob:MergeSourceAndTarget] :: MergeSourceAndTarget -> !MergeSource

-- | "Either Alice Bob"
data MergeSourceOrTarget
MergeSourceOrTarget'Source :: !MergeSource -> MergeSourceOrTarget
MergeSourceOrTarget'Target :: !MergeTarget -> MergeSourceOrTarget


-- | servant-client utilities
module Unison.Cli.ServantClientUtils
data ConnectionError
ConnectionError'Offline :: ConnectionError
ConnectionError'SomethingElse :: HttpExceptionContent -> ConnectionError
ConnectionError'SomethingEntirelyUnexpected :: SomeException -> ConnectionError

-- | Given a <a>SomeException</a> from a <tt>servant-client</tt>
--   <tt>ClientError</tt>, attempt to classify what happened.
classifyConnectionError :: SomeException -> ConnectionError


-- | Types of <a>Unison.Cli.Share.Projects</a>, put in their own module to
--   avoid cyclic dependencies.
--   
--   Refer to that module's documentation, and use it instead if you can.
--   It re-exports these types.
module Unison.Cli.Share.Projects.Types

-- | A remote project.
data RemoteProject
RemoteProject :: RemoteProjectId -> ProjectName -> Maybe Semver -> RemoteProject
[$sel:projectId:RemoteProject] :: RemoteProject -> RemoteProjectId
[$sel:projectName:RemoteProject] :: RemoteProject -> ProjectName
[$sel:latestRelease:RemoteProject] :: RemoteProject -> Maybe Semver

-- | A remote project branch.
data RemoteProjectBranch
RemoteProjectBranch :: RemoteProjectId -> ProjectName -> RemoteProjectBranchId -> ProjectBranchName -> HashJWT -> Maybe HashJWT -> RemoteProjectBranch
[$sel:projectId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectId
[$sel:projectName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectName
[$sel:branchId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectBranchId
[$sel:branchName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectBranchName
[$sel:branchHead:RemoteProjectBranch] :: RemoteProjectBranch -> HashJWT
[$sel:squashedBranchHead:RemoteProjectBranch] :: RemoteProjectBranch -> Maybe HashJWT
instance GHC.Show.Show Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Generics.Generic Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Classes.Eq Unison.Cli.Share.Projects.Types.RemoteProject
instance GHC.Generics.Generic Unison.Cli.Share.Projects.Types.RemoteProjectBranch
instance GHC.Show.Show Unison.Cli.Share.Projects.Types.RemoteProjectBranch
instance GHC.Classes.Eq Unison.Cli.Share.Projects.Types.RemoteProjectBranch

module Unison.Cli.TypeCheck
computeTypecheckingEnvironment :: ShouldUseTndr Transaction -> Codebase IO Symbol Ann -> [Type Symbol Ann] -> UnisonFile Symbol Ann -> Transaction (Env Symbol Ann)
typecheckTerm :: Codebase IO Symbol Ann -> Term Symbol Ann -> Transaction (Result (Seq (Note Symbol Ann)) (Type Symbol Ann))


-- | This module contains functionality related to computing a "unique type
--   guid lookup" function, which resolves a name to a unique type's GUID
--   to reuse.
module Unison.Cli.UniqueTypeGuidLookup
loadUniqueTypeGuid :: ProjectPath -> Name -> Transaction (Maybe Text)

module Unison.Codebase.Editor.AuthorInfo
data AuthorInfo v a
AuthorInfo :: (Id, Term v a, Type v a) -> AuthorInfo v a
[$sel:guid:AuthorInfo, $sel:author:AuthorInfo, $sel:copyrightHolder:AuthorInfo] :: AuthorInfo v a -> (Id, Term v a, Type v a)
createAuthorInfo :: forall m v a. MonadIO m => Var v => a -> Text -> m (AuthorInfo v a)

module Unison.Codebase.Editor.HandleInput.FormatFile

-- | Format a file, returning a list of Text replacements to apply to the
--   file.
formatFile :: Monad m => (Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> m PrettyPrintEnvDecl) -> Int -> Absolute -> Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe (Set Range) -> m (Maybe [TextReplacement])

-- | Apply a list of range replacements to a text, returning the updated
--   text.
--   
--   <pre>
--   &gt;&gt;&gt; applyFormatUpdates [TextReplacement "cakes" (Range (Pos.Pos 1 21) (Pos.Pos 1 28))] "my favorite food is oranges because\nthey are delicious and nutritious"
--   "my favorite food is cakes because\nthey are delicious and nutritious"
--   </pre>
--   
--   Multiple replacements. &gt;&gt;&gt; let txt = "my favorite food is
--   oranges becausenthey are delicious and nutritious" &gt;&gt;&gt; let
--   replacements = [TextReplacement "cakes" (Range (Pos.Pos 1 21) (Pos.Pos
--   1 28)), TextReplacement "decadent" (Range (Pos.Pos 2 10) (Pos.Pos 2
--   19)), TextReplacement "tasty" (Range (Pos.Pos 2 24) (Pos.Pos 2 34))]
--   &gt;&gt;&gt; applyFormatUpdates replacements txt "my favorite food is
--   cakes becausenthey are decadent and tasty"
--   
--   Multi-line replacements. &gt;&gt;&gt; let txt = "mary had a little
--   lambnwhose fleece was white as snownand everywhere that mary wentnthe
--   lamb was sure to go" &gt;&gt;&gt; let replacements = [TextReplacement
--   "lambo, which" (Range (Pos.Pos 1 19) (Pos.Pos 2 13)), TextReplacement
--   " the people stared" (Range (Pos.Pos 3 99) (Pos.Pos 4 99))]
--   &gt;&gt;&gt; applyFormatUpdates replacements txt "mary had a little
--   lambo, which was white as snownand everywhere that mary went the
--   people stared"
applyTextReplacements :: [TextReplacement] -> Text -> Text

-- | A text replacement to apply to a file.
data TextReplacement
TextReplacement :: Text -> Range -> TextReplacement
[$sel:replacementText:TextReplacement] :: TextReplacement -> Text
[$sel:replacementRange:TextReplacement] :: TextReplacement -> Range
instance GHC.Show.Show Unison.Codebase.Editor.HandleInput.FormatFile.TextReplacement
instance GHC.Classes.Eq Unison.Codebase.Editor.HandleInput.FormatFile.TextReplacement

module Unison.Codebase.Editor.Output.BranchDiff
data BranchDiffOutput v a
BranchDiffOutput :: [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [PatchDisplay] -> [AddedTypeDisplay v a] -> [AddedTermDisplay v a] -> [PatchDisplay] -> [RemovedTypeDisplay v a] -> [RemovedTermDisplay v a] -> [PatchDisplay] -> [RenameTypeDisplay v a] -> [RenameTermDisplay v a] -> BranchDiffOutput v a
[$sel:updatedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:updatedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:newTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:newTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:resolvedTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:resolvedTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:updatedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:addedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTypeDisplay v a]
[$sel:addedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTermDisplay v a]
[$sel:addedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:removedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTypeDisplay v a]
[$sel:removedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTermDisplay v a]
[$sel:removedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:renamedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTypeDisplay v a]
[$sel:renamedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTermDisplay v a]
isEmpty :: BranchDiffOutput v a -> Bool
data TermDisplay v a
TermDisplay :: HashQualified Name -> Referent -> Maybe (Type v a) -> TermDisplay v a
[$sel:name:TermDisplay] :: TermDisplay v a -> HashQualified Name
[$sel:ref:TermDisplay] :: TermDisplay v a -> Referent
[$sel:type_:TermDisplay] :: TermDisplay v a -> Maybe (Type v a)
data TypeDisplay v a
TypeDisplay :: HashQualified Name -> Reference -> Maybe (DeclOrBuiltin v a) -> TypeDisplay v a
[$sel:name:TypeDisplay] :: TypeDisplay v a -> HashQualified Name
[$sel:ref:TypeDisplay] :: TypeDisplay v a -> Reference
[$sel:decl:TypeDisplay] :: TypeDisplay v a -> Maybe (DeclOrBuiltin v a)
type AddedTermDisplay v a = ([HashQualified Name], Referent, Maybe (Type v a))
type AddedTypeDisplay v a = ([HashQualified Name], Reference, Maybe (DeclOrBuiltin v a))
type RemovedTermDisplay v a = ([HashQualified Name], Referent, Maybe (Type v a))
type RemovedTypeDisplay v a = ([HashQualified Name], Reference, Maybe (DeclOrBuiltin v a))
type SimpleTermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type SimpleTypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a))
data UpdateTermDisplay v a
UpdateTermDisplay :: Maybe [SimpleTermDisplay v a] -> [TermDisplay v a] -> UpdateTermDisplay v a
[$sel:old:UpdateTermDisplay] :: UpdateTermDisplay v a -> Maybe [SimpleTermDisplay v a]
[$sel:new:UpdateTermDisplay] :: UpdateTermDisplay v a -> [TermDisplay v a]
data UpdateTypeDisplay v a
UpdateTypeDisplay :: Maybe [SimpleTypeDisplay v a] -> [TypeDisplay v a] -> UpdateTypeDisplay v a
[$sel:old:UpdateTypeDisplay] :: UpdateTypeDisplay v a -> Maybe [SimpleTypeDisplay v a]
[$sel:new:UpdateTypeDisplay] :: UpdateTypeDisplay v a -> [TypeDisplay v a]
type RenameTermDisplay v a = (Referent, Maybe (Type v a), Set (HashQualified Name), Set (HashQualified Name))
type RenameTypeDisplay v a = (Reference, Maybe (DeclOrBuiltin v a), Set (HashQualified Name), Set (HashQualified Name))
type PatchDisplay = (Name, PatchDiff)
toOutput :: forall m v a. Monad m => (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (DeclOrBuiltin v a))) -> Int -> Names -> Names -> BranchDiff -> m (BranchDiffOutput v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Generics.Generic (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.BranchDiffOutput v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.UpdateTypeDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.UpdateTermDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.TypeDisplay v a)
instance GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)
instance GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.TermDisplay v a)

module Unison.Codebase.Editor.Output.DumpNamespace
data DumpNamespace
DumpNamespace :: Map Referent (Set NameSegment) -> Map Reference (Set NameSegment) -> Map NameSegment PatchHash -> Map NameSegment CausalHash -> Set CausalHash -> DumpNamespace
[$sel:terms:DumpNamespace] :: DumpNamespace -> Map Referent (Set NameSegment)
[$sel:types:DumpNamespace] :: DumpNamespace -> Map Reference (Set NameSegment)
[$sel:patches:DumpNamespace] :: DumpNamespace -> Map NameSegment PatchHash
[$sel:children:DumpNamespace] :: DumpNamespace -> Map NameSegment CausalHash
[$sel:causalParents:DumpNamespace] :: DumpNamespace -> Set CausalHash
instance GHC.Show.Show Unison.Codebase.Editor.Output.DumpNamespace.DumpNamespace

module Unison.Codebase.Editor.Output.PushPull
data PushPull
Push :: PushPull
Pull :: PushPull
fold :: a -> a -> PushPull -> a
instance GHC.Show.Show Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Ord Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Eq Unison.Codebase.Editor.Output.PushPull.PushPull

module Unison.Codebase.Editor.SlurpComponent
data SlurpComponent
SlurpComponent :: Set Symbol -> Set Symbol -> Set Symbol -> SlurpComponent
[$sel:types:SlurpComponent] :: SlurpComponent -> Set Symbol
[$sel:terms:SlurpComponent] :: SlurpComponent -> Set Symbol
[$sel:ctors:SlurpComponent] :: SlurpComponent -> Set Symbol
empty :: SlurpComponent
fromTerms :: Set Symbol -> SlurpComponent
fromTypes :: Set Symbol -> SlurpComponent
fromCtors :: Set Symbol -> SlurpComponent
isEmpty :: SlurpComponent -> Bool
difference :: SlurpComponent -> SlurpComponent -> SlurpComponent
intersection :: SlurpComponent -> SlurpComponent -> SlurpComponent
closeWithDependencies :: forall a. TypecheckedUnisonFile Symbol a -> SlurpComponent -> SlurpComponent
instance GHC.Show.Show Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Generics.Generic Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Base.Semigroup Unison.Codebase.Editor.SlurpComponent.SlurpComponent
instance GHC.Base.Monoid Unison.Codebase.Editor.SlurpComponent.SlurpComponent

module Unison.Codebase.Editor.SlurpResult
data SlurpResult
SlurpResult :: TypecheckedUnisonFile Symbol Ann -> SlurpComponent -> SlurpComponent -> SlurpComponent -> SlurpComponent -> SlurpComponent -> Set Symbol -> Set Symbol -> Map Symbol Aliases -> Map Symbol Aliases -> SlurpComponent -> SlurpResult
[$sel:originalFile:SlurpResult] :: SlurpResult -> TypecheckedUnisonFile Symbol Ann
[$sel:extraDefinitions:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:adds:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:duplicates:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:collisions:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:updates:SlurpResult] :: SlurpResult -> SlurpComponent
[$sel:termExistingConstructorCollisions:SlurpResult] :: SlurpResult -> Set Symbol
[$sel:constructorExistingTermCollisions:SlurpResult] :: SlurpResult -> Set Symbol
[$sel:termAlias:SlurpResult] :: SlurpResult -> Map Symbol Aliases
[$sel:typeAlias:SlurpResult] :: SlurpResult -> Map Symbol Aliases
[$sel:defsWithBlockedDependencies:SlurpResult] :: SlurpResult -> SlurpComponent
data Aliases
AddAliases :: Set Name -> Aliases
UpdateAliases :: Set Name -> Set Name -> Aliases
[$sel:oldRefNames:AddAliases] :: Aliases -> Set Name
[$sel:newRefNames:AddAliases] :: Aliases -> Set Name
isOk :: SlurpResult -> Bool
isAllDuplicates :: SlurpResult -> Bool
hasAddsOrUpdates :: SlurpResult -> Bool
filterUnisonFile :: SlurpResult -> TypecheckedUnisonFile Symbol Ann -> TypecheckedUnisonFile Symbol Ann
pretty :: IsPastTense -> PrettyPrintEnv -> SlurpResult -> Pretty ColorText
data Status
Add :: Status
Update :: Status
Duplicate :: Status
Collision :: Status
TermExistingConstructorCollision :: Status
ConstructorExistingTermCollision :: Status
ExtraDefinition :: Status
BlockedDependency :: Status
prettyStatus :: Status -> Pretty ColorText
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.SlurpResult
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Status

module Unison.Codebase.Editor.Slurp

-- | The operation which is being performed or checked.
data SlurpOp
AddOp :: SlurpOp
UpdateOp :: SlurpOp
CheckOp :: SlurpOp

-- | Analyze a file and determine the status of all of its definitions with
--   respect to a set of vars to analyze and an operation you wish to
--   perform.
slurpFile :: TypecheckedUnisonFile Symbol Ann -> Set Symbol -> SlurpOp -> Names -> SlurpResult
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.TaggedVar
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Base.Semigroup Unison.Codebase.Editor.Slurp.SlurpingSummary
instance GHC.Base.Monoid Unison.Codebase.Editor.Slurp.SlurpingSummary

module Unison.Codebase.Editor.UCMVersion
type UCMVersion = Text

module Unison.Codebase.Editor.UriParser
readRemoteNamespaceParser :: ProjectBranchSpecifier branch -> P (ReadRemoteNamespace (These ProjectName branch))
parseReadShareLooseCode :: String -> String -> Either (Pretty ColorText) ReadShareLooseCode
writeRemoteNamespace :: P (These ProjectName ProjectBranchName)
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.User
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.HostInfo


-- | The data model for Unison transcripts.
module Unison.Codebase.Transcript
type ExpectingError = Bool
type ScratchFileName = Text
data Hidden
Shown :: Hidden
HideOutput :: Hidden
HideAll :: Hidden
data UcmLine
UcmCommand :: UcmContext -> Text -> UcmLine

-- | Text does not include the '--' prefix.
UcmComment :: Text -> UcmLine

-- | Where a command is run: a project branch (myproject/mybranch&gt;).
data UcmContext
UcmContextProject :: ProjectAndBranch ProjectName ProjectBranchName -> UcmContext
data APIRequest
GetRequest :: Text -> APIRequest
APIComment :: Text -> APIRequest
pattern CMarkCodeBlock :: Maybe PosInfo -> Text -> Text -> Node
type Stanza = Either Node ProcessedBlock
data ProcessedBlock
Ucm :: Hidden -> ExpectingError -> [UcmLine] -> ProcessedBlock
Unison :: Hidden -> ExpectingError -> Maybe ScratchFileName -> Text -> ProcessedBlock
API :: [APIRequest] -> ProcessedBlock
instance GHC.Show.Show Unison.Codebase.Transcript.Hidden
instance GHC.Classes.Eq Unison.Codebase.Transcript.Hidden


-- | Parse and print CommonMark (like Github-flavored Markdown)
--   transcripts.
module Unison.Codebase.Transcript.Parser
formatAPIRequest :: APIRequest -> Text
formatUcmLine :: UcmLine -> Text
formatStanza :: Stanza -> Text
formatNode :: Node -> Text
formatProcessedBlock :: ProcessedBlock -> Text
processedBlockToNode :: ProcessedBlock -> Node
stanzas :: FilePath -> Text -> Either (ParseErrorBundle Text Void) [Stanza]
ucmLine :: P UcmLine
apiRequest :: P APIRequest

-- | Parses the info string and contents of a fenced code block.
fenced :: P (Maybe ProcessedBlock)
hidden :: P Hidden
expectingError :: P ExpectingError
language :: P Text

module Unison.Codebase.Watch
untilJust :: Monad m => m (Maybe a) -> m a
watchDirectory' :: forall m. MonadIO m => FilePath -> m (IO (), IO (FilePath, UTCTime))
collectUntilPause :: forall a. TQueue a -> Int -> IO [a]
watchDirectory :: forall m. MonadIO m => FilePath -> (FilePath -> Bool) -> m (IO (), IO (FilePath, Text))

module Unison.CommandLine.BranchRelativePath
data BranchRelativePath

-- | A path rooted at some specified branch/project
BranchPathInCurrentProject :: ProjectBranchName -> Absolute -> BranchRelativePath
QualifiedBranchPath :: ProjectName -> ProjectBranchName -> Absolute -> BranchRelativePath

-- | A path which is relative to the user's current location.
UnqualifiedPath :: Path' -> BranchRelativePath

-- | Strings without colons are parsed as loose code paths. A path with a
--   colon may specify: 1. A project and branch 2. Only a branch, in which
--   case the project is assumed to be the current project 3. Only a path,
--   in which case the path is rooted at the branch root
--   
--   Specifying only a project is not allowed.
--   
--   <pre>
--   &gt;&gt;&gt; parseBranchRelativePath "foo"
--   Right (UnqualifiedPath foo)
--   
--   &gt;&gt;&gt; parseBranchRelativePath "foo/bar:"
--   Right (QualifiedBranchPath (UnsafeProjectName "foo") (UnsafeProjectBranchName "bar") .)
--   
--   &gt;&gt;&gt; parseBranchRelativePath "foo/bar:.some.path"
--   Right (QualifiedBranchPath (UnsafeProjectName "foo") (UnsafeProjectBranchName "bar") .some.path)
--   
--   &gt;&gt;&gt; parseBranchRelativePath "/bar:.some.path"
--   Right (BranchPathInCurrentProject (UnsafeProjectBranchName "bar") .some.path)
--   
--   &gt;&gt;&gt; parseBranchRelativePath ":.some.path"
--   Right (UnqualifiedPath .some.path)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBranchRelativePath ".branch"
--   Right (UnqualifiedPath .branch)
--   </pre>
parseBranchRelativePath :: String -> Either (Pretty ColorText) BranchRelativePath
branchRelativePathParser :: Parsec Void Text BranchRelativePath

-- | <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "foo"
--   Right (ProjectOrRelative "foo" foo)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "foo/bar:"
--   Right (IncompletePath (Left (ProjectAndBranch {project = UnsafeProjectName "foo", branch = UnsafeProjectBranchName "bar"})) Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "foo/bar:some.path"
--   Right (IncompletePath (Left (ProjectAndBranch {project = UnsafeProjectName "foo", branch = UnsafeProjectBranchName "bar"})) (Just some.path))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "/bar:some.path"
--   Right (IncompletePath (Right (UnsafeProjectBranchName "bar")) (Just some.path))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath ":some.path"
--   Right (PathRelativeToCurrentBranch some.path)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "/branch"
--   Right (IncompleteBranch Nothing (Just (UnsafeProjectBranchName "branch")))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseIncrementalBranchRelativePath "/"
--   Right (IncompleteBranch Nothing Nothing)
--   </pre>
parseIncrementalBranchRelativePath :: String -> Either (Pretty ColorText) IncrementalBranchRelativePath
data IncrementalBranchRelativePath

-- | no dots, slashes, or colons, so could be a project name or a single
--   path segment
ProjectOrPath' :: Text -> Path' -> IncrementalBranchRelativePath

-- | dots, no slashes or colons, must be a relative or absolute path
OnlyPath' :: Path' -> IncrementalBranchRelativePath

-- | valid project, no slash
IncompleteProject :: ProjectName -> IncrementalBranchRelativePath

-- | valid project/branch, slash, no colon
IncompleteBranch :: Maybe ProjectName -> Maybe ProjectBranchName -> IncrementalBranchRelativePath

-- | valid project/branch, with colon
IncompletePath :: Either (ProjectAndBranch ProjectName ProjectBranchName) ProjectBranchName -> Maybe Absolute -> IncrementalBranchRelativePath
PathRelativeToCurrentBranch :: Absolute -> IncrementalBranchRelativePath
toText :: BranchRelativePath -> Text
instance GHC.Show.Show Unison.CommandLine.BranchRelativePath.BranchRelativePath
instance GHC.Classes.Eq Unison.CommandLine.BranchRelativePath.BranchRelativePath
instance GHC.Show.Show Unison.CommandLine.BranchRelativePath.IncrementalBranchRelativePath
instance Witch.From.From Unison.CommandLine.BranchRelativePath.BranchRelativePath Data.Text.Internal.Text

module Unison.Codebase.Editor.Input
data Input
ForkLocalBranchI :: Either ShortCausalHash BranchRelativePath -> BranchRelativePath -> Input
MergeLocalBranchI :: BranchRelativePath -> Maybe BranchRelativePath -> MergeMode -> Input
PreviewMergeLocalBranchI :: BranchRelativePath -> Maybe BranchRelativePath -> Input
DiffNamespaceI :: BranchId2 -> BranchId2 -> Input
PullI :: !PullSourceTarget -> !PullMode -> Input
PushRemoteBranchI :: PushRemoteBranchInput -> Input
ResetI :: BranchId2 -> Maybe UnresolvedProjectBranch -> Input
CreateMessage :: Pretty ColorText -> Input
SwitchBranchI :: Path' -> Input
UpI :: Input
PopBranchI :: Input
NamesI :: IsGlobal -> HashQualified Name -> Input
AliasTermI :: !Bool -> HashOrHQSplit' -> Split' -> Input
AliasTypeI :: !Bool -> HashOrHQSplit' -> Split' -> Input
AliasManyI :: [HQSplit] -> Path' -> Input
MoveAllI :: Path' -> Path' -> Input
MoveTermI :: HQSplit' -> Split' -> Input
MoveTypeI :: HQSplit' -> Split' -> Input
MoveBranchI :: Path' -> Path' -> Input
DeleteI :: DeleteTarget -> Input
LoadI :: Maybe FilePath -> Input
ClearI :: Input
AddI :: Set Name -> Input
PreviewAddI :: Set Name -> Input
UpdateI :: OptionalPatch -> Set Name -> Input
Update2I :: Input
PreviewUpdateI :: Set Name -> Input
TodoI :: Input
UndoI :: Input
HistoryI :: Maybe Int -> Maybe Int -> BranchId -> Input
ExecuteI :: HashQualified Name -> [String] -> Input
SaveExecuteResultI :: Name -> Input
IOTestI :: HashQualified Name -> Input
IOTestAllI :: Input
MakeStandaloneI :: String -> HashQualified Name -> Input
ExecuteSchemeI :: HashQualified Name -> [String] -> Input
CompileSchemeI :: Bool -> Text -> HashQualified Name -> Input
TestI :: TestInput -> Input
CreateAuthorI :: NameSegment -> Text -> Input
DisplayI :: OutputLocation -> NonEmpty (HashQualified Name) -> Input
DocsI :: NonEmpty Name -> Input
FindI :: Bool -> FindScope -> [String] -> Input
FindShallowI :: Path' -> Input
StructuredFindI :: FindScope -> HashQualified Name -> Input
StructuredFindReplaceI :: HashQualified Name -> Input
TextFindI :: Bool -> [String] -> Input
ShowDefinitionI :: OutputLocation -> ShowDefinitionScope -> NonEmpty (HashQualified Name) -> Input
ShowRootReflogI :: Input
ShowGlobalReflogI :: Input
ShowProjectReflogI :: Maybe ProjectName -> Input
ShowProjectBranchReflogI :: Maybe (ProjectAndBranch (Maybe ProjectName) ProjectBranchName) -> Input
UpdateBuiltinsI :: Input
MergeBuiltinsI :: Maybe Path -> Input
MergeIOBuiltinsI :: Maybe Path -> Input
ListDependenciesI :: HashQualified Name -> Input
ListDependentsI :: HashQualified Name -> Input

-- | List all external dependencies of a given namespace, or the current
--   namespace if no path is provided.
NamespaceDependenciesI :: Maybe Path' -> Input
DebugTabCompletionI :: [String] -> Input
DebugLSPNameCompletionI :: Text -> Input
DebugFuzzyOptionsI :: String -> [String] -> Input
DebugFormatI :: Input
DebugNumberedArgsI :: Input
DebugTypecheckedUnisonFileI :: Input
DebugDumpNamespacesI :: Input
DebugDumpNamespaceSimpleI :: Input
DebugTermI :: Bool -> HashQualified Name -> Input
DebugTypeI :: HashQualified Name -> Input
DebugLSPFoldRangesI :: Input
DebugClearWatchI :: Input
DebugDoctorI :: Input
DebugNameDiffI :: ShortCausalHash -> ShortCausalHash -> Input
QuitI :: Input
ApiI :: Input
UiI :: Path' -> Input
DocToMarkdownI :: Name -> Input
DocsToHtmlI :: BranchRelativePath -> FilePath -> Input
AuthLoginI :: Input
VersionI :: Input
ProjectCreateI :: Bool -> Maybe ProjectName -> Input
ProjectRenameI :: ProjectName -> Input
ProjectSwitchI :: ProjectAndBranchNames -> Input
ProjectsI :: Input
BranchI :: BranchSourceI -> ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Input
BranchRenameI :: ProjectBranchName -> Input
BranchesI :: Maybe ProjectName -> Input
CloneI :: ProjectAndBranchNames -> Maybe ProjectAndBranchNames -> Input
ReleaseDraftI :: Semver -> Input
UpgradeI :: !NameSegment -> !NameSegment -> Input
EditNamespaceI :: [Path] -> Input
MergeI :: ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Input
LibInstallI :: !Bool -> !ProjectAndBranch ProjectName (Maybe ProjectBranchNameOrLatestRelease) -> Input
UpgradeCommitI :: Input
MergeCommitI :: Input
DebugSynhashTermI :: !Name -> Input

-- | The source of a <tt>branch</tt> command: what to make the new branch
--   from.
data BranchSourceI

-- | Create a branch from the current context
BranchSourceI'CurrentContext :: BranchSourceI

-- | Create an empty branch
BranchSourceI'Empty :: BranchSourceI

-- | Create a branch from this other branch
BranchSourceI'UnresolvedProjectBranch :: UnresolvedProjectBranch -> BranchSourceI

-- | Pull source and target: either neither is specified, or only a source,
--   or both.
data PullSourceTarget
PullSourceTarget0 :: PullSourceTarget
PullSourceTarget1 :: ReadRemoteNamespace (These ProjectName ProjectBranchNameOrLatestRelease) -> PullSourceTarget
PullSourceTarget2 :: ReadRemoteNamespace (These ProjectName ProjectBranchNameOrLatestRelease) -> ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> PullSourceTarget
data PushRemoteBranchInput
PushRemoteBranchInput :: PushSourceTarget -> PushBehavior -> PushRemoteBranchInput
[$sel:sourceTarget:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushSourceTarget
[$sel:pushBehavior:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushBehavior

-- | Push source and target: either neither is specified, or only a target,
--   or both.
data PushSourceTarget
PushSourceTarget0 :: PushSourceTarget
PushSourceTarget1 :: These ProjectName ProjectBranchName -> PushSourceTarget
PushSourceTarget2 :: PushSource -> These ProjectName ProjectBranchName -> PushSourceTarget
data PushSource
ProjySource :: These ProjectName ProjectBranchName -> PushSource
data TestInput
TestInput :: Bool -> Path -> Bool -> Bool -> TestInput

-- | Should we run tests in the <tt>lib</tt> namespace?
[$sel:includeLibNamespace:TestInput] :: TestInput -> Bool

-- | Relative path to run the tests in. Ignore if
--   <a>$sel:includeLibNamespace:TestInput</a> is True - that means test
--   everything.
[$sel:path:TestInput] :: TestInput -> Path
[$sel:showFailures:TestInput] :: TestInput -> Bool
[$sel:showSuccesses:TestInput] :: TestInput -> Bool
data Event
UnisonFileChanged :: SourceName -> Source -> Event
data OutputLocation
ConsoleLocation :: OutputLocation
LatestFileLocation :: RelativeToFold -> OutputLocation
FileLocation :: FilePath -> RelativeToFold -> OutputLocation

-- | Above a new fold, or within the topmost fold?
data RelativeToFold
AboveFold :: RelativeToFold
WithinFold :: RelativeToFold
type PatchPath = Split'
data BranchIdG p
BranchAtSCH :: ShortCausalHash -> BranchIdG p
BranchAtPath :: p -> BranchIdG p
BranchAtProjectPath :: ProjectPath -> BranchIdG p
type BranchId = BranchIdG Path'
type BranchId2 = Either ShortCausalHash BranchRelativePath
type AbsBranchId = BranchIdG Absolute

-- | An unambiguous project branch name, use the current project name if
--   not provided.
type UnresolvedProjectBranch = ProjectAndBranch (Maybe ProjectName) ProjectBranchName
parseBranchId :: String -> Either Text BranchId
parseBranchId2 :: String -> Either (Pretty ColorText) (Either ShortCausalHash BranchRelativePath)
parseShortCausalHash :: String -> Either String ShortCausalHash
type HashOrHQSplit' = Either ShortHash HQSplit'

-- | Should we force the operation or not?
data Insistence
Force :: Insistence
Try :: Insistence
data PullMode
PullWithHistory :: PullMode
PullWithoutHistory :: PullMode
data OptionalPatch
NoPatch :: OptionalPatch
DefaultPatch :: OptionalPatch
UsePatch :: PatchPath -> OptionalPatch
data FindScope
FindLocal :: Path' -> FindScope
FindLocalAndDeps :: Path' -> FindScope
FindGlobal :: FindScope
data ShowDefinitionScope
ShowDefinitionLocal :: ShowDefinitionScope
ShowDefinitionGlobal :: ShowDefinitionScope
type IsGlobal = Bool
data DeleteOutput
DeleteOutput'Diff :: DeleteOutput
DeleteOutput'NoDiff :: DeleteOutput
data DeleteTarget
DeleteTarget'TermOrType :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Term :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Type :: DeleteOutput -> [HQSplit'] -> DeleteTarget
DeleteTarget'Namespace :: Insistence -> Maybe Split -> DeleteTarget
DeleteTarget'ProjectBranch :: ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> DeleteTarget
DeleteTarget'Project :: ProjectName -> DeleteTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.Event
instance GHC.Show.Show Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Ord Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OptionalPatch
instance Data.Traversable.Traversable Unison.Codebase.Editor.Input.BranchIdG
instance Data.Foldable.Foldable Unison.Codebase.Editor.Input.BranchIdG
instance GHC.Base.Functor Unison.Codebase.Editor.Input.BranchIdG
instance GHC.Show.Show p => GHC.Show.Show (Unison.Codebase.Editor.Input.BranchIdG p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Unison.Codebase.Editor.Input.BranchIdG p)
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullMode
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullMode
instance GHC.Show.Show Unison.Codebase.Editor.Input.BranchSourceI
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.BranchSourceI
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullSourceTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullSourceTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushSource
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushSource
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushSourceTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushSourceTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.TestInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.TestInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.RelativeToFold
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.RelativeToFold
instance GHC.Show.Show Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Show.Show Unison.Codebase.Editor.Input.FindScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.FindScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.DeleteOutput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.DeleteOutput
instance GHC.Show.Show Unison.Codebase.Editor.Input.DeleteTarget
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.DeleteTarget
instance GHC.Show.Show Unison.Codebase.Editor.Input.Input
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Input
instance Witch.From.From p Data.Text.Internal.Text => Witch.From.From (Unison.Codebase.Editor.Input.BranchIdG p) Data.Text.Internal.Text

module Unison.Codebase.Editor.StructuredArgument

-- | The types that can be referenced by a numeric command argument.
data StructuredArgument
AbsolutePath :: Absolute -> StructuredArgument
Name :: Name -> StructuredArgument
HashQualified :: HashQualified Name -> StructuredArgument
Project :: ProjectName -> StructuredArgument
ProjectBranch :: ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> StructuredArgument
Namespace :: CausalHash -> StructuredArgument
NameWithBranchPrefix :: AbsBranchId -> Name -> StructuredArgument
HashQualifiedWithBranchPrefix :: AbsBranchId -> HashQualified Name -> StructuredArgument
ShallowListEntry :: Path' -> ShallowListEntry Symbol Ann -> StructuredArgument
SearchResult :: Maybe Path' -> SearchResult -> StructuredArgument
instance GHC.Show.Show Unison.Codebase.Editor.StructuredArgument.StructuredArgument
instance GHC.Generics.Generic Unison.Codebase.Editor.StructuredArgument.StructuredArgument
instance GHC.Classes.Eq Unison.Codebase.Editor.StructuredArgument.StructuredArgument

module Unison.CommandLine.FZFResolvers
data FZFResolver
FZFResolver :: OptionFetcher -> FZFResolver
[$sel:getOptions:FZFResolver] :: FZFResolver -> OptionFetcher

-- | Select a definition from the given branch.
definitionOptions :: OptionFetcher

-- | Select a term definition from the given branch. Returned names will
--   match the provided <tt>Position</tt> type.
termDefinitionOptions :: OptionFetcher

-- | Select a type definition from the given branch. Returned names will
--   match the provided <tt>Position</tt> type.
typeDefinitionOptions :: OptionFetcher

-- | Select a namespace from the given branch. Returned Path's will match
--   the provided <tt>Position</tt> type.
namespaceOptions :: OptionFetcher
projectDependencyResolver :: FZFResolver

-- | All possible local project names E.g. '@unison/base'
projectNameOptions :: OptionFetcher

-- | All possible local project/branch names. E.g. '@unison<i>base</i>main'
projectBranchOptions :: OptionFetcher

-- | All possible local branch names within the current project. E.g.
--   '@unison<i>base</i>main'
projectBranchOptionsWithinCurrentProject :: OptionFetcher

-- | Select a namespace from the given branch. Returned Path's will match
--   the provided <tt>Position</tt> type.
fuzzySelectFromList :: [Text] -> FZFResolver

-- | Combine multiple option fetchers into one resolver.
multiResolver :: [OptionFetcher] -> FZFResolver
definitionResolver :: FZFResolver
typeDefinitionResolver :: FZFResolver
termDefinitionResolver :: FZFResolver
namespaceResolver :: FZFResolver
namespaceOrDefinitionResolver :: FZFResolver

-- | A project name, branch name, or both.
projectAndOrBranchArg :: FZFResolver
projectOrBranchResolver :: FZFResolver
projectBranchResolver :: FZFResolver
projectBranchWithinCurrentProjectResolver :: FZFResolver
projectNameResolver :: FZFResolver

-- | Exported from here just so the debug command and actual implementation
--   can use the same messaging.
--   
--   <pre>
--   &gt;&gt;&gt; fuzzySelectHeader "definition to view"
--   "Select a definition to view:"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fuzzySelectHeader "alias name"
--   "Select an alias name:"
--   </pre>
fuzzySelectHeader :: Text -> Text
instance GHC.Show.Show Unison.CommandLine.FZFResolvers.FZFResolver


-- | Command-line fuzzy selection of arbitrary values. Shells out to fzf
--   for the actual selection.
module Unison.CommandLine.FuzzySelect

-- | Allows prompting the user to interactively fuzzy-select a result from
--   a list of options, currently shells out to <tt>fzf</tt> under the
--   hood. If fzf is missing, or an error (other than ctrl-c) occurred,
--   returns Nothing.
fuzzySelect :: forall a. Options -> (a -> Text) -> [a] -> IO (Maybe [a])

-- | Fuzzy Selection options
data Options
Options :: Bool -> Options
[$sel:allowMultiSelect:Options] :: Options -> Bool

-- | Default <a>Options</a>
defaultOptions :: Options

module Unison.CommandLine.Helpers
backtick :: IsString s => Pretty s -> Pretty s
aside :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
bigproblem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
note :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
nothingTodo :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
plural :: Foldable f => f a -> b -> b -> b
plural' :: Integral a => a -> b -> b -> b
problem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
tip :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warn :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warnNote :: String -> String

module Unison.CommandLine.Types
data ShouldWatchFiles
ShouldWatchFiles :: ShouldWatchFiles
ShouldNotWatchFiles :: ShouldWatchFiles
instance GHC.Classes.Eq Unison.CommandLine.Types.ShouldWatchFiles
instance GHC.Show.Show Unison.CommandLine.Types.ShouldWatchFiles

module Unison.CommandLine.Welcome
data CodebaseInitStatus
NewlyCreatedCodebase :: CodebaseInitStatus
PreviouslyCreatedCodebase :: CodebaseInitStatus
data Welcome
Welcome :: Onboarding -> Text -> Bool -> Welcome
[$sel:onboarding:Welcome] :: Welcome -> Onboarding
[$sel:unisonVersion:Welcome] :: Welcome -> Text
[$sel:showWelcomeHint:Welcome] :: Welcome -> Bool
asciiartUnison :: Pretty ColorText
run :: Welcome -> [Either Event Input]
welcome :: CodebaseInitStatus -> Text -> Bool -> Welcome
instance GHC.Classes.Eq Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Show.Show Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Classes.Eq Unison.CommandLine.Welcome.Onboarding
instance GHC.Show.Show Unison.CommandLine.Welcome.Onboarding


-- | Instances for LSP types which are strangely missing.
module Unison.LSP.Orphans
instance Language.LSP.Protocol.Types.Lens.HasTextDocument Language.LSP.Protocol.Internal.Types.TextDocumentIdentifier.TextDocumentIdentifier Language.LSP.Protocol.Internal.Types.TextDocumentIdentifier.TextDocumentIdentifier
instance Language.LSP.Protocol.Types.Lens.HasTextDocument Language.LSP.Protocol.Internal.Types.VersionedTextDocumentIdentifier.VersionedTextDocumentIdentifier Language.LSP.Protocol.Internal.Types.VersionedTextDocumentIdentifier.VersionedTextDocumentIdentifier
instance Language.LSP.Protocol.Types.Lens.HasUri Language.LSP.Protocol.Types.Uri.NormalizedUri Language.LSP.Protocol.Types.Uri.Uri

module Unison.LSP.Conversions
rangeToInterval :: Range -> Interval Position
annToInterval :: Ann -> Maybe (Interval Position)

-- | Convert a Unison file-position where the first char is 1 and line is
--   1, to an LSP <a>Position</a> where the first char is 0 and line is 0.
uToLspPos :: Pos -> Position

-- | Convert an LSP <a>Position</a> where the first char is 0 and line is
--   0, to a Unison file-position where the first char is 1 and line is 1.
lspToUPos :: Position -> Pos

-- | Convert a Unison <a>Range</a> where the first char is 1 and line is 1,
--   to an LSP <a>Range</a> where the first char is 0 and line is 0.
uToLspRange :: Range -> Range

-- | Convert an LSP <a>Range</a> where the first char is 0 and line is 0,
--   to a Unison <a>Range</a> where the first char is 1 and line is 1.
lspToURange :: Range -> Range
annToRange :: Ann -> Maybe Range
annToURange :: Ann -> Maybe Range

module Unison.LSP.Types

-- | A custom LSP monad wrapper so we can provide our own environment.
newtype Lsp a
Lsp :: ReaderT Env (LspM Config) a -> Lsp a
[$sel:runLspM:Lsp] :: Lsp a -> ReaderT Env (LspM Config) a

-- | Log an info message to the client's LSP log.
logInfo :: Text -> Lsp ()

-- | Log an error message to the client's LSP log, this will be shown to
--   the user in most LSP implementations.
logError :: Text -> Lsp ()

-- | Environment for the Lsp monad.
data Env
Env :: LanguageContextEnv Config -> Codebase IO Symbol Ann -> IO Names -> IO PrettyPrintEnvDecl -> IO (NameSearch Transaction) -> IO ProjectPath -> MVar VFS -> Runtime Symbol -> TVar (Map Uri (TMVar FileAnalysis)) -> TVar (Set Uri) -> TVar (Map (Int32 |? Text) (IO ())) -> TMVar CompletionTree -> Scope -> Env
[$sel:lspContext:Env] :: Env -> LanguageContextEnv Config
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:currentNamesCache:Env] :: Env -> IO Names
[$sel:ppedCache:Env] :: Env -> IO PrettyPrintEnvDecl
[$sel:nameSearchCache:Env] :: Env -> IO (NameSearch Transaction)
[$sel:currentProjectPathCache:Env] :: Env -> IO ProjectPath
[$sel:vfsVar:Env] :: Env -> MVar VFS
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:checkedFilesVar:Env] :: Env -> TVar (Map Uri (TMVar FileAnalysis))
[$sel:dirtyFilesVar:Env] :: Env -> TVar (Set Uri)
[$sel:cancellationMapVar:Env] :: Env -> TVar (Map (Int32 |? Text) (IO ()))
[$sel:completionsVar:Env] :: Env -> TMVar CompletionTree
[$sel:scope:Env] :: Env -> Scope

-- | A suffix tree over path segments of name completions. see
--   <tt>namesToCompletionTree</tt> for more on how this is built and the
--   invariants it should have.
newtype CompletionTree
CompletionTree :: Cofree (Map NameSegment) (Set (Name, LabeledDependency)) -> CompletionTree
[$sel:unCompletionTree:CompletionTree] :: CompletionTree -> Cofree (Map NameSegment) (Set (Name, LabeledDependency))

-- | A monotonically increasing file version tracked by the lsp client.
type FileVersion = Int32
type LexedSource = (Text, [Token Lexeme])
data TypeSignatureHint
TypeSignatureHint :: Name -> Referent -> Range -> Type Symbol Ann -> TypeSignatureHint
[$sel:name:TypeSignatureHint] :: TypeSignatureHint -> Name
[$sel:referent:TypeSignatureHint] :: TypeSignatureHint -> Referent
[$sel:bindingLocation:TypeSignatureHint] :: TypeSignatureHint -> Range
[$sel:signature:TypeSignatureHint] :: TypeSignatureHint -> Type Symbol Ann
data FileAnalysis
FileAnalysis :: Uri -> FileVersion -> LexedSource -> IntervalMap Position Lexeme -> Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Seq (Note Symbol Ann) -> IntervalMap Position [Diagnostic] -> IntervalMap Position [CodeAction] -> Map Symbol TypeSignatureHint -> Maybe FileSummary -> FileAnalysis
[$sel:fileUri:FileAnalysis] :: FileAnalysis -> Uri
[$sel:fileVersion:FileAnalysis] :: FileAnalysis -> FileVersion
[$sel:lexedSource:FileAnalysis] :: FileAnalysis -> LexedSource
[$sel:tokenMap:FileAnalysis] :: FileAnalysis -> IntervalMap Position Lexeme
[$sel:parsedFile:FileAnalysis] :: FileAnalysis -> Maybe (UnisonFile Symbol Ann)
[$sel:typecheckedFile:FileAnalysis] :: FileAnalysis -> Maybe (TypecheckedUnisonFile Symbol Ann)
[$sel:notes:FileAnalysis] :: FileAnalysis -> Seq (Note Symbol Ann)
[$sel:diagnostics:FileAnalysis] :: FileAnalysis -> IntervalMap Position [Diagnostic]
[$sel:codeActions:FileAnalysis] :: FileAnalysis -> IntervalMap Position [CodeAction]
[$sel:typeSignatureHints:FileAnalysis] :: FileAnalysis -> Map Symbol TypeSignatureHint
[$sel:fileSummary:FileAnalysis] :: FileAnalysis -> Maybe FileSummary
getCurrentProjectPath :: Lsp ProjectPath
getCodebaseCompletions :: Lsp CompletionTree
currentPPED :: Lsp PrettyPrintEnvDecl
getNameSearch :: Lsp (NameSearch Transaction)
getCurrentNames :: Lsp Names
data Config
Config :: Int -> Maybe Int -> Config
[$sel:formattingWidth:Config] :: Config -> Int
[$sel:maxCompletions:Config] :: Config -> Maybe Int
defaultLSPConfig :: Config

-- | Lift a backend computation into the Lsp monad.
lspBackend :: Backend IO a -> Lsp (Either BackendError a)
sendNotification :: forall (m :: Method 'ServerToClient 'Notification). TMessage m ~ TNotificationMessage m => TNotificationMessage m -> Lsp ()
data RangedCodeAction
RangedCodeAction :: [Range] -> CodeAction -> RangedCodeAction
[$sel:_codeActionRanges:RangedCodeAction] :: RangedCodeAction -> [Range]
[$sel:_codeAction:RangedCodeAction] :: RangedCodeAction -> CodeAction
rangedCodeAction :: Text -> [Diagnostic] -> [Range] -> RangedCodeAction

-- | Provided ranges must not intersect.
includeEdits :: Uri -> Text -> [Range] -> RangedCodeAction -> RangedCodeAction
getConfig :: Lsp Config
setConfig :: Config -> Lsp ()
instance GHC.Show.Show Unison.LSP.Types.CompletionTree
instance GHC.Show.Show Unison.LSP.Types.TypeSignatureHint
instance GHC.Show.Show Unison.LSP.Types.FileAnalysis
instance GHC.Show.Show Unison.LSP.Types.Config
instance Language.LSP.Server.Core.MonadLsp Unison.LSP.Types.Config Unison.LSP.Types.Lsp
instance Control.Monad.Reader.Class.MonadReader Unison.LSP.Types.Env Unison.LSP.Types.Lsp
instance Control.Monad.IO.Unlift.MonadUnliftIO Unison.LSP.Types.Lsp
instance Control.Monad.IO.Class.MonadIO Unison.LSP.Types.Lsp
instance GHC.Base.Monad Unison.LSP.Types.Lsp
instance GHC.Base.Applicative Unison.LSP.Types.Lsp
instance GHC.Base.Functor Unison.LSP.Types.Lsp
instance GHC.Show.Show Unison.LSP.Types.RangedCodeAction
instance GHC.Classes.Eq Unison.LSP.Types.RangedCodeAction
instance Language.LSP.Protocol.Types.Lens.HasCodeAction Unison.LSP.Types.RangedCodeAction Language.LSP.Protocol.Internal.Types.CodeAction.CodeAction
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.Types.Config
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.Types.Config
instance GHC.Base.Semigroup Unison.LSP.Types.CompletionTree
instance GHC.Base.Monoid Unison.LSP.Types.CompletionTree

module Unison.LSP.NotificationHandlers
initializedHandler :: TNotificationMessage 'Method_Initialized -> Lsp ()
withDebugging :: Show m => (m -> Lsp ()) -> m -> Lsp ()
setTraceHandler :: TNotificationMessage 'Method_SetTrace -> Lsp ()

module Unison.LSP.HandlerUtils

-- | Cancels an in-flight request
cancelRequest :: (Int32 |? Text) -> Lsp ()
withDebugging :: (Show (TRequestMessage message), Show (MessageResult message)) => (TRequestMessage message -> (Either ResponseError (MessageResult message) -> Lsp ()) -> Lsp ()) -> TRequestMessage message -> (Either ResponseError (MessageResult message) -> Lsp ()) -> Lsp ()

-- | Handler middleware to add the ability for the client to cancel
--   long-running in-flight requests.
withCancellation :: forall message. Maybe Int -> (TRequestMessage message -> (Either ResponseError (MessageResult message) -> Lsp ()) -> Lsp ()) -> TRequestMessage message -> (Either ResponseError (MessageResult message) -> Lsp ()) -> Lsp ()

module Unison.LSP.Diagnostics
reportDiagnostics :: Foldable f => Uri -> Maybe FileVersion -> f Diagnostic -> Lsp ()
mkDiagnostic :: Uri -> Range -> DiagnosticSeverity -> [DiagnosticTag] -> Text -> [(Text, Range)] -> Diagnostic
data () => DiagnosticSeverity
DiagnosticSeverity_Error :: DiagnosticSeverity
DiagnosticSeverity_Warning :: DiagnosticSeverity
DiagnosticSeverity_Information :: DiagnosticSeverity
DiagnosticSeverity_Hint :: DiagnosticSeverity

module Unison.LSP.FileAnalysis.UnusedBindings
data VarUsages
VarUsages :: Map Symbol (Set Ann) -> Set Symbol -> Set Symbol -> VarUsages
[$sel:unusedVars:VarUsages] :: VarUsages -> Map Symbol (Set Ann)
[$sel:usedVars:VarUsages] :: VarUsages -> Set Symbol
[$sel:allUsedVars:VarUsages] :: VarUsages -> Set Symbol
analyseTerm :: Uri -> Term Symbol Ann -> [Diagnostic]
instance GHC.Base.Semigroup Unison.LSP.FileAnalysis.UnusedBindings.VarUsages
instance GHC.Base.Monoid Unison.LSP.FileAnalysis.UnusedBindings.VarUsages

module Unison.LSP.Configuration

-- | Handle configuration changes.
updateConfig :: Applicative m => Config -> m ()
parseConfig :: Config -> Value -> Either Text Config

-- | We could use this notification to cancel/update work-in-progress, but
--   we don't actually need to update the config here, that's handled by
--   the lsp library automatically.
workspaceConfigurationChanged :: TNotificationMessage 'Method_WorkspaceDidChangeConfiguration -> Lsp ()

module Unison.LSP.Commands
supportedCommands :: [Text]
replaceText :: Text -> TextReplacement -> Command
data TextReplacement
TextReplacement :: Range -> Text -> Text -> Uri -> TextReplacement
[$sel:range:TextReplacement] :: TextReplacement -> Range
[$sel:description:TextReplacement] :: TextReplacement -> Text
[$sel:replacementText:TextReplacement] :: TextReplacement -> Text
[$sel:fileUri:TextReplacement] :: TextReplacement -> Uri

-- | Computes code actions for a document.
executeCommandHandler :: TRequestMessage 'Method_WorkspaceExecuteCommand -> (Either ResponseError (Value |? Null) -> Lsp ()) -> Lsp ()
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.Commands.TextReplacement
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.Commands.TextReplacement

module Unison.LSP.CancelRequest

-- | Allows a client to cancel work from a previous request.
cancelRequestHandler :: TNotificationMessage 'Method_CancelRequest -> Lsp ()


-- | A transactional signal type. Similar to a broadcast channel, but with
--   better memory characteristics when you only care about the latest
--   value.
--   
--   Allows multiple consumers to detect the latest value of a signal, and
--   to be notified when the signal changes.
module Unison.LSP.Util.Signal

-- | Create a new signal with an optional initial value.
newSignalIO :: MonadIO m => Maybe a -> m (Signal a)

-- | Update the value of a signal, notifying all subscribers (even if the
--   value didn't change)
writeSignal :: Signal a -> a -> STM ()

-- | Update the value of a signal, notifying all subscribers (even if the
--   value didn't change)
writeSignalIO :: MonadIO m => Signal a -> a -> m ()

-- | Subscribe to a signal, returning an STM action which will read the
--   latest NEW value, after successfully reading a new value, subsequent
--   reads will retry until there's a new value written to the signal.
--   
--   Each independent reader should have its own subscription.
--   
--   <pre>
--   &gt;&gt;&gt; signal &lt;- newSignalIO (Just "initial")
--   
--   &gt;&gt;&gt; subscriber1 &lt;- subscribe signal
--   
--   &gt;&gt;&gt; subscriber2 &lt;- subscribe signal
--   
--   &gt;&gt;&gt; -- Should return the initial value
--   
--   &gt;&gt;&gt; atomically (optional subscriber1)
--   
--   &gt;&gt;&gt; -- Should retry, since the signal hasn't changed.
--   
--   &gt;&gt;&gt; atomically (optional subscriber1)
--   
--   &gt;&gt;&gt; writeSignalIO signal "new value"
--   
--   &gt;&gt;&gt; -- Each subscriber should return the newest value
--   
--   &gt;&gt;&gt; ("sub1",) &lt;$&gt; atomically (optional subscriber1)
--   
--   &gt;&gt;&gt; ("sub2",) &lt;$&gt; atomically (optional subscriber2)
--   
--   &gt;&gt;&gt; -- Both should now retry
--   
--   &gt;&gt;&gt; ("sub1",) &lt;$&gt; atomically (optional subscriber1)
--   
--   &gt;&gt;&gt; ("sub2",) &lt;$&gt; atomically (optional subscriber2)
--   Just "initial"
--   Nothing
--   ("sub1",Just "new value")
--   ("sub2",Just "new value")
--   ("sub1",Nothing)
--   ("sub2",Nothing)
--   </pre>
subscribe :: MonadIO m => Signal a -> m (STM a)
data Signal a

module Unison.LSP.VFS

-- | Some VFS combinators require Monad State, this provides it in a
--   transactionally safe manner so we're sure we don't edit the same file
--   in two different actions at the same time.
usingVFS :: forall a. StateT VFS Lsp a -> Lsp a
getVirtualFile :: Uri -> MaybeT Lsp VirtualFile
getFileContents :: Uri -> MaybeT Lsp (FileVersion, Text)
vfsLogger :: LogAction (StateT VFS Lsp) (WithSeverity VfsLog)

-- | Mark some files as needing to be checked.
markFilesDirty :: (Foldable f, HasUri doc Uri) => f doc -> Lsp ()

-- | Mark all files for re-checking.
--   
--   We may want to do this when our names or perspective change.
markAllFilesDirty :: Lsp ()

-- | Returns the name or symbol which the provided position is contained
--   in.
identifierAtPosition :: Uri -> Position -> MaybeT Lsp Text

-- | Returns the prefix and suffix of the symbol which the provided
--   position is contained in.
identifierSplitAtPosition :: Uri -> Position -> MaybeT Lsp (Text, Text)

-- | Returns the prefix of the symbol at the provided location, and the
--   range that prefix spans.
completionPrefix :: Uri -> Position -> MaybeT Lsp (Range, Text)
lspOpenFile :: TNotificationMessage 'Method_TextDocumentDidOpen -> Lsp ()
lspCloseFile :: TNotificationMessage 'Method_TextDocumentDidClose -> Lsp ()
lspChangeFile :: TNotificationMessage 'Method_TextDocumentDidChange -> Lsp ()

module Unison.LSP.FileAnalysis

-- | Lex, parse, and typecheck a file.
checkFile :: HasUri d Uri => d -> Lsp (Maybe FileAnalysis)

-- | Get the location of user defined definitions within the file
getFileDefLocations :: Uri -> MaybeT Lsp (Map Symbol (Set Ann))
fileAnalysisWorker :: Lsp ()
analyseFile :: Foldable f => Uri -> Text -> PrettyPrintEnvDecl -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])

-- | Returns diagnostics which show a warning diagnostic when editing a
--   term that's conflicted in the codebase.
computeConflictWarningDiagnostics :: Uri -> FileSummary -> Lsp [Diagnostic]
getTokenMap :: [Token Lexeme] -> IntervalMap Position Lexeme
analyseNotes :: Foldable f => Uri -> PrettyPrintEnv -> String -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])
toRangeMap :: Foldable f => f (Range, a) -> IntervalMap Position [a]
getFileAnalysis :: Uri -> MaybeT Lsp FileAnalysis

-- | Build a Names from a file if it's parseable.
--   
--   If the file typechecks, generate names from that, otherwise, generate
--   names from the <tt>parsed</tt> file. Note that the names for a parsed
--   file contains only names for parts of decls, since we don't know
--   references within terms before typechecking due to TDNR. This should
--   be fine though, since those references will all be kept in the ABT as
--   symbols anyways.
--   
--   See UF.toNames and UF.typecheckedToNames for more info.
getFileNames :: Uri -> MaybeT Lsp Names
getFileSummary :: Uri -> MaybeT Lsp FileSummary
ppedForFile :: Uri -> Lsp PrettyPrintEnvDecl
ppedForFileHelper :: Maybe (UnisonFile Symbol a) -> Maybe (TypecheckedUnisonFile Symbol a) -> Lsp PrettyPrintEnvDecl
mkTypeSignatureHints :: UnisonFile Symbol Ann -> TypecheckedUnisonFile Symbol Ann -> Map Symbol TypeSignatureHint


-- | Rewrites of some codebase queries, but which check the scratch file
--   for info first.
module Unison.LSP.Queries

-- | Renders all docs for a given FQN to markdown.
markdownDocsForFQN :: Uri -> HashQualified Name -> Lsp [Text]

-- | Gets the type of a reference from either the parsed file or the
--   codebase.
getTypeOfReferent :: Uri -> Referent -> MaybeT Lsp (Type Symbol Ann)

-- | Gets a decl from either the parsed file or the codebase.
getTypeDeclaration :: Uri -> Id -> MaybeT Lsp (Decl Symbol Ann)

-- | Returns a reference to whatever the symbol at the given position
--   refers to.
refAtPosition :: Uri -> Position -> MaybeT Lsp LabeledDependency

-- | Returns the ABT node at the provided position. Does not return Decl
--   nodes.
nodeAtPosition :: Uri -> Position -> MaybeT Lsp (SourceNode Ann)

-- | Returns the reference a given term node refers to, if any.
refInTerm :: Term v a -> Maybe LabeledDependency
refInType :: Type v a -> Maybe TypeReference

-- | Find the node in a term which contains the specified position, but
--   none of its children contain that position.
findSmallestEnclosingNode :: Pos -> Term Symbol Ann -> Maybe (SourceNode Ann)

-- | Find the node in a type which contains the specified position, but
--   none of its children contain that position. This is helpful for
--   finding the specific type reference of a given argument within a type
--   arrow that a position references.
findSmallestEnclosingType :: Pos -> Type Symbol Ann -> Maybe (Type Symbol Ann)

-- | Returns the type reference the given position applies to within a
--   Decl, if any.
--   
--   I.e. if the cursor is over a type reference within a constructor
--   signature or ability request signature, that type reference will be
--   returned.
refInDecl :: Pos -> Decl Symbol Ann -> Maybe TypeReference
data SourceNode a
TermNode :: Term Symbol a -> SourceNode a
TypeNode :: Type Symbol a -> SourceNode a
PatternNode :: Pattern a -> SourceNode a
instance GHC.Show.Show (Unison.LSP.Queries.SourceNode a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.LSP.Queries.SourceNode a)
instance GHC.Base.Functor Unison.LSP.Queries.SourceNode

module Unison.LSP.Hover

-- | Hover help handler
--   
--   TODO: * Add docs * Resolve fqn on hover
hoverHandler :: TRequestMessage 'Method_TextDocumentHover -> (Either ResponseError (MessageResult 'Method_TextDocumentHover) -> Lsp ()) -> Lsp ()
hoverInfo :: Uri -> Position -> MaybeT Lsp Text

-- | Get the type for term literals.
builtinTypeForTermLiterals :: Term Symbol Ann -> Maybe Text
builtinTypeForPatternLiterals :: Pattern Ann -> Maybe Text

module Unison.LSP.Formatting
formatDocRequest :: TRequestMessage 'Method_TextDocumentFormatting -> (Either ResponseError (MessageResult 'Method_TextDocumentFormatting) -> Lsp ()) -> Lsp ()
formatRangeRequest :: TRequestMessage 'Method_TextDocumentRangeFormatting -> (Either ResponseError (MessageResult 'Method_TextDocumentRangeFormatting) -> Lsp ()) -> Lsp ()

-- | Format all definitions in a file.
formatDefs :: Uri -> Maybe (Set Range) -> Lsp [TextEdit]

module Unison.LSP.FoldingRange
foldingRangeRequest :: TRequestMessage 'Method_TextDocumentFoldingRange -> (Either ResponseError (MessageResult 'Method_TextDocumentFoldingRange) -> Lsp ()) -> Lsp ()

-- | Return a folding range for each top-level definition
foldingRangesForFile :: UnisonFile Symbol Ann -> [FoldingRange]

module Unison.LSP.CodeLens
data TypeSigInsertion
TypeSigInsertion :: Range -> Text -> Uri -> TypeSigInsertion
[$sel:range:TypeSigInsertion] :: TypeSigInsertion -> Range
[$sel:typeSignature:TypeSigInsertion] :: TypeSigInsertion -> Text
[$sel:fileUri:TypeSigInsertion] :: TypeSigInsertion -> Uri

-- | Computes code actions for a document.
codeLensHandler :: TRequestMessage 'Method_TextDocumentCodeLens -> (Either ResponseError ([CodeLens] |? Null) -> Lsp ()) -> Lsp ()
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.CodeLens.TypeSigInsertion
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.CodeLens.TypeSigInsertion

module Unison.LSP.CodeAction

-- | Computes code actions for a document.
codeActionHandler :: TRequestMessage 'Method_TextDocumentCodeAction -> (Either ResponseError (MessageResult 'Method_TextDocumentCodeAction) -> Lsp ()) -> Lsp ()

module Unison.LSP.Completion
completionHandler :: TRequestMessage 'Method_TextDocumentCompletion -> (Either ResponseError (MessageResult 'Method_TextDocumentCompletion) -> Lsp ()) -> Lsp ()

-- | Called to resolve additional details for a completion item that the
--   user is considering.
completionItemResolveHandler :: TRequestMessage 'Method_CompletionItemResolve -> (Either ResponseError CompletionItem -> Lsp ()) -> Lsp ()

-- | Generate a completion tree from a set of names. A completion tree is a
--   suffix tree over the path segments of each name it contains. The goal
--   is to allow fast completion of names by any partial path suffix.
--   
--   The tree is generated by building a trie where all possible suffixes
--   of a name are reachable from the root of the trie, with sharing over
--   subtrees to improve memory residency.
--   
--   Currently we don't "summarize" all of the children of a node in the
--   node itself, and instead you have to crawl all the children to get the
--   actual completions.
--   
--   TODO: Would it be worthwhile to perform compression or include child
--   summaries on the suffix tree? I suspect most namespace trees won't
--   actually compress very well since each node is likely to have
--   terms/types at it.
--   
--   E.g. From the names: * alpha.beta.Nat * alpha.Text * foxtrot.Text
--   
--   It will generate a tree like the following, where each bullet is a
--   possible completion:
--   
--   . ├── foxtrot │ └── Text │ └── * foxtrot.Text (##Text) ├── beta │ └──
--   Nat │ └── * alpha.beta.Nat (##Nat) ├── alpha │ ├── beta │ │ └── Nat │
--   │ └── * alpha.beta.Nat (##Nat) │ └── Text │ └── * alpha.Text (##Text)
--   ├── Text │ ├── * foxtrot.Text (##Text) │ └── * alpha.Text (##Text) └──
--   Nat └── * alpha.beta.Nat (##Nat)
namesToCompletionTree :: Names -> CompletionTree
completionsForQuery :: CompletionTree -> Text -> (Bool, [(Text, Name, LabeledDependency)])
instance Data.Aeson.Types.ToJSON.ToJSON Unison.LSP.Completion.CompletionItemDetails
instance Data.Aeson.Types.FromJSON.FromJSON Unison.LSP.Completion.CompletionItemDetails

module Unison.LSP.UCMWorker

-- | Watches for state changes in UCM and updates cached LSP state
--   accordingly
ucmWorker :: TMVar PrettyPrintEnvDecl -> TMVar Names -> TMVar (NameSearch Transaction) -> TMVar ProjectPath -> Signal ProjectPathIds -> Lsp ()

module Unison.LSP

-- | Spawn an LSP server on the configured port.
spawnLsp :: LspFormattingConfig -> Codebase IO Symbol Ann -> Runtime Symbol -> Signal ProjectPathIds -> IO ()
data LspFormattingConfig
LspFormatEnabled :: LspFormattingConfig
LspFormatDisabled :: LspFormattingConfig
instance GHC.Classes.Eq Unison.LSP.LspFormattingConfig
instance GHC.Show.Show Unison.LSP.LspFormattingConfig


-- | This module handles parsing CLI arguments into <a>Command</a>s. See
--   the excellent documentation at
--   <a>https://hackage.haskell.org/package/optparse-applicative</a>
module ArgParse

-- | Valid ways to provide source code to the run command
data RunSource
RunFromPipe :: HashQualified Name -> RunSource
RunFromSymbol :: ProjectPathNames -> RunSource
RunFromFile :: FilePath -> HashQualified Name -> RunSource
RunCompiled :: FilePath -> RunSource
data ShouldForkCodebase
UseFork :: ShouldForkCodebase
DontFork :: ShouldForkCodebase
data ShouldSaveCodebase
SaveCodebase :: Maybe FilePath -> ShouldSaveCodebase
DontSaveCodebase :: ShouldSaveCodebase
data CodebasePathOption
CreateCodebaseWhenMissing :: FilePath -> CodebasePathOption
DontCreateCodebaseWhenMissing :: FilePath -> CodebasePathOption
data ShouldExit
Exit :: ShouldExit
DoNotExit :: ShouldExit
data IsHeadless
Headless :: IsHeadless
WithCLI :: IsHeadless

-- | Represents commands the cli can run.
--   
--   Note that this is not one-to-one with command-parsers since some are
--   simple variants. E.g. run, run.file, run.pipe
data Command
Launch :: IsHeadless -> CodebaseServerOpts -> Maybe (ProjectAndBranch ProjectName ProjectBranchName) -> ShouldWatchFiles -> Command
PrintVersion :: Command
Init :: Command
Run :: RunSource -> [String] -> Command
Transcript :: ShouldForkCodebase -> ShouldSaveCodebase -> Maybe RtsStatsPath -> NonEmpty FilePath -> Command

-- | Options shared by sufficiently many subcommands.
data GlobalOptions
GlobalOptions :: Maybe CodebasePathOption -> ShouldExit -> Maybe FilePath -> LspFormattingConfig -> GlobalOptions
[$sel:codebasePathOption:GlobalOptions] :: GlobalOptions -> Maybe CodebasePathOption
[$sel:exitOption:GlobalOptions] :: GlobalOptions -> ShouldExit
[$sel:nativeRuntimePath:GlobalOptions] :: GlobalOptions -> Maybe FilePath
[$sel:lspFormattingConfig:GlobalOptions] :: GlobalOptions -> LspFormattingConfig

-- | The root-level <a>ParserInfo</a>.
rootParserInfo :: String -> String -> CodebaseServerOpts -> ParserInfo (GlobalOptions, Command)
type UsageRenderer = -- | Optional sub-command to render help for Maybe String -> String

-- | Parse the command description, options, and usage information from
--   provided cli arguments.
parseCLIArgs :: String -> String -> IO (UsageRenderer, GlobalOptions, Command)

-- | Load default options from environment variables.
codebaseServerOptsFromEnv :: IO CodebaseServerOpts

-- | Purely renders the full help summary for the CLI, or an optional
--   subcommand.
renderUsage :: String -> ParserInfo a -> ParserPrefs -> Maybe String -> String
versionCommand :: Mod CommandFields Command
initCommand :: Mod CommandFields Command
runDesc :: String -> String -> String
runSymbolCommand :: Mod CommandFields Command
runFileCommand :: Mod CommandFields Command
runPipeCommand :: Mod CommandFields Command
runCompiledCommand :: Mod CommandFields Command
transcriptCommand :: Mod CommandFields Command
transcriptForkCommand :: Mod CommandFields Command
commandParser :: CodebaseServerOpts -> Parser Command
globalOptionsParser :: Parser GlobalOptions
codebasePathParser :: Parser (Maybe CodebasePathOption)
codebaseCreateParser :: Parser (Maybe CodebasePathOption)
exitParser :: Parser ShouldExit
lspFormattingParser :: Parser LspFormattingConfig
versionOptionParser :: String -> String -> Parser (a -> a)
launchHeadlessCommand :: CodebaseServerOpts -> Mod CommandFields Command
codebaseServerOptsParser :: CodebaseServerOpts -> Parser CodebaseServerOpts
launchParser :: CodebaseServerOpts -> IsHeadless -> Parser Command
initParser :: Parser Command
versionParser :: Parser Command
runArgumentParser :: Parser [String]
runHQParser :: Parser (HashQualified Name)
runProjectPathParser :: Parser ProjectPathNames
runSymbolParser :: Parser Command
runFileParser :: Parser Command
runPipeParser :: Parser Command
runCompiledParser :: Parser Command
rtsStatsOption :: Parser (Maybe RtsStatsPath)
saveCodebaseFlag :: Parser ShouldSaveCodebase
saveCodebaseToFlag :: Parser ShouldSaveCodebase
startingProjectOption :: Parser (Maybe (ProjectAndBranch ProjectName ProjectBranchName))
noFileWatchFlag :: Parser ShouldWatchFiles
readAbsolutePath :: ReadM Absolute
nativeRuntimePathFlag :: Parser (Maybe FilePath)
readPath' :: ReadM Path'
readProjectAndBranchNames :: ReadM (ProjectAndBranch ProjectName ProjectBranchName)
fileArgument :: String -> Parser FilePath
transcriptParser :: Parser Command
transcriptForkParser :: Parser Command
unisonHelp :: String -> String -> Doc
instance GHC.Classes.Eq ArgParse.RunSource
instance GHC.Show.Show ArgParse.RunSource
instance GHC.Classes.Eq ArgParse.ShouldForkCodebase
instance GHC.Show.Show ArgParse.ShouldForkCodebase
instance GHC.Classes.Eq ArgParse.ShouldSaveCodebase
instance GHC.Show.Show ArgParse.ShouldSaveCodebase
instance GHC.Classes.Eq ArgParse.CodebasePathOption
instance GHC.Show.Show ArgParse.CodebasePathOption
instance GHC.Classes.Eq ArgParse.ShouldExit
instance GHC.Show.Show ArgParse.ShouldExit
instance GHC.Classes.Eq ArgParse.IsHeadless
instance GHC.Show.Show ArgParse.IsHeadless
instance GHC.Classes.Eq ArgParse.Command
instance GHC.Show.Show ArgParse.Command
instance GHC.Classes.Eq ArgParse.GlobalOptions
instance GHC.Show.Show ArgParse.GlobalOptions

module Unison.Share.Codeserver

-- | This is the URI where the share API is based.
defaultCodeserver :: CodeserverURI
resolveCodeserver :: ShareCodeserver -> CodeserverURI


-- | Unfortunately, due to bugs in previous versions of UCM there are some
--   entities whose hashes are not what they should be, but have propagated
--   widely into end-user's codebases. This is a map from the nominal hash
--   to the actual hash of the component of components which are known to
--   have widely available incorrect hashes.
--   
--   Keeping this table allows us to allow UCM to validate the hashes of
--   new terms which are received from remote sources, but allows a bit of
--   lee-way for these known exceptions.
--   
--   While we certainly don't want to make this a common occurence, it's
--   safe as long as we are specific about both the provided and actual
--   hashes.
module Unison.Share.ExpectedHashMismatches
expectedComponentHashMismatches :: Map Hash32 Hash32
expectedCausalHashMismatches :: Map Hash32 Hash32


-- | Types used by the UCM client during sync.
module Unison.Share.Sync.Types

-- | Generic Codeserver transport errors
data CodeserverTransportError
DecodeFailure :: Text -> Response -> CodeserverTransportError
PermissionDenied :: Text -> CodeserverTransportError
RateLimitExceeded :: CodeserverTransportError
Timeout :: CodeserverTransportError
Unauthenticated :: BaseUrl -> CodeserverTransportError
UnexpectedResponse :: Response -> CodeserverTransportError
UnreachableCodeserver :: BaseUrl -> CodeserverTransportError

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | The repo info was invalid. (err, repoInfo)
GetCausalHashByPathErrorInvalidRepoInfo :: Text -> RepoInfo -> GetCausalHashByPathError

-- | The user was not found.
GetCausalHashByPathErrorUserNotFound :: RepoInfo -> GetCausalHashByPathError

-- | An error occurred while pulling code from Unison Share.
data PullError
PullError'DownloadEntities :: DownloadEntitiesError -> PullError
PullError'GetCausalHash :: GetCausalHashByPathError -> PullError
PullError'NoHistoryAtPath :: Path -> PullError
data SyncError e
TransportError :: CodeserverTransportError -> SyncError e
SyncError :: e -> SyncError e
instance GHC.Show.Show Unison.Share.Sync.Types.GetCausalHashByPathError
instance GHC.Show.Show Unison.Share.Sync.Types.PullError
instance GHC.Exception.Type.Exception Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show e => GHC.Show.Show (Unison.Share.Sync.Types.SyncError e)
instance GHC.Base.Functor Unison.Share.Sync.Types.SyncError

module Unison.Util.HTTP
addRequestMiddleware :: (Request -> IO Request) -> ManagerSettings -> ManagerSettings
setUserAgent :: Text -> ManagerSettings -> ManagerSettings
ucmUserAgent :: UCMVersion -> Text

module Unison.Auth.HTTPClient

-- | Returns a new http manager which applies the appropriate Authorization
--   header to any hosts our UCM is authenticated with.
newAuthenticatedHTTPClient :: MonadIO m => TokenProvider -> UCMVersion -> m AuthenticatedHttpClient

-- | Newtype to delineate HTTP Managers with access-token logic.
newtype AuthenticatedHttpClient
AuthenticatedHttpClient :: Manager -> AuthenticatedHttpClient

module Unison.CommandLine.InputPattern
data InputPattern
InputPattern :: String -> [String] -> Visibility -> [(ArgumentDescription, IsOptional, ArgumentType)] -> Pretty ColorText -> (Arguments -> Either (Pretty ColorText) Input) -> InputPattern
[$sel:patternName:InputPattern] :: InputPattern -> String
[$sel:aliases:InputPattern] :: InputPattern -> [String]
[$sel:visibility:InputPattern] :: InputPattern -> Visibility
[$sel:args:InputPattern] :: InputPattern -> [(ArgumentDescription, IsOptional, ArgumentType)]
[$sel:help:InputPattern] :: InputPattern -> Pretty ColorText

-- | Parse the arguments and return either an error message or a command
--   <a>Input</a>.
--   
--   <b>NB</b>: This function should return <a>Left</a> only on failure.
--   For commands (like <a>$sel:help:InputPattern</a>) that simply produce
--   formatted output, use `pure . Input.CreateMessage`. The failure output
--   should be fully formatted (using <tt>wrap</tt>, etc.), but shouldn’t
--   include any general error components like a warninng flag or the full
--   help message, and shouldn’t plan for the context it is being output to
--   (e.g., don’t <a>indentN</a> the entire message).
[$sel:parse:InputPattern] :: InputPattern -> Arguments -> Either (Pretty ColorText) Input

-- | An argument to a command is either a string provided by the user which
--   needs to be parsed or a numbered argument that doesn’t need to be
--   parsed, as we’ve preserved its representation (although the numbered
--   argument could still be of the wrong type, which should result in an
--   error).
type Argument = Either String StructuredArgument
data ArgumentType
ArgumentType :: String -> (forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]) -> Maybe FZFResolver -> ArgumentType
[$sel:typeName:ArgumentType] :: ArgumentType -> String

-- | Generate completion suggestions for this argument type
[$sel:suggestions:ArgumentType] :: ArgumentType -> forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]

-- | If an argument is marked as required, but not provided, the fuzzy
--   finder will be triggered if available.
[$sel:fzfResolver:ArgumentType] :: ArgumentType -> Maybe FZFResolver

-- | Argument description It should fit grammatically into sentences like
--   "I was expecting an argument for the <a>argDesc</a>" e.g. "namespace
--   to merge", "definition to delete", "remote target to push to" etc.
type ArgumentDescription = Text
type Arguments = [Argument]
argType :: InputPattern -> Int -> Maybe ArgumentType
data FZFResolver
FZFResolver :: OptionFetcher -> FZFResolver
[$sel:getOptions:FZFResolver] :: FZFResolver -> OptionFetcher
data IsOptional
Required :: IsOptional
Optional :: IsOptional
ZeroPlus :: IsOptional
OnePlus :: IsOptional
data Visibility
Hidden :: Visibility
Visible :: Visibility
minArgs :: InputPattern -> Int
maxArgs :: InputPattern -> Maybe Int

-- | Union suggestions from all possible completions
unionSuggestions :: forall m v a. MonadIO m => [String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]] -> String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]

-- | Try the first completer, if it returns no suggestions, try the second,
--   etc.
suggestionFallbacks :: forall m v a. MonadIO m => [String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]] -> String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.IsOptional
instance GHC.Show.Show Unison.CommandLine.InputPattern.IsOptional
instance GHC.Classes.Ord Unison.CommandLine.InputPattern.Visibility
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.ArgumentType

module Unison.Codebase.Editor.Output
data Output
Success :: Output
NoUnisonFile :: Output
PrintMessage :: Pretty ColorText -> Output
InvalidSourceName :: String -> Output
SourceLoadFailed :: String -> Output
NoMainFunction :: HashQualified Name -> PrettyPrintEnv -> [Type Symbol Ann] -> Output

-- | Function found, but has improper type Note: the constructor name is
--   misleading here; we weren't necessarily looking for a "main".
BadMainFunction :: Text -> HashQualified Name -> Type Symbol Ann -> PrettyPrintEnv -> [Type Symbol Ann] -> Output
BranchEmpty :: WhichBranchEmpty -> Output
LoadPullRequest :: ReadRemoteNamespace Void -> ReadRemoteNamespace Void -> Path' -> Path' -> Path' -> Path' -> Output
CreatedNewBranch :: Absolute -> Output
BranchAlreadyExists :: Path' -> Output
FindNoLocalMatches :: Output
NoExactTypeMatches :: Output
TypeAlreadyExists :: Split' -> Set Reference -> Output
TypeParseError :: String -> Err Symbol -> Output
ParseResolutionFailures :: String -> [ResolutionFailure Ann] -> Output
TypeHasFreeVars :: Type Symbol Ann -> Output
TermAlreadyExists :: Split' -> Set Referent -> Output
LabeledReferenceAmbiguous :: Int -> HashQualified Name -> Set LabeledDependency -> Output
LabeledReferenceNotFound :: HashQualified Name -> Output
DeleteNameAmbiguous :: Int -> HQSplit' -> Set Referent -> Set Reference -> Output
TermAmbiguous :: PrettyPrintEnv -> HashQualified Name -> Set Referent -> Output
HashAmbiguous :: ShortHash -> Set Referent -> Output
BranchHashAmbiguous :: ShortCausalHash -> Set ShortCausalHash -> Output
BadNamespace :: String -> String -> Output
BranchNotFound :: Path' -> Output
EmptyLooseCodePush :: Path' -> Output
EmptyProjectBranchPush :: ProjectAndBranch ProjectName ProjectBranchName -> Output
NameNotFound :: HQSplit' -> Output
NamesNotFound :: [Name] -> Output
TypeNotFound :: HQSplit' -> Output
TermNotFound :: HQSplit' -> Output
MoveNothingFound :: Path' -> Output
TypeNotFound' :: ShortHash -> Output
TermNotFound' :: ShortHash -> Output
NoLastRunResult :: Output
SaveTermNameConflict :: Name -> Output
SearchTermsNotFound :: [HashQualified Name] -> Output
SearchTermsNotFoundDetailed :: Bool -> [HashQualified Name] -> [HashQualified Name] -> Output
DeleteBranchConfirmation :: [(Path', (Names, [SearchResult' Symbol Ann]))] -> Output
DeleteEverythingConfirmation :: Output
MoveRootBranchConfirmation :: Output
MovedOverExistingBranch :: Path' -> Output
DeletedEverything :: Output
ListNames :: Int -> [(Reference, [HashQualified Name])] -> [(Referent, [HashQualified Name])] -> Output
GlobalListNames :: ProjectAndBranch ProjectName ProjectBranchName -> Int -> [(Reference, [HashQualified Name])] -> [(Referent, [HashQualified Name])] -> Output
ListOfDefinitions :: FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' Symbol Ann] -> Output
ListShallow :: IO PrettyPrintEnv -> [ShallowListEntry Symbol Ann] -> Output
ListStructuredFind :: [HashQualified Name] -> Output
ListTextFind :: Bool -> [HashQualified Name] -> Output
GlobalFindBranchResults :: ProjectAndBranch ProjectName ProjectBranchName -> PrettyPrintEnv -> ListDetailed -> [SearchResult' Symbol Ann] -> Output
SlurpOutput :: Input -> PrettyPrintEnv -> SlurpResult -> Output
ParseErrors :: Text -> [Err Symbol] -> Output
TypeErrors :: Absolute -> Text -> PrettyPrintEnv -> [ErrorNote Symbol Ann] -> Output
CompilerBugs :: Text -> PrettyPrintEnv -> [CompilerBug Symbol Ann] -> Output
DisplayConflicts :: Relation Name Referent -> Relation Name Reference -> Output
EvaluationFailure :: Error -> Output
Evaluated :: SourceFileContents -> PrettyPrintEnv -> [(Symbol, Term Symbol ())] -> Map Symbol (Ann, WatchKind, Term Symbol (), IsCacheHit) -> Output
RunResult :: PrettyPrintEnv -> Term Symbol () -> Output
LoadingFile :: SourceName -> Output
Typechecked :: SourceName -> PrettyPrintEnv -> SlurpResult -> TypecheckedUnisonFile Symbol Ann -> Output
DisplayRendered :: Maybe FilePath -> Pretty ColorText -> Output
DisplayDefinitions :: Pretty ColorText -> Output
LoadedDefinitionsToSourceFile :: FilePath -> Int -> Output
TestIncrementalOutputStart :: PrettyPrintEnv -> (Int, Int) -> TermReferenceId -> Output
TestIncrementalOutputEnd :: PrettyPrintEnv -> (Int, Int) -> TermReferenceId -> Bool -> Output
CantUndo :: UndoFailureReason -> Output
BustedBuiltins :: Set Reference -> Set Reference -> Output
ShareError :: ShareError -> Output
ViewOnShare :: (URI, ProjectName, ProjectBranchName) -> Output
NoConfiguredRemoteMapping :: PushPull -> Absolute -> Output
ConfiguredRemoteMappingParseError :: PushPull -> Absolute -> Text -> String -> Output
TermMissingType :: Reference -> Output
AboutToPropagatePatch :: Output
PatchNeedsToBeConflictFree :: Output
PatchInvolvesExternalDependents :: PrettyPrintEnv -> Set Reference -> Output
StartOfCurrentPathHistory :: Output
ShowReflog :: [(Maybe UTCTime, ShortCausalHash, Text)] -> Output
PullAlreadyUpToDate :: ReadRemoteNamespace RemoteProjectBranch -> ProjectAndBranch Project ProjectBranch -> Output
PullSuccessful :: ReadRemoteNamespace RemoteProjectBranch -> ProjectAndBranch Project ProjectBranch -> Output
AboutToMerge :: Output

-- | Indicates a trivial merge where the destination was empty and was just
--   replaced.
MergeOverEmpty :: ProjectAndBranch Project ProjectBranch -> Output
MergeAlreadyUpToDate :: BranchRelativePath -> BranchRelativePath -> Output
MergeAlreadyUpToDate2 :: !MergeSourceAndTarget -> Output
PreviewMergeAlreadyUpToDate :: ProjectPath -> ProjectPath -> Output
NotImplemented :: Output
NoBranchWithHash :: ShortCausalHash -> Output
ListDependencies :: PrettyPrintEnv -> Set LabeledDependency -> [HashQualified Name] -> [HashQualified Name] -> Output

-- | List dependents of a type or term.
ListDependents :: PrettyPrintEnv -> Set LabeledDependency -> [HashQualified Name] -> [HashQualified Name] -> Output
DumpNumberedArgs :: HashLength -> NumberedArgs -> Output
DumpBitBooster :: CausalHash -> Map CausalHash [CausalHash] -> Output
DumpUnisonFileHashes :: Int -> [(Name, Id)] -> [(Name, Id)] -> [(Name, Id)] -> Output
BadName :: Text -> Output
CouldntLoadBranch :: CausalHash -> Output
HelpMessage :: InputPattern -> Output
NamespaceEmpty :: NonEmpty (Either ShortCausalHash ProjectPath) -> Output
NoOp :: Output

-- | <tt>GistCreated repo</tt> means a causal was just published to
--   <tt>repo</tt>.
GistCreated :: ReadRemoteNamespace Void -> Output

-- | Directs the user to URI to begin an authorization flow.
InitiateAuthFlow :: URI -> Output
UnknownCodeServer :: Text -> Output
CredentialFailureMsg :: CredentialFailure -> Output
PrintVersion :: Text -> Output
IntegrityCheck :: IntegrityResult -> Output
DisplayDebugNameDiff :: NameChanges -> Output
DisplayDebugCompletions :: [Completion] -> Output
DisplayDebugLSPNameCompletions :: [(Text, Name, LabeledDependency)] -> Output
DebugDisplayFuzzyOptions :: Text -> [String] -> Output
DebugFuzzyOptionsNoResolver :: Output
DebugTerm :: Bool -> Either Text (Term Symbol Ann) -> Output
DebugDecl :: Either Text (Decl Symbol Ann) -> Maybe ConstructorId -> Output
AnnotatedFoldRanges :: Text -> Output
ClearScreen :: Output
PulledEmptyBranch :: ReadRemoteNamespace RemoteProjectBranch -> Output
CreatedProject :: Bool -> ProjectName -> Output
CreatedProjectBranch :: CreatedProjectBranchFrom -> ProjectAndBranch ProjectName ProjectBranchName -> Output
CreatedRemoteProject :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
CreatedRemoteProjectBranch :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectBranchIsUpToDate :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
InvalidProjectName :: Text -> Output
InvalidProjectBranchName :: Text -> Output
InvalidStructuredFindReplace :: HashQualified Name -> Output
InvalidStructuredFind :: HashQualified Name -> Output
ProjectNameAlreadyExists :: ProjectName -> Output
ProjectNameRequiresUserSlug :: ProjectName -> Output
ProjectAndBranchNameAlreadyExists :: ProjectAndBranch ProjectName ProjectBranchName -> Output
NotOnProjectBranch :: Output
NoAssociatedRemoteProject :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
NoAssociatedRemoteProjectBranch :: URI -> ProjectAndBranch Project ProjectBranch -> Output
LocalProjectDoesntExist :: ProjectName -> Output
LocalProjectBranchDoesntExist :: ProjectAndBranch ProjectName ProjectBranchName -> Output
LocalProjectNorProjectBranchExist :: ProjectName -> ProjectBranchName -> Output
RemoteProjectDoesntExist :: URI -> ProjectName -> Output
RemoteProjectBranchDoesntExist :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectBranchDoesntExist'Push :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectReleaseIsDeprecated :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectPublishedReleaseCannotBeChanged :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RemoteProjectBranchHeadMismatch :: URI -> ProjectAndBranch ProjectName ProjectBranchName -> Output
Unauthorized :: Text -> Output
ServantClientError :: ClientError -> Output
MarkdownOut :: Text -> Output
DownloadedEntities :: Int -> Output
UploadedEntities :: Int -> Output
NotImplementedYet :: Text -> Output
DraftingRelease :: ProjectBranchName -> Semver -> Output
CannotCreateReleaseBranchWithBranchCommand :: ProjectBranchName -> Semver -> Output
CalculatingDiff :: Output

-- | The <tt>local</tt> in a `clone remote local` is ambiguous
AmbiguousCloneLocal :: ProjectAndBranch ProjectName ProjectBranchName -> ProjectAndBranch ProjectName ProjectBranchName -> Output

-- | The <tt>remote</tt> in a `clone remote local` is ambiguous
AmbiguousCloneRemote :: ProjectName -> ProjectAndBranch ProjectName ProjectBranchName -> Output
ClonedProjectBranch :: ProjectAndBranch ProjectName ProjectBranchName -> ProjectAndBranch ProjectName ProjectBranchName -> Output
RenamedProject :: ProjectName -> ProjectName -> Output
OutputRewrittenFile :: FilePath -> [Symbol] -> Output
RenamedProjectBranch :: ProjectName -> ProjectBranchName -> ProjectBranchName -> Output
CantRenameBranchTo :: ProjectBranchName -> Output
FetchingLatestReleaseOfBase :: Output
FailedToFetchLatestReleaseOfBase :: Output
HappyCoding :: Output
ProjectHasNoReleases :: ProjectName -> Output
UpdateLookingForDependents :: Output
UpdateStartTypechecking :: Output
UpdateTypecheckingFailure :: Output
UpdateTypecheckingSuccess :: Output
UpdateIncompleteConstructorSet :: UpdateOrUpgrade -> Name -> Map ConstructorId Name -> Maybe Int -> Output
UpgradeFailure :: !ProjectBranchName -> !ProjectBranchName -> !FilePath -> !NameSegment -> !NameSegment -> Output
UpgradeSuccess :: !NameSegment -> !NameSegment -> Output
MergeFailure :: !FilePath -> !MergeSourceAndTarget -> !ProjectBranchName -> Output
MergeSuccess :: !MergeSourceAndTarget -> Output
MergeSuccessFastForward :: !MergeSourceAndTarget -> Output
MergeConflictedAliases :: !MergeSourceOrTarget -> !Defn (Name, Name) (Name, Name) -> Output
MergeConflictInvolvingBuiltin :: !Defn Name Name -> Output
MergeDefnsInLib :: !MergeSourceOrTarget -> Output
InstalledLibdep :: !ProjectAndBranch ProjectName ProjectBranchName -> !NameSegment -> Output
NoUpgradeInProgress :: Output
UseLibInstallNotPull :: !ProjectAndBranch ProjectName ProjectBranchName -> Output
PullIntoMissingBranch :: !ReadRemoteNamespace RemoteProjectBranch -> !ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Output
NoMergeInProgress :: Output
Output'DebugSynhashTerm :: !TermReference -> !Hash -> !Text -> Output
ConflictedDefn :: !Text -> !Defn (Conflicted Name Referent) (Conflicted Name TypeReference) -> Output
IncoherentDeclDuringMerge :: !MergeSourceOrTarget -> !IncoherentDeclReason -> Output
IncoherentDeclDuringUpdate :: !IncoherentDeclReason -> Output
data AmbiguousReset'Argument
AmbiguousReset'Hash :: AmbiguousReset'Argument
AmbiguousReset'Target :: AmbiguousReset'Argument

-- | What did we create a project branch from?
--   
--   <ul>
--   <li>Loose code</li>
--   <li>Nothingness (we made an empty branch)</li>
--   <li>Other branch (in another project)</li>
--   <li>Parent branch (in this project)</li>
--   </ul>
data CreatedProjectBranchFrom
CreatedProjectBranchFrom'LooseCode :: Absolute -> CreatedProjectBranchFrom
CreatedProjectBranchFrom'Nothingness :: CreatedProjectBranchFrom
CreatedProjectBranchFrom'OtherBranch :: ProjectAndBranch Project ProjectBranch -> CreatedProjectBranchFrom
CreatedProjectBranchFrom'ParentBranch :: ProjectBranchName -> CreatedProjectBranchFrom

-- | A branch was empty. But how do we refer to that branch?
data WhichBranchEmpty
WhichBranchEmptyHash :: ShortCausalHash -> WhichBranchEmpty
WhichBranchEmptyPath :: ProjectPath -> WhichBranchEmpty
data NumberedOutput
ShowDiffNamespace :: Either ShortCausalHash ProjectPath -> Either ShortCausalHash ProjectPath -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterUndo :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteDefinitions :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteBranch :: Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterModifyBranch :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMerge :: Either ProjectPath (ProjectAndBranch Project ProjectBranch) -> ProjectPath -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePropagate :: Either ProjectPath (ProjectAndBranch Project ProjectBranch) -> ProjectPath -> Path' -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePreview :: Either ProjectPath (ProjectAndBranch Project ProjectBranch) -> ProjectPath -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterPull :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterCreateAuthor :: NameSegment -> Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
TestResults :: TestReportStats -> PrettyPrintEnv -> ShowSuccesses -> ShowFailures -> Map TermReferenceId [Text] -> Map TermReferenceId [Text] -> NumberedOutput
Output'Todo :: !TodoOutput -> NumberedOutput

-- | CantDeleteDefinitions ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteDefinitions :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | CantDeleteNamespace ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteNamespace :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | DeletedDespiteDependents ppe deletedThings
--   thingsWhichNowHaveUnnamedReferences
DeletedDespiteDependents :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | size limit, history , how the history ends
History :: Maybe Int -> HashLength -> [(CausalHash, Diff)] -> HistoryTail -> NumberedOutput
ListProjects :: [Project] -> NumberedOutput
ListBranches :: ProjectName -> [(ProjectBranchName, [(URI, ProjectName, ProjectBranchName)])] -> NumberedOutput
AmbiguousSwitch :: ProjectName -> ProjectAndBranch ProjectName ProjectBranchName -> NumberedOutput
AmbiguousReset :: AmbiguousReset'Argument -> (ProjectAndBranch Project ProjectBranch, Path) -> ProjectAndBranch ProjectName ProjectBranchName -> NumberedOutput

-- | List all direct dependencies which don't have any names in the current
--   branch
ListNamespaceDependencies :: PrettyPrintEnv -> ProjectPath -> Map LabeledDependency (Set Name) -> NumberedOutput
ShowProjectBranchReflog :: Maybe UTCTime -> MoreEntriesThanShown -> [Entry Project ProjectBranch (CausalHash, ShortCausalHash)] -> NumberedOutput

-- | <b>NB</b>: This only temporarily holds <a>Text</a>. Until all of the
--   inputs are updated to handle <a>StructuredArgument</a>s, we need to
--   ensure that the serialization remains unchanged.
type NumberedArgs = [StructuredArgument]
type ListDetailed = Bool
data HistoryTail
EndOfLog :: CausalHash -> HistoryTail
MergeTail :: CausalHash -> [CausalHash] -> HistoryTail
PageEnd :: CausalHash -> Int -> HistoryTail
data TestReportStats
CachedTests :: TotalCount -> CachedCount -> TestReportStats
NewlyComputed :: TestReportStats
data TodoOutput
TodoOutput :: !Bool -> !Set TermReferenceId -> !DefnsF Set TermReference TypeReference -> !Int -> !IncoherentDeclReasons -> !Names -> !PrettyPrintEnvDecl -> TodoOutput
[$sel:defnsInLib:TodoOutput] :: TodoOutput -> !Bool
[$sel:dependentsOfTodo:TodoOutput] :: TodoOutput -> !Set TermReferenceId
[$sel:directDependenciesWithoutNames:TodoOutput] :: TodoOutput -> !DefnsF Set TermReference TypeReference
[$sel:hashLen:TodoOutput] :: TodoOutput -> !Int
[$sel:incoherentDeclReasons:TodoOutput] :: TodoOutput -> !IncoherentDeclReasons
[$sel:nameConflicts:TodoOutput] :: TodoOutput -> !Names
[$sel:ppe:TodoOutput] :: TodoOutput -> !PrettyPrintEnvDecl
todoOutputIsEmpty :: TodoOutput -> Bool
data MoreEntriesThanShown
MoreEntriesThanShown :: MoreEntriesThanShown
AllEntriesShown :: MoreEntriesThanShown
data UndoFailureReason
CantUndoPastStart :: UndoFailureReason
CantUndoPastMerge :: UndoFailureReason
data ShareError
ShareErrorDownloadEntities :: DownloadEntitiesError -> ShareError
ShareErrorGetCausalHashByPath :: GetCausalHashByPathError -> ShareError
ShareErrorPull :: PullError -> ShareError
ShareErrorTransport :: CodeserverTransportError -> ShareError
ShareErrorUploadEntities :: UploadEntitiesError -> ShareError
ShareExpectedSquashedHead :: ShareError
data UpdateOrUpgrade
UOUUpdate :: UpdateOrUpgrade
UOUUpgrade :: UpdateOrUpgrade
isFailure :: Output -> Bool
isNumberedFailure :: NumberedOutput -> Bool
instance GHC.Show.Show Unison.Codebase.Editor.Output.MoreEntriesThanShown
instance GHC.Classes.Eq Unison.Codebase.Editor.Output.MoreEntriesThanShown
instance GHC.Show.Show Unison.Codebase.Editor.Output.HistoryTail
instance GHC.Show.Show Unison.Codebase.Editor.Output.TestReportStats
instance GHC.Show.Show Unison.Codebase.Editor.Output.UndoFailureReason


-- | Small combinators that pretty-print small types in a canonical way for
--   human consumption, such as hashes, file paths, and project names.
module Unison.Cli.Pretty

-- | Displays a full, non-truncated Branch.CausalHash to a string, e.g.
--   #abcdef
displayBranchHash :: CausalHash -> Text
prettyAbsolute :: Absolute -> Pretty
prettyProjectPath :: ProjectPath -> Pretty
prettyBranchRelativePath :: BranchRelativePath -> Pretty
prettyBase32Hex# :: IsString s => Base32Hex -> Pretty s
prettyBase32Hex :: IsString s => Base32Hex -> Pretty s
prettyBranchId :: AbsBranchId -> Pretty
prettyCausalHash :: IsString s => CausalHash -> Pretty s
prettyDeclPair :: Var v => PrettyPrintEnv -> (Reference, DisplayObject () (Decl v a)) -> Pretty
prettyDeclTriple :: Var v => (HashQualified Name, Reference, DisplayObject () (Decl v a)) -> Pretty
prettyFilePath :: FilePath -> Pretty
prettyHash :: IsString s => Hash -> Pretty s
prettyHash32 :: IsString s => Hash32 -> Pretty s
prettyHumanReadableTime :: UTCTime -> UTCTime -> Pretty
prettyLabeledDependencies :: PrettyPrintEnv -> Set LabeledDependency -> Pretty
prettyPath :: Path -> Pretty
prettyPath' :: Path' -> Pretty
prettyMergeSource :: MergeSource -> Pretty
prettyMergeSourceOrTarget :: MergeSourceOrTarget -> Pretty
prettyProjectAndBranchName :: ProjectAndBranch ProjectName ProjectBranchName -> Pretty
prettyProjectBranchName :: ProjectBranchName -> Pretty
prettyProjectName :: ProjectName -> Pretty

-- | <a>prettyProjectName</a> with a trailing slash.
prettyProjectNameSlash :: ProjectName -> Pretty
prettyNamespaceKey :: Either ProjectPath (ProjectAndBranch Project ProjectBranch) -> Pretty
prettyReadRemoteNamespace :: ReadRemoteNamespace RemoteProjectBranch -> Pretty
prettyReadRemoteNamespaceWith :: (a -> Text) -> ReadRemoteNamespace a -> Pretty
prettyRelative :: Relative -> Pretty
prettyRemoteBranchInfo :: (URI, ProjectName, ProjectBranchName) -> Pretty
prettyRepoInfo :: RepoInfo -> Pretty
prettySCH :: IsString s => ShortCausalHash -> Pretty s
prettySemver :: Semver -> Pretty
prettySharePath :: Path -> Pretty
prettyShareURI :: URI -> Pretty

-- | Like <a>prettyProjectBranchName</a>, but with a leading forward slash.
--   This is used in some outputs to encourage/advertise an unambiguous
--   syntax for project branches, as there's an ambiguity with
--   single-segment relative paths.
--   
--   Not all project branches are printed such: for example, when listing
--   all branches of a project, we probably don't need or want to prefix
--   every one with a forward slash.
prettySlashProjectBranchName :: ProjectBranchName -> Pretty
prettyTerm :: PrettyPrintEnvDecl -> Bool -> Bool -> (HashQualified Name, Reference, DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Pretty SyntaxText
prettyTermName :: PrettyPrintEnv -> Referent -> Pretty
prettyType :: PrettyPrintEnvDecl -> (HashQualified Name, Reference, DisplayObject () (Decl Symbol Ann)) -> Pretty SyntaxText
prettyTypeName :: PrettyPrintEnv -> Reference -> Pretty
prettyTypeResultHeader' :: Var v => TypeResult' v a -> Pretty
prettyTypeResultHeaderFull' :: Var v => TypeResult' v a -> Pretty
prettyURI :: URI -> Pretty
prettyUnisonFile :: forall v a. (Var v, Ord a) => PrettyPrintEnvDecl -> UnisonFile v a -> Pretty ColorText

-- | Pretty-print a <a>WhichBranchEmpty</a>.
prettyWhichBranchEmpty :: WhichBranchEmpty -> Pretty
prettyWriteRemoteNamespace :: ProjectAndBranch ProjectName ProjectBranchName -> Pretty
shareOrigin :: Text
unsafePrettyTermResultSigFull' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty

module Unison.CommandLine.Completion

-- | Constructs a list of <a>Completion</a>s from a query and completion
--   options by filtering them for prefix matches. A completion will be
--   selected if it's an exact match for a provided option.
exactComplete :: String -> [String] -> [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteTermOrType :: String -> ProjectPath -> Transaction [Completion]

-- | Completes a term argument by prefix-matching against the query.
prefixCompleteTerm :: String -> ProjectPath -> Transaction [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteType :: String -> ProjectPath -> Transaction [Completion]

-- | Completes a patch argument by prefix-matching against the query.
prefixCompletePatch :: String -> ProjectPath -> Transaction [Completion]

-- | The empty completor.
noCompletions :: MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> m [Completion]

-- | Completes a namespace argument by prefix-matching against the query.
prefixCompleteNamespace :: String -> ProjectPath -> Transaction [Completion]
prettyCompletion :: Bool -> (String, Pretty ColorText) -> Completion
fixupCompletion :: String -> [Completion] -> [Completion]

-- | A completion func for use with Haskeline
haskelineTabComplete :: MonadIO m => Map String InputPattern -> Codebase m v a -> AuthenticatedHttpClient -> ProjectPath -> CompletionFunc m
sharePathCompletion :: MonadIO m => AuthenticatedHttpClient -> String -> m [Completion]
instance GHC.Classes.Ord Unison.CommandLine.Completion.CompletionType
instance GHC.Classes.Eq Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.SearchResult
instance Data.Aeson.Types.FromJSON.FromJSON Unison.CommandLine.Completion.SearchResult


-- | This module defines <a>InputPattern</a> values for every supported
--   input command.
module Unison.CommandLine.InputPatterns
add :: InputPattern
aliasMany :: InputPattern
aliasTerm :: InputPattern
aliasType :: InputPattern
api :: InputPattern
authLogin :: InputPattern
back :: InputPattern
branchEmptyInputPattern :: InputPattern
branchInputPattern :: InputPattern
branchRenameInputPattern :: InputPattern
branchesInputPattern :: InputPattern
cd :: InputPattern
clear :: InputPattern
clone :: InputPattern
compileScheme :: InputPattern
createAuthor :: InputPattern
debugClearWatchCache :: InputPattern
debugDoctor :: InputPattern
debugDumpNamespace :: InputPattern
debugDumpNamespaceSimple :: InputPattern
debugFileHashes :: InputPattern
debugFormat :: InputPattern
debugFuzzyOptions :: InputPattern
debugLSPFoldRanges :: InputPattern
debugNameDiff :: InputPattern
debugNumberedArgs :: InputPattern
debugTabCompletion :: InputPattern
debugLspNameCompletion :: InputPattern
debugTerm :: InputPattern
debugTermVerbose :: InputPattern
debugType :: InputPattern
delete :: InputPattern
deleteBranch :: InputPattern
deleteNamespace :: InputPattern
deleteNamespaceForce :: InputPattern
deleteProject :: InputPattern
deleteTerm :: InputPattern
deleteTermVerbose :: InputPattern
deleteType :: InputPattern
deleteTypeVerbose :: InputPattern
deleteVerbose :: InputPattern
dependencies :: InputPattern
dependents :: InputPattern
diffNamespace :: InputPattern
display :: InputPattern
displayTo :: InputPattern
docToMarkdown :: InputPattern
docs :: InputPattern
docsToHtml :: InputPattern
edit :: InputPattern
editNamespace :: InputPattern
execute :: InputPattern
find :: InputPattern
findAll :: InputPattern
findGlobal :: InputPattern
findIn :: InputPattern
findInAll :: InputPattern
findShallow :: InputPattern
findVerbose :: InputPattern
findVerboseAll :: InputPattern
forkLocal :: InputPattern
help :: InputPattern
helpTopics :: InputPattern
history :: InputPattern
ioTest :: InputPattern
ioTestAll :: InputPattern
libInstallInputPattern :: InputPattern
load :: InputPattern
makeStandalone :: InputPattern
mergeBuiltins :: InputPattern
mergeCommitInputPattern :: InputPattern
mergeIOBuiltins :: InputPattern
mergeInputPattern :: InputPattern
mergeOldInputPattern :: InputPattern
mergeOldPreviewInputPattern :: InputPattern
mergeOldSquashInputPattern :: InputPattern
moveAll :: InputPattern
names :: IsGlobal -> InputPattern
namespaceDependencies :: InputPattern
previewAdd :: InputPattern
previewUpdate :: InputPattern
printVersion :: InputPattern
projectCreate :: InputPattern
projectCreateEmptyInputPattern :: InputPattern
projectRenameInputPattern :: InputPattern
projectSwitch :: InputPattern
projectsInputPattern :: InputPattern
pull :: InputPattern
pullWithoutHistory :: InputPattern
push :: InputPattern
pushCreate :: InputPattern
pushExhaustive :: InputPattern
pushForce :: InputPattern
quit :: InputPattern
releaseDraft :: InputPattern
renameBranch :: InputPattern
renameTerm :: InputPattern
renameType :: InputPattern
reset :: InputPattern
runScheme :: InputPattern
saveExecuteResult :: InputPattern
sfind :: InputPattern
sfindReplace :: InputPattern
textfind :: Bool -> InputPattern
test :: InputPattern
testAll :: InputPattern
todo :: InputPattern
ui :: InputPattern
undo :: InputPattern
up :: InputPattern
update :: InputPattern
updateBuiltins :: InputPattern
updateOld :: InputPattern
updateOldNoPatch :: InputPattern
upgrade :: InputPattern
upgradeCommitInputPattern :: InputPattern
view :: InputPattern
viewGlobal :: InputPattern
deprecatedViewRootReflog :: InputPattern
branchReflog :: InputPattern
projectReflog :: InputPattern
globalReflog :: InputPattern
formatStructuredArgument :: Maybe Int -> StructuredArgument -> Text
helpFor :: InputPattern -> Pretty ColorText
makeExample' :: InputPattern -> Pretty ColorText
makeExample :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExampleEOS :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExampleNoBackticks :: InputPattern -> [Pretty ColorText] -> Pretty ColorText

-- | A map of all command patterns by pattern name or alias.
patternMap :: Map String InputPattern
patternName :: InputPattern -> Pretty ColorText
showPatternHelp :: InputPattern -> Pretty ColorText

-- | Converts an arbitrary argument to a <a>String</a>. This is for cases
--   where the command <i>should</i> accept a structured argument of some
--   type, but currently wants a <a>String</a>.
unifyArgument :: Argument -> String
validInputs :: [InputPattern]
instance GHC.Show.Show Unison.CommandLine.InputPatterns.ProjectInclusion
instance GHC.Classes.Ord Unison.CommandLine.InputPatterns.ProjectInclusion
instance GHC.Classes.Eq Unison.CommandLine.InputPatterns.ProjectInclusion
instance GHC.Show.Show Unison.CommandLine.InputPatterns.BranchInclusion
instance GHC.Classes.Ord Unison.CommandLine.InputPatterns.BranchInclusion
instance GHC.Classes.Eq Unison.CommandLine.InputPatterns.BranchInclusion

module Unison.CommandLine
allow :: FilePath -> Bool
parseInput :: Codebase IO Symbol Ann -> ProjectPath -> IO (Branch IO) -> NumberedArgs -> Map String InputPattern -> [String] -> IO (Either (Pretty ColorText) (Maybe (Arguments, Input)))
prompt :: String
watchFileSystem :: TQueue Event -> FilePath -> IO (IO ())


-- | The main CLI monad.
module Unison.Cli.Monad

-- | The main command-line app monad.
--   
--   <ul>
--   <li>It is a reader monad of <a>Env</a>.</li>
--   <li>It is a state monad of <a>LoopState</a>.</li>
--   <li>It is a short-circuiting monad: a <tt>Cli</tt> computation can
--   short-circuit with success or failure in a delimited scope.</li>
--   <li>It is a resource monad: resources can be acquired in
--   callback-style.</li>
--   <li>It is an IO monad: you can do IO things, but throwing synchronous
--   exceptions is discouraged. Use the built-in short-circuiting mechanism
--   instead.</li>
--   </ul>
data Cli a

-- | What a Cli action returns: a value, an instruction to continue
--   processing input, or an instruction to stop processing input.
data ReturnType a
Success :: a -> ReturnType a
Continue :: ReturnType a
HaltRepl :: ReturnType a

-- | Name used for a source-file/source buffer
type SourceName = Text

-- | Run a <tt>Cli</tt> action down to <tt>IO</tt>.
runCli :: Env -> LoopState -> Cli a -> IO (ReturnType a, LoopState)

-- | The command-line app monad environment.
--   
--   Get the environment with <a>ask</a>.
data Env
Env :: AuthenticatedHttpClient -> Codebase IO Symbol Ann -> CredentialManager -> IO UniqueName -> (SourceName -> IO LoadSourceResult) -> (SourceName -> Text -> Bool -> IO ()) -> (Output -> IO ()) -> (NumberedOutput -> IO NumberedArgs) -> Runtime Symbol -> Runtime Symbol -> Runtime Symbol -> Maybe BaseUrl -> UCMVersion -> Bool -> Env
[$sel:authHTTPClient:Env] :: Env -> AuthenticatedHttpClient
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:credentialManager:Env] :: Env -> CredentialManager

-- | Generate a unique name.
[$sel:generateUniqueName:Env] :: Env -> IO UniqueName

-- | How to load source code.
[$sel:loadSource:Env] :: Env -> SourceName -> IO LoadSourceResult

-- | How to write source code. Bool = make new fold?
[$sel:writeSource:Env] :: Env -> SourceName -> Text -> Bool -> IO ()

-- | What to do with output for the user.
[$sel:notify:Env] :: Env -> Output -> IO ()

-- | What to do with numbered output for the user.
[$sel:notifyNumbered:Env] :: Env -> NumberedOutput -> IO NumberedArgs
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:sandboxedRuntime:Env] :: Env -> Runtime Symbol
[$sel:nativeRuntime:Env] :: Env -> Runtime Symbol
[$sel:serverBaseUrl:Env] :: Env -> Maybe BaseUrl
[$sel:ucmVersion:Env] :: Env -> UCMVersion

-- | Whether we're running in a transcript test or not. Avoid using this
--   except when absolutely necessary.
[$sel:isTranscriptTest:Env] :: Env -> Bool

-- | The command-line app monad mutable state.
--   
--   There's an additional pseudo <tt>"currentPath"</tt> field lens, for
--   convenience.
data LoopState
LoopState :: NonEmpty ProjectPathIds -> Maybe (FilePath, Bool) -> Maybe (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann)) -> Maybe Input -> NumberedArgs -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann) -> LoopState
[$sel:projectPathStack:LoopState] :: LoopState -> NonEmpty ProjectPathIds
[$sel:latestFile:LoopState] :: LoopState -> Maybe (FilePath, Bool)
[$sel:latestTypecheckedFile:LoopState] :: LoopState -> Maybe (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann))
[$sel:lastInput:LoopState] :: LoopState -> Maybe Input
[$sel:numberedArgs:LoopState] :: LoopState -> NumberedArgs
[$sel:lastRunResult:LoopState] :: LoopState -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann)

-- | Create an initial loop state given a root branch and the current path.
loopState0 :: ProjectPathIds -> LoopState
getProjectPathIds :: Cli ProjectPathIds

-- | Lift an action of type <tt>IO (Either e a)</tt>, given a continuation
--   for <tt>e</tt>.
ioE :: IO (Either e a) -> (e -> Cli a) -> Cli a

-- | Wrap a continuation with <a>Cli</a>.
--   
--   Useful for resource acquisition:
--   
--   <pre>
--   with (bracket create destroy) \resource -&gt;
--     ...
--   </pre>
with :: (forall x. (a -> IO x) -> IO x) -> (a -> Cli b) -> Cli b

-- | A variant of <a>with</a> for actions that don't acquire a resource
--   (like <a>bracket_</a>).
with_ :: (forall x. IO x -> IO x) -> Cli a -> Cli a

-- | A variant of <a>with</a> for the variant of bracketing function that
--   may return a Left rather than call the provided continuation.
withE :: (forall x. (a -> IO x) -> IO (Either e x)) -> (Either e a -> Cli b) -> Cli b

-- | Create a label that can be jumped to.
--   
--   <pre>
--   x &lt;- label \j0 -&gt; do
--     ...
--     label \j1 -&gt; do
--       ...
--       j0 someValue
--       ... -- We don't get here
--     ... -- We don't get here
--   -- x is bound to someValue
--   </pre>
label :: forall a. ((forall void. a -> Cli void) -> Cli a) -> Cli a

-- | A variant of <tt>label</tt> for the common case that early-return
--   values are tagged with a Left.
labelE :: ((forall void. a -> Cli void) -> Cli b) -> Cli (Either a b)

-- | Short-circuit the processing of the current input.
returnEarly :: Output -> Cli a

-- | Variant of <a>returnEarly</a> that doesn't take a final output
--   message.
returnEarlyWithoutOutput :: Cli a

-- | Stop processing inputs from the user.
haltRepl :: Cli a
cd :: Absolute -> Cli ()

-- | Pop the latest path off the stack, if it's not the only path in the
--   stack.
--   
--   Returns whether anything was popped.
popd :: Cli Bool
switchProject :: ProjectAndBranch ProjectId ProjectBranchId -> Cli ()
respond :: Output -> Cli ()
respondNumbered :: NumberedOutput -> Cli ()

-- | Updates the numbered args, but only if the new args are non-empty.
setNumberedArgs :: NumberedArgs -> Cli ()

-- | Time an action.
time :: String -> Cli a -> Cli a
runTransaction :: Transaction a -> Cli a

-- | Run a transaction that can abort early with an output message. todo:
--   rename to runTransactionWithReturnEarly
runTransactionWithRollback :: ((forall void. Output -> Transaction void) -> Transaction a) -> Cli a

-- | Run a transaction that can abort early. todo: rename to
--   runTransactionWithRollback
runTransactionWithRollback2 :: ((forall void. a -> Transaction void) -> Transaction a) -> Cli a
setMostRecentProjectPath :: ProjectPathIds -> Cli ()

-- | The result of calling <a>$sel:loadSource:Env</a>.
data LoadSourceResult
InvalidSourceNameError :: LoadSourceResult
LoadError :: LoadSourceResult
LoadSuccess :: Text -> LoadSourceResult
instance GHC.Show.Show a => GHC.Show.Show (Unison.Cli.Monad.ReturnType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Cli.Monad.ReturnType a)
instance GHC.Generics.Generic Unison.Cli.Monad.LoopState
instance GHC.Generics.Generic Unison.Cli.Monad.Env
instance GHC.Base.Functor Unison.Cli.Monad.Cli
instance GHC.Exception.Type.Exception Unison.Cli.Monad.X
instance GHC.Show.Show Unison.Cli.Monad.X
instance GHC.Base.Applicative Unison.Cli.Monad.Cli
instance GHC.Base.Monad Unison.Cli.Monad.Cli
instance Control.Monad.IO.Class.MonadIO Unison.Cli.Monad.Cli
instance Control.Monad.Reader.Class.MonadReader Unison.Cli.Monad.Env Unison.Cli.Monad.Cli
instance Control.Monad.State.Class.MonadState Unison.Cli.Monad.LoopState Unison.Cli.Monad.Cli

module Unison.Share.Sync

-- | Get the causal hash of a path hosted on Unison Share.
getCausalHashByPath :: BaseUrl -> Path -> Cli (Either (SyncError GetCausalHashByPathError) (Maybe HashJWT))

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | The repo info was invalid. (err, repoInfo)
GetCausalHashByPathErrorInvalidRepoInfo :: Text -> RepoInfo -> GetCausalHashByPathError

-- | The user was not found.
GetCausalHashByPathErrorUserNotFound :: RepoInfo -> GetCausalHashByPathError

-- | Upload a set of entities to Unison Share. If the server responds that
--   it cannot yet store any hash(es) due to missing dependencies, send
--   those dependencies too, and on and on, until the server stops
--   responding that it's missing anything.
--   
--   Returns true on success, false on failure (because the user does not
--   have write permission).
uploadEntities :: BaseUrl -> RepoInfo -> NESet Hash32 -> (Int -> IO ()) -> Cli (Either (SyncError UploadEntitiesError) ())
pull :: BaseUrl -> Path -> (Int -> IO ()) -> Cli (Either (SyncError PullError) CausalHash)

-- | An error occurred while pulling code from Unison Share.
data PullError
PullError'DownloadEntities :: DownloadEntitiesError -> PullError
PullError'GetCausalHash :: GetCausalHashByPathError -> PullError
PullError'NoHistoryAtPath :: Path -> PullError
downloadEntities :: BaseUrl -> RepoInfo -> HashJWT -> (Int -> IO ()) -> Cli (Either (SyncError DownloadEntitiesError) ())

module Unison.CommandLine.OutputMessages
reportBugURL :: Pretty
type Pretty = Pretty ColorText
shortenDirectory :: FilePath -> IO FilePath
renderFileName :: FilePath -> IO Pretty
notifyNumbered :: NumberedOutput -> (Pretty, NumberedArgs)
undoTip :: Pretty ColorText
notifyUser :: FilePath -> Output -> IO Pretty
prettyShareError :: ShareError -> Pretty
prettyDownloadEntitiesError :: DownloadEntitiesError -> Pretty
prettyGetCausalHashByPathError :: GetCausalHashByPathError -> Pretty
prettyPullError :: PullError -> Pretty
prettyUploadEntitiesError :: UploadEntitiesError -> Pretty
prettyEntityValidationFailure :: EntityValidationError -> Pretty
prettyTransportError :: CodeserverTransportError -> Pretty
prettyEntityType :: EntityType -> Pretty
invalidRepoInfo :: Text -> RepoInfo -> Pretty
hashMismatchFromShare :: Hash32 -> Hash32 -> Pretty
pushPublicNote :: InputPattern -> Text -> [Text] -> Pretty
needDependencies :: NeedDependencies Hash32 -> Pretty
noReadPermissionForPath :: Path -> Pretty
noReadPermissionForRepo :: RepoInfo -> Pretty
noWritePermissionForPath :: Path -> Pretty
noWritePermissionForRepo :: RepoInfo -> Pretty
notFastForward :: Path -> Pretty
shareProjectNotFound :: Text -> Pretty
shareUserNotFound :: RepoInfo -> Pretty
formatMissingStuff :: (Show tm, Show typ) => [(HashQualified Name, tm)] -> [(HashQualified Name, typ)] -> Pretty
displayOutputRewrittenFile :: Var v => FilePath -> [v] -> IO Pretty
displayDefinitions' :: Var v => Ord a1 => PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> Pretty
displayRendered :: Maybe FilePath -> Pretty -> IO Pretty
displayTestResults :: Bool -> [(HashQualified Name, [Text])] -> [(HashQualified Name, [Text])] -> Pretty
unsafePrettyTermResultSig' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
renderNameConflicts :: Int -> Names -> Numbered Pretty
type Numbered = State (Int, Seq StructuredArgument)
addNumberedArg :: StructuredArgument -> Numbered Int
formatNum :: Int -> Pretty
runNumbered :: Numbered a -> (a, NumberedArgs)
handleTodoOutput :: TodoOutput -> Numbered Pretty
listOfDefinitions :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> IO Pretty
listOfNames :: Int -> [(Reference, [HashQualified Name])] -> [(Referent, [HashQualified Name])] -> IO Pretty
data ShowNumbers
ShowNumbers :: ShowNumbers
HideNumbers :: ShowNumbers

-- | <tt>ppe</tt> is just for rendering type signatures `oldPath, newPath
--   :: Path.Absolute` are just for producing fully-qualified numbered args
showDiffNamespace :: forall v. Var v => ShowNumbers -> PrettyPrintEnv -> AbsBranchId -> AbsBranchId -> BranchDiffOutput v Ann -> (Pretty, NumberedArgs)
noResults :: FindScope -> Pretty
listOfDefinitions' :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> Pretty
watchPrinter :: Var v => Text -> PrettyPrintEnv -> Ann -> WatchKind -> Term v () -> IsCacheHit -> Pretty
filestatusTip :: Pretty
prettyDiff :: Diff -> Pretty

-- | Get the list of numbered args corresponding to an endangerment map,
--   which is used by a few outputs. See <a>endangeredDependentsTable</a>.
numberedArgsForEndangerments :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedArgs

-- | Format and render all dependents which are endangered by references
--   going extinct.
endangeredDependentsTable :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> Pretty ColorText
listFind :: Bool -> Maybe Pretty -> [HashQualified Name] -> Pretty
listDependentsOrDependencies :: PrettyPrintEnv -> Text -> Text -> Set LabeledDependency -> [HashQualified Name] -> [HashQualified Name] -> Pretty
displayProjectBranchReflogEntries :: Maybe UTCTime -> MoreEntriesThanShown -> [Entry Project ProjectBranch (CausalHash, ShortCausalHash)] -> (Pretty, NumberedArgs)

module Unison.CommandLine.DisplayValues
type Pretty = Pretty ColorText
displayTerm :: Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
type ElideUnit = Bool
displayTerm' :: Monad m => ElideUnit -> PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayPretty :: forall m. Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Pretty
termName :: PrettyPrintEnv -> Referent -> Pretty
typeName :: PrettyPrintEnv -> Reference -> Pretty

module Unison.Codebase.Editor.Propagate
propagateAndApply :: Names -> Patch -> Branch0 IO -> Cli (Branch0 IO)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Propagate.Edits v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Codebase.Editor.Propagate.Edits v)

module Unison.Codebase.Editor.HandleInput.RuntimeUtils

-- | Evaluate a single closed definition.
evalUnisonTerm :: Bool -> PrettyPrintEnv -> Bool -> Term Symbol Ann -> Cli (Term Symbol Ann)

-- | Evaluate a single closed definition.
evalUnisonTermE :: Bool -> PrettyPrintEnv -> Bool -> Term Symbol Ann -> Cli (Either Error (Term Symbol Ann))
evalPureUnison :: PrettyPrintEnv -> Bool -> Term Symbol Ann -> Cli (Either Error (Term Symbol Ann))
displayDecompileErrors :: [Error] -> Cli ()


-- | <tt>projects</tt> input handler
module Unison.Codebase.Editor.HandleInput.Projects
handleProjects :: Cli ()

module Unison.Codebase.Editor.HandleInput.Global

-- | Map over ALL project branches in the codebase. This is a _very_ big
--   hammer, that you should basically never use, except for things like
--   debugging or migrations.
forAllProjectBranches :: Monoid r => ((ProjectAndBranch ProjectName ProjectBranchName, ProjectAndBranch ProjectId ProjectBranchId) -> Branch IO -> Cli r) -> Cli r

module Unison.Codebase.Editor.HandleInput.AuthLogin

-- | Direct the user through an authentication flow with the given server
--   and store the credentials in the provided credential manager.
authLogin :: CodeserverURI -> Cli UserInfo

-- | Checks if the user has valid auth for the given codeserver, and runs
--   through an authentication flow if not.
ensureAuthenticatedWithCodeserver :: CodeserverURI -> Cli UserInfo


-- | This module contains functionality that is common to the general idea
--   of "updating" a term in Unison, which is when we reassign a name from
--   one hash to another and then see if all dependents still typecheck.
--   
--   This occurs in the <tt>pull</tt>, <tt>merge</tt>, <tt>update</tt>, and
--   <tt>upgrade</tt> commands.
module Unison.Cli.UpdateUtils
loadNamespaceDefinitions :: forall m. Monad m => (Referent -> m Referent) -> Branch m -> m (Either (Defn (Conflicted Name Referent) (Conflicted Name TypeReference)) (Nametree (DefnsF (Map NameSegment) Referent TypeReference)))

-- | Given a namespace and a set of dependencies, return the subset of the
--   namespace that consists of only the (transitive) dependents of the
--   dependencies.
getNamespaceDependentsOf :: Names -> Set Reference -> Transaction (DefnsF (Relation Name) TermReferenceId TypeReferenceId)

-- | Given a namespace and a set of dependencies, return the subset of the
--   namespace that consists of only the (transitive) dependents of the
--   dependencies.
getNamespaceDependentsOf2 :: Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name) -> Set Reference -> Transaction (DefnsF (Map Name) TermReferenceId TypeReferenceId)

-- | Given a namespace and a set of dependencies, return the subset of the
--   namespace that consists of only the (transitive) dependents of the
--   dependencies.
getNamespaceDependentsOf3 :: Defns (BiMultimap Referent Name) (BiMultimap TypeReference Name) -> DefnsF Set TermReference TypeReference -> Transaction (DefnsF Set TermReferenceId TypeReferenceId)

-- | <a>Narrow</a> a namespace that may contain conflicted names, resulting
--   in either a failure (if we find a conflicted name), or the narrowed
--   nametree without conflicted names.
narrowDefns :: forall term typ. (Ord term, Ord typ) => DefnsF (Relation Name) term typ -> Either (Defn (Conflicted Name term) (Conflicted Name typ)) (Nametree (DefnsF (Map NameSegment) term typ))

-- | Hydrate term<i>type references to actual terms</i>types.
hydrateDefns :: forall m name term typ. (Monad m, Ord name) => (Hash -> m [term]) -> (Hash -> m [typ]) -> DefnsF (Map name) TermReferenceId TypeReferenceId -> m (DefnsF (Map name) (TermReferenceId, term) (TypeReferenceId, typ))
parseAndTypecheck :: Pretty ColorText -> ParsingEnv Transaction -> Cli (Maybe (TypecheckedUnisonFile Symbol Ann))


-- | This module contains Share API calls related to projects, wrapped in
--   the Cli monad.
--   
--   Here, we also validate inputs from Share that the API itself does not.
--   For example, in the API, a project name is just a Text. But because
--   our client requires a richer structure for project names, we try
--   parsing them into a ProjectName, and fail right away if parsing fails.
module Unison.Cli.Share.Projects

-- | A remote project.
data RemoteProject
RemoteProject :: RemoteProjectId -> ProjectName -> Maybe Semver -> RemoteProject
[$sel:projectId:RemoteProject] :: RemoteProject -> RemoteProjectId
[$sel:projectName:RemoteProject] :: RemoteProject -> ProjectName
[$sel:latestRelease:RemoteProject] :: RemoteProject -> Maybe Semver

-- | A remote project branch.
data RemoteProjectBranch
RemoteProjectBranch :: RemoteProjectId -> ProjectName -> RemoteProjectBranchId -> ProjectBranchName -> HashJWT -> Maybe HashJWT -> RemoteProjectBranch
[$sel:projectId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectId
[$sel:projectName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectName
[$sel:branchId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectBranchId
[$sel:branchName:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectBranchName
[$sel:branchHead:RemoteProjectBranch] :: RemoteProjectBranch -> HashJWT
[$sel:squashedBranchHead:RemoteProjectBranch] :: RemoteProjectBranch -> Maybe HashJWT

-- | Get a project by id.
--   
--   On success, update the <tt>remote_project</tt> table.
getProjectById :: RemoteProjectId -> Cli (Maybe RemoteProject)

-- | Get a project by name.
--   
--   On success, update the <tt>remote_project</tt> table.
getProjectByName :: ProjectName -> Cli (Maybe RemoteProject)

-- | Variant of <a>getProjectByName</a> that returns servant client errors.
getProjectByName' :: ProjectName -> Cli (Either ClientError (Maybe RemoteProject))

-- | Create a new project. Kinda weird: returns <a>Nothing</a> if the user
--   handle part of the project doesn't exist.
--   
--   On success, update the <tt>remote_project</tt> table.
createProject :: ProjectName -> Cli (Maybe RemoteProject)
data GetProjectBranchResponse
GetProjectBranchResponseBranchNotFound :: GetProjectBranchResponse
GetProjectBranchResponseProjectNotFound :: GetProjectBranchResponse
GetProjectBranchResponseSuccess :: !RemoteProjectBranch -> GetProjectBranchResponse
data IncludeSquashedHead
IncludeSquashedHead :: IncludeSquashedHead
NoSquashedHead :: IncludeSquashedHead

-- | Get a project branch by id.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
getProjectBranchById :: IncludeSquashedHead -> ProjectAndBranch RemoteProjectId RemoteProjectBranchId -> Cli GetProjectBranchResponse

-- | Get a project branch by name.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
getProjectBranchByName :: IncludeSquashedHead -> ProjectAndBranch RemoteProjectId ProjectBranchName -> Cli GetProjectBranchResponse

-- | Variant of <a>getProjectBranchByName</a> that returns servant client
--   errors.
getProjectBranchByName' :: IncludeSquashedHead -> ProjectAndBranch RemoteProjectId ProjectBranchName -> Cli (Either ClientError GetProjectBranchResponse)

-- | Create a new project branch.
--   
--   On success, update the <tt>remote_project_branch</tt> table.
createProjectBranch :: CreateProjectBranchRequest -> Cli (Maybe RemoteProjectBranch)
data SetProjectBranchHeadResponse
SetProjectBranchHeadResponseNotFound :: SetProjectBranchHeadResponse

-- | (expected, actual)
SetProjectBranchHeadResponseExpectedCausalHashMismatch :: !Hash32 -> !Hash32 -> SetProjectBranchHeadResponse
SetProjectBranchHeadResponsePublishedReleaseIsImmutable :: SetProjectBranchHeadResponse
SetProjectBranchHeadResponseDeprecatedReleaseIsImmutable :: SetProjectBranchHeadResponse
SetProjectBranchHeadResponseSuccess :: SetProjectBranchHeadResponse

-- | Set a project branch head (can be a fast-forward or force-push).
setProjectBranchHead :: SetProjectBranchHeadRequest -> Cli SetProjectBranchHeadResponse
hardCodedBaseUrl :: BaseUrl
hardCodedUri :: URI
instance GHC.Classes.Eq Unison.Cli.Share.Projects.IncludeSquashedHead
instance GHC.Show.Show Unison.Cli.Share.Projects.IncludeSquashedHead
instance GHC.Generics.Generic Unison.Cli.Share.Projects.SetProjectBranchHeadResponse
instance GHC.Show.Show Unison.Cli.Share.Projects.SetProjectBranchHeadResponse
instance GHC.Classes.Eq Unison.Cli.Share.Projects.SetProjectBranchHeadResponse


-- | This module contains miscellaneous helper utils for rote actions in
--   the Cli monad, like resolving a relative path to an absolute path, per
--   the current path.
module Unison.Cli.MonadUtils

-- | Get the current path relative to the current project.
getCurrentPath :: Cli Absolute
getCurrentProjectName :: Cli ProjectName
getCurrentProjectBranchName :: Cli ProjectBranchName
getCurrentProjectPath :: Cli ProjectPath

-- | Resolve a <tt>Path</tt> (interpreted as relative) to a
--   <tt>Path.Absolute</tt>, per the current path.
resolvePath :: Path -> Cli ProjectPath

-- | Resolve a <tt>Path'</tt> to a <tt>Path.Absolute</tt>, per the current
--   path.
resolvePath' :: Path' -> Cli ProjectPath
resolvePath'ToAbsolute :: Path' -> Cli Absolute

-- | Resolve a path split, per the current path.
resolveSplit' :: (Path', a) -> Cli (ProjectPath, a)
getCurrentProjectAndBranch :: Cli (ProjectAndBranch Project ProjectBranch)
getCurrentProjectBranch :: Cli ProjectBranch

-- | Resolve an <tt>AbsBranchId</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found. (Non-existent
--   branches by path are OK - the empty branch will be returned).
resolveAbsBranchId :: AbsBranchId -> Cli (Branch IO)

-- | V2 version of <tt>resolveAbsBranchId2</tt>.
resolveAbsBranchIdV2 :: (forall void. Output -> Transaction void) -> ProjectAndBranch Project ProjectBranch -> AbsBranchId -> Transaction (Branch Transaction)

-- | Resolve a <tt>BranchId</tt> to the corresponding <tt>Branch IO</tt>,
--   or fail if no such branch hash is found. (Non-existent branches by
--   path are OK - the empty branch will be returned).
resolveBranchId :: BranchId -> Cli (Branch IO)

-- | Resolve a <tt>BranchId</tt> to an <tt>AbsBranchId</tt>.
resolveBranchIdToAbsBranchId :: BranchId -> Cli AbsBranchId

-- | Resolve a <tt>ShortCausalHash</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found.
resolveShortCausalHash :: ShortCausalHash -> Cli (Branch IO)

-- | Get the root branch.
getCurrentProjectRoot :: Cli (Branch IO)

-- | Get the root branch0.
getCurrentProjectRoot0 :: Cli (Branch0 IO)

-- | Get the current branch.
getCurrentBranch :: Cli (Branch IO)

-- | Get the current branch0.
getCurrentBranch0 :: Cli (Branch0 IO)
getProjectBranchRoot :: ProjectBranch -> Cli (Branch IO)

-- | Get the branch at an absolute path from the project root.
getBranchFromProjectPath :: ProjectPath -> Cli (Branch IO)

-- | Get the branch0 at an absolute path.
getBranch0FromProjectPath :: ProjectPath -> Cli (Branch0 IO)

-- | Get the maybe-branch at an absolute path.
getMaybeBranchFromProjectPath :: ProjectPath -> Cli (Maybe (Branch IO))

-- | Get the maybe-branch0 at an absolute path.
getMaybeBranch0FromProjectPath :: ProjectPath -> Cli (Maybe (Branch0 IO))

-- | Get the branch at a relative path, or return early if there's no such
--   branch.
expectBranchAtPath :: Path -> Cli (Branch IO)

-- | Get the branch at an absolute or relative path, or return early if
--   there's no such branch.
expectBranchAtPath' :: Path' -> Cli (Branch IO)

-- | Get the branch0 at a relative path, or return early if there's no such
--   branch.
expectBranch0AtPath :: Path -> Cli (Branch0 IO)

-- | Get the branch0 at an absolute or relative path, or return early if
--   there's no such branch.
expectBranch0AtPath' :: Path' -> Cli (Branch0 IO)

-- | Assert that there's "no branch" at an absolute or relative path, or
--   return early if there is one, where "no branch" means either there's
--   actually no branch, or there is a branch whose head is empty (i.e. it
--   may have a history, but no current terms/types etc).
assertNoBranchAtPath' :: Path' -> Cli ()

-- | Check if there's a branch at an absolute or relative path
--   
--   "no branch" means either there's actually no branch, or there is a
--   branch whose head is empty (i.e. it may have a history, but no current
--   terms/types etc).
branchExistsAtPath' :: Path' -> Cli Bool
stepAt' :: Text -> (ProjectPath, Branch0 IO -> Cli (Branch0 IO)) -> Cli Bool
stepAt :: Text -> (ProjectPath, Branch0 IO -> Branch0 IO) -> Cli ()
stepAtM :: Text -> (ProjectPath, Branch0 IO -> IO (Branch0 IO)) -> Cli ()
stepManyAt :: ProjectBranch -> Text -> [(Absolute, Branch0 IO -> Branch0 IO)] -> Cli ()
stepManyAtM :: ProjectBranch -> Text -> [(Absolute, Branch0 IO -> IO (Branch0 IO))] -> Cli ()
updateProjectBranchRoot :: ProjectBranch -> Text -> (Branch IO -> Cli (Branch IO, r)) -> Cli r
updateProjectBranchRoot_ :: ProjectBranch -> Text -> (Branch IO -> Branch IO) -> Cli ()

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAtM :: Text -> ProjectPath -> (Branch IO -> Cli (Branch IO)) -> Cli Bool

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAt :: Text -> ProjectPath -> (Branch IO -> Branch IO) -> Cli Bool
updateAndStepAt :: (Foldable f, Foldable g, Functor g) => Text -> ProjectBranch -> f (Absolute, Branch IO -> Branch IO) -> g (Absolute, Branch0 IO -> Branch0 IO) -> Cli ()
getTermsAt :: (ProjectPath, HQSegment) -> Cli (Set Referent)
getTypesAt :: (ProjectPath, HQSegment) -> Cli (Set TypeReference)

-- | The default patch path.
defaultPatchPath :: Split'

-- | Get the patch at a path, or the empty patch if there's no such patch.
getPatchAt :: Split' -> Cli Patch
getLatestFile :: Cli (Maybe (FilePath, Bool))

-- | Get the latest parsed unison file.
getLatestParsedFile :: Cli (Maybe (UnisonFile Symbol Ann))

-- | Gets the names from the latest typechecked unison file, or latest
--   parsed file if it didn't typecheck.
getNamesFromLatestFile :: Cli Names

-- | Returns a parsed term (potentially with free variables) from the
--   latest file. This term will refer to other terms in the file by vars,
--   not by hash. Used to implement rewriting and other refactorings on the
--   current file.
getTermFromLatestParsedFile :: HashQualified Name -> Cli (Maybe (Term Symbol Ann))
expectLatestFile :: Cli (FilePath, Bool)
expectLatestParsedFile :: Cli (UnisonFile Symbol Ann)

-- | Get the latest typechecked unison file.
getLatestTypecheckedFile :: Cli (Maybe (TypecheckedUnisonFile Symbol Ann))

-- | Get the latest typechecked unison file, or return early if there isn't
--   one.
expectLatestTypecheckedFile :: Cli (TypecheckedUnisonFile Symbol Ann)
makeParsingEnv :: ProjectPath -> Names -> Cli (ParsingEnv Transaction)


-- | <tt>update</tt> input handler.
module Unison.Codebase.Editor.HandleInput.Update2
handleUpdate2 :: Cli ()
typecheckedUnisonFileToBranchUpdates :: (forall void. Output -> Transaction void) -> (Name -> Either Output (Maybe [Name])) -> TypecheckedUnisonFile Symbol Ann -> Transaction [(Path, Branch0 m -> Branch0 m)]

module Unison.Codebase.Editor.HandleInput.UI
openUI :: Path' -> Cli ()


-- | <tt>project.rename</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectRename
handleProjectRename :: ProjectName -> Cli ()

module Unison.Codebase.Editor.HandleInput.MoveType
doMoveType :: (Path', HQSegment) -> (Path', NameSegment) -> Text -> Cli ()
moveTypeSteps :: (Path', HQSegment) -> (Path', NameSegment) -> Cli [(Absolute, Branch0 m -> Branch0 m)]

module Unison.Codebase.Editor.HandleInput.MoveTerm
doMoveTerm :: (Path', HQSegment) -> (Path', NameSegment) -> Text -> Cli ()
moveTermSteps :: (Path', HQSegment) -> (Path', NameSegment) -> Cli [(Absolute, Branch0 m -> Branch0 m)]

module Unison.Codebase.Editor.HandleInput.MoveBranch

-- | Moves a branch and its history from one location to another, and saves
--   the new root branch.
doMoveBranch :: Text -> Bool -> Path' -> Path' -> Cli ()

-- | Note: Currently only allows moving within the same project-branch,
--   should be easy to change in the future if needed.
moveBranchFunc :: Bool -> Path' -> Path' -> Cli (Maybe (Absolute, Branch IO -> Branch IO))

module Unison.Codebase.Editor.HandleInput.MoveAll
handleMoveAll :: Bool -> Path' -> Path' -> Text -> Cli ()

module Unison.Codebase.Editor.HandleInput.FindAndReplace
handleStructuredFindReplaceI :: HashQualified Name -> Cli ()
handleStructuredFindI :: HashQualified Name -> Cli ()
handleTextFindI :: Bool -> [String] -> Cli ()


-- | <tt>delete.project</tt> input handler
module Unison.Codebase.Editor.HandleInput.DeleteProject

-- | Delete a project
handleDeleteProject :: ProjectName -> Cli ()


-- | <tt>debug.synhash.term</tt> input handler.
module Unison.Codebase.Editor.HandleInput.DebugSynhashTerm
handleDebugSynhashTerm :: Name -> Cli ()

module Unison.Codebase.Editor.HandleInput.DebugFoldRanges
debugFoldRanges :: Cli ()


-- | <tt>branches</tt> input handler
module Unison.Codebase.Editor.HandleInput.Branches
handleBranches :: Maybe ProjectName -> Cli ()


-- | <tt>branch.rename</tt> input handler
module Unison.Codebase.Editor.HandleInput.BranchRename
handleBranchRename :: ProjectBranchName -> Cli ()


-- | Project-related utilities.
module Unison.Cli.ProjectUtils
expectProjectBranchByName :: Project -> ProjectBranchName -> Cli ProjectBranch
resolveBranchRelativePath :: BranchRelativePath -> Cli ProjectPath

-- | Expect/resolve branch reference with the following rules:
--   
--   <ol>
--   <li>If the project is missing, use the current project.</li>
--   <li>If we have an unambiguous `<i>branch` or `project</i>branch`,
--   resolve it using the current project, defaulting to <tt>main</tt> if
--   branch is unspecified.</li>
--   </ol>
resolveProjectBranch :: ProjectAndBranch (Maybe ProjectName) (Maybe ProjectBranchName) -> Cli (ProjectAndBranch Project ProjectBranch)

-- | Expect/resolve branch reference with the following rules:
--   
--   <ol>
--   <li>If the project is missing, use the provided project.</li>
--   <li>If we have an unambiguous `<i>branch` or `project</i>branch`,
--   resolve it using the provided project, defaulting to <tt>main</tt> if
--   branch is unspecified.</li>
--   </ol>
resolveProjectBranchInProject :: Project -> ProjectAndBranch (Maybe ProjectName) (Maybe ProjectBranchName) -> Cli (ProjectAndBranch Project ProjectBranch)
hydrateNames :: These ProjectName ProjectBranchName -> Cli (ProjectAndBranch ProjectName ProjectBranchName)
expectProjectAndBranchByIds :: ProjectAndBranch ProjectId ProjectBranchId -> Transaction (ProjectAndBranch Project ProjectBranch)
getProjectAndBranchByTheseNames :: These ProjectName ProjectBranchName -> Cli (Maybe (ProjectAndBranch Project ProjectBranch))
getProjectAndBranchByNames :: ProjectAndBranch ProjectName ProjectBranchName -> Transaction (Maybe (ProjectAndBranch Project ProjectBranch))
expectProjectAndBranchByTheseNames :: These ProjectName ProjectBranchName -> Cli (ProjectAndBranch Project ProjectBranch)

-- | Get the causal hash of a project branch.
getProjectBranchCausalHash :: ProjectBranch -> Transaction CausalHash

-- | Expect a remote project by id. Its latest-known name is also provided,
--   for error messages.
expectRemoteProjectById :: RemoteProjectId -> ProjectName -> Cli RemoteProject
expectRemoteProjectByName :: ProjectName -> Cli RemoteProject
expectRemoteProjectBranchById :: IncludeSquashedHead -> ProjectAndBranch (RemoteProjectId, ProjectName) (RemoteProjectBranchId, ProjectBranchName) -> Cli RemoteProjectBranch
loadRemoteProjectBranchByName :: IncludeSquashedHead -> ProjectAndBranch RemoteProjectId ProjectBranchName -> Cli (Maybe RemoteProjectBranch)
expectRemoteProjectBranchByName :: IncludeSquashedHead -> ProjectAndBranch (RemoteProjectId, ProjectName) ProjectBranchName -> Cli RemoteProjectBranch
loadRemoteProjectBranchByNames :: IncludeSquashedHead -> ProjectAndBranch ProjectName ProjectBranchName -> Cli (Maybe RemoteProjectBranch)
expectRemoteProjectBranchByNames :: IncludeSquashedHead -> ProjectAndBranch ProjectName ProjectBranchName -> Cli RemoteProjectBranch
expectRemoteProjectBranchByTheseNames :: IncludeSquashedHead -> These ProjectName ProjectBranchName -> Cli RemoteProjectBranch
justTheIds :: ProjectAndBranch Project ProjectBranch -> ProjectAndBranch ProjectId ProjectBranchId
justTheIds' :: ProjectBranch -> ProjectAndBranch ProjectId ProjectBranchId
justTheNames :: ProjectAndBranch Project ProjectBranch -> ProjectAndBranch ProjectName ProjectBranchName
findTemporaryBranchName :: ProjectId -> ProjectBranchName -> Transaction ProjectBranchName

-- | Expect the given remote project to have a latest release, and return
--   it as a valid branch name.
expectLatestReleaseBranchName :: RemoteProject -> Cli ProjectBranchName

-- | <tt>getMergeBranchParent branch</tt> returns the parent branch of a
--   "merge" branch.
--   
--   When a merge fails, we put you on a branch called
--   `merge-<a>source</a>-into-<a>target</a>`. That's a "merge" branch.
--   It's not currently distinguished in the database, so we first just
--   switch on whether its name begins with "merge-". If it does, then we
--   get the branch's parent, which should exist, but perhaps wouldn't if
--   the user had manually made a parentless branch called "merge-whatever"
--   for whatever reason.
getMergeBranchParent :: ProjectBranch -> Maybe ProjectBranchId

-- | <tt>getUpgradeBranchParent branch</tt> returns the parent branch of an
--   "upgrade" branch.
--   
--   When an upgrade fails, we put you on a branch called
--   `upgrade-<a>old</a>-to-<a>new</a>`. That's an "upgrade" branch. It's
--   not currently distinguished in the database, so we first just switch
--   on whether its name begins with "upgrade-". If it does, then we get
--   the branch's parent, which should exist, but perhaps wouldn't if the
--   user had manually made a parentless branch called "upgrade-whatever"
--   for whatever reason.
getUpgradeBranchParent :: ProjectBranch -> Maybe ProjectBranchId


-- | Helpers for working with various kinds of reflogs.
module Unison.Codebase.Editor.HandleInput.Reflogs
showProjectBranchReflog :: Maybe (ProjectAndBranch (Maybe ProjectName) ProjectBranchName) -> Cli ()
showProjectReflog :: Maybe ProjectName -> Cli ()
showGlobalReflog :: Cli ()


-- | <tt>push</tt> input handler
module Unison.Codebase.Editor.HandleInput.Push

-- | Handle a <tt>push</tt> command.
handlePushRemoteBranch :: PushRemoteBranchInput -> Cli ()


-- | <tt>switch</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectSwitch

-- | Switch to an existing project or project branch, with a flexible
--   syntax that does not require prefixing branch names with forward
--   slashes (though doing so makes the command unambiguous).
--   
--   When the argument is ambiguous, when outside of a project, "switch
--   foo" means switch to project "foo", not branch "foo" (since there is
--   no current project). And when inside a project, "switch foo" means one
--   of:
--   
--   <ol>
--   <li>Switch to project "foo", since there isn't a branch "foo" in the
--   current project</li>
--   <li>Switch to branch "foo", since there isn't a project "foo"</li>
--   <li>Complain, because there's both a project "foo" and a branch "foo"
--   in the current project</li>
--   </ol>
projectSwitch :: ProjectAndBranchNames -> Cli ()


-- | <tt>branch</tt> input handler
module Unison.Codebase.Editor.HandleInput.Branch
data CreateFrom
CreateFrom'NamespaceWithParent :: ProjectBranch -> Branch IO -> CreateFrom
CreateFrom'ParentBranch :: ProjectBranch -> CreateFrom
CreateFrom'Namespace :: Branch IO -> CreateFrom
CreateFrom'Nothingness :: CreateFrom

-- | Create a new project branch from an existing project branch or
--   namespace.
handleBranch :: BranchSourceI -> ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Cli ()

-- | <tt>createBranch description createFrom project getNewBranchName</tt>:
--   
--   <ol>
--   <li>Creates a new branch row in <tt>project</tt> at the name from
--   <tt>getNewBranchName</tt> (failing if branch already exists in
--   <tt>project</tt>).</li>
--   <li>Switches to the new branch.</li>
--   </ol>
--   
--   This bit of functionality is factored out from the main
--   <a>handleBranch</a> handler because it is also called by the
--   <tt>release.draft</tt> command, which essentially just creates a
--   branch, but with some different output for the user.
--   
--   Returns the branch id and name of the newly-created branch.
createBranch :: Text -> CreateFrom -> Project -> Transaction ProjectBranchName -> Cli (ProjectBranchId, ProjectBranchName)


-- | <tt>upgrade</tt> input handler.
module Unison.Codebase.Editor.HandleInput.Upgrade
handleUpgrade :: NameSegment -> NameSegment -> Cli ()


-- | <tt>release.draft</tt> input handler
module Unison.Codebase.Editor.HandleInput.ReleaseDraft

-- | Handle a <tt>release.draft</tt> command.
handleReleaseDraft :: Semver -> Cli ()


-- | <tt>merge</tt> input handler.
module Unison.Codebase.Editor.HandleInput.Merge2
handleMerge :: ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Cli ()
data MergeInfo
MergeInfo :: !AliceMergeInfo -> !BobMergeInfo -> !LcaMergeInfo -> !Text -> MergeInfo
[$sel:alice:MergeInfo] :: MergeInfo -> !AliceMergeInfo
[$sel:bob:MergeInfo] :: MergeInfo -> !BobMergeInfo
[$sel:lca:MergeInfo] :: MergeInfo -> !LcaMergeInfo

-- | How should we describe this merge in the reflog?
[$sel:description:MergeInfo] :: MergeInfo -> !Text
data AliceMergeInfo
AliceMergeInfo :: !CausalHash -> !ProjectAndBranch Project ProjectBranch -> AliceMergeInfo
[$sel:causalHash:AliceMergeInfo] :: AliceMergeInfo -> !CausalHash
[$sel:projectAndBranch:AliceMergeInfo] :: AliceMergeInfo -> !ProjectAndBranch Project ProjectBranch
data BobMergeInfo
BobMergeInfo :: !CausalHash -> !MergeSource -> BobMergeInfo
[$sel:causalHash:BobMergeInfo] :: BobMergeInfo -> !CausalHash
[$sel:source:BobMergeInfo] :: BobMergeInfo -> !MergeSource
newtype LcaMergeInfo
LcaMergeInfo :: Maybe CausalHash -> LcaMergeInfo
[$sel:causalHash:LcaMergeInfo] :: LcaMergeInfo -> Maybe CausalHash
doMerge :: MergeInfo -> Cli ()
doMergeLocalBranch :: TwoWay (ProjectAndBranch Project ProjectBranch) -> Cli ()
hasDefnsInLib :: Applicative m => Branch m -> m Bool


-- | <tt>todo</tt> input handler
module Unison.Codebase.Editor.HandleInput.Todo
handleTodo :: Cli ()


-- | Utilities that have to do with constructing names objects.
module Unison.Cli.NamesUtils

-- | Produce a <a>Names</a> object which contains names for the current
--   branch.
currentNames :: Cli Names
currentProjectRootNames :: Cli Names
projectBranchNames :: ProjectBranch -> Cli Names

module Unison.Codebase.Editor.HandleInput.Update

-- | Handle an <tt>update</tt> command.
handleUpdate :: Input -> OptionalPatch -> Set Name -> Cli ()
doSlurpAdds :: forall m. Monad m => SlurpComponent -> TypecheckedUnisonFile Symbol Ann -> Branch0 m -> Branch0 m

module Unison.Codebase.Editor.HandleInput.Tests

-- | Handle a <tt>test</tt> command. Run pure tests in the current
--   subnamespace.
handleTest :: TestInput -> Cli ()
handleIOTest :: HashQualified Name -> Cli ()
handleAllIOTests :: Cli ()
isTestOk :: Term v Ann -> Bool

module Unison.Codebase.Editor.HandleInput.TermResolution
lookupTermRefs :: HashQualified Name -> Names -> ([Reference], [Referent])
lookupTermRefWithType :: Codebase IO Symbol Ann -> HashQualified Name -> Cli [(Reference, Type Symbol Ann)]
resolveCon :: HashQualified Name -> Cli ConstructorReference
resolveTerm :: HashQualified Name -> Cli Referent
resolveTermRef :: HashQualified Name -> Cli Reference
resolveMainRef :: HashQualified Name -> Cli (Reference, PrettyPrintEnv)

module Unison.Codebase.Editor.HandleInput.ShowDefinition

-- | Handle a <tt>ShowDefinitionI</tt> input command, i.e. <a>view</a> or
--   <tt>edit</tt>.
handleShowDefinition :: OutputLocation -> ShowDefinitionScope -> NonEmpty (HashQualified Name) -> Cli ()

-- | Show the provided definitions to console or scratch file. The caller
--   is responsible for ensuring that the definitions include cycles if
--   that's the desired behavior.
showDefinitions :: OutputLocation -> PrettyPrintEnvDecl -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Map Reference (DisplayObject () (Decl Symbol Ann)) -> [HashQualified Name] -> Cli ()

module Unison.Codebase.Editor.HandleInput.EditNamespace
handleEditNamespace :: OutputLocation -> [Path] -> Cli ()


-- | Helpers/utils that have to do with namespace diffs.
module Unison.Codebase.Editor.HandleInput.NamespaceDiffUtils
diffHelper :: Branch0 IO -> Branch0 IO -> Cli (PrettyPrintEnv, BranchDiffOutput Symbol Ann)

module Unison.Codebase.Editor.HandleInput.NamespaceDependencies
handleNamespaceDependencies :: Maybe Path' -> Cli ()

module Unison.Codebase.Editor.HandleInput.Ls
handleLs :: Path' -> Cli ()

module Unison.Codebase.Editor.HandleInput.Load
handleLoad :: Maybe FilePath -> Cli ()
loadUnisonFile :: Text -> Text -> Cli ()
data EvalMode
Sandboxed :: EvalMode
Permissive :: EvalMode
Native :: EvalMode

-- | Evaluate all watched expressions in a UnisonFile and return their
--   results, keyed by the name of the watch variable. The tuple returned
--   has the form: (hash, (ann, sourceTerm, evaluatedTerm, isCacheHit))
--   
--   where <tt>hash</tt> is the hash of the original watch expression
--   definition <tt>ann</tt> gives the location of the watch expression
--   <tt>sourceTerm</tt> is a closed term (no free vars) for the watch
--   expression <tt>evaluatedTerm</tt> is the result of evaluating that
--   <tt>sourceTerm</tt> <tt>isCacheHit</tt> is True if the result was
--   computed by just looking up in a cache
--   
--   It's expected that the user of this action might add the `(hash,
--   evaluatedTerm)` mapping to a cache to make future evaluations of the
--   same watches instantaneous.
evalUnisonFile :: EvalMode -> PrettyPrintEnv -> TypecheckedUnisonFile Symbol Ann -> [String] -> Cli ([(Symbol, Term Symbol ())], Map Symbol (Ann, WatchKind, Id, Term Symbol (), Term Symbol (), Bool))

module Unison.Codebase.Editor.HandleInput.Run
handleRun :: Bool -> HashQualified Name -> [String] -> Cli ()

module Unison.Codebase.Editor.HandleInput.LSPDebug
debugLspNameCompletion :: Text -> Cli ()

module Unison.Codebase.Editor.HandleInput.DebugDefinition
debugTerm :: Bool -> HashQualified Name -> Cli ()
debugDecl :: HashQualified Name -> Cli ()

module Unison.Codebase.Editor.HandleInput.AddRun
handleAddRun :: Input -> Name -> Cli ()


-- | Utility functions for downloading remote entities and storing them
--   locally in SQLite.
--   
--   These are shared by commands like <tt>pull</tt> and <tt>clone</tt>.
module Unison.Cli.DownloadUtils

-- | Download a project/branch from Share.
downloadProjectBranchFromShare :: HasCallStack => IncludeSquashedHead -> RemoteProjectBranch -> Cli (Either ShareError CausalHash)

-- | Download loose code from Share.
downloadLooseCodeFromShare :: ReadShareLooseCode -> Cli (Either ShareError CausalHash)


-- | <tt>pull</tt> input handler
module Unison.Codebase.Editor.HandleInput.Pull
handlePull :: PullSourceTarget -> PullMode -> Cli ()
loadPropagateDiffDefaultPatch :: Text -> Maybe (Either ProjectPath (ProjectAndBranch Project ProjectBranch)) -> ProjectPath -> Cli ()

-- | supply <tt>dest0</tt> if you want to print diff messages supply
--   unchangedMessage if you want to display it if merge had no effect
mergeBranchAndPropagateDefaultPatch :: MergeMode -> Text -> Maybe Output -> Branch IO -> Maybe (Either ProjectPath (ProjectAndBranch Project ProjectBranch)) -> ProjectPath -> Cli ()
propagatePatch :: Text -> Patch -> ProjectPath -> Cli Bool


-- | <tt>project.create</tt> input handler
module Unison.Codebase.Editor.HandleInput.ProjectCreate

-- | Create a new project.
--   
--   <ol>
--   <li>If a project already exists with the given name, bail.</li>
--   <li>Otherwise, create a scaffold out a new project with a "main"
--   branch, and add it to the namespace (at a magic location that the user
--   isn't supposed to look at).</li>
--   </ol>
--   
--   Big danger: we first commit the project identity and metadata (like
--   its name) to the codebase, then manipulate our in-memory namespace and
--   flush its contents out in a separate transaction. This means that if
--   lightning strikes at the wrong time, we'll be in an inconsistent
--   state.
--   
--   This could be fixed in a few different ways:
--   
--   <ol>
--   <li>Make a better <tt>stepAt</tt> helper that can mutate the namespace
--   in a transaction.</li>
--   <li>Add more code to detect the inconsistency and work around it. For
--   example, if we ever see that a project id exists in the codebase but
--   not at its corresponding place in the namespace, we could consider it
--   garbage and delete it. Then, any user who tried to create a project
--   called "foo" shortly before getting hit by lightning could simply try
--   creating "foo" again later.</li>
--   <li>Don't store projects in the root namespace at all. We don't even
--   want them there, it's just a little too convenient because *not*
--   storing them in the root namespace would require a lot of reworking
--   and rewriting. We'd rather hit some shorter-term project milestones
--   and clean our mess up Later (TM).</li>
--   </ol>
--   
--   For now, it doesn't seem worth it to do (1) or (2), since we want to
--   do (3) eventually, and we'd rather not waste too much time getting
--   everything perfectly correct before we get there.
projectCreate :: Bool -> Maybe ProjectName -> Cli (ProjectAndBranch ProjectId ProjectBranchId)


-- | <tt>delete.branch</tt> input handler
module Unison.Codebase.Editor.HandleInput.DeleteBranch

-- | Delete a project branch.
--   
--   Currently, deleting a branch means deleting its
--   <tt>project_branch</tt> row, then deleting its contents from the
--   namespace. Its children branches, if any, are reparented to their
--   grandparent, if any. You may delete the only branch in a project.
handleDeleteBranch :: ProjectAndBranch (Maybe ProjectName) ProjectBranchName -> Cli ()

-- | Delete a project branch and record an entry in the reflog.
doDeleteProjectBranch :: HasCallStack => ProjectAndBranch Project ProjectBranch -> Cli ()


-- | <tt>upgrade.commit</tt> handler.
module Unison.Codebase.Editor.HandleInput.CommitUpgrade
handleCommitUpgrade :: Cli ()


-- | <tt>merge.commit</tt> handler.
module Unison.Codebase.Editor.HandleInput.CommitMerge
handleCommitMerge :: Cli ()


-- | <tt>clone</tt>-related input handlers
module Unison.Codebase.Editor.HandleInput.ProjectClone

-- | Clone a remote branch.
handleClone :: ProjectAndBranchNames -> Maybe ProjectAndBranchNames -> Cli ()
instance GHC.Generics.Generic Unison.Codebase.Editor.HandleInput.ProjectClone.ResolvedRemoteNames


-- | <tt>lib.install</tt> input handler
module Unison.Codebase.Editor.HandleInput.InstallLib
handleInstallLib :: Bool -> ProjectAndBranch ProjectName (Maybe ProjectBranchNameOrLatestRelease) -> Cli ()

module Unison.Codebase.Editor.HandleInput
loop :: Either Event Input -> Cli ()

module Unison.CommandLine.Main
main :: FilePath -> Welcome -> ProjectPathIds -> [Either Event Input] -> Runtime Symbol -> Runtime Symbol -> Runtime Symbol -> Codebase IO Symbol Ann -> Maybe BaseUrl -> UCMVersion -> (ProjectPathIds -> IO ()) -> ShouldWatchFiles -> IO ()


-- | Execute transcripts.
module Unison.Codebase.Transcript.Runner
data Error
ParseError :: ParseErrorBundle Text Void -> Error
RunFailure :: Text -> Error
type Runner = String -> Text -> (FilePath, Codebase IO Symbol Ann) -> IO (Either Error Text)
withRunner :: forall m r. MonadUnliftIO m => Bool -> Verbosity -> UCMVersion -> FilePath -> (Runner -> m r) -> m r
instance GHC.Exception.Type.Exception Unison.Codebase.Transcript.Runner.Error
instance GHC.Show.Show Unison.Codebase.Transcript.Runner.Error

module Unison.Version
data Version
Version :: Text -> (GitRef, CommitDate) -> Version
[$sel:gitDescribeWithDate:Version] :: Version -> Text
[$sel:gitDescribe:Version] :: Version -> (GitRef, CommitDate)
type CommitDate = Text
type GitRef = Text

module Unison.Main
main :: Version -> IO ()
