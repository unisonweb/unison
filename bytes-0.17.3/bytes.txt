-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sharing code for serialization between binary and cereal
--   
--   Sharing code for serialization between binary and cereal.
@package bytes
@version 0.17.3


-- | This module generalizes the <tt>binary</tt> <a>Get</a> and
--   <tt>cereal</tt> <a>Get</a> monads in an ad hoc fashion to permit code
--   to be written that is compatible across them.
--   
--   Moreover, this class permits code to be written to be portable over
--   various monad transformers applied to these as base monads.
module Data.Bytes.Get
class (forall a b. Coercible a b => Coercible (m a) (m b), Integral (Remaining m), MonadFail m, Applicative m) => MonadGet m where {
    
    -- | An <a>Integral</a> number type used for unchecked skips and counting.
    type Remaining m :: *;
    
    -- | The underlying ByteString type used by this instance
    type Bytes m :: *;
}

-- | Skip ahead <tt>n</tt> bytes. Fails if fewer than <tt>n</tt> bytes are
--   available.
skip :: MonadGet m => Int -> m ()

-- | Skip ahead <tt>n</tt> bytes. Fails if fewer than <tt>n</tt> bytes are
--   available.
skip :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => Int -> m ()

-- | If at least <tt>n</tt> bytes are available return at least that much
--   of the current input. Otherwise fail.
ensure :: MonadGet m => Int -> m ByteString

-- | If at least <tt>n</tt> bytes are available return at least that much
--   of the current input. Otherwise fail.
ensure :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => Int -> m ByteString

-- | Run <tt>ga</tt>, but return without consuming its input. Fails if
--   <tt>ga</tt> fails.
lookAhead :: MonadGet m => m a -> m a

-- | Like <a>lookAhead</a>, but consume the input if <tt>gma</tt> returns
--   'Just _'. Fails if <tt>gma</tt> fails.
lookAheadM :: MonadGet m => m (Maybe a) -> m (Maybe a)

-- | Like <a>lookAhead</a>, but consume the input if <tt>gea</tt> returns
--   'Right _'. Fails if <tt>gea</tt> fails.
lookAheadE :: MonadGet m => m (Either a b) -> m (Either a b)

-- | Pull <tt>n</tt> bytes from the input, as a strict ByteString.
getBytes :: MonadGet m => Int -> m ByteString

-- | Pull <tt>n</tt> bytes from the input, as a strict ByteString.
getBytes :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => Int -> m ByteString

-- | Get the number of remaining unparsed bytes. Useful for checking
--   whether all input has been consumed. Note that this forces the rest of
--   the input.
remaining :: MonadGet m => m (Remaining m)

-- | Get the number of remaining unparsed bytes. Useful for checking
--   whether all input has been consumed. Note that this forces the rest of
--   the input.
remaining :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n, Remaining m ~ Remaining n) => m (Remaining m)

-- | Test whether all input has been consumed, i.e. there are no remaining
--   unparsed bytes.
isEmpty :: MonadGet m => m Bool

-- | Test whether all input has been consumed, i.e. there are no remaining
--   unparsed bytes.
isEmpty :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Bool

-- | Read a Word8 from the monad state
getWord8 :: MonadGet m => m Word8

-- | Read a Word8 from the monad state
getWord8 :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word8

-- | An efficient <a>get</a> method for strict ByteStrings. Fails if fewer
--   than <tt>n</tt> bytes are left in the input.
getByteString :: MonadGet m => Int -> m ByteString

-- | An efficient <a>get</a> method for strict ByteStrings. Fails if fewer
--   than <tt>n</tt> bytes are left in the input.
getByteString :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => Int -> m ByteString

-- | An efficient <a>get</a> method for lazy ByteStrings. Does not fail if
--   fewer than <tt>n</tt> bytes are left in the input.
getLazyByteString :: MonadGet m => Int64 -> m ByteString

-- | An efficient <a>get</a> method for lazy ByteStrings. Does not fail if
--   fewer than <tt>n</tt> bytes are left in the input.
getLazyByteString :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => Int64 -> m ByteString

-- | Read a <a>Word16</a> in big endian format
getWord16be :: MonadGet m => m Word16

-- | Read a <a>Word16</a> in big endian format
getWord16be :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word16

-- | Read a <a>Word16</a> in little endian format
getWord16le :: MonadGet m => m Word16

-- | Read a <a>Word16</a> in little endian format
getWord16le :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word16

-- | <i>O(1).</i> Read a 2 byte <a>Word16</a> in native host order and host
--   endianness.
getWord16host :: MonadGet m => m Word16

-- | <i>O(1).</i> Read a 2 byte <a>Word16</a> in native host order and host
--   endianness.
getWord16host :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word16

-- | Read a <a>Word32</a> in big endian format
getWord32be :: MonadGet m => m Word32

-- | Read a <a>Word32</a> in big endian format
getWord32be :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word32

-- | Read a <a>Word32</a> in little endian format
getWord32le :: MonadGet m => m Word32

-- | Read a <a>Word32</a> in little endian format
getWord32le :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word32

-- | <i>O(1).</i> Read a <a>Word32</a> in native host order and host
--   endianness.
getWord32host :: MonadGet m => m Word32

-- | <i>O(1).</i> Read a <a>Word32</a> in native host order and host
--   endianness.
getWord32host :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word32

-- | Read a <a>Word64</a> in big endian format
getWord64be :: MonadGet m => m Word64

-- | Read a <a>Word64</a> in big endian format
getWord64be :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word64

-- | Read a <a>Word64</a> in little endian format
getWord64le :: MonadGet m => m Word64

-- | Read a <a>Word64</a> in little endian format
getWord64le :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word64

-- | <i>O(1).</i> Read a <a>Word64</a> in native host order and host
--   endianness.
getWord64host :: MonadGet m => m Word64

-- | <i>O(1).</i> Read a <a>Word64</a> in native host order and host
--   endianness.
getWord64host :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word64

-- | <i>O(1).</i> Read a single native machine word. The word is read in
--   host order, host endian form, for the machine you're on. On a 64 bit
--   machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.
getWordhost :: MonadGet m => m Word

-- | <i>O(1).</i> Read a single native machine word. The word is read in
--   host order, host endian form, for the machine you're on. On a 64 bit
--   machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.
getWordhost :: (MonadGet m, MonadTrans t, MonadGet n, m ~ t n) => m Word

-- | Get something from a lazy <a>ByteString</a> using <a>runGet</a>.
runGetL :: Get a -> ByteString -> a

-- | Get something from a strict <a>ByteString</a> using <a>runGet</a>.
runGetS :: Get a -> ByteString -> Either String a
instance Data.Bytes.Get.MonadGet Data.Binary.Get.Internal.Get
instance Data.Bytes.Get.MonadGet Data.Serialize.Get.Get
instance Data.Bytes.Get.MonadGet m => Data.Bytes.Get.MonadGet (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Bytes.Get.MonadGet m => Data.Bytes.Get.MonadGet (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Bytes.Get.MonadGet m => Data.Bytes.Get.MonadGet (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Bytes.Get.MonadGet m, GHC.Base.Monoid w) => Data.Bytes.Get.MonadGet (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Bytes.Get.MonadGet m, GHC.Base.Monoid w) => Data.Bytes.Get.MonadGet (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Bytes.Get.MonadGet m, GHC.Base.Monoid w) => Data.Bytes.Get.MonadGet (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Data.Bytes.Get.MonadGet m, GHC.Base.Monoid w) => Data.Bytes.Get.MonadGet (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Bytes.Get.MonadGet m => Data.Bytes.Get.MonadGet (Control.Monad.Trans.Except.ExceptT e m)


-- | This module generalizes the <tt>binary</tt> <a>PutM</a> and
--   <tt>cereal</tt> <a>PutM</a> monads in an ad hoc fashion to permit code
--   to be written that is compatible across them.
--   
--   Moreover, this class permits code to be written to be portable over
--   various monad transformers applied to these as base monads.
module Data.Bytes.Put
class (Applicative m, Monad m) => MonadPut m

-- | Efficiently write a byte into the output buffer
putWord8 :: MonadPut m => Word8 -> m ()

-- | Efficiently write a byte into the output buffer
putWord8 :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word8 -> m ()

-- | An efficient primitive to write a strict <a>ByteString</a> into the
--   output buffer.
--   
--   In <tt>binary</tt> this flushes the current buffer, and writes the
--   argument into a new chunk.
putByteString :: MonadPut m => ByteString -> m ()

-- | An efficient primitive to write a strict <a>ByteString</a> into the
--   output buffer.
--   
--   In <tt>binary</tt> this flushes the current buffer, and writes the
--   argument into a new chunk.
putByteString :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => ByteString -> m ()

-- | Write a lazy <a>ByteString</a> efficiently.
--   
--   With <tt>binary</tt>, this simply appends the chunks to the output
--   buffer
putLazyByteString :: MonadPut m => ByteString -> m ()

-- | Write a lazy <a>ByteString</a> efficiently.
--   
--   With <tt>binary</tt>, this simply appends the chunks to the output
--   buffer
putLazyByteString :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => ByteString -> m ()

-- | Pop the <a>ByteString</a> we have constructed so far, if any, yielding
--   a new chunk in the result <a>ByteString</a>.
--   
--   If we're building a strict <a>ByteString</a> with <tt>cereal</tt> then
--   this does nothing.
flush :: MonadPut m => m ()

-- | Pop the <a>ByteString</a> we have constructed so far, if any, yielding
--   a new chunk in the result <a>ByteString</a>.
--   
--   If we're building a strict <a>ByteString</a> with <tt>cereal</tt> then
--   this does nothing.
flush :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => m ()

-- | Write a <a>Word16</a> in little endian format
putWord16le :: MonadPut m => Word16 -> m ()

-- | Write a <a>Word16</a> in little endian format
putWord16le :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word16 -> m ()

-- | Write a <a>Word16</a> in big endian format
putWord16be :: MonadPut m => Word16 -> m ()

-- | Write a <a>Word16</a> in big endian format
putWord16be :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word16 -> m ()

-- | <i>O(1).</i> Write a <a>Word16</a> in native host order and host
--   endianness. For portability issues see <a>putWordhost</a>.
putWord16host :: MonadPut m => Word16 -> m ()

-- | <i>O(1).</i> Write a <a>Word16</a> in native host order and host
--   endianness. For portability issues see <a>putWordhost</a>.
putWord16host :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word16 -> m ()

-- | Write a <a>Word32</a> in little endian format
putWord32le :: MonadPut m => Word32 -> m ()

-- | Write a <a>Word32</a> in little endian format
putWord32le :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word32 -> m ()

-- | Write a <a>Word32</a> in big endian format
putWord32be :: MonadPut m => Word32 -> m ()

-- | Write a <a>Word32</a> in big endian format
putWord32be :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word32 -> m ()

-- | <i>O(1).</i> Write a <a>Word32</a> in native host order and host
--   endianness. For portability issues see <tt>putWordhost</tt>.
putWord32host :: MonadPut m => Word32 -> m ()

-- | <i>O(1).</i> Write a <a>Word32</a> in native host order and host
--   endianness. For portability issues see <tt>putWordhost</tt>.
putWord32host :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word32 -> m ()

-- | Write a <a>Word64</a> in little endian format
putWord64le :: MonadPut m => Word64 -> m ()

-- | Write a <a>Word64</a> in little endian format
putWord64le :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word64 -> m ()

-- | Write a <a>Word64</a> in big endian format
putWord64be :: MonadPut m => Word64 -> m ()

-- | Write a <a>Word64</a> in big endian format
putWord64be :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word64 -> m ()

-- | <i>O(1).</i> Write a <a>Word64</a> in native host order and host
--   endianness. For portability issues see <tt>putWordhost</tt>.
putWord64host :: MonadPut m => Word64 -> m ()

-- | <i>O(1).</i> Write a <a>Word64</a> in native host order and host
--   endianness. For portability issues see <tt>putWordhost</tt>.
putWord64host :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word64 -> m ()

-- | <i>O(1).</i> Write a single native machine word. The word is written
--   in host order, host endian form, for the machine you're on. On a 64
--   bit machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.
--   Values written this way are not portable to different endian or word
--   sized machines, without conversion.
putWordhost :: MonadPut m => Word -> m ()

-- | <i>O(1).</i> Write a single native machine word. The word is written
--   in host order, host endian form, for the machine you're on. On a 64
--   bit machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.
--   Values written this way are not portable to different endian or word
--   sized machines, without conversion.
putWordhost :: (MonadPut m, m ~ t n, MonadTrans t, MonadPut n) => Word -> m ()

-- | Put a value into a lazy <a>ByteString</a> using <a>runPut</a>.
runPutL :: Put -> ByteString

-- | Put a value into a strict <a>ByteString</a> using <a>runPut</a>.
runPutS :: Put -> ByteString
instance Data.Bytes.Put.MonadPut Data.Binary.Put.PutM
instance Data.Bytes.Put.MonadPut Data.Serialize.Put.PutM
instance Data.Bytes.Put.MonadPut m => Data.Bytes.Put.MonadPut (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Bytes.Put.MonadPut m => Data.Bytes.Put.MonadPut (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Bytes.Put.MonadPut m => Data.Bytes.Put.MonadPut (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Bytes.Put.MonadPut m, GHC.Base.Monoid w) => Data.Bytes.Put.MonadPut (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Bytes.Put.MonadPut m, GHC.Base.Monoid w) => Data.Bytes.Put.MonadPut (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Bytes.Put.MonadPut m, GHC.Base.Monoid w) => Data.Bytes.Put.MonadPut (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Data.Bytes.Put.MonadPut m, GHC.Base.Monoid w) => Data.Bytes.Put.MonadPut (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Bytes.Put.MonadPut m => Data.Bytes.Put.MonadPut (Control.Monad.Trans.Except.ExceptT e m)


-- | When one wants to think of an <a>Int</a> as a dumb bitstring,
--   converting it to a <a>Word</a> avoids pesky complications with respect
--   to sign extension.
module Data.Bytes.Signed
type family Unsigned i :: *
unsigned :: (Integral i, Num (Unsigned i)) => i -> Unsigned i
type family Signed i :: *
signed :: (Integral i, Num (Signed i)) => i -> Signed i


-- | This module provides a <a>VarInt</a> wrapper with a <tt>Serial</tt>
--   instance that generates base-128 variable-width ints. Values are
--   encoded 7 bits at a time, with the most significant being a
--   continuation bit. Thus, the numbers from 0 to 127 require only a
--   single byte to encode, those from 128 to 16383 require two bytes, etc.
--   
--   This format is taken from Google's <i>Protocol Buffers</i>, which
--   provides a bit more verbiage on the encoding:
--   <a>https://developers.google.com/protocol-buffers/docs/encoding#varints</a>.
module Data.Bytes.VarInt
newtype VarInt n
VarInt :: n -> VarInt n
[unVarInt] :: VarInt n -> n
instance GHC.Bits.Bits n => GHC.Bits.Bits (Data.Bytes.VarInt.VarInt n)
instance GHC.Real.Real n => GHC.Real.Real (Data.Bytes.VarInt.VarInt n)
instance GHC.Enum.Bounded n => GHC.Enum.Bounded (Data.Bytes.VarInt.VarInt n)
instance GHC.Real.Integral n => GHC.Real.Integral (Data.Bytes.VarInt.VarInt n)
instance GHC.Num.Num n => GHC.Num.Num (Data.Bytes.VarInt.VarInt n)
instance GHC.Enum.Enum n => GHC.Enum.Enum (Data.Bytes.VarInt.VarInt n)
instance GHC.Show.Show n => GHC.Show.Show (Data.Bytes.VarInt.VarInt n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Data.Bytes.VarInt.VarInt n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Data.Bytes.VarInt.VarInt n)


-- | This module contains two main classes, each providing methods to
--   serialize and deserialize types. <a>Serial</a> is the primary class,
--   to be used for the canonical way to serialize a specific type.
--   <a>SerialEndian</a> is used to provide endian-specific methods for
--   serializing a type.
module Data.Bytes.Serial

-- | Methods to serialize and deserialize type <tt>a</tt> to a binary
--   representation
--   
--   Instances provided here for fixed-with Integers and Words are big
--   endian. Instances for strict and lazy bytestrings store also the
--   length of bytestring big endian. Instances for Word and Int are host
--   endian as they are machine-specific types.
class Serial a
serialize :: (Serial a, MonadPut m) => a -> m ()
serialize :: (Serial a, MonadPut m, GSerial (Rep a), Generic a) => a -> m ()
deserialize :: (Serial a, MonadGet m) => m a
deserialize :: (Serial a, MonadGet m, GSerial (Rep a), Generic a) => m a

-- | Methods to serialize and deserialize type <tt>a</tt> to a big and
--   little endian binary representations. Methods suffixed with "host" are
--   automatically defined to use equal the methods corresponding to the
--   current machine's native endianness, but they can be overridden.
class SerialEndian a
serializeBE :: (SerialEndian a, MonadPut m) => a -> m ()
serializeBE :: (SerialEndian a, MonadPut m, GSerialEndian (Rep a), Generic a) => a -> m ()
deserializeBE :: (SerialEndian a, MonadGet m) => m a
deserializeBE :: (SerialEndian a, MonadGet m, GSerialEndian (Rep a), Generic a) => m a
serializeLE :: (SerialEndian a, MonadPut m) => a -> m ()
serializeLE :: (SerialEndian a, MonadPut m, GSerialEndian (Rep a), Generic a) => a -> m ()
deserializeLE :: (SerialEndian a, MonadGet m) => m a
deserializeLE :: (SerialEndian a, MonadGet m, GSerialEndian (Rep a), Generic a) => m a
serializeHost :: (SerialEndian a, MonadPut m) => a -> m ()
deserializeHost :: (SerialEndian a, MonadGet m) => m a
class Serial1 f
serializeWith :: (Serial1 f, MonadPut m) => (a -> m ()) -> f a -> m ()
serializeWith :: (Serial1 f, MonadPut m, GSerial1 (Rep1 f), Generic1 f) => (a -> m ()) -> f a -> m ()
deserializeWith :: (Serial1 f, MonadGet m) => m a -> m (f a)
deserializeWith :: (Serial1 f, MonadGet m, GSerial1 (Rep1 f), Generic1 f) => m a -> m (f a)
serialize1 :: (MonadPut m, Serial1 f, Serial a) => f a -> m ()
deserialize1 :: (MonadGet m, Serial1 f, Serial a) => m (f a)
class Serial2 f
serializeWith2 :: (Serial2 f, MonadPut m) => (a -> m ()) -> (b -> m ()) -> f a b -> m ()
deserializeWith2 :: (Serial2 f, MonadGet m) => m a -> m b -> m (f a b)
serialize2 :: (MonadPut m, Serial2 f, Serial a, Serial b) => f a b -> m ()
deserialize2 :: (MonadGet m, Serial2 f, Serial a, Serial b) => m (f a b)

-- | serialize any <a>Storable</a> in a host-specific format.
store :: (MonadPut m, Storable a) => a -> m ()

-- | deserialize any <a>Storable</a> in a host-specific format.
restore :: forall m a. (MonadGet m, Storable a) => m a

-- | Used internally to provide generic serialization
class GSerial f
gserialize :: (GSerial f, MonadPut m) => f a -> m ()
gdeserialize :: (GSerial f, MonadGet m) => m (f a)

-- | Used internally to provide generic big-endian serialization
class GSerialEndian f
gserializeBE :: (GSerialEndian f, MonadPut m) => f a -> m ()
gserializeBE :: (GSerialEndian f, MonadPut m, GSerial f) => f a -> m ()
gdeserializeBE :: (GSerialEndian f, MonadGet m) => m (f a)
gdeserializeBE :: (GSerialEndian f, MonadGet m, GSerial f) => m (f a)
gserializeLE :: (GSerialEndian f, MonadPut m) => f a -> m ()
gserializeLE :: (GSerialEndian f, MonadPut m, GSerial f) => f a -> m ()
gdeserializeLE :: (GSerialEndian f, MonadGet m) => m (f a)
gdeserializeLE :: (GSerialEndian f, MonadGet m, GSerial f) => m (f a)

-- | Used internally to provide generic serialization
class GSerial1 f
gserializeWith :: (GSerial1 f, MonadPut m) => (a -> m ()) -> f a -> m ()
gdeserializeWith :: (GSerial1 f, MonadGet m) => m a -> m (f a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial1 (Data.Either.Either a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial1 ((,) a)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Bytes.Serial.Serial1 ((,,) a b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c) => Data.Bytes.Serial.Serial1 ((,,,) a b c)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c, Data.Bytes.Serial.Serial d) => Data.Bytes.Serial.Serial1 ((,,,,) a b c d)
instance Data.Bytes.Serial.Serial1 Data.IntMap.Internal.IntMap
instance (GHC.Classes.Ord k, Data.Bytes.Serial.Serial k) => Data.Bytes.Serial.Serial1 (Data.Map.Internal.Map k)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k, Data.Bytes.Serial.Serial k) => Data.Bytes.Serial.Serial1 (Data.HashMap.Internal.HashMap k)
instance Data.Bytes.Serial.Serial2 Data.Either.Either
instance Data.Bytes.Serial.Serial2 (,)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial2 ((,,) a)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Bytes.Serial.Serial2 ((,,,) a b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c) => Data.Bytes.Serial.Serial2 ((,,,,) a b c)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Sequence.Internal.Seq a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (GHC.Base.NonEmpty a)
instance Data.Bytes.Serial.Serial v => Data.Bytes.Serial.Serial (Data.IntMap.Internal.IntMap v)
instance (Data.Bytes.Serial.Serial k, Data.Bytes.Serial.Serial v, GHC.Classes.Ord k) => Data.Bytes.Serial.Serial (Data.Map.Internal.Map k v)
instance (Data.Bytes.Serial.Serial k, Data.Bytes.Serial.Serial v, Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Bytes.Serial.Serial (Data.HashMap.Internal.HashMap k v)
instance Data.Bytes.Serial.Serial1 []
instance Data.Bytes.Serial.Serial1 GHC.Maybe.Maybe
instance Data.Bytes.Serial.Serial1 Data.Sequence.Internal.Seq
instance Data.Bytes.Serial.Serial1 GHC.Base.NonEmpty
instance Data.Bytes.Serial.Serial1 f => Data.Bytes.Serial.GSerial1 (GHC.Generics.Rec1 f)
instance (Data.Bytes.Serial.Serial1 f, Data.Bytes.Serial.GSerial1 g) => Data.Bytes.Serial.GSerial1 (f GHC.Generics.:.: g)
instance Data.Bytes.Serial.GSerial1 GHC.Generics.Par1
instance Data.Bytes.Serial.GSerial1 GHC.Generics.U1
instance Data.Bytes.Serial.GSerial1 GHC.Generics.V1
instance (Data.Bytes.Serial.GSerial1 f, Data.Bytes.Serial.GSerial1 g) => Data.Bytes.Serial.GSerial1 (f GHC.Generics.:*: g)
instance (Data.Bytes.Serial.GSerial1 f, Data.Bytes.Serial.GSerial1 g) => Data.Bytes.Serial.GSerial1 (f GHC.Generics.:+: g)
instance Data.Bytes.Serial.GSerial1 f => Data.Bytes.Serial.GSerial1 (GHC.Generics.M1 i c f)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.GSerial1 (GHC.Generics.K1 i a)
instance Data.Bytes.Serial.SerialEndian GHC.Types.Double
instance Data.Bytes.Serial.SerialEndian GHC.Types.Float
instance Data.Bytes.Serial.SerialEndian GHC.Types.Char
instance Data.Bytes.Serial.SerialEndian GHC.Word.Word64
instance Data.Bytes.Serial.SerialEndian GHC.Word.Word32
instance Data.Bytes.Serial.SerialEndian GHC.Word.Word16
instance Data.Bytes.Serial.SerialEndian GHC.Int.Int64
instance Data.Bytes.Serial.SerialEndian GHC.Int.Int32
instance Data.Bytes.Serial.SerialEndian GHC.Int.Int16
instance Data.Bytes.Serial.Serial GHC.Types.Double
instance Data.Bytes.Serial.Serial GHC.Types.Float
instance Data.Bytes.Serial.Serial GHC.Types.Char
instance Data.Bytes.Serial.Serial GHC.Word.Word64
instance Data.Bytes.Serial.Serial GHC.Word.Word32
instance Data.Bytes.Serial.Serial GHC.Word.Word16
instance Data.Bytes.Serial.Serial GHC.Int.Int64
instance Data.Bytes.Serial.Serial GHC.Int.Int32
instance Data.Bytes.Serial.Serial GHC.Int.Int16
instance Data.Bytes.Serial.SerialEndian a => Data.Bytes.Serial.GSerialEndian (GHC.Generics.K1 i a)
instance Data.Bytes.Serial.Serial Data.ByteString.Internal.Type.ByteString
instance Data.Bytes.Serial.Serial Data.ByteString.Lazy.Internal.ByteString
instance Data.Bytes.Serial.Serial Data.Text.Internal.Text
instance Data.Bytes.Serial.Serial Data.Text.Internal.Lazy.Text
instance Data.Bytes.Serial.Serial ()
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial [a]
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (GHC.Maybe.Maybe a)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Bytes.Serial.Serial (Data.Either.Either a b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b) => Data.Bytes.Serial.Serial (a, b)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c) => Data.Bytes.Serial.Serial (a, b, c)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c, Data.Bytes.Serial.Serial d) => Data.Bytes.Serial.Serial (a, b, c, d)
instance (Data.Bytes.Serial.Serial a, Data.Bytes.Serial.Serial b, Data.Bytes.Serial.Serial c, Data.Bytes.Serial.Serial d, Data.Bytes.Serial.Serial e) => Data.Bytes.Serial.Serial (a, b, c, d, e)
instance Data.Bytes.Serial.Serial GHC.Types.Bool
instance Data.Bytes.Serial.Serial GHC.Types.Word
instance Data.Bytes.Serial.Serial GHC.Word.Word8
instance Data.Bytes.Serial.Serial GHC.Types.Int
instance Data.Bytes.Serial.Serial GHC.Int.Int8
instance Data.Bytes.Serial.Serial Data.Scientific.Scientific
instance Data.Bytes.Serial.Serial GHC.Base.Void
instance Data.Bytes.Serial.Serial Data.IntSet.Internal.IntSet
instance (Data.Bytes.Serial.Serial a, GHC.Classes.Ord a) => Data.Bytes.Serial.Serial (Data.Set.Internal.Set a)
instance (Data.Bytes.Serial.Serial v, Data.Hashable.Class.Hashable v, GHC.Classes.Eq v) => Data.Bytes.Serial.Serial (Data.HashSet.Internal.HashSet v)
instance (GHC.Bits.Bits n, GHC.Real.Integral n, GHC.Bits.Bits (Data.Bytes.Signed.Unsigned n), GHC.Real.Integral (Data.Bytes.Signed.Unsigned n)) => Data.Bytes.Serial.Serial (Data.Bytes.VarInt.VarInt n)
instance Data.Bytes.Serial.Serial GHC.Num.Integer.Integer
instance Data.Bytes.Serial.Serial GHC.Num.Natural.Natural
instance Data.Fixed.HasResolution a => Data.Bytes.Serial.Serial (Data.Fixed.Fixed a)
instance Data.Bytes.Serial.Serial Data.Time.Clock.Internal.DiffTime.DiffTime
instance Data.Bytes.Serial.Serial Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Data.Bytes.Serial.Serial Data.Time.Calendar.Days.Day
instance Data.Bytes.Serial.Serial Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.Bytes.Serial.Serial Data.Time.Clock.Internal.AbsoluteTime.AbsoluteTime
instance (Data.Bytes.Serial.Serial a, GHC.Real.Integral a) => Data.Bytes.Serial.Serial (GHC.Real.Ratio a)
instance Data.Bytes.Serial.Serial Data.Time.Clock.Internal.UniversalTime.UniversalTime
instance Data.Bytes.Serial.Serial Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Data.Bytes.Serial.Serial Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Data.Bytes.Serial.Serial Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Data.Bytes.Serial.Serial Data.Time.LocalTime.Internal.ZonedTime.ZonedTime
instance Data.Bytes.Serial.Serial GHC.Types.Ordering
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Ord.Down a)
instance Data.Bytes.Serial.Serial Data.Version.Version
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Control.Applicative.ZipList a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Functor.Identity.Identity a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Functor.Constant.Constant a b)
instance (Data.Bytes.Serial.Serial (f a), Data.Bytes.Serial.Serial (g a)) => Data.Bytes.Serial.Serial (Data.Functor.Product.Product f g a)
instance Data.Bytes.Serial.Serial (f a) => Data.Bytes.Serial.Serial (Data.Functor.Reverse.Reverse f a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Semigroup.Internal.Dual a)
instance Data.Bytes.Serial.Serial Data.Semigroup.Internal.All
instance Data.Bytes.Serial.Serial Data.Semigroup.Internal.Any
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Semigroup.Internal.Sum a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Semigroup.Internal.Product a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Monoid.First a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.Serial (Data.Monoid.Last a)
instance Data.Bytes.Serial.Serial a => Data.Bytes.Serial.GSerial (GHC.Generics.K1 i a)
instance Data.Bytes.Serial.GSerial GHC.Generics.U1
instance Data.Bytes.Serial.GSerial GHC.Generics.V1
instance (Data.Bytes.Serial.GSerial f, Data.Bytes.Serial.GSerial g) => Data.Bytes.Serial.GSerial (f GHC.Generics.:*: g)
instance (Data.Bytes.Serial.GSerial f, Data.Bytes.Serial.GSerial g) => Data.Bytes.Serial.GSerial (f GHC.Generics.:+: g)
instance Data.Bytes.Serial.GSerial f => Data.Bytes.Serial.GSerial (GHC.Generics.M1 i c f)
