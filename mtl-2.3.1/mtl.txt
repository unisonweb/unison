-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad classes for transformers, using functional dependencies
--   
--   MTL is a collection of monad classes, extending the
--   <a>transformers</a> package, using functional dependencies for generic
--   lifting of monadic actions.
@package mtl
@version 2.3.1


-- | <ul>
--   <li><i>Computation type:</i> Accumulation (either append-only state,
--   or writer with the ability to read all previous input).</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   monoidally accumulates the subcomputations (that is, using
--   <a>&lt;&gt;</a>).</li>
--   <li><i>Useful for:</i> Logging, patch-style tracking.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Accum</a> w a</tt></li>
--   </ul>
--   
--   <h1>A note on commutativity</h1>
--   
--   Some effects are <i>commutative</i>: it doesn't matter which you
--   resolve first, as all possible orderings of commutative effects are
--   isomorphic. Consider, for example, the reader and state effects, as
--   exemplified by <a>ReaderT</a> and <a>StateT</a> respectively. If we
--   have <tt><a>ReaderT</a> r (<a>State</a> s) a</tt>, this is effectively
--   <tt>r -&gt; <a>State</a> s a ~ r -&gt; s -&gt; (a, s)</tt>; if we
--   instead have <tt><a>StateT</a> s (<a>Reader</a> r) a</tt>, this is
--   effectively <tt>s -&gt; <a>Reader</a> r (a, s) ~ s -&gt; r -&gt; (a,
--   s)</tt>. Since we can always reorder function arguments (for example,
--   using <a>flip</a>, as in this case) without changing the result, these
--   are isomorphic, showing that reader and state are <i>commutative</i>,
--   or, more precisely, <i>commute with each other</i>.
--   
--   However, this isn't generally the case. Consider instead the error and
--   state effects, as exemplified by <a>MaybeT</a> and <a>StateT</a>
--   respectively. If we have <tt><a>MaybeT</a> (<a>State</a> s) a</tt>,
--   this is effectively <tt><tt>State</tt> s (<a>Maybe</a> a) ~ s -&gt;
--   (<a>Maybe</a> a, s)</tt>: put simply, the error can occur only in the
--   <i>result</i>, but not the state, which always 'survives'. On the
--   other hand, if we have <tt><a>StateT</a> s <a>Maybe</a> a</tt>, this
--   is instead <tt>s -&gt; <a>Maybe</a> (a, s)</tt>: here, if we error, we
--   lose <i>both</i> the state and the result! Thus, error and state
--   effects do <i>not</i> commute with each other.
--   
--   As the MTL is capability-based, we support any ordering of
--   non-commutative effects on an equal footing. Indeed, if you wish to
--   use <a>MonadState</a>, for example, whether your final monadic stack
--   ends up being <tt><a>MaybeT</a> (<a>State</a> s) a</tt>,
--   <tt><a>StateT</a> s <a>Maybe</a> a</tt>, or anything else, you will be
--   able to write your desired code without having to consider such
--   differences. However, the way we <i>implement</i> these capabilities
--   for any given transformer (or rather, any given transformed stack)
--   <i>is</i> affected by this ordering unless the effects in question are
--   commutative.
--   
--   We note in this module which effects the accumulation effect does and
--   doesn't commute with; we also note on implementations with
--   non-commutative transformers what the outcome will be. Note that,
--   depending on how the 'inner monad' is structured, this may be more
--   complex than we note: we describe only what impact the 'outer effect'
--   has, not what else might be in the stack.
--   
--   <h1>Commutativity of accumulation</h1>
--   
--   The accumulation effect commutes with the identity effect
--   (<a>IdentityT</a>), reader, writer or state effects (<a>ReaderT</a>,
--   <a>WriterT</a>, <a>StateT</a> and any combination, including
--   <a>RWST</a> for example) and with itself. It does <i>not</i> commute
--   with anything else.
module Control.Monad.Accum

-- | The capability to accumulate. This can be seen in one of two ways:
--   
--   <ul>
--   <li>A <a>MonadState</a> which can only append (using <a>&lt;&gt;</a>);
--   or</li>
--   <li>A <a>MonadWriter</a> (limited to <a>tell</a>) with the ability to
--   view the result of all previous <a>tell</a>s.</li>
--   </ul>
--   
--   <h1>Laws</h1>
--   
--   <a>accum</a> should obey the following:
--   
--   <ol>
--   <li><tt><a>accum</a> (<a>const</a> (x, <a>mempty</a>))</tt> <tt>=</tt>
--   <tt><a>pure</a> x</tt></li>
--   <li><tt><a>accum</a> f <a>*&gt;</a> <a>accum</a> g</tt> <tt>=</tt>
--   <tt><a>accum</a> <a>$</a> acc -&gt; let (_, v) = f acc (res, w) = g
--   (acc <a>&lt;&gt;</a> v) in (res, v <a>&lt;&gt;</a> w)</tt></li>
--   </ol>
--   
--   If you choose to define <a>look</a> and <a>add</a> instead, their
--   definitions must obey the following:
--   
--   <ol>
--   <li><tt><a>look</a> <a>*&gt;</a> <a>look</a></tt> <tt>=</tt>
--   <tt><a>look</a></tt></li>
--   <li><tt><a>add</a> <a>mempty</a></tt> <tt>=</tt> <tt><a>pure</a>
--   ()</tt></li>
--   <li><tt><a>add</a> x <a>*&gt;</a> <a>add</a> y</tt> <tt>=</tt>
--   <tt><a>add</a> (x <a>&lt;&gt;</a> y)</tt></li>
--   <li><tt><a>add</a> x <a>*&gt;</a> <a>look</a></tt> <tt>=</tt>
--   <tt><a>look</a> <a>&gt;&gt;=</a> w -&gt; <a>add</a> x <a>$&gt;</a> w
--   <a>&lt;&gt;</a> x</tt></li>
--   </ol>
--   
--   If you want to define both, the relationship between them is as
--   follows. These are also the default definitions.
--   
--   <ol>
--   <li><tt><a>look</a></tt> <tt>=</tt> <tt><a>accum</a> <a>$</a> acc
--   -&gt; (acc, mempty)</tt></li>
--   <li><tt><a>add</a> x</tt> <tt>=</tt> <tt><a>accum</a> <a>$</a> acc
--   -&gt; (<tt>()</tt>, x)</tt></li>
--   <li><tt><a>accum</a> f</tt> <tt>=</tt> <tt><a>look</a> &gt;&gt;= acc
--   -&gt; let (res, v) = f acc in <a>add</a> v <a>$&gt;</a> res</tt></li>
--   </ol>
class (Monoid w, Monad m) => MonadAccum w m | m -> w

-- | Retrieve the accumulated result so far.
look :: MonadAccum w m => m w

-- | Append a value to the result.
add :: MonadAccum w m => w -> m ()

-- | Embed a simple accumulation action into the monad.
accum :: MonadAccum w m => (w -> (a, w)) -> m a

-- | A helper type to decrease boilerplate when defining new transformer
--   instances of <a>MonadAccum</a>.
--   
--   Most of the instances in this module are derived using this method;
--   for example, our instance of <a>ExceptT</a> is derived as follows:
--   
--   <pre>
--   deriving via (LiftingAccum (ExceptT e) m) instance (MonadAccum w m) =&gt;
--    MonadAccum w (ExceptT e m)
--   </pre>
newtype LiftingAccum (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) (a :: Type)
LiftingAccum :: t m a -> LiftingAccum (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) (a :: Type)

-- | Retrieve a function of the accumulated value.
looks :: forall (a :: Type) (m :: Type -> Type) (w :: Type). MonadAccum w m => (w -> a) -> m a
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Monad.Accum.LiftingAccum t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Monad.Accum.LiftingAccum t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Monad.Accum.LiftingAccum t m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Accum.MonadAccum w' m => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (Control.Monad.Accum.MonadAccum w' m, GHC.Base.Monoid w) => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Accum.MonadAccum w' m, GHC.Base.Monoid w) => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Select.SelectT r m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Accum.MonadAccum w m => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Accum.MonadAccum w' m => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (Control.Monad.Accum.MonadAccum w' m, GHC.Base.Monoid w) => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Accum.MonadAccum w' m, GHC.Base.Monoid w) => Control.Monad.Accum.MonadAccum w' (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m), Control.Monad.Accum.MonadAccum w m) => Control.Monad.Accum.MonadAccum w (Control.Monad.Accum.LiftingAccum t m)
instance GHC.Base.Monoid w => Control.Monad.Accum.MonadAccum w (Control.Monad.Trans.Accum.AccumT w Data.Functor.Identity.Identity)


-- | <ul>
--   <li><i>Computation type:</i> Computations which can be interrupted and
--   resumed.</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   creates a new continuation which uses the function as the continuation
--   of the monadic computation.</li>
--   <li><i>Useful for:</i> Complex control structures, error handling, and
--   creating co-routines.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><tt>Cont</tt> r a</tt></li>
--   </ul>
--   
--   The Continuation monad represents computations in continuation-passing
--   style (CPS). In continuation-passing style function result is not
--   returned, but instead is passed to another function, received as a
--   parameter (continuation). Computations are built up from sequences of
--   nested continuations, terminated by a final continuation (often
--   <tt>id</tt>) which produces the final result. Since continuations are
--   functions which represent the future of a computation, manipulation of
--   the continuation functions can achieve complex manipulations of the
--   future of the computation, such as interrupting a computation in the
--   middle, aborting a portion of a computation, restarting a computation,
--   and interleaving execution of computations. The Continuation monad
--   adapts CPS to the structure of a monad.
--   
--   Before using the Continuation monad, be sure that you have a firm
--   understanding of continuation-passing style and that continuations
--   represent the best solution to your particular design problem. Many
--   algorithms which require continuations in other languages do not
--   require them in Haskell, due to Haskell's lazy semantics. Abuse of the
--   Continuation monad can produce code that is impossible to understand
--   and maintain.
module Control.Monad.Cont.Class
class Monad m => MonadCont (m :: Type -> Type)

-- | <tt>callCC</tt> (call-with-current-continuation) calls a function with
--   the current continuation as its argument. Provides an escape
--   continuation mechanism for use with Continuation monads. Escape
--   continuations allow to abort the current computation and return a
--   value immediately. They achieve a similar effect to <a>throwError</a>
--   and <a>catchError</a> within an <a>Except</a> monad. Advantage of this
--   function over calling <tt>return</tt> is that it makes the
--   continuation explicit, allowing more flexibility and better control
--   (see examples in <a>Control.Monad.Cont</a>).
--   
--   The standard idiom used with <tt>callCC</tt> is to provide a
--   lambda-expression to name the continuation. Then calling the named
--   continuation anywhere within its scope will escape from the
--   computation, even if it is many layers deep within nested
--   computations.
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a

-- | Introduces a recursive binding to the continuation. Due to the use of
--   <tt>callCC</tt>, calling the continuation will interrupt execution of
--   the current block creating an effect similar to goto/setjmp in C.
label :: MonadCont m => a -> m (a -> m b, a)

-- | Simplified version of <a>label</a> without arguments.
label_ :: MonadCont m => m (m a)

-- | Lift a <a>callCC</a>-style function through any <a>MonadTrans</a>.
--   
--   <h1>Note</h1>
--   
--   For any function <tt>f</tt>, <tt>'liftCallCC f'</tt> satisfies the
--   <a>uniformity condition</a> provided that <tt>f</tt> is
--   quasi-algebraic. More specifically, for any <tt>g</tt>, we must have:
--   
--   <pre>
--   'join' '$' f (\exit -&gt; 'pure' '$' g (exit '.' 'pure') = f g
--   </pre>
--   
--   <a>callCC</a> is quasi-algebraic; furthermore, for any quasi-algebraic
--   <tt>f</tt>, <tt><a>liftCallCC</a> f</tt> is also quasi-algebraic.
--   
--   <h1>See also</h1>
--   
--   <ul>
--   <li><a>Proof of quasi-algebraic properties</a></li>
--   <li><a>Original issue</a></li>
--   </ul>
liftCallCC :: forall (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) (a :: Type) (b :: Type). (MonadTrans t, Monad m, forall (m' :: Type -> Type). Monad m' => Monad (t m')) => CallCC m (t m a) b -> CallCC (t m) a b
instance forall k (r :: k) (m :: k -> *). Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Cont.Class.MonadCont m) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Accum.AccumT w m)


-- | <ul>
--   <li><i>Computation type:</i> Computations which can be interrupted and
--   resumed.</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   creates a new continuation which uses the function as the continuation
--   of the monadic computation.</li>
--   <li><i>Useful for:</i> Complex control structures, error handling, and
--   creating co-routines.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><tt>Cont</tt> r a</tt></li>
--   </ul>
--   
--   The Continuation monad represents computations in continuation-passing
--   style (CPS). In continuation-passing style function result is not
--   returned, but instead is passed to another function, received as a
--   parameter (continuation). Computations are built up from sequences of
--   nested continuations, terminated by a final continuation (often
--   <tt>id</tt>) which produces the final result. Since continuations are
--   functions which represent the future of a computation, manipulation of
--   the continuation functions can achieve complex manipulations of the
--   future of the computation, such as interrupting a computation in the
--   middle, aborting a portion of a computation, restarting a computation,
--   and interleaving execution of computations. The Continuation monad
--   adapts CPS to the structure of a monad.
--   
--   Before using the Continuation monad, be sure that you have a firm
--   understanding of continuation-passing style and that continuations
--   represent the best solution to your particular design problem. Many
--   algorithms which require continuations in other languages do not
--   require them in Haskell, due to Haskell's lazy semantics. Abuse of the
--   Continuation monad can produce code that is impossible to understand
--   and maintain.
module Control.Monad.Cont
class Monad m => MonadCont (m :: Type -> Type)

-- | <tt>callCC</tt> (call-with-current-continuation) calls a function with
--   the current continuation as its argument. Provides an escape
--   continuation mechanism for use with Continuation monads. Escape
--   continuations allow to abort the current computation and return a
--   value immediately. They achieve a similar effect to <a>throwError</a>
--   and <a>catchError</a> within an <a>Except</a> monad. Advantage of this
--   function over calling <tt>return</tt> is that it makes the
--   continuation explicit, allowing more flexibility and better control
--   (see examples in <a>Control.Monad.Cont</a>).
--   
--   The standard idiom used with <tt>callCC</tt> is to provide a
--   lambda-expression to name the continuation. Then calling the named
--   continuation anywhere within its scope will escape from the
--   computation, even if it is many layers deep within nested
--   computations.
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a

-- | Introduces a recursive binding to the continuation. Due to the use of
--   <tt>callCC</tt>, calling the continuation will interrupt execution of
--   the current block creating an effect similar to goto/setjmp in C.
label :: MonadCont m => a -> m (a -> m b, a)

-- | Simplified version of <a>label</a> without arguments.
label_ :: MonadCont m => m (m a)

-- | Continuation monad. <tt>Cont r a</tt> is a CPS ("continuation-passing
--   style") computation that produces an intermediate result of type
--   <tt>a</tt> within a CPS computation whose final result type is
--   <tt>r</tt>.
--   
--   The <tt>return</tt> function simply creates a continuation which
--   passes the value on.
--   
--   The <tt>&gt;&gt;=</tt> operator adds the bound function into the
--   continuation chain.
type Cont r = ContT r Identity

-- | Construct a continuation-passing computation from a function. (The
--   inverse of <a>runCont</a>)
cont :: ((a -> r) -> r) -> Cont r a

-- | The result of running a CPS computation with a given final
--   continuation. (The inverse of <a>cont</a>)
runCont :: Cont r a -> (a -> r) -> r

-- | The result of running a CPS computation with the identity as the final
--   continuation.
--   
--   <ul>
--   <li><pre><a>evalCont</a> (<a>return</a> x) = x</pre></li>
--   </ul>
evalCont :: Cont r r -> r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>mapCont</a> f m) = f . <a>runCont</a>
--   m</pre></li>
--   </ul>
mapCont :: (r -> r) -> Cont r a -> Cont r a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>withCont</a> f m) = <a>runCont</a> m .
--   f</pre></li>
--   </ul>
withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b

-- | The continuation monad transformer. Can be used to add continuation
--   handling to any type constructor: the <a>Monad</a> instance and most
--   of the operations do not require <tt>m</tt> to be a monad.
--   
--   <a>ContT</a> is not a functor on the category of monads, and many
--   operations cannot be lifted through it.
newtype () => ContT (r :: k) (m :: k -> Type) a
ContT :: ((a -> m r) -> m r) -> ContT (r :: k) (m :: k -> Type) a
runContT :: ContT r m a -> (a -> m r) -> m r

-- | The result of running a CPS computation with <a>return</a> as the
--   final continuation.
--   
--   <ul>
--   <li><pre><a>evalContT</a> (<a>lift</a> m) = m</pre></li>
--   </ul>
evalContT :: Monad m => ContT r m r -> m r

-- | Apply a function to transform the result of a continuation-passing
--   computation. This has a more restricted type than the <tt>map</tt>
--   operations for other monad transformers, because <a>ContT</a> does not
--   define a functor in the category of monads.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>mapContT</a> f m) = f . <a>runContT</a>
--   m</pre></li>
--   </ul>
mapContT :: forall {k} m (r :: k) a. (m r -> m r) -> ContT r m a -> ContT r m a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>withContT</a> f m) = <a>runContT</a> m .
--   f</pre></li>
--   </ul>
withContT :: forall {k} b m (r :: k) a. ((b -> m r) -> a -> m r) -> ContT r m a -> ContT r m b


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function, other values are used as inputs to the bound function.</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail or using exception handling to structure error
--   handling.</li>
--   <li><i>Zero and plus:</i> Zero is represented by an empty error and
--   the plus operation executes its second argument if the first
--   fails.</li>
--   <li><i>Example type:</i> <tt><a>Either</a> <tt>String</tt> a</tt></li>
--   </ul>
--   
--   The Error monad (also called the Exception monad).
module Control.Monad.Error.Class

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class (Monad m) => MonadError e m | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | <a>MonadError</a> analogue to the <a>try</a> function.
tryError :: MonadError e m => m a -> m (Either e a)

-- | <a>MonadError</a> analogue to the <tt>withExceptT</tt> function.
--   Modify the value (but not the type) of an error. The type is fixed
--   because of the functional dependency <tt>m -&gt; e</tt>. If you need
--   to change the type of <tt>e</tt> use <a>mapError</a> or
--   <a>modifyError</a>.
withError :: MonadError e m => (e -> e) -> m a -> m a

-- | As <tt>handle</tt> is flipped <a>catch</a>, <a>handleError</a> is
--   flipped <a>catchError</a>.
handleError :: MonadError e m => (e -> m a) -> m a -> m a

-- | <a>MonadError</a> analogue of the <tt>mapExceptT</tt> function. The
--   computation is unwrapped, a function is applied to the
--   <tt>Either</tt>, and the result is lifted into the second
--   <a>MonadError</a> instance.
mapError :: (MonadError e m, MonadError e' n) => (m (Either e a) -> n (Either e' b)) -> m a -> n b

-- | A different <a>MonadError</a> analogue to the <tt>withExceptT</tt>
--   function. Modify the value (and possibly the type) of an error in an
--   <tt>ExceptT</tt>-transformed monad, while stripping the
--   <tt>ExceptT</tt> layer.
--   
--   This is useful for adapting the <a>MonadError</a> constraint of a
--   computation.
--   
--   For example:
--   
--   <pre>
--   data DatabaseError = ...
--   
--   performDatabaseQuery :: (MonadError DatabaseError m, ...) =&gt; m PersistedValue
--   
--   data AppError
--     = MkDatabaseError DatabaseError
--     | ...
--   
--   app :: (MonadError AppError m, ...) =&gt; m ()
--   </pre>
--   
--   Given these types, <tt>performDatabaseQuery</tt> cannot be used
--   directly inside <tt>app</tt>, because the error types don't match.
--   Using <a>modifyError</a>, an equivalent function with a different
--   error type can be constructed:
--   
--   <pre>
--   performDatabaseQuery' :: (MonadError AppError m, ...) =&gt; m PersistedValue
--   performDatabaseQuery' = modifyError MkDatabaseError performDatabaseQuery
--   </pre>
--   
--   Since the error types do match, <tt>performDatabaseQuery'</tt> _can_
--   be used in <tt>app</tt>, assuming all other constraints carry over.
--   
--   This works by instantiating the <tt>m</tt> in the type of
--   <tt>performDatabaseQuery</tt> to <tt>ExceptT DatabaseError m'</tt>,
--   which satisfies the <tt>MonadError DatabaseError</tt> constraint.
--   Immediately, the <tt>ExceptT DatabaseError</tt> layer is unwrapped,
--   producing <a>Either</a> a <tt>DatabaseError</tt> or a
--   <tt>PersistedValue</tt>. If it's the former, the error is wrapped in
--   <tt>MkDatabaseError</tt> and re-thrown in the inner monad, otherwise
--   the result value is returned.
modifyError :: MonadError e' m => (e -> e') -> ExceptT e m a -> m a
instance Control.Monad.Error.Class.MonadError GHC.IO.Exception.IOException GHC.Types.IO
instance Control.Monad.Error.Class.MonadError () GHC.Maybe.Maybe
instance Control.Monad.Error.Class.MonadError e (Data.Either.Either e)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Error.Class.MonadError e m) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Accum.AccumT w m)


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function, other values are used as inputs to the bound function.</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail or using exception handling to structure error
--   handling.</li>
--   <li><i>Example type:</i> <tt><a>Either</a> String a</tt></li>
--   </ul>
--   
--   The Error monad (also called the Exception monad).
module Control.Monad.Except

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class (Monad m) => MonadError e m | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | <a>MonadError</a> analogue to the <a>try</a> function.
tryError :: MonadError e m => m a -> m (Either e a)

-- | <a>MonadError</a> analogue to the <tt>withExceptT</tt> function.
--   Modify the value (but not the type) of an error. The type is fixed
--   because of the functional dependency <tt>m -&gt; e</tt>. If you need
--   to change the type of <tt>e</tt> use <a>mapError</a> or
--   <a>modifyError</a>.
withError :: MonadError e m => (e -> e) -> m a -> m a

-- | As <tt>handle</tt> is flipped <a>catch</a>, <a>handleError</a> is
--   flipped <a>catchError</a>.
handleError :: MonadError e m => (e -> m a) -> m a -> m a

-- | <a>MonadError</a> analogue of the <tt>mapExceptT</tt> function. The
--   computation is unwrapped, a function is applied to the
--   <tt>Either</tt>, and the result is lifted into the second
--   <a>MonadError</a> instance.
mapError :: (MonadError e m, MonadError e' n) => (m (Either e a) -> n (Either e' b)) -> m a -> n b

-- | A different <a>MonadError</a> analogue to the <tt>withExceptT</tt>
--   function. Modify the value (and possibly the type) of an error in an
--   <tt>ExceptT</tt>-transformed monad, while stripping the
--   <tt>ExceptT</tt> layer.
--   
--   This is useful for adapting the <a>MonadError</a> constraint of a
--   computation.
--   
--   For example:
--   
--   <pre>
--   data DatabaseError = ...
--   
--   performDatabaseQuery :: (MonadError DatabaseError m, ...) =&gt; m PersistedValue
--   
--   data AppError
--     = MkDatabaseError DatabaseError
--     | ...
--   
--   app :: (MonadError AppError m, ...) =&gt; m ()
--   </pre>
--   
--   Given these types, <tt>performDatabaseQuery</tt> cannot be used
--   directly inside <tt>app</tt>, because the error types don't match.
--   Using <a>modifyError</a>, an equivalent function with a different
--   error type can be constructed:
--   
--   <pre>
--   performDatabaseQuery' :: (MonadError AppError m, ...) =&gt; m PersistedValue
--   performDatabaseQuery' = modifyError MkDatabaseError performDatabaseQuery
--   </pre>
--   
--   Since the error types do match, <tt>performDatabaseQuery'</tt> _can_
--   be used in <tt>app</tt>, assuming all other constraints carry over.
--   
--   This works by instantiating the <tt>m</tt> in the type of
--   <tt>performDatabaseQuery</tt> to <tt>ExceptT DatabaseError m'</tt>,
--   which satisfies the <tt>MonadError DatabaseError</tt> constraint.
--   Immediately, the <tt>ExceptT DatabaseError</tt> layer is unwrapped,
--   producing <a>Either</a> a <tt>DatabaseError</tt> or a
--   <tt>PersistedValue</tt>. If it's the former, the error is wrapped in
--   <tt>MkDatabaseError</tt> and re-thrown in the inner monad, otherwise
--   the result value is returned.
modifyError :: MonadError e' m => (e -> e') -> ExceptT e m a -> m a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a


-- | <ul>
--   <li><i>Computation type:</i> Simple function application.</li>
--   <li><i>Binding strategy:</i> The bound function is applied to the
--   input value. <tt><a>Identity</a> x &gt;&gt;= f == f x</tt></li>
--   <li><i>Useful for:</i> Monads can be derived from monad transformers
--   applied to the <a>Identity</a> monad.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Identity</a> a</tt></li>
--   </ul>
--   
--   The <tt>Identity</tt> monad is a monad that does not embody any
--   computational strategy. It simply applies the bound function to its
--   input without any modification. Computationally, there is no reason to
--   use the <tt>Identity</tt> monad instead of the much simpler act of
--   simply applying functions to their arguments. The purpose of the
--   <tt>Identity</tt> monad is its fundamental role in the theory of monad
--   transformers. Any monad transformer applied to the <tt>Identity</tt>
--   monad yields a non-transformer version of that monad.
module Control.Monad.Identity


-- | <ul>
--   <li><i>Computation type:</i> Computations which read values from a
--   shared environment.</li>
--   <li><i>Binding strategy:</i> Monad values are functions from the
--   environment to a value. The bound function is applied to the bound
--   value, and both have access to the shared environment.</li>
--   <li><i>Useful for:</i> Maintaining variable bindings, or other shared
--   environment.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><tt>Reader</tt> [(String,Value)]
--   a</tt></li>
--   </ul>
--   
--   The <tt>Reader</tt> monad (also called the Environment monad).
--   Represents a computation, which can read values from a shared
--   environment, pass values from function to function, and execute
--   sub-computations in a modified environment. Using <tt>Reader</tt>
--   monad for such computations is often clearer and easier than using the
--   <a>State</a> monad.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Reader.Class

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r m | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a
instance Control.Monad.Reader.Class.MonadReader r ((->) r)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Reader.Class.MonadReader r' m => Control.Monad.Reader.Class.MonadReader r' (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Reader.Class.MonadReader r m) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Accum.AccumT w m)
instance Control.Monad.Reader.Class.MonadReader r' m => Control.Monad.Reader.Class.MonadReader r' (Control.Monad.Trans.Select.SelectT r m)


-- | <ul>
--   <li><i>Computation type:</i> Backtracking search, with <tt>r</tt> as a
--   'ranking' or 'evaluation' type.</li>
--   <li><i>Binding strategy:</i> Binding a function to a monadic value
--   'chains together' strategies; having seen the result of one search,
--   decide which policy to use to continue.</li>
--   <li><i>Useful for:</i> Search problems.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Select</a> r a</tt></li>
--   </ul>
--   
--   <h1>A note on commutativity</h1>
--   
--   Some effects are <i>commutative</i>: it doesn't matter which you
--   resolve first, as all possible orderings of commutative effects are
--   isomorphic. Consider, for example, the reader and state effects, as
--   exemplified by <a>ReaderT</a> and <a>StateT</a> respectively. If we
--   have <tt><a>ReaderT</a> r (<a>State</a> s) a</tt>, this is effectively
--   <tt>r -&gt; <a>State</a> s a ~ r -&gt; s -&gt; (a, s)</tt>; if we
--   instead have <tt><a>StateT</a> s (<a>Reader</a> r) a</tt>, this is
--   effectively <tt>s -&gt; <a>Reader</a> r (a, s) ~ s -&gt; r -&gt; (a,
--   s)</tt>. Since we can always reorder function arguments (for example,
--   using <a>flip</a>, as in this case) without changing the result, these
--   are isomorphic, showing that reader and state are <i>commutative</i>,
--   or, more precisely, <i>commute with each other</i>.
--   
--   However, this isn't generally the case. Consider instead the error and
--   state effects, as exemplified by <a>MaybeT</a> and <a>StateT</a>
--   respectively. If we have <tt><a>MaybeT</a> (<a>State</a> s) a</tt>,
--   this is effectively <tt><tt>State</tt> s (<a>Maybe</a> a) ~ s -&gt;
--   (<a>Maybe</a> a, s)</tt>: put simply, the error can occur only in the
--   <i>result</i>, but not the state, which always 'survives'. On the
--   other hand, if we have <tt><a>StateT</a> s <a>Maybe</a> a</tt>, this
--   is instead <tt>s -&gt; <a>Maybe</a> (a, s)</tt>: here, if we error, we
--   lose <i>both</i> the state and the result! Thus, error and state
--   effects do <i>not</i> commute with each other.
--   
--   As the MTL is capability-based, we support any ordering of
--   non-commutative effects on an equal footing. Indeed, if you wish to
--   use <a>MonadState</a>, for example, whether your final monadic stack
--   ends up being <tt><a>MaybeT</a> (<a>State</a> s) a</tt>,
--   <tt><a>StateT</a> s <a>Maybe</a> a</tt>, or anything else, you will be
--   able to write your desired code without having to consider such
--   differences. However, the way we <i>implement</i> these capabilities
--   for any given transformer (or rather, any given transformed stack)
--   <i>is</i> affected by this ordering unless the effects in question are
--   commutative.
--   
--   We note in this module which effects the accumulation effect does and
--   doesn't commute with; we also note on implementations with
--   non-commutative transformers what the outcome will be. Note that,
--   depending on how the 'inner monad' is structured, this may be more
--   complex than we note: we describe only what impact the 'outer effect'
--   has, not what else might be in the stack.
--   
--   <h1>Commutativity of selection</h1>
--   
--   The selection effect commutes with the identity effect
--   (<a>IdentityT</a>), but nothing else.
module Control.Monad.Select

-- | The capability to search with backtracking. Essentially describes a
--   'policy function': given the state of the search (and a 'ranking' or
--   'evaluation' of each possible result so far), pick the result that's
--   currently best.
--   
--   <h1>Laws</h1>
--   
--   Any instance of <a>MonadSelect</a> must follow these laws:
--   
--   <ul>
--   <li><tt><a>select</a> (<a>const</a> x)</tt> <tt>=</tt> <tt><a>pure</a>
--   x</tt></li>
--   <li><tt><a>select</a> f <a>*&gt;</a> <a>select</a> g</tt> <tt>=</tt>
--   <tt><a>select</a> g</tt></li>
--   </ul>
class (Monad m) => MonadSelect r m | m -> r
select :: MonadSelect r m => ((a -> r) -> a) -> m a

-- | A helper type to decrease boilerplate when defining new transformer
--   instances of <a>MonadSelect</a>.
--   
--   Most of the instances in this module are derived using this method;
--   for example, our instance of <a>ExceptT</a> is derived as follows:
--   
--   <pre>
--   deriving via (LiftingSelect (ExceptT e) m) instance (MonadSelect r m) =&gt;
--    MonadSelect r (ExceptT e m)
--   </pre>
newtype LiftingSelect (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) (a :: Type)
LiftingSelect :: t m a -> LiftingSelect (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) (a :: Type)
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Monad.Select.LiftingSelect t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Monad.Select.LiftingSelect t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Monad.Select.LiftingSelect t m)
instance Control.Monad.Select.MonadSelect r m => Control.Monad.Select.MonadSelect r (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Select.MonadSelect r' m => Control.Monad.Select.MonadSelect r' (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Select.MonadSelect r m => Control.Monad.Select.MonadSelect r (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Select.MonadSelect r m => Control.Monad.Select.MonadSelect r (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Select.MonadSelect r' m => Control.Monad.Select.MonadSelect r' (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Select.MonadSelect w m => Control.Monad.Select.MonadSelect w (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Select.MonadSelect w m => Control.Monad.Select.MonadSelect w (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Select.MonadSelect w' m => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (Control.Monad.Select.MonadSelect w' m, GHC.Base.Monoid w) => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Select.MonadSelect w' m, GHC.Base.Monoid w) => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.Monad.Select.MonadSelect w' m => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (Control.Monad.Select.MonadSelect w' m, GHC.Base.Monoid w) => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Select.MonadSelect w' m, GHC.Base.Monoid w) => Control.Monad.Select.MonadSelect w' (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Control.Monad.Select.MonadSelect r m, GHC.Base.Monoid w) => Control.Monad.Select.MonadSelect r (Control.Monad.Trans.Accum.AccumT w m)
instance (Control.Monad.Trans.Class.MonadTrans t, Control.Monad.Select.MonadSelect r m, GHC.Base.Monad (t m)) => Control.Monad.Select.MonadSelect r (Control.Monad.Select.LiftingSelect t m)
instance Control.Monad.Select.MonadSelect r (Control.Monad.Trans.Select.SelectT r Data.Functor.Identity.Identity)


-- | MonadState class.
--   
--   This module is inspired by the paper <i>Functional Programming with
--   Overloading and Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State.Class

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s m | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.State.Class.MonadState s m) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.State.Class.MonadState s m) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.State.Class.MonadState s m) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.State.Class.MonadState s m) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Accum.AccumT w m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Select.SelectT r m)


-- | Classes for monad transformers.
--   
--   A monad transformer makes new monad out of an existing monad, such
--   that computations of the old monad may be embedded in the new one. To
--   construct a monad with a desired set of features, one typically starts
--   with a base monad, such as <tt>Identity</tt>, <tt>[]</tt> or
--   <a>IO</a>, and applies a sequence of monad transformers.
--   
--   Most monad transformer modules include the special case of applying
--   the transformer to <tt>Identity</tt>. For example, <tt>State s</tt> is
--   an abbreviation for <tt>StateT s Identity</tt>.
--   
--   Each monad transformer also comes with an operation
--   <tt>run</tt><i>XXX</i> to unwrap the transformer, exposing a
--   computation of the inner monad.
module Control.Monad.Trans


-- | Strict state monads.
--   
--   This module is inspired by the paper <i>Functional Programming with
--   Overloading and Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State.Strict

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s m | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype () => StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
runStateT :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: forall s (m :: Type -> Type) a. (s -> s) -> StateT s m a -> StateT s m a


-- | Lazy state monads.
--   
--   This module is inspired by the paper <i>Functional Programming with
--   Overloading and Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State.Lazy

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s m | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype () => StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
runStateT :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: forall s (m :: Type -> Type) a. (s -> s) -> StateT s m a -> StateT s m a


-- | State monads.
--   
--   This module is inspired by the paper <i>Functional Programming with
--   Overloading and Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.State


-- | <ul>
--   <li><i>Computation type:</i> Computations which read values from a
--   shared environment.</li>
--   <li><i>Binding strategy:</i> Monad values are functions from the
--   environment to a value. The bound function is applied to the bound
--   value, and both have access to the shared environment.</li>
--   <li><i>Useful for:</i> Maintaining variable bindings, or other shared
--   environment.</li>
--   <li><i>Zero and plus:</i> None.</li>
--   <li><i>Example type:</i> <tt><a>Reader</a> [(String,Value)]
--   a</tt></li>
--   </ul>
--   
--   The <a>Reader</a> monad (also called the Environment monad).
--   Represents a computation, which can read values from a shared
--   environment, pass values from function to function, and execute
--   sub-computations in a modified environment. Using <a>Reader</a> monad
--   for such computations is often clearer and easier than using the
--   <a>State</a> monad.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.Reader

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r m | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Transform the value returned by a <tt>Reader</tt>.
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>mapReader</a> f m) = f .
--   <a>runReader</a> m</pre></li>
--   </ul>
mapReader :: (a -> b) -> Reader r a -> Reader r b

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>withReader</a> f m) = <a>runReader</a> m
--   . f</pre></li>
--   </ul>
withReader :: (r' -> r) -> Reader r a -> Reader r' a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype () => ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a
runReaderT :: ReaderT r m a -> r -> m a

-- | Transform the computation inside a <tt>ReaderT</tt>.
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>mapReaderT</a> f m) = f .
--   <a>runReaderT</a> m</pre></li>
--   </ul>
mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b

-- | Execute a computation in a modified environment (a more general
--   version of <a>local</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>withReaderT</a> f m) =
--   <a>runReaderT</a> m . f</pre></li>
--   </ul>
withReaderT :: forall r' r (m :: Type -> Type) a. (r' -> r) -> ReaderT r m a -> ReaderT r' m a


-- | The MonadWriter class.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Class
class (Monoid w, Monad m) => MonadWriter w m | m -> w

-- | <tt><a>writer</a> (a,w)</tt> embeds a simple writer action.
writer :: MonadWriter w m => (a, w) -> m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: MonadWriter w m => w -> m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
listen :: MonadWriter w m => m a -> m (a, w)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <tt>liftM</tt> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   </ul>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<tt>liftM</tt> (\x -&gt;
--   (x,f)) m)</pre></li>
--   </ul>
censor :: MonadWriter w m => (w -> w) -> m a -> m a
instance GHC.Base.Monoid w => Control.Monad.Writer.Class.MonadWriter w ((,) w)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w', Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Accum.AccumT w' m)


-- | Strict writer monads that use continuation-passing-style to achieve
--   constant space usage.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
--   
--   <i>Since: mtl-2.3, transformers-0.5.6</i>
module Control.Monad.Writer.CPS
class (Monoid w, Monad m) => MonadWriter w m | m -> w

-- | <tt><a>writer</a> (a,w)</tt> embeds a simple writer action.
writer :: MonadWriter w m => (a, w) -> m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: MonadWriter w m => w -> m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
listen :: MonadWriter w m => m a -> m (a, w)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <tt>liftM</tt> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   </ul>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<tt>liftM</tt> (\x -&gt;
--   (x,f)) m)</pre></li>
--   </ul>
censor :: MonadWriter w m => (w -> w) -> m a -> m a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Monoid w => Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Monoid w => Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: (Monoid w, Monoid w') => ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data () => WriterT w (m :: Type -> Type) a

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: (Monad m, Monoid w) => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (Monad n, Monoid w, Monoid w') => (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b


-- | Declaration of the MonadRWS class.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Class
class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => MonadRWS r w s m | m -> r, m -> w, m -> s
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.Maybe.MaybeT m)


-- | Strict RWS monad.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Strict

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype () => RWST r w s (m :: Type -> Type) a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s (m :: Type -> Type) a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: forall r' s r w (m :: Type -> Type) a. (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a


-- | Lazy RWS monad.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS.Lazy

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype () => RWST r w s (m :: Type -> Type) a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s (m :: Type -> Type) a
runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: forall r' s r w (m :: Type -> Type) a. (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a


-- | Declaration of the MonadRWS class.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
module Control.Monad.RWS


-- | Strict RWS monad that uses continuation-passing-style to achieve
--   constant space usage.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/</a>) Advanced School of Functional
--   Programming, 1995.
--   
--   <i>Since: mtl-2.3, transformers-0.5.6</i>
module Control.Monad.RWS.CPS

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: Monoid w => (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: Monoid w => RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: Monoid w => RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: Monoid w => RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: (Monoid w, Monoid w') => ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
data () => RWST r w s (m :: Type -> Type) a

-- | Unwrap an RWST computation as a function. (The inverse of
--   <a>rwsT</a>.)
runRWST :: Monoid w => RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: (Monad m, Monoid w) => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: (Monad m, Monoid w) => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><tt><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</tt> mapRWST :: (m (a, s, w) -&gt; n (b, s, w')) -&gt; RWST r w s
--   m a -&gt; RWST r w' s n b</li>
--   </ul>
mapRWST :: (Monad n, Monoid w, Monoid w') => (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: forall r' s r w (m :: Type -> Type) a. (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a


-- | Lazy writer monads.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Lazy
class (Monoid w, Monad m) => MonadWriter w m | m -> w

-- | <tt><a>writer</a> (a,w)</tt> embeds a simple writer action.
writer :: MonadWriter w m => (a, w) -> m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: MonadWriter w m => w -> m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
listen :: MonadWriter w m => m a -> m (a, w)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <tt>liftM</tt> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   </ul>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<tt>liftM</tt> (\x -&gt;
--   (x,f)) m)</pre></li>
--   </ul>
censor :: MonadWriter w m => (w -> w) -> m a -> m a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype () => WriterT w (m :: Type -> Type) a
WriterT :: m (a, w) -> WriterT w (m :: Type -> Type) a
runWriterT :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b


-- | The MonadWriter class.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer


-- | Strict writer monads.
--   
--   Inspired by the paper <i>Functional Programming with Overloading and
--   Higher-Order Polymorphism</i>, Mark P Jones
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>) Advanced
--   School of Functional Programming, 1995.
module Control.Monad.Writer.Strict
class (Monoid w, Monad m) => MonadWriter w m | m -> w

-- | <tt><a>writer</a> (a,w)</tt> embeds a simple writer action.
writer :: MonadWriter w m => (a, w) -> m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: MonadWriter w m => w -> m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
listen :: MonadWriter w m => m a -> m (a, w)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
pass :: MonadWriter w m => m (a, w -> w) -> m a

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <tt>liftM</tt> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   </ul>
listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<tt>liftM</tt> (\x -&gt;
--   (x,f)) m)</pre></li>
--   </ul>
censor :: MonadWriter w m => (w -> w) -> m a -> m a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype () => WriterT w (m :: Type -> Type) a
WriterT :: m (a, w) -> WriterT w (m :: Type -> Type) a
[runWriterT] :: WriterT w (m :: Type -> Type) a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
