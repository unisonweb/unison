-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC BigNum library
--   
--   This package provides the low-level implementation of the standard
--   <a>BigNat</a>, <a>Natural</a> and <a>Integer</a> types.
@package ghc-bignum
@version 1.3

module GHC.Num.Primitives
type Bool# = Int#
(&&#) :: Bool# -> Bool# -> Bool#
infixr 3 &&#
(||#) :: Bool# -> Bool# -> Bool#
infixr 2 ||#
notB# :: Bool# -> Bool#
testBitI# :: Int# -> Word# -> Bool#
minI# :: Int# -> Int# -> Int#
maxI# :: Int# -> Int# -> Int#

-- | Branchless <tt>signum</tt>
sgnI# :: Int# -> Int#

-- | Branchless <tt>abs</tt>
absI# :: Int# -> Int#

-- | Branchless comparison
cmpI# :: Int# -> Int# -> Int#

-- | Encode (# Int# mantissa, Int# exponent #) into a Double#.
--   
--   (provided by GHC's RTS)
intEncodeDouble# :: Int# -> Int# -> Double#

-- | Population count
popCntI# :: Int# -> Word#
andNot# :: Word# -> Word# -> Word#
cmpW# :: Word# -> Word# -> Ordering
bitW# :: Int# -> Word#
maxW# :: Word# -> Word# -> Word#
minW# :: Word# -> Word# -> Word#
testBitW# :: Word# -> Word# -> Bool#

-- | Safe right shift for Word#
shiftRW# :: Word# -> Word# -> Word#

-- | Add 3 values together
plusWord3# :: Word# -> Word# -> Word# -> (# Word#, Word# #)

-- | (h,l) &lt;- a + (hb,lb)
plusWord12# :: Word# -> (# Word#, Word# #) -> (# Word#, Word# #)

-- | 2-by-1 large division
--   
--   Requires: b0 /= 0 a1 &gt;= b0 (not required, but if not q1=0)
quotRemWord3# :: (# Word#, Word# #) -> Word# -> (# (# Word#, Word# #), Word# #)

-- | Return the absolute value of the Int# in a Word#
wordFromAbsInt# :: Int# -> Word#

-- | Compute base-2 log of <a>Word#</a>
--   
--   This is internally implemented as count-leading-zeros machine
--   instruction.
wordLog2# :: Word# -> Word#

-- | Logarithm for an arbitrary base
wordLogBase# :: Word# -> Word# -> Word#
wordSizeInBase# :: Word# -> Word# -> Word#

-- | Indicate if the value is a power of two and which one
wordIsPowerOf2# :: Word# -> (# (# #) | Word# #)

-- | Encode (# Word# mantissa, Int# exponent #) into a Double#.
--   
--   (provided by GHC's RTS)
wordEncodeDouble# :: Word# -> Int# -> Double#

-- | Reverse bits in a Word#
wordReverseBits# :: Word# -> Word#

-- | Reverse bits in the Word32 subwords composing a Word#
wordReverseBits32# :: Word# -> Word#

-- | Reverse bytes in a Word#
wordReverseBytes# :: Word# -> Word#

-- | Read a Word from <tt><i>addr</i></tt> in base-256 representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
wordFromAddr# :: Word# -> Addr# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Read a Word from <tt><i>addr</i></tt> in base-256 little-endian
--   representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
wordFromAddrLE# :: Word# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Read a Word from <tt><i>addr</i></tt> in base-256 big-endian
--   representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
wordFromAddrBE# :: Word# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Write a Word to <tt><i>addr</i></tt> in base-256 representation and
--   return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
wordToAddr# :: Word# -> Addr# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write a Word to <tt><i>addr</i></tt> in base-256 little-endian
--   representation and return the number of bytes written.
wordToAddrLE# :: Word# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Write a Word to <tt><i>addr</i></tt> in base-256 big-endian
--   representation and return the number of bytes written.
wordToAddrBE# :: Word# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Write a full word with little-endian encoding
wordWriteAddrLE# :: Word# -> Addr# -> State# s -> State# s

-- | Write a full word with little-endian encoding
wordWriteAddrBE# :: Word# -> Addr# -> State# s -> State# s

-- | Read a Word from <tt><i>ByteArray</i></tt> in base-256 representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
wordFromByteArray# :: Word# -> ByteArray# -> Word# -> Bool# -> Word#

-- | Read a Word from <tt><i>ByteArray</i></tt> in base-256 little-endian
--   representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
wordFromByteArrayLE# :: Word# -> ByteArray# -> Word# -> Word#

-- | Read a Word from <tt><i>ByteArray</i></tt> in base-256 big-endian
--   representation.
--   
--   @<tt>n</tt> is the number of bytes to read.
wordFromByteArrayBE# :: Word# -> ByteArray# -> Word# -> Word#

-- | Write a Word to <tt><i>MutableByteArray</i></tt> in base-256
--   representation and return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
--   
--   The offset is in bytes.
wordToMutableByteArray# :: Word# -> MutableByteArray# s -> Word# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write a Word to <tt><i>MutableByteArray</i></tt> in base-256
--   little-endian representation and return the number of bytes written.
--   
--   The offset is in bytes.
wordToMutableByteArrayLE# :: Word# -> MutableByteArray# s -> Word# -> State# s -> (# State# s, Word# #)

-- | Write a Word to <tt><i>MutableByteArray</i></tt> in base-256
--   big-endian representation and return the number of bytes written.
--   
--   The offset is in bytes.
wordToMutableByteArrayBE# :: Word# -> MutableByteArray# s -> Word# -> State# s -> (# State# s, Word# #)

-- | Write a full word with little-endian encoding
wordWriteMutableByteArrayLE# :: Word# -> MutableByteArray# s -> Word# -> State# s -> State# s

-- | Write a full word with little-endian encoding
wordWriteMutableByteArrayBE# :: Word# -> MutableByteArray# s -> Word# -> State# s -> State# s

-- | Raise <a>underflowException</a>
raiseUnderflow :: a
raiseUnderflow_Word# :: (# #) -> Word#

-- | Raise <a>divZeroException</a>
raiseDivZero :: a
raiseDivZero_Word# :: (# #) -> Word#
unexpectedValue :: a
unexpectedValue_Int# :: (# #) -> Int#
unexpectedValue_Word# :: (# #) -> Word#
ioWord# :: IO Word -> State# RealWorld -> (# State# RealWorld, Word# #)
ioInt# :: IO Int -> State# RealWorld -> (# State# RealWorld, Int# #)
ioVoid :: IO a -> State# RealWorld -> State# RealWorld
ioBool :: IO Bool -> State# RealWorld -> (# State# RealWorld, Bool# #)

module GHC.Num.WordArray

-- | Unlifted array of Word
type WordArray# = ByteArray#
type MutableWordArray# = MutableByteArray#
data WordArray
WordArray :: WordArray# -> WordArray
data MutableWordArray s
MutableWordArray :: MutableWordArray# s -> MutableWordArray s

-- | Convert limb count into byte count
wordsToBytes# :: Int# -> Int#

-- | Convert byte count into limb count
bytesToWords# :: Int# -> Int#

-- | Create a new WordArray# of the given size (*in Word#*) and apply the
--   action to it before returning it frozen
withNewWordArray# :: Int# -> (MutableWordArray# RealWorld -> State# RealWorld -> State# RealWorld) -> WordArray#

-- | Create two new WordArray# of the given sizes (*in Word#*) and apply
--   the action to them before returning them frozen
withNewWordArray2# :: Int# -> Int# -> (MutableWordArray# RealWorld -> MutableWordArray# RealWorld -> State# RealWorld -> State# RealWorld) -> (# WordArray#, WordArray# #)

-- | Create a new WordArray#
newWordArray# :: Int# -> State# s -> (# State# s, MutableWordArray# s #)

-- | Create a new WordArray# of the given size (*in Word#*), apply the
--   action to it, trim its most significant zeroes, then return it frozen
withNewWordArrayTrimmed# :: Int# -> (MutableWordArray# RealWorld -> State# RealWorld -> State# RealWorld) -> WordArray#

-- | Create two new WordArray# of the given sizes (*in Word#*), apply the
--   action to them, trim their most significant zeroes, then return them
--   frozen
withNewWordArray2Trimmed# :: Int# -> Int# -> (MutableWordArray# RealWorld -> MutableWordArray# RealWorld -> State# RealWorld -> State# RealWorld) -> (# WordArray#, WordArray# #)

-- | Create a new WordArray# of the given size (*in Word#*), apply the
--   action to it. If the action returns true#, trim its most significant
--   zeroes, then return it frozen. Otherwise, return ().
withNewWordArrayTrimmedMaybe# :: Int# -> (MutableWordArray# RealWorld -> State# RealWorld -> (# State# RealWorld, Bool# #)) -> (# (# #) | WordArray# #)

-- | Create a WordArray# from two Word#
--   
--   `wordArrayFromWord2# h l where h is the most significant word l is the
--   least significant word
wordArrayFromWord2# :: Word# -> Word# -> WordArray#

-- | Create a WordArray# from one Word#
wordArrayFromWord# :: Word# -> WordArray#

-- | Word array size
wordArraySize# :: WordArray# -> Int#

-- | Equality test for WordArray#
--   
--   Get size in Words
mwaSize# :: MutableWordArray# s -> State# s -> (# State# s, Int# #)

-- | Get the last Word (must be non empty!)
wordArrayLast# :: WordArray# -> Word#

-- | Copy Words from a WordArray
--   
--   Don't do anything if the number of words to copy is &lt;= 0
mwaArrayCopy# :: MutableByteArray# s -> Int# -> WordArray# -> Int# -> Int# -> State# s -> State# s

-- | Shrink last words of a WordArray
mwaShrink# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Set size
mwaSetSize# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Copy the WordArray into the MWA and shrink the size of MWA to the one
--   of the WordArray
mwaInitCopyShrink# :: MutableByteArray# s -> WordArray# -> State# s -> State# s

-- | Trim ending zeroes
mwaTrimZeroes# :: MutableByteArray# s -> State# s -> State# s

-- | Count leading zero Words
mwaClz :: MutableWordArray# s -> State# s -> (# State# s, Int# #)

-- | Count leading zero Words starting at given position
mwaClzAt :: MutableWordArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Count leading zero Words starting at given position
waClzAt :: WordArray# -> Int# -> Int#

-- | Compare the most signiciant limbs of a and b. The comparison stops
--   (i.e. returns EQ) when there isn't enough lims in a or b to perform
--   another comparison.
wordArrayCompareMSWords :: WordArray# -> WordArray# -> Ordering

-- | Compute MutableWordArray &lt;- WordArray + Word
--   
--   The MutableWordArray may not be initialized and will be erased anyway.
--   
--   Input: Size(MutableWordArray) = Size(WordArray) + 1 Output:
--   Size(MutableWordArray) = Size(WordArray) [+ 1]
mwaInitArrayPlusWord :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> State# s

-- | Write the most-significant Word: * if it is 0: shrink the array of 1
--   Word * otherwise: write it
mwaWriteOrShrink :: MutableWordArray# s -> Word# -> Int# -> State# s -> State# s

-- | Compute the index of the most-significant Word and write it.
mwaWriteMostSignificant :: MutableWordArray# s -> Word# -> State# s -> State# s

-- | MutableWordArray &lt;- zipWith op wa1 wa2
--   
--   Required output: Size(MutableWordArray) = min Size(wa1) Size(wa2)
mwaInitArrayBinOp :: MutableWordArray# s -> WordArray# -> WordArray# -> (Word# -> Word# -> Word#) -> State# s -> State# s

-- | Write an element of the MutableWordArray
mwaWrite# :: MutableWordArray# s -> Int# -> Word# -> State# s -> State# s

-- | Fill some part of a MutableWordArray with the given Word#
mwaFill# :: MutableWordArray# s -> Word# -> Word# -> Word# -> State# s -> State# s

-- | Add Word# inplace (a the specified offset) in the mwa with carry
--   propagation.
mwaAddInplaceWord# :: MutableWordArray# d -> Int# -> Word# -> State# d -> State# d

-- | Sub Word# inplace (at the specified offset) in the mwa with carry
--   propagation.
--   
--   Return False# on underflow
mwaSubInplaceWord# :: MutableWordArray# d -> Int# -> Word# -> State# d -> (# State# d, Bool# #)

-- | Trim <tt>a</tt> of <tt>k</tt> less significant limbs and then compare
--   the result with <tt>b</tt>
--   
--   "mwa" doesn't need to be trimmed
mwaTrimCompare :: Int# -> MutableWordArray# s -> WordArray# -> State# s -> (# State# s, Ordering #)

-- | Sub array inplace (at the specified offset) in the mwa with carry
--   propagation.
--   
--   We don't trim the resulting array!
--   
--   Return False# on underflow.
mwaSubInplaceArray :: MutableWordArray# d -> Int# -> WordArray# -> State# d -> (# State# d, Bool# #)

-- | Add array inplace (a the specified offset) in the mwa with carry
--   propagation.
--   
--   Upper bound of the result mutable aray is not checked against
--   overflow.
mwaAddInplaceArray :: MutableWordArray# d -> Int# -> WordArray# -> State# d -> State# d

-- | Sub array inplace (at the specified offset) in the mwa with carry
--   propagation.
--   
--   We don't trim the resulting array!
--   
--   Return False# on underflow.
mwaSubInplaceMutableArray :: MutableWordArray# d -> Int# -> MutableWordArray# d -> State# d -> (# State# d, Bool# #)

-- | Sub an array inplace and then trim zeroes
--   
--   Don't check overflow. The caller must ensure that a&gt;=b
mwaSubInplaceArrayTrim :: MutableWordArray# d -> Int# -> WordArray# -> State# d -> State# d

-- | Read an indexed Word in the MutableWordArray. If the index is
--   out-of-bound, return zero.
mwaReadOrZero :: MutableWordArray# s -> Int# -> State# s -> (# State# s, Word# #)
mwaRead# :: MutableWordArray# s -> Int# -> State# s -> (# State# s, Word# #)


-- | Selected backend
--   
--   We need this module in addition to GHC.Num.Backend to avoid module
--   loops with Check backend.
module GHC.Num.Backend.Selected

-- | ghc-bignum backend name
backendName :: [Char]

-- | Type representing a GMP Limb
type GmpLimb = Word
type GmpLimb# = Word#

-- | Count of <a>GmpLimb</a>s, must be positive (unless specified
--   otherwise).
type GmpSize = Int
type GmpSize# = Int#
narrowGmpSize# :: Int# -> Int#
narrowCInt# :: Int# -> Int#
bignat_compare :: WordArray# -> WordArray# -> Int#
bignat_add :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_add_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_sub :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> (# State# RealWorld, Bool# #)
bignat_sub_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> (# State# RealWorld, Bool# #)
bignat_mul :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_mul_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_popcount :: WordArray# -> Word#
bignat_shiftl :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_shiftr :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_or :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_xor :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_and :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_and_not :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_quotrem :: MutableWordArray# RealWorld -> MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_quot :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_rem :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_quotrem_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> (# State# RealWorld, Word# #)
bignat_quot_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_rem_word :: WordArray# -> Word# -> Word#
bignat_gcd :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_gcd_word :: WordArray# -> Word# -> Word#
bignat_gcd_word_word :: Word# -> Word# -> Word#
bignat_encode_double :: WordArray# -> Int# -> Double#
bignat_shiftr_neg :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_powmod_word :: WordArray# -> WordArray# -> Word# -> Word#
bignat_powmod_words :: Word# -> Word# -> Word# -> Word#
bignat_powmod :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
integer_powmod :: Integer -> Natural -> Natural -> Natural
sbignat_powmod :: MutableWordArray# RealWorld -> Int# -> WordArray# -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
integer_gcde :: Integer -> Integer -> (# Integer, Integer, Integer #)
integer_recip_mod :: Integer -> Natural -> (# Natural | () #)

-- | Return 0 for invalid inputs
sbignat_recip_mod :: Int# -> BigNat# -> BigNat# -> BigNat#
integer_gmp_gcd_word :: GmpLimb# -> GmpLimb# -> GmpLimb#
c_mpn_gcd_1# :: ByteArray# -> GmpSize# -> GmpLimb# -> GmpLimb#
c_mpn_gcd# :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpSize
integer_gmp_gcdext# :: MutableByteArray# s -> Addr# -> MutableByteArray# s -> Addr# -> MutableByteArray# s -> Addr# -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO ()
integer_gmp_invert# :: MutableByteArray# RealWorld -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpSize
c_mpn_add_1 :: MutableByteArray# s -> ByteArray# -> GmpSize# -> GmpLimb# -> IO GmpLimb
c_mpn_sub_1 :: MutableByteArray# s -> ByteArray# -> GmpSize# -> GmpLimb# -> IO GmpLimb
c_mpn_mul_1 :: MutableByteArray# s -> ByteArray# -> GmpSize# -> GmpLimb# -> IO GmpLimb
c_mpn_add :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpLimb
c_mpn_sub :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpLimb
c_mpn_mul :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpLimb
c_mpn_cmp :: ByteArray# -> ByteArray# -> GmpSize# -> Int#
c_mpn_tdiv_qr :: MutableByteArray# s -> MutableByteArray# s -> GmpSize# -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_tdiv_q :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_tdiv_r :: MutableByteArray# s -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_divrem_1 :: MutableByteArray# s -> GmpSize# -> ByteArray# -> GmpSize# -> GmpLimb# -> IO GmpLimb
c_mpn_mod_1 :: ByteArray# -> GmpSize# -> GmpLimb# -> GmpLimb#
c_mpn_rshift :: MutableByteArray# s -> ByteArray# -> GmpSize# -> Word# -> IO GmpLimb
c_mpn_rshift_2c :: MutableByteArray# s -> ByteArray# -> GmpSize# -> Word# -> IO GmpLimb
c_mpn_lshift :: MutableByteArray# s -> ByteArray# -> GmpSize# -> Word# -> IO GmpLimb
c_mpn_and_n :: MutableByteArray# s -> ByteArray# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_andn_n :: MutableByteArray# s -> ByteArray# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_ior_n :: MutableByteArray# s -> ByteArray# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_xor_n :: MutableByteArray# s -> ByteArray# -> ByteArray# -> GmpSize# -> IO ()
c_mpn_popcount :: ByteArray# -> GmpSize# -> Word#
c_mpn_get_d :: ByteArray# -> GmpSize# -> Int# -> Double#
integer_gmp_powm# :: MutableByteArray# RealWorld -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> IO GmpSize
integer_gmp_powm_word :: GmpLimb# -> GmpLimb# -> GmpLimb# -> GmpLimb#
integer_gmp_powm1# :: ByteArray# -> GmpSize# -> ByteArray# -> GmpSize# -> GmpLimb# -> GmpLimb#


-- | Selected backend
module GHC.Num.Backend


-- | Multi-precision natural
module GHC.Num.BigNat

-- | A BigNat
--   
--   Represented as an array of limbs (Word#) stored in little-endian order
--   (Word# themselves use machine order).
--   
--   Invariant (canonical representation): higher Word# is non-zero.
--   
--   As a consequence, zero is represented with a WordArray# whose size is
--   0.
type BigNat# = WordArray#

-- | A lifted BigNat
--   
--   Represented as an array of limbs (Word#) stored in little-endian order
--   (Word# themselves use machine order).
--   
--   Invariant (canonical representation): higher Word# is non-zero.
--   
--   As a consequence, zero is represented with a WordArray# whose size is
--   0.
data BigNat
BN# :: BigNat# -> BigNat
[unBigNat] :: BigNat -> BigNat#

-- | Check that the BigNat is valid
bigNatCheck# :: BigNat# -> Bool#

-- | Check that the BigNat is valid
bigNatCheck :: BigNat# -> Bool

-- | Number of words in the BigNat
bigNatSize :: BigNat# -> Word

-- | Number of words in the BigNat
bigNatSize# :: BigNat# -> Int#
bigNatZero :: BigNat
bigNatOne :: BigNat

-- | BigNat Zero
bigNatZero# :: (# #) -> BigNat#

-- | BigNat one
bigNatOne# :: (# #) -> BigNat#
raiseDivZero_BigNat :: (# #) -> BigNat#

-- | Indicate if a bigNat is zero
bigNatIsZero :: BigNat# -> Bool

-- | Indicate if a bigNat is zero
bigNatIsZero# :: BigNat# -> Bool#

-- | Indicate if a bigNat is one
bigNatIsOne :: BigNat# -> Bool

-- | Indicate if a bigNat is one
bigNatIsOne# :: BigNat# -> Bool#

-- | Indicate if a bigNat is two
bigNatIsTwo :: BigNat# -> Bool

-- | Indicate if a bigNat is two
bigNatIsTwo# :: BigNat# -> Bool#

-- | Indicate if the value is a power of two and which one
bigNatIsPowerOf2# :: BigNat# -> (# (# #) | Word# #)

-- | Return the Word# at the given index
bigNatIndex# :: BigNat# -> Int# -> Word#

-- | Return the Word# at the given index
bigNatIndex :: BigNat# -> Int# -> Word

-- | Create a BigNat from a Word
bigNatFromWord :: Word -> BigNat#

-- | Create a BigNat from a Word
bigNatFromWord# :: Word# -> BigNat#

-- | Convert a list of non-zero Words (most-significant first) into a
--   BigNat
bigNatFromWordList :: [Word] -> BigNat#

-- | Convert a list of non-zero Words (most-significant first) into a
--   BigNat
bigNatFromWordList# :: [Word] -> WordArray#

-- | Return the absolute value of the Int# in a BigNat
bigNatFromAbsInt# :: Int# -> BigNat#

-- | Convert a list of non-zero Words (most-significant first) into a
--   BigNat. Don't remove most-significant zero words
bigNatFromWordListUnsafe :: [Word] -> BigNat#

-- | Convert a BigNat into a list of non-zero Words (most-significant
--   first)
bigNatToWordList :: BigNat# -> [Word]

-- | Convert two Word# (most-significant first) into a BigNat
bigNatFromWord2# :: Word# -> Word# -> BigNat#

-- | Convert a BigNat into a Word#
bigNatToWord# :: BigNat# -> Word#

-- | Convert a BigNat into a Word# if it fits
bigNatToWordMaybe# :: BigNat# -> (# (# #) | Word# #)

-- | Convert a BigNat into a Word
bigNatToWord :: BigNat# -> Word

-- | Convert a BigNat into a Int#
bigNatToInt# :: BigNat# -> Int#

-- | Convert a BigNat into a Int
bigNatToInt :: BigNat# -> Int

-- | Convert a Word64# into a BigNat on 64-bit architectures
bigNatFromWord64# :: Word64# -> BigNat#

-- | Convert a BigNat into a Word64# on 64-bit architectures
bigNatToWord64# :: BigNat# -> Word64#

-- | Encode (# BigNat mantissa, Int# exponent #) into a Double#
bigNatEncodeDouble# :: BigNat# -> Int# -> Double#

-- | Test if a BigNat is greater than a Word
bigNatGtWord# :: BigNat# -> Word# -> Bool#

-- | Test if a BigNat is equal to a Word
bigNatEqWord# :: BigNat# -> Word# -> Bool#

-- | Test if a BigNat is greater than a Word
bigNatGtWord :: BigNat# -> Word -> Bool

-- | Test if a BigNat is lower than or equal to a Word
bigNatLeWord# :: BigNat# -> Word# -> Bool#

-- | Test if a BigNat is lower than or equal to a Word
bigNatLeWord :: BigNat# -> Word -> Bool

-- | Equality test for BigNat
bigNatEq# :: BigNat# -> BigNat# -> Bool#

-- | Equality test for BigNat
bigNatEq :: BigNat# -> BigNat# -> Bool

-- | Inequality test for BigNat
bigNatNe# :: BigNat# -> BigNat# -> Bool#

-- | Equality test for BigNat
bigNatNe :: BigNat# -> BigNat# -> Bool

-- | Compare a BigNat and a Word#
bigNatCompareWord# :: BigNat# -> Word# -> Ordering

-- | Compare a BigNat and a Word
bigNatCompareWord :: BigNat# -> Word -> Ordering

-- | Compare two BigNat
bigNatCompare :: BigNat# -> BigNat# -> Ordering

-- | Predicate: a &lt; b
bigNatLt# :: BigNat# -> BigNat# -> Bool#

-- | Predicate: a &lt; b
bigNatLt :: BigNat# -> BigNat# -> Bool

-- | Predicate: a &lt;= b
bigNatLe# :: BigNat# -> BigNat# -> Bool#

-- | Predicate: a &lt;= b
bigNatLe :: BigNat# -> BigNat# -> Bool

-- | Predicate: a &gt; b
bigNatGt# :: BigNat# -> BigNat# -> Bool#

-- | Predicate: a &gt; b
bigNatGt :: BigNat# -> BigNat# -> Bool

-- | Predicate: a &gt;= b
bigNatGe# :: BigNat# -> BigNat# -> Bool#

-- | Predicate: a &gt;= b
bigNatGe :: BigNat# -> BigNat# -> Bool

-- | Add a bigNat and a Word#
bigNatAddWord# :: BigNat# -> Word# -> BigNat#

-- | Add a bigNat and a Word
bigNatAddWord :: BigNat# -> Word -> BigNat#

-- | Add two bigNats
bigNatAdd :: BigNat# -> BigNat# -> BigNat#

-- | Multiply a BigNat by a Word#
bigNatMulWord# :: BigNat# -> Word# -> BigNat#

-- | Multiply a BigNAt by a Word
bigNatMulWord :: BigNat# -> Word -> BigNat#

-- | Square a BigNat
bigNatSqr :: BigNat# -> BigNat#

-- | Multiplication (classical algorithm)
bigNatMul :: BigNat# -> BigNat# -> BigNat#

-- | Subtract a Word# from a BigNat
--   
--   The BigNat must be bigger than the Word#.
bigNatSubWordUnsafe# :: BigNat# -> Word# -> BigNat#

-- | Subtract a Word# from a BigNat
--   
--   The BigNat must be bigger than the Word#.
bigNatSubWordUnsafe :: BigNat# -> Word -> BigNat#

-- | Subtract a Word# from a BigNat
bigNatSubWord# :: BigNat# -> Word# -> (# (# #) | BigNat# #)

-- | Subtract two BigNat (don't check if a &gt;= b)
bigNatSubUnsafe :: BigNat# -> BigNat# -> BigNat#

-- | Subtract two BigNat
bigNatSub :: BigNat# -> BigNat# -> (# (# #) | BigNat# #)

-- | Divide a BigNat by a Word, return the quotient
--   
--   Require: b /= 0
bigNatQuotWord# :: BigNat# -> Word# -> BigNat#

-- | Divide a BigNat by a Word, return the quotient
--   
--   Require: b /= 0
bigNatQuotWord :: BigNat# -> Word -> BigNat#

-- | Divide a BigNat by a Word, return the remainder
--   
--   Require: b /= 0
bigNatRemWord# :: BigNat# -> Word# -> Word#

-- | Divide a BigNat by a Word, return the remainder
--   
--   Require: b /= 0
bigNatRemWord :: BigNat# -> Word -> Word

-- | QuotRem a BigNat by a Word
--   
--   Require: b /= 0
bigNatQuotRemWord# :: BigNat# -> Word# -> (# BigNat#, Word# #)

-- | BigNat division returning (quotient,remainder)
bigNatQuotRem# :: BigNat# -> BigNat# -> (# BigNat#, BigNat# #)

-- | BigNat division returning quotient
bigNatQuot :: BigNat# -> BigNat# -> BigNat#

-- | BigNat division returning remainder
bigNatRem :: BigNat# -> BigNat# -> BigNat#

-- | Greatest common divisor between two Word#
gcdWord# :: Word# -> Word# -> Word#

-- | Greatest common divisor between two Word
gcdWord :: Word -> Word -> Word

-- | Greatest common divisor between two Int#
--   
--   <b>Warning</b>: result may become negative if (at least) one argument
--   is <tt>minBound</tt>
gcdInt# :: Int# -> Int# -> Int#

-- | Greatest common divisor between two Int
--   
--   <b>Warning</b>: result may become negative if (at least) one argument
--   is <tt>minBound</tt>
gcdInt :: Int -> Int -> Int

-- | Greatest common divisor
bigNatGcd :: BigNat# -> BigNat# -> BigNat#

-- | Greatest common divisor
bigNatGcdWord# :: BigNat# -> Word# -> Word#

-- | Least common multiple
bigNatLcm :: BigNat# -> BigNat# -> BigNat#

-- | Least common multiple with a Word#
bigNatLcmWord# :: BigNat# -> Word# -> BigNat#

-- | Least common multiple between two Word#
bigNatLcmWordWord# :: Word# -> Word# -> BigNat#

-- | Bitwise OR
bigNatOr :: BigNat# -> BigNat# -> BigNat#

-- | Bitwise OR with Word#
bigNatOrWord# :: BigNat# -> Word# -> BigNat#

-- | Bitwise AND
bigNatAnd :: BigNat# -> BigNat# -> BigNat#

-- | Bitwise ANDNOT
bigNatAndNot :: BigNat# -> BigNat# -> BigNat#

-- | Bitwise AND with Word#
bigNatAndWord# :: BigNat# -> Word# -> BigNat#

-- | Bitwise ANDNOT with Word#
bigNatAndNotWord# :: BigNat# -> Word# -> BigNat#

-- | Bitwise AND with Int#
bigNatAndInt# :: BigNat# -> Int# -> BigNat#

-- | Bitwise XOR
bigNatXor :: BigNat# -> BigNat# -> BigNat#

-- | Bitwise XOR with Word#
bigNatXorWord# :: BigNat# -> Word# -> BigNat#

-- | PopCount for BigNat
bigNatPopCount :: BigNat# -> Word

-- | PopCount for BigNat
bigNatPopCount# :: BigNat# -> Word#

-- | Bit shift right
bigNatShiftR# :: BigNat# -> Word# -> BigNat#

-- | Bit shift right (two's complement)
bigNatShiftRNeg# :: BigNat# -> Word# -> BigNat#

-- | Bit shift right
bigNatShiftR :: BigNat# -> Word -> BigNat#

-- | Bit shift left
bigNatShiftL :: BigNat# -> Word -> BigNat#

-- | Bit shift left
bigNatShiftL# :: BigNat# -> Word# -> BigNat#

-- | BigNat bit test
bigNatTestBit# :: BigNat# -> Word# -> Bool#

-- | BigNat bit test
bigNatTestBit :: BigNat# -> Word -> Bool

-- | Return a BigNat whose bit <tt>i</tt> is the only one set.
--   
--   Specialized version of `bigNatShiftL (bigNatFromWord# 1##)`
bigNatBit# :: Word# -> BigNat#

-- | Return a BigNat whose bit <tt>i</tt> is the only one set.
--   
--   Specialized version of `bigNatShiftL (bigNatFromWord# 1##)`
bigNatBit :: Word -> BigNat#

-- | BigNat clear bit
bigNatClearBit# :: BigNat# -> Word# -> BigNat#

-- | BigNat set bit
bigNatSetBit# :: BigNat# -> Word# -> BigNat#

-- | Reverse the given bit
bigNatComplementBit# :: BigNat# -> Word# -> BigNat#

-- | Base 2 logarithm
bigNatLog2# :: BigNat# -> Word#

-- | Base 2 logarithm
bigNatLog2 :: BigNat# -> Word

-- | Logarithm for an arbitrary base
bigNatLogBase# :: BigNat# -> BigNat# -> Word#

-- | Logarithm for an arbitrary base
bigNatLogBase :: BigNat# -> BigNat# -> Word

-- | Logarithm for an arbitrary base
bigNatLogBaseWord# :: Word# -> BigNat# -> Word#

-- | Logarithm for an arbitrary base
bigNatLogBaseWord :: Word -> BigNat# -> Word

-- | Compute the number of digits of the BigNat in the given base.
--   
--   <tt>base</tt> must be &gt; 1
bigNatSizeInBase# :: Word# -> BigNat# -> Word#

-- | Compute the number of digits of the BigNat in the given base.
--   
--   <tt>base</tt> must be &gt; 1
bigNatSizeInBase :: Word -> BigNat# -> Word
powModWord# :: Word# -> Word# -> Word# -> Word#

-- | "<tt><a>bigNatPowModWord#</a> <i>b</i> <i>e</i> <i>m</i></tt>"
--   computes base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt>
--   modulo <tt><i>m</i></tt>.
bigNatPowModWord# :: BigNat# -> BigNat# -> Word# -> Word#

-- | "<tt><a>bigNatPowMod</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
bigNatPowMod :: BigNat# -> BigNat# -> BigNat# -> BigNat#

-- | Return count of trailing zero bits
--   
--   Return 0 for zero BigNat
bigNatCtz# :: BigNat# -> Word#

-- | Return count of trailing zero bits
--   
--   Return 0 for zero BigNat
bigNatCtz :: BigNat# -> Word

-- | Return count of trailing zero words
--   
--   Return 0 for zero BigNat
bigNatCtzWord# :: BigNat# -> Word#

-- | Return count of trailing zero words
--   
--   Return 0 for zero BigNat
bigNatCtzWord :: BigNat# -> Word

-- | Write a BigNat in base-256 little-endian representation and return the
--   number of bytes written.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToAddrLE# :: BigNat# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Write a BigNat in base-256 big-endian representation and return the
--   number of bytes written.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToAddrBE# :: BigNat# -> Addr# -> State# s -> (# State# s, Word# #)

-- | Write a BigNat in base-256 representation and return the number of
--   bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToAddr# :: BigNat# -> Addr# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write a BigNat in base-256 representation and return the number of
--   bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToAddr :: BigNat# -> Addr# -> Bool# -> IO Word

-- | Read a BigNat in base-256 little-endian representation from an Addr#.
--   
--   The size is given in bytes.
--   
--   Higher limbs equal to 0 are automatically trimmed.
bigNatFromAddrLE# :: Word# -> Addr# -> State# s -> (# State# s, BigNat# #)

-- | Read a BigNat in base-256 big-endian representation from an Addr#.
--   
--   The size is given in bytes.
--   
--   Null higher limbs are automatically trimmed.
bigNatFromAddrBE# :: Word# -> Addr# -> State# s -> (# State# s, BigNat# #)

-- | Read a BigNat in base-256 representation from an Addr#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimmed.
bigNatFromAddr# :: Word# -> Addr# -> Bool# -> State# s -> (# State# s, BigNat# #)

-- | Write a BigNat in base-256 little-endian representation and return the
--   number of bytes written.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToMutableByteArrayLE# :: BigNat# -> MutableByteArray# s -> Word# -> State# s -> (# State# s, Word# #)

-- | Write a BigNat in base-256 big-endian representation and return the
--   number of bytes written.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToMutableByteArrayBE# :: BigNat# -> MutableByteArray# s -> Word# -> State# s -> (# State# s, Word# #)

-- | Write a BigNat in base-256 representation and return the number of
--   bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Use "<tt><a>bigNatSizeInBase</a> 256# <i>i</i></tt>" to compute the
--   exact number of bytes written in advance. In case of <tt><i>i</i> ==
--   0</tt>, the function will write and report zero bytes written.
bigNatToMutableByteArray# :: BigNat# -> MutableByteArray# s -> Word# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Read a BigNat in base-256 little-endian representation from a
--   ByteArray#.
--   
--   The size is given in bytes.
--   
--   Null higher limbs are automatically trimmed.
bigNatFromByteArrayLE# :: Word# -> ByteArray# -> Word# -> State# s -> (# State# s, BigNat# #)

-- | Read a BigNat in base-256 big-endian representation from a ByteArray#.
--   
--   The size is given in bytes.
--   
--   Null higher limbs are automatically trimmed.
bigNatFromByteArrayBE# :: Word# -> ByteArray# -> Word# -> State# s -> (# State# s, BigNat# #)

-- | Read a BigNat in base-256 representation from a ByteArray#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimmed.
bigNatFromByteArray# :: Word# -> ByteArray# -> Word# -> Bool# -> State# s -> (# State# s, BigNat# #)

-- | Create a BigNat# from a WordArray# containing <i>n</i> limbs in
--   least-significant-first order.
--   
--   If possible <a>WordArray#</a>, will be used directly (i.e. shared
--   <i>without</i> cloning the <a>WordArray#</a> into a newly allocated
--   one)
bigNatFromWordArray# :: WordArray# -> Word# -> BigNat#

-- | Create a BigNat from a WordArray# containing <i>n</i> limbs in
--   least-significant-first order.
--   
--   If possible <a>WordArray#</a>, will be used directly (i.e. shared
--   <i>without</i> cloning the <a>WordArray#</a> into a newly allocated
--   one)
bigNatFromWordArray :: WordArray# -> Word# -> BigNat
instance GHC.Classes.Eq GHC.Num.BigNat.BigNat
instance GHC.Classes.Ord GHC.Num.BigNat.BigNat

module GHC.Num.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data Natural
NS :: !Word# -> Natural
NB :: !BigNat# -> Natural

-- | Check Natural invariants
naturalCheck# :: Natural -> Bool#

-- | Check Natural invariants
naturalCheck :: Natural -> Bool

-- | Zero Natural
naturalZero :: Natural

-- | One Natural
naturalOne :: Natural

-- | Test Zero Natural
naturalIsZero :: Natural -> Bool

-- | Test One Natural
naturalIsOne :: Natural -> Bool

-- | Indicate if the value is a power of two and which one
naturalIsPowerOf2# :: Natural -> (# (# #) | Word# #)

-- | Create a Natural from a BigNat# (respect the invariants)
naturalFromBigNat# :: BigNat# -> Natural

-- | Convert a Natural into a BigNat#
naturalToBigNat# :: Natural -> BigNat#

-- | Create a Natural from a Word#
naturalFromWord# :: Word# -> Natural

-- | Convert two Word# (most-significant first) into a Natural
naturalFromWord2# :: Word# -> Word# -> Natural

-- | Create a Natural from a Word
naturalFromWord :: Word -> Natural

-- | Create a Natural from a list of Word
naturalFromWordList :: [Word] -> Natural

-- | Convert the lower bits of a Natural into a Word#
naturalToWord# :: Natural -> Word#

-- | Convert the lower bits of a Natural into a Word
naturalToWord :: Natural -> Word

-- | Convert a Natural into a Word# clamping to (maxBound :: Word#).
naturalToWordClamp# :: Natural -> Word#

-- | Convert a Natural into a Word# clamping to (maxBound :: Word).
naturalToWordClamp :: Natural -> Word

-- | Try downcasting <a>Natural</a> to <a>Word</a> value. Returns
--   <tt>(##)</tt> if value doesn't fit in <a>Word</a>.
naturalToWordMaybe# :: Natural -> (# (# #) | Word# #)

-- | Encode (# Natural mantissa, Int# exponent #) into a Double#
naturalEncodeDouble# :: Natural -> Int# -> Double#

-- | Encode (# Natural mantissa, Int# exponent #) into a Float#
--   
--   TODO: Not sure if it's worth to write <a>Float</a> optimized versions
--   here
naturalEncodeFloat# :: Natural -> Int# -> Float#

-- | Equality test for Natural
naturalEq# :: Natural -> Natural -> Bool#

-- | Equality test for Natural
naturalEq :: Natural -> Natural -> Bool

-- | Inequality test for Natural
naturalNe# :: Natural -> Natural -> Bool#

-- | Inequality test for Natural
naturalNe :: Natural -> Natural -> Bool

-- | Greater or equal test for Natural
naturalGe# :: Natural -> Natural -> Bool#

-- | Greater or equal test for Natural
naturalGe :: Natural -> Natural -> Bool

-- | Lower or equal test for Natural
naturalLe# :: Natural -> Natural -> Bool#

-- | Lower or equal test for Natural
naturalLe :: Natural -> Natural -> Bool

-- | Greater test for Natural
naturalGt# :: Natural -> Natural -> Bool#

-- | Greater test for Natural
naturalGt :: Natural -> Natural -> Bool

-- | Lower test for Natural
naturalLt# :: Natural -> Natural -> Bool#

-- | Lower test for Natural
naturalLt :: Natural -> Natural -> Bool

-- | Compare two Natural
naturalCompare :: Natural -> Natural -> Ordering

-- | PopCount for Natural
naturalPopCount# :: Natural -> Word#

-- | PopCount for Natural
naturalPopCount :: Natural -> Word

-- | Right shift for Natural
naturalShiftR# :: Natural -> Word# -> Natural

-- | Right shift for Natural
naturalShiftR :: Natural -> Word -> Natural

-- | Left shift
naturalShiftL# :: Natural -> Word# -> Natural

-- | Left shift
naturalShiftL :: Natural -> Word -> Natural

-- | Add two naturals
naturalAdd :: Natural -> Natural -> Natural

-- | Sub two naturals
naturalSub :: Natural -> Natural -> (# (# #) | Natural #)

-- | Sub two naturals
--   
--   Throw an Underflow exception if x &lt; y
naturalSubThrow :: Natural -> Natural -> Natural

-- | Sub two naturals
--   
--   Unsafe: don't check that x &gt;= y Undefined results if it happens
naturalSubUnsafe :: Natural -> Natural -> Natural

-- | Multiplication
naturalMul :: Natural -> Natural -> Natural

-- | Square a Natural
naturalSqr :: Natural -> Natural

-- | Signum for Natural
naturalSignum :: Natural -> Natural

-- | Negate for Natural
naturalNegate :: Natural -> Natural

-- | Return division quotient and remainder
--   
--   Division by zero is handled by BigNat
naturalQuotRem# :: Natural -> Natural -> (# Natural, Natural #)

-- | Return division quotient and remainder
naturalQuotRem :: Natural -> Natural -> (Natural, Natural)

-- | Return division quotient
naturalQuot :: Natural -> Natural -> Natural

-- | Return division remainder
naturalRem :: Natural -> Natural -> Natural
naturalAnd :: Natural -> Natural -> Natural
naturalAndNot :: Natural -> Natural -> Natural
naturalOr :: Natural -> Natural -> Natural
naturalXor :: Natural -> Natural -> Natural
naturalTestBit# :: Natural -> Word# -> Bool#
naturalTestBit :: Natural -> Word -> Bool
naturalBit# :: Word# -> Natural
naturalBit :: Word -> Natural

naturalSetBit# :: Natural -> Word# -> Natural

naturalSetBit :: Natural -> Word -> Natural

naturalClearBit# :: Natural -> Word# -> Natural

naturalClearBit :: Natural -> Word -> Natural

naturalComplementBit# :: Natural -> Word# -> Natural

naturalComplementBit :: Natural -> Word -> Natural

-- | Compute greatest common divisor.
naturalGcd :: Natural -> Natural -> Natural

-- | Compute least common multiple.
naturalLcm :: Natural -> Natural -> Natural

-- | Base 2 logarithm
naturalLog2# :: Natural -> Word#

-- | Base 2 logarithm
naturalLog2 :: Natural -> Word

-- | Logarithm for an arbitrary base
naturalLogBaseWord# :: Word# -> Natural -> Word#

-- | Logarithm for an arbitrary base
naturalLogBaseWord :: Word -> Natural -> Word

-- | Logarithm for an arbitrary base
naturalLogBase# :: Natural -> Natural -> Word#

-- | Logarithm for an arbitrary base
naturalLogBase :: Natural -> Natural -> Word

-- | "<tt><a>naturalPowMod</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
naturalPowMod :: Natural -> Natural -> Natural -> Natural

-- | Compute the number of digits of the Natural in the given base.
--   
--   <tt>base</tt> must be &gt; 1
naturalSizeInBase# :: Word# -> Natural -> Word#

-- | Write a <a>Natural</a> to <tt><i>addr</i></tt> in base-256
--   representation and return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
naturalToAddr# :: Natural -> Addr# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write a <a>Natural</a> to <tt><i>addr</i></tt> in base-256
--   representation and return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
naturalToAddr :: Natural -> Addr# -> Bool# -> IO Word

-- | Read a Natural in base-256 representation from an Addr#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
naturalFromAddr# :: Word# -> Addr# -> Bool# -> State# s -> (# State# s, Natural #)

-- | Read a Natural in base-256 representation from an Addr#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
naturalFromAddr :: Word# -> Addr# -> Bool# -> IO Natural

-- | Write a Natural in base-256 representation and return the number of
--   bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
naturalToMutableByteArray# :: Natural -> MutableByteArray# s -> Word# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Read a Natural in base-256 representation from a ByteArray#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
naturalFromByteArray# :: Word# -> ByteArray# -> Word# -> Bool# -> State# s -> (# State# s, Natural #)
instance GHC.Classes.Eq GHC.Num.Natural.Natural
instance GHC.Classes.Ord GHC.Num.Natural.Natural


-- | The <a>Integer</a> type.
module GHC.Num.Integer

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data Integer

-- | iff value in <tt>[minBound::<a>Int</a>, maxBound::<a>Int</a>]</tt>
--   range
IS :: !Int# -> Integer

-- | iff value in <tt>]maxBound::<a>Int</a>, +inf[</tt> range
IP :: !BigNat# -> Integer

-- | iff value in <tt>]-inf, minBound::<a>Int</a>[</tt> range
IN :: !BigNat# -> Integer

-- | Check Integer invariants
integerCheck# :: Integer -> Bool#

-- | Check Integer invariants
integerCheck :: Integer -> Bool

-- | Integer Zero
integerZero :: Integer

-- | Integer One
integerOne :: Integer

-- | Create a positive Integer from a BigNat
integerFromBigNat# :: BigNat# -> Integer

-- | Create a negative Integer from a BigNat
integerFromBigNatNeg# :: BigNat# -> Integer

-- | Create an Integer from a sign-bit and a BigNat
integerFromBigNatSign# :: Int# -> BigNat# -> Integer

-- | Convert an Integer into a sign-bit and a BigNat
integerToBigNatSign# :: Integer -> (# Int#, BigNat# #)

-- | Convert an Integer into a BigNat.
--   
--   Return 0 for negative Integers.
integerToBigNatClamp# :: Integer -> BigNat#

-- | Create an Integer from an Int#
integerFromInt# :: Int# -> Integer

-- | Create an Integer from an Int
integerFromInt :: Int -> Integer

-- | Truncates <a>Integer</a> to least-significant <a>Int#</a>
integerToInt# :: Integer -> Int#

-- | Truncates <a>Integer</a> to least-significant <a>Int#</a>
integerToInt :: Integer -> Int

-- | Convert a Word# into an Integer
integerFromWord# :: Word# -> Integer

-- | Convert a Word into an Integer
integerFromWord :: Word -> Integer

-- | Create a negative Integer with the given Word magnitude
integerFromWordNeg# :: Word# -> Integer

-- | Create an Integer from a sign and a Word magnitude
integerFromWordSign# :: Int# -> Word# -> Integer

-- | Truncate an Integer into a Word
integerToWord# :: Integer -> Word#

-- | Truncate an Integer into a Word
integerToWord :: Integer -> Word

-- | Convert a Natural into an Integer
integerFromNatural :: Natural -> Integer

-- | Convert a list of Word into an Integer
integerFromWordList :: Bool -> [Word] -> Integer

-- | Convert an Integer into a Natural
--   
--   Return 0 for negative Integers.
integerToNaturalClamp :: Integer -> Natural

-- | Convert an Integer into a Natural
--   
--   Return absolute value
integerToNatural :: Integer -> Natural

-- | Convert an Integer into a Natural
--   
--   Throw an Underflow exception if input is negative.
integerToNaturalThrow :: Integer -> Natural

-- | Negative predicate
integerIsNegative# :: Integer -> Bool#

-- | Negative predicate
integerIsNegative :: Integer -> Bool

-- | Zero predicate
integerIsZero :: Integer -> Bool

-- | One predicate
integerIsOne :: Integer -> Bool

-- | Not-equal predicate.
integerNe :: Integer -> Integer -> Bool

-- | Equal predicate.
integerEq :: Integer -> Integer -> Bool

-- | Lower-or-equal predicate.
integerLe :: Integer -> Integer -> Bool

-- | Lower predicate.
integerLt :: Integer -> Integer -> Bool

-- | Greater predicate.
integerGt :: Integer -> Integer -> Bool

-- | Greater-or-equal predicate.
integerGe :: Integer -> Integer -> Bool

-- | Equal predicate.
integerEq# :: Integer -> Integer -> Bool#

-- | Not-equal predicate.
integerNe# :: Integer -> Integer -> Bool#

-- | Greater predicate.
integerGt# :: Integer -> Integer -> Bool#

-- | Lower-or-equal predicate.
integerLe# :: Integer -> Integer -> Bool#

-- | Lower predicate.
integerLt# :: Integer -> Integer -> Bool#

-- | Greater-or-equal predicate.
integerGe# :: Integer -> Integer -> Bool#

-- | Compare two Integer
integerCompare :: Integer -> Integer -> Ordering

-- | Subtract one <a>Integer</a> from another.
integerSub :: Integer -> Integer -> Integer

-- | Add two <a>Integer</a>s
integerAdd :: Integer -> Integer -> Integer

-- | Multiply two <a>Integer</a>s
integerMul :: Integer -> Integer -> Integer

-- | Negate <a>Integer</a>.
--   
--   One edge-case issue to take into account is that Int's range is not
--   symmetric around 0. I.e. <tt>minBound+maxBound = -1</tt>
--   
--   IP is used iff n &gt; maxBound::Int IN is used iff n &lt;
--   minBound::Int
integerNegate :: Integer -> Integer

-- | Compute absolute value of an <a>Integer</a>
integerAbs :: Integer -> Integer

-- | Return <tt>-1</tt>, <tt>0</tt>, and <tt>1</tt> depending on whether
--   argument is negative, zero, or positive, respectively
integerSignum :: Integer -> Integer

-- | Return <tt>-1#</tt>, <tt>0#</tt>, and <tt>1#</tt> depending on whether
--   argument is negative, zero, or positive, respectively
integerSignum# :: Integer -> Int#

-- | Count number of set bits. For negative arguments returns the negated
--   population count of the absolute value.
integerPopCount# :: Integer -> Int#

-- | Positive <a>Integer</a> for which only <i>n</i>-th bit is set
integerBit# :: Word# -> Integer

-- | <a>Integer</a> for which only <i>n</i>-th bit is set
integerBit :: Word -> Integer

-- | Test if <i>n</i>-th bit is set.
--   
--   Fake 2's complement for negative values (might be slow)
integerTestBit# :: Integer -> Word# -> Bool#

-- | Test if <i>n</i>-th bit is set. For negative Integers it tests the
--   n-th bit of the negated argument.
--   
--   Fake 2's complement for negative values (might be slow)
integerTestBit :: Integer -> Word -> Bool

-- | Shift-right operation
--   
--   Fake 2's complement for negative values (might be slow)
integerShiftR# :: Integer -> Word# -> Integer

-- | Shift-right operation
--   
--   Fake 2's complement for negative values (might be slow)
integerShiftR :: Integer -> Word -> Integer

-- | Shift-left operation
integerShiftL# :: Integer -> Word# -> Integer

-- | Shift-left operation
--   
--   Remember that bits are stored in sign-magnitude form, hence the
--   behavior of negative Integers is different from negative Int's
--   behavior.
integerShiftL :: Integer -> Word -> Integer

-- | Bitwise OR operation
--   
--   Fake 2's complement for negative values (might be slow)
integerOr :: Integer -> Integer -> Integer

-- | Bitwise XOR operation
--   
--   Fake 2's complement for negative values (might be slow)
integerXor :: Integer -> Integer -> Integer

-- | Bitwise AND operation
--   
--   Fake 2's complement for negative values (might be slow)
integerAnd :: Integer -> Integer -> Integer

-- | Binary complement of the
integerComplement :: Integer -> Integer

-- | Simultaneous <a>integerQuot</a> and <a>integerRem</a>.
--   
--   Divisor must be non-zero otherwise the GHC runtime will terminate with
--   a division-by-zero fault.
integerQuotRem# :: Integer -> Integer -> (# Integer, Integer #)

-- | Simultaneous <a>integerQuot</a> and <a>integerRem</a>.
--   
--   Divisor must be non-zero otherwise the GHC runtime will terminate with
--   a division-by-zero fault.
integerQuotRem :: Integer -> Integer -> (Integer, Integer)
integerQuot :: Integer -> Integer -> Integer
integerRem :: Integer -> Integer -> Integer

-- | Simultaneous <a>integerDiv</a> and <a>integerMod</a>.
--   
--   Divisor must be non-zero otherwise the GHC runtime will terminate with
--   a division-by-zero fault.
integerDivMod# :: Integer -> Integer -> (# Integer, Integer #)

-- | Simultaneous <a>integerDiv</a> and <a>integerMod</a>.
--   
--   Divisor must be non-zero otherwise the GHC runtime will terminate with
--   a division-by-zero fault.
integerDivMod :: Integer -> Integer -> (Integer, Integer)
integerDiv :: Integer -> Integer -> Integer
integerMod :: Integer -> Integer -> Integer

-- | Compute greatest common divisor.
integerGcd :: Integer -> Integer -> Integer

-- | Compute least common multiple.
integerLcm :: Integer -> Integer -> Integer

-- | Square a Integer
integerSqr :: Integer -> Integer

-- | Base 2 logarithm (floor)
--   
--   For numbers &lt;= 0, return 0
integerLog2# :: Integer -> Word#

-- | Base 2 logarithm (floor)
--   
--   For numbers &lt;= 0, return 0
integerLog2 :: Integer -> Word

-- | Logarithm (floor) for an arbitrary base
--   
--   For numbers &lt;= 0, return 0
integerLogBaseWord# :: Word# -> Integer -> Word#

-- | Logarithm (floor) for an arbitrary base
--   
--   For numbers &lt;= 0, return 0
integerLogBaseWord :: Word -> Integer -> Word

-- | Logarithm (floor) for an arbitrary base
--   
--   For numbers &lt;= 0, return 0
integerLogBase# :: Integer -> Integer -> Word#

-- | Logarithm (floor) for an arbitrary base
--   
--   For numbers &lt;= 0, return 0
integerLogBase :: Integer -> Integer -> Word

-- | Indicate if the value is a power of two and which one
integerIsPowerOf2# :: Integer -> (# (# #) | Word# #)

-- | Convert an Int64# into an Integer
integerFromInt64# :: Int64# -> Integer

-- | Convert a Word64# into an Integer
integerFromWord64# :: Word64# -> Integer

-- | Convert an Integer into an Int64#
integerToInt64# :: Integer -> Int64#

-- | Convert an Integer into a Word64#
integerToWord64# :: Integer -> Word64#

-- | Decode a Double# into (# Integer mantissa, Int# exponent #)
integerDecodeDouble# :: Double# -> (# Integer, Int# #)

-- | Encode (# Integer mantissa, Int# exponent #) into a Double#
integerEncodeDouble# :: Integer -> Int# -> Double#

-- | Encode (Integer mantissa, Int exponent) into a Double
integerEncodeDouble :: Integer -> Int -> Double

-- | Encode (# Integer mantissa, Int# exponent #) into a Float#
--   
--   TODO: Not sure if it's worth to write <a>Float</a> optimized versions
--   here
integerEncodeFloat# :: Integer -> Int# -> Float#

-- | Compute the number of digits of the Integer (without the sign) in the
--   given base.
--   
--   <tt>base</tt> must be &gt; 1
integerSizeInBase# :: Word# -> Integer -> Word#

-- | Write an <a>Integer</a> (without sign) to <tt><i>addr</i></tt> in
--   base-256 representation and return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
integerToAddr# :: Integer -> Addr# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write an <a>Integer</a> (without sign) to <tt><i>addr</i></tt> in
--   base-256 representation and return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: write most
--   significant byte first (big-endian) if <tt>1#</tt> or least
--   significant byte first (little-endian) if <tt>0#</tt>.
integerToAddr :: Integer -> Addr# -> Bool# -> IO Word

-- | Read an <a>Integer</a> (without sign) in base-256 representation from
--   an Addr#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
integerFromAddr# :: Word# -> Addr# -> Bool# -> State# s -> (# State# s, Integer #)

-- | Read an <a>Integer</a> (without sign) in base-256 representation from
--   an Addr#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
integerFromAddr :: Word# -> Addr# -> Bool# -> IO Integer

-- | Write an <a>Integer</a> (without sign) in base-256 representation and
--   return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
integerToMutableByteArray# :: Integer -> MutableByteArray# s -> Word# -> Bool# -> State# s -> (# State# s, Word# #)

-- | Write an <a>Integer</a> (without sign) in base-256 representation and
--   return the number of bytes written.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
integerToMutableByteArray :: Integer -> MutableByteArray# RealWorld -> Word# -> Bool# -> IO Word

-- | Read an <a>Integer</a> (without sign) in base-256 representation from
--   a ByteArray#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
integerFromByteArray# :: Word# -> ByteArray# -> Word# -> Bool# -> State# s -> (# State# s, Integer #)

-- | Read an <a>Integer</a> (without sign) in base-256 representation from
--   a ByteArray#.
--   
--   The size is given in bytes.
--   
--   The endianness is selected with the Bool# parameter: most significant
--   byte first (big-endian) if <tt>1#</tt> or least significant byte first
--   (little-endian) if <tt>0#</tt>.
--   
--   Null higher limbs are automatically trimed.
integerFromByteArray :: Word# -> ByteArray# -> Word# -> Bool# -> Integer

-- | Get the extended GCD of two integers.
--   
--   `integerGcde# a b` returns (# g,x,y #) where * ax + by = g = |gcd a b|
integerGcde# :: Integer -> Integer -> (# Integer, Integer, Integer #)

-- | Get the extended GCD of two integers.
--   
--   `integerGcde a b` returns (g,x,y) where * ax + by = g = |gcd a b|
integerGcde :: Integer -> Integer -> (Integer, Integer, Integer)

-- | Computes the modular inverse.
--   
--   I.e. y = integerRecipMod# x m = x^(-1) <tt>mod</tt> m
--   
--   with 0 &lt; y &lt; |m|
integerRecipMod# :: Integer -> Natural -> (# Natural | () #)

-- | Computes the modular exponentiation.
--   
--   I.e. y = integer_powmod b e m = b^e <tt>mod</tt> m
--   
--   with 0 &lt;= y &lt; abs m
--   
--   If e is negative, we use <a>integerRecipMod#</a> to try to find a
--   modular multiplicative inverse (which may not exist).
integerPowMod# :: Integer -> Integer -> Natural -> (# Natural | () #)
instance GHC.Classes.Eq GHC.Num.Integer.Integer
instance GHC.Classes.Ord GHC.Num.Integer.Integer

module GHC.Num.Backend.Native

-- | ghc-bignum backend name
backendName :: [Char]
count_words_bits :: Word# -> (# Word#, Word# #)
count_words_bits_int :: Word# -> (# Int#, Int# #)
bignat_compare :: WordArray# -> WordArray# -> Int#
bignat_add :: MutableWordArray# s -> WordArray# -> WordArray# -> State# s -> State# s
bignat_add_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_sub_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> (# State# RealWorld, Bool# #)
bignat_mul_word :: MutableWordArray# RealWorld -> WordArray# -> Word# -> State# RealWorld -> State# RealWorld
bignat_mul :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_sub :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> (# State# RealWorld, Bool# #)
bignat_popcount :: WordArray# -> Word#
bignat_shiftl :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> State# s
bignat_shiftr :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> State# s
bignat_shiftr_neg :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> State# s
bignat_or :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_xor :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_and :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_and_not :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_quotrem :: MutableWordArray# s -> MutableWordArray# s -> WordArray# -> WordArray# -> State# s -> State# s
bignat_quot :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_rem :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld

-- | Perform quotRem on normalized inputs: * highest bit of B is set * A is
--   trimmed * A &gt;= B * B &gt; 1
bignat_quotrem_normalized :: MutableWordArray# s -> MutableWordArray# s -> WordArray# -> State# s -> State# s
bignat_quotrem_word :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> (# State# s, Word# #)
bignat_quot_word :: MutableWordArray# s -> WordArray# -> Word# -> State# s -> State# s
bignat_rem_word :: WordArray# -> Word# -> Word#
bignat_gcd :: MutableWordArray# s -> WordArray# -> WordArray# -> State# s -> State# s
bignat_gcd_word :: WordArray# -> Word# -> Word#

-- | This operation doesn't really belongs here, but GMP's one is much
--   faster than this simple implementation (basic Euclid algorithm).
--   
--   Ideally we should make an implementation as fast as GMP's one and put
--   it into GHC.Num.Primitives.
bignat_gcd_word_word :: Word# -> Word# -> Word#
bignat_encode_double :: WordArray# -> Int# -> Double#
bignat_powmod_word :: WordArray# -> WordArray# -> Word# -> Word#
bignat_powmod :: MutableWordArray# RealWorld -> WordArray# -> WordArray# -> WordArray# -> State# RealWorld -> State# RealWorld
bignat_powmod_words :: Word# -> Word# -> Word# -> Word#
integer_gcde :: Integer -> Integer -> (# Integer, Integer, Integer #)
integer_recip_mod :: Integer -> Natural -> (# Natural | () #)
integer_powmod :: Integer -> Natural -> Natural -> Natural
