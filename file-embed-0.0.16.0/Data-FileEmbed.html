<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.FileEmbed</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">file-embed-0.0.16.0: Use Template Haskell to embed file contents directly.</span><ul class="links" id="page-menu"><li><a href="src/Data.FileEmbed.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.FileEmbed</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Embed at compile time</a></li><li><a href="#g:2">Embed as a IsString</a></li><li><a href="#g:3">Inject into an executable</a></li><li><a href="#g:4">Relative path manipulation</a></li><li><a href="#g:5">Internal</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module uses template Haskell. Following is a simplified explanation of usage for those unfamiliar with calling Template Haskell functions.</p><p>The function <code>embedFile</code> in this modules embeds a file into the executable
 that you can use it at runtime. A file is represented as a <code>ByteString</code>.
 However, as you can see below, the type signature indicates a value of type
 <code>Q Exp</code> will be returned. In order to convert this into a <code>ByteString</code>, you
 must use Template Haskell syntax, e.g.:</p><pre>$(embedFile &quot;myfile.txt&quot;)</pre><p>This expression will have type <code>ByteString</code>. Be certain to enable the
 TemplateHaskell language extension, usually by adding the following to the
 top of your module:</p><pre>{-# LANGUAGE TemplateHaskell #-}</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:embedFile">embedFile</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedFileRelative">embedFileRelative</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedFileIfExists">embedFileIfExists</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedOneFileOf">embedOneFileOf</a> :: [<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>] -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedDir">embedDir</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedDirListing">embedDirListing</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:getDir">getDir</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> [(<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)]</li><li class="src short"><a href="#v:embedStringFile">embedStringFile</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:embedOneStringFileOf">embedOneStringFileOf</a> :: [<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>] -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:dummySpace">dummySpace</a> :: <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:dummySpaceWith">dummySpaceWith</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:inject">inject</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li><li class="src short"><a href="#v:injectFile">injectFile</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:injectWith">injectWith</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li><li class="src short"><a href="#v:injectFileWith">injectFileWith</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:makeRelativeToProject">makeRelativeToProject</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></li><li class="src short"><a href="#v:makeRelativeToLocationPredicate">makeRelativeToLocationPredicate</a> :: (<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></li><li class="src short"><a href="#v:stringToBs">stringToBs</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li><li class="src short"><a href="#v:bsToExp">bsToExp</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:strToExp">strToExp</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Embed at compile time</h1></a><div class="top"><p class="src"><a id="v:embedFile" class="def">embedFile</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedFile" class="link">Source</a> <a href="#v:embedFile" class="selflink">#</a></p><div class="doc"><p>Embed a single file in your source code.</p><pre>import qualified Data.ByteString

myFile :: Data.ByteString.ByteString
myFile = $(embedFile &quot;dirName/fileName&quot;)</pre></div></div><div class="top"><p class="src"><a id="v:embedFileRelative" class="def">embedFileRelative</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedFileRelative" class="link">Source</a> <a href="#v:embedFileRelative" class="selflink">#</a></p><div class="doc"><p>Embed a single file in your source code.
   Unlike <code><a href="Data-FileEmbed.html#v:embedFile" title="Data.FileEmbed">embedFile</a></code>, path is given relative to project root.
 @since 0.0.16.0</p></div></div><div class="top"><p class="src"><a id="v:embedFileIfExists" class="def">embedFileIfExists</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedFileIfExists" class="link">Source</a> <a href="#v:embedFileIfExists" class="selflink">#</a></p><div class="doc"><p>Maybe embed a single file in your source code depending on whether or not file exists.</p><p>Warning: When a build is compiled with the file missing, a recompile when the file exists might not trigger an embed of the file.
 You might try to fix this by doing a clean build.</p><pre>import qualified Data.ByteString

maybeMyFile :: Maybe Data.ByteString.ByteString
maybeMyFile = $(embedFileIfExists &quot;dirName/fileName&quot;)</pre><p><em>Since: 0.0.14.0</em></p></div></div><div class="top"><p class="src"><a id="v:embedOneFileOf" class="def">embedOneFileOf</a> :: [<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>] -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedOneFileOf" class="link">Source</a> <a href="#v:embedOneFileOf" class="selflink">#</a></p><div class="doc"><p>Embed a single existing file in your source code
 out of list a list of paths supplied.</p><pre>import qualified Data.ByteString

myFile :: Data.ByteString.ByteString
myFile = $(embedOneFileOf [ &quot;dirName/fileName&quot;, &quot;src/dirName/fileName&quot; ])</pre></div></div><div class="top"><p class="src"><a id="v:embedDir" class="def">embedDir</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedDir" class="link">Source</a> <a href="#v:embedDir" class="selflink">#</a></p><div class="doc"><p>Embed a directory recursively in your source code.</p><pre>import qualified Data.ByteString

myDir :: [(FilePath, Data.ByteString.ByteString)]
myDir = $(embedDir &quot;dirName&quot;)</pre></div></div><div class="top"><p class="src"><a id="v:embedDirListing" class="def">embedDirListing</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedDirListing" class="link">Source</a> <a href="#v:embedDirListing" class="selflink">#</a></p><div class="doc"><p>Embed a directory listing recursively in your source code.</p><pre>myFiles :: [FilePath]
myFiles = $(embedDirListing &quot;dirName&quot;)</pre><p><em>Since: 0.0.11</em></p></div></div><div class="top"><p class="src"><a id="v:getDir" class="def">getDir</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> [(<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)] <a href="src/Data.FileEmbed.html#getDir" class="link">Source</a> <a href="#v:getDir" class="selflink">#</a></p><div class="doc"><p>Get a directory tree in the IO monad.</p><p>This is the workhorse of <code><a href="Data-FileEmbed.html#v:embedDir" title="Data.FileEmbed">embedDir</a></code></p></div></div><a href="#g:2" id="g:2"><h1>Embed as a IsString</h1></a><div class="top"><p class="src"><a id="v:embedStringFile" class="def">embedStringFile</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedStringFile" class="link">Source</a> <a href="#v:embedStringFile" class="selflink">#</a></p><div class="doc"><p>Embed a single file in your source code.</p><pre>import Data.String

myFile :: IsString a =&gt; a
myFile = $(embedStringFile &quot;dirName/fileName&quot;)</pre><p>Since 0.0.9</p></div></div><div class="top"><p class="src"><a id="v:embedOneStringFileOf" class="def">embedOneStringFileOf</a> :: [<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a>] -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#embedOneStringFileOf" class="link">Source</a> <a href="#v:embedOneStringFileOf" class="selflink">#</a></p><div class="doc"><p>Embed a single existing string file in your source code
 out of list a list of paths supplied.</p><p>Since 0.0.9</p></div></div><a href="#g:3" id="g:3"><h1>Inject into an executable</h1></a><div class="doc"><p>The inject system allows arbitrary content to be embedded inside a Haskell
executable, post compilation. Typically, file-embed allows you to read some
contents from the file system at compile time and embed them inside your
executable. Consider a case, instead, where you would want to embed these
contents after compilation. Two real-world examples are:</p><ul><li>You would like to embed a hash of the executable itself, for sanity checking in a network protocol. (Obviously the hash will change after you embed the hash.)</li><li>You want to create a self-contained web server that has a set of content, but will need to update the content on machines that do not have access to GHC.</li></ul><p>The typical workflow use:</p><ul><li>Use <code><a href="Data-FileEmbed.html#v:dummySpace" title="Data.FileEmbed">dummySpace</a></code> or <code><a href="Data-FileEmbed.html#v:dummySpaceWith" title="Data.FileEmbed">dummySpaceWith</a></code> to create some empty space in your executable</li><li>Use <code><a href="Data-FileEmbed.html#v:injectFile" title="Data.FileEmbed">injectFile</a></code> or <code><a href="Data-FileEmbed.html#v:injectFileWith" title="Data.FileEmbed">injectFileWith</a></code> from a separate utility to modify that executable to have the updated content.</li></ul><p>The reason for the <code>With</code>-variant of the functions is for cases where you wish
to inject multiple different kinds of content, and therefore need control over
the magic key. If you know for certain that there will only be one dummy space
available, you can use the non-<code>With</code> variants.</p></div><div class="top"><p class="src"><a id="v:dummySpace" class="def">dummySpace</a> :: <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#dummySpace" class="link">Source</a> <a href="#v:dummySpace" class="selflink">#</a></p><div class="doc"><p>Allocate the given number of bytes in the generate executable. That space
 can be filled up with the <code><a href="Data-FileEmbed.html#v:inject" title="Data.FileEmbed">inject</a></code> and <code><a href="Data-FileEmbed.html#v:injectFile" title="Data.FileEmbed">injectFile</a></code> functions.</p></div></div><div class="top"><p class="src"><a id="v:dummySpaceWith" class="def">dummySpaceWith</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#dummySpaceWith" class="link">Source</a> <a href="#v:dummySpaceWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-FileEmbed.html#v:dummySpace" title="Data.FileEmbed">dummySpace</a></code>, but takes a postfix for the magic string.  In
 order for this to work, the same postfix must be used by <code><a href="Data-FileEmbed.html#v:inject" title="Data.FileEmbed">inject</a></code> /
 <code><a href="Data-FileEmbed.html#v:injectFile" title="Data.FileEmbed">injectFile</a></code>.  This allows an executable to have multiple
 <code>ByteString</code>s injected into it, without encountering collisions.</p><p>Since 0.0.8</p></div></div><div class="top"><p class="src"><a id="v:inject" class="def">inject</a> <a href="src/Data.FileEmbed.html#inject" class="link">Source</a> <a href="#v:inject" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>bs to inject</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>original BS containing dummy</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>new BS, or Nothing if there is insufficient dummy space</p></td></tr></table></div><div class="doc"><p>Inject some raw data inside a <code>ByteString</code> containing empty, dummy space
 (allocated with <code>dummySpace</code>). Typically, the original <code>ByteString</code> is an
 executable read from the filesystem.</p></div></div><div class="top"><p class="src"><a id="v:injectFile" class="def">injectFile</a> <a href="src/Data.FileEmbed.html#injectFile" class="link">Source</a> <a href="#v:injectFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>bs to inject</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></td><td class="doc"><p>template file</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></td><td class="doc"><p>output file</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Data-FileEmbed.html#v:inject" title="Data.FileEmbed">inject</a></code>, but instead of performing the injecting in memory, read
 the contents from the filesystem and write back to a different file on the
 filesystem.</p></div></div><div class="top"><p class="src"><a id="v:injectWith" class="def">injectWith</a> <a href="src/Data.FileEmbed.html#injectWith" class="link">Source</a> <a href="#v:injectWith" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>postfix of magic string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>bs to inject</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>original BS containing dummy</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>new BS, or Nothing if there is insufficient dummy space</p></td></tr></table></div><div class="doc"><p>Like <code><a href="Data-FileEmbed.html#v:inject" title="Data.FileEmbed">inject</a></code>, but takes a postfix for the magic string.</p><p>Since 0.0.8</p></div></div><div class="top"><p class="src"><a id="v:injectFileWith" class="def">injectFileWith</a> <a href="src/Data.FileEmbed.html#injectFileWith" class="link">Source</a> <a href="#v:injectFileWith" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>postfix of magic string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>bs to inject</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></td><td class="doc"><p>template file</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></td><td class="doc"><p>output file</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-FileEmbed.html#v:injectFile" title="Data.FileEmbed">injectFile</a></code>, but takes a postfix for the magic string.</p><p>Since 0.0.8</p></div></div><a href="#g:4" id="g:4"><h1>Relative path manipulation</h1></a><div class="top"><p class="src"><a id="v:makeRelativeToProject" class="def">makeRelativeToProject</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="src/Data.FileEmbed.html#makeRelativeToProject" class="link">Source</a> <a href="#v:makeRelativeToProject" class="selflink">#</a></p><div class="doc"><p>Take a relative file path and attach it to the root of the current
 project.</p><p>The idea here is that, when building with Stack, the build will always be
 executed with a current working directory of the root of the project (where
 your .cabal file is located). However, if you load up multiple projects with
 <code>stack ghci</code>, the working directory may be something else entirely.</p><p>This function looks at the source location of the Haskell file calling it,
 finds the first parent directory with a .cabal file, and uses that as the
 root directory for fixing the relative path.</p><pre>$(makeRelativeToProject &quot;data/foo.txt&quot; &gt;&gt;= embedFile)</pre><p><em>Since: 0.0.10</em></p></div></div><div class="top"><p class="src"><a id="v:makeRelativeToLocationPredicate" class="def">makeRelativeToLocationPredicate</a> :: (<a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="src/Data.FileEmbed.html#makeRelativeToLocationPredicate" class="link">Source</a> <a href="#v:makeRelativeToLocationPredicate" class="selflink">#</a></p><div class="doc"><p>Take a predicate to infer the project root and a relative file path, the given file path is then attached to the inferred project root</p><p>This function looks at the source location of the Haskell file calling it,
 finds the first parent directory with a file matching the given predicate, and uses that as the
 root directory for fixing the relative path.</p><pre>$(makeRelativeToLocationPredicate ((==) &quot;.cabal&quot; . takeExtension) &quot;data/foo.txt&quot; &gt;&gt;= embedFile)</pre><p><em>Since: 0.0.15.0</em></p></div></div><a href="#g:5" id="g:5"><h1>Internal</h1></a><div class="top"><p class="src"><a id="v:stringToBs" class="def">stringToBs</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="src/Data.FileEmbed.html#stringToBs" class="link">Source</a> <a href="#v:stringToBs" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:bsToExp" class="def">bsToExp</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#bsToExp" class="link">Source</a> <a href="#v:bsToExp" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:strToExp" class="def">strToExp</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Data.FileEmbed.html#strToExp" class="link">Source</a> <a href="#v:strToExp" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>