-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-sqlite
@version 0.0.0


-- | Internals exported for testing.
module Unison.Sqlite.Internal
data Param
FieldParam :: !Text -> Param
RowParam :: !Text -> !Int -> Param
data ParsedLump
ParsedOuterLump :: !Text -> ![Param] -> ParsedLump
ParsedInnerLump :: !Text -> ParsedLump
ParsedInLump :: !Text -> ParsedLump
ParsedValuesLump :: !Text -> ParsedLump

-- | Parse a SQL string, and return the list of lumps. Exported only for
--   testing.
internalParseSql :: Text -> Either String [ParsedLump]

module Unison.Sqlite.Connection

-- | A <i>non-thread safe</i> connection to a SQLite database.
data Connection
Connection :: String -> FilePath -> Connection -> Connection
[$sel:name:Connection] :: Connection -> String
[$sel:file:Connection] :: Connection -> FilePath
[$sel:conn:Connection] :: Connection -> Connection

-- | Perform an action with a connection to a SQLite database.
--   
--   Note: the connection is created with <tt>PRAGMA foreign_keys = ON</tt>
--   automatically, to work around the fact that SQLite does not
--   automatically enforce foreign key integrity, because it elected to
--   maintain backwards compatibility with code that was written before the
--   foreign key integrity feature was implemented.
withConnection :: MonadUnliftIO m => String -> FilePath -> (Connection -> m a) -> m a
execute :: HasCallStack => Connection -> Sql -> IO ()

-- | Execute one or more semicolon-delimited statements.
--   
--   This function does not support parameters, and is mostly useful for
--   executing DDL and migrations.
executeStatements :: HasCallStack => Connection -> Text -> IO ()
queryStreamRow :: (HasCallStack, FromRow a) => Connection -> Sql -> (IO (Maybe a) -> IO r) -> IO r
queryStreamCol :: forall a r. (HasCallStack, FromField a) => Connection -> Sql -> (IO (Maybe a) -> IO r) -> IO r
queryListRow :: forall a. (FromRow a, HasCallStack) => Connection -> Sql -> IO [a]
queryListCol :: forall a. (FromField a, HasCallStack) => Connection -> Sql -> IO [a]
queryMaybeRow :: (FromRow a, HasCallStack) => Connection -> Sql -> IO (Maybe a)
queryMaybeCol :: forall a. (FromField a, HasCallStack) => Connection -> Sql -> IO (Maybe a)
queryOneRow :: (FromRow a, HasCallStack) => Connection -> Sql -> IO a
queryOneCol :: forall a. (FromField a, HasCallStack) => Connection -> Sql -> IO a
queryListRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> ([a] -> Either e r) -> IO r
queryListColCheck :: forall a e r. (FromField a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> ([a] -> Either e r) -> IO r
queryMaybeRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> (a -> Either e r) -> IO (Maybe r)
queryMaybeColCheck :: forall a e r. (FromField a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> (a -> Either e r) -> IO (Maybe r)
queryOneRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> (a -> Either e r) -> IO r
queryOneColCheck :: forall a e r. (FromField a, SqliteExceptionReason e, HasCallStack) => Connection -> Sql -> (a -> Either e r) -> IO r
rowsModified :: Connection -> IO Int

-- | <tt>VACUUM</tt>, and return whether or not the vacuum succeeded. A
--   vacuum fails if the connection has any open transactions.
vacuum :: Connection -> IO Bool

-- | <pre>
--   VACUUM INTO
--   </pre>
vacuumInto :: Connection -> FilePath -> IO ()

-- | <pre>
--   BEGIN
--   </pre>
begin :: Connection -> IO ()

-- | <pre>
--   BEGIN IMMEDIATE
--   </pre>
beginImmediate :: Connection -> IO ()

-- | <pre>
--   COMMIT
--   </pre>
commit :: Connection -> IO ()

-- | <pre>
--   ROLLBACK
--   </pre>
rollback :: Connection -> IO ()

-- | Perform an action within a named savepoint. The action is provided a
--   rollback action.
withSavepoint :: MonadUnliftIO m => Connection -> Text -> (m () -> m a) -> m a
withSavepointIO :: Connection -> Text -> (IO () -> IO a) -> IO a

-- | <pre>
--   SAVEPOINT
--   </pre>
savepoint :: Connection -> Text -> IO ()

-- | <pre>
--   ROLLBACK TO
--   </pre>
rollbackTo :: Connection -> Text -> IO ()

-- | <pre>
--   RELEASE
--   </pre>
release :: Connection -> Text -> IO ()

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedAtMostOneRowException
ExpectedAtMostOneRowException :: String -> ExpectedAtMostOneRowException
[$sel:rows:ExpectedAtMostOneRowException] :: ExpectedAtMostOneRowException -> String

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedExactlyOneRowException
ExpectedExactlyOneRowException :: String -> ExpectedExactlyOneRowException
[$sel:rows:ExpectedExactlyOneRowException] :: ExpectedExactlyOneRowException -> String
instance Unison.Sqlite.Exception.SqliteExceptionReason Unison.Sqlite.Connection.ExpectedExactlyOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.ExpectedExactlyOneRowException
instance Unison.Sqlite.Exception.SqliteExceptionReason Unison.Sqlite.Connection.ExpectedAtMostOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.ExpectedAtMostOneRowException
instance GHC.Show.Show Unison.Sqlite.Connection.Query

module Unison.Sqlite.Transaction
data Transaction a

-- | Run a transaction on the given connection.
runTransaction :: (MonadIO m, HasCallStack) => Connection -> Transaction a -> m a

-- | Run a transaction on the given connection, providing a function that
--   can short-circuit (and roll back) the transaction.
runTransactionWithRollback :: (MonadIO m, HasCallStack) => Connection -> ((forall void. a -> Transaction void) -> Transaction a) -> m a

-- | Run a transaction that is known to only perform reads.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions. If the transaction does attempt a write and gets
--   SQLITE_BUSY, it's your fault!
runReadOnlyTransaction :: (MonadUnliftIO m, HasCallStack) => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Run a transaction that is known to perform at least one write.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions.
runWriteTransaction :: (HasCallStack, MonadUnliftIO m) => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Wrap a transaction with a cache; cache hits will not hit SQLite.
cacheTransaction :: forall k v. Cache k v -> (k -> Transaction v) -> k -> Transaction v

-- | Perform an atomic sub-computation within a transaction; if it returns
--   <a>Left</a>, it's rolled back.
savepoint :: Transaction (Either a a) -> Transaction a

-- | Perform IO inside a transaction, which should be idempotent, because
--   it may be run more than once if the transaction needs to retry.
--   
--   <i>Warning</i>: attempting to run a transaction inside a transaction
--   will cause an exception!
unsafeIO :: HasCallStack => IO a -> Transaction a
unsafeGetConnection :: Transaction Connection

-- | Unwrap the transaction newtype, throwing away the sending of
--   BEGIN/COMMIT + automatic retry.
unsafeUnTransaction :: Transaction a -> Connection -> IO a
execute :: HasCallStack => Sql -> Transaction ()
executeStatements :: HasCallStack => Text -> Transaction ()
queryStreamRow :: (FromRow a, HasCallStack) => Sql -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryStreamCol :: forall a r. (FromField a, HasCallStack) => Sql -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryListRow :: (FromRow a, HasCallStack) => Sql -> Transaction [a]
queryListCol :: (FromField a, HasCallStack) => Sql -> Transaction [a]
queryMaybeRow :: (FromRow a, HasCallStack) => Sql -> Transaction (Maybe a)
queryMaybeCol :: (FromField a, HasCallStack) => Sql -> Transaction (Maybe a)
queryOneRow :: (FromRow a, HasCallStack) => Sql -> Transaction a
queryOneCol :: (FromField a, HasCallStack) => Sql -> Transaction a
queryListRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> ([a] -> Either e r) -> Transaction r
queryListColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> ([a] -> Either e r) -> Transaction r
queryMaybeRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction r
queryOneColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction r
rowsModified :: Transaction Int
instance GHC.Base.Monad Unison.Sqlite.Transaction.Transaction
instance GHC.Base.Functor Unison.Sqlite.Transaction.Transaction
instance GHC.Base.Applicative Unison.Sqlite.Transaction.Transaction
instance GHC.Base.Monad Unison.Sqlite.Transaction.TransactionWithMonadIO
instance GHC.Base.Functor Unison.Sqlite.Transaction.TransactionWithMonadIO
instance GHC.Base.Applicative Unison.Sqlite.Transaction.TransactionWithMonadIO
instance GHC.Exception.Type.Exception Unison.Sqlite.Transaction.RollingBack
instance GHC.Show.Show Unison.Sqlite.Transaction.RollingBack
instance Control.Monad.IO.Class.MonadIO Unison.Sqlite.Transaction.TransactionWithMonadIO
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Sqlite.Transaction.Transaction a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Sqlite.Transaction.Transaction a)


-- | The Unison monorepo interface to SQLite.
--   
--   This module provides a high(-er) level interface to SQLite than the
--   <tt>sqlite-simple</tt> library, which it wraps. Code that interacts
--   with SQLite in this monorepo should use this interface, rather than
--   <tt>sqlite-simple</tt> or <tt>direct-sqlite</tt> directly.
--   
--   Three variants of the main query interface are provided:
--   
--   <ul>
--   <li><a>Unison.Sqlite.Connection</a> provides an interface in
--   <tt>IO</tt>, which takes the <a>Connection</a> argument as an explicit
--   argument.</li>
--   <li><a>Unison.Sqlite.Transaction</a> provides a safer interface that
--   executes queries in transactions, with automatic retries on
--   <tt>SQLITE_BUSY</tt> due to concurrent writers.</li>
--   </ul>
module Unison.Sqlite

-- | A <i>non-thread safe</i> connection to a SQLite database.
data Connection

-- | Perform an action with a connection to a SQLite database.
--   
--   Note: the connection is created with <tt>PRAGMA foreign_keys = ON</tt>
--   automatically, to work around the fact that SQLite does not
--   automatically enforce foreign key integrity, because it elected to
--   maintain backwards compatibility with code that was written before the
--   foreign key integrity feature was implemented.
withConnection :: MonadUnliftIO m => String -> FilePath -> (Connection -> m a) -> m a
data Transaction a

-- | Run a transaction on the given connection.
runTransaction :: (MonadIO m, HasCallStack) => Connection -> Transaction a -> m a

-- | Run a transaction on the given connection, providing a function that
--   can short-circuit (and roll back) the transaction.
runTransactionWithRollback :: (MonadIO m, HasCallStack) => Connection -> ((forall void. a -> Transaction void) -> Transaction a) -> m a

-- | Run a transaction that is known to only perform reads.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions. If the transaction does attempt a write and gets
--   SQLITE_BUSY, it's your fault!
runReadOnlyTransaction :: (MonadUnliftIO m, HasCallStack) => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Run a transaction that is known to perform at least one write.
--   
--   The action is provided a function that peels off the
--   <a>Transaction</a> newtype without sending the corresponding
--   BEGIN/COMMIT statements.
--   
--   The transaction is never retried, so it is (more) safe to interleave
--   arbitrary IO actions.
runWriteTransaction :: (HasCallStack, MonadUnliftIO m) => Connection -> ((forall x. Transaction x -> m x) -> m a) -> m a

-- | Wrap a transaction with a cache; cache hits will not hit SQLite.
cacheTransaction :: forall k v. Cache k v -> (k -> Transaction v) -> k -> Transaction v

-- | Perform an atomic sub-computation within a transaction; if it returns
--   <a>Left</a>, it's rolled back.
savepoint :: Transaction (Either a a) -> Transaction a

-- | Perform IO inside a transaction, which should be idempotent, because
--   it may be run more than once if the transaction needs to retry.
--   
--   <i>Warning</i>: attempting to run a transaction inside a transaction
--   will cause an exception!
unsafeIO :: HasCallStack => IO a -> Transaction a

-- | Unwrap the transaction newtype, throwing away the sending of
--   BEGIN/COMMIT + automatic retry.
unsafeUnTransaction :: Transaction a -> Connection -> IO a

-- | A SQL query.
data Sql

-- | A quasi-quoter for producing a <a>Sql</a> from a SQL query string,
--   using the Haskell variables in scope for each named parameter.
--   
--   For example, the query
--   
--   <pre>
--   let qux = 5 :: Int
--   
--   [sql|
--     SELECT foo
--     FROM bar
--     WHERE baz = :qux
--   |]
--   </pre>
--   
--   would produce a value like
--   
--   <pre>
--   Sql
--     { query = "SELECT foo FROM bar WHERE baz = ?"
--     , params = [SQLInteger 5]
--     }
--   </pre>
--   
--   which, of course, will require a <tt>qux</tt> with a <a>ToField</a>
--   instance in scope.
--   
--   There are five valid syntaxes for interpolating a variable:
--   
--   <ul>
--   <li><tt>:colon</tt>, which denotes a single-field variable</li>
--   <li><tt>@at</tt>, followed by 1+ bare <tt>@</tt>, which denotes a
--   multi-field variable</li>
--   <li><tt>$dollar</tt>, which denotes an entire <a>Sql</a> fragment</li>
--   <li><tt>IN :colon</tt>, which denotes an <tt>IN</tt> expression, where
--   the right-hand side is a list of scalars</li>
--   <li><tt>VALUES :colon</tt>, which denotes an entire <tt>VALUES</tt>
--   literal (1+ tuples)</li>
--   </ul>
--   
--   As an example of the <tt>@at</tt> syntax, consider a variable
--   <tt>plonk</tt> with a two-field <a>ToRow</a> instance. A query that
--   interpolates <tt>plonk</tt> might look like:
--   
--   <pre>
--   [sql|
--     SELECT foo
--     FROM bar
--     WHERE stuff = @plonk
--       AND other = @
--   |]
--   </pre>
--   
--   As an example of <tt>$dollar</tt> syntax,
--   
--   <pre>
--   let foo = [sql| bar |] in [sql| $foo baz |]
--   </pre>
--   
--   splices <tt>foo</tt> into the second fragment, and is equivalent to
--   
--   <pre>
--   [sql| bar baz |]
--   </pre>
--   
--   As an example of <tt>IN :colon</tt> syntax, the query
--   
--   <pre>
--   [sql| IN :foo |]
--   </pre>
--   
--   will require a list "foo" to be in scope, whose elements have
--   <tt>ToField</tt> instances, and will expand to SQL that looks like
--   
--   <pre>
--   IN (?, ?, ?, ?)
--   </pre>
--   
--   depending on how man elements "foo" has.
--   
--   As an example of <tt>VALUES :colon</tt> syntax, the query
--   
--   <pre>
--   [sql| VALUES :foo |]
--   </pre>
--   
--   will require a non-empty list "foo" to be in scope, whose elements
--   have <tt>ToRow</tt> instances, and will expand to SQL that looks like
--   
--   <pre>
--   VALUES (?, ?), (?, ?), (?, ?)
--   </pre>
--   
--   depending on how many elements "foo" has, and how wide its rows are.
sql :: QuasiQuoter
execute :: HasCallStack => Sql -> Transaction ()
executeStatements :: HasCallStack => Text -> Transaction ()
queryStreamRow :: (FromRow a, HasCallStack) => Sql -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryStreamCol :: forall a r. (FromField a, HasCallStack) => Sql -> (Transaction (Maybe a) -> Transaction r) -> Transaction r
queryListRow :: (FromRow a, HasCallStack) => Sql -> Transaction [a]
queryListCol :: (FromField a, HasCallStack) => Sql -> Transaction [a]
queryMaybeRow :: (FromRow a, HasCallStack) => Sql -> Transaction (Maybe a)
queryMaybeCol :: (FromField a, HasCallStack) => Sql -> Transaction (Maybe a)
queryOneRow :: (FromRow a, HasCallStack) => Sql -> Transaction a
queryOneCol :: (FromField a, HasCallStack) => Sql -> Transaction a
queryListRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> ([a] -> Either e r) -> Transaction r
queryListColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> ([a] -> Either e r) -> Transaction r
queryMaybeRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryMaybeColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction (Maybe r)
queryOneRowCheck :: (FromRow a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction r
queryOneColCheck :: (FromField a, SqliteExceptionReason e, HasCallStack) => Sql -> (a -> Either e r) -> Transaction r
rowsModified :: Transaction Int
newtype DataVersion
DataVersion :: Int64 -> DataVersion
getDataVersion :: Transaction DataVersion

-- | <a>https://www.sqlite.org/pragma.html#pragma_journal_mode</a>
data JournalMode
JournalMode'DELETE :: JournalMode
JournalMode'TRUNCATE :: JournalMode
JournalMode'PERSIST :: JournalMode
JournalMode'MEMORY :: JournalMode
JournalMode'WAL :: JournalMode
JournalMode'OFF :: JournalMode
trySetJournalMode :: MonadIO m => Connection -> JournalMode -> m ()

-- | <tt>VACUUM</tt>, and return whether or not the vacuum succeeded. A
--   vacuum fails if the connection has any open transactions.
vacuum :: Connection -> IO Bool

-- | <pre>
--   VACUUM INTO
--   </pre>
vacuumInto :: Connection -> FilePath -> IO ()

-- | The root exception for all exceptions thrown by this library.
--   
--   <pre>
--   SomeException (from base)
--     └── SomeSqliteException
--           └── SqliteConnectException
--           └── SqliteQueryException
--   </pre>
--   
--   A <tt>SomeSqliteException</tt> should not be inspected or used for
--   control flow when run in a trusted environment, where the database can
--   be assumed to be uncorrupt. Rather, wherever possible, the user of
--   this library should write code that is guaranteed not to throw
--   exceptions, by checking the necessary preconditions first. If that is
--   not possible, it should be considered a bug in this library.
--   
--   When actions are run on an untrusted codebase, e.g. one downloaded
--   from a remote server, it is sufficient to catch just one exception
--   type, <tt>SomeSqliteException</tt>.
data SomeSqliteException
SomeSqliteException :: e -> SomeSqliteException
isCantOpenException :: SomeSqliteException -> Bool

-- | An exception thrown during establishing a connection.
data SqliteConnectException

-- | A <tt>SqliteQueryException</tt> represents an exception thrown during
--   processing a query, paired with some context that resulted in the
--   exception.
--   
--   A <tt>SqliteQueryException</tt> may result from a number of different
--   conditions:
--   
--   <ul>
--   <li>The underlying sqlite library threw an exception.</li>
--   <li>A postcondition violation of a function like <a>queryMaybeRow</a>,
--   which asserts that the resulting relation will have certain number of
--   rows,</li>
--   <li>A postcondition violation of a function like
--   <a>queryListRowCheck</a>, which takes a user-defined check as an
--   argument.</li>
--   </ul>
--   
--   A <tt>SqliteQueryException</tt> should not be inspected or used for
--   control flow when run in a trusted environment, where the database can
--   be assumed to be uncorrupt. Rather, wherever possible, the user of
--   this library should write code that is guaranteed not to throw
--   exceptions, by checking the necessary preconditions first. If that is
--   not possible, it should be considered a bug in this library.
--   
--   When actions are run on an untrusted codebase, e.g. one downloaded
--   from a remote server, it is sufficient to catch just one exception
--   type, <tt>SqliteQueryException</tt>.
data SqliteQueryException

-- | A type that is intended to be used as additional context for a
--   sqlite-related exception.
class (Show e, Typeable e) => SqliteExceptionReason e
data SomeSqliteExceptionReason
SomeSqliteExceptionReason :: e -> SomeSqliteExceptionReason

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedAtMostOneRowException
ExpectedAtMostOneRowException :: String -> ExpectedAtMostOneRowException
[$sel:rows:ExpectedAtMostOneRowException] :: ExpectedAtMostOneRowException -> String

-- | A query was expected to return exactly one row, but it did not. The
--   exception carries a string representation of the rows that were
--   actually returned.
newtype ExpectedExactlyOneRowException
ExpectedExactlyOneRowException :: String -> ExpectedExactlyOneRowException
[$sel:rows:ExpectedExactlyOneRowException] :: ExpectedExactlyOneRowException -> String
data SetJournalModeException
SetJournalModeException :: JournalMode -> JournalMode -> SetJournalModeException
[$sel:currentJournalMode:SetJournalModeException] :: SetJournalModeException -> JournalMode
[$sel:couldntSetTo:SetJournalModeException] :: SetJournalModeException -> JournalMode
field :: FromField a => RowParser a

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data () => h :. t
(:.) :: h -> t -> (:.) h t
infixr 3 :.
infixr 3 :.

-- | A type that may be converted from a SQL type.
class () => FromField a

-- | Convert a SQL value to a Haskell value.
--   
--   Returns a list of exceptions if the conversion fails. In the case of
--   library instances, this will usually be a single <a>ResultError</a>,
--   but may be a <tt>UnicodeException</tt>.
--   
--   Implementations of <a>fromField</a> should not retain any references
--   to the <a>Field</a> nor the <a>ByteString</a> arguments after the
--   result has been evaluated to WHNF. Such a reference causes the entire
--   <tt>LibPQ.<a>Result</a></tt> to be retained.
--   
--   For example, the instance for <a>ByteString</a> uses <a>copy</a> to
--   avoid such a reference, and that using bytestring functions such as
--   <a>drop</a> and <a>takeWhile</a> alone will also trigger this memory
--   leak.
fromField :: FromField a => FieldParser a

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   <pre>
--   data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where
--       fromRow = User &lt;$&gt; <a>field</a> &lt;*&gt; <a>field</a>
--   </pre>
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
--   
--   <h3>Generic implementation</h3>
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>FromRow</a>. With a <a>Generic</a>
--   instance for <tt>User</tt>, the example above could be written:
--   
--   <pre>
--   instance <a>FromRow</a> User where
--   </pre>
--   
--   With <tt>-XDeriveAnyClass -XDerivingStrategies</tt> the same can be
--   written:
--   
--   <pre>
--   deriving anyclass instance <a>FromRow</a> User
--   </pre>
--   
--   For more details refer to <a>GFromRow</a>.
class () => FromRow a
fromRow :: FromRow a => RowParser a

-- | The 1-tuple type or single-value "collection".
--   
--   This type is structurally equivalent to the <a>Identity</a> type, but
--   its intent is more about serving as the anonymous 1-tuple type missing
--   from Haskell for attaching typeclass instances.
--   
--   Parameter usage example:
--   
--   <pre>
--   encodeSomething (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result usage example:
--   
--   <pre>
--   xs &lt;- decodeSomething
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype () => Only a
Only :: a -> Only a
[fromOnly] :: Only a -> a
data () => RowParser a
data () => SQLData
SQLInteger :: !Int64 -> SQLData
SQLFloat :: !Double -> SQLData
SQLText :: !Text -> SQLData
SQLBlob :: !ByteString -> SQLData
SQLNull :: SQLData

-- | A type that may be used as a single parameter to a SQL query.
class () => ToField a

-- | Prepare a value for substitution into a query string.
toField :: ToField a => a -> SQLData

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
--   
--   Since version 0.4.18.1 it is possible in some cases to derive a
--   generic implementation for <a>ToRow</a>. Refer to the documentation
--   for <a>FromRow</a> to see how this can be done.
class () => ToRow a

-- | <a>ToField</a> a collection of values.
toRow :: ToRow a => a -> [SQLData]
