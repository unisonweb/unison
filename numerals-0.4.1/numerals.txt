-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convert numbers to number words
--   
--   Convert numbers to number words in a number of languages. Each
--   language has its own module. The module name is based on the ISO 639-3
--   code for that language. Each module contains one or more
--   <a>cardinal</a> and <a>ordinal</a> functions and a <a>struct</a>
--   function. The <a>cardinal</a> functions directly convert cardinal
--   numbers to a string-like representation of their spoken form. The
--   <a>ordinal</a> functions do the same but for ordinal numbers. The
--   <a>struct</a> functions convert numbers to a polymorphic
--   representation of their grammatical structure. See the
--   <a>Text.Numeral</a> module for information on how to use this library.
@package numerals
@version 0.4.1

module Text.Numeral.Grammar
data Inflection
Inflection :: Maybe Case -> Maybe Gender -> Maybe Number -> Inflection
[iCase] :: Inflection -> Maybe Case
[iGender] :: Inflection -> Maybe Gender
[iNumber] :: Inflection -> Maybe Number
defaultInflection :: Inflection
data Case

-- | In linguistics, abessive (abbreviated abe or abess), caritive and
--   privative (abbreviated priv) are names for a grammatical case
--   expressing the lack or absence of the marked noun.
Abessive :: Case

-- | The ablative case (abbreviated abl) indicates movement from something,
--   or cause.
Ablative :: Case

-- | The accusative case (abbreviated acc) indicates the direct object of a
--   verb.
Accusative :: Case

-- | The comitative case (abbreviated com), also known as the associative
--   case (abbreviated ass), is a grammatical case that denotes
--   companionship, and is used where English would typically use
--   preposition "with" in the sense of "in company with" or "together
--   with" (other uses of "with," e.g. with the meaning of "using," "by
--   means of" (I cut bread with a knife) would correspond to the
--   instrumental case or related cases).
Comitative :: Case

-- | The dative case (abbreviated dat, or sometimes d when it is a core
--   argument) indicates the indirect object of a verb.
Dative :: Case

-- | The delative case (abbreviated del; from Latin deferre "to bear or
--   bring away or down") in the Hungarian language can originally express
--   the movement from the surface of something (e.g. "off the table"), but
--   it is used in several other meanings (e.g. "about people"), some of
--   them related to the original (e.g. "from the post office").
Delative :: Case

-- | The distributive case (abbreviated distr) is used on nouns for the
--   meanings of per or each.
Distributive :: Case

-- | The distributive-temporal case specifies when something is done.
DistributiveTemporal :: Case

-- | The essive or similaris case (abbreviated ess) carries the meaning of
--   a temporary location or state of being, often equivalent to the
--   English "as a (child)".
Essive :: Case

-- | The genitive case (abbreviated gen; also called the possessive case or
--   second case), which roughly corresponds to English's possessive case
--   and preposition of, indicates the possessor of another noun.
Genitive :: Case

-- | The instrumental case (abbreviated ins or instr; also called the
--   eighth case) indicates an object used in performing an action.
Instrumental :: Case

-- | In the Finnish language and Estonian language, the instructive case
--   has the basic meaning of "by means of". It is a comparatively rarely
--   used case, though it is found in some commonly used expressions, such
--   as omin silmin -&gt; "with one's own eyes".
Instructive :: Case

-- | Lative (abbreviated lat) is a case which indicates motion to a
--   location. It corresponds to the English prepositions "to" and "into".
--   The lative case belongs to the group of the general local cases
--   together with the locative and separative case. The term derives from
--   the Latin lat-, the participle stem of ferre, "to bring".
Lative :: Case

-- | The locative case (abbreviated loc) indicates a location.
Locative :: Maybe Locative -> Case

-- | The multiplicative case is a grammatical case used for marking a
--   number of something ("three times").
Multiplicative :: Case

-- | The nominative case (abbreviated nom) indicates the subject of a
--   finite verb.
Nominative :: Case

-- | The partitive case (abbreviated ptv or more ambiguously part) denotes
--   "partialness", "without result", or "without specific identity". It is
--   also used in contexts where a subgroup is selected from a larger
--   group, or with numbers.
Partitive :: Case

-- | The term sublative case (abbreviated subl) is used to refer to
--   grammatical cases expressing different situations: In Hungarian, it
--   expresses the destination of the movement, originally to the surface
--   of something (e.g. sit down on the ground, climb the tree), but in
--   other figurative meanings as well (e.g. to university, for two
--   nights), while in Tsez and other Northeast Caucasian languages it
--   denotes a movement towards the bottomsides or the area under an
--   object. The sublative case is used in the Finnish, Tsez and Hungarian
--   languages.
Sublative :: Case

-- | The Superessive case (abbreviated supe) is a grammatical declension
--   indicating location on top of, or on the surface of something. Its
--   name comes from Latin supersum, superesse: to be over and above.
SuperEssive :: Case

-- | The translative case (abbreviated transl) is a grammatical case that
--   indicates a change in state of a noun, with the general sense of
--   "becoming X" or "change to X".
Translative :: Case

-- | The vocative case indicates an addressee.
Vocative :: Case
data Gender
Neuter :: Gender
Masculine :: Gender
Feminine :: Gender
Common :: Gender
data Number
Singular :: Number
Dual :: Number
Trial :: Number
Paucal :: Number
Plural :: Number
noCase :: Inflection -> Inflection
hasNoCase :: Inflection -> Bool
ablative :: Inflection -> Inflection
isAblative :: Inflection -> Bool
abessive :: Inflection -> Inflection
isAbessive :: Inflection -> Bool
accusative :: Inflection -> Inflection
isAccusative :: Inflection -> Bool
comitative :: Inflection -> Inflection
isComitative :: Inflection -> Bool
dative :: Inflection -> Inflection
isDative :: Inflection -> Bool
delative :: Inflection -> Inflection
isDelative :: Inflection -> Bool
distributive :: Inflection -> Inflection
isDistributive :: Inflection -> Bool
distributiveTemporal :: Inflection -> Inflection
isDistributiveTemporal :: Inflection -> Bool
essive :: Inflection -> Inflection
isEssive :: Inflection -> Bool
genitive :: Inflection -> Inflection
isGenitive :: Inflection -> Bool
instrumental :: Inflection -> Inflection
isInstrumental :: Inflection -> Bool
instructive :: Inflection -> Inflection
isInstructive :: Inflection -> Bool
lative :: Inflection -> Inflection
isLative :: Inflection -> Bool
locative :: Inflection -> Inflection
isLocative :: Inflection -> Bool
multiplicative :: Inflection -> Inflection
isMultiplicative :: Inflection -> Bool
nominative :: Inflection -> Inflection
isNominative :: Inflection -> Bool
partitive :: Inflection -> Inflection
isPartitive :: Inflection -> Bool
superEssive :: Inflection -> Inflection
isSuperEssive :: Inflection -> Bool
sublative :: Inflection -> Inflection
isSublative :: Inflection -> Bool
translative :: Inflection -> Inflection
isTranslative :: Inflection -> Bool
vocative :: Inflection -> Inflection
isVocative :: Inflection -> Bool
locativeInessive :: Inflection -> Inflection
isLocativeInessive :: Inflection -> Bool
locativeElative :: Inflection -> Inflection
isLocativeElative :: Inflection -> Bool
locativeIllative :: Inflection -> Inflection
isLocativeIllative :: Inflection -> Bool
locativeAdessive :: Inflection -> Inflection
isLocativeAdessive :: Inflection -> Bool
locativeAblative :: Inflection -> Inflection
isLocativeAblative :: Inflection -> Bool
locativeAllative :: Inflection -> Inflection
isLocativeAllative :: Inflection -> Bool
noGender :: Inflection -> Inflection
hasNoGender :: Inflection -> Bool
neuter :: Inflection -> Inflection
isNeuter :: Inflection -> Bool
masculine :: Inflection -> Inflection
isMasculine :: Inflection -> Bool
feminine :: Inflection -> Inflection
isFeminine :: Inflection -> Bool
common :: Inflection -> Inflection
isCommon :: Inflection -> Bool
noNumber :: Inflection -> Inflection
hasNoNumber :: Inflection -> Bool
singular :: Inflection -> Inflection
isSingular :: Inflection -> Bool
dual :: Inflection -> Inflection
isDual :: Inflection -> Bool
trial :: Inflection -> Inflection
isTrial :: Inflection -> Bool
paucal :: Inflection -> Inflection
isPaucal :: Inflection -> Bool
plural :: Inflection -> Inflection
isPlural :: Inflection -> Bool
instance GHC.Show.Show Text.Numeral.Grammar.Locative
instance GHC.Classes.Eq Text.Numeral.Grammar.Locative
instance GHC.Show.Show Text.Numeral.Grammar.Case
instance GHC.Classes.Eq Text.Numeral.Grammar.Case
instance GHC.Show.Show Text.Numeral.Grammar.Gender
instance GHC.Classes.Eq Text.Numeral.Grammar.Gender
instance GHC.Show.Show Text.Numeral.Grammar.Number
instance GHC.Classes.Eq Text.Numeral.Grammar.Number
instance GHC.Classes.Eq Text.Numeral.Grammar.Inflection
instance GHC.Show.Show Text.Numeral.Grammar.Inflection

module Text.Numeral.Exp

-- | An expression that represents the structure of a numeral.
data Exp

-- | An unknown value. This is used to signal that a value can not be
--   represented in the expression language.
Unknown :: Exp

-- | A literal value.
--   
--   Example in English:
--   
--   <pre>
--   "three" = Lit 3
--   </pre>
Lit :: Integer -> Exp

-- | Negation of an expression.
--   
--   Example in English:
--   
--   <pre>
--   "minus two" = Neg (Lit 2)
--   </pre>
Neg :: Exp -> Exp

-- | Addition of two expressions.
--   
--   Example in English:
--   
--   <pre>
--   "fifteen" = Lit 5 `Add` Lit 10
--   </pre>
Add :: Exp -> Exp -> Exp

-- | Multiplication of two expressions.
--   
--   Example in English:
--   
--   <pre>
--   "thirty" = Lit 3 `Mul` Lit 10
--   </pre>
Mul :: Exp -> Exp -> Exp

-- | One expression subtracted from another expression.
--   
--   Example in Latin:
--   
--   <pre>
--   "duodēvīgintī" = Lit 2 `Sub` (Lit 2 `Mul` Lit 10)
--   </pre>
Sub :: Exp -> Exp -> Exp

-- | A fraction.
--   
--   Example in English:
--   
--   <pre>
--   "two thirds" = `Frac` (Lit 2) (Lit 3)
--   </pre>
Frac :: Exp -> Exp -> Exp

-- | A step in a scale of large values.
--   
--   Should be interpreted as <tt>10 ^ (rank * base + offset)</tt>.
--   
--   Example in English:
--   
--   <pre>
--   "quadrillion" = Scale 3 3 4
--   </pre>
Scale :: Integer -> Integer -> Exp -> Exp
ChangeCase :: Maybe Case -> Exp -> Exp

-- | A change of grammatical gender.
--   
--   This is used in a language like Spanish where the inflection of a
--   number word is not always constant. Specifically, in Spanish, large
--   number names always have the masculine gender. So <tt>millón</tt>,
--   <tt>billón</tt> and the like are all masculine. This can result in the
--   following number word: 10000001 = "un (masculine) millón una
--   (feminine)"
--   
--   Example in Spanish (with the context being Feminine):
--   
--   <pre>
--   "un millón una" = ChangeGender (Just Masculine) (Lit 1) `Mul` Scale 3 3 1 `Add` Lit 1
--   </pre>
ChangeGender :: Maybe Gender -> Exp -> Exp
ChangeNumber :: Maybe Number -> Exp -> Exp
infixl 6 `Add`
infixl 7 `Mul`
infixl 6 `Sub`
showExp :: Exp -> String
evalScale :: Integral a => a -> a -> a -> a

-- | A side or direction, either <a>L</a>eft or <a>R</a>ight.
data Side

-- | Left.
L :: Side

-- | Right.
R :: Side
instance GHC.Show.Show Text.Numeral.Exp.Side
instance GHC.Classes.Eq Text.Numeral.Exp.Side

module Text.Numeral.Entry
data Conversion a
Conversion :: (Inflection -> a -> Maybe Text) -> (a -> Exp) -> Conversion a
[toNumeral] :: Conversion a -> Inflection -> a -> Maybe Text
[toStructure] :: Conversion a -> a -> Exp
data Entry
Entry :: Maybe Text -> [Text] -> Maybe Text -> [Text] -> Maybe Text -> Maybe Text -> Maybe (Conversion Integer) -> Maybe (Conversion Integer) -> Maybe (Conversion (Integer, Integer)) -> Maybe (Conversion Integer) -> Entry
[entIso639_1] :: Entry -> Maybe Text
[entIso639_2] :: Entry -> [Text]
[entIso639_3] :: Entry -> Maybe Text
[entNativeNames] :: Entry -> [Text]
[entEnglishName] :: Entry -> Maybe Text
[entVariant] :: Entry -> Maybe Text
[entCardinal] :: Entry -> Maybe (Conversion Integer)
[entOrdinal] :: Entry -> Maybe (Conversion Integer)
[entPartitive] :: Entry -> Maybe (Conversion (Integer, Integer))
[entMultiplicative] :: Entry -> Maybe (Conversion Integer)
emptyEntry :: Entry

module Text.Numeral.Misc

-- | The (base 10) logarithm of an integral value. Note that the result
--   must be able to fit in an ordinary Int value. This means the maximum
--   input value is 10 ^ (maxBound :: Int).
--   
--   Raise 10 to some power.
dec :: Integral a => a -> a
intLog :: Integral a => a -> a

module Text.Numeral.Render

-- | Renders an expression to a <a>Text</a> value according to a certain
--   representation and inflection.
render :: Repr -> Inflection -> Exp -> Maybe Text

-- | A representation for numerals.
--   
--   A <a>Repr</a> contains all the information on how to render an
--   <a>Exp</a>ression to a <a>Text</a> value.
data Repr
Repr :: Maybe Text -> (Inflection -> Integer -> Maybe (Ctx Exp -> Text)) -> Maybe (Exp -> Ctx Exp -> Text) -> Maybe (Exp -> Exp -> Ctx Exp -> Text) -> Maybe (Exp -> Exp -> Ctx Exp -> Text) -> Maybe (Exp -> Exp -> Ctx Exp -> Text) -> Maybe (Exp -> Exp -> Ctx Exp -> Text) -> ScaleRepr -> Maybe (Text -> Text -> Exp -> Text) -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text) -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text) -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text) -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text) -> Repr

-- | Representation for unknown values.
[reprUnknown] :: Repr -> Maybe Text

-- | Renders a literal value. Not necessarily defined for every value.
[reprValue] :: Repr -> Inflection -> Integer -> Maybe (Ctx Exp -> Text)

-- | Renders a negation. This concerns the negation itself, not the thing
--   being negated.
[reprNeg] :: Repr -> Maybe (Exp -> Ctx Exp -> Text)

-- | Renders an addition. This concerns the addition itself, not the things
--   being added. For example: In "one hundred and eighty" this function
--   would be responsible for rendering the "and".
[reprAdd] :: Repr -> Maybe (Exp -> Exp -> Ctx Exp -> Text)

-- | Renders a multiplication. This concerns the multiplication itself, not
--   the things being multiplied.
[reprMul] :: Repr -> Maybe (Exp -> Exp -> Ctx Exp -> Text)

-- | Renders a subtraction. This concerns the subtraction itself, not the
--   things being subtracted.
[reprSub] :: Repr -> Maybe (Exp -> Exp -> Ctx Exp -> Text)

-- | Renders a fraction. This concerns the fraction itself, not the
--   numerator or the denominator.
[reprFrac] :: Repr -> Maybe (Exp -> Exp -> Ctx Exp -> Text)

-- | Renders a step in a scale of large values.
[reprScale] :: Repr -> ScaleRepr

-- | Combines a negation and the thing being negated. For example: this
--   would combine "minus" and "three" into "minus three".
[reprNegCombine] :: Repr -> Maybe (Text -> Text -> Exp -> Text)

-- | Combines an addition and the things being added.
[reprAddCombine] :: Repr -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text)

-- | Combines a multiplication and the things being multiplied.
[reprMulCombine] :: Repr -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text)

-- | Combines a subtraction and the things being subtracted.
[reprSubCombine] :: Repr -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text)

-- | Combines a fraction and the numerator and denominator.
[reprFracCombine] :: Repr -> Maybe (Text -> Text -> Exp -> Text -> Exp -> Text)

-- | Function that renders the representation of a step in a scale of large
--   values. The value represented by the step is 10 ^ (rank * base +
--   offset).
type ScaleRepr = Inflection -> -- | Base. Integer -> -- | Offset. Integer -> -- | Rank. Exp -> -- | Rank context. Ctx Exp -> Maybe Text

-- | The default representation.
--   
--   Only the combining functions are defined. The rest are either
--   <a>Nothing</a> or always produce <a>Nothing</a>.
defaultRepr :: Repr

-- | A context in which an <a>Exp</a>ression appears.
data Ctx a

-- | The empty context. Used for top level expressions.
CtxEmpty :: Ctx a

-- | Negation context.
CtxNeg :: Ctx a -> Ctx a

-- | Addition context.
CtxAdd :: Side -> a -> Ctx a -> Ctx a

-- | Multiplication context.
CtxMul :: Side -> a -> Ctx a -> Ctx a

-- | Subtraction context.
CtxSub :: Side -> a -> Ctx a -> Ctx a

-- | Fraction context.
CtxFrac :: Side -> a -> Ctx a -> Ctx a

-- | Scale context.
CtxScale :: Ctx a -> Ctx a
posIndex :: Ctx a -> Integer

-- | Checks whether a context is completely on the outside of an
--   expression, either left or right.
--   
--   Given the following expression:
--   
--   <pre>
--   <a>Add</a> (<a>Lit</a> 1000) (<a>Add</a> (<a>Mul</a> (<a>Lit</a> 2) (<a>Lit</a> 100)) (<a>Add</a> (<a>Lit</a> 4) (<a>Mul</a> (<a>Lit</a> 3) (<a>Lit</a> 10))))
--   </pre>
--   
--   On the left we have <tt><a>Lit</a> 1000</tt> and on the right
--   <tt><a>Lit</a> 10</tt>.
isOutside :: Side -> Ctx a -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Text.Numeral.Render.Ctx a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Numeral.Render.Ctx a)


-- | Rules to convert numbers to an expression language.
module Text.Numeral.Rules

-- | A rule on how to convert a number into an expression language. Notice
--   how this type is similar to the type of the <a>$</a> operator.
type Rule a = (a -> Exp) -> (a -> Exp)

-- | The 'if-then-else' concept for rules. Applies the first rule if the
--   predicate holds on the input value, otherwise applies the second rule.
conditional :: (a -> Bool) -> Rule a -> Rule a -> Rule a

-- | Tries to apply the first rule, if that produces an <a>Unknown</a>
--   value it applies the second rule.
combine :: Rule a -> Rule a -> Rule a

-- | Transform a value before it is given to a rule.
mapRule :: (a -> a) -> Rule a -> Rule a

-- | Chooses which rule to apply to an input value based on a interval list
--   of rules.
findRule :: (Ord a, Num a) => (a, Rule a) -> [(a, Rule a)] -> a -> Rule a

-- | A rule that always fails to convert a value. It constantly produces
--   the <a>unknown</a> value.
--   
--   <pre>
--   &gt;&gt;&gt; (fix unknown) (3 :: Integer) :: Exp
--   Unknown
--   </pre>
unknown :: Rule a

-- | The literal rule. Converts its argument into a <a>lit</a>eral
--   expression.
--   
--   <pre>
--   &gt;&gt;&gt; lit (fix unknown) (3 :: Integer) :: Exp
--   Lit 3
--   </pre>
--   
--   In this example lit is applied to the nonsense rule "<a>fix</a>
--   <a>unknown</a>". Lit ignores that function, which is why we can pass
--   it anything we want, including itself.
--   
--   <pre>
--   &gt;&gt;&gt; lit (fix undefined) (3 :: Integer) :: Exp
--   Lit 3
--   
--   &gt;&gt;&gt; (fix lit) (3 :: Integer) :: Exp
--   Lit 3
--   </pre>
lit :: Integral a => Rule a

-- | A variant on the <a>lit</a> rule which always multiplies its argument
--   with 1. Useful for languages which have numerals of the form "one
--   hundred and three" as opposed to "hundred and three".
--   
--   <pre>
--   &gt;&gt;&gt; lit1 (fix unknown) (3 :: Integer) :: Exp
--   Mul (Lit 1) (Lit 3)
--   </pre>
lit1 :: Integral a => Rule a

-- | <pre>
--   &gt;&gt;&gt; (pos $ lit $ fix unknown) (3 :: Integer) :: Exp
--   Lit 3
--   
--   &gt;&gt;&gt; (pos $ lit $ fix unknown) (-3 :: Integer) :: Exp
--   Neg (Lit 3)
--   </pre>
pos :: (Ord a, Num a) => Rule a

-- | <pre>
--   &gt;&gt;&gt; (checkPos $ lit $ fix unknown) (3 :: Integer) :: Exp
--   Lit 3
--   
--   &gt;&gt;&gt; (checkPos $ lit $ fix unknown) (-3 :: Integer) :: Exp
--   Unknown
--   </pre>
checkPos :: (Ord a, Num a) => Rule a

-- | <pre>
--   &gt;&gt;&gt; (add 10 L $ lit $ fix unknown) (13 :: Integer) :: Exp
--   Add (Lit 3) (Lit 10)
--   </pre>
add :: Num a => a -> Side -> Rule a

-- | <pre>
--   &gt;&gt;&gt; (mul 10 R L $ lit $ fix unknown) (42 :: Integer) :: Exp
--   Add (Mul (Lit 4) (Lit 10)) (Lit 2)
--   </pre>
mul :: Integral a => a -> Side -> Side -> Rule a
mul1 :: Integral a => a -> Side -> Side -> Rule a

-- | <pre>
--   &gt;&gt;&gt; (sub 20 $ lit $ fix unknown) (18 :: Integer) :: Exp
--   Sub (Lit 2) (Lit 20)
--   </pre>
sub :: Integral a => a -> Rule a
mulScale_ :: forall a. Integral a => ((a -> Exp) -> a -> Exp -> Side -> Exp) -> a -> a -> Side -> Side -> Rule a -> Rule a
mulScale :: Integral a => a -> a -> Side -> Side -> Rule a -> Rule a
mulScale1 :: Integral a => a -> a -> Side -> Side -> Rule a -> Rule a
shortScale :: Integral a => Side -> Side -> Rule a -> Rule a
longScale :: Integral a => Side -> Side -> Rule a -> Rule a
pelletierScale :: Integral a => Side -> Side -> Rule a -> Rule a
shortScale1 :: Integral a => Side -> Side -> Rule a -> Rule a
longScale1 :: Integral a => Side -> Side -> Rule a -> Rule a
pelletierScale1 :: Integral a => Side -> Side -> Rule a -> Rule a
mkStep :: Integral a => Rule a -> (a -> Side -> Rule a) -> (a -> Side -> Side -> Rule a) -> a -> a -> Side -> Side -> Rule a
step :: Integral a => a -> a -> Side -> Side -> Rule a
step1 :: Integral a => a -> a -> Side -> Side -> Rule a
changeCase :: Maybe Case -> Rule a
changeGender :: Maybe Gender -> Rule a
changeNumber :: Maybe Number -> Rule a

module Text.Numeral


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> zh</li>
--   <li><i><tt>ISO639-2B</tt></i> chi</li>
--   <li><i><tt>ISO639-2T</tt></i> zho</li>
--   <li><i><tt>ISO639-3</tt></i> cmn</li>
--   <li><i><tt>Native name</tt></i> 官話</li>
--   <li><i><tt>English name</tt></i> Chinese</li>
--   </ul>
module Text.Numeral.Language.ZHO
trad_entry :: Entry
simpl_entry :: Entry
finance_trad_entry :: Entry
finance_simpl_entry :: Entry
pinyin_entry :: Entry
trad_cardinal :: Integral a => Inflection -> a -> Maybe Text
simpl_cardinal :: Integral a => Inflection -> a -> Maybe Text
finance_trad_cardinal :: Integral a => Inflection -> a -> Maybe Text
finance_simpl_cardinal :: Integral a => Inflection -> a -> Maybe Text
pinyin_cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> yo</li>
--   <li><i><tt>ISO639-2</tt></i> yor</li>
--   <li><i><tt>ISO639-3</tt></i> yor</li>
--   <li><i><tt>Native name</tt></i> èdè Yorùbá</li>
--   <li><i><tt>English name</tt></i> Yoruba</li>
--   </ul>
module Text.Numeral.Language.YOR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> wo</li>
--   <li><i><tt>ISO639-2</tt></i> wo1</li>
--   <li><i><tt>ISO639-3</tt></i> wo1</li>
--   <li><i><tt>Native name</tt></i> Wolof</li>
--   <li><i><tt>English name</tt></i> Wolof</li>
--   </ul>
module Text.Numeral.Language.WOL
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> sco</li>
--   <li><i><tt>ISO639-3</tt></i> sco</li>
--   <li><i><tt>Native name</tt></i> Scots</li>
--   <li><i><tt>English name</tt></i> Scots</li>
--   </ul>
module Text.Numeral.Language.SCO
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> ru</li>
--   <li><i><tt>ISO639-2</tt></i> rus</li>
--   <li><i><tt>ISO639-3</tt></i> rus</li>
--   <li><i><tt>Native name</tt></i> Русский язык</li>
--   <li><i><tt>English name</tt></i> Russian</li>
--   </ul>
module Text.Numeral.Language.RUS
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> oj</li>
--   <li><i><tt>ISO639-2</tt></i> oji</li>
--   <li><i><tt>ISO639-3</tt></i> oji</li>
--   <li><i><tt>Native name</tt></i> ᐊᓂᔑᓈᐯᒧᐎᓐ (Anishinaabemowin)</li>
--   <li><i><tt>English name</tt></i> Ojibwe</li>
--   </ul>
module Text.Numeral.Language.OJI
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2B</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> nqm</li>
--   <li><i><tt>Native name</tt></i> -</li>
--   <li><i><tt>English name</tt></i> Ndom</li>
--   </ul>
module Text.Numeral.Language.NQM
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> nen</li>
--   <li><i><tt>Native name</tt></i> -</li>
--   <li><i><tt>English name</tt></i> Nengone</li>
--   </ul>
module Text.Numeral.Language.NEN
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> mg</li>
--   <li><i><tt>ISO639-2</tt></i> mlg</li>
--   <li><i><tt>ISO639-3</tt></i> mlg</li>
--   <li><i><tt>Native name</tt></i> -</li>
--   <li><i><tt>English name</tt></i> Malagasy</li>
--   </ul>
module Text.Numeral.Language.MLG
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> la</li>
--   <li><i><tt>ISO639-2B</tt></i> lat</li>
--   <li><i><tt>ISO639-3</tt></i> lat</li>
--   <li><i><tt>Native name</tt></i> Latine</li>
--   <li><i><tt>English name</tt></i> Latin</li>
--   </ul>
module Text.Numeral.Language.LAT
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> ja</li>
--   <li><i><tt>ISO639-2B</tt></i> jpn</li>
--   <li><i><tt>ISO639-3</tt></i> jpn</li>
--   <li><i><tt>Native name</tt></i> 日本語</li>
--   <li><i><tt>English name</tt></i> Japanese</li>
--   </ul>
module Text.Numeral.Language.JPN
kanji_entry :: Entry
daiji_entry :: Entry
on'yomi_entry :: Entry
preferred_entry :: Entry
kanji_cardinal :: Integral a => Inflection -> a -> Maybe Text
daiji_cardinal :: Integral a => Inflection -> a -> Maybe Text
on'yomi_cardinal :: Integral a => Inflection -> a -> Maybe Text
preferred_cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)
daiji_bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> hop</li>
--   <li><i><tt>Native name</tt></i> Hopilàvayi</li>
--   <li><i><tt>English name</tt></i> Hopi</li>
--   </ul>
module Text.Numeral.Language.HOP
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> he</li>
--   <li><i><tt>ISO639-2</tt></i> heb</li>
--   <li><i><tt>ISO639-3</tt></i> heb</li>
--   <li><i><tt>Native name</tt></i> עִבְרִית</li>
--   <li><i><tt>English name</tt></i> Modern Hebrew</li>
--   </ul>
module Text.Numeral.Language.HEB
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> gv</li>
--   <li><i><tt>ISO639-2</tt></i> glv</li>
--   <li><i><tt>ISO639-3</tt></i> glv</li>
--   <li><i><tt>Native name</tt></i> Gaelg</li>
--   <li><i><tt>English name</tt></i> Manx</li>
--   </ul>
module Text.Numeral.Language.GLV
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> eo</li>
--   <li><i><tt>ISO639-2B</tt></i> epo</li>
--   <li><i><tt>ISO639-3</tt></i> epo</li>
--   <li><i><tt>Native name</tt></i> Esperanto</li>
--   <li><i><tt>English name</tt></i> Esperanto</li>
--   </ul>
module Text.Numeral.Language.EPO
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2B</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> clm</li>
--   <li><i><tt>Native name</tt></i> nəxʷsƛ̕ay̕əmúcən</li>
--   <li><i><tt>English name</tt></i> Klallam</li>
--   </ul>
module Text.Numeral.Language.CLM
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> chr</li>
--   <li><i><tt>ISO639-3</tt></i> chr</li>
--   <li><i><tt>Native name</tt></i> ᏣᎳᎩ ᎦᏬᏂᎯᏍᏗ (Tsalagi Gawonihisdi)</li>
--   <li><i><tt>English name</tt></i> Cherokee</li>
--   </ul>
module Text.Numeral.Language.CHR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)

-- | Transliterates a string written in the Cherokee syllabary to the latin
--   alphabet.
transliterate :: Text -> Text


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2B</tt></i> chn</li>
--   <li><i><tt>ISO639-3</tt></i> chn</li>
--   <li><i><tt>Native name</tt></i> chinuk wawa</li>
--   <li><i><tt>English name</tt></i> Chinook Jargon</li>
--   </ul>
module Text.Numeral.Language.CHN
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> amp</li>
--   <li><i><tt>Native name</tt></i> -</li>
--   <li><i><tt>English name</tt></i> Alamblak</li>
--   </ul>
module Text.Numeral.Language.AMP
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)

module Text.Numeral.BigNum
cardinal :: Integral a => Inflection -> a -> Maybe Text
rule :: Integral a => Rule a
cardinalRepr :: Repr
symMap :: Integral a => Map a (Ctx Exp -> Text)
forms :: Text -> Text -> Text -> Text -> Text -> Ctx Exp -> Text

-- | Function that renders the postfix part of a large number name. Or more
--   simply put, this calculates the "illion" part of "million", "billion",
--   etc.
type PostfixRepr = -- | Current inflection. Inflection -> -- | Context. Ctx Exp -> -- | Postfix representation. Text
scaleRepr :: PostfixRepr -> [(Integer, Ctx Exp -> Text)] -> ScaleRepr
pelletierRepr :: PostfixRepr -> PostfixRepr -> [(Integer, Ctx Exp -> Text)] -> ScaleRepr
quantityName :: Text -> Text -> PostfixRepr
ordQuantityName :: Text -> Text -> Text -> Text -> PostfixRepr


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> tr</li>
--   <li><i><tt>ISO639-2</tt></i> tur</li>
--   <li><i><tt>ISO639-3</tt></i> tur</li>
--   <li><i><tt>Native name</tt></i> Türkçe</li>
--   <li><i><tt>English name</tt></i> Turkish</li>
--   </ul>
module Text.Numeral.Language.TUR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> sv</li>
--   <li><i><tt>ISO639-2B</tt></i> swe</li>
--   <li><i><tt>ISO639-3</tt></i> swe</li>
--   <li><i><tt>Native name</tt></i> svenska</li>
--   <li><i><tt>English name</tt></i> Swedish</li>
--   </ul>
module Text.Numeral.Language.SWE
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> es</li>
--   <li><i><tt>ISO639-2B</tt></i> spa</li>
--   <li><i><tt>ISO639-3</tt></i> spa</li>
--   <li><i><tt>Native name</tt></i> Español</li>
--   <li><i><tt>English name</tt></i> Spanish</li>
--   </ul>
module Text.Numeral.Language.SPA
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> pt</li>
--   <li><i><tt>ISO639-2</tt></i> por</li>
--   <li><i><tt>ISO639-3</tt></i> por</li>
--   <li><i><tt>Native name</tt></i> Português</li>
--   <li><i><tt>English name</tt></i> Portuguese</li>
--   </ul>
module Text.Numeral.Language.POR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
cardinal_struct :: Integral a => a -> Exp
ordinal_struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> pl</li>
--   <li><i><tt>ISO639-2</tt></i> pol</li>
--   <li><i><tt>ISO639-3</tt></i> pol</li>
--   <li><i><tt>Native name</tt></i> język polski</li>
--   <li><i><tt>English name</tt></i> Polish</li>
--   </ul>
module Text.Numeral.Language.POL
entry :: Entry

-- | liczebniki główne
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> pdc</li>
--   <li><i><tt>Native name</tt></i> Pennsilfaanisch Deitsch</li>
--   <li><i><tt>English name</tt></i> Pennsylvania German</li>
--   </ul>
module Text.Numeral.Language.PDC
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> nb</li>
--   <li><i><tt>ISO639-2B</tt></i> nob</li>
--   <li><i><tt>ISO639-3</tt></i> nob</li>
--   <li><i><tt>Native name</tt></i> Bokmål</li>
--   <li><i><tt>English name</tt></i> Norwegian Bokmål</li>
--   </ul>
module Text.Numeral.Language.NOB
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> nl</li>
--   <li><i><tt>ISO639-2B</tt></i> dut</li>
--   <li><i><tt>ISO639-3</tt></i> nld</li>
--   <li><i><tt>Native name</tt></i> Nederlands</li>
--   <li><i><tt>English name</tt></i> Dutch</li>
--   </ul>
module Text.Numeral.Language.NLD
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
partitive :: Integral a => Inflection -> (a, a) -> Maybe Text
multiplicative :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> it</li>
--   <li><i><tt>ISO639-2B</tt></i> ita</li>
--   <li><i><tt>ISO639-3</tt></i> ita</li>
--   <li><i><tt>Native name</tt></i> Italiano</li>
--   <li><i><tt>English name</tt></i> Italian</li>
--   </ul>
module Text.Numeral.Language.ITA
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
rule :: Integral a => Rule a
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> fur</li>
--   <li><i><tt>ISO639-3</tt></i> fur</li>
--   <li><i><tt>Native name</tt></i> Furlan</li>
--   <li><i><tt>English name</tt></i> Friulan</li>
--   </ul>
module Text.Numeral.Language.FUR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> -</li>
--   <li><i><tt>ISO639-3</tt></i> lld</li>
--   <li><i><tt>Native name</tt></i> Ladin</li>
--   <li><i><tt>English name</tt></i> Ladin</li>
--   </ul>
module Text.Numeral.Language.LLD
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> fr</li>
--   <li><i><tt>ISO639-2B</tt></i> fre</li>
--   <li><i><tt>ISO639-3</tt></i> fra</li>
--   <li><i><tt>Native name</tt></i> Français</li>
--   <li><i><tt>English name</tt></i> French</li>
--   </ul>
module Text.Numeral.Language.FRA
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
cardinalStruct :: Integral a => a -> Exp
ordinalStruct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> fi</li>
--   <li><i><tt>ISO639-2B</tt></i> fin</li>
--   <li><i><tt>ISO639-3</tt></i> fin</li>
--   <li><i><tt>Native name</tt></i> suomi</li>
--   <li><i><tt>English name</tt></i> Finnish</li>
--   </ul>
module Text.Numeral.Language.FIN
entry :: Entry
data Inflection
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> en</li>
--   <li><i><tt>ISO639-2B</tt></i> eng</li>
--   <li><i><tt>ISO639-3</tt></i> eng</li>
--   <li><i><tt>Native name</tt></i> English</li>
--   <li><i><tt>English name</tt></i> English</li>
--   </ul>
module Text.Numeral.Language.ENG
gb_entry :: Entry
us_entry :: Entry
gb_cardinal :: Integral a => Inflection -> a -> Maybe Text
gb_ordinal :: Integral a => Inflection -> a -> Maybe Text
gbPelletier_cardinal :: Integral a => Inflection -> a -> Maybe Text
us_cardinal :: Integral a => Inflection -> a -> Maybe Text
us_ordinal :: Integral a => Inflection -> a -> Maybe Text
shortScaleStruct :: Integral a => a -> Exp
pelletierScaleStruct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> de</li>
--   <li><i><tt>ISO639-2B</tt></i> ger</li>
--   <li><i><tt>ISO639-2T</tt></i> deu</li>
--   <li><i><tt>ISO639-3</tt></i> deu</li>
--   <li><i><tt>Native name</tt></i> Deutsch</li>
--   <li><i><tt>English name</tt></i> German</li>
--   </ul>
module Text.Numeral.Language.DEU
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> -</li>
--   <li><i><tt>ISO639-2</tt></i> gse</li>
--   <li><i><tt>ISO639-3</tt></i> gse</li>
--   <li><i><tt>Native name</tt></i> Schwyzerdütsch</li>
--   <li><i><tt>English name</tt></i> Swiss German</li>
--   </ul>
module Text.Numeral.Language.GSW
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> hr</li>
--   <li><i><tt>ISO639-2B</tt></i> cro</li>
--   <li><i><tt>ISO639-3</tt></i> cro</li>
--   <li><i><tt>Native name</tt></i> Hrvatski</li>
--   <li><i><tt>English name</tt></i> Croatian</li>
--   </ul>
module Text.Numeral.Language.CRO
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
shortScaleStruct :: Integral a => a -> Exp
pelletierScaleStruct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> cs</li>
--   <li><i><tt>ISO639-2B</tt></i> cze</li>
--   <li><i><tt>ISO639-2T</tt></i> ces</li>
--   <li><i><tt>ISO639-3</tt></i> ces</li>
--   <li><i><tt>Native name</tt></i> Čeština</li>
--   <li><i><tt>English name</tt></i> Czech</li>
--   </ul>
module Text.Numeral.Language.CES
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> bg</li>
--   <li><i><tt>ISO639-2</tt></i> bul</li>
--   <li><i><tt>ISO639-3</tt></i> bul</li>
--   <li><i><tt>Native name</tt></i> Български език</li>
--   <li><i><tt>English name</tt></i> Bulgarian</li>
--   </ul>
module Text.Numeral.Language.BUL
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)


-- | <ul>
--   <li><i><tt>ISO639-1</tt></i> af</li>
--   <li><i><tt>ISO639-2</tt></i> afr</li>
--   <li><i><tt>ISO639-3</tt></i> afr</li>
--   <li><i><tt>Native name</tt></i> Afrikaans</li>
--   <li><i><tt>English name</tt></i> Afrikaans</li>
--   </ul>
module Text.Numeral.Language.AFR
entry :: Entry
cardinal :: Integral a => Inflection -> a -> Maybe Text
ordinal :: Integral a => Inflection -> a -> Maybe Text
struct :: Integral a => a -> Exp
bounds :: Integral a => (a, a)

module Text.Numeral.Language.Entries
entries :: [Entry]
