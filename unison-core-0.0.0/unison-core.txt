-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-core
@version 0.0.0

module U.Codebase.HashTags

-- | Represents a hash of a type or term component
newtype ComponentHash
ComponentHash :: Hash -> ComponentHash
[unComponentHash] :: ComponentHash -> Hash
newtype BranchHash
BranchHash :: Hash -> BranchHash
[unBranchHash] :: BranchHash -> Hash

-- | Represents a hash of a causal containing values of the provided type.
newtype CausalHash
CausalHash :: Hash -> CausalHash
[unCausalHash] :: CausalHash -> Hash
newtype PatchHash
PatchHash :: Hash -> PatchHash
[unPatchHash] :: PatchHash -> Hash
instance GHC.Classes.Ord U.Codebase.HashTags.ComponentHash
instance GHC.Classes.Eq U.Codebase.HashTags.ComponentHash
instance GHC.Classes.Ord U.Codebase.HashTags.BranchHash
instance GHC.Classes.Eq U.Codebase.HashTags.BranchHash
instance GHC.Classes.Ord U.Codebase.HashTags.CausalHash
instance GHC.Classes.Eq U.Codebase.HashTags.CausalHash
instance GHC.Classes.Ord U.Codebase.HashTags.PatchHash
instance GHC.Classes.Eq U.Codebase.HashTags.PatchHash
instance GHC.Show.Show U.Codebase.HashTags.PatchHash
instance Witch.From.From U.Codebase.HashTags.PatchHash Data.Text.Internal.Text
instance Witch.From.From U.Codebase.HashTags.PatchHash Unison.Hash.Hash
instance Witch.From.From Unison.Hash.Hash U.Codebase.HashTags.PatchHash
instance Witch.From.From U.Codebase.HashTags.PatchHash Unison.Hash32.Hash32
instance Witch.From.From Unison.Hash32.Hash32 U.Codebase.HashTags.PatchHash
instance GHC.Show.Show U.Codebase.HashTags.CausalHash
instance Witch.From.From U.Codebase.HashTags.CausalHash Data.Text.Internal.Text
instance Witch.From.From U.Codebase.HashTags.CausalHash Unison.Hash.Hash
instance Witch.From.From Unison.Hash.Hash U.Codebase.HashTags.CausalHash
instance Witch.From.From U.Codebase.HashTags.CausalHash Unison.Hash32.Hash32
instance Witch.From.From Unison.Hash32.Hash32 U.Codebase.HashTags.CausalHash
instance GHC.Show.Show U.Codebase.HashTags.BranchHash
instance Witch.From.From U.Codebase.HashTags.BranchHash Data.Text.Internal.Text
instance Witch.From.From U.Codebase.HashTags.BranchHash Unison.Hash.Hash
instance Witch.From.From Unison.Hash.Hash U.Codebase.HashTags.BranchHash
instance Witch.From.From U.Codebase.HashTags.BranchHash Unison.Hash32.Hash32
instance Witch.From.From Unison.Hash32.Hash32 U.Codebase.HashTags.BranchHash
instance GHC.Show.Show U.Codebase.HashTags.ComponentHash
instance Witch.From.From U.Codebase.HashTags.ComponentHash Data.Text.Internal.Text
instance Witch.From.From U.Codebase.HashTags.ComponentHash Unison.Hash.Hash
instance Witch.From.From Unison.Hash.Hash U.Codebase.HashTags.ComponentHash
instance Witch.From.From U.Codebase.HashTags.ComponentHash Unison.Hash32.Hash32
instance Witch.From.From Unison.Hash32.Hash32 U.Codebase.HashTags.ComponentHash

module U.Core.ABT.Var

-- | A class for avoiding accidental variable capture
--   
--   <ul>
--   <li>`Set.notMember (freshIn vs v) vs`: <a>freshIn</a> returns a
--   variable not used in the <a>Set</a></li>
--   </ul>
class (Ord v) => Var v
freshIn :: Var v => Set v -> v -> v

module U.Core.ABT
data ABT f v r
Var :: v -> ABT f v r
Cycle :: r -> ABT f v r
Abs :: v -> r -> ABT f v r
Tm :: f r -> ABT f v r

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data Term f v a
Term :: Set v -> a -> ABT f v (Term f v a) -> Term f v a
[freeVars] :: Term f v a -> Set v
[annotation] :: Term f v a -> a
[out] :: Term f v a -> ABT f v (Term f v a)
data Term' f v a x
Term' :: Set v -> a -> ABT f v x -> Term' f v a x
[freeVars'] :: Term' f v a x -> Set v
[annotation'] :: Term' f v a x -> a
[out'] :: Term' f v a x -> ABT f v x
amap :: Functor f => (a -> a') -> Term f v a -> Term f v a'
vmap :: (Functor f, Foldable f, Ord v') => (v -> v') -> Term f v a -> Term f v' a
vmapM :: (Applicative m, Traversable f, Foldable f, Ord v2) => (v -> m v2) -> Term f v a -> m (Term f v2 a)
transform :: (Ord v, Foldable g, Functor g) => (forall a. f a -> g a) -> Term f v a -> Term g v a
transformM :: (Ord v, Monad m, Traversable g) => (forall a. f a -> m (g a)) -> Term f v a -> m (Term g v a)
abs :: Ord v => a -> v -> Term f v a -> Term f v a
var :: a -> v -> Term f v a
cycle :: a -> Term f v a -> Term f v a
tm :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a

-- | `visit f t` applies an effectful function to each subtree of
--   <tt>t</tt> and sequences the results. When <tt>f</tt> returns
--   <a>Nothing</a>, <a>visit</a> descends into the children of the current
--   subtree. When <tt>f</tt> returns `Just t2`, <a>visit</a> replaces the
--   current subtree with <tt>t2</tt>. Thus: `visit (const Nothing) t ==
--   pure t` and `visit (const (Just (pure t2))) t == pure t2`
visit :: (Traversable f, Applicative g, Ord v) => (Term f v a -> Maybe (g (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit' :: (Traversable f, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit_ :: (Traversable f, Applicative g, Ord v) => (f (Term f v a) -> g ()) -> Term f v a -> g (Term f v a)

-- | <a>visit</a> specialized to the <a>Identity</a> effect.
visitPure :: (Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a
foreachSubterm :: (Traversable f, Applicative g) => (Term f v a -> g b) -> Term f v a -> g [b]
subterms :: (Ord v, Traversable f) => Term f v a -> [Term f v a]
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> Term f v a -> Term f v a
pattern AbsN' :: [v] -> Term f v a -> Term f v a
pattern Tm' :: f (Term f v a) -> Term f v a
unabs :: Term f v a -> ([v], Term f v a)

-- | Produce a variable which is free in both terms
freshInBoth :: Var v => Term f v a -> Term f v a -> v -> v
substsInheritAnnotation :: (Foldable f, Functor f, Var v) => [(v, Term f v b)] -> Term f v a -> Term f v a
substInheritAnnotation :: (Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a
subst' :: (Foldable f, Functor f, Var v) => (a -> Term f v a) -> v -> Set v -> Term f v a -> Term f v a

-- | renames <tt>old</tt> to <tt>new</tt> in the given term, ignoring
--   subtrees that bind <tt>old</tt>
rename :: (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a
allVars :: Foldable f => Term f v a -> [v]

-- | Freshens the given variable wrt. the set of used variables tracked by
--   state. Adds the result to the set of used variables.
freshenS :: (Var v, MonadState (Set v) m) => v -> m v

-- | A more general version of <a>freshenS</a> that uses a lens to focus on
--   used variables inside state.
freshenS' :: (Var v, MonadState s m) => Lens' s (Set v) -> v -> m v
instance GHC.Generics.Generic (U.Core.ABT.ABT f v r)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.ABT f v)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.ABT f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.ABT f v)
instance (GHC.Show.Show v, GHC.Show.Show r, GHC.Show.Show (f r)) => GHC.Show.Show (U.Core.ABT.ABT f v r)
instance (GHC.Classes.Eq v, GHC.Classes.Eq r, GHC.Classes.Eq (f r)) => GHC.Classes.Eq (U.Core.ABT.ABT f v r)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (U.Core.ABT.Term f v)
instance GHC.Generics.Generic (U.Core.ABT.Term f v a)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (U.Core.ABT.Term f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.Term f v)
instance GHC.Base.Functor f => GHC.Base.Functor (U.Core.ABT.Term' f v a)
instance GHC.Base.Functor f => Unison.Util.Recursion.Recursive (U.Core.ABT.Term f v a) (U.Core.ABT.Term' f v a)
instance (Data.Foldable.Foldable f, GHC.Base.Functor f, forall a1. GHC.Classes.Eq a1 => GHC.Classes.Eq (f a1), U.Core.ABT.Var.Var v) => GHC.Classes.Eq (U.Core.ABT.Term f v a)
instance (forall a1. GHC.Classes.Eq a1 => GHC.Classes.Eq (f a1), Data.Foldable.Foldable f, GHC.Base.Functor f, forall a1. GHC.Classes.Ord a1 => GHC.Classes.Ord (f a1), U.Core.ABT.Var.Var v) => GHC.Classes.Ord (U.Core.ABT.Term f v a)
instance (forall a1. GHC.Show.Show a1 => GHC.Show.Show (f a1), GHC.Show.Show v) => GHC.Show.Show (U.Core.ABT.Term f v a)


-- | Project-related types.
--   
--   A larger API, including orphan instances for parsing from <a>Text</a>,
--   is available in <a>Unison.Project</a>. Here, we just define the types,
--   which are shared among the low-level database layer (which assumes
--   without verifying that project names and such are syntactically valid)
--   and the higher-level project manipulation exposed by UCM.
module Unison.Core.Project

-- | The name of a project.
newtype ProjectName
UnsafeProjectName :: Text -> ProjectName

-- | The name of a branch of a project.
newtype ProjectBranchName
UnsafeProjectBranchName :: Text -> ProjectBranchName

-- | A generic data structure that contains information about a project and
--   a branch in that project.
data ProjectAndBranch a b
ProjectAndBranch :: a -> b -> ProjectAndBranch a b
[project] :: ProjectAndBranch a b -> a
[branch] :: ProjectAndBranch a b -> b
instance GHC.Generics.Generic Unison.Core.Project.ProjectName
instance GHC.Show.Show Unison.Core.Project.ProjectName
instance GHC.Classes.Ord Unison.Core.Project.ProjectName
instance GHC.Classes.Eq Unison.Core.Project.ProjectName
instance GHC.Generics.Generic Unison.Core.Project.ProjectBranchName
instance GHC.Show.Show Unison.Core.Project.ProjectBranchName
instance GHC.Classes.Ord Unison.Core.Project.ProjectBranchName
instance GHC.Classes.Eq Unison.Core.Project.ProjectBranchName
instance GHC.Base.Functor (Unison.Core.Project.ProjectAndBranch a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Unison.Core.Project.ProjectAndBranch a b)
instance GHC.Generics.Generic (Unison.Core.Project.ProjectAndBranch a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Unison.Core.Project.ProjectAndBranch a b)
instance Data.Bifunctor.Bifunctor Unison.Core.Project.ProjectAndBranch
instance Data.Bifoldable.Bifoldable Unison.Core.Project.ProjectAndBranch
instance Data.Bitraversable.Bitraversable Unison.Core.Project.ProjectAndBranch

module Unison.ShortHash
data ShortHash
Builtin :: Text -> ShortHash
ShortHash :: Text -> Maybe Word64 -> Maybe Word64 -> ShortHash
[prefix] :: ShortHash -> Text
[cycle] :: ShortHash -> Maybe Word64
[cid] :: ShortHash -> Maybe Word64
newtype ShortCausalHash
ShortCausalHash :: Text -> ShortCausalHash
[shortCausalHashToText] :: ShortCausalHash -> Text
newtype ShortNamespaceHash
ShortNamespaceHash :: Text -> ShortNamespaceHash
[shortNamespaceHashToText] :: ShortNamespaceHash -> Text
isPrefixOf :: ShortHash -> ShortHash -> Bool
shortenTo :: Int -> ShortHash -> ShortHash
fromText :: Text -> Maybe ShortHash
toText :: ShortHash -> Text
instance GHC.Show.Show Unison.ShortHash.ShortHash
instance GHC.Classes.Ord Unison.ShortHash.ShortHash
instance GHC.Classes.Eq Unison.ShortHash.ShortHash
instance GHC.Show.Show Unison.ShortHash.ShortCausalHash
instance GHC.Classes.Ord Unison.ShortHash.ShortCausalHash
instance GHC.Classes.Eq Unison.ShortHash.ShortCausalHash
instance GHC.Show.Show Unison.ShortHash.ShortNamespaceHash
instance GHC.Classes.Ord Unison.ShortHash.ShortNamespaceHash
instance GHC.Classes.Eq Unison.ShortHash.ShortNamespaceHash

module U.Codebase.Reference

-- | This is the canonical representation of Reference
type Reference = Reference' Text Hash

-- | A possibly-self (R = "recursive") reference.
type RReference = Reference' Text (Maybe Hash)

-- | A term reference.
type TermReference = Reference

-- | A possibly-self term reference.
type TermRReference = RReference

-- | A term reference id.
type TermReferenceId = Id

-- | A type declaration reference.
type TypeReference = Reference

-- | A possibly-self type declaration reference.
type TypeRReference = RReference

-- | A type declaration reference id.
type TypeReferenceId = Id

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   Used for both terms and types.
data Reference' t h
ReferenceBuiltin :: t -> Reference' t h
ReferenceDerived :: Id' h -> Reference' t h

-- | A type declaration reference.
type TermReference' t h = Reference' t h

-- | A term declaration reference.
type TypeReference' t h = Reference' t h
data ReferenceType
RtTerm :: ReferenceType
RtType :: ReferenceType
pattern Derived :: h -> Pos -> Reference' t h
type Id = Id' Hash

-- | <tt>Pos</tt> is a position into a cycle, as cycles are hashed
--   together.
data Id' h
Id :: h -> Pos -> Id' h
type Pos = Word64
_ReferenceDerived :: Prism (Reference' t h) (Reference' t h') (Id' h) (Id' h')
_RReferenceReference :: Prism' (Reference' t (Maybe h)) (Reference' t h)
t_ :: Prism (Reference' t h) (Reference' t' h) t t'
h_ :: Traversal (Reference' t h) (Reference' t h') h h'
idH :: Lens (Id' h) (Id' h') h h'
idPos :: Lens' (Id' h) Pos
idToHash :: Id -> Hash
idToShortHash :: Id -> ShortHash
isBuiltin :: Reference -> Bool
toShortHash :: Reference -> ShortHash
toId :: Reference -> Maybe Id
unsafeId :: Reference -> Id
component :: Hash -> [k] -> [(k, Id)]
instance GHC.Show.Show U.Codebase.Reference.ReferenceType
instance GHC.Classes.Ord U.Codebase.Reference.ReferenceType
instance GHC.Classes.Eq U.Codebase.Reference.ReferenceType
instance Data.Traversable.Traversable U.Codebase.Reference.Id'
instance Data.Foldable.Foldable U.Codebase.Reference.Id'
instance GHC.Base.Functor U.Codebase.Reference.Id'
instance GHC.Show.Show h => GHC.Show.Show (U.Codebase.Reference.Id' h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (U.Codebase.Reference.Id' h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (U.Codebase.Reference.Id' h)
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Reference.Reference' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Reference.Reference' t h)
instance GHC.Base.Functor (U.Codebase.Reference.Reference' t)
instance GHC.Generics.Generic (U.Codebase.Reference.Reference' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Reference.Reference' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Reference.Reference'
instance Data.Bifoldable.Bifoldable U.Codebase.Reference.Reference'
instance Data.Bitraversable.Bitraversable U.Codebase.Reference.Reference'

module Unison.Util.Alphabetical
class (Eq n) => Alphabetical n
compareAlphabetical :: Alphabetical n => n -> n -> Ordering
sortAlphabetically :: Alphabetical a => [a] -> [a]
sortAlphabeticallyOn :: Alphabetical a => (b -> a) -> [b] -> [b]
newtype OrderAlphabetically a
OrderAlphabetically :: a -> OrderAlphabetically a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Data.Foldable.Foldable Unison.Util.Alphabetical.OrderAlphabetically
instance Data.Traversable.Traversable Unison.Util.Alphabetical.OrderAlphabetically
instance GHC.Base.Functor Unison.Util.Alphabetical.OrderAlphabetically
instance (GHC.Classes.Eq a, Unison.Util.Alphabetical.Alphabetical a) => GHC.Classes.Ord (Unison.Util.Alphabetical.OrderAlphabetically a)
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical [a]
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical (GHC.Base.NonEmpty a)
instance Unison.Util.Alphabetical.Alphabetical a => Unison.Util.Alphabetical.Alphabetical (GHC.Maybe.Maybe a)
instance Unison.Util.Alphabetical.Alphabetical Data.Text.Internal.Text


-- | This module exposes the underlying representation of
--   <a>NameSegment</a>, and thus should only be imported by parsers &amp;
--   printers.
module Unison.NameSegment.Internal

-- | Represents the parts of a name between the <tt>.</tt>s.
newtype NameSegment
NameSegment :: Text -> NameSegment

-- | Convert a name segment to unescaped text.
--   
--   You might use this when storing a name segment as text in a database,
--   where the literal name segment bytes are all that matter. However, you
--   wouldn't use this to display the name segment to a user - that depends
--   on concrete syntax. See Unison.Syntax.NameSegment (or indeed, some
--   actual yet-built interface that abstracts concrete syntax) for that
--   kind of function.
--   
--   <pre>
--   toUnescapedText (unsafeFromText ".~") = ".~"
--   </pre>
[toUnescapedText] :: NameSegment -> Text
instance Unison.Util.Alphabetical.Alphabetical Unison.NameSegment.Internal.NameSegment
instance GHC.Show.Show Unison.NameSegment.Internal.NameSegment
instance GHC.Classes.Ord Unison.NameSegment.Internal.NameSegment
instance GHC.Generics.Generic Unison.NameSegment.Internal.NameSegment
instance GHC.Classes.Eq Unison.NameSegment.Internal.NameSegment
instance (TypeError ...) => Data.String.IsString Unison.NameSegment.Internal.NameSegment

module Unison.NameSegment

-- | Represents the parts of a name between the <tt>.</tt>s.
data NameSegment

-- | Convert a name segment to unescaped text.
--   
--   You might use this when storing a name segment as text in a database,
--   where the literal name segment bytes are all that matter. However, you
--   wouldn't use this to display the name segment to a user - that depends
--   on concrete syntax. See Unison.Syntax.NameSegment (or indeed, some
--   actual yet-built interface that abstracts concrete syntax) for that
--   kind of function.
--   
--   <pre>
--   toUnescapedText (unsafeFromText ".~") = ".~"
--   </pre>
toUnescapedText :: NameSegment -> Text
defaultPatchSegment :: NameSegment
docSegment :: NameSegment
libSegment :: NameSegment
pattern LibSegment :: NameSegment
publicLooseCodeSegment :: NameSegment
baseSegment :: NameSegment
snocSegment :: NameSegment
consSegment :: NameSegment
concatSegment :: NameSegment
watchSegment :: NameSegment
setSegment :: NameSegment
modifySegment :: NameSegment
licenseSegment :: NameSegment
metadataSegment :: NameSegment
authorsSegment :: NameSegment
copyrightHoldersSegment :: NameSegment
guidSegment :: NameSegment
builtinSegment :: NameSegment
