-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Contravariant functors
--   
--   Contravariant functors.
@package contravariant
@version 1.5.5


-- | This module supplies contravariant analogues to the <a>Applicative</a>
--   and <a>Alternative</a> classes.
module Data.Functor.Contravariant.Divisible

-- | A <a>Divisible</a> contravariant functor is the contravariant analogue
--   of <a>Applicative</a>.
--   
--   Continuing the intuition that <a>Contravariant</a> functors consume
--   input, a <a>Divisible</a> contravariant functor also has the ability
--   to be composed "beside" another contravariant functor.
--   
--   Serializers provide a good example of <a>Divisible</a> contravariant
--   functors. To begin let's start with the type of serializers for
--   specific types:
--   
--   <pre>
--   newtype Serializer a = Serializer { runSerializer :: a -&gt; ByteString }
--   </pre>
--   
--   This is a contravariant functor:
--   
--   <pre>
--   instance Contravariant Serializer where
--     contramap f s = Serializer (runSerializer s . f)
--   </pre>
--   
--   That is, given a serializer for <tt>a</tt> (<tt>s :: Serializer
--   a</tt>), and a way to turn <tt>b</tt>s into <tt>a</tt>s (a mapping
--   <tt>f :: b -&gt; a</tt>), we have a serializer for <tt>b</tt>:
--   <tt>contramap f s :: Serializer b</tt>.
--   
--   Divisible gives us a way to combine two serializers that focus on
--   different parts of a structure. If we postulate the existance of two
--   primitive serializers - <tt>string :: Serializer String</tt> and
--   <tt>int :: Serializer Int</tt>, we would like to be able to combine
--   these into a serializer for pairs of <tt>String</tt>s and
--   <tt>Int</tt>s. How can we do this? Simply run both serializers and
--   combine their output!
--   
--   <pre>
--   data StringAndInt = StringAndInt String Int
--   
--   stringAndInt :: Serializer StringAndInt
--   stringAndInt = Serializer $ \(StringAndInt s i) -&gt;
--     let sBytes = runSerializer string s
--         iBytes = runSerializer int i
--     in sBytes &lt;&gt; iBytes
--   </pre>
--   
--   <a>divide</a> is a generalization by also taking a <a>contramap</a>
--   like function to split any <tt>a</tt> into a pair. This conveniently
--   allows you to target fields of a record, for instance, by extracting
--   the values under two fields and combining them into a tuple.
--   
--   To complete the example, here is how to write <tt>stringAndInt</tt>
--   using a <tt>Divisible</tt> instance:
--   
--   <pre>
--   instance Divisible Serializer where
--     conquer = Serializer (const mempty)
--   
--     divide toBC bSerializer cSerializer = Serializer $ \a -&gt;
--       case toBC a of
--         (b, c) -&gt;
--           let bBytes = runSerializer bSerializer b
--               cBytes = runSerializer cSerializer c
--           in bBytes &lt;&gt; cBytes
--   
--   stringAndInt :: Serializer StringAndInt
--   stringAndInt =
--     divide (\(StringAndInt s i) -&gt; (s, i)) string int
--   </pre>
class Contravariant f => Divisible f
divide :: Divisible f => (a -> (b, c)) -> f b -> f c -> f a

-- | Conquer acts as an identity for combining <tt>Divisible</tt> functors.
conquer :: Divisible f => f a

-- | <pre>
--   <a>divided</a> = <a>divide</a> <a>id</a>
--   </pre>
divided :: Divisible f => f a -> f b -> f (a, b)

-- | Redundant, but provided for symmetry.
--   
--   <pre>
--   <a>conquered</a> = <a>conquer</a>
--   </pre>
conquered :: Divisible f => f ()

-- | This is the divisible analogue of <a>liftA</a>. It gives a viable
--   default definition for <a>contramap</a> in terms of the members of
--   <a>Divisible</a>.
--   
--   <pre>
--   <a>liftD</a> f = <a>divide</a> ((,) () . f) <a>conquer</a>
--   </pre>
liftD :: Divisible f => (a -> b) -> f b -> f a

-- | A <a>Decidable</a> contravariant functor is the contravariant analogue
--   of <a>Alternative</a>.
--   
--   Noting the superclass constraint that <tt>f</tt> must also be
--   <a>Divisible</a>, a <tt>Decidable</tt> functor has the ability to "fan
--   out" input, under the intuition that contravariant functors consume
--   input.
--   
--   In the discussion for <tt>Divisible</tt>, an example was demonstrated
--   with <tt>Serializer</tt>s, that turn <tt>a</tt>s into
--   <tt>ByteString</tt>s. <tt>Divisible</tt> allowed us to serialize the
--   <i>product</i> of multiple values by concatenation. By making our
--   <tt>Serializer</tt> also <tt>Decidable</tt>- we now have the ability
--   to serialize the <i>sum</i> of multiple values - for example different
--   constructors in an ADT.
--   
--   Consider serializing arbitrary identifiers that can be either
--   <tt>String</tt>s or <tt>Int</tt>s:
--   
--   <pre>
--   data Identifier = StringId String | IntId Int
--   </pre>
--   
--   We know we have serializers for <tt>String</tt>s and <tt>Int</tt>s,
--   but how do we combine them into a <tt>Serializer</tt> for
--   <tt>Identifier</tt>? Essentially, our <tt>Serializer</tt> needs to
--   scrutinise the incoming value and choose how to serialize it:
--   
--   <pre>
--   identifier :: Serializer Identifier
--   identifier = Serializer $ \identifier -&gt;
--     case identifier of
--       StringId s -&gt; runSerializer string s
--       IntId i -&gt; runSerializer int i
--   </pre>
--   
--   It is exactly this notion of choice that <tt>Decidable</tt> encodes.
--   Hence if we add an instance of <tt>Decidable</tt> for
--   <tt>Serializer</tt>...
--   
--   <pre>
--   instance Decidable Serializer where
--     lose f = Serializer $ \a -&gt; absurd (f a)
--     choose split l r = Serializer $ \a -&gt;
--       either (runSerializer l) (runSerializer r) (split a)
--   </pre>
--   
--   Then our <tt>identifier</tt> <tt>Serializer</tt> is
--   
--   <pre>
--   identifier :: Serializer Identifier
--   identifier = choose toEither string int where
--     toEither (StringId s) = Left s
--     toEither (IntId i) = Right i
--   </pre>
class Divisible f => Decidable f

-- | Acts as identity to <a>choose</a>.
lose :: Decidable f => (a -> Void) -> f a
choose :: Decidable f => (a -> Either b c) -> f b -> f c -> f a

-- | <pre>
--   <a>chosen</a> = <a>choose</a> <a>id</a>
--   </pre>
chosen :: Decidable f => f b -> f c -> f (Either b c)

-- | <pre>
--   <a>lost</a> = <a>lose</a> <a>id</a>
--   </pre>
lost :: Decidable f => f Void
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Decidable Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Divisible.Decidable GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Decidable m => Data.Functor.Contravariant.Divisible.Decidable (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Divisible.Decidable f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Decidable Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divisible.Decidable Data.StateVar.SettableStateVar
instance GHC.Base.Monoid r => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divisible.Divisible Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Const.Const m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Divisible.Divisible GHC.Generics.U1
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:*: g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divisible.Divisible m => Data.Functor.Contravariant.Divisible.Divisible (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Compose.Compose f g)
instance GHC.Base.Monoid m => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Constant.Constant m)
instance (Data.Functor.Contravariant.Divisible.Divisible f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Divisible.Divisible Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divisible.Divisible Data.StateVar.SettableStateVar


-- | Composition of contravariant functors.
module Data.Functor.Contravariant.Compose

-- | Composition of two contravariant functors
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)

-- | Composition of covariant and contravariant functors
newtype ComposeFC f g a
ComposeFC :: f (g a) -> ComposeFC f g a
[getComposeFC] :: ComposeFC f g a -> f (g a)

-- | Composition of contravariant and covariant functors
newtype ComposeCF f g a
ComposeCF :: f (g a) -> ComposeCF f g a
[getComposeCF] :: ComposeCF f g a -> f (g a)
instance (Data.Functor.Contravariant.Contravariant f, GHC.Base.Functor g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (Data.Functor.Contravariant.Divisible.Divisible f, GHC.Base.Applicative g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Divisible g) => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (GHC.Base.Applicative f, Data.Functor.Contravariant.Divisible.Decidable g) => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => GHC.Base.Functor (Data.Functor.Contravariant.Compose.Compose f g)


module Data.Functor.Contravariant.Generic

-- | This provides machinery for deconstructing an arbitrary <a>Generic</a>
--   instance using a <a>Decidable</a> <a>Contravariant</a> functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare :: <a>Deciding</a> <a>Ord</a> a =&gt; a -&gt; a -&gt; <a>Ordering</a>
--   gcompare = <a>getComparison</a> $ <a>deciding</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> <a>compare</a>)
--   </pre>
--   
--   <pre>
--   geq :: <a>Deciding</a> <a>Eq</a> a =&gt; a -&gt; a -&gt; <a>Bool</a>
--   geq = <a>getEquivalence</a> $ <a>deciding</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>))
--   </pre>
class (Generic a, GDeciding q (Rep' a)) => Deciding q a
deciding :: (Deciding q a, Decidable f) => p q -> (forall b. q b => f b) -> f a

-- | This provides machinery for deconstructing an arbitrary
--   <a>Generic1</a> instance using a <a>Decidable</a> <a>Contravariant</a>
--   functor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   gcompare1 :: <a>Deciding1</a> <a>Ord</a> f =&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; f a -&gt; f a -&gt; <a>Ordering</a>
--   gcompare1 f = <a>getComparison</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Ord</a>) (<a>Comparison</a> compare) (<a>Comparison</a> f)
--   </pre>
--   
--   <pre>
--   geq1 :: <a>Deciding1</a> <a>Eq</a> f =&gt; (a -&gt; a -&gt; <a>Bool</a>) -&gt; f a -&gt; f a -&gt; <a>Bool</a>
--   geq1 f = <a>getEquivalence</a> $ <a>deciding1</a> (Proxy :: Proxy <a>Eq</a>) (<a>Equivalence</a> (<a>==</a>)) (<a>Equivalence</a> f)
--   </pre>
class (Generic1 t, GDeciding1 q (Rep1' t)) => Deciding1 q t
deciding1 :: (Deciding1 q t, Decidable f) => p q -> (forall b. q b => f b) -> f a -> f (t a)
instance (GHC.Generics.Generic1 t, Data.Functor.Contravariant.Generic.GDeciding1 q (Data.Functor.Contravariant.Generic.Rep1' t), Data.Functor.Contravariant.Generic.GG (GHC.Generics.Rep1 t)) => Data.Functor.Contravariant.Generic.Deciding1 q t
instance Data.Functor.Contravariant.Generic.Deciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.V1
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f Data.Functor.Contravariant.Generic.::*: g)
instance (Data.Functor.Contravariant.Generic.GDeciding1 q f, Data.Functor.Contravariant.Generic.GDeciding1 q g) => Data.Functor.Contravariant.Generic.GDeciding1 q (f Data.Functor.Contravariant.Generic.::+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.K1 i p)
instance Data.Functor.Contravariant.Generic.GDeciding1 q f => Data.Functor.Contravariant.Generic.GDeciding1 q (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GDeciding1 q GHC.Generics.Par1
instance (GHC.Generics.Generic a, Data.Functor.Contravariant.Generic.GG (GHC.Generics.Rep a), Data.Functor.Contravariant.Generic.GDeciding q (Data.Functor.Contravariant.Generic.Rep' a)) => Data.Functor.Contravariant.Generic.Deciding q a
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GDeciding q GHC.Generics.V1
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f Data.Functor.Contravariant.Generic.::*: g)
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) (g :: k -> *). (Data.Functor.Contravariant.Generic.GDeciding q f, Data.Functor.Contravariant.Generic.GDeciding q g) => Data.Functor.Contravariant.Generic.GDeciding q (f Data.Functor.Contravariant.Generic.::+: g)
instance q p => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.K1 i p)
instance forall k (q :: * -> GHC.Types.Constraint) (f :: k -> *) i (c :: GHC.Generics.Meta). Data.Functor.Contravariant.Generic.GDeciding q f => Data.Functor.Contravariant.Generic.GDeciding q (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GG f => Data.Functor.Contravariant.Generic.GG (GHC.Generics.M1 i c f)
instance Data.Functor.Contravariant.Generic.GG GHC.Generics.V1
instance Data.Functor.Contravariant.Generic.GG GHC.Generics.U1
instance Data.Functor.Contravariant.Generic.GG (GHC.Generics.K1 i c)
instance Data.Functor.Contravariant.Generic.GG GHC.Generics.Par1
instance Data.Functor.Contravariant.Generic.GG (GHC.Generics.Rec1 f)
instance (Data.Functor.Contravariant.Generic.GG f, Data.Functor.Contravariant.Generic.GG g) => Data.Functor.Contravariant.Generic.GG (f GHC.Generics.:+: g)
instance (Data.Functor.Contravariant.Generic.GG f, Data.Functor.Contravariant.Generic.GG g) => Data.Functor.Contravariant.Generic.GG (f GHC.Generics.:*: g)
