-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Conversion from strings to Integer
--   
--   The naive <tt>foldl' (acc d -&gt; acc * 10 + d) 0</tt> is expensive
--   (quadratic!) for large <tt>Integer</tt>s. This package provides
--   sub-quadratic implementation.
@package integer-conversion
@version 0.1.0.1


-- | The naive left fold to convert digits to integer is quadratic as
--   multiplying (big) <a>Integer</a>s is not a constant time operation.
--   
--   This module provides sub-quadratic algorithm for conversion of
--   <a>Text</a> or <a>ByteString</a> into <a>Integer</a>.
--   
--   For example for a text of 262144 9 digits, fold implementation takes
--   1.5 seconds, and <a>textToInteger</a> just 26 milliseconds on my
--   machine. Difference is already noticeable around 100-200 digits.
--   
--   In particular <a>read</a> is correct (i.e. faster) than
--   <tt>List.foldl'</tt> (better complexity), <a>stringToInteger</a> is a
--   bit faster than <a>read</a> (same complexity, lower coeffcient).
module Data.Integer.Conversion

-- | Convert <a>Text</a> to <a>Integer</a>.
--   
--   Semantically same as <tt>T.foldl' (acc c -&gt; acc * 10 + toInteger
--   (ord c - 48)) 0</tt>, but this is more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; textToInteger "123456789"
--   123456789
--   </pre>
--   
--   For non-decimal inputs some nonsense is calculated
--   
--   <pre>
--   &gt;&gt;&gt; textToInteger "foobar"
--   6098556
--   </pre>
textToInteger :: Text -> Integer

-- | Convert <a>ByteString</a> to <a>Integer</a>.
--   
--   Semantically same as <tt>BS.foldl' (acc c -&gt; acc * 10 + toInteger c
--   - 48) 0</tt>, but this is more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; byteStringToInteger "123456789"
--   123456789
--   </pre>
--   
--   For non-decimal inputs some nonsense is calculated
--   
--   <pre>
--   &gt;&gt;&gt; byteStringToInteger "foobar"
--   6098556
--   </pre>
byteStringToInteger :: ByteString -> Integer

-- | Convert <a>String</a> to <a>Integer</a>.
--   
--   Semantically same as <tt>List.foldl' (acc c -&gt; acc * 10 + toInteger
--   c - 48) 0</tt>, but this is more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; stringToInteger "123456789"
--   123456789
--   </pre>
--   
--   For non-decimal inputs some nonsense is calculated
--   
--   <pre>
--   &gt;&gt;&gt; stringToInteger "foobar"
--   6098556
--   </pre>
stringToInteger :: String -> Integer

-- | Convert <a>String</a> to <a>Integer</a> when you know the length
--   beforehand.
--   
--   <pre>
--   &gt;&gt;&gt; stringToIntegerWithLen "123" 3
--   123
--   </pre>
--   
--   If the length is wrong, you may get wrong results. (Simple algorithm
--   is used for short strings).
--   
--   <pre>
--   &gt;&gt;&gt; stringToIntegerWithLen (replicate 40 '0' ++ "123") 45
--   12300
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToIntegerWithLen (replicate 40 '0' ++ "123") 44
--   1200
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stringToIntegerWithLen (replicate 40 '0' ++ "123") 42
--   12
--   </pre>
stringToIntegerWithLen :: String -> Int -> Integer
