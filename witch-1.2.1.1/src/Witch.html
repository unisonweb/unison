<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | The Witch package is a library that allows you to confidently convert</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- values between various types. This module exports everything you need to</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- perform conversions or define your own. It is designed to be imported</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- unqualified, so getting started is as easy as:</span><span>
</span><span id="line-5"></span><span class="hs-comment">--</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- &gt;&gt;&gt; import Witch</span><span>
</span><span id="line-7"></span><span class="hs-comment">--</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- In typical usage, the functions that you will use most often are</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- 'Witch.Utility.into' for conversions that always succeed and</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- 'Witch.Utility.tryInto' for conversions that sometimes fail.</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Please consider reading the blog post that announces this library:</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- &lt;https://taylor.fausak.me/2021/07/13/witch/&gt;</span><span>
</span><span id="line-14"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Witch</span><span>
</span><span id="line-15"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Type classes</span></span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** From</span></span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Witch.From.html#From"><span class="hs-identifier">Witch.From.From</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Witch.From.html#from"><span class="hs-identifier">from</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#into"><span class="hs-identifier">Witch.Utility.into</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** TryFrom</span></span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><a href="Witch.TryFrom.html#TryFrom"><span class="hs-identifier">Witch.TryFrom.TryFrom</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Witch.TryFrom.html#tryFrom"><span class="hs-identifier">tryFrom</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#tryInto"><span class="hs-identifier">Witch.Utility.tryInto</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Data types</span></span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Witch.TryFromException.html#TryFromException"><span class="hs-identifier">Witch.TryFromException.TryFromException</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Encodings</span></span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#ISO_8859_1"><span class="hs-identifier">Witch.Encoding.ISO_8859_1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#UTF_8"><span class="hs-identifier">Witch.Encoding.UTF_8</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#UTF_16LE"><span class="hs-identifier">Witch.Encoding.UTF_16LE</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#UTF_16BE"><span class="hs-identifier">Witch.Encoding.UTF_16BE</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#UTF_32LE"><span class="hs-identifier">Witch.Encoding.UTF_32LE</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><a href="Witch.Encoding.html#UTF_32BE"><span class="hs-identifier">Witch.Encoding.UTF_32BE</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Utilities</span></span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#via"><span class="hs-identifier">Witch.Utility.via</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#tryVia"><span class="hs-identifier">Witch.Utility.tryVia</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#maybeTryFrom"><span class="hs-identifier">Witch.Utility.maybeTryFrom</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#eitherTryFrom"><span class="hs-identifier">Witch.Utility.eitherTryFrom</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Unsafe</span></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span>    </span><span class="hs-comment">-- | These functions should only be used in two circumstances: When you know</span><span>
</span><span id="line-45"></span><span>    </span><span class="hs-comment">-- a conversion is safe even though you can't prove it to the compiler, and</span><span>
</span><span id="line-46"></span><span>    </span><span class="hs-comment">-- when you're alright with your program crashing if the conversion fails.</span><span>
</span><span id="line-47"></span><span>    </span><span class="hs-comment">-- In all other cases you should prefer the normal conversion functions like</span><span>
</span><span id="line-48"></span><span>    </span><span class="hs-comment">-- 'Witch.TryFrom.tryFrom'. And if you're converting a literal value,</span><span>
</span><span id="line-49"></span><span>    </span><span class="hs-comment">-- consider using the Template Haskell conversion functions like</span><span>
</span><span id="line-50"></span><span>    </span><span class="hs-comment">-- 'Witch.Lift.liftedFrom'.</span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#unsafeFrom"><span class="hs-identifier">Witch.Utility.unsafeFrom</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Witch.Utility.html#unsafeInto"><span class="hs-identifier">Witch.Utility.unsafeInto</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Template Haskell</span></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span>    </span><span class="hs-comment">-- | This library uses /typed/ Template Haskell, which may be a little</span><span>
</span><span id="line-57"></span><span>    </span><span class="hs-comment">-- different than what you're used to. Normally Template Haskell uses the</span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-comment">-- @$(...)@ syntax for splicing in things to run at compile time. The typed</span><span>
</span><span id="line-59"></span><span>    </span><span class="hs-comment">-- variant uses the @$$(...)@ syntax for splices, doubling up on the dollar</span><span>
</span><span id="line-60"></span><span>    </span><span class="hs-comment">-- signs. Other than that, using typed Template Haskell should be pretty</span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-comment">-- much the same as using regular Template Haskell.</span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><a href="Witch.Lift.html#liftedFrom"><span class="hs-identifier">Witch.Lift.liftedFrom</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><a href="Witch.Lift.html#liftedInto"><span class="hs-identifier">Witch.Lift.liftedInto</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Notes</span></span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Motivation</span></span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span>    </span><span class="hs-comment">-- | Haskell provides many ways to convert between common types, and core</span><span>
</span><span id="line-70"></span><span>    </span><span class="hs-comment">-- libraries add even more. It can be challenging to know which function to</span><span>
</span><span id="line-71"></span><span>    </span><span class="hs-comment">-- use when converting from some source type @a@ to some target type @b@. It</span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-comment">-- can be even harder to know if that conversion is safe or if there are any</span><span>
</span><span id="line-73"></span><span>    </span><span class="hs-comment">-- pitfalls to watch out for.</span><span>
</span><span id="line-74"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-75"></span><span>    </span><span class="hs-comment">-- This library tries to address that problem by providing a common</span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-comment">-- interface for converting between types. The 'Witch.From.From' type class</span><span>
</span><span id="line-77"></span><span>    </span><span class="hs-comment">-- is for conversions that cannot fail, and the 'Witch.TryFrom.TryFrom' type</span><span>
</span><span id="line-78"></span><span>    </span><span class="hs-comment">-- class is for conversions that can fail. These type classes are inspired</span><span>
</span><span id="line-79"></span><span>    </span><span class="hs-comment">-- by the [@From@](https://doc.rust-lang.org/std/convert/trait.From.html)</span><span>
</span><span id="line-80"></span><span>    </span><span class="hs-comment">-- trait in Rust.</span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Type applications</span></span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-comment">-- | Although you can use this library without the [@TypeApplications@](https://downloads.haskell.org/ghc/9.6.1/docs/users_guide/exts/type_applications.html)</span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-comment">-- language extension, the extension is strongly recommended. Since most</span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-comment">-- functions provided by this library are polymorphic in at least one type</span><span>
</span><span id="line-87"></span><span>    </span><span class="hs-comment">-- variable, it's easy to use them in a situation that would be ambiguous.</span><span>
</span><span id="line-88"></span><span>    </span><span class="hs-comment">-- Normally you could resolve the ambiguity with an explicit type signature,</span><span>
</span><span id="line-89"></span><span>    </span><span class="hs-comment">-- but type applications are much more ergonomic. For example:</span><span>
</span><span id="line-90"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-91"></span><span>    </span><span class="hs-comment">-- &gt; -- Avoid this:</span><span>
</span><span id="line-92"></span><span>    </span><span class="hs-comment">-- &gt; f . (from :: Int8 -&gt; Int16) . g</span><span>
</span><span id="line-93"></span><span>    </span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-comment">-- &gt; -- Prefer this:</span><span>
</span><span id="line-95"></span><span>    </span><span class="hs-comment">-- &gt; f . from @Int8 @Int16 . g</span><span>
</span><span id="line-96"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-97"></span><span>    </span><span class="hs-comment">-- Most functions in this library have two versions with their type</span><span>
</span><span id="line-98"></span><span>    </span><span class="hs-comment">-- variables in opposite orders. That's because usually one side of the</span><span>
</span><span id="line-99"></span><span>    </span><span class="hs-comment">-- conversion or the other already has its type inferred by context. In</span><span>
</span><span id="line-100"></span><span>    </span><span class="hs-comment">-- those situations it makes sense to only provide one type argument.</span><span>
</span><span id="line-101"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-102"></span><span>    </span><span class="hs-comment">-- &gt; -- Avoid this: (assuming f :: Int16 -&gt; ...)</span><span>
</span><span id="line-103"></span><span>    </span><span class="hs-comment">-- &gt; f $ from @Int8 @Int16 0</span><span>
</span><span id="line-104"></span><span>    </span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-105"></span><span>    </span><span class="hs-comment">-- &gt; -- Prefer this:</span><span>
</span><span id="line-106"></span><span>    </span><span class="hs-comment">-- &gt; f $ from @Int8 0</span><span>
</span><span id="line-107"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-108"></span><span>    </span><span class="hs-comment">-- &gt; -- Avoid this: (assuming x :: Int8)</span><span>
</span><span id="line-109"></span><span>    </span><span class="hs-comment">-- &gt; g $ from @Int8 @Int16 x</span><span>
</span><span id="line-110"></span><span>    </span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-111"></span><span>    </span><span class="hs-comment">-- &gt; -- Prefer this:</span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-comment">-- &gt; g $ into @Int16 x</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Alternatives</span></span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span>    </span><span class="hs-comment">-- | Many Haskell libraries already provide similar functionality. How is</span><span>
</span><span id="line-117"></span><span>    </span><span class="hs-comment">-- this library different?</span><span>
</span><span id="line-118"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-119"></span><span>    </span><span class="hs-comment">-- - [@Coercible@](https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Coerce.html#t:Coercible):</span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-comment">--   This type class is solved by the compiler, but it only works for types</span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-comment">--   that have the same runtime representation. This is very convenient for</span><span>
</span><span id="line-122"></span><span>    </span><span class="hs-comment">--   @newtype@s, but it does not work for converting between arbitrary types</span><span>
</span><span id="line-123"></span><span>    </span><span class="hs-comment">--   like @Int8@ and @Int16@.</span><span>
</span><span id="line-124"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-125"></span><span>    </span><span class="hs-comment">-- - [@Convertible@](https://hackage.haskell.org/package/convertible-1.1.1.0/docs/Data-Convertible-Base.html#t:Convertible):</span><span>
</span><span id="line-126"></span><span>    </span><span class="hs-comment">--   This popular conversion type class is similar to what this library</span><span>
</span><span id="line-127"></span><span>    </span><span class="hs-comment">--   provides. The main difference is that it does not differentiate between</span><span>
</span><span id="line-128"></span><span>    </span><span class="hs-comment">--   conversions that can fail and those that cannot.</span><span>
</span><span id="line-129"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-130"></span><span>    </span><span class="hs-comment">-- - [@From@](https://hackage.haskell.org/package/basement-0.0.11/docs/Basement-From.html#t:From):</span><span>
</span><span id="line-131"></span><span>    </span><span class="hs-comment">--   This type class is almost identical to what this library provides.</span><span>
</span><span id="line-132"></span><span>    </span><span class="hs-comment">--   Unfortunately it is part of the @basement@ package, which is an</span><span>
</span><span id="line-133"></span><span>    </span><span class="hs-comment">--   alternative standard library that some people may not want to depend</span><span>
</span><span id="line-134"></span><span>    </span><span class="hs-comment">--   on.</span><span>
</span><span id="line-135"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-comment">-- - [@Inj@](https://hackage.haskell.org/package/inj-1.0/docs/Inj.html#t:Inj):</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-comment">--   This type class requires instances to be an injection, which means that</span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-comment">--   no two input values should map to the same output. That restriction</span><span>
</span><span id="line-139"></span><span>    </span><span class="hs-comment">--   prohibits many useful instances. Also many instances throw impure</span><span>
</span><span id="line-140"></span><span>    </span><span class="hs-comment">--   exceptions.</span><span>
</span><span id="line-141"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-comment">-- In addition to those general-purpose type classes, there are many</span><span>
</span><span id="line-143"></span><span>    </span><span class="hs-comment">-- alternatives for more specific conversions. How does this library compare</span><span>
</span><span id="line-144"></span><span>    </span><span class="hs-comment">-- to those?</span><span>
</span><span id="line-145"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span>    </span><span class="hs-comment">-- - Monomorphic conversion functions like [@Data.Text.pack@](https://hackage.haskell.org/package/text-1.2.4.1/docs/Data-Text.html#v:pack)</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-comment">--   are explicit but not necessarily convenient. It can be tedious to</span><span>
</span><span id="line-148"></span><span>    </span><span class="hs-comment">--   manage the imports necessary to use the functions. And if you want to</span><span>
</span><span id="line-149"></span><span>    </span><span class="hs-comment">--   put them in a custom prelude, you will have to come up with your own</span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-comment">--   names.</span><span>
</span><span id="line-151"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-152"></span><span>    </span><span class="hs-comment">-- - Polymorphic conversion methods like 'toEnum' are more convenient but</span><span>
</span><span id="line-153"></span><span>    </span><span class="hs-comment">--   may have unwanted semantics or runtime behavior. For example the 'Enum'</span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-comment">--   type class is more or less tied to the 'Int' data type and frequently</span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-comment">--   throws impure exceptions.</span><span>
</span><span id="line-156"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-comment">-- - Polymorphic conversion functions like 'fromIntegral' are very</span><span>
</span><span id="line-158"></span><span>    </span><span class="hs-comment">--   convenient. Unfortunately it can be challenging to know which types</span><span>
</span><span id="line-159"></span><span>    </span><span class="hs-comment">--   have the instances necessary to make the conversion possible. And even</span><span>
</span><span id="line-160"></span><span>    </span><span class="hs-comment">--   if the conversion is possible, is it safe? For example converting a</span><span>
</span><span id="line-161"></span><span>    </span><span class="hs-comment">--   negative 'Int' into a 'Word' will overflow, which may be surprising.</span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Instances</span></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span>    </span><span class="hs-comment">-- | When should you add a 'Witch.From.From' (or 'Witch.TryFrom.TryFrom')</span><span>
</span><span id="line-166"></span><span>    </span><span class="hs-comment">-- instance for some pair of types? This is a surprisingly tricky question</span><span>
</span><span id="line-167"></span><span>    </span><span class="hs-comment">-- to answer precisely. Instances are driven more by guidelines than rules.</span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-comment">-- - Conversions must not throw impure exceptions. This means no 'undefined'</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-comment">--   or anything equivalent to it.</span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-comment">-- - Conversions should be unambiguous. If there are multiple reasonable</span><span>
</span><span id="line-173"></span><span>    </span><span class="hs-comment">--   ways to convert from @a@ to @b@, then you probably should not add a</span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-comment">--   'Witch.From.From' instance for them.</span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">-- - Conversions should be lossless. If you have @From a b@ then no two @a@</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">--   values should be converted to the same @b@ value.</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-comment">--     - Some conversions necessarily lose information, like converting from</span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-comment">--       a list into a set.</span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">-- - If you have both @From a b@ and @From b a@, then</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">--   @from \@b \@a . from \@a \@b@ should be the same as 'id'. In other</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">--   words, @a@ and @b@ are isomorphic.</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">--     - This often true, but not always. For example, converting a list</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">--       into a set will remove duplicates. And then converting back into a</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">--       list will put the elements in ascending order.</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">-- - If you have both @From a b@ and @From b c@, then you could also have</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">--   @From a c@ and it should be the same as @from \@b \@c . from \@a \@b@.</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">--   In other words, @From@ is transitive.</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">--     - This is not always true. For example an @Int8@ may be represented</span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">--       as a number in JSON, whereas an @Int64@ might be represented as a</span><span>
</span><span id="line-196"></span><span>    </span><span class="hs-comment">--       string. That means @into \@JSON (into \@Int64 int8)@ would not be</span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-comment">--       the same as @into \@JSON int8@.</span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-comment">-- - You should not have both a @From@ instance and a @TryFrom@ instance for</span><span>
</span><span id="line-200"></span><span>    </span><span class="hs-comment">--   the same pair of types.</span><span>
</span><span id="line-201"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-202"></span><span>    </span><span class="hs-comment">-- - If you have a @From@ or @TryFrom@ instance for a pair of types, then</span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-comment">--   you should probably have a @From@ or @TryFrom@ instance for the same</span><span>
</span><span id="line-204"></span><span>    </span><span class="hs-comment">--   pair of types but in the opposite direction. In other words if you have</span><span>
</span><span id="line-205"></span><span>    </span><span class="hs-comment">--   @From a b@ then you should have @From b a@ or @TryFrom b a@.</span><span>
</span><span id="line-206"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-comment">-- In general if @s@ /is/ a @t@, then you should add a 'Witch.From.From'</span><span>
</span><span id="line-208"></span><span>    </span><span class="hs-comment">-- instance for it. But if @s@ merely /can be/ a @t@, then you could add a</span><span>
</span><span id="line-209"></span><span>    </span><span class="hs-comment">-- 'Witch.TryFrom.TryFrom' instance for it. And if it is technically</span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-comment">-- possible to convert from @s@ to @t@ but there are a lot of caveats, you</span><span>
</span><span id="line-211"></span><span>    </span><span class="hs-comment">-- probably should not write any instances at all.</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Laws</span></span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span>    </span><span class="hs-comment">-- | As the previous section notes, there aren't any cut and dried laws for</span><span>
</span><span id="line-216"></span><span>    </span><span class="hs-comment">-- the @From@ and @TryFrom@ type classes. However it can be useful to</span><span>
</span><span id="line-217"></span><span>    </span><span class="hs-comment">-- consider the following equations for guiding instances:</span><span>
</span><span id="line-218"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-219"></span><span>    </span><span class="hs-comment">-- &gt; -- same strictness</span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-comment">-- &gt; seq (from @a @b x) y = seq x y</span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-comment">-- &gt; seq (tryFrom @a @b x) y = seq x y</span><span>
</span><span id="line-222"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-223"></span><span>    </span><span class="hs-comment">-- &gt; -- round trip</span><span>
</span><span id="line-224"></span><span>    </span><span class="hs-comment">-- &gt; from @b @a (from @a @b x) = x</span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-226"></span><span>    </span><span class="hs-comment">-- &gt; -- transitive</span><span>
</span><span id="line-227"></span><span>    </span><span class="hs-comment">-- &gt; from @b @c (from @a @b x) = from @a @c x</span><span>
</span><span id="line-228"></span><span>    </span><span class="hs-comment">-- &gt; tryFrom @b @a (from @a @b x) = Right x</span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-comment">-- &gt; if isRight (tryFrom @a @b x) then</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-comment">-- &gt;   fmap (from @b @a) (tryFrom @a @b x) = Right x</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-comment">-- &gt; if isRight (tryFrom @a @b x) then do</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-comment">-- &gt;   fmap (tryFrom @b @a) (tryFrom @a @b x) = Right (Right x)</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Integral types</span></span><span>
</span><span id="line-235"></span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-comment">-- | There are a lot of types that represent various different ranges of</span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-comment">-- integers, and Witch may not provide the instances you want. In particular</span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-comment">-- it does not provide a total way to convert from an @Int32@ into an @Int@.</span><span>
</span><span id="line-239"></span><span>    </span><span class="hs-comment">-- Why is that?</span><span>
</span><span id="line-240"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-241"></span><span>    </span><span class="hs-comment">-- The Haskell Language Report only demands that @Int@s have at least 30</span><span>
</span><span id="line-242"></span><span>    </span><span class="hs-comment">-- bits of precision. That means a reasonable Haskell implementation could</span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-comment">-- have an @Int@ type that's smaller than the @Int32@ type.</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-comment">-- However in practice everyone uses the same Haskell implementation: GHC.</span><span>
</span><span id="line-246"></span><span>    </span><span class="hs-comment">-- And with GHC the @Int@ type always has 32 bits of precision, even on</span><span>
</span><span id="line-247"></span><span>    </span><span class="hs-comment">-- 32-bit architectures. So for almost everybody, it's probably safe to use</span><span>
</span><span id="line-248"></span><span>    </span><span class="hs-comment">-- @unsafeFrom \@Int32 \@Int@. Similarly most software these days runs on</span><span>
</span><span id="line-249"></span><span>    </span><span class="hs-comment">-- machines with 64-bit architectures. That means it's also probably safe</span><span>
</span><span id="line-250"></span><span>    </span><span class="hs-comment">-- for you to use @unsafeFrom \@Int64 \@Int@.</span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-252"></span><span>    </span><span class="hs-comment">-- All of the above also applies for @Word@, @Word32@, and @Word64@.</span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Downsides</span></span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span>    </span><span class="hs-comment">-- | As the author of this library, I obviously think that everyone should</span><span>
</span><span id="line-257"></span><span>    </span><span class="hs-comment">-- use it because it's the greatest thing since sliced bread. But nothing is</span><span>
</span><span id="line-258"></span><span>    </span><span class="hs-comment">-- perfect, so what are some downsides to this library?</span><span>
</span><span id="line-259"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-260"></span><span>    </span><span class="hs-comment">-- - More specific type classes are often better. For example, @IsString s@</span><span>
</span><span id="line-261"></span><span>    </span><span class="hs-comment">--   is more useful that @From String s@. The former says that the type @s@</span><span>
</span><span id="line-262"></span><span>    </span><span class="hs-comment">--   is the same as a string literal, but the latter just says you can</span><span>
</span><span id="line-263"></span><span>    </span><span class="hs-comment">--   produce a value of type @s@ when given a string.</span><span>
</span><span id="line-264"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-265"></span><span>    </span><span class="hs-comment">-- - The @From@ type class works great for specific pairs of types, but can</span><span>
</span><span id="line-266"></span><span>    </span><span class="hs-comment">--   get confusing when it's polymorphic. For example if you have some</span><span>
</span><span id="line-267"></span><span>    </span><span class="hs-comment">--   function with a @From s t@ constraint, that doesn't really tell you</span><span>
</span><span id="line-268"></span><span>    </span><span class="hs-comment">--   anything about what it's doing.</span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-270"></span><span class="hs-keyword">where</span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.Encoding.html"><span class="hs-identifier">Witch.Encoding</span></a></span><span>
</span><span id="line-273"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.From.html"><span class="hs-identifier">Witch.From</span></a></span><span>
</span><span id="line-274"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Witch.Instances.html"><span class="hs-identifier">Witch.Instances</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-275"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.Lift.html"><span class="hs-identifier">Witch.Lift</span></a></span><span>
</span><span id="line-276"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.TryFrom.html"><span class="hs-identifier">Witch.TryFrom</span></a></span><span>
</span><span id="line-277"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.TryFromException.html"><span class="hs-identifier">Witch.TryFromException</span></a></span><span>
</span><span id="line-278"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Witch.Utility.html"><span class="hs-identifier">Witch.Utility</span></a></span><span>
</span><span id="line-279"></span></pre></body></html>