-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Align and Zip type-classes from the common Semialign ancestor.
--   
--   The major use of <tt>These</tt> of this is provided by the
--   <tt>align</tt> member of <tt>Semialign</tt> class, representing a
--   generalized notion of "zipping with padding" that combines structures
--   without truncating to the size of the smaller input.
--   
--   It turns out that <tt>zip</tt> operation fits well the
--   <tt>Semialign</tt> class, forming lattice-like structure.
@package semialign
@version 1.3.1


-- | Zipping and aligning of indexed functors.
module Data.Semialign.Indexed

-- | Indexed version of <a>Semialign</a>.
class (FunctorWithIndex i f, Semialign f) => SemialignWithIndex i f | f -> i

-- | Analogous to <a>alignWith</a>, but also provides an index.
ialignWith :: SemialignWithIndex i f => (i -> These a b -> c) -> f a -> f b -> f c

-- | Indexed version of <a>Zip</a>.
class (SemialignWithIndex i f, Zip f) => ZipWithIndex i f | f -> i

-- | Analogous to <a>zipWith</a>, but also provides an index.
izipWith :: ZipWithIndex i f => (i -> a -> b -> c) -> f a -> f b -> f c

-- | Indexed version of <a>Repeat</a>.
class (ZipWithIndex i f, Repeat f) => RepeatWithIndex i f | f -> i

-- | Analogous to <a>repeat</a>, but also provides an index.
--   
--   This should be the same as <tt>tabulate</tt> for representable
--   functors.
irepeat :: RepeatWithIndex i f => (i -> a) -> f a


-- | Zipping and aligning of functors with non-uniform shapes.
module Data.Semialign

-- | Functors supporting an <a>align</a> operation that takes the union of
--   non-uniform shapes.
--   
--   Minimal definition: either <a>align</a> or <a>alignWith</a>.
--   
--   <h2>Laws</h2>
--   
--   The laws of <a>align</a> and <a>zip</a> resemble lattice laws. There
--   is a plenty of laws, but they are simply satisfied.
--   
--   And an additional property if <tt>f</tt> is <tt>Foldable</tt>, which
--   tries to enforce <a>align</a>-feel: neither values are duplicated nor
--   lost.
--   
--   <i>Note:</i> <tt><tt>join</tt> f x = f x x</tt>
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   join align ≡ fmap (join These)
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   align x y ≡ swap &lt;$&gt; align y x
--   </pre>
--   
--   <i>Associativity</i>
--   
--   <pre>
--   align x (align y z) ≡ assoc &lt;$&gt; align (align x y) z
--   </pre>
--   
--   <i>With</i>
--   
--   <pre>
--   alignWith f a b ≡ f &lt;$&gt; align a b
--   </pre>
--   
--   <i>Functoriality</i>
--   
--   <pre>
--   align (f &lt;$&gt; x) (g &lt;$&gt; y) ≡ bimap f g &lt;$&gt; align x y
--   </pre>
--   
--   <i>Alignedness</i>, if <tt>f</tt> is <tt>Foldable</tt>
--   
--   <pre>
--   toList x ≡ toListOf (folded . here) (align x y)
--            ≡ mapMaybe justHere (toList (align x y))
--   </pre>
class Functor f => Semialign f

-- | Analogous to <tt><a>zip</a></tt>, combines two structures by taking
--   the union of their shapes and using <tt><a>These</a></tt> to hold the
--   elements.
align :: Semialign f => f a -> f b -> f (These a b)

-- | Analogous to <tt><a>zipWith</a></tt>, combines two structures by
--   taking the union of their shapes and combining the elements with the
--   given function.
alignWith :: Semialign f => (These a b -> c) -> f a -> f b -> f c

-- | A unit of <a>align</a>.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   (`align` nil) ≡ fmap This
--   (nil `align`) ≡ fmap That
--   </pre>
class Semialign f => Align f

-- | An empty structure. <tt><a>align</a></tt>ing with <tt><a>nil</a></tt>
--   will produce a structure with the same shape and elements as the other
--   input, modulo <tt><a>This</a></tt> or <tt><a>That</a></tt>.
nil :: Align f => f a

-- | Alignable functors supporting an "inverse" to <a>align</a>: splitting
--   a union shape into its component parts.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   uncurry align (unalign xs) ≡ xs
--   unalign (align xs ys) ≡ (xs, ys)
--   </pre>
--   
--   <h2>Compatibility note</h2>
--   
--   In version 1 <a>unalign</a> was changed to return <tt>(f a, f b)</tt>
--   pair, instead of <tt>(f (Just a), f (Just b))</tt>. Old behaviour can
--   be achieved with if ever needed.
--   
--   <pre>
--   &gt;&gt;&gt; unzipWith (unalign . Just) [This 'a', That 'b', These 'c' 'd']
--   ([Just 'a',Nothing,Just 'c'],[Nothing,Just 'b',Just 'd'])
--   </pre>
class Semialign f => Unalign f
unalign :: Unalign f => f (These a b) -> (f a, f b)
unalignWith :: Unalign f => (c -> These a b) -> f c -> (f a, f b)

-- | Functors supporting a <a>zip</a> operation that takes the intersection
--   of non-uniform shapes.
--   
--   Minimal definition: either <a>zip</a> or <a>zipWith</a>.
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   join zip   ≡ fmap (join (,))
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   zip x y ≡ swap &lt;$&gt; zip y x
--   </pre>
--   
--   <i>Associativity</i>
--   
--   <pre>
--   zip x (zip y z) ≡ assoc &lt;$&gt; zip (zip x y) z
--   </pre>
--   
--   <i>Absorption</i>
--   
--   <pre>
--   fst    &lt;$&gt; zip xs (align xs ys) ≡ xs
--   toThis &lt;$&gt; align xs (zip xs ys) ≡ This &lt;$&gt; xs
--     where
--       toThis (This a)    = This a
--       toThis (These a _) = This a
--       toThis (That b)    = That b
--   </pre>
--   
--   <i>With</i>
--   
--   <pre>
--   zipWith f a b ≡ f &lt;$&gt; zip a b
--   </pre>
--   
--   <i>Functoriality</i>
--   
--   <pre>
--   zip (f &lt;$&gt; x) (g &lt;$&gt; y) ≡ bimap f g &lt;$&gt; zip x y
--   </pre>
--   
--   <i>Zippyness</i>
--   
--   <pre>
--   fmap fst (zip x x) ≡ x
--   fmap snd (zip x x) ≡ x
--   zip (fmap fst x) (fmap snd x) ≡ x
--   </pre>
--   
--   <i>Distributivity</i>
--   
--   <pre>
--                      align (zip xs ys) zs ≡ undistrThesePair &lt;$&gt; zip (align xs zs) (align ys zs)
--   distrPairThese &lt;$&gt; zip (align xs ys) zs ≡                      align (zip xs zs) (zip ys zs)
--                      zip (align xs ys) zs ≡ undistrPairThese &lt;$&gt; align (zip xs zs) (zip ys zs)
--   </pre>
--   
--   <i>Note</i>, the following doesn't hold:
--   
--   <pre>
--   distrThesePair &lt;$&gt; align (zip xs ys) zs ≢ zip (align xs zs) (align ys zs)
--   </pre>
--   
--   when <tt>xs = []</tt> and <tt>ys = zs = [0]</tt>, then the left hand
--   side is "only" <tt>[(<a>That</a> 0, <a>That</a> 0)]</tt>, but the
--   right hand side is <tt>[(<a>That</a> 0, <a>These</a> 0 0)]</tt>.
class Semialign f => Zip f

-- | Combines two structures by taking the intersection of their shapes and
--   using pair to hold the elements.
zip :: Zip f => f a -> f b -> f (a, b)

-- | Combines two structures by taking the intersection of their shapes and
--   combining the elements with the given function.
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c

-- | Zippable functors supporting left and right units
--   
--   <i>Unit</i>
--   
--   <pre>
--   fst &lt;$&gt; zip xs (repeat y) ≡ xs
--   snd &lt;$&gt; zip (repeat x) ys ≡ ys
--   </pre>
class Zip f => Repeat f

-- | A <i>repeat</i> structure.
repeat :: Repeat f => a -> f a

-- | Right inverse of <a>zip</a>.
--   
--   This class is definable for every <a>Functor</a>. See
--   <a>unzipDefault</a>.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   uncurry zip (unzip xs) ≡ xs
--   unzip (zip xs xs) ≡ (xs, xs)
--   </pre>
--   
--   Note:
--   
--   <pre>
--   unzip (zip xs ys) ≢ (xs, _) or (_, ys)
--   </pre>
--   
--   For sequence-like types this holds, but for Map-like it doesn't.
class Zip f => Unzip f
unzipWith :: Unzip f => (c -> (a, b)) -> f c -> (f a, f b)
unzip :: Unzip f => f (a, b) -> (f a, f b)
unzipDefault :: Functor f => f (a, b) -> (f a, f b)

-- | Align two structures and combine with <a>&lt;&gt;</a>.
salign :: (Semialign f, Semigroup a) => f a -> f a -> f a

-- | Align two structures as in <a>zip</a>, but filling in blanks with
--   <a>Nothing</a>.
padZip :: Semialign f => f a -> f b -> f (Maybe a, Maybe b)

-- | Align two structures as in <a>zipWith</a>, but filling in blanks with
--   <a>Nothing</a>.
padZipWith :: Semialign f => (Maybe a -> Maybe b -> c) -> f a -> f b -> f c

-- | Left-padded <a>zip</a>.
lpadZip :: [a] -> [b] -> [(Maybe a, b)]

-- | Left-padded <a>zipWith</a>.
lpadZipWith :: (Maybe a -> b -> c) -> [a] -> [b] -> [c]

-- | Right-padded <a>zip</a>.
rpadZip :: [a] -> [b] -> [(a, Maybe b)]

-- | Right-padded <a>zipWith</a>.
rpadZipWith :: (a -> Maybe b -> c) -> [a] -> [b] -> [c]
alignVectorWith :: (Vector v a, Vector v b, Vector v c) => (These a b -> c) -> v a -> v b -> v c


-- | <tt>These</tt>-based aligning and unaligning of functors with
--   non-uniform shapes.
--   
--   For a traversals traversal of (bi)foldable (bi)functors through said
--   functors see <a>Data.Crosswalk</a>.
module Data.Align

-- | Functors supporting an <a>align</a> operation that takes the union of
--   non-uniform shapes.
--   
--   Minimal definition: either <a>align</a> or <a>alignWith</a>.
--   
--   <h2>Laws</h2>
--   
--   The laws of <a>align</a> and <a>zip</a> resemble lattice laws. There
--   is a plenty of laws, but they are simply satisfied.
--   
--   And an additional property if <tt>f</tt> is <tt>Foldable</tt>, which
--   tries to enforce <a>align</a>-feel: neither values are duplicated nor
--   lost.
--   
--   <i>Note:</i> <tt><tt>join</tt> f x = f x x</tt>
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   join align ≡ fmap (join These)
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   align x y ≡ swap &lt;$&gt; align y x
--   </pre>
--   
--   <i>Associativity</i>
--   
--   <pre>
--   align x (align y z) ≡ assoc &lt;$&gt; align (align x y) z
--   </pre>
--   
--   <i>With</i>
--   
--   <pre>
--   alignWith f a b ≡ f &lt;$&gt; align a b
--   </pre>
--   
--   <i>Functoriality</i>
--   
--   <pre>
--   align (f &lt;$&gt; x) (g &lt;$&gt; y) ≡ bimap f g &lt;$&gt; align x y
--   </pre>
--   
--   <i>Alignedness</i>, if <tt>f</tt> is <tt>Foldable</tt>
--   
--   <pre>
--   toList x ≡ toListOf (folded . here) (align x y)
--            ≡ mapMaybe justHere (toList (align x y))
--   </pre>
class Functor f => Semialign f

-- | Analogous to <tt><a>zip</a></tt>, combines two structures by taking
--   the union of their shapes and using <tt><a>These</a></tt> to hold the
--   elements.
align :: Semialign f => f a -> f b -> f (These a b)

-- | Analogous to <tt><a>zipWith</a></tt>, combines two structures by
--   taking the union of their shapes and combining the elements with the
--   given function.
alignWith :: Semialign f => (These a b -> c) -> f a -> f b -> f c

-- | A unit of <a>align</a>.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   (`align` nil) ≡ fmap This
--   (nil `align`) ≡ fmap That
--   </pre>
class Semialign f => Align f

-- | An empty structure. <tt><a>align</a></tt>ing with <tt><a>nil</a></tt>
--   will produce a structure with the same shape and elements as the other
--   input, modulo <tt><a>This</a></tt> or <tt><a>That</a></tt>.
nil :: Align f => f a

-- | Alignable functors supporting an "inverse" to <a>align</a>: splitting
--   a union shape into its component parts.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   uncurry align (unalign xs) ≡ xs
--   unalign (align xs ys) ≡ (xs, ys)
--   </pre>
--   
--   <h2>Compatibility note</h2>
--   
--   In version 1 <a>unalign</a> was changed to return <tt>(f a, f b)</tt>
--   pair, instead of <tt>(f (Just a), f (Just b))</tt>. Old behaviour can
--   be achieved with if ever needed.
--   
--   <pre>
--   &gt;&gt;&gt; unzipWith (unalign . Just) [This 'a', That 'b', These 'c' 'd']
--   ([Just 'a',Nothing,Just 'c'],[Nothing,Just 'b',Just 'd'])
--   </pre>
class Semialign f => Unalign f
unalign :: Unalign f => f (These a b) -> (f a, f b)
unalignWith :: Unalign f => (c -> These a b) -> f c -> (f a, f b)

-- | Align two structures and combine with <a>&lt;&gt;</a>.
salign :: (Semialign f, Semigroup a) => f a -> f a -> f a

-- | Align two structures as in <a>zip</a>, but filling in blanks with
--   <a>Nothing</a>.
padZip :: Semialign f => f a -> f b -> f (Maybe a, Maybe b)

-- | Align two structures as in <a>zipWith</a>, but filling in blanks with
--   <a>Nothing</a>.
padZipWith :: Semialign f => (Maybe a -> Maybe b -> c) -> f a -> f b -> f c

-- | Left-padded <a>zip</a>.
lpadZip :: [a] -> [b] -> [(Maybe a, b)]

-- | Left-padded <a>zipWith</a>.
lpadZipWith :: (Maybe a -> b -> c) -> [a] -> [b] -> [c]

-- | Right-padded <a>zip</a>.
rpadZip :: [a] -> [b] -> [(a, Maybe b)]

-- | Right-padded <a>zipWith</a>.
rpadZipWith :: (a -> Maybe b -> c) -> [a] -> [b] -> [c]
alignVectorWith :: (Vector v a, Vector v b, Vector v c) => (These a b -> c) -> v a -> v b -> v c

module Data.Crosswalk

-- | Foldable functors supporting traversal through an alignable functor.
--   
--   Minimal definition: <tt>crosswalk</tt> or <tt>sequenceL</tt>.
--   
--   Laws:
--   
--   <pre>
--   crosswalk (const nil) = const nil
--   crosswalk f = sequenceL . fmap f
--   </pre>
class (Functor t, Foldable t) => Crosswalk t
crosswalk :: (Crosswalk t, Align f) => (a -> f b) -> t a -> f (t b)
sequenceL :: (Crosswalk t, Align f) => t (f a) -> f (t a)

-- | Bifoldable bifunctors supporting traversal through an alignable
--   functor.
--   
--   Minimal definition: <tt>bicrosswalk</tt> or <tt>bisequenceL</tt>.
--   
--   Laws:
--   
--   <pre>
--   bicrosswalk (const empty) (const empty) = const empty
--   bicrosswalk f g = bisequenceL . bimap f g
--   </pre>
class (Bifunctor t, Bifoldable t) => Bicrosswalk t
bicrosswalk :: (Bicrosswalk t, Align f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
bisequenceL :: (Bicrosswalk t, Align f) => t (f a) (f b) -> f (t a b)
instance Data.Crosswalk.Bicrosswalk Data.Either.Either
instance Data.Crosswalk.Bicrosswalk Data.These.These
instance Data.Crosswalk.Crosswalk Data.Functor.Identity.Identity
instance Data.Crosswalk.Crosswalk GHC.Maybe.Maybe
instance Data.Crosswalk.Crosswalk []
instance Data.Crosswalk.Crosswalk Data.Sequence.Internal.Seq
instance Data.Crosswalk.Crosswalk (Data.These.These a)
instance Data.Crosswalk.Crosswalk Data.Vector.Vector
instance Data.Crosswalk.Crosswalk ((,) a)
instance (Data.Crosswalk.Crosswalk f, Data.Crosswalk.Crosswalk g) => Data.Crosswalk.Crosswalk (Data.Functor.Compose.Compose f g)


-- | Zipping and unzipping of functors with non-uniform shapes.
module Data.Zip

-- | Functors supporting an <a>align</a> operation that takes the union of
--   non-uniform shapes.
--   
--   Minimal definition: either <a>align</a> or <a>alignWith</a>.
--   
--   <h2>Laws</h2>
--   
--   The laws of <a>align</a> and <a>zip</a> resemble lattice laws. There
--   is a plenty of laws, but they are simply satisfied.
--   
--   And an additional property if <tt>f</tt> is <tt>Foldable</tt>, which
--   tries to enforce <a>align</a>-feel: neither values are duplicated nor
--   lost.
--   
--   <i>Note:</i> <tt><tt>join</tt> f x = f x x</tt>
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   join align ≡ fmap (join These)
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   align x y ≡ swap &lt;$&gt; align y x
--   </pre>
--   
--   <i>Associativity</i>
--   
--   <pre>
--   align x (align y z) ≡ assoc &lt;$&gt; align (align x y) z
--   </pre>
--   
--   <i>With</i>
--   
--   <pre>
--   alignWith f a b ≡ f &lt;$&gt; align a b
--   </pre>
--   
--   <i>Functoriality</i>
--   
--   <pre>
--   align (f &lt;$&gt; x) (g &lt;$&gt; y) ≡ bimap f g &lt;$&gt; align x y
--   </pre>
--   
--   <i>Alignedness</i>, if <tt>f</tt> is <tt>Foldable</tt>
--   
--   <pre>
--   toList x ≡ toListOf (folded . here) (align x y)
--            ≡ mapMaybe justHere (toList (align x y))
--   </pre>
class Functor f => Semialign f

-- | Analogous to <tt><a>zip</a></tt>, combines two structures by taking
--   the union of their shapes and using <tt><a>These</a></tt> to hold the
--   elements.
align :: Semialign f => f a -> f b -> f (These a b)

-- | Analogous to <tt><a>zipWith</a></tt>, combines two structures by
--   taking the union of their shapes and combining the elements with the
--   given function.
alignWith :: Semialign f => (These a b -> c) -> f a -> f b -> f c

-- | Functors supporting a <a>zip</a> operation that takes the intersection
--   of non-uniform shapes.
--   
--   Minimal definition: either <a>zip</a> or <a>zipWith</a>.
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   join zip   ≡ fmap (join (,))
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   zip x y ≡ swap &lt;$&gt; zip y x
--   </pre>
--   
--   <i>Associativity</i>
--   
--   <pre>
--   zip x (zip y z) ≡ assoc &lt;$&gt; zip (zip x y) z
--   </pre>
--   
--   <i>Absorption</i>
--   
--   <pre>
--   fst    &lt;$&gt; zip xs (align xs ys) ≡ xs
--   toThis &lt;$&gt; align xs (zip xs ys) ≡ This &lt;$&gt; xs
--     where
--       toThis (This a)    = This a
--       toThis (These a _) = This a
--       toThis (That b)    = That b
--   </pre>
--   
--   <i>With</i>
--   
--   <pre>
--   zipWith f a b ≡ f &lt;$&gt; zip a b
--   </pre>
--   
--   <i>Functoriality</i>
--   
--   <pre>
--   zip (f &lt;$&gt; x) (g &lt;$&gt; y) ≡ bimap f g &lt;$&gt; zip x y
--   </pre>
--   
--   <i>Zippyness</i>
--   
--   <pre>
--   fmap fst (zip x x) ≡ x
--   fmap snd (zip x x) ≡ x
--   zip (fmap fst x) (fmap snd x) ≡ x
--   </pre>
--   
--   <i>Distributivity</i>
--   
--   <pre>
--                      align (zip xs ys) zs ≡ undistrThesePair &lt;$&gt; zip (align xs zs) (align ys zs)
--   distrPairThese &lt;$&gt; zip (align xs ys) zs ≡                      align (zip xs zs) (zip ys zs)
--                      zip (align xs ys) zs ≡ undistrPairThese &lt;$&gt; align (zip xs zs) (zip ys zs)
--   </pre>
--   
--   <i>Note</i>, the following doesn't hold:
--   
--   <pre>
--   distrThesePair &lt;$&gt; align (zip xs ys) zs ≢ zip (align xs zs) (align ys zs)
--   </pre>
--   
--   when <tt>xs = []</tt> and <tt>ys = zs = [0]</tt>, then the left hand
--   side is "only" <tt>[(<a>That</a> 0, <a>That</a> 0)]</tt>, but the
--   right hand side is <tt>[(<a>That</a> 0, <a>These</a> 0 0)]</tt>.
class Semialign f => Zip f

-- | Combines two structures by taking the intersection of their shapes and
--   using pair to hold the elements.
zip :: Zip f => f a -> f b -> f (a, b)

-- | Combines two structures by taking the intersection of their shapes and
--   combining the elements with the given function.
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c

-- | Zippable functors supporting left and right units
--   
--   <i>Unit</i>
--   
--   <pre>
--   fst &lt;$&gt; zip xs (repeat y) ≡ xs
--   snd &lt;$&gt; zip (repeat x) ys ≡ ys
--   </pre>
class Zip f => Repeat f

-- | A <i>repeat</i> structure.
repeat :: Repeat f => a -> f a

-- | Right inverse of <a>zip</a>.
--   
--   This class is definable for every <a>Functor</a>. See
--   <a>unzipDefault</a>.
--   
--   <h2>Laws</h2>
--   
--   <pre>
--   uncurry zip (unzip xs) ≡ xs
--   unzip (zip xs xs) ≡ (xs, xs)
--   </pre>
--   
--   Note:
--   
--   <pre>
--   unzip (zip xs ys) ≢ (xs, _) or (_, ys)
--   </pre>
--   
--   For sequence-like types this holds, but for Map-like it doesn't.
class Zip f => Unzip f
unzipWith :: Unzip f => (c -> (a, b)) -> f c -> (f a, f b)
unzip :: Unzip f => f (a, b) -> (f a, f b)
unzipDefault :: Functor f => f (a, b) -> (f a, f b)
newtype Zippy f a
Zippy :: f a -> Zippy f a
[getZippy] :: Zippy f a -> f a
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Zip.Zippy f)
instance GHC.Read.Read (f a) => GHC.Read.Read (Data.Zip.Zippy f a)
instance GHC.Show.Show (f a) => GHC.Show.Show (Data.Zip.Zippy f a)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Zip.Zippy f a)
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Zip.Zippy f a)
instance (Data.Semialign.Internal.Zip f, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Zip.Zippy f a)
instance (Data.Semialign.Internal.Repeat f, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Zip.Zippy f a)
instance Data.Semialign.Internal.Zip f => Data.Functor.Bind.Class.Apply (Data.Zip.Zippy f)
instance Data.Semialign.Internal.Repeat f => GHC.Base.Applicative (Data.Zip.Zippy f)
