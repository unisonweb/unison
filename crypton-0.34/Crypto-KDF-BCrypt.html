<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Crypto.KDF.BCrypt</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">crypton-0.34: Cryptography Primitives sink</span><ul class="links" id="page-menu"><li><a href="src/Crypto.KDF.BCrypt.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Crypto.KDF.BCrypt</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Password encoding and validation using bcrypt.</p><p>Example usage:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Crypto.KDF.BCrypt (hashPassword, validatePassword)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.ByteString.Char8 as B
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let bcryptHash = B.pack &quot;$2a$10$MJJifxfaqQmbx1Mhsq3oq.YmMmfNhkyW4s/MS3K5rIMVfB7w0Q/OW&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let password = B.pack &quot;password&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>validatePassword password bcryptHash
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>True
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let otherPassword = B.pack &quot;otherpassword&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>otherHash &lt;- hashPassword 12 otherPassword :: IO B.ByteString
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>validatePassword otherPassword otherHash
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>True
</code></strong></pre><p>See <a href="https://www.usenix.org/conference/1999-usenix-annual-technical-conference/future-adaptable-password-scheme">https://www.usenix.org/conference/1999-usenix-annual-technical-conference/future-adaptable-password-scheme</a>
 for details of the original algorithm.</p><p>The functions <code>hashPassword</code> and <code>validatePassword</code> should be all that
 most users need.</p><p>Hashes are strings of the form
 <code>$2a$10$MJJifxfaqQmbx1Mhsq3oq.YmMmfNhkyW4s<em>MS3K5rIMVfB7w0Q</em>OW</code> which
 encode a version number, an integer cost parameter and the concatenated
 salt and hash bytes (each separately Base64 encoded. Incrementing the
 cost parameter approximately doubles the time taken to calculate the hash.</p><p>The different version numbers evolved to account for bugs in the standard
 C implementations. They don't represent different versions of the algorithm
 itself and in most cases should produce identical results.
 The most up to date version is <code>2b</code> and this implementation uses the
 <code>2b</code> version prefix, but will also attempt to validate
 against hashes with versions <code>2a</code> and <code>2y</code>. Version <code>2</code> or <code>2x</code> will be
 rejected. No attempt is made to differentiate between the different versions
 when validating a password, but in practice this shouldn't cause any problems
 if passwords are UTF-8 encoded (which they should be) and less than 256
 characters long.</p><p>The cost parameter can be between 4 and 31 inclusive, but anything less than
 10 is probably not strong enough. High values may be prohibitively slow
 depending on your hardware. Choose the highest value you can without having
 an unacceptable impact on your users. The cost parameter can also be varied
 depending on the account, since it is unique to an individual hash.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:hashPassword">hashPassword</a> :: (<a href="Crypto-Random-Types.html#t:MonadRandom" title="Crypto.Random.Types">MonadRandom</a> m, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash) =&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; password -&gt; m hash</li><li class="src short"><a href="#v:validatePassword">validatePassword</a> :: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash) =&gt; password -&gt; hash -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:validatePasswordEither">validatePasswordEither</a> :: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash) =&gt; password -&gt; hash -&gt; <a href="../base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:bcrypt">bcrypt</a> :: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> salt, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> output) =&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; salt -&gt; password -&gt; output</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:hashPassword" class="def">hashPassword</a> <a href="src/Crypto.KDF.BCrypt.html#hashPassword" class="link">Source</a> <a href="#v:hashPassword" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Crypto-Random-Types.html#t:MonadRandom" title="Crypto.Random.Types">MonadRandom</a> m, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>The cost parameter. Should be between 4 and 31 (inclusive).
 Values which lie outside this range will be adjusted accordingly.</p></td></tr><tr><td class="src">-&gt; password</td><td class="doc"><p>The password. Should be the UTF-8 encoded bytes of the password text.</p></td></tr><tr><td class="src">-&gt; m hash</td><td class="doc"><p>The bcrypt hash in standard format.</p></td></tr></table></div><div class="doc"><p>Create a bcrypt hash for a password with a provided cost value.
 Typically used to create a hash when a new user account is registered
 or when a user changes their password.</p><p>Each increment of the cost approximately doubles the time taken.
 The 16 bytes of random salt will be generated internally.</p></div></div><div class="top"><p class="src"><a id="v:validatePassword" class="def">validatePassword</a> :: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash) =&gt; password -&gt; hash -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Crypto.KDF.BCrypt.html#validatePassword" class="link">Source</a> <a href="#v:validatePassword" class="selflink">#</a></p><div class="doc"><p>Check a password against a stored bcrypt hash when authenticating a user.</p><p>Returns <code>False</code> if the password doesn't match the hash, or if the hash is
 invalid or an unsupported version.</p></div></div><div class="top"><p class="src"><a id="v:validatePasswordEither" class="def">validatePasswordEither</a> :: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> hash) =&gt; password -&gt; hash -&gt; <a href="../base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Crypto.KDF.BCrypt.html#validatePasswordEither" class="link">Source</a> <a href="#v:validatePasswordEither" class="selflink">#</a></p><div class="doc"><p>Check a password against a bcrypt hash</p><p>As for <code>validatePassword</code> but will provide error information if the hash is invalid or
 an unsupported version.</p></div></div><div class="top"><p class="src"><a id="v:bcrypt" class="def">bcrypt</a> <a href="src/Crypto.KDF.BCrypt.html#bcrypt" class="link">Source</a> <a href="#v:bcrypt" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> salt, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> password, <a href="../memory-0.18.0/Data-ByteArray.html#t:ByteArray" title="Data.ByteArray">ByteArray</a> output)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>The cost parameter. Should be between 4 and 31 (inclusive).
 Values which lie outside this range will be adjusted accordingly.</p></td></tr><tr><td class="src">-&gt; salt</td><td class="doc"><p>The salt. Must be 16 bytes in length or an error will be raised.</p></td></tr><tr><td class="src">-&gt; password</td><td class="doc"><p>The password. Should be the UTF-8 encoded bytes of the password text.</p></td></tr><tr><td class="src">-&gt; output</td><td class="doc"><p>The bcrypt hash in standard format.</p></td></tr></table></div><div class="doc"><p>Create a bcrypt hash for a password with a provided cost value and salt.</p><p>Cost value under 4 will be automatically adjusted back to 10 for safety reason.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>