-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FoldMap lists
--   
--   FoldMap lists are lists represented by their foldMap function. FoldMap
--   lists have O(1) cons, snoc and append, just like DLists, but other
--   operations might have favorable performance characteristics as well.
--   These wild claims are still completely unverified though.
@package fmlist
@version 0.9.4


-- | FoldMap lists: lists represented by their <a>foldMap</a> function.
--   
--   Examples:
--   
--   <pre>
--   -- A right-infinite list
--   c = 1 `cons` c
--   </pre>
--   
--   <pre>
--   -- A left-infinite list
--   d = d `snoc` 2
--   </pre>
--   
--   <pre>
--   -- A middle-infinite list ??
--   e = c `append` d
--   </pre>
--   
--   <pre>
--   *&gt; head e
--   1
--   *&gt; last e
--   2
--   </pre>
module Data.FMList

-- | <a>FMList</a> is a <a>foldMap</a> function wrapped up in a newtype.
newtype FMList a
FM :: (forall m. Monoid m => (a -> m) -> m) -> FMList a
[unFM] :: FMList a -> forall m. Monoid m => (a -> m) -> m

-- | The function <a>transform</a> transforms a list by changing the map
--   function that is passed to <a>foldMap</a>.
--   
--   It has the following property:
--   
--   <pre>
--   transform a . transform b = transform (b . a)
--   </pre>
--   
--   For example:
--   
--   <ul>
--   <li><pre> m &gt;&gt;= g</pre></li>
--   <li><pre>= flatten (fmap g m)</pre></li>
--   <li><pre>= flatten . fmap g $ m</pre></li>
--   <li><pre>= transform foldMap . transform (. g) $ m</pre></li>
--   <li><pre>= transform ((. g) . foldMap) m</pre></li>
--   <li><pre>= transform (\f -&gt; foldMap f . g) m</pre></li>
--   </ul>
transform :: (forall m. Monoid m => (a -> m) -> b -> m) -> FMList b -> FMList a

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a
singleton :: a -> FMList a
cons :: a -> FMList a -> FMList a
snoc :: FMList a -> a -> FMList a
pair :: a -> a -> FMList a
append :: FMList a -> FMList a -> FMList a
fromList :: [a] -> FMList a
fromFoldable :: Foldable f => f a -> FMList a
null :: FMList a -> Bool
length :: FMList a -> Int
genericLength :: Num b => FMList a -> b
head :: FMList a -> a
tail :: FMList a -> FMList a
last :: FMList a -> a
init :: FMList a -> FMList a
reverse :: FMList a -> FMList a

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]
flatten :: Foldable t => FMList (t a) -> FMList a

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and concat the monoid results.
foldMapA :: (Foldable t, Applicative f, Monoid m) => (a -> f m) -> t a -> f m
filter :: (a -> Bool) -> FMList a -> FMList a
take :: (Ord n, Num n) => n -> FMList a -> FMList a
drop :: (Ord n, Num n) => n -> FMList a -> FMList a
takeWhile :: (a -> Bool) -> FMList a -> FMList a
dropWhile :: (a -> Bool) -> FMList a -> FMList a
zip :: FMList a -> FMList b -> FMList (a, b)
zipWith :: (a -> b -> c) -> FMList a -> FMList b -> FMList c
iterate :: (a -> a) -> a -> FMList a

-- | <a>repeat</a> buids an infinite list of a single value. While
--   infinite, the result is still accessible from both the start and end.
repeat :: a -> FMList a

-- | <a>cycle</a> repeats a list to create an infinite list. It is also
--   accessible from the end, where <tt>last (cycle l)</tt> equals <tt>last
--   l</tt>.
cycle :: FMList a -> FMList a

-- | <a>unfold</a> builds a list from a seed value. The function takes the
--   seed and returns an <a>FMList</a> of values. If the value is
--   <a>Right</a> <tt>a</tt>, then <tt>a</tt> is appended to the result,
--   and if the value is <a>Left</a> <tt>b</tt>, then <tt>b</tt> is used as
--   seed value in a recursive call.
--   
--   A simple use of <a>unfold</a> (simulating unfoldl):
--   
--   <pre>
--   *&gt; unfold (\b -&gt; if b == 0 then empty else Left (b-1) `pair` Right b) 10
--   fromList [1,2,3,4,5,6,7,8,9,10]
--   </pre>
unfold :: (b -> FMList (Either b a)) -> b -> FMList a

-- | <a>unfoldr</a> builds an <a>FMList</a> from a seed value from left to
--   right. The function takes the element and returns <a>Nothing</a> if it
--   is done producing the list or returns <a>Just</a> <tt>(a,b)</tt>, in
--   which case, <tt>a</tt> is a appended to the result and <tt>b</tt> is
--   used as the next seed value in a recursive call.
--   
--   A simple use of <a>unfoldr</a>:
--   
--   <pre>
--   *&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   fromList [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> FMList a
instance (GHC.Base.Applicative f, GHC.Base.Semigroup m) => GHC.Base.Semigroup (Data.FMList.WrapApp f m)
instance (GHC.Base.Applicative f, GHC.Base.Monoid m) => GHC.Base.Monoid (Data.FMList.WrapApp f m)
instance GHC.Base.Functor Data.FMList.FMList
instance Data.Foldable.Foldable Data.FMList.FMList
instance Data.Traversable.Traversable Data.FMList.FMList
instance GHC.Base.Monad Data.FMList.FMList
instance Control.Monad.Fail.MonadFail Data.FMList.FMList
instance GHC.Base.Applicative Data.FMList.FMList
instance GHC.Base.Semigroup (Data.FMList.FMList a)
instance GHC.Base.Monoid (Data.FMList.FMList a)
instance GHC.Base.MonadPlus Data.FMList.FMList
instance GHC.Base.Alternative Data.FMList.FMList
instance GHC.Show.Show a => GHC.Show.Show (Data.FMList.FMList a)
