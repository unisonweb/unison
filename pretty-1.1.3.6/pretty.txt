-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty-printing library
--   
--   This package contains a pretty-printing library, a set of API's that
--   provides a way to easily print out text in a consistent format of your
--   choosing. This is useful for compilers and related tools.
--   
--   This library was originally designed by John Hughes's and has since
--   been heavily modified by Simon Peyton Jones.
@package pretty
@version 1.1.3.6


-- | This module provides a version of pretty that allows for annotations
--   to be attached to documents. Annotations are arbitrary pieces of
--   metadata that can be attached to sub-documents.
module Text.PrettyPrint.Annotated.HughesPJ

-- | The abstract type of documents. A Doc represents a <i>set</i> of
--   layouts. A Doc with no occurrences of Union or NoDoc represents just
--   one layout.
data Doc a

-- | A TextDetails represents a fragment of text that will be output at
--   some point in a <tt>Doc</tt>.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails

-- | An annotation (side-metadata) attached at a particular point in a
--   <tt>Doc</tt>. Allows carrying non-pretty-printed data around in a
--   <tt>Doc</tt> that is attached at particular points in the structure.
--   Once the <tt>Doc</tt> is render to an output type (such as
--   <a>String</a>), we can also retrieve where in the rendered document
--   our annotations start and end (see <a>Span</a> and
--   <a>renderSpans</a>).
data AnnotDetails a
AnnotStart :: AnnotDetails a
NoAnnot :: !TextDetails -> {-# UNPACK #-} !Int -> AnnotDetails a
AnnotEnd :: a -> AnnotDetails a

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc a

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc a

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc a

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc a

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc a
int :: Int -> Doc a
integer :: Integer -> Doc a
float :: Float -> Doc a
double :: Double -> Doc a
rational :: Rational -> Doc a
semi :: Doc a
comma :: Doc a
colon :: Doc a
space :: Doc a
equals :: Doc a
lparen :: Doc a
rparen :: Doc a
lbrack :: Doc a
rbrack :: Doc a
lbrace :: Doc a
rbrace :: Doc a
parens :: Doc a -> Doc a
brackets :: Doc a -> Doc a
braces :: Doc a -> Doc a
quotes :: Doc a -> Doc a
doubleQuotes :: Doc a -> Doc a

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc a -> Doc a

-- | Apply <a>brackets</a> to <a>Doc</a> if boolean is true.
maybeBrackets :: Bool -> Doc a -> Doc a

-- | Apply <a>braces</a> to <a>Doc</a> if boolean is true.
maybeBraces :: Bool -> Doc a -> Doc a

-- | Apply <a>quotes</a> to <a>Doc</a> if boolean is true.
maybeQuotes :: Bool -> Doc a -> Doc a

-- | Apply <a>doubleQuotes</a> to <a>Doc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> Doc a -> Doc a

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc a

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc a -> Doc a -> Doc a
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc a -> Doc a -> Doc a
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc a] -> Doc a

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc a] -> Doc a

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc a -> Doc a -> Doc a
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc a -> Doc a -> Doc a
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc a] -> Doc a

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc a] -> Doc a

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc a] -> Doc a

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc a -> Doc a

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc a -> Int -> Doc a -> Doc a

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc a -> [Doc a] -> [Doc a]

-- | Attach an annotation to a document.
annotate :: a -> Doc a -> Doc a

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc a -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: Doc a -> Doc a -> Doc a

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: Doc a -> RDoc a

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>
--   (see <a>style</a>).
render :: Doc a -> String

-- | Render an annotated <tt>Doc</tt> to a String and list of annotations
--   (see <a>Span</a>) using the default <tt>Style</tt> (see <a>style</a>).
renderSpans :: Doc ann -> (String, [Span ann])

-- | A <tt>Span</tt> represents the result of an annotation after a
--   <tt>Doc</tt> has been rendered, capturing where the annotation now
--   starts and ends in the rendered output.
data Span a
Span :: !Int -> !Int -> a -> Span a
[spanStart] :: Span a -> !Int
[spanLength] :: Span a -> !Int
[spanAnnotation] :: Span a -> a

-- | Render out a String, interpreting the annotations as part of the
--   resulting document.
--   
--   <i>IMPORTANT</i>: the size of the annotation string does NOT figure
--   into the layout of the document, so the document will lay out as
--   though the annotations are not present.
renderDecorated :: (ann -> String) -> (ann -> String) -> Doc ann -> String

-- | Render a document with annotations, by interpreting the start and end
--   of the annotations, as well as the text details in the context of a
--   monad.
renderDecoratedM :: Monad m => (ann -> m r) -> (ann -> m r) -> (String -> m r) -> m r -> Doc ann -> m r

-- | A rendering style. Allows us to specify constraints to choose among
--   the many different rendering options.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode.
[mode] :: Style -> Mode

-- | Maximum length of a line, in characters.
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length. A ribbon refers to the
--   characters on a line <i>excluding</i> indentation. So a
--   <a>lineLength</a> of 100, with a <a>ribbonsPerLine</a> of <tt>2.0</tt>
--   would only allow up to 50 characters of ribbon to be displayed on a
--   line, while allowing it to be indented up to 50 characters.
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc a -> String

-- | Rendering mode.
data Mode

-- | Normal rendering (<a>lineLength</a> and <a>ribbonsPerLine</a>
--   respected').
PageMode :: Mode

-- | With zig-zag cuts.
ZigZagMode :: Mode

-- | No indentation, infinitely long lines (<a>lineLength</a> ignored), but
--   explicit new lines, i.e., <tt>text "one" $$ text "two"</tt>, are
--   respected.
LeftMode :: Mode

-- | All on one line, <a>lineLength</a> ignored and explicit new lines
--   (<tt>$$</tt>) are turned into spaces.
OneLineMode :: Mode

-- | The general rendering interface. Please refer to the <tt>Style</tt>
--   and <tt>Mode</tt> types for a description of rendering mode, line
--   length and ribbons.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc b -> a

-- | The general rendering interface, supporting annotations. Please refer
--   to the <tt>Style</tt> and <tt>Mode</tt> types for a description of
--   rendering mode, line length and ribbons.
fullRenderAnn :: Mode -> Int -> Float -> (AnnotDetails b -> a -> a) -> a -> Doc b -> a
instance GHC.Generics.Generic Text.PrettyPrint.Annotated.HughesPJ.TextDetails
instance GHC.Classes.Eq Text.PrettyPrint.Annotated.HughesPJ.TextDetails
instance GHC.Show.Show Text.PrettyPrint.Annotated.HughesPJ.TextDetails
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.PrettyPrint.Annotated.HughesPJ.AnnotDetails a)
instance GHC.Show.Show a => GHC.Show.Show (Text.PrettyPrint.Annotated.HughesPJ.AnnotDetails a)
instance GHC.Generics.Generic (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Generics.Generic Text.PrettyPrint.Annotated.HughesPJ.Mode
instance GHC.Classes.Eq Text.PrettyPrint.Annotated.HughesPJ.Mode
instance GHC.Show.Show Text.PrettyPrint.Annotated.HughesPJ.Mode
instance GHC.Generics.Generic Text.PrettyPrint.Annotated.HughesPJ.Style
instance GHC.Classes.Eq Text.PrettyPrint.Annotated.HughesPJ.Style
instance GHC.Show.Show Text.PrettyPrint.Annotated.HughesPJ.Style
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.PrettyPrint.Annotated.HughesPJ.Span a)
instance GHC.Show.Show a => GHC.Show.Show (Text.PrettyPrint.Annotated.HughesPJ.Span a)
instance GHC.Base.Functor Text.PrettyPrint.Annotated.HughesPJ.Span
instance GHC.Show.Show (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Base.Semigroup (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Base.Monoid (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance Data.String.IsString (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Classes.Eq (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Base.Functor Text.PrettyPrint.Annotated.HughesPJ.Doc
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Text.PrettyPrint.Annotated.HughesPJ.Doc a)
instance GHC.Base.Functor Text.PrettyPrint.Annotated.HughesPJ.AnnotDetails
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Text.PrettyPrint.Annotated.HughesPJ.AnnotDetails a)
instance Control.DeepSeq.NFData Text.PrettyPrint.Annotated.HughesPJ.TextDetails


-- | This module provides a version of pretty that allows for annotations
--   to be attached to documents. Annotations are arbitrary pieces of
--   metadata that can be attached to sub-documents.
--   
--   This module should be used as opposed to the <a>HughesPJ</a> module.
--   Both are equivalent though as this module simply re-exports the other.
module Text.PrettyPrint.Annotated

-- | The abstract type of documents. A Doc represents a <i>set</i> of
--   layouts. A Doc with no occurrences of Union or NoDoc represents just
--   one layout.
data Doc a

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc a

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc a

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc a

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc a

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc a
int :: Int -> Doc a
integer :: Integer -> Doc a
float :: Float -> Doc a
double :: Double -> Doc a
rational :: Rational -> Doc a
semi :: Doc a
comma :: Doc a
colon :: Doc a
space :: Doc a
equals :: Doc a
lparen :: Doc a
rparen :: Doc a
lbrack :: Doc a
rbrack :: Doc a
lbrace :: Doc a
rbrace :: Doc a
parens :: Doc a -> Doc a
brackets :: Doc a -> Doc a
braces :: Doc a -> Doc a
quotes :: Doc a -> Doc a
doubleQuotes :: Doc a -> Doc a

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc a

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc a -> Doc a -> Doc a
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc a -> Doc a -> Doc a
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc a] -> Doc a

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc a] -> Doc a

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc a -> Doc a -> Doc a
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc a -> Doc a -> Doc a
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc a] -> Doc a

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc a] -> Doc a

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc a] -> Doc a

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc a] -> Doc a

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k z
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc a -> Doc a

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc a -> Int -> Doc a -> Doc a

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc a -> [Doc a] -> [Doc a]

-- | Attach an annotation to a document.
annotate :: a -> Doc a -> Doc a

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc a -> Bool

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>
--   (see <a>style</a>).
render :: Doc a -> String

-- | Render an annotated <tt>Doc</tt> to a String and list of annotations
--   (see <a>Span</a>) using the default <tt>Style</tt> (see <a>style</a>).
renderSpans :: Doc ann -> (String, [Span ann])

-- | A <tt>Span</tt> represents the result of an annotation after a
--   <tt>Doc</tt> has been rendered, capturing where the annotation now
--   starts and ends in the rendered output.
data Span a
Span :: !Int -> !Int -> a -> Span a
[spanStart] :: Span a -> !Int
[spanLength] :: Span a -> !Int
[spanAnnotation] :: Span a -> a

-- | A rendering style. Allows us to specify constraints to choose among
--   the many different rendering options.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode.
[mode] :: Style -> Mode

-- | Maximum length of a line, in characters.
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length. A ribbon refers to the
--   characters on a line <i>excluding</i> indentation. So a
--   <a>lineLength</a> of 100, with a <a>ribbonsPerLine</a> of <tt>2.0</tt>
--   would only allow up to 50 characters of ribbon to be displayed on a
--   line, while allowing it to be indented up to 50 characters.
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc a -> String

-- | The general rendering interface. Please refer to the <tt>Style</tt>
--   and <tt>Mode</tt> types for a description of rendering mode, line
--   length and ribbons.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc b -> a

-- | The general rendering interface, supporting annotations. Please refer
--   to the <tt>Style</tt> and <tt>Mode</tt> types for a description of
--   rendering mode, line length and ribbons.
fullRenderAnn :: Mode -> Int -> Float -> (AnnotDetails b -> a -> a) -> a -> Doc b -> a

-- | Rendering mode.
data Mode

-- | Normal rendering (<a>lineLength</a> and <a>ribbonsPerLine</a>
--   respected').
PageMode :: Mode

-- | With zig-zag cuts.
ZigZagMode :: Mode

-- | No indentation, infinitely long lines (<a>lineLength</a> ignored), but
--   explicit new lines, i.e., <tt>text "one" $$ text "two"</tt>, are
--   respected.
LeftMode :: Mode

-- | All on one line, <a>lineLength</a> ignored and explicit new lines
--   (<tt>$$</tt>) are turned into spaces.
OneLineMode :: Mode

-- | A TextDetails represents a fragment of text that will be output at
--   some point in a <tt>Doc</tt>.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.Annotated.HughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc ann
pPrint :: Pretty a => a -> Doc ann
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc ann

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> Doc ann -> Doc ann
instance GHC.Show.Show Text.PrettyPrint.Annotated.HughesPJClass.PrettyLevel
instance GHC.Classes.Ord Text.PrettyPrint.Annotated.HughesPJClass.PrettyLevel
instance GHC.Classes.Eq Text.PrettyPrint.Annotated.HughesPJClass.PrettyLevel
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Int
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Num.Integer.Integer
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Float
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Double
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty ()
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Bool
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Ordering
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty GHC.Types.Char
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty a => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (GHC.Maybe.Maybe a)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (Data.Either.Either a b)
instance Text.PrettyPrint.Annotated.HughesPJClass.Pretty a => Text.PrettyPrint.Annotated.HughesPJClass.Pretty [a]
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c, Text.PrettyPrint.Annotated.HughesPJClass.Pretty d) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c, d)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c, Text.PrettyPrint.Annotated.HughesPJClass.Pretty d, Text.PrettyPrint.Annotated.HughesPJClass.Pretty e) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c, d, e)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c, Text.PrettyPrint.Annotated.HughesPJClass.Pretty d, Text.PrettyPrint.Annotated.HughesPJClass.Pretty e, Text.PrettyPrint.Annotated.HughesPJClass.Pretty f) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c, d, e, f)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c, Text.PrettyPrint.Annotated.HughesPJClass.Pretty d, Text.PrettyPrint.Annotated.HughesPJClass.Pretty e, Text.PrettyPrint.Annotated.HughesPJClass.Pretty f, Text.PrettyPrint.Annotated.HughesPJClass.Pretty g) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c, d, e, f, g)
instance (Text.PrettyPrint.Annotated.HughesPJClass.Pretty a, Text.PrettyPrint.Annotated.HughesPJClass.Pretty b, Text.PrettyPrint.Annotated.HughesPJClass.Pretty c, Text.PrettyPrint.Annotated.HughesPJClass.Pretty d, Text.PrettyPrint.Annotated.HughesPJClass.Pretty e, Text.PrettyPrint.Annotated.HughesPJClass.Pretty f, Text.PrettyPrint.Annotated.HughesPJClass.Pretty g, Text.PrettyPrint.Annotated.HughesPJClass.Pretty h) => Text.PrettyPrint.Annotated.HughesPJClass.Pretty (a, b, c, d, e, f, g, h)


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   Originally designed by John Hughes's and Simon Peyton Jones's.
--   
--   For more information you can refer to the <a>original paper</a> that
--   serves as the basis for this libraries design: /The Design of a
--   Pretty-printing Library/ by John Hughes, in Advanced Functional
--   Programming, 1995.
module Text.PrettyPrint.HughesPJ

-- | The abstract type of documents. A Doc represents a <i>set</i> of
--   layouts. A Doc with no occurrences of Union or NoDoc represents just
--   one layout.
data Doc

-- | A TextDetails represents a fragment of text that will be output at
--   some point in a <tt>Doc</tt>.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | Apply <a>parens</a> to <a>Doc</a> if boolean is true.
maybeParens :: Bool -> Doc -> Doc

-- | Apply <a>brackets</a> to <a>Doc</a> if boolean is true.
maybeBrackets :: Bool -> Doc -> Doc

-- | Apply <a>braces</a> to <a>Doc</a> if boolean is true.
maybeBraces :: Bool -> Doc -> Doc

-- | Apply <a>quotes</a> to <a>Doc</a> if boolean is true.
maybeQuotes :: Bool -> Doc -> Doc

-- | Apply <a>doubleQuotes</a> to <a>Doc</a> if boolean is true.
maybeDoubleQuotes :: Bool -> Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k x
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | <tt>first</tt> returns its first argument if it is non-empty,
--   otherwise its second.
first :: Doc -> Doc -> Doc

-- | Perform some simplification of a built up <tt>GDoc</tt>.
reduceDoc :: Doc -> RDoc

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>
--   (see <a>style</a>).
render :: Doc -> String

-- | A rendering style. Allows us to specify constraints to choose among
--   the many different rendering options.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode.
[mode] :: Style -> Mode

-- | Maximum length of a line, in characters.
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length. A ribbon refers to the
--   characters on a line <i>excluding</i> indentation. So a
--   <a>lineLength</a> of 100, with a <a>ribbonsPerLine</a> of <tt>2.0</tt>
--   would only allow up to 50 characters of ribbon to be displayed on a
--   line, while allowing it to be indented up to 50 characters.
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | Rendering mode.
data Mode

-- | Normal rendering (<a>lineLength</a> and <a>ribbonsPerLine</a>
--   respected').
PageMode :: Mode

-- | With zig-zag cuts.
ZigZagMode :: Mode

-- | No indentation, infinitely long lines (<a>lineLength</a> ignored), but
--   explicit new lines, i.e., <tt>text "one" $$ text "two"</tt>, are
--   respected.
LeftMode :: Mode

-- | All on one line, <a>lineLength</a> ignored and explicit new lines
--   (<tt>$$</tt>) are turned into spaces.
OneLineMode :: Mode

-- | The general rendering interface. Please refer to the <tt>Style</tt>
--   and <tt>Mode</tt> types for a description of rendering mode, line
--   length and ribbons.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a
instance GHC.Generics.Generic Text.PrettyPrint.HughesPJ.Doc
instance GHC.Base.Semigroup Text.PrettyPrint.HughesPJ.Doc
instance GHC.Base.Monoid Text.PrettyPrint.HughesPJ.Doc
instance Data.String.IsString Text.PrettyPrint.HughesPJ.Doc
instance GHC.Show.Show Text.PrettyPrint.HughesPJ.Doc
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJ.Doc
instance Control.DeepSeq.NFData Text.PrettyPrint.HughesPJ.Doc


-- | Provides a collection of pretty printer combinators, a set of API's
--   that provides a way to easily print out text in a consistent format of
--   your choosing.
--   
--   This module should be used as opposed to the <a>HughesPJ</a> module.
--   Both are equivalent though as this module simply re-exports the other.
module Text.PrettyPrint

-- | The abstract type of documents. A Doc represents a <i>set</i> of
--   layouts. A Doc with no occurrences of Union or NoDoc represents just
--   one layout.
data Doc

-- | A document of height and width 1, containing a literal character.
char :: Char -> Doc

-- | A document of height 1 containing a literal string. <a>text</a>
--   satisfies the following laws:
--   
--   <ul>
--   <li><pre><a>text</a> s <a>&lt;&gt;</a> <a>text</a> t = <a>text</a>
--   (s<a>++</a>t)</pre></li>
--   <li><tt><a>text</a> "" <a>&lt;&gt;</a> x = x</tt>, if <tt>x</tt>
--   non-empty</li>
--   </ul>
--   
--   The side condition on the last law is necessary because
--   <tt><a>text</a> ""</tt> has height 1, while <a>empty</a> has no
--   height.
text :: String -> Doc

-- | Same as <tt>text</tt>. Used to be used for Bytestrings.
ptext :: String -> Doc

-- | Some text with any width. (<tt>text s = sizedText (length s) s</tt>)
sizedText :: Int -> String -> Doc

-- | Some text, but without any width. Use for non-printing text such as a
--   HTML or Latex tags
zeroWidthText :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc
semi :: Doc
comma :: Doc
colon :: Doc
space :: Doc
equals :: Doc
lparen :: Doc
rparen :: Doc
lbrack :: Doc
rbrack :: Doc
lbrace :: Doc
rbrace :: Doc
parens :: Doc -> Doc
brackets :: Doc -> Doc
braces :: Doc -> Doc
quotes :: Doc -> Doc
doubleQuotes :: Doc -> Doc

-- | The empty document, with no height and no width. <a>empty</a> is the
--   identity for <a>&lt;&gt;</a>, <a>&lt;+&gt;</a>, <a>$$</a> and
--   <a>$+$</a>, and anywhere in the argument list for <a>sep</a>,
--   <a>hcat</a>, <a>hsep</a>, <a>vcat</a>, <a>fcat</a> etc.
empty :: Doc

-- | Beside. <a>&lt;&gt;</a> is associative, with identity <a>empty</a>.
(<>) :: Doc -> Doc -> Doc
infixl 6 <>

-- | Beside, separated by space, unless one of the arguments is
--   <a>empty</a>. <a>&lt;+&gt;</a> is associative, with identity
--   <a>empty</a>.
(<+>) :: Doc -> Doc -> Doc
infixl 6 <+>

-- | List version of <a>&lt;&gt;</a>.
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>.
hsep :: [Doc] -> Doc

-- | Above, except that if the last line of the first argument stops at
--   least one position before the first line of the second begins, these
--   two lines are overlapped. For example:
--   
--   <pre>
--   text "hi" $$ nest 5 (text "there")
--   </pre>
--   
--   lays out as
--   
--   <pre>
--   hi   there
--   </pre>
--   
--   rather than
--   
--   <pre>
--   hi
--        there
--   </pre>
--   
--   <a>$$</a> is associative, with identity <a>empty</a>, and also
--   satisfies
--   
--   <ul>
--   <li><tt>(x <a>$$</a> y) <a>&lt;&gt;</a> z = x <a>$$</a> (y
--   <a>&lt;&gt;</a> z)</tt>, if <tt>y</tt> non-empty.</li>
--   </ul>
($$) :: Doc -> Doc -> Doc
infixl 5 $$

-- | Above, with no overlapping. <a>$+$</a> is associative, with identity
--   <a>empty</a>.
($+$) :: Doc -> Doc -> Doc
infixl 5 $+$

-- | List version of <a>$$</a>.
vcat :: [Doc] -> Doc

-- | Either <a>hsep</a> or <a>vcat</a>.
sep :: [Doc] -> Doc

-- | Either <a>hcat</a> or <a>vcat</a>.
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>sep</a>.
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of <a>cat</a>.
fcat :: [Doc] -> Doc

-- | Nest (or indent) a document by a given number of positions (which may
--   also be negative). <a>nest</a> satisfies the laws:
--   
--   <ul>
--   <li><pre><a>nest</a> 0 x = x</pre></li>
--   <li><pre><a>nest</a> k (<a>nest</a> k' x) = <a>nest</a> (k+k')
--   x</pre></li>
--   <li><pre><a>nest</a> k (x <a>&lt;&gt;</a> y) = <a>nest</a> k x
--   <a>&lt;&gt;</a> <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k (x <a>$$</a> y) = <a>nest</a> k x <a>$$</a>
--   <a>nest</a> k y</pre></li>
--   <li><pre><a>nest</a> k <a>empty</a> = <a>empty</a></pre></li>
--   <li><tt>x <a>&lt;&gt;</a> <a>nest</a> k y = x <a>&lt;&gt;</a> y</tt>,
--   if <tt>x</tt> non-empty</li>
--   </ul>
--   
--   The side condition on the last law is needed because <a>empty</a> is a
--   left identity for <a>&lt;&gt;</a>.
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> Bool

-- | Render the <tt>Doc</tt> to a String using the default <tt>Style</tt>
--   (see <a>style</a>).
render :: Doc -> String

-- | A rendering style. Allows us to specify constraints to choose among
--   the many different rendering options.
data Style
Style :: Mode -> Int -> Float -> Style

-- | The rendering mode.
[mode] :: Style -> Mode

-- | Maximum length of a line, in characters.
[lineLength] :: Style -> Int

-- | Ratio of line length to ribbon length. A ribbon refers to the
--   characters on a line <i>excluding</i> indentation. So a
--   <a>lineLength</a> of 100, with a <a>ribbonsPerLine</a> of <tt>2.0</tt>
--   would only allow up to 50 characters of ribbon to be displayed on a
--   line, while allowing it to be indented up to 50 characters.
[ribbonsPerLine] :: Style -> Float

-- | The default style (<tt>mode=PageMode, lineLength=100,
--   ribbonsPerLine=1.5</tt>).
style :: Style

-- | Render the <tt>Doc</tt> to a String using the given <tt>Style</tt>.
renderStyle :: Style -> Doc -> String

-- | The general rendering interface. Please refer to the <tt>Style</tt>
--   and <tt>Mode</tt> types for a description of rendering mode, line
--   length and ribbons.
fullRender :: Mode -> Int -> Float -> (TextDetails -> a -> a) -> a -> Doc -> a

-- | Rendering mode.
data Mode

-- | Normal rendering (<a>lineLength</a> and <a>ribbonsPerLine</a>
--   respected').
PageMode :: Mode

-- | With zig-zag cuts.
ZigZagMode :: Mode

-- | No indentation, infinitely long lines (<a>lineLength</a> ignored), but
--   explicit new lines, i.e., <tt>text "one" $$ text "two"</tt>, are
--   respected.
LeftMode :: Mode

-- | All on one line, <a>lineLength</a> ignored and explicit new lines
--   (<tt>$$</tt>) are turned into spaces.
OneLineMode :: Mode

-- | A TextDetails represents a fragment of text that will be output at
--   some point in a <tt>Doc</tt>.
data TextDetails

-- | A single Char fragment
Chr :: {-# UNPACK #-} !Char -> TextDetails

-- | A whole String fragment
Str :: String -> TextDetails

-- | Used to represent a Fast String fragment but now deprecated and
--   identical to the Str constructor.
PStr :: String -> TextDetails


-- | Pretty printing class, simlar to <a>Show</a> but nicer looking.
--   
--   Note that the precedence level is a <a>Rational</a> so there is an
--   unlimited number of levels. This module re-exports <a>HughesPJ</a>.
module Text.PrettyPrint.HughesPJClass

-- | Pretty printing class. The precedence level is used in a similar way
--   as in the <a>Show</a> class. Minimal complete definition is either
--   <a>pPrintPrec</a> or <a>pPrint</a>.
class Pretty a
pPrintPrec :: Pretty a => PrettyLevel -> Rational -> a -> Doc
pPrint :: Pretty a => a -> Doc
pPrintList :: Pretty a => PrettyLevel -> [a] -> Doc

-- | Level of detail in the pretty printed output. Level 0 is the least
--   detail.
newtype PrettyLevel
PrettyLevel :: Int -> PrettyLevel

-- | The "normal" (Level 0) of detail.
prettyNormal :: PrettyLevel

-- | Pretty print a value with the <a>prettyNormal</a> level.
prettyShow :: Pretty a => a -> String

-- | Parenthesize an value if the boolean is true.

-- | <i>Deprecated: Please use <a>maybeParens</a> instead</i>
prettyParen :: Bool -> Doc -> Doc
instance GHC.Show.Show Text.PrettyPrint.HughesPJClass.PrettyLevel
instance GHC.Classes.Ord Text.PrettyPrint.HughesPJClass.PrettyLevel
instance GHC.Classes.Eq Text.PrettyPrint.HughesPJClass.PrettyLevel
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Int
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Num.Integer.Integer
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Float
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Double
instance Text.PrettyPrint.HughesPJClass.Pretty ()
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Bool
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Ordering
instance Text.PrettyPrint.HughesPJClass.Pretty GHC.Types.Char
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty (GHC.Maybe.Maybe a)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b) => Text.PrettyPrint.HughesPJClass.Pretty (Data.Either.Either a b)
instance Text.PrettyPrint.HughesPJClass.Pretty a => Text.PrettyPrint.HughesPJClass.Pretty [a]
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b) => Text.PrettyPrint.HughesPJClass.Pretty (a, b)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f, Text.PrettyPrint.HughesPJClass.Pretty g) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f, g)
instance (Text.PrettyPrint.HughesPJClass.Pretty a, Text.PrettyPrint.HughesPJClass.Pretty b, Text.PrettyPrint.HughesPJClass.Pretty c, Text.PrettyPrint.HughesPJClass.Pretty d, Text.PrettyPrint.HughesPJClass.Pretty e, Text.PrettyPrint.HughesPJClass.Pretty f, Text.PrettyPrint.HughesPJClass.Pretty g, Text.PrettyPrint.HughesPJClass.Pretty h) => Text.PrettyPrint.HughesPJClass.Pretty (a, b, c, d, e, f, g, h)
