-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FunctorWithIndex, FoldableWithIndex, TraversableWithIndex
--   
--   This package provides three useful generalizations:
--   
--   <pre>
--   class Functor f =&gt; FunctorWithIndex i f | f -&gt; i where
--     imap :: (i -&gt; a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   <pre>
--   class Foldable f =&gt; FoldableWithIndex i f | f -&gt; i where
--     ifoldMap :: Monoid m =&gt; (i -&gt; a -&gt; m) -&gt; f a -&gt; m
--   </pre>
--   
--   <pre>
--   class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) =&gt; TraversableWithIndex i t | t -&gt; i where
--     itraverse :: Applicative f =&gt; (i -&gt; a -&gt; f b) -&gt; t a -&gt; f (t b)
--   </pre>
--   
--   This package contains instances for types in GHC boot libraries. For
--   some additional instances see <a>indexed-traversable-instances</a>.
--   
--   The <a>keys</a> package provides similar functionality, but uses
--   (associated) <tt>TypeFamilies</tt> instead of
--   <tt>FunctionalDependencies</tt>.
@package indexed-traversable
@version 0.1.4


-- | Indexed Traversables
module Data.Traversable.WithIndex

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i t | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, i ~ Int, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <tt>.</tt> <tt>const</tt>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access the
--   index.
--   
--   When you don't need access to the index <tt>mapM</tt> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <tt>mapM</tt> ≡ <a>imapM</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access its
--   position (and the arguments flipped).
--   
--   <pre>
--   <tt>forM</tt> a ≡ <a>iforM</a> a <tt>.</tt> <tt>const</tt>
--   <a>iforM</a> ≡ <a>flip</a> <a>imapM</a>
--   </pre>
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)

-- | Generalizes <a>mapAccumR</a> to add access to the index.
--   
--   <a>imapAccumR</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>imapAccumR</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Generalizes <a>mapAccumL</a> to add access to the index.
--   
--   <a>imapAccumL</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>imapAccumL</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
imapDefault :: TraversableWithIndex i f => (i -> a -> b) -> f a -> f b
ifoldMapDefault :: (TraversableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

module Data.Functor.WithIndex

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i f | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | Map with access to the index.
imap :: (FunctorWithIndex i f, TraversableWithIndex i f) => (i -> a -> b) -> f a -> f b


-- | Indexed non-empty Foldables.
module Data.Foldable1.WithIndex

-- | A non-empty container that supports folding with an additional index.
class (Foldable1 f, FoldableWithIndex i f) => Foldable1WithIndex i f | f -> i

-- | Map each element of the structure to a semigroup, and combine the
--   results.
ifoldMap1 :: (Foldable1WithIndex i f, Semigroup m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap1</a> that is strict in the accumulator.
ifoldMap1' :: (Foldable1WithIndex i f, Semigroup m) => (i -> a -> m) -> f a -> m

-- | Generalized <tt>ifoldr1</tt>.
ifoldrMap1 :: Foldable1WithIndex i f => (i -> a -> b) -> (i -> a -> b -> b) -> f a -> b

-- | Generalized <tt>ifoldl1'</tt>.
ifoldlMap1' :: Foldable1WithIndex i f => (i -> a -> b) -> (i -> b -> a -> b) -> f a -> b

-- | Generalized <tt>ifoldl1</tt>.
ifoldlMap1 :: Foldable1WithIndex i f => (i -> a -> b) -> (i -> b -> a -> b) -> f a -> b

-- | Generalized <tt>ifoldr1'</tt>.
ifoldrMap1' :: Foldable1WithIndex i f => (i -> a -> b) -> (i -> a -> b -> b) -> f a -> b


-- | Indexed Foldables.
module Data.Foldable.WithIndex

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i f | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, TraversableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Return whether or not any element in a container satisfies a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>any</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>any</a> ≡ <a>iany</a> <a>.</a> <tt>const</tt>
--   </pre>
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not all elements in a container satisfy a predicate,
--   with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <tt>all</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>all</tt> ≡ <a>iall</a> <a>.</a> <tt>const</tt>
--   </pre>
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not none of the elements in a container satisfy a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>none</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>none</a> ≡ <a>inone</a> <a>.</a> <tt>const</tt>
--   <a>inone</a> f ≡ <a>not</a> <a>.</a> <a>iany</a> f
--   </pre>
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Determines whether no elements of the structure satisfy the predicate.
--   
--   <pre>
--   <a>none</a> f ≡ <a>not</a> <a>.</a> <a>any</a> f
--   </pre>
none :: Foldable f => (a -> Bool) -> f a -> Bool

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <tt>traverse_</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>traverse_</tt> l = <a>itraverse</a> <a>.</a> <tt>const</tt>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <tt>for_</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>for_</tt> a ≡ <a>ifor_</a> a <a>.</a> <tt>const</tt>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>mapM_</tt> ≡ <tt>imapM</tt> <a>.</a> <tt>const</tt>
--   </pre>
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforM_</a> ≡ <a>flip</a> <a>imapM_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forM_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forM_</a> a ≡ <tt>iforM</tt> a <a>.</a> <tt>const</tt>
--   </pre>
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()

-- | Concatenate the results of a function of the elements of an indexed
--   container with access to the index.
--   
--   When you don't need access to the index then <tt>concatMap</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>concatMap</tt> ≡ <a>iconcatMap</a> <a>.</a> <tt>const</tt>
--   <a>iconcatMap</a> ≡ <a>ifoldMap</a>
--   </pre>
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]

-- | Searches a container with a predicate that is also supplied the index,
--   returning the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <tt>find</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>find</tt> ≡ <a>ifind</a> <a>.</a> <tt>const</tt>
--   </pre>
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <tt>foldrM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldrM</tt> ≡ <a>ifoldrM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <tt>foldlM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldlM</tt> ≡ <a>ifoldlM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <tt>toList</tt> is more flexible in what it accepts.
--   
--   <pre>
--   <tt>toList</tt> ≡ <a>map</a> <tt>snd</tt> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]
