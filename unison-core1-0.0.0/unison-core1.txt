-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-core1
@version 0.0.0

module Unison.Blank

-- | Blank is just a dummy annotation.
data Blank loc

-- | just a dummy annotation
Blank :: Blank loc

-- | indicates that we want to remember the variable's solution for some
--   reason
Recorded :: Recorded loc -> Blank loc

-- | indicates that we want to prefer keeping the variable in the context
--   to better refine the above recorded solutions
Retain :: Blank loc
data Recorded loc
Placeholder :: loc -> String -> Recorded loc
Resolve :: loc -> String -> Recorded loc
MissingResultPlaceholder :: loc -> Recorded loc
loc :: Recorded loc -> loc
nameb :: Blank loc -> Maybe String
instance GHC.Generics.Generic (Unison.Blank.Recorded loc)
instance GHC.Base.Functor Unison.Blank.Recorded
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Blank.Recorded loc)
instance GHC.Classes.Eq loc => GHC.Classes.Eq (Unison.Blank.Recorded loc)
instance GHC.Show.Show loc => GHC.Show.Show (Unison.Blank.Recorded loc)
instance GHC.Generics.Generic (Unison.Blank.Blank loc)
instance GHC.Base.Functor Unison.Blank.Blank
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Blank.Blank loc)
instance GHC.Classes.Eq loc => GHC.Classes.Eq (Unison.Blank.Blank loc)
instance GHC.Show.Show loc => GHC.Show.Show (Unison.Blank.Blank loc)

module Unison.ConstructorType
data ConstructorType
Data :: ConstructorType
Effect :: ConstructorType
instance GHC.Generics.Generic Unison.ConstructorType.ConstructorType
instance GHC.Enum.Enum Unison.ConstructorType.ConstructorType
instance GHC.Show.Show Unison.ConstructorType.ConstructorType
instance GHC.Classes.Ord Unison.ConstructorType.ConstructorType
instance GHC.Classes.Eq Unison.ConstructorType.ConstructorType

module Unison.DataDeclaration.ConstructorId
type ConstructorId = Word64

module Unison.Hashable
accumulate' :: (Accumulate h, Hashable t) => t -> h
hash :: (Accumulate h, Hashable t) => t -> h
class Accumulate h
accumulate :: Accumulate h => [Token h] -> h
fromBytes :: Accumulate h => ByteString -> h
toBytes :: Accumulate h => h -> ByteString
data Token h
Tag :: !Word8 -> Token h
Bytes :: !ByteString -> Token h
Int :: !Int64 -> Token h
Text :: !Text -> Token h
Double :: !Double -> Token h
Hashed :: !h -> Token h
Nat :: !Word64 -> Token h
instance GHC.Show.Show h => GHC.Show.Show (Unison.Hashable.Token h)
instance Unison.Hashable.Hashable a => Unison.Hashable.Hashable [a]
instance (Unison.Hashable.Hashable a, Unison.Hashable.Hashable b) => Unison.Hashable.Hashable (a, b)
instance Unison.Hashable.Hashable a => Unison.Hashable.Hashable (Data.Set.Internal.Set a)
instance (Unison.Hashable.Hashable k, Unison.Hashable.Hashable v) => Unison.Hashable.Hashable (Data.Map.Internal.Map k v)
instance (Unison.Hashable.Hashable a, Unison.Hashable.Hashable b) => Unison.Hashable.Hashable (Unison.Util.Relation.Relation a b)
instance (Unison.Hashable.Hashable d1, Unison.Hashable.Hashable d2, Unison.Hashable.Hashable d3) => Unison.Hashable.Hashable (Unison.Util.Relation3.Relation3 d1 d2 d3)
instance (Unison.Hashable.Hashable d1, Unison.Hashable.Hashable d2, Unison.Hashable.Hashable d3, Unison.Hashable.Hashable d4) => Unison.Hashable.Hashable (Unison.Util.Relation4.Relation4 d1 d2 d3 d4)
instance Unison.Hashable.Hashable ()
instance Unison.Hashable.Hashable GHC.Types.Double
instance Unison.Hashable.Hashable Data.Text.Internal.Text
instance Unison.Hashable.Hashable GHC.Types.Char
instance Unison.Hashable.Hashable Data.ByteString.Internal.Type.ByteString
instance Unison.Hashable.Hashable GHC.Word.Word64
instance Unison.Hashable.Hashable GHC.Int.Int64
instance Unison.Hashable.Hashable GHC.Types.Bool
instance Unison.Hashable.Hashable Unison.Hash.Hash
instance Unison.Hashable.Accumulate Unison.Hash.Hash

module Unison.Kind
data Kind
Star :: Kind
Arrow :: Kind -> Kind -> Kind
instance GHC.Generics.Generic Unison.Kind.Kind
instance GHC.Show.Show Unison.Kind.Kind
instance GHC.Read.Read Unison.Kind.Kind
instance GHC.Classes.Ord Unison.Kind.Kind
instance GHC.Classes.Eq Unison.Kind.Kind

module Unison.Position

-- | An indicator of whether something is absolute, e.g. ".foo.bar", or
--   relative, e.g. "foo.bar"
data Position
Absolute :: Position
Relative :: Position
instance GHC.Show.Show Unison.Position.Position
instance GHC.Classes.Ord Unison.Position.Position
instance GHC.Classes.Eq Unison.Position.Position


-- | The private Unison.Name innards. Prefer importing Unison.Name instead,
--   unless you need the data constructor of Name.
module Unison.Name.Internal

-- | A name is an absolute-or-relative non-empty list of name segments. It
--   is used to represent the path to a definition.
--   
--   A few example names:
--   
--   <ul>
--   <li>"foo.bar" --&gt; Name Relative ("bar" :| ["foo"])</li>
--   <li>".foo.bar" --&gt; Name Absolute ("bar" :| ["foo"])</li>
--   <li>"|&gt;.<a>--</a> Name Relative ("<a>:| ["|</a>"])</li>
--   <li>"." --&gt; Name Relative ("." :| [])</li>
--   <li>".." --&gt; Name Absolute (".." :| [])</li>
--   </ul>
data Name
Name :: Position -> NonEmpty NameSegment -> Name

-- | Is this name absolute?
--   
--   <i>O(1)</i>.
isAbsolute :: Name -> Bool

-- | Return the name segments of a name.
--   
--   <pre>
--   &gt;&gt;&gt; segments "a.b.c"
--   "a" :| ["b", "c"]
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
segments :: Name -> NonEmpty NameSegment
instance GHC.Show.Show Unison.Name.Internal.Name
instance GHC.Generics.Generic Unison.Name.Internal.Name
instance GHC.Classes.Eq Unison.Name.Internal.Name
instance Unison.Util.Alphabetical.Alphabetical Unison.Name.Internal.Name
instance (TypeError ...) => Data.String.IsString Unison.Name.Internal.Name
instance GHC.Classes.Ord Unison.Name.Internal.Name
instance Control.Lens.Cons.Snoc Unison.Name.Internal.Name Unison.Name.Internal.Name Unison.NameSegment.Internal.NameSegment Unison.NameSegment.Internal.NameSegment

module Unison.Name

-- | A name is an absolute-or-relative non-empty list of name segments. It
--   is used to represent the path to a definition.
--   
--   A few example names:
--   
--   <ul>
--   <li>"foo.bar" --&gt; Name Relative ("bar" :| ["foo"])</li>
--   <li>".foo.bar" --&gt; Name Absolute ("bar" :| ["foo"])</li>
--   <li>"|&gt;.<a>--</a> Name Relative ("<a>:| ["|</a>"])</li>
--   <li>"." --&gt; Name Relative ("." :| [])</li>
--   <li>".." --&gt; Name Absolute (".." :| [])</li>
--   </ul>
data Name

-- | Cons a name segment onto the head of a relative name. Not monotonic
--   with respect to ordering! It is not safe to use <tt>cons s</tt> as the
--   first argument to <tt>Map.mapKeysMonotonic</tt>!
--   
--   <i>Precondition</i>: the name is relative
--   
--   <i>O(n)</i>, where <i>n</i> is the number of segments.
cons :: HasCallStack => NameSegment -> Name -> Name

-- | Snoc a name segment onto the end of a name.
--   
--   <i>O(1)</i>.
snoc :: Name -> NameSegment -> Name
joinDot :: HasCallStack => Name -> Name -> Name

-- | Construct a relative name from a name segment.
--   
--   <i>O(1)</i>.
fromSegment :: NameSegment -> Name

-- | Construct a relative name from a list of name segments.
--   
--   <pre>
--   &gt;&gt;&gt; fromSegments ("a" :| ["b", "c"])
--   "a.b.c"
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
fromSegments :: NonEmpty NameSegment -> Name

-- | Construct a relative name from a list of name segments which are in
--   reverse order
--   
--   <pre>
--   &gt;&gt;&gt; fromReverseSegments ("c" :| ["b", "a"])
--   a.b.c
--   </pre>
--   
--   <i>O(1)</i>
fromReverseSegments :: NonEmpty NameSegment -> Name

-- | Return the number of name segments in a name.
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
countSegments :: Name -> Int

-- | Is this name absolute?
--   
--   <i>O(1)</i>.
isAbsolute :: Name -> Bool

-- | Is this name relative?
--   
--   <i>O(1)</i>.
isRelative :: Name -> Bool

-- | <tt>isPrefixOf x y</tt> returns whether <tt>x</tt> is a prefix of (or
--   equivalent to) <tt>y</tt>, which is false if one name is relative and
--   the other is absolute.
--   
--   <pre>
--   &gt;&gt;&gt; isPrefixOf "a.b" "a.b.c"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isPrefixOf "a.b.c" "a.b.c"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isPrefixOf ".a.b" "a.b.c"
--   False
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
isPrefixOf :: Name -> Name -> Bool

-- | <tt>beginsWithSegment name segment</tt> returns whether
--   <tt>name</tt>'s first name segment is <tt>segment</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; beginsWithSegment "abc.def" "abc"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; beginsWithSegment "abc.def" "ab"
--   False
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
beginsWithSegment :: Name -> NameSegment -> Bool
endsWith :: Name -> Name -> Bool

-- | Like <a>endsWithSegments</a>, but accepts a list of name segments in
--   reverse order.
--   
--   Slightly more efficient than <a>endsWithSegments</a>.
--   
--   <pre>
--   &gt;&gt;&gt; endsWithReverseSegments "a.b.c" ["c", "b"]
--   True
--   </pre>
endsWithReverseSegments :: Name -> [NameSegment] -> Bool

-- | <tt>endsWithSegments x y</tt> returns whether <tt>x</tt> ends with
--   <tt>y</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; endsWithSegments "a.b.c" ["b", "c"]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; endsWithSegments "a.b.c" ["d"]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; endsWithSegments "a.b.c" []
--   True
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
endsWithSegments :: Name -> [NameSegment] -> Bool
stripReversedPrefix :: Name -> [NameSegment] -> Maybe Name

-- | Like <a>stripReversedPrefix</a> but if the prefix doesn't match, or if
--   it would strip the entire name away just return the original name.
--   
--   <pre>
--   &gt;&gt;&gt; tryStripReversedPrefix (fromReverseSegments ("c" :| ["b", "a"])) ["b", "a"]
--   Name Relative (NameSegment {toText = "c"} :| [])
--   
--   &gt;&gt;&gt; tryStripReversedPrefix (fromReverseSegments ("y" :| ["x"])) ["b", "a"]
--   Name Relative (NameSegment {toText = "y"} :| [NameSegment {toText = "x"}])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tryStripReversedPrefix (fromReverseSegments ("c" :| ["b", "a"])) ["b", "a"]
--   Name Relative (NameSegment {toText = "c"} :| [])
--   </pre>
tryStripReversedPrefix :: Name -> [NameSegment] -> Name

-- | Return the name segments of a name, in reverse order.
--   
--   <pre>
--   &gt;&gt;&gt; reverseSegments "a.b.c"
--   "c" :| ["b", "a"]
--   </pre>
--   
--   <i>O(1)</i>.
reverseSegments :: Name -> NonEmpty NameSegment

-- | Return the name segments of a name.
--   
--   <pre>
--   &gt;&gt;&gt; segments "a.b.c"
--   "a" :| ["b", "c"]
--   </pre>
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
segments :: Name -> NonEmpty NameSegment

-- | Return all relative suffixes of a name, in ascending-length order. The
--   returned list will always be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; suffixes "a.b.c"
--   ["a.b.c", "a.b", "c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixes ".a.b.c"
--   ["a.b.c", "a.b", "c"]
--   </pre>
suffixes :: Name -> [Name]

-- | Return the final segment of a name.
--   
--   <pre>
--   &gt;&gt;&gt; lastSegment (fromSegments ("base" :| ["List", "map"]))
--   NameSegment {toText = "map"}
--   </pre>
lastSegment :: Name -> NameSegment

-- | Make a name absolute. No-op if the name is already absolute.
--   
--   <i>O(1)</i>.
makeAbsolute :: Name -> Name

-- | Make a name relative. No-op if the name is already relative.
--   
--   <i>O(1)</i>.
makeRelative :: Name -> Name

-- | Overwrite a name's position. This only changes the name's tag, it
--   performs no manipulations to the segments of the name.
--   
--   <i>O(1)</i>.
setPosition :: Position -> Name -> Name

-- | Compute the "parent" of a name, unless the name is only a single
--   segment, in which case it has no parent.
--   
--   <pre>
--   &gt;&gt;&gt; parent "a.b.c"
--   Just "a.b"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parent ".a.b.c"
--   Just ".a.b"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parent "a"
--   Nothing
--   </pre>
parent :: Name -> Maybe Name

-- | <tt>stripNamePrefix x y</tt> strips prefix <tt>x</tt> from name
--   <tt>y</tt>, and returns the resulting name. Returns <tt>Nothing</tt>
--   <tt>x</tt> is not a proper (meaning shorter-than) prefix of
--   <tt>y</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; stripNamePrefix "a.b" "a.b.c"
--   Just "c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripNamePrefix ".a.b" "a.b.c"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripNamePrefix "a.b.c" "a.b.c"
--   Nothing
--   </pre>
stripNamePrefix :: Name -> Name -> Maybe Name

-- | Drop all leading segments from a name, retaining only the last segment
--   as a relative name.
--   
--   <pre>
--   &gt;&gt;&gt; unqualified "a.b.c"
--   "c"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unqualified ".a.b.c"
--   "c"
--   </pre>
unqualified :: Name -> Name
isUnqualified :: Name -> Bool

-- | Returns the common prefix of two names as segments
--   
--   Note: the returned segments are NOT reversed.
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefix "a.b.x" "a.b.y"
--   [a,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefix "x.y.z" "a.b.c"
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; commonPrefix "a.b.c" "a.b.c.d.e"
--   [a,b,c]
--   </pre>
--   
--   Must have equivalent positions or no there's no common prefix
--   &gt;&gt;&gt; commonPrefix ".a.b.c" "a.b.c.d.e" []
--   
--   Prefix matches are performed at the *segment* level: &gt;&gt;&gt;
--   commonPrefix "a.bears" "a.beats" [a]
commonPrefix :: Name -> Name -> [NameSegment]

-- | precondition: input list is deduped, and so is the Name list in the
--   tuple
preferShallowLibDepth :: Ord r => [([Name], r)] -> Set r
searchByRankedSuffix :: Ord r => Name -> Relation Name r -> Set r
searchBySuffix :: Ord r => Name -> Relation Name r -> Set r

-- | Like <a>searchBySuffix</a>, but also keeps the names around.
filterBySuffix :: Ord r => Name -> Relation Name r -> Relation Name r

-- | Like <a>searchByRankedSuffix</a>, but also keeps the names around.
filterByRankedSuffix :: Ord r => Name -> Relation Name r -> Relation Name r
suffixifyByName :: forall r. Ord r => Name -> Relation Name r -> Name
suffixifyByHash :: forall r. Ord r => Name -> Relation Name r -> Name
suffixifyByHashName :: forall r. Ord r => Name -> Relation Name r -> Name
sortByText :: (a -> Text) -> [a] -> [a]
sortNamed :: (Name -> Text) -> (a -> Name) -> [a] -> [a]
sortNames :: (Name -> Text) -> [Name] -> [Name]

-- | Return all "splits" of a relative name, which pair a possibly-empty
--   prefix of name segments with a suffix, such that the original name is
--   equivalent to <tt>prefix + suffix</tt>.
--   
--   Note: always returns a non-empty list, but (currently) does not use
--   <tt>NonEmpty</tt> for convenience, as none of the call-sites care if
--   the list is empty or not.
--   
--   <pre>
--   &gt; splits foo.bar.baz
--   
--     prefix    suffix
--     ------    ------
--     ∅         foo.bar.baz
--     foo       bar.baz
--     foo.bar   baz
--   </pre>
--   
--   <i>Precondition</i>: the name is relative.
splits :: HasCallStack => Name -> [([NameSegment], Name)]
suffixFrom :: Name -> Name -> Maybe Name
class Eq n => Alphabetical n
compareAlphabetical :: Alphabetical n => n -> n -> Ordering

-- | <tt>compareSuffix x y</tt> compares the suffix of <tt>y</tt> (in
--   reverse segment order) that is as long as <tt>x</tt> to <tt>x</tt> (in
--   reverse segment order).
--   
--   <pre>
--   &gt;&gt;&gt; compareSuffix "b.c" "a.b.c"
--   EQ -- because [c,b] == [c,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compareSuffix "b.c" "a.b.b"
--   LT -- because [b,b] &lt; [c,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compareSuffix "a.b.c" "b.c"
--   LT -- because [c,b] &lt; [c,b,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compareSuffix "b.b" "a.b.c"
--   GT -- because [c,b] &gt; [b,b]
--   </pre>
--   
--   Used for suffix-based lookup of a name. For instance, given a <tt>r :
--   Relation Name x</tt>, <tt>Relation.searchDom (compareSuffix "foo.bar")
--   r</tt> will find all <tt>r</tt> whose name has <tt>foo.bar</tt> as a
--   suffix.
--   
--   This is only exported for testing; use <a>searchBySuffix</a> or
--   <tt>shortestUniqueSuffix</tt> instead.
--   
--   <i>O(n)</i>, where <i>n</i> is the number of name segments.
compareSuffix :: Name -> Name -> Ordering
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Name.NamePriority a)
instance GHC.Base.Functor Unison.Name.NamePriority
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Name.NamePriority a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Unison.Name.NamePriority a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Unison.Name.NamePriority a)

module Unison.Names.ResolvesTo
data ResolvesTo ref
ResolvesToNamespace :: ref -> ResolvesTo ref
ResolvesToLocal :: Name -> ResolvesTo ref
partitionResolutions :: [(v, ResolvesTo ref)] -> ([(v, ref)], [(v, Name)])
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Names.ResolvesTo.ResolvesTo ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Names.ResolvesTo.ResolvesTo ref)
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Names.ResolvesTo.ResolvesTo ref)

module Unison.Name.Forward
newtype ForwardName
ForwardName :: NonEmpty NameSegment -> ForwardName
[$sel:toList:ForwardName] :: ForwardName -> NonEmpty NameSegment

-- | O(d)
fromName :: Name -> ForwardName
stripNamePrefix :: ForwardName -> ForwardName -> Maybe ForwardName
instance GHC.Show.Show Unison.Name.Forward.ForwardName
instance GHC.Classes.Ord Unison.Name.Forward.ForwardName
instance GHC.Classes.Eq Unison.Name.Forward.ForwardName

module Unison.DeclNameLookup

-- | A lookup from decl-to-constructor name and vice-versa.
--   
--   For example, a type decl like
--   
--   <pre>
--   unique type Foo
--     = Bar Int
--     | Baz.Qux Nat Nat
--   </pre>
--   
--   is represented as
--   
--   <pre>
--   DeclNameLookup
--     { constructorToDecl = Map.fromList [(<a>Foo.Bar</a>, <a>Foo</a>), (<a>Foo.Baz.Qux</a>, <a>Foo</a>)]
--     , declToConstructors = Map.fromList [(<a>Foo</a>, [<a>Foo.Bar</a>, <a>Foo.Baz.Qux</a>])]
--     }
--   </pre>
--   
--   Note that:
--   
--   <ul>
--   <li>Constructor names are given "in full", though they will all
--   necessarily begin with the decl's name.</li>
--   <li>In <tt>declToConstructors</tt>, the constructor names are given in
--   their canonical ordering.</li>
--   </ul>
data DeclNameLookup
DeclNameLookup :: !Map Name Name -> !Map Name [Name] -> DeclNameLookup
[$sel:constructorToDecl:DeclNameLookup] :: DeclNameLookup -> !Map Name Name
[$sel:declToConstructors:DeclNameLookup] :: DeclNameLookup -> !Map Name [Name]
expectDeclName :: HasCallStack => DeclNameLookup -> Name -> Name
expectConstructorNames :: HasCallStack => DeclNameLookup -> Name -> [Name]
instance GHC.Base.Semigroup Unison.DeclNameLookup.DeclNameLookup
instance GHC.Generics.Generic Unison.DeclNameLookup.DeclNameLookup


-- | Projects.
--   
--   The syntax-related parsing code (what makes a valid project name, etc)
--   could conceivably be moved into a different package, but for now we
--   have just defined the one blessed project/branch name syntax that we
--   allow.
module Unison.Project

-- | The name of a project.
data () => ProjectName

-- | Get the user slug at the beginning of a project name, if there is one.
--   
--   <pre>
--   &gt;&gt;&gt; projectNameUserSlug "@arya/lens"
--   Just "arya"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; projectNameUserSlug "lens"
--   Nothing
--   </pre>
projectNameUserSlug :: ProjectName -> Maybe Text

-- | Parse a "@arya/lens" into the "arya" and "lens" parts.
--   
--   If there's no "arya" part, returns the empty string there.
--   
--   <pre>
--   &gt;&gt;&gt; projectNameToUserProjectSlugs (UnsafeProjectName "@arya/lens")
--   ("arya","lens")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; projectNameToUserProjectSlugs (UnsafeProjectName "lens")
--   ("","lens")
--   </pre>
projectNameToUserProjectSlugs :: ProjectName -> (Text, Text)

-- | Prepend a user slug to a project name, if it doesn't already have one.
--   
--   <pre>
--   &gt;&gt;&gt; prependUserSlugToProjectName "arya" "lens"
--   "@arya/lens"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prependUserSlugToProjectName "runar" "@unison/base"
--   "@unison/base"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prependUserSlugToProjectName "???invalid???" "@unison/base"
--   "@unison/base"
--   </pre>
prependUserSlugToProjectName :: Text -> ProjectName -> ProjectName

-- | The name of a branch of a project.
data () => ProjectBranchName

-- | Get the user slug at the beginning of a project branch name, if there
--   is one.
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchNameUserSlug "@arya/topic"
--   Just "arya"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; projectBranchNameUserSlug "topic"
--   Nothing
--   </pre>
projectBranchNameUserSlug :: ProjectBranchName -> Maybe Text

-- | Though a branch name is just a flat string, we have logic that handles
--   certain strings specially.
--   
--   A branch's name indicates it is exactly one of the following:
--   
--   <ul>
--   <li>A contributor branch like "@arya/topic"</li>
--   <li>A draft release branch like "releases<i>drafts</i>1.2.3"</li>
--   <li>A release branch like "releases/1.2.3"</li>
--   <li>None of the above, like "topic"</li>
--   </ul>
--   
--   Note these classifications are only tied to the branch's (mutable)
--   name, and are not really otherwise indicative of much.
--   
--   For instance,
--   
--   <ul>
--   <li>The existence of a local "releases/1.2.3" branch does not
--   necessarily imply the existence of some remote release version
--   "1.2.3".</li>
--   <li>The existence of a local "<tt>arya/topic</tt> branch does not
--   necessarily imply the existence of some remote "arya" user made some
--   "topic" branch at some point.</li>
--   </ul>
--   
--   That said, we do try to make the system mostly make sense by rejecting
--   certain inputs (e.g. you should not be able to easily create a local
--   branch called "releases/1.2.3" out of thin air; you should have to
--   clone it from somewhere). But ultimately, again, branch names are best
--   thought of as opaque, flat strings.
data ProjectBranchNameKind
ProjectBranchNameKind'Contributor :: !Text -> !ProjectBranchName -> ProjectBranchNameKind
ProjectBranchNameKind'DraftRelease :: !Semver -> ProjectBranchNameKind
ProjectBranchNameKind'Release :: !Semver -> ProjectBranchNameKind
ProjectBranchNameKind'NothingSpecial :: ProjectBranchNameKind

-- | Classify a project branch name.
--   
--   <pre>
--   &gt;&gt;&gt; classifyProjectBranchName "@arya/topic"
--   Contributor "arya" "topic"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; classifyProjectBranchName "releases/drafts/1.2.3"
--   DraftRelease (Semver 1 2 3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; classifyProjectBranchName "releases/1.2.3"
--   Release (Semver 1 2 3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; classifyProjectBranchName "topic"
--   NothingSpecial
--   </pre>
classifyProjectBranchName :: ProjectBranchName -> ProjectBranchNameKind

-- | A project branch name, or the latest release of its project.
data ProjectBranchNameOrLatestRelease
ProjectBranchNameOrLatestRelease'LatestRelease :: ProjectBranchNameOrLatestRelease
ProjectBranchNameOrLatestRelease'Name :: !ProjectBranchName -> ProjectBranchNameOrLatestRelease

-- | How a project branch can be specified.
data ProjectBranchSpecifier :: Type -> Type

-- | By name.
[ProjectBranchSpecifier'Name] :: ProjectBranchSpecifier ProjectBranchName

-- | By name, or "the latest release"
[ProjectBranchSpecifier'NameOrLatestRelease] :: ProjectBranchSpecifier ProjectBranchNameOrLatestRelease

-- | A generic data structure that contains information about a project and
--   a branch in that project.
data () => ProjectAndBranch a b
ProjectAndBranch :: a -> b -> ProjectAndBranch a b
[project] :: ProjectAndBranch a b -> a
[branch] :: ProjectAndBranch a b -> b
projectAndBranchNamesParser :: forall branch. ProjectBranchSpecifier branch -> Parsec Void Text (These ProjectName branch)

-- | Parse a fully specified myproject/mybranch name.
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Megaparsec (parseMaybe)
--   
--   &gt;&gt;&gt; parseMaybe fullyQualifiedProjectAndBranchNamesParser ("myproject/mybranch" :: Text)
--   Just (ProjectAndBranch {project = UnsafeProjectName "myproject", branch = UnsafeProjectBranchName "mybranch"})
--   </pre>
fullyQualifiedProjectAndBranchNamesParser :: Parsec Void Text (ProjectAndBranch ProjectName ProjectBranchName)
projectAndOptionalBranchParser :: forall branch. ProjectBranchSpecifier branch -> Parsec Void Text (ProjectAndBranch ProjectName (Maybe branch))
branchWithOptionalProjectParser :: Parsec Void Text (ProjectAndBranch (Maybe ProjectName) ProjectBranchName)

-- | Sometimes, it's convenient (to users) if we defer interpreting certain
--   names (like "foo") as a project name or branch name, instead leaving
--   it up to a command handler to handle the ambiguity.
--   
--   For example, we might want "switch foo" to switch to either the
--   project "foo", or the branch "foo", or complain if both exist.
--   
--   This type is useful for those situtations.
data ProjectAndBranchNames
ProjectAndBranchNames'Ambiguous :: ProjectName -> ProjectBranchName -> ProjectAndBranchNames
ProjectAndBranchNames'Unambiguous :: These ProjectName ProjectBranchName -> ProjectAndBranchNames
projectAndBranchNamesParser2 :: Parsec Void Text ProjectAndBranchNames
projectNameParser :: Parsec Void Text (ProjectName, Bool)
projectBranchNameParser :: Bool -> Parsec Void Text ProjectBranchName
data Semver
Semver :: !Int -> !Int -> !Int -> Semver
instance GHC.Show.Show Unison.Project.Semver
instance GHC.Classes.Eq Unison.Project.Semver
instance GHC.Show.Show Unison.Project.ProjectBranchNameOrLatestRelease
instance GHC.Classes.Eq Unison.Project.ProjectBranchNameOrLatestRelease
instance GHC.Show.Show Unison.Project.ProjectAndBranchNames
instance GHC.Classes.Eq Unison.Project.ProjectAndBranchNames
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text Unison.Project.ProjectAndBranchNames
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text (Data.These.These Unison.Core.Project.ProjectName Unison.Core.Project.ProjectBranchName)
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text (Unison.Core.Project.ProjectAndBranch Unison.Core.Project.ProjectName (GHC.Maybe.Maybe Unison.Core.Project.ProjectBranchName))
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text (Unison.Core.Project.ProjectAndBranch Unison.Core.Project.ProjectName Unison.Core.Project.ProjectBranchName)
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text (Unison.Core.Project.ProjectAndBranch Unison.Core.Project.ProjectName (GHC.Maybe.Maybe Unison.Project.ProjectBranchNameOrLatestRelease))
instance Witch.From.From Unison.Project.Semver Data.Text.Internal.Text
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text Unison.Project.Semver
instance Witch.From.From Unison.Core.Project.ProjectName Data.Text.Internal.Text
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text Unison.Core.Project.ProjectName
instance Witch.From.From Unison.Core.Project.ProjectBranchName Data.Text.Internal.Text
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text Unison.Core.Project.ProjectBranchName
instance Witch.From.From (Unison.Core.Project.ProjectAndBranch Unison.Core.Project.ProjectName Unison.Core.Project.ProjectBranchName) Data.Text.Internal.Text
instance Witch.From.From (Data.These.These Unison.Core.Project.ProjectName Unison.Core.Project.ProjectBranchName) Data.Text.Internal.Text
instance Witch.From.From (Unison.Core.Project.ProjectAndBranch Unison.Core.Project.ProjectName (GHC.Maybe.Maybe Unison.Core.Project.ProjectBranchName)) Data.Text.Internal.Text
instance Witch.From.From (Unison.Core.Project.ProjectAndBranch (GHC.Maybe.Maybe Unison.Core.Project.ProjectName) Unison.Core.Project.ProjectBranchName) Data.Text.Internal.Text
instance Witch.TryFrom.TryFrom Data.Text.Internal.Text (Unison.Core.Project.ProjectAndBranch (GHC.Maybe.Maybe Unison.Core.Project.ProjectName) Unison.Core.Project.ProjectBranchName)

module Unison.Reference

-- | This is the canonical representation of Reference
type Reference = Reference' Text Hash

-- | Either a builtin or a user defined (hashed) top-level declaration.
--   Used for both terms and types.
data () => Reference' t h
ReferenceBuiltin :: t -> Reference' t h
ReferenceDerived :: Id' h -> Reference' t h
pattern Builtin :: t -> Reference' t h
pattern DerivedId :: Id' h -> Reference' t h
pattern Derived :: h -> Pos -> Reference' t h
_DerivedId :: Prism' Reference Id
type Id = Id' Hash

-- | <tt>Pos</tt> is a position into a cycle, as cycles are hashed
--   together.
data () => Id' h
Id :: h -> Pos -> Id' h
type Pos = Word64
type CycleSize = Word64
type Size = CycleSize

-- | A term reference.
type TermReference = Reference

-- | A term reference id.
type TermReferenceId = Id

-- | A type declaration reference.
type TypeReference = Reference

-- | A type declaration reference id.
type TypeReferenceId = Id
derivedBase32Hex :: Text -> Pos -> Maybe Reference
component :: Hash -> [k] -> [(k, Id)]
components :: [(Hash, [k])] -> [(k, Id)]
groupByComponent :: [(k, Reference)] -> [[(k, Reference)]]
componentFor :: Hash -> [a] -> [(Id, a)]
componentFromLength :: Hash -> CycleSize -> Set Id
unsafeFromText :: Text -> Reference
isPrefixOf :: ShortHash -> Reference -> Bool

-- | todo: take a (Reference -&gt; CycleSize) so that <a>readSuffix</a>
--   doesn't have to parse the size from the text. examples:
--   
--   builtins don’t have cycles &gt;&gt;&gt; fromText "##Text.take" Right
--   ##Text.take
--   
--   derived, no cycle &gt;&gt;&gt; fromText
--   "#dqp2oi4iderlrgp2h11sgkff6drk92omo4c84dncfhg9o0jn21cli4lhga72vlchmrb2jk0b3bdc2gie1l06sqdli8ego4q0akm3au8"
--   Right #dqp2o
--   
--   derived, part of cycle &gt;&gt;&gt; fromText
--   "#dqp2oi4iderlrgp2h11sgkff6drk92omo4c84dncfhg9o0jn21cli4lhga72vlchmrb2jk0b3bdc2gie1l06sqdli8ego4q0akm3au8.12345"
--   Right #dqp2o.12345
--   
--   Errors with <a>Left</a> on invalid hashes &gt;&gt;&gt; fromText
--   "#invalid_hash.12345" Left "Invalid hash: "invalid_hash""
fromText :: Text -> Either String Reference
readSuffix :: Text -> Either String Pos
showShort :: Int -> Reference -> Text
showSuffix :: Pos -> Text
toHash :: Reference -> Maybe Hash
toId :: Reference -> Maybe Id
fromId :: Id -> Reference
toText :: Reference -> Text
idToText :: Id -> Text
unsafeId :: Reference -> Id
toShortHash :: Reference -> ShortHash
idToHash :: Id -> Hash
idToShortHash :: Id -> ShortHash
isBuiltin :: Reference -> Bool


-- | The constructor reference type.
module Unison.ConstructorReference

-- | A reference to a constructor is represented by a reference to its type
--   declaration, plus the ordinal constructor id.
data GConstructorReference r
ConstructorReference :: !r -> !ConstructorId -> GConstructorReference r
type ConstructorReference = GConstructorReference TypeReference
type ConstructorReferenceId = GConstructorReference TypeReferenceId

-- | A lens onto the reference part of a constructor reference.
reference_ :: Lens (GConstructorReference r) (GConstructorReference s) r s
toId :: ConstructorReference -> Maybe ConstructorReferenceId
toShortHash :: ConstructorReference -> ShortHash
instance GHC.Show.Show r => GHC.Show.Show (Unison.ConstructorReference.GConstructorReference r)
instance GHC.Classes.Ord r => GHC.Classes.Ord (Unison.ConstructorReference.GConstructorReference r)
instance GHC.Base.Functor Unison.ConstructorReference.GConstructorReference
instance GHC.Classes.Eq r => GHC.Classes.Eq (Unison.ConstructorReference.GConstructorReference r)

module Unison.ReferentPrime

-- | Specifies a term.
--   
--   Either a term <tt>Reference</tt>, a data constructor, or an effect
--   constructor.
--   
--   Slightly odd naming. This is the "referent of term name in the
--   codebase", rather than the target of a Reference.
--   
--   When <tt>Ref'</tt> then <tt>r</tt> represents a term.
--   
--   When <tt>Con'</tt> then <tt>r</tt> is a type declaration.
data Referent' r
Ref' :: r -> Referent' r
Con' :: GConstructorReference r -> ConstructorType -> Referent' r
isConstructor :: Referent' r -> Bool
fold :: (r -> a) -> (r -> ConstructorId -> ConstructorType -> a) -> Referent' r -> a

-- | A lens onto the reference in a referent.
reference_ :: Lens (Referent' r) (Referent' r') r r'
toReference' :: Referent' r -> r
toTermReference :: Referent' r -> Maybe r
toTypeReference :: Referent' r -> Maybe r
instance GHC.Generics.Generic (Unison.ReferentPrime.Referent' r)
instance GHC.Base.Functor Unison.ReferentPrime.Referent'
instance GHC.Classes.Ord r => GHC.Classes.Ord (Unison.ReferentPrime.Referent' r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Unison.ReferentPrime.Referent' r)
instance GHC.Show.Show r => GHC.Show.Show (Unison.ReferentPrime.Referent' r)

module Unison.Referent

-- | Specifies a term.
--   
--   Either a term <a>Reference</a>, a data constructor, or an effect
--   constructor.
--   
--   Slightly odd naming. This is the "referent of term name in the
--   codebase", rather than the target of a Reference.
type Referent = Referent' Reference
pattern Ref :: TermReference -> Referent
pattern Con :: ConstructorReference -> ConstructorType -> Referent

-- | By definition, cannot be a builtin.
type Id = Referent' Id
pattern RefId :: Id -> Id
pattern ConId :: ConstructorReferenceId -> ConstructorType -> Id
fold :: (r -> a) -> (r -> ConstructorId -> ConstructorType -> a) -> Referent' r -> a
toId :: Referent -> Maybe Id
toReference :: Referent -> Reference
toReferenceId :: Referent -> Maybe Id
toConstructorReference :: Referent' r -> Maybe (GConstructorReference r)
toConstructorReferenceId :: Referent -> Maybe ConstructorReferenceId
toTermReference :: Referent' r -> Maybe r
toTermReferenceId :: Referent -> Maybe TermReferenceId
fromId :: Id -> Referent

-- | Inject a Term Reference into a Referent
fromTermReference :: TermReference -> Referent
fromTermReferenceId :: TermReferenceId -> Referent
fromText :: Text -> Maybe Referent

-- | A lens onto the reference in a referent.
reference_ :: Lens (Referent' r) (Referent' r') r r'
isPrefixOf :: ShortHash -> Referent -> Bool
toShortHash :: Referent -> ShortHash
toText :: Referent -> Text
toString :: Referent -> String

module Unison.LabeledDependency
derivedTerm :: Id -> LabeledDependency
derivedType :: Id -> LabeledDependency
termRef :: Reference -> LabeledDependency
typeRef :: Reference -> LabeledDependency
referent :: Referent -> LabeledDependency
dataConstructor :: ConstructorReference -> LabeledDependency
effectConstructor :: ConstructorReference -> LabeledDependency
fold :: (Reference -> a) -> (Referent -> a) -> LabeledDependency -> a
referents :: Foldable f => f Referent -> Set LabeledDependency

-- | A Union Type which contains either Type References or Term Referents.
data LabeledDependency
TypeReference :: Reference -> LabeledDependency
TermReferent :: Referent -> LabeledDependency

-- | Match on a TermReferent which is a Constructor.
pattern ConReference :: ConstructorReference -> ConstructorType -> LabeledDependency

-- | Match on a TermReferent which is NOT a Constructor.
pattern TermReference :: Reference -> LabeledDependency
partition :: Foldable t => t LabeledDependency -> ([Reference], [Referent])
instance GHC.Show.Show Unison.LabeledDependency.LabeledDependency
instance GHC.Classes.Ord Unison.LabeledDependency.LabeledDependency
instance GHC.Classes.Eq Unison.LabeledDependency.LabeledDependency

module Unison.HashQualified
data HashQualified n
NameOnly :: n -> HashQualified n
HashOnly :: ShortHash -> HashQualified n
HashQualified :: n -> ShortHash -> HashQualified n
stripNamespace :: Name -> HashQualified Name -> HashQualified Name
toName :: HashQualified n -> Maybe n
sortByLength :: [HashQualified Name] -> [HashQualified Name]
hasName :: HashQualified Name -> Bool
hasHash :: HashQualified Name -> Bool
toHash :: HashQualified n -> Maybe ShortHash
fromNameHash :: Maybe Name -> Maybe ShortHash -> HashQualified Name
take :: Int -> HashQualified n -> HashQualified n
toStringWith :: (n -> String) -> HashQualified n -> String
toTextWith :: (n -> Text) -> HashQualified n -> Text
fromNamedReferent :: n -> Referent -> HashQualified n
fromNamedReference :: n -> Reference -> HashQualified n
fromReferent :: Referent -> HashQualified Name
fromReference :: Reference -> HashQualified Name
fromPattern :: ConstructorReference -> HashQualified Name
fromName :: n -> HashQualified n
matchesNamedReferent :: Name -> Referent -> HashQualified Name -> Bool
matchesNamedReference :: Name -> Reference -> HashQualified Name -> Bool
requalify :: HashQualified Name -> Referent -> HashQualified Name
instance GHC.Generics.Generic (Unison.HashQualified.HashQualified n)
instance GHC.Show.Show n => GHC.Show.Show (Unison.HashQualified.HashQualified n)
instance GHC.Base.Functor Unison.HashQualified.HashQualified
instance Data.Traversable.Traversable Unison.HashQualified.HashQualified
instance GHC.Classes.Ord n => GHC.Classes.Ord (Unison.HashQualified.HashQualified n)
instance Data.Foldable.Foldable Unison.HashQualified.HashQualified
instance GHC.Classes.Eq n => GHC.Classes.Eq (Unison.HashQualified.HashQualified n)
instance Unison.Util.Alphabetical.Alphabetical n => Unison.Util.Alphabetical.Alphabetical (Unison.HashQualified.HashQualified n)

module Unison.HashQualifiedPrime

-- | Like Unison.HashQualified, but doesn't support a HashOnly variant
data HashQualified n
NameOnly :: n -> HashQualified n
HashQualified :: n -> ShortHash -> HashQualified n
type HQSegment = HashQualified NameSegment
toHQ :: HashQualified n -> HashQualified n
fromHQ :: HashQualified n -> Maybe (HashQualified n)

-- | Like <a>fromHQ</a>, but if the <a>HashQualified</a> is just a
--   <a>ShortHash</a>, return it on the <a>Left</a>, rather than as a
--   <a>Nothing</a>.
fromHQ2 :: HashQualified n -> Either ShortHash (HashQualified n)
toName :: HashQualified n -> n
nameLength :: (Name -> Text) -> HashQualified Name -> Int
take :: Int -> HashQualified n -> HashQualified n
toNameOnly :: HashQualified n -> HashQualified n
toHash :: HashQualified n -> Maybe ShortHash
toStringWith :: (n -> String) -> HashQualified n -> String
toTextWith :: (n -> Text) -> HashQualified n -> Text
fromNamedReferent :: n -> Referent -> HashQualified n
fromNamedReference :: n -> Reference -> HashQualified n
fromName :: n -> HashQualified n
fromNameHash :: n -> Maybe ShortHash -> HashQualified n
matchesNamedReferent :: Eq n => n -> Referent -> HashQualified n -> Bool
matchesNamedReference :: Eq n => n -> Reference -> HashQualified n -> Bool
requalify :: HashQualified Name -> Referent -> HashQualified Name

-- | Sort the list of names by length of segments: smaller number of
--   segments is listed first. NameOnly &lt; HashQualified
sortByLength :: [HashQualified Name] -> [HashQualified Name]
instance Data.Traversable.Traversable Unison.HashQualifiedPrime.HashQualified
instance GHC.Show.Show n => GHC.Show.Show (Unison.HashQualifiedPrime.HashQualified n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (Unison.HashQualifiedPrime.HashQualified n)
instance Data.Foldable.Foldable Unison.HashQualifiedPrime.HashQualified
instance GHC.Generics.Generic (Unison.HashQualifiedPrime.HashQualified n)
instance GHC.Base.Functor Unison.HashQualifiedPrime.HashQualified
instance GHC.Classes.Eq n => GHC.Classes.Eq (Unison.HashQualifiedPrime.HashQualified n)
instance Unison.Util.Alphabetical.Alphabetical n => Unison.Util.Alphabetical.Alphabetical (Unison.HashQualifiedPrime.HashQualified n)

module Unison.Settings
debugNoteLoc :: Bool
debugNoteSummary :: Bool
debugRevealForalls :: Bool
renderTermMaxLength :: Int
demoHideVarNumber :: Bool
removePureEffects :: Bool
cleanupTypes :: Bool

module Unison.Util.Components

-- | Order bindings by dependencies and group into components. Each
--   component consists of &gt; 1 bindings, each of which depends
--   transitively on all other bindings in the component.
--   
--   1-element components may or may not depend on themselves.
--   
--   The order is such that a component at index i will not depend on
--   components and indexes &gt; i. But a component at index i does not
--   _necessarily_ depend on any components at earlier indices.
--   
--   Example:
--   
--   let rec ping n = pong (n + 1); pong n = ping (n + 1); g = id 42; y =
--   id "hi" id x = x; in ping g
--   
--   <a>components</a> would produce `[[ping,pong], [id], [g], [y]]` Notice
--   that <a>id</a> comes before <tt>g</tt> and <tt>y</tt> in the output,
--   since both <tt>g</tt> and <tt>y</tt> depend on <a>id</a>.
--   
--   Uses Tarjan's algorithm:
--   <a>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a>
components :: Ord v => (t -> Set v) -> [(v, t)] -> [[(v, t)]]


-- | Based on:
--   <a>http://semantic-domain.blogspot.com/2015/03/abstract-binding-trees.html</a>
module Unison.ABT
data () => ABT (f :: Type -> Type) v r
Var :: v -> ABT (f :: Type -> Type) v r
Cycle :: r -> ABT (f :: Type -> Type) v r
Abs :: v -> r -> ABT (f :: Type -> Type) v r
Tm :: f r -> ABT (f :: Type -> Type) v r

-- | At each level in the tree, we store the set of free variables and a
--   value of type <tt>a</tt>. Variables are of type <tt>v</tt>.
data () => Term (f :: Type -> Type) v a
Term :: Set v -> a -> ABT f v (Term f v a) -> Term (f :: Type -> Type) v a
[freeVars] :: Term (f :: Type -> Type) v a -> Set v
[annotation] :: Term (f :: Type -> Type) v a -> a
[out] :: Term (f :: Type -> Type) v a -> ABT f v (Term f v a)
data () => Term' (f :: Type -> Type) v a x
Term' :: Set v -> a -> ABT f v x -> Term' (f :: Type -> Type) v a x
[freeVars'] :: Term' (f :: Type -> Type) v a x -> Set v
[annotation'] :: Term' (f :: Type -> Type) v a x -> a
[out'] :: Term' (f :: Type -> Type) v a x -> ABT f v x

-- | A class for avoiding accidental variable capture
--   
--   <ul>
--   <li>`Set.notMember (freshIn vs v) vs`: <a>freshIn</a> returns a
--   variable not used in the <a>Set</a></li>
--   </ul>
class Ord v => Var v
freshIn :: Var v => Set v -> v -> v
data V v
Free :: v -> V v
Bound :: v -> V v
data Subst f v a
Subst :: (forall m v'. Monad m => (v -> m v') -> m v') -> (Term f v a -> Term f v a) -> (forall b. Term f v b -> Term f v a) -> v -> Subst f v a
[$sel:freshen:Subst] :: Subst f v a -> forall m v'. Monad m => (v -> m v') -> m v'
[$sel:bind:Subst] :: Subst f v a -> Term f v a -> Term f v a
[$sel:bindInheritAnnotation:Subst] :: Subst f v a -> forall b. Term f v b -> Term f v a
[$sel:variable:Subst] :: Subst f v a -> v
fresh :: Var v => Term f v a -> v -> v
unvar :: V v -> v

-- | Freshens the given variable wrt. the set of used variables tracked by
--   state. Adds the result to the set of used variables.
freshenS :: (Var v, MonadState (Set v) m) => v -> m v

-- | Produce a variable which is free in both terms
freshInBoth :: forall v (f :: Type -> Type) a. Var v => Term f v a -> Term f v a -> v -> v
freshenBothWrt :: (Var v, Traversable f) => Term f v a -> Term f v a -> Term f v a -> (Term f v a, Term f v a)
freshenWrt :: (Var v, Traversable f) => (v -> v) -> Term f v a -> [Term f v a] -> [Term f v a]

-- | `visit f t` applies an effectful function to each subtree of
--   <tt>t</tt> and sequences the results. When <tt>f</tt> returns
--   <a>Nothing</a>, <a>visit</a> descends into the children of the current
--   subtree. When <tt>f</tt> returns `Just t2`, <a>visit</a> replaces the
--   current subtree with <tt>t2</tt>. Thus: `visit (const Nothing) t ==
--   pure t` and `visit (const (Just (pure t2))) t == pure t2`
visit :: forall (f :: Type -> Type) g v a. (Traversable f, Applicative g, Ord v) => (Term f v a -> Maybe (g (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit' :: (Traversable f, Monad g, Ord v) => (f (Term f v a) -> g (f (Term f v a))) -> Term f v a -> g (Term f v a)

-- | Apply an effectful function to an ABT tree top down, sequencing the
--   results.
visit_ :: (Traversable f, Applicative g, Ord v) => (f (Term f v a) -> g ()) -> Term f v a -> g (Term f v a)

-- | <a>visit</a> specialized to the <a>Identity</a> effect.
visitPure :: forall (f :: Type -> Type) v a. (Traversable f, Ord v) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Term f v a
changeVars :: (Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a
allVars :: forall (f :: Type -> Type) v a. Foldable f => Term f v a -> [v]
numberedFreeVars :: (Ord v, Foldable f) => Term f v a -> Map v Int
subterms :: forall v (f :: Type -> Type) a. (Ord v, Traversable f) => Term f v a -> [Term f v a]
annotateBound :: (Ord v, Foldable f, Functor f) => Term f v a -> Term f v (a, Set v)
rebuildUp :: (Ord v, Foldable f, Functor f) => (f (Term f v a) -> f (Term f v a)) -> Term f v a -> Term f v a
rebuildMaybeUp :: (Ord v, Foldable f, Functor f) => (Term f v a -> Maybe (Term f v a)) -> Term f v a -> Maybe (Term f v a)
rebuildUp' :: (Ord v, Foldable f, Functor f) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a
reannotateUp :: (Ord v, Foldable f, Functor f, Monoid b) => (Term f v a -> b) -> Term f v a -> Term f v (a, b)
rewriteDown :: (Traversable f, Ord v) => (Term f v a -> Term f v a) -> Term f v a -> Term f v a
transform :: (Ord v, Foldable g, Functor g) => (forall a1. () => f a1 -> g a1) -> Term f v a -> Term g v a
transformM :: (Ord v, Monad m, Traversable g) => (forall a1. () => f a1 -> m (g a1)) -> Term f v a -> m (Term g v a)
foreachSubterm :: forall (f :: Type -> Type) g v a b. (Traversable f, Applicative g) => (Term f v a -> g b) -> Term f v a -> g [b]
freeVarOccurrences :: (Traversable f, Ord v) => Set v -> Term f v a -> [(v, a)]

-- | <a>True</a> if <tt>v</tt> is a member of the set of free variables of
--   <tt>t</tt>
isFreeIn :: Ord v => v -> Term f v a -> Bool
occurrences :: (Foldable f, Var v) => v -> Term f v a -> Int
extraMap :: Functor g => (forall k. f k -> g k) -> Term f v a -> Term g v a
vmap :: forall (f :: Type -> Type) v' v a. (Functor f, Foldable f, Ord v') => (v -> v') -> Term f v a -> Term f v' a
vmapM :: forall m (f :: Type -> Type) v2 v a. (Applicative m, Traversable f, Foldable f, Ord v2) => (v -> m v2) -> Term f v a -> m (Term f v2 a)
amap :: (Functor f, Foldable f, Ord v) => (a -> a2) -> Term f v a -> Term f v a2

-- | renames <tt>old</tt> to <tt>new</tt> in the given term, ignoring
--   subtrees that bind <tt>old</tt>
rename :: forall (f :: Type -> Type) v a. (Foldable f, Functor f, Var v) => v -> v -> Term f v a -> Term f v a
renames :: (Foldable f, Functor f, Var v) => Map v v -> Term f v a -> Term f v a

-- | `subst v e body` substitutes <tt>e</tt> for <tt>v</tt> in
--   <tt>body</tt>, avoiding capture by renaming abstractions in
--   <tt>body</tt>
subst :: (Foldable f, Functor f, Var v) => v -> Term f v a -> Term f v a -> Term f v a

-- | `substs [(t1,v1), (t2,v2), ...] body` performs multiple simultaneous
--   substitutions, avoiding capture
substs :: (Foldable f, Functor f, Var v) => [(v, Term f v a)] -> Term f v a -> Term f v a
substInheritAnnotation :: forall (f :: Type -> Type) v b a. (Foldable f, Functor f, Var v) => v -> Term f v b -> Term f v a -> Term f v a
substsInheritAnnotation :: forall (f :: Type -> Type) v b a. (Foldable f, Functor f, Var v) => [(v, Term f v b)] -> Term f v a -> Term f v a
find :: (Ord v, Foldable f, Functor f) => (Term f v a -> FindAction x) -> Term f v a -> [x]
find' :: (Ord v, Foldable f, Functor f) => (Term f v a -> Bool) -> Term f v a -> [Term f v a]
data FindAction x
Found :: x -> FindAction x
Prune :: FindAction x
Continue :: FindAction x

-- | Core logic of structured find. Works for any base functor. Returns
--   <a>True</a> if there's a subexpression of <a>tm</a> which matches
--   <tt>query0</tt> for some assignment of variables.
containsExpression :: forall f v a. (Var v, forall a. Eq a => Eq (f a), Traversable f) => Term f v a -> Term f v a -> Bool

-- | Core logic of structured find and replace. Works for any base functor.
--   Returns <a>Nothing</a> if no replacements.
rewriteExpression :: forall f v a. (Var v, Show v, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), Traversable f) => Term f v a -> Term f v a -> Term f v a -> Maybe (Term f v a)
baseFunctor_ :: Applicative m => (f (Term f v a) -> m (f (Term f v a))) -> Term f v a -> m (Term f v a)

-- | Setter' (Term f v a) (Term f v a)
rewriteDown_ :: (Traversable f, Monad m, Ord v) => (Term f v a -> m (Term f v a)) -> Term f v a -> m (Term f v a)

-- | Replace the annotation with the given argument.
annotate :: a -> Term f v a -> Term f v a
annotatedVar :: a -> v -> Term f v a
var :: v -> Term f v ()
tm :: (Foldable f, Ord v) => f (Term f v ()) -> Term f v ()
tm' :: (Foldable f, Ord v) => a -> f (Term f v a) -> Term f v a
abs :: Ord v => v -> Term f v () -> Term f v ()
absChain :: Ord v => [v] -> Term f v () -> Term f v ()
absChain' :: Ord v => [(a, v)] -> Term f v a -> Term f v a
abs' :: Ord v => a -> v -> Term f v a -> Term f v a
absr :: (Functor f, Foldable f, Var v) => v -> Term f (V v) () -> Term f (V v) ()
unabs :: forall (f :: Type -> Type) v a. Term f v a -> ([v], Term f v a)
unabsA :: Term f v a -> ([(a, v)], Term f v a)
dropAbs :: Int -> Term f v a -> Term f v a
cycle :: Term f v () -> Term f v ()
cycle' :: a -> Term f v a -> Term f v a
cycler :: (Functor f, Foldable f, Var v) => [v] -> Term f (V v) () -> Term f (V v) ()
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
pattern Abs'' :: v -> Term f v a -> Term f v a
pattern AbsN' :: [v] -> Term f v a -> Term f v a
pattern AbsNA' :: [(a, v)] -> Term f v a -> Term f v a
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> f (Term f v a) -> Term f v a
pattern Cycle'' :: Term f v a -> Term f v a
pattern CycleA' :: a -> [(a, v)] -> Term f v a -> Term f v a
pattern Tm' :: f (Term f v a) -> Term f v a
components :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]
orderedComponents :: Var v => [(v, Term f v a)] -> [[(v, Term f v a)]]
instance GHC.Base.Functor Unison.ABT.V
instance GHC.Show.Show v => GHC.Show.Show (Unison.ABT.V v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.ABT.V v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.ABT.V v)
instance GHC.Base.Functor Unison.ABT.FindAction
instance GHC.Show.Show x => GHC.Show.Show (Unison.ABT.FindAction x)
instance U.Core.ABT.Var.Var v => U.Core.ABT.Var.Var (Unison.ABT.V v)

module Unison.ABT.Normalized
data ABT f v
Abs :: v -> Term f v -> ABT f v
Tm :: f v (Term f v) -> ABT f v
data Term f v
Term :: Set v -> ABT f v -> Term f v
[$sel:freeVars:Term] :: Term f v -> Set v
[$sel:out:Term] :: Term f v -> ABT f v
pattern TAbs :: Var v => v -> Term f v -> Term f v
pattern TTm :: (Var v, Bifoldable f) => f v (Term f v) -> Term f v
pattern TAbss :: Var v => [v] -> Term f v -> Term f v
class (Bifoldable f, Bifunctor f) => Align f
align :: (Align f, Applicative g) => (vl -> vr -> g vs) -> (el -> er -> g es) -> f vl el -> f vr er -> Maybe (g (f vs es))
alpha :: Align f => Var v => Map v v -> Term f v -> Term f v -> Either (Term f v, Term f v) ()
renames :: (Var v, Ord v, Bifunctor f, Bifoldable f) => Map v v -> Term f v -> Term f v
rename :: (Var v, Ord v, Bifunctor f, Bifoldable f) => v -> v -> Term f v -> Term f v
transform :: (Var v, Bifunctor g, Bifoldable f, Bifoldable g) => (forall a b. f a b -> g a b) -> Term f v -> Term g v
instance (forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (f a b), GHC.Show.Show v) => GHC.Show.Show (Unison.ABT.Normalized.ABT f v)
instance (forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (f a b), GHC.Show.Show v) => GHC.Show.Show (Unison.ABT.Normalized.Term f v)
instance (forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (f a b), Data.Bifunctor.Bifunctor f, Data.Bifoldable.Bifoldable f, U.Core.ABT.Var.Var v) => GHC.Classes.Eq (Unison.ABT.Normalized.ABT f v)
instance (forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (f a b), Data.Bifunctor.Bifunctor f, Data.Bifoldable.Bifoldable f, U.Core.ABT.Var.Var v) => GHC.Classes.Eq (Unison.ABT.Normalized.Term f v)

module Unison.Util.Conflicted

-- | A conflicted thing.
data Conflicted n a
Conflicted :: !n -> !NESet a -> Conflicted n a

module Unison.Util.Defn

-- | A "definition" is either a term or a type.
data Defn term typ
TermDefn :: term -> Defn term typ
TypeDefn :: typ -> Defn term typ

module Unison.Util.Defns

-- | Definitions (terms and types) in a namespace.
data Defns terms types
Defns :: terms -> types -> Defns terms types
[$sel:terms:Defns] :: Defns terms types -> terms
[$sel:types:Defns] :: Defns terms types -> types

-- | A common shape of definitions - terms and types are stored in the same
--   structure.
type DefnsF f terms types = Defns (f terms) (f types)
type DefnsF2 f g terms types = Defns (f (g terms)) (f (g types))
type DefnsF3 f g h terms types = Defns (f (g (h terms))) (f (g (h types)))
type DefnsF4 f g h i terms types = Defns (f (g (h (i terms)))) (f (g (h (i types))))
alignDefnsWith :: Semialign f => (These a b -> c) -> Defns (f a) (f b) -> f c
defnsAreEmpty :: (Foldable f, Foldable g) => Defns (f a) (g b) -> Bool
hoistDefnsF :: (forall x. f x -> g x) -> DefnsF f a b -> DefnsF g a b
mapDefns :: (a -> b) -> Defns a a -> Defns b b
unzipDefns :: Defns (tm1, tm2) (ty1, ty2) -> (Defns tm1 ty1, Defns tm2 ty2)
unzipDefnsWith :: (tm1 -> (tm2, tm3)) -> (ty1 -> (ty2, ty3)) -> Defns tm1 ty1 -> (Defns tm2 ty2, Defns tm3 ty3)
zipDefns :: Defns tm1 ty1 -> Defns tm2 ty2 -> Defns (tm1, tm2) (ty1, ty2)
zipDefnsWith :: (tm1 -> tm2 -> tm3) -> (ty1 -> ty2 -> ty3) -> Defns tm1 ty1 -> Defns tm2 ty2 -> Defns tm3 ty3
zipDefnsWith3 :: (tm1 -> tm2 -> tm3 -> tm4) -> (ty1 -> ty2 -> ty3 -> ty4) -> Defns tm1 ty1 -> Defns tm2 ty2 -> Defns tm3 ty3 -> Defns tm4 ty4
zipDefnsWith4 :: (tm1 -> tm2 -> tm3 -> tm4 -> tm5) -> (ty1 -> ty2 -> ty3 -> ty4 -> ty5) -> Defns tm1 ty1 -> Defns tm2 ty2 -> Defns tm3 ty3 -> Defns tm4 ty4 -> Defns tm5 ty5
instance (GHC.Base.Semigroup terms, GHC.Base.Semigroup types) => GHC.Base.Semigroup (Unison.Util.Defns.Defns terms types)
instance (GHC.Base.Monoid terms, GHC.Base.Monoid types) => GHC.Base.Monoid (Unison.Util.Defns.Defns terms types)
instance (GHC.Show.Show terms, GHC.Show.Show types) => GHC.Show.Show (Unison.Util.Defns.Defns terms types)
instance GHC.Base.Functor (Unison.Util.Defns.Defns terms)
instance GHC.Generics.Generic (Unison.Util.Defns.Defns terms types)
instance Data.Bifoldable.Bifoldable Unison.Util.Defns.Defns
instance Data.Bifunctor.Bifunctor Unison.Util.Defns.Defns
instance Data.Bitraversable.Bitraversable Unison.Util.Defns.Defns

module Unison.Util.Nametree

-- | A nametree has a value, and a collection of children nametrees keyed
--   by name segment.
data Nametree a
Nametree :: !a -> !Map NameSegment (Nametree a) -> Nametree a
[$sel:value:Nametree] :: Nametree a -> !a
[$sel:children:Nametree] :: Nametree a -> !Map NameSegment (Nametree a)

-- | Traverse over a nametree, with access to the list of name segments (in
--   reverse order) leading to each value.
traverseNametreeWithName :: Applicative f => ([NameSegment] -> a -> f b) -> Nametree a -> f (Nametree b)

-- | Build a nametree from a seed value.
unfoldNametree :: (a -> (b, Map NameSegment a)) -> a -> Nametree b

-- | <a>flattenNametree</a> organizes a nametree like
--   
--   <pre>
--   "foo" = #foo
--   "foo": {
--     "bar" = #bar
--     "bar": {
--       "baz" = #baz
--     }
--   }
--   </pre>
--   
--   into an equivalent-but-flat association between names and definitions,
--   like
--   
--   <pre>
--   {
--     "foo" = #bar,
--     "foo.bar" = #bar,
--     "foo.bar.baz" = #baz
--   }
--   </pre>
flattenNametree :: forall a b. Ord b => (a -> Map NameSegment b) -> Nametree a -> BiMultimap b Name

-- | Like <a>flattenNametree</a>, but works on both the types and terms
--   namespace at once.
flattenNametrees :: (Ord term, Ord typ) => Nametree (DefnsF (Map NameSegment) term typ) -> Defns (BiMultimap term Name) (BiMultimap typ Name)

-- | <a>unflattenNametree</a> organizes an association between names and
--   definitions like
--   
--   <pre>
--   {
--     "foo" = #bar,
--     "foo.bar" = #bar,
--     "foo.bar.baz" = #baz
--   }
--   </pre>
--   
--   into an equivalent-but-less-flat nametree, like
--   
--   <pre>
--   "foo" = #foo
--   "foo": {
--     "bar" = #bar
--     "bar": {
--       "baz" = #baz
--     }
--   }
--   </pre>
unflattenNametree :: Ord a => Map Name a -> Nametree (Map NameSegment a)

-- | Like <a>unflattenNametree</a>, but works on both the types and terms
--   namespace at once.
unflattenNametrees :: (Ord term, Ord typ) => DefnsF (Map Name) term typ -> Nametree (DefnsF (Map NameSegment) term typ)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Util.Nametree.Nametree a)
instance GHC.Generics.Generic (Unison.Util.Nametree.Nametree a)
instance Data.Traversable.Traversable Unison.Util.Nametree.Nametree
instance Data.Foldable.Foldable Unison.Util.Nametree.Nametree
instance GHC.Base.Functor Unison.Util.Nametree.Nametree
instance Data.Semialign.Internal.Semialign Unison.Util.Nametree.Nametree
instance Data.Semialign.Internal.Zip Unison.Util.Nametree.Nametree
instance Data.Semialign.Internal.Unzip Unison.Util.Nametree.Nametree

module Unison.Names
data Names
Names :: Relation Name Referent -> Relation Name TypeReference -> Names
[$sel:terms:Names] :: Names -> Relation Name Referent
[$sel:types:Names] :: Names -> Relation Name TypeReference
addTerm :: Name -> Referent -> Names -> Names
addType :: Name -> TypeReference -> Names -> Names

-- | Collect all references in the given Names, tagged with their type.
labeledReferences :: Names -> Set LabeledDependency

-- | filters out everything from the domain except what's conflicted
conflicts :: Names -> Names
contains :: Names -> Reference -> Bool
difference :: Names -> Names -> Names
filter :: (Name -> Bool) -> Names -> Names
filterByHQs :: Set (HashQualified Name) -> Names -> Names
filterBySHs :: Set ShortHash -> Names -> Names
filterTypes :: (Name -> Bool) -> Names -> Names

-- | Construct a <a>Names</a> from unconflicted reference ids.
fromReferenceIds :: DefnsF (Relation Name) TermReferenceId TypeReferenceId -> Names

-- | Construct a <a>Names</a> from unconflicted reference ids.
fromUnconflictedReferenceIds :: DefnsF (Map Name) TermReferenceId TypeReferenceId -> Names
map :: (Name -> Name) -> Names -> Names
makeAbsolute :: Names -> Names
makeRelative :: Names -> Names
fuzzyFind :: (Name -> Text) -> [String] -> Names -> [(Alignment, Name, Set (Either Referent TypeReference))]

-- | Like hqTermName and hqTypeName, but considers term and type names to
--   conflict with each other (so will hash-qualify if there is e.g. both a
--   term and a type named "foo").
--   
--   This is useful in contexts such as printing branch diffs. Example:
--   
--   <ul>
--   <li>Deletes:</li>
--   </ul>
--   
--   foo foo
--   
--   We want to append the hash regardless of whether or not one is a term
--   and the other is a type.
hqName :: Names -> Name -> Either TypeReference Referent -> HashQualified Name
hqTermName :: Int -> Names -> Name -> Referent -> HashQualified Name
hqTypeName :: Int -> Names -> Name -> TypeReference -> HashQualified Name
hqTermName' :: Int -> Name -> Referent -> HashQualified Name
hqTypeName' :: Int -> Name -> TypeReference -> HashQualified Name
_hqTermName :: Names -> Name -> Referent -> HashQualified Name
_hqTypeName :: Names -> Name -> TypeReference -> HashQualified Name
_hqTermAliases :: Names -> Name -> Referent -> Set (HashQualified Name)
_hqTypeAliases :: Names -> Name -> TypeReference -> Set (HashQualified Name)

-- | Map over each name in a <a>Names</a>.
mapNames :: (Name -> Name) -> Names -> Names

-- | <tt>prefix0 n ns</tt> prepends <tt>n</tt> to each name in <tt>ns</tt>.
--   
--   Precondition: every name in <tt>ns</tt> is relative.
prefix0 :: Name -> Names -> Names
restrictReferences :: Set Reference -> Names -> Names

-- | Get all terms with a specific name.
refTermsNamed :: Names -> Name -> Set TermReference

-- | Get all terms with a specific hash-qualified name.
refTermsHQNamed :: Names -> HashQualified Name -> Set TermReference

-- | Get all (untagged) term/type references ids in a <tt>Names</tt>.
referenceIds :: Names -> Set Id

-- | Returns all constructor term references. Constructors are omitted.
termReferences :: Names -> Set TermReference
termReferents :: Names -> Set Referent
typeReferences :: Names -> Set TypeReference
termsNamed :: Names -> Name -> Set Referent
typesNamed :: Names -> Name -> Set TypeReference

-- | Construct names from a left-biased map union of the domains of the
--   input names. That is, for each distinct name, if it refers to *any*
--   references in the left argument, use those (ignoring the right).
--   
--   This is appropriate for shadowing names in the codebase with names in
--   a Unison file, for instance:
--   
--   <pre>
--   shadowing scratchFileNames codebaseNames
--   </pre>
shadowing :: Names -> Names -> Names
shadowing1 :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b

-- | Construct names from a left-biased map union of the ranges of the
--   input names. That is, for each distinct reference, if it is referred
--   to by *any* names in the left argument, use those (ignoring the
--   right).
--   
--   This is appropriate for biasing a PPE towards picking names in the
--   left argument.
preferring :: Names -> Names -> Names
namesForReference :: Names -> TypeReference -> Set Name
namesForReferent :: Names -> Referent -> Set Name
shadowTerms :: [Name] -> Names -> Names

-- | Given a mapping from name to qualified name, update a <a>Names</a>, so
--   for instance if the input has [(Some, Optional.Some)], and <a>Some</a>
--   is a constructor in the input <a>Names</a>, the alias <tt>Some</tt>
--   will map to that same constructor and shadow anything else that is
--   currently called <tt>Some</tt>.
importing :: [(Name, Name)] -> Names -> Names
constructorsForType :: TypeReference -> Names -> [(Name, Referent)]

-- | Converts a wildcard import into a list of explicit imports, of the
--   form [(suffix, full)]. Example: if <tt>io</tt> contains two functions,
--   <tt>foo</tt> and <tt>bar</tt>, then `expandWildcardImport io` will
--   produce `[(foo, io.foo), (bar, io.bar)]`.
expandWildcardImport :: Name -> Names -> [(Name, Name)]
isEmpty :: Names -> Bool
hashQualifyTypesRelation :: Relation Name TypeReference -> Relation (HashQualified Name) TypeReference
hashQualifyTermsRelation :: Relation Name Referent -> Relation (HashQualified Name) Referent
fromTermsAndTypes :: [(Name, Referent)] -> [(Name, TypeReference)] -> Names

-- | <a>Leniently</a> view a Names as a NameTree
--   
--   This function is "lenient" in the sense that it does not handle
--   conflicted names with any smarts whatsoever. The resulting nametree
--   will simply contain one of the associated references of a conflicted
--   name - we don't specify which.
lenientToNametree :: Names -> Nametree (DefnsF (Map NameSegment) Referent TypeReference)
resolveName :: forall ref. (Ord ref, Show ref) => Relation Name ref -> Set Name -> Name -> Set (ResolvesTo ref)

-- | Like <a>resolveName</a>, but include the names in the output.
resolveNameIncludingNames :: forall ref. (Ord ref, Show ref) => Relation Name ref -> Set Name -> Name -> Relation Name (ResolvesTo ref)
instance GHC.Generics.Generic Unison.Names.Names
instance GHC.Show.Show Unison.Names.Names
instance GHC.Classes.Ord Unison.Names.Names
instance GHC.Classes.Eq Unison.Names.Names
instance GHC.Base.Semigroup Unison.Names.Names
instance GHC.Base.Monoid Unison.Names.Names

module Unison.NamesWithHistory
diff :: Names -> Names -> Diff
push :: Names -> Names -> Names

-- | Find all types whose name has a suffix matching the provided
--   <a>HashQualified</a>.
lookupHQType :: SearchType -> HashQualified Name -> Names -> Set TypeReference

-- | Find all types whose name has a suffix matching the provided
--   <tt>HashQualified'</tt>. See <a>lookupHQType</a>.
lookupHQType' :: SearchType -> HashQualified Name -> Names -> Set TypeReference

-- | Find all terms whose name has a suffix matching the provided
--   <a>HashQualified</a>.
lookupHQTerm :: SearchType -> HashQualified Name -> Names -> Set Referent

-- | Find all terms whose name has a suffix matching the provided
--   <tt>HashQualified'</tt>. See <a>lookupHQTerm</a>.
lookupHQTerm' :: SearchType -> HashQualified Name -> Names -> Set Referent
lookupRelativeHQType :: SearchType -> HashQualified Name -> Names -> Set TypeReference
lookupRelativeHQType' :: SearchType -> HashQualified Name -> Names -> Set TypeReference
lookupRelativeHQTerm :: SearchType -> HashQualified Name -> Names -> Set Referent
lookupRelativeHQTerm' :: SearchType -> HashQualified Name -> Names -> Set Referent
hasTermNamed :: SearchType -> Name -> Names -> Bool
hasTypeNamed :: SearchType -> Name -> Names -> Bool
typeName :: Int -> Reference -> Names -> Set (HashQualified Name)
termNamesByLength :: Int -> Referent -> Names -> [HashQualified Name]
longestTermName :: Int -> Referent -> Names -> HashQualified Name
termName :: Int -> Referent -> Names -> Set (HashQualified Name)
lookupHQPattern :: SearchType -> HashQualified Name -> ConstructorType -> Names -> Set ConstructorReference
data Diff
Diff :: Names -> Names -> Names -> Diff
[$sel:originalNames:Diff] :: Diff -> Names
[$sel:addedNames:Diff] :: Diff -> Names
[$sel:removedNames:Diff] :: Diff -> Names

-- | Whether to search for exact matches or to find definitions by a suffix
--   of their name.
data SearchType
IncludeSuffixes :: SearchType
ExactName :: SearchType
instance GHC.Show.Show Unison.NamesWithHistory.SearchType
instance GHC.Classes.Ord Unison.NamesWithHistory.SearchType
instance GHC.Classes.Eq Unison.NamesWithHistory.SearchType
instance GHC.Show.Show Unison.NamesWithHistory.Diff

module Unison.Names.ResolutionResult
data ResolutionError ref
NotFound :: ResolutionError ref
Ambiguous :: Names -> Set ref -> Set Name -> ResolutionError ref

-- | ResolutionFailure represents the failure to resolve a given name.
data ResolutionFailure annotation
TypeResolutionFailure :: HashQualified Name -> annotation -> ResolutionError TypeReference -> ResolutionFailure annotation
TermResolutionFailure :: HashQualified Name -> annotation -> ResolutionError Referent -> ResolutionFailure annotation
type ResolutionResult a r = Either (Seq (ResolutionFailure a)) r
getAnnotation :: ResolutionFailure a -> a
instance GHC.Show.Show ref => GHC.Show.Show (Unison.Names.ResolutionResult.ResolutionError ref)
instance GHC.Classes.Ord ref => GHC.Classes.Ord (Unison.Names.ResolutionResult.ResolutionError ref)
instance GHC.Classes.Eq ref => GHC.Classes.Eq (Unison.Names.ResolutionResult.ResolutionError ref)
instance Data.Traversable.Traversable Unison.Names.ResolutionResult.ResolutionFailure
instance Data.Foldable.Foldable Unison.Names.ResolutionResult.ResolutionFailure
instance GHC.Base.Functor Unison.Names.ResolutionResult.ResolutionFailure
instance GHC.Show.Show annotation => GHC.Show.Show (Unison.Names.ResolutionResult.ResolutionFailure annotation)
instance GHC.Classes.Ord annotation => GHC.Classes.Ord (Unison.Names.ResolutionResult.ResolutionFailure annotation)
instance GHC.Classes.Eq annotation => GHC.Classes.Eq (Unison.Names.ResolutionResult.ResolutionFailure annotation)


-- | A "watch kind" is the slug that comes before a "&gt;" in a Unison
--   file:
--   
--   <pre>
--   foo&gt; bar = baz
--   </pre>
--   
--   In this example, the watch kind is "foo".
module Unison.WatchKind
type WatchKind = String

-- | A non-test watch, such as <tt> &gt; 3 + 4 </tt>
pattern RegularWatch :: (Eq a, IsString a) => a

-- | A named test watch, such as
--   
--   <pre>
--   test&gt; x = expect (1 == 1)
--   </pre>
--   
--   Note: currently test watches don't need to be named by the user, but
--   that "feature" will be removed soon.
pattern TestWatch :: (Eq a, IsString a) => a
watchKindShouldBeStoredInDatabase :: Maybe WatchKind -> Bool

module Unison.Var

-- | A class for variables. Variables may have auxiliary information which
--   may not form part of their identity according to <a>Eq</a> /
--   <a>Ord</a>. Laws:
--   
--   <ul>
--   <li>`typeOf (typed n) == n`</li>
--   <li>`typeOf (ABT.freshIn vs v) == typeOf v`: <a>freshIn</a> does not
--   alter the name</li>
--   </ul>
class (Show v, Var v) => Var v
typed :: Var v => Type -> v
typeOf :: Var v => v -> Type
freshId :: Var v => v -> Word64
freshenId :: Var v => Word64 -> v -> v
data Type
User :: Text -> Type
Inference :: InferenceType -> Type
MissingResult :: Type
Blank :: Type

-- | An unnamed reference, created during unhashing a term/decl component.
UnnamedReference :: Id -> Type
UnnamedWatch :: WatchKind -> Text -> Type
Eta :: Type
ANFBlank :: Type
Float :: Type
Pattern :: Type
Irrelevant :: Type
Delay :: Type
data InferenceType
Ability :: InferenceType
Input :: InferenceType
Output :: InferenceType
PatternPureE :: InferenceType
PatternPureV :: InferenceType
PatternBindE :: InferenceType
PatternBindV :: InferenceType
TypeConstructor :: InferenceType
TypeConstructorArg :: InferenceType
Other :: InferenceType
bakeId :: Var v => v -> v
blank :: Var v => v
freshIn :: Var v => Set v -> v -> v
inferAbility :: Var v => v
inferInput :: Var v => v
inferOther :: Var v => v
inferOutput :: Var v => v
inferPatternBindE :: Var v => v
inferPatternBindV :: Var v => v
inferPatternPureE :: Var v => v
inferPatternPureV :: Var v => v
inferTypeConstructor :: Var v => v
inferTypeConstructorArg :: Var v => v

-- | Currently, actions in blocks are encoded as bindings with names of the
--   form _123 (an underscore, followed by 1 or more digits). This function
--   returns <a>True</a> if the input variable has this form.
--   
--   Various places check for this (the pretty-printer, to determine how to
--   print the binding), and the typechecker (to decide if it should ensure
--   the binding has type <tt>()</tt>).
isAction :: Var v => v -> Bool
missingResult :: Var v => v
name :: Var v => v -> Text
nameStr :: Var v => v -> String
named :: Var v => Text -> v
nameds :: Var v => String -> v
rawName :: Type -> Text
reset :: Var v => v -> v
uncapitalize :: Var v => v -> v
universallyQuantifyIfFree :: forall v. Var v => v -> Bool
unnamedRef :: Var v => Id -> v
unnamedTest :: Var v => Text -> v
instance GHC.Show.Show Unison.Var.InferenceType
instance GHC.Classes.Ord Unison.Var.InferenceType
instance GHC.Classes.Eq Unison.Var.InferenceType
instance GHC.Show.Show Unison.Var.Type
instance GHC.Classes.Ord Unison.Var.Type
instance GHC.Classes.Eq Unison.Var.Type

module Unison.Type

-- | Base functor for types in the Unison language
data F a
Ref :: TypeReference -> F a
Arrow :: a -> a -> F a
Ann :: a -> Kind -> F a
App :: a -> a -> F a
Effect :: a -> a -> F a
Effects :: [a] -> F a
Forall :: a -> F a
IntroOuter :: a -> F a
_Ref :: Prism' (F a) TypeReference

-- | Types are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Type v a = Term F v a

-- | For use with recursion schemes.
type TypeF v a r = Term' F v a r
wrapV :: Ord v => Type v a -> Type (V v) a
freeVars :: Type v a -> Set v
bindExternal :: Var v => [(v, TypeReference)] -> Type v a -> Type v a
bindReferences :: Var v => (v -> Name) -> Set v -> Map Name TypeReference -> Type v a -> ResolutionResult a (Type v a)
newtype Monotype v a
Monotype :: Type v a -> Monotype v a
[$sel:getPolytype:Monotype] :: Monotype v a -> Type v a
monotype :: Var v => Type v a -> Maybe (Monotype v a)
arity :: Type v a -> Int
pattern Ref' :: TypeReference -> Term F v a
pattern Arrow' :: Term F v a -> Term F v a -> Term F v a
pattern Arrow'' :: Ord v => Term F v a -> [Type v a] -> Type v a -> Term F v a
pattern Arrows' :: [Type v a] -> Type v a
pattern EffectfulArrows' :: Type v a -> [(Maybe [Type v a], Type v a)] -> Type v a
pattern Ann' :: Term F v a -> Kind -> Term F v a
pattern App' :: Term F v a -> Term F v a -> Term F v a
pattern Apps' :: Type v a -> [Type v a] -> Type v a
pattern Pure' :: Ord v => Type v a -> Type v a
pattern Request' :: [Type v a] -> Type v a -> Type v a
pattern Effects' :: [Term F v a] -> Term F v a
pattern Effect1' :: Term F v a -> Term F v a -> Term F v a
pattern Effect' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Effect'' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Effect0' :: Ord v => [Type v a] -> Type v a -> Type v a
pattern Forall' :: Var v => Subst F v a -> Term F v a
pattern IntroOuter' :: Var v => Subst F v a -> Term F v a
pattern IntroOuterNamed' :: v -> Term F v a -> Term F v a
pattern ForallsNamed' :: [v] -> Type v a -> Type v a
pattern ForallsNamedOpt' :: [v] -> Type v a -> Type v a
unForallsOpt :: Type v a -> ([v], Type v a)
pattern ForallNamed' :: v -> Term F v a -> Term F v a
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> f (Term f v a) -> Term f v a
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
unPure :: Ord v => Type v a -> Maybe (Type v a)
unArrows :: Type v a -> Maybe [Type v a]
unEffectfulArrows :: Type v a -> Maybe (Type v a, [(Maybe [Type v a], Type v a)])
unApps :: Type v a -> Maybe (Type v a, [Type v a])
unIntroOuters :: Type v a -> Maybe ([v], Type v a)
stripIntroOuters :: Type v a -> Type v a
unForalls :: Type v a -> Maybe ([v], Type v a)
unEffect0 :: Ord v => Type v a -> ([Type v a], Type v a)
unEffects1 :: Ord v => Type v a -> Maybe ([Type v a], Type v a)

-- | True if the given type is a function, possibly quantified
isArrow :: Var v => Type v a -> Bool
ref :: Ord v => a -> TypeReference -> Type v a
refId :: Ord v => a -> Id -> Type v a
termLink :: Ord v => a -> Type v a
typeLink :: Ord v => a -> Type v a
derivedBase32Hex :: Ord v => TypeReference -> a -> Type v a
intRef :: TypeReference
natRef :: TypeReference
floatRef :: TypeReference
booleanRef :: TypeReference
textRef :: TypeReference
charRef :: TypeReference
listRef :: TypeReference
bytesRef :: TypeReference
effectRef :: TypeReference
termLinkRef :: TypeReference
typeLinkRef :: TypeReference
builtinIORef :: TypeReference
fileHandleRef :: TypeReference
filePathRef :: TypeReference
threadIdRef :: TypeReference
socketRef :: TypeReference
udpSocketRef :: TypeReference
udpListenSocketRef :: TypeReference
udpClientSockAddrRef :: TypeReference
processHandleRef :: TypeReference
scopeRef :: TypeReference
refRef :: TypeReference
iarrayRef :: TypeReference
marrayRef :: TypeReference
ibytearrayRef :: TypeReference
mbytearrayRef :: TypeReference
mvarRef :: TypeReference
tvarRef :: TypeReference
ticketRef :: TypeReference
promiseRef :: TypeReference
tlsRef :: TypeReference
stmRef :: TypeReference
patternRef :: TypeReference
charClassRef :: TypeReference
tlsClientConfigRef :: TypeReference
tlsServerConfigRef :: TypeReference
tlsSignedCertRef :: TypeReference
tlsPrivateKeyRef :: TypeReference
tlsCipherRef :: TypeReference
tlsVersionRef :: TypeReference
hashAlgorithmRef :: TypeReference
codeRef :: TypeReference
valueRef :: TypeReference
anyRef :: TypeReference
timeSpecRef :: TypeReference
any :: Ord v => a -> Type v a
builtin :: Ord v => a -> Text -> Type v a
int :: Ord v => a -> Type v a
nat :: Ord v => a -> Type v a
float :: Ord v => a -> Type v a
boolean :: Ord v => a -> Type v a
text :: Ord v => a -> Type v a
char :: Ord v => a -> Type v a
fileHandle :: Ord v => a -> Type v a
processHandle :: Ord v => a -> Type v a
threadId :: Ord v => a -> Type v a
builtinIO :: Ord v => a -> Type v a
scopeType :: Ord v => a -> Type v a
refType :: Ord v => a -> Type v a
iarrayType :: Ord v => a -> Type v a
marrayType :: Ord v => a -> Type v a
ibytearrayType :: Ord v => a -> Type v a
mbytearrayType :: Ord v => a -> Type v a
socket :: Ord v => a -> Type v a
udpSocket :: Ord v => a -> Type v a
udpListenSocket :: Ord v => a -> Type v a
udpClientSockAddr :: Ord v => a -> Type v a
list :: Ord v => a -> Type v a
bytes :: Ord v => a -> Type v a
effectType :: Ord v => a -> Type v a
code :: Ord v => a -> Type v a
value :: Ord v => a -> Type v a
app :: Ord v => a -> Type v a -> Type v a -> Type v a
apps :: Ord v => Type v a -> [(a, Type v a)] -> Type v a
app' :: (Ord v, Semigroup a) => Type v a -> Type v a -> Type v a
apps' :: (Semigroup a, Ord v) => Type v a -> [Type v a] -> Type v a
arrow :: Ord v => a -> Type v a -> Type v a -> Type v a
arrow' :: (Semigroup a, Ord v) => Type v a -> Type v a -> Type v a
ann :: Ord v => a -> Type v a -> Kind -> Type v a
forAll :: Ord v => a -> v -> Type v a -> Type v a
introOuter :: Ord v => a -> v -> Type v a -> Type v a
iff :: Var v => Type v ()
iff' :: Var v => a -> Type v a
iff2 :: Var v => a -> Type v a
andor :: Ord v => Type v ()
andor' :: Ord v => a -> Type v a
var :: Ord v => a -> v -> Type v a
v' :: Var v => Text -> Type v ()
av' :: Var v => a -> Text -> Type v a
forAll' :: Var v => a -> [Text] -> Type v a -> Type v a
foralls :: Ord v => a -> [v] -> Type v a -> Type v a
arrows :: Ord v => [(a, Type v a)] -> Type v a -> Type v a
effect :: Ord v => a -> [Type v a] -> Type v a -> Type v a
effects :: Ord v => a -> [Type v a] -> Type v a
effect1 :: Ord v => a -> Type v a -> Type v a -> Type v a
flattenEffects :: Type v a -> [Type v a]
effectV :: Ord v => a -> (a, Type v a) -> (a, Type v a) -> Type v a
stripEffect :: Ord v => Type v a -> ([Type v a], Type v a)
flipApply :: Var v => Type v () -> Type v ()
generalize' :: Var v => Type -> Type v a -> Type v a

-- | Bind the given variables with an outer <a>forAll</a>, if they are used
--   in <tt>t</tt>.
generalize :: Ord v => [v] -> Type v a -> Type v a
unforall :: Type v a -> Type v a
unforall' :: Type v a -> ([v], Type v a)
dependencies :: Ord v => Type v a -> Set TypeReference
labeledDependencies :: Ord v => Type v a -> Set LabeledDependency
updateDependencies :: Ord v => Map TypeReference TypeReference -> Type v a -> Type v a
usesEffects :: Ord v => Type v a -> Bool
freeEffectVars :: Ord v => Type v a -> Set v
existentializeArrows :: (Ord v, Monad m) => m v -> Type v a -> m (Type v a)
purifyArrows :: Ord v => Type v a -> Type v a
removeEffectVars :: Var v => Bool -> Set v -> Type v a -> Type v a
removeAllEffectVars :: Var v => Type v a -> Type v a
removeEmptyEffects :: Ord v => Type v a -> Type v a
removePureEffects :: Var v => Bool -> Type v a -> Type v a
editFunctionResult :: forall v a. Ord v => (Type v a -> Type v a) -> Type v a -> Type v a
functionResult :: Type v a -> Maybe (Type v a)

-- | Bind all free variables (not in <tt>except</tt>) that start with a
--   lowercase letter and are unqualified with an outer <tt>forall</tt>. `a
--   -&gt; a` becomes `∀ a . a -&gt; a` `B -&gt; B` becomes `B -&gt; B`
--   (not changed) `.foo -&gt; .foo` becomes `.foo -&gt; .foo` (not
--   changed) `.foo.bar -&gt; blarrg.woot` becomes `.foo.bar -&gt;
--   blarrg.woot` (unchanged)
generalizeLowercase :: Var v => Set v -> Type v a -> Type v a
freeVarsToOuters :: Ord v => Set v -> Type v a -> Type v a
normalizeForallOrder :: forall v a. Var v => Type v a -> Type v a

-- | This function removes all variable shadowing from the types and
--   reduces fresh ids to the minimum possible to avoid ambiguity. Useful
--   when showing two different types.
cleanupVars :: Var v => [Type v a] -> [Type v a]
cleanupVarsMap :: Var v => [Type v a] -> Map v v
cleanupVars1' :: Var v => Map v v -> Type v a -> Type v a

-- | This function removes all variable shadowing from the type and reduces
--   fresh ids to the minimum possible to avoid ambiguity.
cleanupVars1 :: Var v => Type v a -> Type v a
cleanupAbilityLists :: Var v => Type v a -> Type v a
cleanups :: Var v => [Type v a] -> [Type v a]
cleanup :: Var v => Type v a -> Type v a
builtinAbilities :: Set TypeReference
instance Data.Traversable.Traversable Unison.Type.F
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Type.F a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Type.F a)
instance GHC.Generics.Generic1 Unison.Type.F
instance GHC.Generics.Generic (Unison.Type.F a)
instance GHC.Base.Functor Unison.Type.F
instance Data.Foldable.Foldable Unison.Type.F
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Type.Monotype v a)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Type.Monotype v a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Type.F a)

module Unison.Type.Names
bindNames :: forall a v. Var v => (v -> Name) -> (Name -> v) -> Set v -> Names -> Type v a -> ResolutionResult a (Type v a)

module Unison.Pattern
data Pattern loc
Unbound :: loc -> Pattern loc
Var :: loc -> Pattern loc
Boolean :: loc -> !Bool -> Pattern loc
Int :: loc -> !Int64 -> Pattern loc
Nat :: loc -> !Word64 -> Pattern loc
Float :: loc -> !Double -> Pattern loc
Text :: loc -> !Text -> Pattern loc
Char :: loc -> !Char -> Pattern loc
Constructor :: loc -> !ConstructorReference -> [Pattern loc] -> Pattern loc
As :: loc -> Pattern loc -> Pattern loc
EffectPure :: loc -> Pattern loc -> Pattern loc
EffectBind :: loc -> !ConstructorReference -> [Pattern loc] -> Pattern loc -> Pattern loc
SequenceLiteral :: loc -> [Pattern loc] -> Pattern loc
SequenceOp :: loc -> Pattern loc -> !SeqOp -> Pattern loc -> Pattern loc
data SeqOp
Cons :: SeqOp
Snoc :: SeqOp
Concat :: SeqOp
updateDependencies :: Map Referent Referent -> Pattern loc -> Pattern loc
hasSubpattern :: Pattern loc -> Pattern loc -> Bool
application :: Pattern loc -> Bool
loc :: Pattern loc -> loc
setLoc :: Pattern loc -> loc -> Pattern loc
foldMap' :: Monoid m => (Pattern loc -> m) -> Pattern loc -> m
generalizedDependencies :: Ord r => (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Pattern loc -> Set r
labeledDependencies :: Pattern loc -> Set LabeledDependency
instance GHC.Generics.Generic Unison.Pattern.SeqOp
instance GHC.Classes.Ord Unison.Pattern.SeqOp
instance GHC.Show.Show Unison.Pattern.SeqOp
instance GHC.Classes.Eq Unison.Pattern.SeqOp
instance Data.Traversable.Traversable Unison.Pattern.Pattern
instance Data.Foldable.Foldable Unison.Pattern.Pattern
instance GHC.Base.Functor Unison.Pattern.Pattern
instance GHC.Generics.Generic (Unison.Pattern.Pattern loc)
instance GHC.Classes.Ord loc => GHC.Classes.Ord (Unison.Pattern.Pattern loc)
instance GHC.Show.Show (Unison.Pattern.Pattern loc)
instance GHC.Classes.Eq (Unison.Pattern.Pattern loc)

module Unison.Term
data MatchCase loc a
MatchCase :: Pattern loc -> Maybe a -> a -> MatchCase loc a
[$sel:matchPattern:MatchCase] :: MatchCase loc a -> Pattern loc
[$sel:matchGuard:MatchCase] :: MatchCase loc a -> Maybe a
[$sel:matchBody:MatchCase] :: MatchCase loc a -> a
matchPattern_ :: Lens' (MatchCase loc a) (Pattern loc)

-- | Base functor for terms in the Unison language We need <tt>typeVar</tt>
--   because the term and type variables may differ.
data F typeVar typeAnn patternAnn a
Int :: Int64 -> F typeVar typeAnn patternAnn a
Nat :: Word64 -> F typeVar typeAnn patternAnn a
Float :: Double -> F typeVar typeAnn patternAnn a
Boolean :: Bool -> F typeVar typeAnn patternAnn a
Text :: Text -> F typeVar typeAnn patternAnn a
Char :: Char -> F typeVar typeAnn patternAnn a
Blank :: Blank typeAnn -> F typeVar typeAnn patternAnn a
Ref :: Reference -> F typeVar typeAnn patternAnn a
Constructor :: ConstructorReference -> F typeVar typeAnn patternAnn a
Request :: ConstructorReference -> F typeVar typeAnn patternAnn a
Handle :: a -> a -> F typeVar typeAnn patternAnn a
App :: a -> a -> F typeVar typeAnn patternAnn a
Ann :: a -> Type typeVar typeAnn -> F typeVar typeAnn patternAnn a
List :: Seq a -> F typeVar typeAnn patternAnn a
If :: a -> a -> a -> F typeVar typeAnn patternAnn a
And :: a -> a -> F typeVar typeAnn patternAnn a
Or :: a -> a -> F typeVar typeAnn patternAnn a
Lam :: a -> F typeVar typeAnn patternAnn a
LetRec :: IsTop -> [a] -> a -> F typeVar typeAnn patternAnn a
Let :: IsTop -> a -> a -> F typeVar typeAnn patternAnn a
Match :: a -> [MatchCase patternAnn a] -> F typeVar typeAnn patternAnn a
TermLink :: Referent -> F typeVar typeAnn patternAnn a
TypeLink :: Reference -> F typeVar typeAnn patternAnn a
_Ref :: Prism' (F tv ta pa a) Reference
_Match :: Prism' (F tv ta pa a) (a, [MatchCase pa a])
_Constructor :: Prism' (F tv ta pa a) ConstructorReference
_Request :: Prism' (F tv ta pa a) ConstructorReference
_Ann :: Prism' (F tv ta pa a) (a, Term F tv ta)
_TermLink :: Prism' (F tv ta pa a) Referent
_TypeLink :: Prism' (F tv ta pa a) Reference

-- | Returns the top-level type annotation for a term if it has one.
getTypeAnnotation :: Term v a -> Maybe (Type v a)
type IsTop = Bool

-- | Like `Term v`, but with an annotation of type <tt>a</tt> at every
--   level in the tree
type Term v a = Term2 v a a v a

-- | Allow type variables and term variables to differ
type Term' vt v a = Term2 vt a a v a

-- | Allow type variables, term variables, type annotations and term
--   annotations to all differ
type Term2 vt at ap v a = Term (F vt at ap) v a

-- | Like `Term v a`, but with only () for type and pattern annotations.
type Term3 v a = Term2 v () () v a

-- | Terms are represented as ABTs over the base functor F, with variables
--   in <tt>v</tt>
type Term0 v = Term v ()

-- | Terms with type variables in <tt>vt</tt>, and term variables in
--   <tt>v</tt>
type Term0' vt v = Term' vt v ()
bindNames :: forall v a. Var v => (v -> Name) -> (Name -> v) -> Set v -> Names -> Term v a -> ResolutionResult a (Term v a)
prepareTDNR :: Var v => Term (F vt b ap) v b -> Term (F vt b ap) v b
amap :: Ord v => (a -> a2) -> Term v a -> Term v a2
patternMap :: (Pattern ap -> Pattern ap2) -> Term2 vt at ap v a -> Term2 vt at ap2 v a
vmap :: Ord v2 => (v -> v2) -> Term v a -> Term v2 a
vtmap :: Ord vt2 => (vt -> vt2) -> Term' vt v a -> Term' vt2 v a
typeMap :: Ord vt2 => (Type vt at -> Type vt2 at2) -> Term2 vt at ap v a -> Term2 vt2 at2 ap v a
extraMap' :: (Ord vt, Ord vt') => (vt -> vt') -> (at -> at') -> (ap -> ap') -> Term2 vt at ap v a -> Term2 vt' at' ap' v a
extraMap :: (Ord vt, Ord vt') => (vt -> vt') -> (at -> at') -> (ap -> ap') -> F vt at ap a -> F vt' at' ap' a
matchCaseExtraMap :: (loc -> loc') -> MatchCase loc a -> MatchCase loc' a
unannotate :: forall vt at ap v a. Ord v => Term2 vt at ap v a -> Term0' vt v
wrapV :: Ord v => Term v a -> Term (V v) a

-- | All variables mentioned in the given term. Includes both term and type
--   variables, both free and bound.
allVars :: Ord v => Term v a -> Set v
freeVars :: Term' vt v a -> Set v
freeTypeVars :: Ord vt => Term' vt v a -> Set vt
freeTypeVarAnnotations :: Ord vt => Term' vt v a -> Map vt [a]
substTypeVars :: (Ord v, Var vt) => [(vt, Type vt b)] -> Term' vt v a -> Term' vt v a
substTypeVar :: (Ord v, Var vt) => vt -> Type vt b -> Term' vt v a -> Term' vt v a
renameTypeVar :: (Ord v, Var vt) => vt -> vt -> Term' vt v a -> Term' vt v a
generalizeTypeSignatures :: (Var vt, Var v) => Term' vt v a -> Term' vt v a
pattern Var' :: v -> Term f v a
pattern Cycle' :: [v] -> f (Term f v a) -> Term f v a
pattern Abs' :: (Foldable f, Functor f, Var v) => Subst f v a -> Term f v a
pattern Int' :: Int64 -> Term (F typeVar typeAnn patternAnn) v a
pattern Nat' :: Word64 -> Term (F typeVar typeAnn patternAnn) v a
pattern Float' :: Double -> Term (F typeVar typeAnn patternAnn) v a
pattern Boolean' :: Bool -> Term (F typeVar typeAnn patternAnn) v a
pattern Text' :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern Char' :: Char -> Term (F typeVar typeAnn patternAnn) v a
pattern Blank' :: Blank typeAnn -> Term (F typeVar typeAnn patternAnn) v a
pattern Ref' :: Reference -> Term (F typeVar typeAnn patternAnn) v a
pattern TermLink' :: Referent -> Term (F typeVar typeAnn patternAnn) v a
pattern TypeLink' :: Reference -> Term (F typeVar typeAnn patternAnn) v a
pattern Builtin' :: Text -> Term (F typeVar typeAnn patternAnn) v a
pattern App' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Match' :: Term (F typeVar typeAnn patternAnn) v a -> [MatchCase patternAnn (Term (F typeVar typeAnn patternAnn) v a)] -> Term (F typeVar typeAnn patternAnn) v a
pattern Constructor' :: ConstructorReference -> Term (F typeVar typeAnn patternAnn) v a
pattern Request' :: ConstructorReference -> Term (F typeVar typeAnn patternAnn) v a
pattern RequestOrCtor' :: ConstructorReference -> Term2 vt at ap v a
pattern If' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern And' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Or' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Handle' :: Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Apps' :: Term2 vt at ap v a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
pattern Ands' :: [Term2 vt at ap v a] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern Ors' :: [Term2 vt at ap v a] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern AppsPred' :: Term2 vt at ap v a -> [Term2 vt at ap v a] -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern BinaryApp' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern BinaryApps' :: [(Term2 vt at ap v a, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern BinaryAppsPred' :: [(Term2 vt at ap v a, Term2 vt at ap v a)] -> Term2 vt at ap v a -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern BinaryAppPred' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern OverappliedBinaryAppPred' :: Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> [Term2 vt at ap v a] -> (Term2 vt at ap v a, Term2 vt at ap v a -> Bool)
pattern Ann' :: Term (F typeVar typeAnn patternAnn) v a -> Type typeVar typeAnn -> Term (F typeVar typeAnn patternAnn) v a
pattern List' :: Seq (Term (F typeVar typeAnn patternAnn) v a) -> Term (F typeVar typeAnn patternAnn) v a
pattern Lam' :: Var v => Subst (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Delay' :: Var v => Term2 vt at ap v a -> Term2 vt at ap v a
unDelay :: Var v => Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
pattern LamNamed' :: v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern LamsNamed' :: [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LamsNamedOpt' :: [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LamsNamedPred' :: [v] -> Term2 vt at ap v a -> (Term2 vt at ap v a, v -> Bool)
pattern LamsNamedOrDelay' :: Var v => [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern Let1' :: Var v => Term' vt v a -> Subst (F vt a a) v a -> Term' vt v a
pattern Let1Top' :: Var v => IsTop -> Term' vt v a -> Subst (F vt a a) v a -> Term' vt v a
pattern Let1Named' :: v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Let1NamedTop' :: IsTop -> v -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a -> Term (F typeVar typeAnn patternAnn) v a
pattern Lets' :: [(IsTop, v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRecNamed' :: [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRecNamedTop' :: IsTop -> [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
pattern LetRec' :: (Monad m, Var v) => ((v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a)) -> Term2 vt at ap v a
pattern LetRecTop' :: (Monad m, Var v) => IsTop -> ((v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a)) -> Term2 vt at ap v a
pattern LetRecNamedAnnotated' :: a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a
pattern LetRecNamedAnnotatedTop' :: IsTop -> a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a
fresh :: Var v => Term0 v -> v -> v
var :: a -> v -> Term2 vt at ap v a
var' :: Var v => Text -> Term0' vt v
ref :: Ord v => a -> Reference -> Term2 vt at ap v a
pattern Referent' :: Referent -> Term2 vt at ap v a
unReferent :: Term2 vt at ap v a -> Maybe Referent
refId :: Ord v => a -> Id -> Term2 vt at ap v a
termLink :: Ord v => a -> Referent -> Term2 vt at ap v a
typeLink :: Ord v => a -> Reference -> Term2 vt at ap v a
builtin :: Ord v => a -> Text -> Term2 vt at ap v a
float :: Ord v => a -> Double -> Term2 vt at ap v a
boolean :: Ord v => a -> Bool -> Term2 vt at ap v a
int :: Ord v => a -> Int64 -> Term2 vt at ap v a
nat :: Ord v => a -> Word64 -> Term2 vt at ap v a
text :: Ord v => a -> Text -> Term2 vt at ap v a
char :: Ord v => a -> Char -> Term2 vt at ap v a
watch :: (Var v, Semigroup a) => a -> String -> Term v a -> Term v a
watchMaybe :: (Var v, Semigroup a) => Maybe String -> Term v a -> Term v a
blank :: Ord v => a -> Term2 vt at ap v a
placeholder :: Ord v => a -> String -> Term2 vt a ap v a
resolve :: Ord v => at -> ab -> String -> Term2 vt ab ap v at
missingResult :: Ord v => at -> ab -> Term2 vt ab ap v at
constructor :: Ord v => a -> ConstructorReference -> Term2 vt at ap v a
request :: Ord v => a -> ConstructorReference -> Term2 vt at ap v a
app_ :: Ord v => Term0' vt v -> Term0' vt v -> Term0' vt v
app :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
match :: Ord v => a -> Term2 vt at a v a -> [MatchCase a (Term2 vt at a v a)] -> Term2 vt at a v a
handle :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
and :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
or :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
list :: Ord v => a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
list' :: Ord v => a -> Seq (Term2 vt at ap v a) -> Term2 vt at ap v a
apps :: Ord v => Term2 vt at ap v a -> [(a, Term2 vt at ap v a)] -> Term2 vt at ap v a
apps' :: (Ord v, Semigroup a) => Term2 vt at ap v a -> [Term2 vt at ap v a] -> Term2 vt at ap v a
iff :: Ord v => a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a -> Term2 vt at ap v a
ann_ :: Ord v => Term0' vt v -> Type vt () -> Term0' vt v
ann :: Ord v => a -> Term2 vt at ap v a -> Type vt at -> Term2 vt at ap v a

-- | Add a lambda with a single argument.
lam :: Ord v => a -> (a, v) -> Term2 vt at ap v a -> Term2 vt at ap v a

-- | Add a lambda with a list of arguments.
lam' :: Ord v => a -> [(a, v)] -> Term2 vt at ap v a -> Term2 vt at ap v a

-- | Only use this variant if you don't have source annotations for the
--   binding arguments available.
lamWithoutBindingAnns :: Ord v => a -> [v] -> Term2 vt at ap v a -> Term2 vt at ap v a
delay :: Var v => a -> Term2 vt at ap v a -> Term2 vt at ap v a
isLam :: Term2 vt at ap v a -> Bool
arity :: Term2 vt at ap v a -> Int
unLetRecNamedAnnotated :: Term' vt v a -> Maybe (IsTop, a, [((a, v), Term' vt v a)], Term' vt v a)
letRec' :: (Ord v, Monoid a) => Bool -> [(v, a, Term' vt v a)] -> Term' vt v a -> Term' vt v a
consLetRec :: (Ord v, Semigroup a) => Bool -> a -> (a, v, Term' vt v a) -> Term' vt v a -> Term' vt v a
letRec :: forall v vt a. Ord v => Bool -> a -> [((a, v), Term' vt v a)] -> Term' vt v a -> Term' vt v a

-- | Smart constructor for let rec blocks. Each binding in the block may
--   reference any other binding in the block in its body (including
--   itself), and the output expression may also reference any binding in
--   the block.
letRec_ :: Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v

-- | Smart constructor for let blocks. Each binding in the block may
--   reference only previous bindings in the block, not including itself.
--   The output expression may reference any binding in the block. todo:
--   delete me
let1_ :: Ord v => IsTop -> [(v, Term0' vt v)] -> Term0' vt v -> Term0' vt v

-- | annotations are applied to each nested Let expression
let1 :: (Ord v, Semigroup a) => IsTop -> [((a, v), Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a
let1' :: (Semigroup a, Ord v) => IsTop -> [(v, Term2 vt at ap v a)] -> Term2 vt at ap v a -> Term2 vt at ap v a

-- | Like <a>let1</a>, but for a single binding, avoiding the Semigroup
--   constraint.
singleLet :: Ord v => IsTop -> a -> a -> (v, Term2 vt at ap v a) -> Term2 vt at ap v a -> Term2 vt at ap v a
unLet1 :: Var v => Term' vt v a -> Maybe (IsTop, Term' vt v a, Subst (F vt a a) v a)

-- | Satisfies `unLet (let' bs e) == Just (bs, e)`
unLet :: Term2 vt at ap v a -> Maybe ([(IsTop, v, Term2 vt at ap v a)], Term2 vt at ap v a)

-- | Satisfies `unLetRec (letRec bs e) == Just (bs, e)`
unLetRecNamed :: Term2 vt at ap v a -> Maybe (IsTop, [(v, Term2 vt at ap v a)], Term2 vt at ap v a)
unLetRec :: (Monad m, Var v) => Term2 vt at ap v a -> Maybe (IsTop, (v -> m v) -> m ([(v, Term2 vt at ap v a)], Term2 vt at ap v a))
unAnds :: Term2 vt at ap v a -> Maybe ([Term2 vt at ap v a], Term2 vt at ap v a)
unOrs :: Term2 vt at ap v a -> Maybe ([Term2 vt at ap v a], Term2 vt at ap v a)
unApps :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, [Term2 vt at ap v a])
unAppsPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe (Term2 vt at ap v a, [Term2 vt at ap v a])
unBinaryApp :: Term2 vt at ap v a -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a, Term2 vt at ap v a)
unOverappliedBinaryAppPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a, Term2 vt at ap v a, [Term2 vt at ap v a])
unBinaryApps :: Term2 vt at ap v a -> Maybe ([(Term2 vt at ap v a, Term2 vt at ap v a)], Term2 vt at ap v a)
unBinaryAppsPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe ([(Term2 vt at ap v a, Term2 vt at ap v a)], Term2 vt at ap v a)
unBinaryAppPred :: (Term2 vt at ap v a, Term2 vt at ap v a -> Bool) -> Maybe (Term2 vt at ap v a, Term2 vt at ap v a, Term2 vt at ap v a)
unLams' :: Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsOpt' :: Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsUntilDelay' :: Var v => Term2 vt at ap v a -> Maybe ([v], Term2 vt at ap v a)
unLamsPred' :: (Term2 vt at ap v a, v -> Bool) -> Maybe ([v], Term2 vt at ap v a)
unReqOrCtor :: Term2 vt at ap v a -> Maybe ConstructorReference
dependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> DefnsF Set TermReference TypeReference
termDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set TermReference
typeDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
constructorDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set Reference
generalizedDependencies :: (Ord v, Ord vt, Ord r) => (Reference -> r) -> (Reference -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> (Reference -> ConstructorId -> r) -> (Reference -> r) -> Term2 vt at ap v a -> Set r
labeledDependencies :: (Ord v, Ord vt) => Term2 vt at ap v a -> Set LabeledDependency
updateDependencies :: Ord v => Map Referent Referent -> Map Reference Reference -> Term v a -> Term v a

-- | If the outermost term is a function application, perform substitution
--   of the argument into the body
betaReduce :: Var v => Term0 v -> Term0 v
betaNormalForm :: Var v => Term0 v -> Term0 v
etaNormalForm :: Ord v => Term0 v -> Term0 v
etaReduceEtaVars :: Var v => Term0 v -> Term0 v
unhashComponent :: forall v a. Var v => Map Id (Term v a) -> Map Id (v, Term v a)
fromReferent :: Ord v => a -> Referent -> Term2 vt at ap v a
containsExpression :: (Var v, Var typeVar, Eq typeAnn) => Term2 typeVar typeAnn loc v a -> Term2 typeVar typeAnn loc v a -> Bool
containsCaseTerm :: Var v1 => Term2 tv ta tb v1 loc -> Term2 typeVar typeAnn loc v2 a -> Maybe Bool
containsCase :: Pattern loc -> Term2 typeVar typeAnn loc v a -> Bool
containsSignature :: (Ord v, Var vt, Show vt) => Type vt at -> Term2 vt at ap v a -> Bool
rewriteSignatures :: (Ord v, Var vt, Show vt) => Type vt at -> Type vt at -> Term2 vt at ap v a -> Maybe (Term2 vt at ap v a)
rewriteCasesLHS :: forall v typeVar typeAnn a. (Var v, Var typeVar, Ord v, Show typeVar, Eq typeAnn, Semigroup a) => Term2 typeVar typeAnn a v a -> Term2 typeVar typeAnn a v a -> Term2 typeVar typeAnn a v a -> Maybe (Term2 typeVar typeAnn a v a)
toPattern :: Var v => Term2 tv ta tb v loc -> Maybe (Pattern loc)
matchCaseFromTerm :: Var v => Term2 typeVar typeAnn a v a -> Maybe (MatchCase a (Term2 typeVar typeAnn a v a))
matchCaseToTerm :: (Semigroup a, Ord v) => MatchCase a (Term2 typeVar typeAnn a v a) -> Term2 typeVar typeAnn a v a
instance Data.Traversable.Traversable (Unison.Term.MatchCase loc)
instance GHC.Generics.Generic1 (Unison.Term.MatchCase loc)
instance GHC.Generics.Generic (Unison.Term.MatchCase loc a)
instance GHC.Base.Functor (Unison.Term.MatchCase loc)
instance Data.Foldable.Foldable (Unison.Term.MatchCase loc)
instance (GHC.Classes.Ord loc, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Term.MatchCase loc a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Term.MatchCase loc a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.Term.MatchCase loc a)
instance Data.Traversable.Traversable (Unison.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic1 (Unison.Term.F typeVar typeAnn patternAnn)
instance GHC.Generics.Generic (Unison.Term.F typeVar typeAnn patternAnn a)
instance GHC.Base.Functor (Unison.Term.F typeVar typeAnn patternAnn)
instance Data.Foldable.Foldable (Unison.Term.F typeVar typeAnn patternAnn)
instance (U.Core.ABT.Var.Var typeVar, GHC.Classes.Ord typeAnn, GHC.Classes.Ord a, GHC.Classes.Ord patternAnn) => GHC.Classes.Ord (Unison.Term.F typeVar typeAnn patternAnn a)
instance (U.Core.ABT.Var.Var vt, GHC.Classes.Eq at, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Term.F vt at p a)
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Term.F v a0 p a)

module Unison.Symbol
data Symbol
Symbol :: !Word64 -> Type -> Symbol
symbol :: Text -> Symbol
instance GHC.Generics.Generic Unison.Symbol.Symbol
instance U.Core.ABT.Var.Var Unison.Symbol.Symbol
instance Unison.Var.Var Unison.Symbol.Symbol
instance GHC.Classes.Eq Unison.Symbol.Symbol
instance GHC.Classes.Ord Unison.Symbol.Symbol
instance GHC.Show.Show Unison.Symbol.Symbol


-- | This module contains various utilities related to the implementation
--   of record types.
module Unison.DataDeclaration.Records
generateRecordAccessors :: (Semigroup a, Var v) => (NonEmpty v -> v) -> (a -> a) -> [(v, a)] -> v -> TypeReference -> [(v, a, Term v a)]

module Unison.DataDeclaration
data DataDeclaration v a
DataDeclaration :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
[$sel:modifier:DataDeclaration] :: DataDeclaration v a -> Modifier
[$sel:annotation:DataDeclaration] :: DataDeclaration v a -> a
[$sel:bound:DataDeclaration] :: DataDeclaration v a -> [v]
[$sel:constructors':DataDeclaration] :: DataDeclaration v a -> [(a, v, Type v a)]
newtype EffectDeclaration v a
EffectDeclaration :: DataDeclaration v a -> EffectDeclaration v a
[$sel:toDataDecl:EffectDeclaration] :: EffectDeclaration v a -> DataDeclaration v a
type Decl v a = Either (EffectDeclaration v a) (DataDeclaration v a)
data DeclOrBuiltin v a
Builtin :: ConstructorType -> DeclOrBuiltin v a
Decl :: Decl v a -> DeclOrBuiltin v a
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier

-- | All variables mentioned in the given data declaration. Includes both
--   term and type variables, both free and bound.
allVars :: Ord v => DataDeclaration v a -> Set v
asDataDecl :: Decl v a -> DataDeclaration v a
bindReferences :: Var v => (v -> Name) -> Set v -> Map Name Reference -> DataDeclaration v a -> ResolutionResult a (DataDeclaration v a)
constructorCount :: DataDeclaration v a -> Int
constructorNames :: Var v => DataDeclaration v a -> [Text]
constructors :: DataDeclaration v a -> [(v, Type v a)]
constructorType :: Decl v a -> ConstructorType
constructorTypes :: DataDeclaration v a -> [Type v a]
constructorVars :: DataDeclaration v a -> [v]

-- | The constructor ids for the given data declaration.
constructorIds :: DataDeclaration v a -> [ConstructorId]
declConstructorReferents :: TypeReferenceId -> Decl v a -> [Id]
declTypeDependencies :: Ord v => Decl v a -> Set Reference
labeledDeclTypeDependencies :: Ord v => Decl v a -> Set LabeledDependency

-- | Compute the dependencies of a data declaration, including the type
--   itself and references for each of its constructors.
--   
--   NOTE: You may prefer
--   labeledDeclDependenciesIncludingSelfAndFieldAccessors in
--   Unison.DataDeclaration.Dependencies, it also includes Referents for
--   accessors of record fields.
labeledDeclDependenciesIncludingSelf :: Ord v => TypeReference -> Decl v a -> Set LabeledDependency
declFields :: Var v => Decl v a -> Either [Int] [Int]

-- | All references to types mentioned in the given data declaration's
--   fields/constructors Note: Does not include references to the
--   constructors or the decl itself (unless the decl is self-referential)
--   Note: Does NOT include the referents for fields and field accessors.
--   Those must be computed separately because we need access to the
--   typechecker to do so.
typeDependencies :: Ord v => DataDeclaration v a -> Set TypeReference
labeledTypeDependencies :: Ord v => DataDeclaration v a -> Set LabeledDependency

-- | This converts <a>Reference</a>s it finds that are in the input
--   <a>Map</a> back to free variables.
--   
--   In the result map, any of the references inside the Decls which are
--   keys of the input map; have been replaced with the corresponding
--   output <tt>v</tt>s in the output <a>Decl</a>s, which are fresh with
--   respect to all input Decls.
unhashComponent :: forall v a. Var v => Map Id (Decl v a) -> Map Id (v, Decl v a)
mkDataDecl' :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> DataDeclaration v a
mkEffectDecl' :: Modifier -> a -> [v] -> [(a, v, Type v a)] -> EffectDeclaration v a
typeOfConstructor :: DataDeclaration v a -> ConstructorId -> Maybe (Type v a)
withEffectDeclM :: Functor f => (DataDeclaration v a -> f (DataDeclaration v' a')) -> EffectDeclaration v a -> f (EffectDeclaration v' a')
amap :: (a -> a2) -> Decl v a -> Decl v a2
updateDependencies :: Ord v => Map Reference Reference -> Decl v a -> Decl v a
constructors_ :: Lens' (DataDeclaration v a) [(a, v, Type v a)]
asDataDecl_ :: Iso' (EffectDeclaration v a) (DataDeclaration v a)
declAsDataDecl_ :: Lens' (Decl v a) (DataDeclaration v a)

-- | Overwrite the constructor names with the given list, given in
--   canonical order, which is assumed to be of the correct length.
--   
--   Presumably this is called because the decl was loaded from the
--   database outside of the context of a namespace, since it's not stored
--   with names there, so we had plugged in dummy names like
--   <a>Constructor1</a>, <a>Constructor2</a>, ...
--   
--   Then, at some point, we discover the constructors' names in a
--   namespace, and now we'd like to combine the two together to get a Decl
--   structure in memory with good/correct names for constructors.
setConstructorNames :: [v] -> Decl v a -> Decl v a
instance GHC.Show.Show Unison.DataDeclaration.Modifier
instance GHC.Classes.Ord Unison.DataDeclaration.Modifier
instance GHC.Classes.Eq Unison.DataDeclaration.Modifier
instance GHC.Generics.Generic (Unison.DataDeclaration.DataDeclaration v a)
instance GHC.Base.Functor (Unison.DataDeclaration.DataDeclaration v)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.DataDeclaration v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.DataDeclaration.DataDeclaration v a)
instance (GHC.Classes.Eq a, U.Core.ABT.Var.Var v) => GHC.Classes.Eq (Unison.DataDeclaration.DataDeclaration v a)
instance GHC.Base.Functor (Unison.DataDeclaration.EffectDeclaration v)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.EffectDeclaration v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.DataDeclaration.EffectDeclaration v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.DataDeclaration.EffectDeclaration v a)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.DataDeclaration.DeclOrBuiltin v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.DataDeclaration.DeclOrBuiltin v a)
instance (U.Core.ABT.Var.Var v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.DataDeclaration.DeclOrBuiltin v a)
instance GHC.Show.Show a => GHC.Show.Show (Unison.DataDeclaration.F a)
instance Data.Foldable.Foldable Unison.DataDeclaration.F
instance GHC.Base.Functor Unison.DataDeclaration.F

module Unison.DataDeclaration.Names
bindNames :: Var v => (v -> Name) -> (Name -> v) -> Set v -> Names -> DataDeclaration v a -> ResolutionResult a (DataDeclaration v a)
dataDeclToNames' :: Var v => (v -> Name) -> (v, (Id, DataDeclaration v a)) -> Names
effectDeclToNames' :: Var v => (v -> Name) -> (v, (Id, EffectDeclaration v a)) -> Names
