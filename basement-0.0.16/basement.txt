-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Foundation scrap box of array & string
--   
--   Foundation most basic primitives without any dependencies
@package basement
@version 0.0.16


-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <tt>Functor</tt>, a type constructor such as <tt>Either</tt> does not
--   need to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <tt>Left</tt>
--   value or the <tt>Right</tt> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
module Basement.Compat.Bifunctor

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class forall a. () => Functor p a => Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c


-- | Literal support for Integral and Fractional {-# LANGUAGE
--   TypeSynonymInstances #-} {-# LANGUAGE FlexibleInstances #-}
module Basement.Compat.C.Types

-- | Haskell type representing the C <tt>char</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CChar
CChar :: Int8 -> CChar

-- | Haskell type representing the C <tt>signed char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CSChar
CSChar :: Int8 -> CSChar

-- | Haskell type representing the C <tt>unsigned char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CUChar
CUChar :: Word8 -> CUChar

-- | Haskell type representing the C <tt>short</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CShort
CShort :: Int16 -> CShort

-- | Haskell type representing the C <tt>unsigned short</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CUShort
CUShort :: Word16 -> CUShort

-- | Haskell type representing the C <tt>int</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CInt
CInt :: Int32 -> CInt

-- | Haskell type representing the C <tt>unsigned int</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CUInt
CUInt :: Word32 -> CUInt

-- | Haskell type representing the C <tt>long</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CLong
CLong :: Int64 -> CLong

-- | Haskell type representing the C <tt>unsigned long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CULong
CULong :: Word64 -> CULong

-- | Haskell type representing the C <tt>ptrdiff_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff

-- | Haskell type representing the C <tt>size_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CSize
CSize :: Word64 -> CSize

-- | Haskell type representing the C <tt>wchar_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CWchar
CWchar :: Int32 -> CWchar

-- | Haskell type representing the C <tt>sig_atomic_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i> See Note [Lack of signals on wasm32-wasi].
newtype () => CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic

-- | Haskell type representing the C <tt>long long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CLLong
CLLong :: Int64 -> CLLong

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
--   <i>(The concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CULLong
CULLong :: Word64 -> CULLong

-- | Haskell type representing the C <tt>bool</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CBool
CBool :: Word8 -> CBool
newtype () => CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype () => CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype () => CIntMax
CIntMax :: Int64 -> CIntMax
newtype () => CUIntMax
CUIntMax :: Word64 -> CUIntMax

-- | Haskell type representing the C <tt>clock_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CClock
CClock :: Int64 -> CClock

-- | Haskell type representing the C <tt>time_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CTime
CTime :: Int64 -> CTime

-- | Haskell type representing the C <tt>useconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CUSeconds
CUSeconds :: Word32 -> CUSeconds

-- | Haskell type representing the C <tt>suseconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype () => CSUSeconds
CSUSeconds :: Int64 -> CSUSeconds

-- | Haskell type representing the C <tt>float</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype () => CFloat
CFloat :: Float -> CFloat

-- | Haskell type representing the C <tt>double</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
data () => CDouble
newtype () => COff
COff :: Int64 -> COff
newtype () => CMode
CMode :: Word32 -> CMode

module Basement.Compat.CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack


-- | Identity re-export, with a compat wrapper for older version of base
--   that do not have Data.Functor.Identity
module Basement.Compat.Identity

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a


-- | compat friendly version of IsList
module Basement.Compat.IsList

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class () => IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type family Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

module Basement.Compat.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural
integerToNatural :: Integer -> Natural
naturalToInteger :: Natural -> Integer


-- | Literal support for Integral and Fractional
module Basement.Compat.NumLiteral

-- | Integral Literal support
--   
--   e.g. 123 :: Integer 123 :: Word8
class Integral a
fromInteger :: Integral a => Integer -> a

-- | Fractional Literal support
--   
--   e.g. 1.2 :: Double 0.03 :: Float
class Fractional a
fromRational :: Fractional a => Rational -> a

-- | Negation support
--   
--   e.g. -(f x)
class HasNegation a
negate :: HasNegation a => a -> a
instance Basement.Compat.NumLiteral.HasNegation GHC.Num.Integer.Integer
instance Basement.Compat.NumLiteral.HasNegation GHC.Types.Int
instance Basement.Compat.NumLiteral.HasNegation GHC.Int.Int8
instance Basement.Compat.NumLiteral.HasNegation GHC.Int.Int16
instance Basement.Compat.NumLiteral.HasNegation GHC.Int.Int32
instance Basement.Compat.NumLiteral.HasNegation GHC.Int.Int64
instance Basement.Compat.NumLiteral.HasNegation GHC.Types.Word
instance Basement.Compat.NumLiteral.HasNegation GHC.Word.Word8
instance Basement.Compat.NumLiteral.HasNegation GHC.Word.Word16
instance Basement.Compat.NumLiteral.HasNegation GHC.Word.Word32
instance Basement.Compat.NumLiteral.HasNegation GHC.Word.Word64
instance Basement.Compat.NumLiteral.HasNegation GHC.Types.Float
instance Basement.Compat.NumLiteral.HasNegation GHC.Types.Double
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CChar
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CSChar
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CShort
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CInt
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CLong
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CPtrdiff
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CWchar
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CLLong
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CIntMax
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CFloat
instance Basement.Compat.NumLiteral.HasNegation Foreign.C.Types.CDouble
instance Basement.Compat.NumLiteral.Fractional GHC.Real.Rational
instance Basement.Compat.NumLiteral.Fractional GHC.Types.Float
instance Basement.Compat.NumLiteral.Fractional GHC.Types.Double
instance Basement.Compat.NumLiteral.Fractional Foreign.C.Types.CFloat
instance Basement.Compat.NumLiteral.Fractional Foreign.C.Types.CDouble
instance Basement.Compat.NumLiteral.Integral GHC.Num.Integer.Integer
instance Basement.Compat.NumLiteral.Integral GHC.Num.Natural.Natural
instance Basement.Compat.NumLiteral.Integral GHC.Types.Int
instance Basement.Compat.NumLiteral.Integral GHC.Types.Word
instance Basement.Compat.NumLiteral.Integral GHC.Word.Word8
instance Basement.Compat.NumLiteral.Integral GHC.Word.Word16
instance Basement.Compat.NumLiteral.Integral GHC.Word.Word32
instance Basement.Compat.NumLiteral.Integral GHC.Word.Word64
instance Basement.Compat.NumLiteral.Integral GHC.Int.Int8
instance Basement.Compat.NumLiteral.Integral GHC.Int.Int16
instance Basement.Compat.NumLiteral.Integral GHC.Int.Int32
instance Basement.Compat.NumLiteral.Integral GHC.Int.Int64
instance Basement.Compat.NumLiteral.Integral Foreign.Ptr.IntPtr
instance Basement.Compat.NumLiteral.Integral GHC.Types.Float
instance Basement.Compat.NumLiteral.Integral GHC.Types.Double
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CChar
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CSChar
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUChar
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CShort
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUShort
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CInt
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUInt
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CLong
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CULong
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CPtrdiff
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CSize
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CWchar
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CSigAtomic
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CLLong
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CULLong
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CBool
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CIntPtr
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUIntPtr
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CIntMax
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUIntMax
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CClock
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CTime
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CUSeconds
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CSUSeconds
instance Basement.Compat.NumLiteral.Integral System.Posix.Types.COff
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CFloat
instance Basement.Compat.NumLiteral.Integral Foreign.C.Types.CDouble


module Basement.Compat.PrimTypes

-- | File size in bytes
type FileSize# = Word64#

-- | Offset in a bytearray, string, type alias
--   
--   for code documentation purpose only, just a simple type alias on Int#
type Offset# = Int#

-- | CountOf in bytes type alias
--   
--   for code documentation purpose only, just a simple type alias on Int#
type CountOf# = Int#

-- | Lowlevel Boolean
type Bool# = Int#

-- | Pinning status
type Pinned# = Bool#


module Basement.Compat.Primitive

-- | turn an Int# into a Bool
bool# :: Int# -> Bool

-- | Flag record whether a specific byte array is pinned or not
data PinnedStatus
Pinned :: PinnedStatus
Unpinned :: PinnedStatus
toPinnedStatus# :: Pinned# -> PinnedStatus

-- | A mkWeak# version that keep working on 8.0
--   
--   signature change in ghc-prim: * 0.4: mkWeak# :: o -&gt; b -&gt; c
--   -&gt; State# RealWorld -&gt; ( RealWorld, Weak# b#) * 0.5 :mkWeak# ::
--   o -&gt; b -&gt; (State# RealWorld -&gt; ( RealWorld, c#)) -&gt; State#
--   RealWorld -&gt; ( RealWorld, Weak# b#)
compatMkWeak# :: o -> b -> IO () -> State# RealWorld -> (# State# RealWorld, Weak# b #)
compatIsByteArrayPinned# :: ByteArray# -> Pinned#
compatIsMutableByteArrayPinned# :: MutableByteArray# s -> Pinned#

-- | Highly, terribly dangerous coercion from one representation type to
--   another. Misuse of this function can invite the garbage collector to
--   trounce upon your data and then laugh in your face. You don't want
--   this function. Really.
unsafeCoerce# :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). a -> b

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word
W# :: Word# -> Word
data Word8# :: TYPE 'Word8Rep
data Word16# :: TYPE 'Word16Rep
data Word32# :: TYPE 'Word32Rep
data Int8# :: TYPE 'Int8Rep
data Int16# :: TYPE 'Int16Rep
data Int32# :: TYPE 'Int32Rep
word8ToWord16# :: Word8# -> Word16#
word8ToWord32# :: Word8# -> Word32#
word8ToWord# :: Word8# -> Word#
word16ToWord8# :: Word16# -> Word8#
word16ToWord32# :: Word16# -> Word32#
word16ToWord# :: Word16# -> Word#
word32ToWord# :: Word32# -> Word#
word32ToWord8# :: Word32# -> Word8#
word32ToWord16# :: Word32# -> Word16#
wordToWord32# :: Word# -> Word32#
wordToWord16# :: Word# -> Word16#
wordToWord8# :: Word# -> Word8#
int8ToInt16# :: Int8# -> Int16#
int8ToInt32# :: Int8# -> Int32#
int8ToInt# :: Int8# -> Int#
int16ToInt32# :: Int16# -> Int32#
int16ToInt# :: Int16# -> Int#
int32ToInt# :: Int32# -> Int#
intToInt8# :: Int# -> Int8#
intToInt16# :: Int# -> Int16#
intToInt32# :: Int# -> Int32#
word8ToInt# :: Word8# -> Int#
word8ToInt16# :: Word8# -> Int16#
word8ToInt32# :: Word8# -> Int32#
charToWord32# :: Char# -> Word32#
word8ToChar# :: Word8# -> Char#
word16ToChar# :: Word16# -> Char#
word32ToChar# :: Word32# -> Char#
wordToChar# :: Word# -> Char#
plusWord8# :: Word8# -> Word8# -> Word8#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
plusInt8# :: Int8# -> Int8# -> Int8#
plusInt16# :: Int16# -> Int16# -> Int16#
plusInt32# :: Int32# -> Int32# -> Int32#
instance GHC.Classes.Eq Basement.Compat.Primitive.PinnedStatus

module Basement.Compat.Semigroup

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>
type ListNonEmpty = NonEmpty


-- | conveniently provide support for legacy and modern base
module Basement.Compat.Typeable

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)


-- | internal re-export of all the good base bits
module Basement.Compat.Base

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | morphism composition
(.) :: forall (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | the identity morphism
id :: forall (a :: k). Category cat => cat a a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class () => Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class () => Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class () => Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
data () => Bool
False :: Bool
True :: Bool

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | Integral Literal support
--   
--   e.g. 123 :: Integer 123 :: Word8
class Integral a
fromInteger :: Integral a => Integer -> a

-- | Fractional Literal support
--   
--   e.g. 1.2 :: Double 0.03 :: Float
class Fractional a
fromRational :: Fractional a => Rational -> a

-- | Negation support
--   
--   e.g. -(f x)
class HasNegation a
negate :: HasNegation a => a -> a

-- | 8-bit signed integer type
data () => Int8

-- | 16-bit signed integer type
data () => Int16

-- | 32-bit signed integer type
data () => Int32

-- | 64-bit signed integer type
data () => Int64

-- | 8-bit unsigned integer type
data () => Word8

-- | 16-bit unsigned integer type
data () => Word16

-- | 32-bit unsigned integer type
data () => Word32

-- | 64-bit unsigned integer type
data () => Word64

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class () => IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type family Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class () => IsString a
fromString :: IsString a => String -> a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type within generic folding is <tt>r -&gt;
--   r</tt>. So the result of folding is a function to which we finally
--   pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data () => DataType

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data () => Ptr a
Ptr :: Addr# -> Ptr a

-- | for support of if .. then .. else
ifThenElse :: Bool -> a -> a -> a

-- | Only to use internally for internal error cases
internalError :: [Char] -> a


-- | An internal and really simple monad transformers, without any bells
--   and whistse.
module Basement.Compat.MonadTrans

-- | Simple State monad
newtype State s m a
State :: (s -> m (a, s)) -> State s m a
[runState] :: State s m a -> s -> m (a, s)

-- | Simple Reader monad
newtype Reader r m a
Reader :: (r -> m a) -> Reader r m a
[runReader] :: Reader r m a -> r -> m a
instance GHC.Base.Monad m => GHC.Base.Functor (Basement.Compat.MonadTrans.Reader r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Basement.Compat.MonadTrans.Reader r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Basement.Compat.MonadTrans.Reader r m)
instance GHC.Base.Monad m => GHC.Base.Functor (Basement.Compat.MonadTrans.State s m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Basement.Compat.MonadTrans.State s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Basement.Compat.MonadTrans.State r m)

module Basement.Compat.AMP

-- | <i>Deprecated: use Monad</i>
type AMPMonad m = Monad m


-- | Set endianness tag to a given primitive. This will help for
--   serialising data for protocols (such as the network protocols).
module Basement.Endianness

-- | Class of types that can be byte-swapped.
--   
--   e.g. Word16, Word32, Word64
class ByteSwap a

-- | Big Endian value
newtype BE a
BE :: a -> BE a
[unBE] :: BE a -> a

-- | Convert a value in cpu endianess to big endian
toBE :: ByteSwap a => a -> BE a

-- | Convert from a big endian value to the cpu endianness
fromBE :: ByteSwap a => BE a -> a

-- | Little Endian value
newtype LE a
LE :: a -> LE a
[unLE] :: LE a -> a

-- | Convert a value in cpu endianess to little endian
toLE :: ByteSwap a => a -> LE a

-- | Convert from a little endian value to the cpu endianness
fromLE :: ByteSwap a => LE a -> a
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness

-- | endianness of the current architecture
endianness :: Endianness
instance GHC.Show.Show Basement.Endianness.Endianness
instance GHC.Classes.Eq Basement.Endianness.Endianness
instance GHC.Bits.Bits a => GHC.Bits.Bits (Basement.Endianness.LE a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.Endianness.LE a)
instance GHC.Show.Show a => GHC.Show.Show (Basement.Endianness.LE a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Basement.Endianness.BE a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.Endianness.BE a)
instance GHC.Show.Show a => GHC.Show.Show (Basement.Endianness.BE a)
instance (Basement.Endianness.ByteSwap a, GHC.Classes.Ord a) => GHC.Classes.Ord (Basement.Endianness.LE a)
instance (Basement.Endianness.ByteSwap a, GHC.Classes.Ord a) => GHC.Classes.Ord (Basement.Endianness.BE a)
instance Basement.Endianness.ByteSwap GHC.Word.Word16
instance Basement.Endianness.ByteSwap GHC.Word.Word32
instance Basement.Endianness.ByteSwap GHC.Word.Word64

module Basement.Floating
integerToDouble :: Integer -> Double
naturalToDouble :: Natural -> Double
doubleExponant :: Double -> Int -> Double
integerToFloat :: Integer -> Float
naturalToFloat :: Natural -> Float
wordToFloat :: Word32 -> Float
floatToWord :: Float -> Word32
wordToDouble :: Word64 -> Double
doubleToWord :: Double -> Word64


-- | Allow to run operation in ST and IO, without having to distinguinsh
--   between the two. Most operations exposes the bare nuts and bolts of
--   how IO and ST actually works, and relatively easy to shoot yourself in
--   the foot
--   
--   this is highly similar to the Control.Monad.Primitive in the primitive
--   package
module Basement.Monad

-- | Primitive monad that can handle mutation.
--   
--   For example: IO and ST.
class (Functor m, Applicative m, Monad m) => PrimMonad m where {
    
    -- | type of state token associated with the PrimMonad m
    type PrimState m;
    
    -- | type of variable associated with the PrimMonad m
    type PrimVar m :: * -> *;
}

-- | Unwrap the State# token to pass to a function a primitive function
--   that returns an unboxed state and a value.
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | Throw Exception in the primitive monad
primThrow :: (PrimMonad m, Exception e) => e -> m a

-- | Run a Prim monad from a dedicated state#
unPrimMonad :: PrimMonad m => m a -> State# (PrimState m) -> (# State# (PrimState m), a #)

-- | Build a new variable in the Prim Monad
primVarNew :: PrimMonad m => a -> m (PrimVar m a)

-- | Read the variable in the Prim Monad
primVarRead :: PrimMonad m => PrimVar m a -> m a

-- | Write the variable in the Prim Monad
primVarWrite :: PrimMonad m => PrimVar m a -> a -> m ()

-- | Monad that can represent failure
--   
--   Similar to MonadFail but with a parametrized Failure linked to the
--   Monad
class Monad m => MonadFailure m where {
    
    -- | The associated type with the MonadFailure, representing what failure
    --   can be encoded in this monad
    type Failure m;
}

-- | Raise a Failure through a monad.
mFail :: MonadFailure m => Failure m -> m ()

-- | just like <tt>unwrapPrimMonad</tt> but throw away the result and
--   return just the new State#
unPrimMonad_ :: PrimMonad m => m () -> State# (PrimState m) -> State# (PrimState m)

-- | Convert a prim monad to another prim monad.
--   
--   The net effect is that it coerce the state repr to another, so the
--   runtime representation should be the same, otherwise hilary ensues.
unsafePrimCast :: (PrimMonad m1, PrimMonad m2) => m1 a -> m2 a

-- | Convert any prim monad to an ST monad
unsafePrimToST :: PrimMonad prim => prim a -> ST s a

-- | Convert any prim monad to an IO monad
unsafePrimToIO :: PrimMonad prim => prim a -> IO a

-- | Convert any IO monad to a prim monad
unsafePrimFromIO :: PrimMonad prim => IO a -> prim a

-- | Touch primitive lifted to any prim monad
primTouch :: PrimMonad m => a -> m ()
instance Basement.Monad.MonadFailure GHC.Maybe.Maybe
instance Basement.Monad.MonadFailure (Data.Either.Either a)
instance Basement.Monad.PrimMonad GHC.Types.IO
instance Basement.Monad.PrimMonad (GHC.ST.ST s)


-- | A smaller ForeignPtr reimplementation that work in any prim monad.
--   
--   Here be dragon.
module Basement.FinalPtr

-- | Create a pointer with an associated finalizer
data FinalPtr a
FinalPtr :: Ptr a -> FinalPtr a
FinalForeign :: ForeignPtr a -> FinalPtr a

-- | Check if 2 final ptr points on the same memory bits
--   
--   it stand to reason that provided a final ptr that is still being
--   referenced and thus have the memory still valid, if 2 final ptrs have
--   the same address, they should be the same final ptr
finalPtrSameMemory :: FinalPtr a -> FinalPtr b -> Bool

-- | Cast a finalized pointer from type a to type b
castFinalPtr :: FinalPtr a -> FinalPtr b

-- | create a new FinalPtr from a Pointer
toFinalPtr :: PrimMonad prim => Ptr a -> (Ptr a -> IO ()) -> prim (FinalPtr a)

-- | Create a new FinalPtr from a ForeignPtr
toFinalPtrForeign :: ForeignPtr a -> FinalPtr a
touchFinalPtr :: PrimMonad prim => FinalPtr p -> prim ()

-- | Looks at the raw pointer inside a FinalPtr, making sure the data
--   pointed by the pointer is not finalized during the call to <tt>f</tt>
withFinalPtr :: PrimMonad prim => FinalPtr p -> (Ptr p -> prim a) -> prim a

-- | Unsafe version of <a>withFinalPtr</a>
withUnsafeFinalPtr :: PrimMonad prim => FinalPtr p -> (Ptr p -> prim a) -> a
withFinalPtrNoTouch :: FinalPtr p -> (Ptr p -> a) -> a
instance GHC.Show.Show (Basement.FinalPtr.FinalPtr a)
instance GHC.Classes.Eq (Basement.FinalPtr.FinalPtr a)
instance GHC.Classes.Ord (Basement.FinalPtr.FinalPtr a)

module Basement.Numerical.Number

-- | Number literals, convertible through the generic Integer type.
--   
--   all number are Enum'erable, meaning that you can move to next element
class (Integral a, Eq a, Ord a) => IsIntegral a
toInteger :: IsIntegral a => a -> Integer

-- | Non Negative Number literals, convertible through the generic Natural
--   type
class IsIntegral a => IsNatural a
toNatural :: IsNatural a => a -> Natural
instance Basement.Numerical.Number.IsNatural GHC.Num.Natural.Natural
instance Basement.Numerical.Number.IsNatural GHC.Types.Word
instance Basement.Numerical.Number.IsNatural GHC.Word.Word8
instance Basement.Numerical.Number.IsNatural GHC.Word.Word16
instance Basement.Numerical.Number.IsNatural GHC.Word.Word32
instance Basement.Numerical.Number.IsNatural GHC.Word.Word64
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CUChar
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CUShort
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CUInt
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CULong
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CSize
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CULLong
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Number.IsNatural Foreign.C.Types.CUIntMax
instance Basement.Numerical.Number.IsIntegral GHC.Num.Integer.Integer
instance Basement.Numerical.Number.IsIntegral GHC.Types.Int
instance Basement.Numerical.Number.IsIntegral GHC.Int.Int8
instance Basement.Numerical.Number.IsIntegral GHC.Int.Int16
instance Basement.Numerical.Number.IsIntegral GHC.Int.Int32
instance Basement.Numerical.Number.IsIntegral GHC.Int.Int64
instance Basement.Numerical.Number.IsIntegral GHC.Num.Natural.Natural
instance Basement.Numerical.Number.IsIntegral GHC.Types.Word
instance Basement.Numerical.Number.IsIntegral GHC.Word.Word8
instance Basement.Numerical.Number.IsIntegral GHC.Word.Word16
instance Basement.Numerical.Number.IsIntegral GHC.Word.Word32
instance Basement.Numerical.Number.IsIntegral GHC.Word.Word64
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CChar
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CSChar
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CUChar
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CShort
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CUShort
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CInt
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CUInt
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CLong
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CULong
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CPtrdiff
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CSize
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CWchar
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CSigAtomic
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CLLong
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CULLong
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CBool
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CIntPtr
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CIntMax
instance Basement.Numerical.Number.IsIntegral Foreign.C.Types.CUIntMax

module Basement.IntegralConv

-- | Downsize an integral value
class IntegralDownsize a b
integralDownsize :: IntegralDownsize a b => a -> b
integralDownsize :: (IntegralDownsize a b, a ~ b) => a -> b
integralDownsizeCheck :: IntegralDownsize a b => a -> Maybe b

-- | Upsize an integral value
--   
--   The destination type <tt>b</tt> size need to be greater or equal than
--   the size type of <tt>a</tt>
class IntegralUpsize a b
integralUpsize :: IntegralUpsize a b => a -> b
intToInt64 :: Int -> Int64
int64ToInt :: Int64 -> Int
wordToWord64 :: Word -> Word64
word64ToWord32s :: Word64 -> Word32x2

-- | 2 Word32s
data Word32x2
Word32x2 :: {-# UNPACK #-} !Word32 -> {-# UNPACK #-} !Word32 -> Word32x2
word64ToWord :: Word64 -> Word
wordToChar :: Word -> Char
wordToInt :: Word -> Int
charToInt :: Char -> Int
instance Basement.Numerical.Number.IsIntegral a => Basement.IntegralConv.IntegralUpsize a GHC.Num.Integer.Integer
instance Basement.Numerical.Number.IsNatural a => Basement.IntegralConv.IntegralUpsize a GHC.Num.Natural.Natural
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int8 GHC.Int.Int16
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int8 GHC.Int.Int32
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int8 GHC.Int.Int64
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int8 GHC.Types.Int
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int16 GHC.Int.Int32
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int16 GHC.Int.Int64
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int16 GHC.Types.Int
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int32 GHC.Int.Int64
instance Basement.IntegralConv.IntegralUpsize GHC.Int.Int32 GHC.Types.Int
instance Basement.IntegralConv.IntegralUpsize GHC.Types.Int GHC.Int.Int64
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Word.Word16
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Word.Word32
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Word.Word64
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Types.Word
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Int.Int16
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Int.Int32
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Int.Int64
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word8 GHC.Types.Int
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word16 GHC.Word.Word32
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word16 GHC.Word.Word64
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word16 GHC.Types.Word
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word32 GHC.Word.Word64
instance Basement.IntegralConv.IntegralUpsize GHC.Word.Word32 GHC.Types.Word
instance Basement.IntegralConv.IntegralUpsize GHC.Types.Word GHC.Word.Word64
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Int GHC.Int.Int8
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Int GHC.Int.Int16
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Int GHC.Int.Int32
instance Basement.IntegralConv.IntegralDownsize GHC.Int.Int64 GHC.Int.Int8
instance Basement.IntegralConv.IntegralDownsize GHC.Int.Int64 GHC.Int.Int16
instance Basement.IntegralConv.IntegralDownsize GHC.Int.Int64 GHC.Int.Int32
instance Basement.IntegralConv.IntegralDownsize GHC.Int.Int64 GHC.Types.Int
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word64 GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word64 GHC.Word.Word16
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word64 GHC.Word.Word32
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Word GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Word GHC.Word.Word16
instance Basement.IntegralConv.IntegralDownsize GHC.Types.Word GHC.Word.Word32
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word32 GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word32 GHC.Word.Word16
instance Basement.IntegralConv.IntegralDownsize GHC.Word.Word16 GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Int.Int8
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Int.Int16
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Int.Int32
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Int.Int64
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Word.Word16
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Word.Word32
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Word.Word64
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Integer.Integer GHC.Num.Natural.Natural
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Natural.Natural GHC.Word.Word8
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Natural.Natural GHC.Word.Word16
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Natural.Natural GHC.Word.Word32
instance Basement.IntegralConv.IntegralDownsize GHC.Num.Natural.Natural GHC.Word.Word64

module Basement.Types.Char7

-- | ASCII value between 0x0 and 0x7f
newtype Char7
Char7 :: Word8 -> Char7
[toByte] :: Char7 -> Word8

-- | Convert a <a>Char7</a> to a unicode code point <a>Char</a>
toChar :: Char7 -> Char

-- | Convert a <a>Char</a> to a <a>Char7</a> ignoring all higher bits
fromCharMask :: Char -> Char7

-- | Try to convert a <a>Char</a> to a <a>Char7</a>
--   
--   If the code point is non ascii, then Nothing is returned.
fromChar :: Char -> Maybe Char7

-- | Convert a <tt>Byte</tt> to a <a>Char7</a> ignoring the higher bit
fromByteMask :: Word8 -> Char7

-- | Try to convert <a>Word8</a> to a <a>Char7</a>
--   
--   If the byte got higher bit set, then Nothing is returned.
fromByte :: Word8 -> Maybe Char7
c7_LF :: Char7
c7_CR :: Char7
c7_minus :: Char7
c7_a :: Char7
c7_A :: Char7
c7_z :: Char7
c7_Z :: Char7
c7_0 :: Char7
c7_1 :: Char7
c7_2 :: Char7
c7_3 :: Char7
c7_4 :: Char7
c7_5 :: Char7
c7_6 :: Char7
c7_7 :: Char7
c7_8 :: Char7
c7_9 :: Char7
c7Upper :: Char7 -> Char7
c7Lower :: Char7 -> Char7
instance GHC.Classes.Ord Basement.Types.Char7.Char7
instance GHC.Classes.Eq Basement.Types.Char7.Char7
instance GHC.Show.Show Basement.Types.Char7.Char7

module Basement.Base16

-- | Convert a byte value in Word# to two Word#s containing the hexadecimal
--   representation of the Word#
--   
--   The output words# are guaranteed to be included in the 0 to 2^7-1
--   range
--   
--   Note that calling convertByte with a value greater than 256 will cause
--   segfault or other horrible effect. From GHC9.2, Word8# cannot be &gt;=
--   256.
unsafeConvertByte :: Word8# -> (# Word8#, Word8# #)

-- | hex word16
hexWord16 :: Word16 -> (Char, Char, Char, Char)

-- | hex word32
hexWord32 :: Word32 -> (Char, Char, Char, Char, Char, Char, Char, Char)
escapeByte :: Word8 -> Base16Escape
data Base16Escape
Base16Escape :: {-# UNPACK #-} !Char7 -> {-# UNPACK #-} !Char7 -> Base16Escape

module Basement.Types.Word128

-- | 128 bits Word
data Word128
Word128 :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Word128

-- | Add 2 Word128
(+) :: Word128 -> Word128 -> Word128

-- | Subtract 2 Word128
(-) :: Word128 -> Word128 -> Word128

-- | Multiplication
(*) :: Word128 -> Word128 -> Word128

-- | Division
quot :: Word128 -> Word128 -> Word128

-- | Modulo
rem :: Word128 -> Word128 -> Word128

-- | Bitwise and
bitwiseAnd :: Word128 -> Word128 -> Word128

-- | Bitwise or
bitwiseOr :: Word128 -> Word128 -> Word128

-- | Bitwise xor
bitwiseXor :: Word128 -> Word128 -> Word128

-- | Bitwise complement
complement :: Word128 -> Word128

-- | Bitwise Shift Left
shiftL :: Word128 -> Int -> Word128

-- | Bitwise Shift Right
shiftR :: Word128 -> Int -> Word128

-- | Bitwise rotate Left
rotateL :: Word128 -> Int -> Word128

-- | Bitwise rotate Left
rotateR :: Word128 -> Int -> Word128

-- | Population count
popCount :: Word128 -> Int
fromNatural :: Natural -> Word128
instance GHC.Classes.Eq Basement.Types.Word128.Word128
instance GHC.Show.Show Basement.Types.Word128.Word128
instance GHC.Enum.Enum Basement.Types.Word128.Word128
instance GHC.Enum.Bounded Basement.Types.Word128.Word128
instance GHC.Classes.Ord Basement.Types.Word128.Word128
instance Foreign.Storable.Storable Basement.Types.Word128.Word128
instance Basement.Compat.NumLiteral.Integral Basement.Types.Word128.Word128
instance Basement.Compat.NumLiteral.HasNegation Basement.Types.Word128.Word128
instance Basement.Numerical.Number.IsIntegral Basement.Types.Word128.Word128
instance Basement.Numerical.Number.IsNatural Basement.Types.Word128.Word128
instance GHC.Num.Num Basement.Types.Word128.Word128
instance GHC.Bits.Bits Basement.Types.Word128.Word128

module Basement.Types.Word256

-- | 256 bits Word
data Word256
Word256 :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Word256

-- | Add 2 Word256
(+) :: Word256 -> Word256 -> Word256

-- | Subtract 2 Word256
(-) :: Word256 -> Word256 -> Word256

-- | Multiplication
(*) :: Word256 -> Word256 -> Word256

-- | Division
quot :: Word256 -> Word256 -> Word256

-- | Modulo
rem :: Word256 -> Word256 -> Word256

-- | Bitwise and
bitwiseAnd :: Word256 -> Word256 -> Word256

-- | Bitwise or
bitwiseOr :: Word256 -> Word256 -> Word256

-- | Bitwise xor
bitwiseXor :: Word256 -> Word256 -> Word256

-- | Bitwise complement
complement :: Word256 -> Word256

-- | Bitwise Shift Left
shiftL :: Word256 -> Int -> Word256

-- | Bitwise Shift Right
shiftR :: Word256 -> Int -> Word256

-- | Bitwise rotate Left
rotateL :: Word256 -> Int -> Word256

-- | Bitwise rotate Left
rotateR :: Word256 -> Int -> Word256

-- | Population count
popCount :: Word256 -> Int
fromNatural :: Natural -> Word256
instance GHC.Classes.Eq Basement.Types.Word256.Word256
instance GHC.Show.Show Basement.Types.Word256.Word256
instance GHC.Enum.Enum Basement.Types.Word256.Word256
instance GHC.Enum.Bounded Basement.Types.Word256.Word256
instance GHC.Classes.Ord Basement.Types.Word256.Word256
instance Foreign.Storable.Storable Basement.Types.Word256.Word256
instance Basement.Compat.NumLiteral.Integral Basement.Types.Word256.Word256
instance Basement.Compat.NumLiteral.HasNegation Basement.Types.Word256.Word256
instance Basement.Numerical.Number.IsIntegral Basement.Types.Word256.Word256
instance Basement.Numerical.Number.IsNatural Basement.Types.Word256.Word256
instance GHC.Num.Num Basement.Types.Word256.Word256
instance GHC.Bits.Bits Basement.Types.Word256.Word256

module Basement.Nat

-- | A type synonym for <a>Natural</a>.
--   
--   Prevously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class () => KnownNat (n :: Nat)

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Integer

-- | Comparison (&lt;=) of comparable types, as a constraint.
type (x :: t) <= (y :: t) = Assert x <=? y LeErrMsg x y :: Constraint
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type (m :: k) <=? (n :: k) = OrdCond Compare m n 'True 'True 'False
infix 4 <=?

-- | Addition of type-level naturals.
type family (a :: Natural) + (b :: Natural) :: Natural
infixl 6 +

-- | Multiplication of type-level naturals.
type family (a :: Natural) * (b :: Natural) :: Natural
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (a :: Natural) ^ (b :: Natural) :: Natural
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (a :: Natural) - (b :: Natural) :: Natural
infixl 6 -

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Natural) (b :: Natural) :: Ordering
natValNatural :: forall n proxy. KnownNat n => proxy n -> Natural
natValInt :: forall n proxy. (KnownNat n, NatWithinBound Int n) => proxy n -> Int
natValInt8 :: forall n proxy. (KnownNat n, NatWithinBound Int8 n) => proxy n -> Int8
natValInt16 :: forall n proxy. (KnownNat n, NatWithinBound Int16 n) => proxy n -> Int16
natValInt32 :: forall n proxy. (KnownNat n, NatWithinBound Int32 n) => proxy n -> Int32
natValInt64 :: forall n proxy. (KnownNat n, NatWithinBound Int64 n) => proxy n -> Int64
natValWord :: forall n proxy. (KnownNat n, NatWithinBound Word n) => proxy n -> Word
natValWord8 :: forall n proxy. (KnownNat n, NatWithinBound Word8 n) => proxy n -> Word8
natValWord16 :: forall n proxy. (KnownNat n, NatWithinBound Word16 n) => proxy n -> Word16
natValWord32 :: forall n proxy. (KnownNat n, NatWithinBound Word32 n) => proxy n -> Word32
natValWord64 :: forall n proxy. (KnownNat n, NatWithinBound Word64 n) => proxy n -> Word64

-- | Get Maximum bounds of different Integral / Natural types related to
--   Nat
type family NatNumMaxBound ty :: Nat

-- | Check if a Nat is in bounds of another integral / natural types
type family NatInBoundOf ty n

-- | Constraint to check if a natural is within a specific bounds of a
--   type.
--   
--   i.e. given a Nat <tt>n</tt>, is it possible to convert it to
--   <tt>ty</tt> without losing information
type family NatWithinBound ty (n :: Nat)


-- | Types to represent ℤ/nℤ.
--   
--   ℤ/nℤ is a finite field and is defined as the set of natural number:
--   {0, 1, ..., n − 1}.
module Basement.Bounded

-- | A type level bounded natural backed by a Word64
data Zn64 (n :: Nat)
unZn64 :: Zn64 n -> Word64

-- | A type level bounded natural
data Zn (n :: Nat)
unZn :: Zn n -> Natural

-- | Create an element of ℤ/nℤ from a Word64
--   
--   If the value is greater than n, then the value is normalized by using
--   the integer modulus n
zn64 :: forall n. (KnownNat n, NatWithinBound Word64 n) => Word64 -> Zn64 n

-- | Create an element of ℤ/nℤ from a Natural.
--   
--   If the value is greater than n, then the value is normalized by using
--   the integer modulus n
zn :: forall n. KnownNat n => Natural -> Zn n

-- | Create an element of ℤ/nℤ from a type level Nat
zn64Nat :: forall m n. (KnownNat m, KnownNat n, NatWithinBound Word64 m, NatWithinBound Word64 n, CmpNat m n ~ 'LT) => Proxy m -> Zn64 n

-- | Create an element of ℤ/nℤ from a type level Nat
znNat :: forall m n. (KnownNat m, KnownNat n, CmpNat m n ~ 'LT) => Proxy m -> Zn n
instance GHC.Classes.Ord (Basement.Bounded.Zn64 n)
instance GHC.Classes.Eq (Basement.Bounded.Zn64 n)
instance GHC.Show.Show (Basement.Bounded.Zn64 n)
instance GHC.Classes.Ord (Basement.Bounded.Zn n)
instance GHC.Classes.Eq (Basement.Bounded.Zn n)
instance GHC.Show.Show (Basement.Bounded.Zn n)
instance GHC.TypeNats.KnownNat n => GHC.Num.Num (Basement.Bounded.Zn n)
instance GHC.TypeNats.KnownNat n => Basement.Compat.NumLiteral.Integral (Basement.Bounded.Zn n)
instance GHC.TypeNats.KnownNat n => Basement.Numerical.Number.IsIntegral (Basement.Bounded.Zn n)
instance GHC.TypeNats.KnownNat n => Basement.Numerical.Number.IsNatural (Basement.Bounded.Zn n)
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => GHC.Num.Num (Basement.Bounded.Zn64 n)
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.Compat.NumLiteral.Integral (Basement.Bounded.Zn64 n)
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.Numerical.Number.IsIntegral (Basement.Bounded.Zn64 n)
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.Numerical.Number.IsNatural (Basement.Bounded.Zn64 n)

module Basement.Numerical.Subtractive

-- | Represent class of things that can be subtracted.
--   
--   Note that the result is not necessary of the same type as the operand
--   depending on the actual type.
--   
--   For example:
--   
--   <pre>
--   (-) :: Int -&gt; Int -&gt; Int
--   (-) :: DateTime -&gt; DateTime -&gt; Seconds
--   (-) :: Ptr a -&gt; Ptr a -&gt; PtrDiff
--   (-) :: Natural -&gt; Natural -&gt; Maybe Natural
--   </pre>
class Subtractive a where {
    type Difference a;
}
(-) :: Subtractive a => a -> a -> Difference a
infixl 6 -
instance Basement.Numerical.Subtractive.Subtractive GHC.Num.Integer.Integer
instance Basement.Numerical.Subtractive.Subtractive GHC.Types.Int
instance Basement.Numerical.Subtractive.Subtractive GHC.Int.Int8
instance Basement.Numerical.Subtractive.Subtractive GHC.Int.Int16
instance Basement.Numerical.Subtractive.Subtractive GHC.Int.Int32
instance Basement.Numerical.Subtractive.Subtractive GHC.Int.Int64
instance Basement.Numerical.Subtractive.Subtractive GHC.Num.Natural.Natural
instance Basement.Numerical.Subtractive.Subtractive GHC.Types.Word
instance Basement.Numerical.Subtractive.Subtractive GHC.Word.Word8
instance Basement.Numerical.Subtractive.Subtractive GHC.Word.Word16
instance Basement.Numerical.Subtractive.Subtractive GHC.Word.Word32
instance Basement.Numerical.Subtractive.Subtractive GHC.Word.Word64
instance Basement.Numerical.Subtractive.Subtractive Basement.Types.Word128.Word128
instance Basement.Numerical.Subtractive.Subtractive Basement.Types.Word256.Word256
instance Basement.Numerical.Subtractive.Subtractive GHC.Types.Float
instance Basement.Numerical.Subtractive.Subtractive GHC.Types.Double
instance Basement.Numerical.Subtractive.Subtractive GHC.Types.Char
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.Numerical.Subtractive.Subtractive (Basement.Bounded.Zn64 n)
instance GHC.TypeNats.KnownNat n => Basement.Numerical.Subtractive.Subtractive (Basement.Bounded.Zn n)
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CChar
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CSChar
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUChar
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CShort
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUShort
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CInt
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUInt
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CLong
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CULong
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CPtrdiff
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CSize
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CWchar
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CSigAtomic
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CLLong
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CULLong
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CBool
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CIntPtr
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CIntMax
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUIntMax
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CClock
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CTime
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CUSeconds
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CSUSeconds
instance Basement.Numerical.Subtractive.Subtractive System.Posix.Types.COff
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CFloat
instance Basement.Numerical.Subtractive.Subtractive Foreign.C.Types.CDouble

module Basement.Numerical.Additive

-- | Represent class of things that can be added together, contains a
--   neutral element and is commutative.
--   
--   <pre>
--   x + azero = x
--   azero + x = x
--   x + y = y + x
--   </pre>
class Additive a
azero :: Additive a => a
(+) :: Additive a => a -> a -> a
scale :: (Additive a, IsNatural n) => n -> a -> a
scale :: (Additive a, Enum n, IsNatural n) => n -> a -> a
infixl 6 +
instance Basement.Numerical.Additive.Additive GHC.Num.Integer.Integer
instance Basement.Numerical.Additive.Additive GHC.Types.Int
instance Basement.Numerical.Additive.Additive GHC.Int.Int8
instance Basement.Numerical.Additive.Additive GHC.Int.Int16
instance Basement.Numerical.Additive.Additive GHC.Int.Int32
instance Basement.Numerical.Additive.Additive GHC.Int.Int64
instance Basement.Numerical.Additive.Additive GHC.Types.Word
instance Basement.Numerical.Additive.Additive GHC.Num.Natural.Natural
instance Basement.Numerical.Additive.Additive GHC.Word.Word8
instance Basement.Numerical.Additive.Additive GHC.Word.Word16
instance Basement.Numerical.Additive.Additive GHC.Word.Word32
instance Basement.Numerical.Additive.Additive GHC.Word.Word64
instance Basement.Numerical.Additive.Additive Basement.Types.Word128.Word128
instance Basement.Numerical.Additive.Additive Basement.Types.Word256.Word256
instance Basement.Numerical.Additive.Additive GHC.Types.Float
instance Basement.Numerical.Additive.Additive GHC.Types.Double
instance Basement.Numerical.Additive.Additive GHC.Real.Rational
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.Numerical.Additive.Additive (Basement.Bounded.Zn64 n)
instance GHC.TypeNats.KnownNat n => Basement.Numerical.Additive.Additive (Basement.Bounded.Zn n)
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CChar
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CSChar
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUChar
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CShort
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUShort
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CInt
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUInt
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CLong
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CULong
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CPtrdiff
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CSize
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CWchar
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CSigAtomic
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CLLong
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CULLong
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CIntPtr
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CIntMax
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUIntMax
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CClock
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CTime
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CUSeconds
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CSUSeconds
instance Basement.Numerical.Additive.Additive System.Posix.Types.COff
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CFloat
instance Basement.Numerical.Additive.Additive Foreign.C.Types.CDouble

module Basement.Numerical.Multiplicative

-- | Represent class of things that can be multiplied together
--   
--   <pre>
--   x * midentity = x
--   midentity * x = x
--   </pre>
class Multiplicative a

-- | Identity element over multiplication
midentity :: Multiplicative a => a

-- | Multiplication of 2 elements that result in another element
(*) :: Multiplicative a => a -> a -> a

-- | Raise to power, repeated multiplication e.g. &gt; a ^ 2 = a * a &gt; a
--   ^ 10 = (a ^ 5) * (a ^ 5) .. (^) :: (IsNatural n) =&gt; a -&gt; n -&gt;
--   a
(^) :: (Multiplicative a, IsNatural n, Enum n, IDivisible n) => a -> n -> a
infixl 7 *
infixr 8 ^

-- | Represent types that supports an euclidian division
--   
--   <pre>
--   (x ‘div‘ y) * y + (x ‘mod‘ y) == x
--   </pre>
class (Additive a, Multiplicative a) => IDivisible a
div :: IDivisible a => a -> a -> a
mod :: IDivisible a => a -> a -> a
divMod :: IDivisible a => a -> a -> (a, a)

-- | Support for division between same types
--   
--   This is likely to change to represent specific mathematic divisions
class Multiplicative a => Divisible a
(/) :: Divisible a => a -> a -> a
infixl 7 /
recip :: Divisible a => a -> a
instance Basement.Numerical.Multiplicative.Divisible GHC.Real.Rational
instance Basement.Numerical.Multiplicative.Divisible GHC.Types.Float
instance Basement.Numerical.Multiplicative.Divisible GHC.Types.Double
instance Basement.Numerical.Multiplicative.Divisible Foreign.C.Types.CFloat
instance Basement.Numerical.Multiplicative.Divisible Foreign.C.Types.CDouble
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Num.Integer.Integer
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Types.Int
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Int.Int8
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Int.Int16
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Int.Int32
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Int.Int64
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Num.Natural.Natural
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Types.Word
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Word.Word8
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Word.Word16
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Word.Word32
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Word.Word64
instance Basement.Numerical.Multiplicative.Multiplicative Basement.Types.Word128.Word128
instance Basement.Numerical.Multiplicative.Multiplicative Basement.Types.Word256.Word256
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Types.Float
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Types.Double
instance Basement.Numerical.Multiplicative.Multiplicative GHC.Real.Rational
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CChar
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CSChar
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUChar
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CShort
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUShort
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CInt
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUInt
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CLong
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CULong
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CPtrdiff
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CSize
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CWchar
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CSigAtomic
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CLLong
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CULLong
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CIntPtr
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CIntMax
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUIntMax
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CClock
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CTime
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CUSeconds
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CSUSeconds
instance Basement.Numerical.Multiplicative.Multiplicative System.Posix.Types.COff
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CFloat
instance Basement.Numerical.Multiplicative.Multiplicative Foreign.C.Types.CDouble
instance Basement.Numerical.Multiplicative.IDivisible GHC.Num.Integer.Integer
instance Basement.Numerical.Multiplicative.IDivisible GHC.Types.Int
instance Basement.Numerical.Multiplicative.IDivisible GHC.Int.Int8
instance Basement.Numerical.Multiplicative.IDivisible GHC.Int.Int16
instance Basement.Numerical.Multiplicative.IDivisible GHC.Int.Int32
instance Basement.Numerical.Multiplicative.IDivisible GHC.Int.Int64
instance Basement.Numerical.Multiplicative.IDivisible GHC.Num.Natural.Natural
instance Basement.Numerical.Multiplicative.IDivisible GHC.Types.Word
instance Basement.Numerical.Multiplicative.IDivisible GHC.Word.Word8
instance Basement.Numerical.Multiplicative.IDivisible GHC.Word.Word16
instance Basement.Numerical.Multiplicative.IDivisible GHC.Word.Word32
instance Basement.Numerical.Multiplicative.IDivisible GHC.Word.Word64
instance Basement.Numerical.Multiplicative.IDivisible Basement.Types.Word128.Word128
instance Basement.Numerical.Multiplicative.IDivisible Basement.Types.Word256.Word256
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CChar
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CSChar
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CUChar
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CShort
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CUShort
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CInt
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CUInt
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CLong
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CULong
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CPtrdiff
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CSize
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CWchar
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CSigAtomic
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CLLong
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CULLong
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CIntPtr
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CUIntPtr
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CIntMax
instance Basement.Numerical.Multiplicative.IDivisible Foreign.C.Types.CUIntMax


module Basement.Types.OffsetSize

-- | File size in bytes
newtype FileSize
FileSize :: Word64 -> FileSize

-- | Offset in a data structure consisting of elements of type <tt>ty</tt>.
--   
--   Int is a terrible backing type which is hard to get away from,
--   considering that GHC/Haskell are mostly using this for offset. Trying
--   to bring some sanity by a lightweight wrapping.
newtype Offset ty
Offset :: Int -> Offset ty

-- | Offset in bytes used for memory addressing (e.g. in a vector, string,
--   ..)
type Offset8 = Offset Word8
sentinel :: Offset ty
offsetOfE :: CountOf Word8 -> Offset ty -> Offset8
offsetPlusE :: Offset ty -> CountOf ty -> Offset ty
offsetMinusE :: Offset ty -> CountOf ty -> Offset ty
offsetRecast :: CountOf Word8 -> CountOf Word8 -> Offset ty -> Offset ty2
offsetCast :: Proxy (a -> b) -> Offset a -> Offset b

-- | subtract 2 CountOf values of the same type.
--   
--   m need to be greater than n, otherwise negative count error ensue use
--   the safer (-) version if unsure.
offsetSub :: Offset a -> Offset a -> Offset a
offsetShiftL :: Int -> Offset ty -> Offset ty2
offsetShiftR :: Int -> Offset ty -> Offset ty2
sizeCast :: Proxy (a -> b) -> CountOf a -> CountOf b
sizeLastOffset :: CountOf a -> Offset a
sizeAsOffset :: CountOf a -> Offset a

-- | subtract 2 CountOf values of the same type.
--   
--   m need to be greater than n, otherwise negative count error ensue use
--   the safer (-) version if unsure.
sizeSub :: CountOf a -> CountOf a -> CountOf a

-- | alignment need to be a power of 2
countOfRoundUp :: Int -> CountOf ty -> CountOf ty
offsetAsSize :: Offset a -> CountOf a
(+.) :: Offset ty -> Int -> Offset ty
(.==#) :: Offset ty -> CountOf ty -> Bool

-- | CountOf of a data structure.
--   
--   More specifically, it represents the number of elements of type
--   <tt>ty</tt> that fit into the data structure.
--   
--   <pre>
--   &gt;&gt;&gt; length (fromList ['a', 'b', 'c', '🌟']) :: CountOf Char
--   CountOf 4
--   </pre>
--   
--   Same caveats as <a>Offset</a> apply here.
newtype CountOf ty
CountOf :: Int -> CountOf ty
sizeOfE :: CountOf Word8 -> CountOf ty -> CountOf Word8
csizeOfOffset :: Offset8 -> CSize
csizeOfSize :: CountOf Word8 -> CSize
sizeOfCSSize :: CSsize -> CountOf Word8
sizeOfCSize :: CSize -> CountOf Word8
type Countable ty n = NatWithinBound (CountOf ty) n
type Offsetable ty n = NatWithinBound (Offset ty) n
natValCountOf :: forall n ty proxy. (KnownNat n, NatWithinBound (CountOf ty) n) => proxy n -> CountOf ty
natValOffset :: forall n ty proxy. (KnownNat n, NatWithinBound (Offset ty) n) => proxy n -> Offset ty
instance GHC.Classes.Ord Basement.Types.OffsetSize.FileSize
instance GHC.Classes.Eq Basement.Types.OffsetSize.FileSize
instance GHC.Show.Show Basement.Types.OffsetSize.FileSize
instance GHC.Num.Num (Basement.Types.OffsetSize.Offset ty)
instance Basement.Compat.NumLiteral.Integral (Basement.Types.OffsetSize.Offset ty)
instance Basement.Numerical.Additive.Additive (Basement.Types.OffsetSize.Offset ty)
instance GHC.Enum.Enum (Basement.Types.OffsetSize.Offset ty)
instance GHC.Classes.Ord (Basement.Types.OffsetSize.Offset ty)
instance GHC.Classes.Eq (Basement.Types.OffsetSize.Offset ty)
instance GHC.Show.Show (Basement.Types.OffsetSize.Offset ty)
instance Basement.Compat.NumLiteral.Integral (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Enum.Enum (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Classes.Ord (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Classes.Eq (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Show.Show (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Subtractive.Subtractive (Basement.Types.OffsetSize.Offset ty)
instance GHC.Num.Num (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Number.IsIntegral (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Number.IsNatural (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Additive.Additive (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Subtractive.Subtractive (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Base.Semigroup (Basement.Types.OffsetSize.CountOf ty)
instance GHC.Base.Monoid (Basement.Types.OffsetSize.CountOf ty)
instance Basement.Numerical.Number.IsIntegral (Basement.Types.OffsetSize.Offset ty)
instance Basement.Numerical.Number.IsNatural (Basement.Types.OffsetSize.Offset ty)

module Basement.Types.Ptr
data Addr
Addr :: Addr# -> Addr
addrPlus :: Addr -> Offset Word8 -> Addr
addrPlusSz :: Addr -> CountOf Word8 -> Addr
addrPlusCSz :: Addr -> CSize -> Addr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data () => Ptr a
Ptr :: Addr# -> Ptr a
ptrPlus :: Ptr a -> Offset Word8 -> Ptr a
ptrPlusSz :: Ptr a -> CountOf Word8 -> Ptr a
ptrPlusCSz :: Ptr a -> CSize -> Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b
instance GHC.Classes.Ord Basement.Types.Ptr.Addr
instance GHC.Classes.Eq Basement.Types.Ptr.Addr

module Basement.Terminal
initialize :: IO ()

-- | Return the size of the current terminal
--   
--   If the system is not supported or that querying the system result in
--   an error then a default size of (80, 24) will be given back.
getDimensions :: IO (CountOf Char, CountOf Char)

module Basement.PrimType

-- | Represent the accessor for types that can be stored in the UArray and
--   MUArray.
--   
--   Types need to be a instance of storable and have fixed sized.
class Eq ty => PrimType ty where {
    
    -- | type level size of the given <tt>ty</tt>
    type PrimSize ty :: Nat;
}

-- | get the size in bytes of a ty element
primSizeInBytes :: PrimType ty => Proxy ty -> CountOf Word8

-- | get the shift size
primShiftToBytes :: PrimType ty => Proxy ty -> Int

-- | return the element stored at a specific index
primBaUIndex :: PrimType ty => ByteArray# -> Offset ty -> ty

-- | Read an element at an index in a mutable array
primMbaURead :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> prim ty

-- | Write an element to a specific cell in a mutable array.
primMbaUWrite :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> ty -> prim ()

-- | Read from Address, without a state. the value read should be
--   considered a constant for all pratical purpose, otherwise bad thing
--   will happens.
primAddrIndex :: PrimType ty => Addr# -> Offset ty -> ty

-- | Read a value from Addr in a specific primitive monad
primAddrRead :: (PrimType ty, PrimMonad prim) => Addr# -> Offset ty -> prim ty

-- | Write a value to Addr in a specific primitive monad
primAddrWrite :: (PrimType ty, PrimMonad prim) => Addr# -> Offset ty -> ty -> prim ()

-- | A constraint class for serializable type that have an unique memory
--   compare representation
--   
--   e.g. Float and Double have -0.0 and 0.0 which are Eq individual, yet
--   have a different memory representation which doesn't allow for memcmp
--   operation
class PrimMemoryComparable ty
primBaIndex :: PrimType ty => ByteArray# -> Offset ty -> ty
primMbaRead :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> prim ty
primMbaWrite :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> ty -> prim ()
primArrayIndex :: Array# ty -> Offset ty -> ty
primMutableArrayRead :: PrimMonad prim => MutableArray# (PrimState prim) ty -> Offset ty -> prim ty
primMutableArrayWrite :: PrimMonad prim => MutableArray# (PrimState prim) ty -> Offset ty -> ty -> prim ()

-- | <i>Deprecated: use offsetInBytes</i>
primOffsetOfE :: forall a. PrimType a => Offset a -> Offset Word8
primOffsetRecast :: forall a b. (PrimType a, PrimType b) => Offset a -> Offset b

-- | Cast a CountOf linked to type A (CountOf A) to a CountOf linked to
--   type B (CountOf B)
sizeRecast :: forall a b. (PrimType a, PrimType b) => CountOf a -> CountOf b
offsetAsSize :: Offset a -> CountOf a
sizeAsOffset :: CountOf a -> Offset a
sizeInBytes :: forall a. PrimType a => CountOf a -> CountOf Word8
offsetInBytes :: forall a. PrimType a => Offset a -> Offset Word8
offsetInElements :: forall a. PrimType a => Offset Word8 -> Offset a
offsetIsAligned :: forall a. PrimType a => Proxy a -> Offset Word8 -> Bool
primWordGetByteAndShift :: Word# -> (# Word#, Word# #)
primWord64GetByteAndShift :: Word# -> (# Word#, Word# #)
primWord64GetHiLo :: Word# -> (# Word#, Word# #)
instance Basement.PrimType.PrimMemoryComparable GHC.Types.Int
instance Basement.PrimType.PrimMemoryComparable GHC.Types.Word
instance Basement.PrimType.PrimMemoryComparable GHC.Word.Word8
instance Basement.PrimType.PrimMemoryComparable GHC.Word.Word16
instance Basement.PrimType.PrimMemoryComparable GHC.Word.Word32
instance Basement.PrimType.PrimMemoryComparable GHC.Word.Word64
instance Basement.PrimType.PrimMemoryComparable Basement.Types.Word128.Word128
instance Basement.PrimType.PrimMemoryComparable Basement.Types.Word256.Word256
instance Basement.PrimType.PrimMemoryComparable GHC.Int.Int8
instance Basement.PrimType.PrimMemoryComparable GHC.Int.Int16
instance Basement.PrimType.PrimMemoryComparable GHC.Int.Int32
instance Basement.PrimType.PrimMemoryComparable GHC.Int.Int64
instance Basement.PrimType.PrimMemoryComparable GHC.Types.Char
instance Basement.PrimType.PrimMemoryComparable Foreign.C.Types.CChar
instance Basement.PrimType.PrimMemoryComparable Foreign.C.Types.CUChar
instance Basement.PrimType.PrimMemoryComparable a => Basement.PrimType.PrimMemoryComparable (Basement.Endianness.LE a)
instance Basement.PrimType.PrimMemoryComparable a => Basement.PrimType.PrimMemoryComparable (Basement.Endianness.BE a)
instance Basement.PrimType.PrimType GHC.Types.Int
instance Basement.PrimType.PrimType GHC.Types.Word
instance Basement.PrimType.PrimType GHC.Word.Word8
instance Basement.PrimType.PrimType GHC.Word.Word16
instance Basement.PrimType.PrimType GHC.Word.Word32
instance Basement.PrimType.PrimType GHC.Word.Word64
instance Basement.PrimType.PrimType Basement.Types.Word128.Word128
instance Basement.PrimType.PrimType Basement.Types.Word256.Word256
instance Basement.PrimType.PrimType GHC.Int.Int8
instance Basement.PrimType.PrimType GHC.Int.Int16
instance Basement.PrimType.PrimType GHC.Int.Int32
instance Basement.PrimType.PrimType GHC.Int.Int64
instance Basement.PrimType.PrimType GHC.Types.Float
instance Basement.PrimType.PrimType GHC.Types.Double
instance Basement.PrimType.PrimType GHC.Types.Char
instance Basement.PrimType.PrimType Foreign.C.Types.CChar
instance Basement.PrimType.PrimType Foreign.C.Types.CUChar
instance Basement.PrimType.PrimType Basement.Types.Char7.Char7
instance Basement.PrimType.PrimType a => Basement.PrimType.PrimType (Basement.Endianness.LE a)
instance Basement.PrimType.PrimType a => Basement.PrimType.PrimType (Basement.Endianness.BE a)

module Basement.MutableBuilder
newtype Builder collection mutCollection step state err a
Builder :: State (Offset step, BuildingState collection mutCollection step (PrimState state), Maybe err) state a -> Builder collection mutCollection step state err a
[runBuilder] :: Builder collection mutCollection step state err a -> State (Offset step, BuildingState collection mutCollection step (PrimState state), Maybe err) state a

-- | The in-progress state of a building operation.
--   
--   The previous buffers are in reverse order, and this contains the
--   current buffer and the state of progress packing the elements inside.
data BuildingState collection mutCollection step state
BuildingState :: [collection] -> !CountOf step -> mutCollection state -> !CountOf step -> BuildingState collection mutCollection step state
[prevChunks] :: BuildingState collection mutCollection step state -> [collection]
[prevChunksSize] :: BuildingState collection mutCollection step state -> !CountOf step
[curChunk] :: BuildingState collection mutCollection step state -> mutCollection state
[chunkSize] :: BuildingState collection mutCollection step state -> !CountOf step
instance GHC.Base.Monad state => GHC.Base.Monad (Basement.MutableBuilder.Builder collection mutCollection step state err)
instance GHC.Base.Monad state => GHC.Base.Applicative (Basement.MutableBuilder.Builder collection mutCollection step state err)
instance GHC.Base.Monad state => GHC.Base.Functor (Basement.MutableBuilder.Builder collection mutCollection step state err)
instance GHC.Base.Monad state => Basement.Monad.MonadFailure (Basement.MutableBuilder.Builder collection mutCollection step state err)


-- | Common part for vectors
module Basement.Exception

-- | Exception during an operation accessing the vector out of bound
--   
--   Represent the type of operation, the index accessed, and the total
--   length of the vector.
data OutOfBound
OutOfBound :: OutOfBoundOperation -> Int -> Int -> OutOfBound

-- | The type of operation that triggers an OutOfBound exception.
--   
--   <ul>
--   <li>OOB_Index: reading an immutable vector</li>
--   <li>OOB_Read: reading a mutable vector</li>
--   <li>OOB_Write: write a mutable vector</li>
--   <li>OOB_MemCopy: copying a vector</li>
--   <li>OOB_MemSet: initializing a mutable vector</li>
--   </ul>
data OutOfBoundOperation
OOB_Read :: OutOfBoundOperation
OOB_Write :: OutOfBoundOperation
OOB_MemSet :: OutOfBoundOperation
OOB_MemCopy :: OutOfBoundOperation
OOB_Index :: OutOfBoundOperation
isOutOfBound :: Offset ty -> CountOf ty -> Bool
outOfBound :: OutOfBoundOperation -> Offset ty -> CountOf ty -> a
primOutOfBound :: PrimMonad prim => OutOfBoundOperation -> Offset ty -> CountOf ty -> prim a
data InvalidRecast
InvalidRecast :: RecastSourceSize -> RecastDestinationSize -> InvalidRecast
newtype RecastSourceSize
RecastSourceSize :: Int -> RecastSourceSize
newtype RecastDestinationSize
RecastDestinationSize :: Int -> RecastDestinationSize

-- | Exception for using NonEmpty assertion with an empty collection
data NonEmptyCollectionIsEmpty
NonEmptyCollectionIsEmpty :: NonEmptyCollectionIsEmpty
instance GHC.Classes.Eq Basement.Exception.OutOfBoundOperation
instance GHC.Show.Show Basement.Exception.OutOfBoundOperation
instance GHC.Show.Show Basement.Exception.OutOfBound
instance GHC.Classes.Eq Basement.Exception.RecastSourceSize
instance GHC.Show.Show Basement.Exception.RecastSourceSize
instance GHC.Classes.Eq Basement.Exception.RecastDestinationSize
instance GHC.Show.Show Basement.Exception.RecastDestinationSize
instance GHC.Show.Show Basement.Exception.InvalidRecast
instance GHC.Show.Show Basement.Exception.NonEmptyCollectionIsEmpty
instance GHC.Exception.Type.Exception Basement.Exception.NonEmptyCollectionIsEmpty
instance GHC.Exception.Type.Exception Basement.Exception.InvalidRecast
instance GHC.Exception.Type.Exception Basement.Exception.OutOfBound


-- | A newtype wrapper around a non-empty Collection.
module Basement.NonEmpty

-- | NonEmpty property for any Collection
newtype NonEmpty a
NonEmpty :: a -> NonEmpty a
[getNonEmpty] :: NonEmpty a -> a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.NonEmpty.NonEmpty a)
instance GHC.Show.Show a => GHC.Show.Show (Basement.NonEmpty.NonEmpty a)
instance GHC.IsList.IsList c => GHC.IsList.IsList (Basement.NonEmpty.NonEmpty c)

module Basement.Compat.ExtList

-- | Compute the size of the list
length :: [a] -> CountOf a
null :: [a] -> Bool

-- | Sum the element in a list
sum :: Additive n => [n] -> n
reverse :: [a] -> [a]
(!!) :: [a] -> Offset a -> a


-- | XorShift variant: Xoroshiro128+
--   <a>https://en.wikipedia.org/wiki/Xoroshiro128%2B</a>
--   
--   Xoroshiro128+ is a PRNG that uses a shift/rotate-based linear
--   transformation. This is lar
--   
--   C implementation at:
--   <a>http://xoroshiro.di.unimi.it/xoroshiro128plus.c</a>
module Basement.Alg.XorShift

-- | State of Xoroshiro128 plus
data State
State :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> State

-- | Given a state, call the function <tt>f</tt> with the generated Word64
--   and the next State
next :: State -> (Word64 -> State -> a) -> a

-- | Same as <a>next</a> but give a random value of type Double in the
--   range of [0.0 .. 1.0]
nextDouble :: State -> (Double -> State -> a) -> a

-- | Jump the state by 2^64 calls of next
jump :: State -> State

module Basement.NormalForm

-- | Data that can be fully evaluated in Normal Form
class NormalForm a
toNormalForm :: NormalForm a => a -> ()
deepseq :: NormalForm a => a -> b -> b
force :: NormalForm a => a -> a
instance Basement.NormalForm.NormalForm GHC.Int.Int8
instance Basement.NormalForm.NormalForm GHC.Int.Int16
instance Basement.NormalForm.NormalForm GHC.Int.Int32
instance Basement.NormalForm.NormalForm GHC.Int.Int64
instance Basement.NormalForm.NormalForm GHC.Types.Int
instance Basement.NormalForm.NormalForm GHC.Num.Integer.Integer
instance Basement.NormalForm.NormalForm GHC.Word.Word8
instance Basement.NormalForm.NormalForm GHC.Word.Word16
instance Basement.NormalForm.NormalForm GHC.Word.Word32
instance Basement.NormalForm.NormalForm GHC.Word.Word64
instance Basement.NormalForm.NormalForm GHC.Types.Word
instance Basement.NormalForm.NormalForm GHC.Num.Natural.Natural
instance Basement.NormalForm.NormalForm GHC.Types.Float
instance Basement.NormalForm.NormalForm GHC.Types.Double
instance Basement.NormalForm.NormalForm GHC.Types.Char
instance Basement.NormalForm.NormalForm GHC.Types.Bool
instance Basement.NormalForm.NormalForm ()
instance Basement.NormalForm.NormalForm Foreign.C.Types.CChar
instance Basement.NormalForm.NormalForm Foreign.C.Types.CUChar
instance Basement.NormalForm.NormalForm Foreign.C.Types.CSChar
instance Basement.NormalForm.NormalForm Foreign.C.Types.CShort
instance Basement.NormalForm.NormalForm Foreign.C.Types.CUShort
instance Basement.NormalForm.NormalForm Foreign.C.Types.CInt
instance Basement.NormalForm.NormalForm Foreign.C.Types.CUInt
instance Basement.NormalForm.NormalForm Foreign.C.Types.CLong
instance Basement.NormalForm.NormalForm Foreign.C.Types.CULong
instance Basement.NormalForm.NormalForm Foreign.C.Types.CLLong
instance Basement.NormalForm.NormalForm Foreign.C.Types.CULLong
instance Basement.NormalForm.NormalForm Foreign.C.Types.CFloat
instance Basement.NormalForm.NormalForm Foreign.C.Types.CDouble
instance Basement.NormalForm.NormalForm (GHC.Ptr.Ptr a)
instance Basement.NormalForm.NormalForm (Basement.Types.OffsetSize.Offset a)
instance Basement.NormalForm.NormalForm (Basement.Types.OffsetSize.CountOf a)
instance Basement.NormalForm.NormalForm Basement.Types.Char7.Char7
instance Basement.NormalForm.NormalForm Basement.Types.Word128.Word128
instance Basement.NormalForm.NormalForm Basement.Types.Word256.Word256
instance Basement.NormalForm.NormalForm (Basement.Bounded.Zn n)
instance Basement.NormalForm.NormalForm (Basement.Bounded.Zn64 n)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (GHC.Maybe.Maybe a)
instance (Basement.NormalForm.NormalForm l, Basement.NormalForm.NormalForm r) => Basement.NormalForm.NormalForm (Data.Either.Either l r)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (Basement.Endianness.LE a)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (Basement.Endianness.BE a)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm [a]
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b) => Basement.NormalForm.NormalForm (a, b)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c) => Basement.NormalForm.NormalForm (a, b, c)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c, Basement.NormalForm.NormalForm d) => Basement.NormalForm.NormalForm (a, b, c, d)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c, Basement.NormalForm.NormalForm d, Basement.NormalForm.NormalForm e) => Basement.NormalForm.NormalForm (a, b, c, d, e)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c, Basement.NormalForm.NormalForm d, Basement.NormalForm.NormalForm e, Basement.NormalForm.NormalForm f) => Basement.NormalForm.NormalForm (a, b, c, d, e, f)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c, Basement.NormalForm.NormalForm d, Basement.NormalForm.NormalForm e, Basement.NormalForm.NormalForm f, Basement.NormalForm.NormalForm g) => Basement.NormalForm.NormalForm (a, b, c, d, e, f, g)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b, Basement.NormalForm.NormalForm c, Basement.NormalForm.NormalForm d, Basement.NormalForm.NormalForm e, Basement.NormalForm.NormalForm f, Basement.NormalForm.NormalForm g, Basement.NormalForm.NormalForm h) => Basement.NormalForm.NormalForm (a, b, c, d, e, f, g, h)


-- | <tt>These a b</tt>, sum type to represent either <tt>a</tt> or
--   <tt>b</tt> or both.
module Basement.These

-- | Either a or b or both.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Basement.These.These a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Basement.These.These a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Basement.These.These a b)
instance (Basement.NormalForm.NormalForm a, Basement.NormalForm.NormalForm b) => Basement.NormalForm.NormalForm (Basement.These.These a b)


-- | A Nat-sized list abstraction
--   
--   Using this module is limited to GHC 7.10 and above.
module Basement.Sized.List

-- | A Typed-level sized List equivalent to [a]
data ListN (n :: Nat) a

-- | Try to create a ListN from a List, succeeding if the length is correct
toListN :: forall (n :: Nat) a. (KnownNat n, NatWithinBound Int n) => [a] -> Maybe (ListN n a)

-- | Create a ListN from a List, expecting a given length
--   
--   If this list contains more or less than the expected length of the
--   resulting type, then an asynchronous error is raised. use
--   <a>toListN</a> for a more friendly functions
toListN_ :: forall n a. (HasCallStack, NatWithinBound Int n, KnownNat n) => [a] -> ListN n a
unListN :: ListN n a -> [a]

-- | Get the length of a list
length :: forall a (n :: Nat). (KnownNat n, NatWithinBound Int n) => ListN n a -> CountOf a

-- | Create a new list of size n, repeately calling f from 0 to n-1
create :: forall a (n :: Nat). KnownNat n => (Natural -> a) -> ListN n a

-- | Same as create but apply an offset
createFrom :: forall a (n :: Nat) (start :: Nat). (KnownNat n, KnownNat start) => Proxy start -> (Natural -> a) -> ListN n a

-- | Create an empty list of a
empty :: ListN 0 a

-- | create a list of 1 element
singleton :: a -> ListN 1 a

-- | Decompose a list into its head and tail.
uncons :: 1 <= n => ListN n a -> (a, ListN (n - 1) a)

-- | prepend an element to the list
cons :: a -> ListN n a -> ListN (n + 1) a

-- | Decompose a list into its first elements and the last.
unsnoc :: 1 <= n => ListN n a -> (ListN (n - 1) a, a)

-- | append an element to the list
snoc :: ListN n a -> a -> ListN (n + 1) a

-- | Get the i'the element
index :: ListN n ty -> Offset ty -> ty

-- | Get the i'th elements
--   
--   This only works with TypeApplication:
--   
--   <pre>
--   indexStatic @1 (toListN_ [1,2,3] :: ListN 3 Int)
--   </pre>
indexStatic :: forall i n a. (KnownNat i, CmpNat i n ~ 'LT, Offsetable a i) => ListN n a -> a

-- | Update the value in a list at a specific location
updateAt :: forall n a. Offset a -> (a -> a) -> ListN n a -> ListN n a

-- | Map all elements in a list
map :: (a -> b) -> ListN n a -> ListN n b

-- | Map all elements in a list with an additional index
mapi :: (Natural -> a -> b) -> ListN n a -> ListN n b

-- | Check if a list contains the element a
elem :: Eq a => a -> ListN n a -> Bool

-- | Fold all elements from left
foldl :: (b -> a -> b) -> b -> ListN n a -> b

-- | Fold all elements from left strictly
foldl' :: (b -> a -> b) -> b -> ListN n a -> b

-- | Fold all elements from left strictly with a first element as the
--   accumulator
foldl1' :: 1 <= n => (a -> a -> a) -> ListN n a -> a

-- | <tt>scanl</tt> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
scanl' :: (b -> a -> b) -> b -> ListN n a -> ListN (n + 1) b

-- | <tt>scanl1</tt> is a variant of <tt>scanl</tt> that has no starting
--   value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1' :: (a -> a -> a) -> ListN n a -> ListN n a

-- | Fold all elements from right
foldr :: (a -> b -> b) -> b -> ListN n a -> b

-- | Fold all elements from right assuming at least one element is in the
--   list.
foldr1 :: 1 <= n => (a -> a -> a) -> ListN n a -> a

-- | Reverse a list
reverse :: ListN n a -> ListN n a

-- | Append 2 list together returning the new list
append :: ListN n a -> ListN m a -> ListN (n + m) a

-- | Get the minimum element of a list
minimum :: (Ord a, 1 <= n) => ListN n a -> a

-- | Get the maximum element of a list
maximum :: (Ord a, 1 <= n) => ListN n a -> a

-- | Get the head element of a list
head :: 1 <= n => ListN n a -> a

-- | Get the tail of a list
tail :: 1 <= n => ListN n a -> ListN (n - 1) a

-- | Get the list with the last element missing
init :: 1 <= n => ListN n a -> ListN (n - 1) a

-- | Take m elements from the beggining of the list.
--   
--   The number of elements need to be less or equal to the list in
--   argument
take :: forall a (m :: Nat) (n :: Nat). (KnownNat m, NatWithinBound Int m, m <= n) => ListN n a -> ListN m a

-- | Drop elements from a list keeping the m remaining elements
drop :: forall a d (m :: Nat) (n :: Nat). (KnownNat d, NatWithinBound Int d, (n - m) ~ d, m <= n) => ListN n a -> ListN m a

-- | Split a list into two, returning 2 lists
splitAt :: forall a d (m :: Nat) (n :: Nat). (KnownNat d, NatWithinBound Int d, (n - m) ~ d, m <= n) => ListN n a -> (ListN m a, ListN (n - m) a)

-- | Zip 2 lists of the same size, returning a new list of the tuple of
--   each elements
zip :: ListN n a -> ListN n b -> ListN n (a, b)

-- | Zip 3 lists of the same size
zip3 :: ListN n a -> ListN n b -> ListN n c -> ListN n (a, b, c)

-- | Zip 4 lists of the same size
zip4 :: ListN n a -> ListN n b -> ListN n c -> ListN n d -> ListN n (a, b, c, d)

-- | Zip 5 lists of the same size
zip5 :: ListN n a -> ListN n b -> ListN n c -> ListN n d -> ListN n e -> ListN n (a, b, c, d, e)

-- | Unzip a list of tuple, to 2 List of the deconstructed tuples
unzip :: ListN n (a, b) -> (ListN n a, ListN n b)

-- | Zip 2 lists using a function
zipWith :: (a -> b -> x) -> ListN n a -> ListN n b -> ListN n x

-- | Zip 3 lists using a function
zipWith3 :: (a -> b -> c -> x) -> ListN n a -> ListN n b -> ListN n c -> ListN n x

-- | Zip 4 lists using a function
zipWith4 :: (a -> b -> c -> d -> x) -> ListN n a -> ListN n b -> ListN n c -> ListN n d -> ListN n x

-- | Zip 5 lists using a function
zipWith5 :: (a -> b -> c -> d -> e -> x) -> ListN n a -> ListN n b -> ListN n c -> ListN n d -> ListN n e -> ListN n x

-- | Create a list of n elements where each element is the element in
--   argument
replicate :: forall (n :: Nat) a. (NatWithinBound Int n, KnownNat n) => a -> ListN n a

-- | performs a monadic action n times, gathering the results in a List of
--   size n.
replicateM :: forall (n :: Nat) m a. (NatWithinBound Int n, Monad m, KnownNat n) => m a -> m (ListN n a)

-- | Evaluate each monadic action in the list sequentially, and collect the
--   results.
sequence :: Monad m => ListN n (m a) -> m (ListN n a)

-- | Evaluate each monadic action in the list sequentially, and ignore the
--   results.
sequence_ :: Monad m => ListN n (m a) -> m ()

-- | Map each element of a List to a monadic action, evaluate these actions
--   sequentially and collect the results
mapM :: Monad m => (a -> m b) -> ListN n a -> m (ListN n b)

-- | Map each element of a List to a monadic action, evaluate these actions
--   sequentially and ignore the results
mapM_ :: Monad m => (a -> m b) -> ListN n a -> m ()
instance GHC.Generics.Generic (Basement.Sized.List.ListN n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Basement.Sized.List.ListN n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.Sized.List.ListN n a)
instance GHC.Show.Show a => GHC.Show.Show (Basement.Sized.List.ListN n a)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (Basement.Sized.List.ListN n a)


module Basement.Cast

-- | <a>Cast</a> an object of type a to b.
--   
--   Do not add instance of this class if the source type is not of the
--   same size of the destination type. Also keep in mind this is casting a
--   value of a given type into a destination type. The value won't be
--   changed to fit the destination represention.
--   
--   If you wish to convert a value of a given type into another type, look
--   at <tt>From</tt> and <tt>TryFrom</tt>.
--   
--   <pre>
--   cast (-10 :: Int) :: Word === 18446744073709551606
--   </pre>
class Cast source destination
cast :: Cast source destination => source -> destination
cast :: (Cast source destination, PrimType source, PrimType destination, PrimSize source ~ PrimSize destination) => source -> destination
instance Basement.Cast.Cast GHC.Int.Int8 GHC.Word.Word8
instance Basement.Cast.Cast GHC.Int.Int16 GHC.Word.Word16
instance Basement.Cast.Cast GHC.Int.Int32 GHC.Word.Word32
instance Basement.Cast.Cast GHC.Int.Int64 GHC.Word.Word64
instance Basement.Cast.Cast GHC.Types.Int GHC.Types.Word
instance Basement.Cast.Cast GHC.Word.Word8 GHC.Int.Int8
instance Basement.Cast.Cast GHC.Word.Word16 GHC.Int.Int16
instance Basement.Cast.Cast GHC.Word.Word32 GHC.Int.Int32
instance Basement.Cast.Cast GHC.Word.Word64 GHC.Int.Int64
instance Basement.Cast.Cast GHC.Types.Word GHC.Types.Int
instance Basement.Cast.Cast GHC.Types.Word GHC.Word.Word64
instance Basement.Cast.Cast GHC.Word.Word64 GHC.Types.Word
instance Basement.Cast.Cast GHC.Types.Word GHC.Int.Int64
instance Basement.Cast.Cast GHC.Int.Int64 GHC.Types.Word
instance Basement.Cast.Cast GHC.Types.Int GHC.Int.Int64
instance Basement.Cast.Cast GHC.Int.Int64 GHC.Types.Int
instance Basement.Cast.Cast GHC.Types.Int GHC.Word.Word64
instance Basement.Cast.Cast GHC.Word.Word64 GHC.Types.Int
instance Basement.Cast.Cast (Basement.Block.Base.Block a) (Basement.Block.Base.Block GHC.Word.Word8)


-- | A block of memory that contains elements of a type, very similar to an
--   unboxed array but with the key difference:
--   
--   <ul>
--   <li>It doesn't have slicing capability (no cheap take or drop)</li>
--   <li>It consume less memory: 1 Offset, 1 CountOf, 1 Pinning status
--   trimmed</li>
--   <li>It's unpackable in any constructor</li>
--   <li>It uses unpinned memory by default</li>
--   </ul>
--   
--   It should be rarely needed in high level API, but in lowlevel API or
--   some data structure containing lots of unboxed array that will benefit
--   from optimisation.
--   
--   Because it's unpinned, the blocks are compactable / movable, at the
--   expense of making them less friendly to interop with the C layer as
--   address.
--   
--   Note that sadly the bytearray primitive type automatically create a
--   pinned bytearray if the size is bigger than a certain threshold
--   
--   GHC Documentation associated:
--   
--   includes<i>rts</i>storage/Block.h * LARGE_OBJECT_THRESHOLD
--   ((uint32_t)(BLOCK_SIZE * 8 / 10)) * BLOCK_SIZE (1&lt;&lt;BLOCK_SHIFT)
--   
--   includes<i>rts</i>Constant.h * BLOCK_SHIFT 12
module Basement.Block.Mutable

-- | A block of memory containing unpacked bytes representing values of
--   type <tt>ty</tt>
data Block ty
Block :: ByteArray# -> Block ty

-- | A Mutable block of memory containing unpacked bytes representing
--   values of type <tt>ty</tt>
data MutableBlock ty st
MutableBlock :: MutableByteArray# st -> MutableBlock ty st

-- | <i>Deprecated: use mutableLength</i>
mutableLengthSize :: PrimType ty => MutableBlock ty st -> CountOf ty

-- | Return the length of a Mutable Block
--   
--   note: we don't allow resizing yet, so this can remain a pure function
mutableLength :: forall ty st. PrimType ty => MutableBlock ty st -> CountOf ty
mutableLengthBytes :: MutableBlock ty st -> CountOf Word8

-- | Use the <a>Ptr</a> to a mutable block in a safer construct
--   
--   If the block is not pinned, this is a _dangerous_ operation

-- | <i>Deprecated: use withMutablePtr</i>
mutableWithPtr :: PrimMonad prim => MutableBlock ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a

-- | Create a pointer on the beginning of the MutableBlock and call a
--   function <tt>f</tt>.
--   
--   The mutable block can be mutated by the <tt>f</tt> function and the
--   change will be reflected in the mutable block
--   
--   If the mutable block is unpinned, a trampoline buffer is created and
--   the data is only copied when <tt>f</tt> return.
--   
--   it is all-in-all highly inefficient as this cause 2 copies
withMutablePtr :: PrimMonad prim => MutableBlock ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a

-- | Same as <a>withMutablePtr</a> but allow to specify 2 optimisations
--   which is only useful when the MutableBlock is unpinned and need a
--   pinned trampoline to be called safely.
--   
--   If skipCopy is True, then the first copy which happen before the call
--   to <tt>f</tt>, is skipped. The Ptr is now effectively pointing to
--   uninitialized data in a new mutable Block.
--   
--   If skipCopyBack is True, then the second copy which happen after the
--   call to <tt>f</tt>, is skipped. Then effectively in the case of a
--   trampoline being used the memory changed by <tt>f</tt> will not be
--   reflected in the original Mutable Block.
--   
--   If using the wrong parameters, it will lead to difficult to debug
--   issue of corrupted buffer which only present themselves with certain
--   Mutable Block that happened to have been allocated unpinned.
--   
--   If unsure use <a>withMutablePtr</a>, which default to *not* skip any
--   copy.
withMutablePtrHint :: forall ty prim a. PrimMonad prim => Bool -> Bool -> MutableBlock ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a

-- | Create a new unpinned mutable block of a specific N size of
--   <tt>ty</tt> elements
--   
--   If the size exceeds a GHC-defined threshold, then the memory will be
--   pinned. To be certain about pinning status with small size, use
--   <a>newPinned</a>
new :: forall prim ty. (PrimMonad prim, PrimType ty) => CountOf ty -> prim (MutableBlock ty (PrimState prim))

-- | Create a new pinned mutable block of a specific N size of <tt>ty</tt>
--   elements
newPinned :: forall prim ty. (PrimMonad prim, PrimType ty) => CountOf ty -> prim (MutableBlock ty (PrimState prim))
mutableEmpty :: PrimMonad prim => prim (MutableBlock ty (PrimState prim))

-- | Set all mutable block element to a value
iterSet :: (PrimType ty, PrimMonad prim) => (Offset ty -> ty) -> MutableBlock ty (PrimState prim) -> prim ()

-- | read a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
read :: (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> prim ty

-- | Write to a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
write :: (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | Create a new mutable block of a specific size in bytes.
--   
--   Note that no checks are made to see if the size in bytes is compatible
--   with the size of the underlaying element <tt>ty</tt> in the block.
--   
--   use <a>new</a> if unsure
unsafeNew :: PrimMonad prim => PinnedStatus -> CountOf Word8 -> prim (MutableBlock ty (PrimState prim))

-- | write to a cell in a mutable block without bounds checking.
--   
--   Writing with invalid bounds will corrupt memory and your program will
--   become unreliable. use <tt>write</tt> if unsure.
unsafeWrite :: (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | read from a cell in a mutable block without bounds checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <tt>read</tt> if unsure.
unsafeRead :: (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> prim ty

-- | Freeze a mutable block into a block.
--   
--   If the mutable block is still use after freeze, then the modification
--   will be reflected in an unexpected way in the Block.
unsafeFreeze :: PrimMonad prim => MutableBlock ty (PrimState prim) -> prim (Block ty)

-- | Thaw an immutable block.
--   
--   If the immutable block is modified, then the original immutable block
--   will be modified too, but lead to unexpected results when querying
unsafeThaw :: (PrimType ty, PrimMonad prim) => Block ty -> prim (MutableBlock ty (PrimState prim))

-- | Copy a number of elements from an array to another array with offsets
unsafeCopyElements :: forall prim ty. (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> MutableBlock ty (PrimState prim) -> Offset ty -> CountOf ty -> prim ()
unsafeCopyElementsRO :: forall prim ty. (PrimMonad prim, PrimType ty) => MutableBlock ty (PrimState prim) -> Offset ty -> Block ty -> Offset ty -> CountOf ty -> prim ()

-- | Copy a number of bytes from a MutableBlock to another MutableBlock
--   with specific byte offsets
unsafeCopyBytes :: forall prim ty. PrimMonad prim => MutableBlock ty (PrimState prim) -> Offset Word8 -> MutableBlock ty (PrimState prim) -> Offset Word8 -> CountOf Word8 -> prim ()

-- | Copy a number of bytes from a Block to a MutableBlock with specific
--   byte offsets
unsafeCopyBytesRO :: forall prim ty. PrimMonad prim => MutableBlock ty (PrimState prim) -> Offset Word8 -> Block ty -> Offset Word8 -> CountOf Word8 -> prim ()

-- | Copy a number of bytes from a Ptr to a MutableBlock with specific byte
--   offsets
unsafeCopyBytesPtr :: forall prim ty. PrimMonad prim => MutableBlock ty (PrimState prim) -> Offset Word8 -> Ptr ty -> CountOf Word8 -> prim ()

-- | Copy from a pointer, <tt>count</tt> elements, into the Mutable Block
--   at a starting offset <tt>ofs</tt>
--   
--   if the source pointer is invalid (size or bad allocation), bad things
--   will happen
copyFromPtr :: forall prim ty. (PrimMonad prim, PrimType ty) => Ptr ty -> MutableBlock ty (PrimState prim) -> Offset ty -> CountOf ty -> prim ()

-- | Copy all the block content to the memory starting at the destination
--   address
--   
--   If the destination pointer is invalid (size or bad allocation), bad
--   things will happen
copyToPtr :: forall ty prim. (PrimType ty, PrimMonad prim) => MutableBlock ty (PrimState prim) -> Offset ty -> Ptr ty -> CountOf ty -> prim ()


-- | A block of memory that contains elements of a type, very similar to an
--   unboxed array but with the key difference:
--   
--   <ul>
--   <li>It doesn't have slicing capability (no cheap take or drop)</li>
--   <li>It consume less memory: 1 Offset, 1 CountOf</li>
--   <li>It's unpackable in any constructor</li>
--   <li>It uses unpinned memory by default</li>
--   </ul>
module Basement.Block

-- | A block of memory containing unpacked bytes representing values of
--   type <tt>ty</tt>
data Block ty
Block :: ByteArray# -> Block ty

-- | A Mutable block of memory containing unpacked bytes representing
--   values of type <tt>ty</tt>
data MutableBlock ty st
MutableBlock :: MutableByteArray# st -> MutableBlock ty st
length :: forall ty. PrimType ty => Block ty -> CountOf ty

-- | Thaw an immutable block.
--   
--   If the immutable block is modified, then the original immutable block
--   will be modified too, but lead to unexpected results when querying
unsafeThaw :: (PrimType ty, PrimMonad prim) => Block ty -> prim (MutableBlock ty (PrimState prim))

-- | Freeze a mutable block into a block.
--   
--   If the mutable block is still use after freeze, then the modification
--   will be reflected in an unexpected way in the Block.
unsafeFreeze :: PrimMonad prim => MutableBlock ty (PrimState prim) -> prim (Block ty)

-- | Return the element at a specific index from an array without bounds
--   checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <tt>index</tt> if unsure.
unsafeIndex :: forall ty. PrimType ty => Block ty -> Offset ty -> ty

-- | Thaw a Block into a MutableBlock
--   
--   the Block is not modified, instead a new Mutable Block is created and
--   its content is copied to the mutable block
thaw :: (PrimMonad prim, PrimType ty) => Block ty -> prim (MutableBlock ty (PrimState prim))

-- | Freeze a MutableBlock into a Block, copying all the data
--   
--   If the data is modified in the mutable block after this call, then the
--   immutable Block resulting is not impacted.
freeze :: (PrimType ty, PrimMonad prim) => MutableBlock ty (PrimState prim) -> prim (Block ty)

-- | Copy every cells of an existing Block to a new Block
copy :: PrimType ty => Block ty -> Block ty

-- | Unsafely recast an UArray containing <tt>a</tt> to an UArray
--   containing <tt>b</tt>
--   
--   The offset and size are converted from units of <tt>a</tt> to units of
--   <tt>b</tt>, but no check are performed to make sure this is
--   compatible.
--   
--   use <a>cast</a> if unsure.
unsafeCast :: PrimType b => Block a -> Block b

-- | Cast a Block of <tt>a</tt> to a Block of <tt>b</tt>
--   
--   The requirement is that the size of type <tt>a</tt> need to be a
--   multiple or dividend of the size of type <tt>b</tt>.
--   
--   If this requirement is not met, the InvalidRecast exception is thrown
cast :: forall a b. (PrimType a, PrimType b) => Block a -> Block b

-- | Create an empty block of memory
empty :: Block ty

-- | Create a new array of size <tt>n by settings each cells through the
--   function </tt>f.
create :: forall ty. PrimType ty => CountOf ty -> (Offset ty -> ty) -> Block ty
isPinned :: Block ty -> PinnedStatus
isMutablePinned :: MutableBlock s ty -> PinnedStatus
singleton :: PrimType ty => ty -> Block ty
replicate :: PrimType ty => CountOf ty -> ty -> Block ty

-- | Return the element at a specific index from an array.
--   
--   If the index @n is out of bounds, an error is raised.
index :: PrimType ty => Block ty -> Offset ty -> ty

-- | Map all element <tt>a</tt> from a block to a new block of <tt>b</tt>
map :: (PrimType a, PrimType b) => (a -> b) -> Block a -> Block b
foldl' :: PrimType ty => (a -> ty -> a) -> a -> Block ty -> a
foldr :: PrimType ty => (ty -> a -> a) -> a -> Block ty -> a
foldl1' :: PrimType ty => (ty -> ty -> ty) -> NonEmpty (Block ty) -> ty
foldr1 :: PrimType ty => (ty -> ty -> ty) -> NonEmpty (Block ty) -> ty
cons :: PrimType ty => ty -> Block ty -> Block ty
snoc :: PrimType ty => Block ty -> ty -> Block ty
uncons :: PrimType ty => Block ty -> Maybe (ty, Block ty)
unsnoc :: PrimType ty => Block ty -> Maybe (Block ty, ty)
sub :: PrimType ty => Block ty -> Offset ty -> Offset ty -> Block ty
splitAt :: PrimType ty => CountOf ty -> Block ty -> (Block ty, Block ty)
revSplitAt :: PrimType ty => CountOf ty -> Block ty -> (Block ty, Block ty)
splitOn :: PrimType ty => (ty -> Bool) -> Block ty -> [Block ty]
break :: PrimType ty => (ty -> Bool) -> Block ty -> (Block ty, Block ty)
breakEnd :: PrimType ty => (ty -> Bool) -> Block ty -> (Block ty, Block ty)
span :: PrimType ty => (ty -> Bool) -> Block ty -> (Block ty, Block ty)
elem :: PrimType ty => ty -> Block ty -> Bool
all :: PrimType ty => (ty -> Bool) -> Block ty -> Bool
any :: PrimType ty => (ty -> Bool) -> Block ty -> Bool
find :: PrimType ty => (ty -> Bool) -> Block ty -> Maybe ty
filter :: PrimType ty => (ty -> Bool) -> Block ty -> Block ty
reverse :: forall ty. PrimType ty => Block ty -> Block ty
sortBy :: PrimType ty => (ty -> ty -> Ordering) -> Block ty -> Block ty
intersperse :: forall ty. PrimType ty => ty -> Block ty -> Block ty

-- | Freeze a chunk of memory pointed, of specific size into a new unboxed
--   array
createFromPtr :: PrimType ty => Ptr ty -> CountOf ty -> IO (Block ty)

-- | Copy all the block content to the memory starting at the destination
--   address
unsafeCopyToPtr :: forall ty prim. PrimMonad prim => Block ty -> Ptr ty -> prim ()

-- | Get a Ptr pointing to the data in the Block.
--   
--   Since a Block is immutable, this Ptr shouldn't be to use to modify the
--   contents
--   
--   If the Block is pinned, then its address is returned as is, however if
--   it's unpinned, a pinned copy of the Block is made before getting the
--   address.
withPtr :: PrimMonad prim => Block ty -> (Ptr ty -> prim a) -> prim a
instance (Basement.Monad.PrimMonad prim, st GHC.Types.~ Basement.Monad.PrimState prim, Basement.PrimType.PrimType ty) => Basement.Alg.Class.RandomAccess (Basement.Block.Base.MutableBlock ty st) prim ty
instance Basement.PrimType.PrimType ty => Basement.Alg.Class.Indexable (Basement.Block.Base.Block ty) ty
instance Basement.Alg.Class.Indexable (Basement.Block.Base.Block GHC.Word.Word8) GHC.Word.Word64


-- | A Nat-sized version of Block
module Basement.Sized.Block

-- | Sized version of <a>Block</a>
data BlockN (n :: Nat) a
data MutableBlockN (n :: Nat) ty st
length :: forall n ty. (KnownNat n, Countable ty n) => BlockN n ty -> CountOf ty
lengthBytes :: forall n ty. PrimType ty => BlockN n ty -> CountOf Word8
toBlockN :: forall n ty. (PrimType ty, KnownNat n, Countable ty n) => Block ty -> Maybe (BlockN n ty)
toBlock :: BlockN n ty -> Block ty

-- | Create a new unpinned mutable block of a specific N size of
--   <tt>ty</tt> elements
--   
--   If the size exceeds a GHC-defined threshold, then the memory will be
--   pinned. To be certain about pinning status with small size, use
--   <a>newPinned</a>
new :: forall n ty prim. (PrimType ty, KnownNat n, Countable ty n, PrimMonad prim) => prim (MutableBlockN n ty (PrimState prim))

-- | Create a new pinned mutable block of a specific N size of <tt>ty</tt>
--   elements
newPinned :: forall n ty prim. (PrimType ty, KnownNat n, Countable ty n, PrimMonad prim) => prim (MutableBlockN n ty (PrimState prim))
singleton :: PrimType ty => ty -> BlockN 1 ty
replicate :: forall n ty. (KnownNat n, Countable ty n, PrimType ty) => ty -> BlockN n ty
thaw :: (KnownNat n, PrimMonad prim, PrimType ty) => BlockN n ty -> prim (MutableBlockN n ty (PrimState prim))
freeze :: (PrimMonad prim, PrimType ty, Countable ty n) => MutableBlockN n ty (PrimState prim) -> prim (BlockN n ty)
index :: forall i n ty. PrimType ty => BlockN n ty -> Offset ty -> ty
indexStatic :: forall i n ty. (KnownNat i, CmpNat i n ~ 'LT, PrimType ty, Offsetable ty i) => BlockN n ty -> ty
map :: (PrimType a, PrimType b) => (a -> b) -> BlockN n a -> BlockN n b
foldl' :: PrimType ty => (a -> ty -> a) -> a -> BlockN n ty -> a
foldr :: PrimType ty => (ty -> a -> a) -> a -> BlockN n ty -> a
cons :: PrimType ty => ty -> BlockN n ty -> BlockN (n + 1) ty
snoc :: PrimType ty => BlockN n ty -> ty -> BlockN (n + 1) ty
elem :: PrimType ty => ty -> BlockN n ty -> Bool
sub :: forall i j n ty. ((i <=? n) ~ 'True, (j <=? n) ~ 'True, (i <=? j) ~ 'True, PrimType ty, KnownNat i, KnownNat j, Offsetable ty i, Offsetable ty j) => BlockN n ty -> BlockN (j - i) ty
uncons :: forall n ty. (CmpNat 0 n ~ 'LT, PrimType ty, KnownNat n, Offsetable ty n) => BlockN n ty -> (ty, BlockN (n - 1) ty)
unsnoc :: forall n ty. (CmpNat 0 n ~ 'LT, KnownNat n, PrimType ty, Offsetable ty n) => BlockN n ty -> (BlockN (n - 1) ty, ty)
splitAt :: forall i n ty. (CmpNat i n ~ 'LT, PrimType ty, KnownNat i, Countable ty i) => BlockN n ty -> (BlockN i ty, BlockN (n - i) ty)
all :: PrimType ty => (ty -> Bool) -> BlockN n ty -> Bool
any :: PrimType ty => (ty -> Bool) -> BlockN n ty -> Bool
find :: PrimType ty => (ty -> Bool) -> BlockN n ty -> Maybe ty
reverse :: PrimType ty => BlockN n ty -> BlockN n ty
sortBy :: PrimType ty => (ty -> ty -> Ordering) -> BlockN n ty -> BlockN n ty
intersperse :: (CmpNat n 1 ~ 'GT, PrimType ty) => ty -> BlockN n ty -> BlockN ((n + n) - 1) ty

-- | Get a Ptr pointing to the data in the Block.
--   
--   Since a Block is immutable, this Ptr shouldn't be to use to modify the
--   contents
--   
--   If the Block is pinned, then its address is returned as is, however if
--   it's unpinned, a pinned copy of the Block is made before getting the
--   address.
withPtr :: (PrimMonad prim, KnownNat n) => BlockN n ty -> (Ptr ty -> prim a) -> prim a

-- | Create a pointer on the beginning of the MutableBlock and call a
--   function <tt>f</tt>.
--   
--   The mutable block can be mutated by the <tt>f</tt> function and the
--   change will be reflected in the mutable block
--   
--   If the mutable block is unpinned, a trampoline buffer is created and
--   the data is only copied when <tt>f</tt> return.
--   
--   it is all-in-all highly inefficient as this cause 2 copies
withMutablePtr :: (PrimMonad prim, KnownNat n) => MutableBlockN n ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a

-- | Same as <a>withMutablePtr</a> but allow to specify 2 optimisations
--   which is only useful when the MutableBlock is unpinned and need a
--   pinned trampoline to be called safely.
--   
--   If skipCopy is True, then the first copy which happen before the call
--   to <tt>f</tt>, is skipped. The Ptr is now effectively pointing to
--   uninitialized data in a new mutable Block.
--   
--   If skipCopyBack is True, then the second copy which happen after the
--   call to <tt>f</tt>, is skipped. Then effectively in the case of a
--   trampoline being used the memory changed by <tt>f</tt> will not be
--   reflected in the original Mutable Block.
--   
--   If using the wrong parameters, it will lead to difficult to debug
--   issue of corrupted buffer which only present themselves with certain
--   Mutable Block that happened to have been allocated unpinned.
--   
--   If unsure use <a>withMutablePtr</a>, which default to *not* skip any
--   copy.
withMutablePtrHint :: forall n ty prim a. (PrimMonad prim, KnownNat n) => Bool -> Bool -> MutableBlockN n ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a
cast :: forall n m a b. (PrimType a, PrimType b, KnownNat n, KnownNat m, (PrimSize b * m) ~ (PrimSize a * n)) => BlockN n a -> BlockN m b
mutableCast :: forall n m a b st. (PrimType a, PrimType b, KnownNat n, KnownNat m, (PrimSize b * m) ~ (PrimSize a * n)) => MutableBlockN n a st -> MutableBlockN m b st
instance (Basement.PrimType.PrimType a, GHC.Classes.Ord a) => GHC.Classes.Ord (Basement.Sized.Block.BlockN n a)
instance (GHC.TypeNats.KnownNat n, Data.Data.Data a) => Data.Data.Data (Basement.Sized.Block.BlockN n a)
instance (Basement.PrimType.PrimType a, GHC.Show.Show a) => GHC.Show.Show (Basement.Sized.Block.BlockN n a)
instance Basement.PrimType.PrimType a => GHC.Classes.Eq (Basement.Sized.Block.BlockN n a)
instance Basement.NormalForm.NormalForm (Basement.Sized.Block.BlockN n a)


-- | A Nat-sized version of Block
module Basement.BlockN


module Basement.Bits

-- | operation over bits
class BitOps bits
(.&.) :: BitOps bits => bits -> bits -> bits
(.|.) :: BitOps bits => bits -> bits -> bits
(.^.) :: BitOps bits => bits -> bits -> bits
(.<<.) :: BitOps bits => bits -> CountOf Bool -> bits
(.>>.) :: BitOps bits => bits -> CountOf Bool -> bits

-- | construct a bit set with the bit at the given index set.
bit :: BitOps bits => Offset Bool -> bits

-- | construct a bit set with the bit at the given index set.
bit :: (BitOps bits, Integral bits) => Offset Bool -> bits

-- | test the bit at the given index is set
isBitSet :: BitOps bits => bits -> Offset Bool -> Bool

-- | test the bit at the given index is set
isBitSet :: (BitOps bits, Integral bits, Eq bits) => bits -> Offset Bool -> Bool

-- | set the bit at the given index
setBit :: BitOps bits => bits -> Offset Bool -> bits

-- | set the bit at the given index
setBit :: (BitOps bits, Integral bits) => bits -> Offset Bool -> bits

-- | clear the bit at the given index
clearBit :: BitOps bits => bits -> Offset Bool -> bits

-- | clear the bit at the given index
clearBit :: (BitOps bits, FiniteBitsOps bits) => bits -> Offset Bool -> bits
infixl 7 .&.
infixl 5 .|.
infixl 6 .^.
infixl 8 .<<.
infixl 8 .>>.

-- | operation over finite bits
class FiniteBitsOps bits

-- | get the number of bits in the given object
numberOfBits :: FiniteBitsOps bits => bits -> CountOf Bool

-- | rotate the given bit set.
rotateL :: FiniteBitsOps bits => bits -> CountOf Bool -> bits

-- | rotate the given bit set.
rotateR :: FiniteBitsOps bits => bits -> CountOf Bool -> bits

-- | count of number of bit set to 1 in the given bit set.
popCount :: FiniteBitsOps bits => bits -> CountOf Bool

-- | reverse all bits in the argument
bitFlip :: FiniteBitsOps bits => bits -> bits

-- | count of the number of leading zeros
countLeadingZeros :: FiniteBitsOps bits => bits -> CountOf Bool

-- | count of the number of leading zeros
countLeadingZeros :: (FiniteBitsOps bits, BitOps bits) => bits -> CountOf Bool

-- | count of the number of trailing zeros
countTrailingZeros :: FiniteBitsOps bits => bits -> CountOf Bool

-- | count of the number of trailing zeros
countTrailingZeros :: (FiniteBitsOps bits, BitOps bits) => bits -> CountOf Bool
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | Bool set of <tt>n</tt> bits.
data Bits (n :: Nat)

-- | convert the given <a>Natural</a> into a <a>Bits</a> of size <tt>n</tt>
--   
--   if bits that are not within the boundaries of the 'Bits n' will be
--   truncated.
toBits :: SizeValid n => Natural -> Bits n

-- | construct a <a>Bits</a> with all bits set.
--   
--   this function is equivalet to <a>maxBound</a>
allOne :: forall n. SizeValid n => Bits n
instance GHC.Classes.Ord (Basement.Bits.Bits n)
instance GHC.Classes.Eq (Basement.Bits.Bits n)
instance GHC.Show.Show (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => GHC.Enum.Enum (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => GHC.Enum.Bounded (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => Basement.Numerical.Additive.Additive (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => Basement.Numerical.Subtractive.Subtractive (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => Basement.Numerical.Multiplicative.Multiplicative (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => Basement.Numerical.Multiplicative.IDivisible (Basement.Bits.Bits n)
instance Basement.Bits.SizeValid n => Basement.Bits.BitOps (Basement.Bits.Bits n)
instance (Basement.Bits.SizeValid n, Basement.Nat.NatWithinBound (Basement.Types.OffsetSize.CountOf GHC.Types.Bool) n) => Basement.Bits.FiniteBitsOps (Basement.Bits.Bits n)
instance Basement.Bits.FiniteBitsOps GHC.Types.Bool
instance Basement.Bits.BitOps GHC.Types.Bool
instance Basement.Bits.FiniteBitsOps GHC.Word.Word8
instance Basement.Bits.BitOps GHC.Word.Word8
instance Basement.Bits.FiniteBitsOps GHC.Word.Word16
instance Basement.Bits.BitOps GHC.Word.Word16
instance Basement.Bits.FiniteBitsOps GHC.Word.Word32
instance Basement.Bits.BitOps GHC.Word.Word32
instance Basement.Bits.FiniteBitsOps GHC.Types.Word
instance Basement.Bits.BitOps GHC.Types.Word
instance Basement.Bits.FiniteBitsOps GHC.Word.Word64
instance Basement.Bits.BitOps GHC.Word.Word64
instance Basement.Bits.FiniteBitsOps Basement.Types.Word128.Word128
instance Basement.Bits.BitOps Basement.Types.Word128.Word128
instance Basement.Bits.FiniteBitsOps Basement.Types.Word256.Word256
instance Basement.Bits.BitOps Basement.Types.Word256.Word256
instance Basement.Bits.FiniteBitsOps GHC.Int.Int8
instance Basement.Bits.BitOps GHC.Int.Int8
instance Basement.Bits.FiniteBitsOps GHC.Int.Int16
instance Basement.Bits.BitOps GHC.Int.Int16
instance Basement.Bits.FiniteBitsOps GHC.Int.Int32
instance Basement.Bits.BitOps GHC.Int.Int32
instance Basement.Bits.FiniteBitsOps GHC.Int.Int64
instance Basement.Bits.BitOps GHC.Int.Int64


-- | Simple boxed array abstraction
module Basement.BoxedArray

-- | Array of a
data Array a

-- | Mutable Array of a
data MArray a st
empty :: Array a
length :: Array a -> CountOf a

-- | return the numbers of elements in a mutable array
mutableLength :: MArray ty st -> Int

-- | Copy the element to a new element array
copy :: Array ty -> Array ty

-- | Copy <tt>n</tt> sequential elements from the specified offset in a
--   source array to the specified position in a destination array.
--   
--   This function does not check bounds. Accessing invalid memory can
--   return unpredictable and invalid values.
unsafeCopyAtRO :: PrimMonad prim => MArray ty (PrimState prim) -> Offset ty -> Array ty -> Offset ty -> CountOf ty -> prim ()

-- | Thaw an array to a mutable array.
--   
--   the array is not modified, instead a new mutable array is created and
--   every values is copied, before returning the mutable array.
thaw :: PrimMonad prim => Array ty -> prim (MArray ty (PrimState prim))

-- | Create a new mutable array of size @n.
--   
--   all the cells are uninitialized and could contains invalid values.
--   
--   All mutable arrays are allocated on a 64 bits aligned addresses and
--   always contains a number of bytes multiples of 64 bits.
new :: PrimMonad prim => CountOf ty -> prim (MArray ty (PrimState prim))

-- | Create a new array of size <tt>n by settings each cells through the
--   function </tt>f.
create :: forall ty. CountOf ty -> (Offset ty -> ty) -> Array ty

-- | Freeze a mutable array into an array.
--   
--   the MArray must not be changed after freezing.
unsafeFreeze :: PrimMonad prim => MArray ty (PrimState prim) -> prim (Array ty)

-- | Thaw an immutable array.
--   
--   The Array must not be used after thawing.
unsafeThaw :: PrimMonad prim => Array ty -> prim (MArray ty (PrimState prim))
freeze :: PrimMonad prim => MArray ty (PrimState prim) -> prim (Array ty)

-- | write to a cell in a mutable array without bounds checking.
--   
--   Writing with invalid bounds will corrupt memory and your program will
--   become unreliable. use <a>write</a> if unsure.
unsafeWrite :: PrimMonad prim => MArray ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | read from a cell in a mutable array without bounds checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <a>read</a> if unsure.
unsafeRead :: PrimMonad prim => MArray ty (PrimState prim) -> Offset ty -> prim ty

-- | Return the element at a specific index from an array without bounds
--   checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <a>index</a> if unsure.
unsafeIndex :: Array ty -> Offset ty -> ty

-- | Write to a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
write :: PrimMonad prim => MArray ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | read a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
read :: PrimMonad prim => MArray ty (PrimState prim) -> Offset ty -> prim ty

-- | Return the element at a specific index from an array.
--   
--   If the index @n is out of bounds, an error is raised.
index :: Array ty -> Offset ty -> ty
singleton :: ty -> Array ty
replicate :: CountOf ty -> ty -> Array ty
null :: Array ty -> Bool
take :: CountOf ty -> Array ty -> Array ty
drop :: CountOf ty -> Array ty -> Array ty
splitAt :: CountOf ty -> Array ty -> (Array ty, Array ty)
revTake :: CountOf ty -> Array ty -> Array ty
revDrop :: CountOf ty -> Array ty -> Array ty
revSplitAt :: CountOf ty -> Array ty -> (Array ty, Array ty)
splitOn :: (ty -> Bool) -> Array ty -> [Array ty]
sub :: Array ty -> Offset ty -> Offset ty -> Array ty
intersperse :: ty -> Array ty -> Array ty
span :: (ty -> Bool) -> Array ty -> (Array ty, Array ty)
spanEnd :: (ty -> Bool) -> Array ty -> (Array ty, Array ty)
break :: (ty -> Bool) -> Array ty -> (Array ty, Array ty)
breakEnd :: (ty -> Bool) -> Array ty -> (Array ty, Array ty)
mapFromUnboxed :: PrimType a => (a -> b) -> UArray a -> Array b
mapToUnboxed :: PrimType b => (a -> b) -> Array a -> UArray b
cons :: ty -> Array ty -> Array ty
snoc :: Array ty -> ty -> Array ty
uncons :: Array ty -> Maybe (ty, Array ty)
unsnoc :: Array ty -> Maybe (Array ty, ty)
sortBy :: forall ty. (ty -> ty -> Ordering) -> Array ty -> Array ty
filter :: forall ty. (ty -> Bool) -> Array ty -> Array ty
reverse :: Array ty -> Array ty
elem :: Eq ty => ty -> Array ty -> Bool
find :: (ty -> Bool) -> Array ty -> Maybe ty
foldl' :: (a -> ty -> a) -> a -> Array ty -> a
foldr :: (ty -> a -> a) -> a -> Array ty -> a
foldl1' :: (ty -> ty -> ty) -> NonEmpty (Array ty) -> ty
foldr1 :: (ty -> ty -> ty) -> NonEmpty (Array ty) -> ty
all :: (ty -> Bool) -> Array ty -> Bool
any :: (ty -> Bool) -> Array ty -> Bool
isPrefixOf :: Eq ty => Array ty -> Array ty -> Bool
isSuffixOf :: Eq ty => Array ty -> Array ty -> Bool
builderAppend :: PrimMonad state => ty -> Builder (Array ty) (MArray ty) ty state err ()
builderBuild :: PrimMonad m => Int -> Builder (Array ty) (MArray ty) ty m err () -> m (Either err (Array ty))
builderBuild_ :: PrimMonad m => Int -> Builder (Array ty) (MArray ty) ty m () () -> m (Array ty)
instance (Basement.Monad.PrimMonad prim, st GHC.Types.~ Basement.Monad.PrimState prim) => Basement.Alg.Class.RandomAccess (Basement.BoxedArray.MArray ty st) prim ty
instance Data.Data.Data ty => Data.Data.Data (Basement.BoxedArray.Array ty)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (Basement.BoxedArray.Array a)
instance GHC.Base.Functor Basement.BoxedArray.Array
instance GHC.Base.Semigroup (Basement.BoxedArray.Array a)
instance GHC.Base.Monoid (Basement.BoxedArray.Array a)
instance GHC.Show.Show a => GHC.Show.Show (Basement.BoxedArray.Array a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.BoxedArray.Array a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Basement.BoxedArray.Array a)
instance GHC.IsList.IsList (Basement.BoxedArray.Array ty)

module Basement.Sized.Vect
data Vect (n :: Nat) a
data MVect (n :: Nat) ty st
unVect :: Vect n a -> Array a
toVect :: forall n ty. (KnownNat n, Countable ty n) => Array ty -> Maybe (Vect n ty)
empty :: Vect 0 ty
singleton :: ty -> Vect 1 ty
replicate :: forall n ty. (KnownNat n, Countable ty n) => ty -> Vect n ty
thaw :: (KnownNat n, PrimMonad prim) => Vect n ty -> prim (MVect n ty (PrimState prim))
freeze :: (PrimMonad prim, Countable ty n) => MVect n ty (PrimState prim) -> prim (Vect n ty)
index :: Vect n ty -> Offset ty -> ty
map :: (a -> b) -> Vect n a -> Vect n b
foldl' :: (a -> ty -> a) -> a -> Vect n ty -> a
foldr :: (ty -> a -> a) -> a -> Vect n ty -> a
cons :: ty -> Vect n ty -> Vect (n + 1) ty
snoc :: Vect n ty -> ty -> Vect (n + 1) ty
elem :: Eq ty => ty -> Vect n ty -> Bool
sub :: forall i j n ty. ((i <=? n) ~ 'True, (j <=? n) ~ 'True, (i <=? j) ~ 'True, KnownNat i, KnownNat j, Offsetable ty i, Offsetable ty j) => Vect n ty -> Vect (j - i) ty
uncons :: forall n ty. (CmpNat 0 n ~ 'LT, KnownNat n, Offsetable ty n) => Vect n ty -> (ty, Vect (n - 1) ty)
unsnoc :: forall n ty. (CmpNat 0 n ~ 'LT, KnownNat n, Offsetable ty n) => Vect n ty -> (Vect (n - 1) ty, ty)
splitAt :: forall i n ty. (CmpNat i n ~ 'LT, KnownNat i, Countable ty i) => Vect n ty -> (Vect i ty, Vect (n - i) ty)
all :: (ty -> Bool) -> Vect n ty -> Bool
any :: (ty -> Bool) -> Vect n ty -> Bool
find :: (ty -> Bool) -> Vect n ty -> Maybe ty
reverse :: Vect n ty -> Vect n ty
sortBy :: (ty -> ty -> Ordering) -> Vect n ty -> Vect n ty
intersperse :: CmpNat n 1 ~ 'GT => ty -> Vect n ty -> Vect ((n + n) - 1) ty
instance GHC.Show.Show a => GHC.Show.Show (Basement.Sized.Vect.Vect n a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Basement.Sized.Vect.Vect n a)
instance Basement.NormalForm.NormalForm a => Basement.NormalForm.NormalForm (Basement.Sized.Vect.Vect n a)
instance GHC.Base.Functor (Basement.Sized.Vect.Vect n)


-- | A simple array abstraction that allow to use typed array of bytes
--   where the array is pinned in memory to allow easy use with Foreign
--   interfaces, ByteString and always aligned to 64 bytes.
module Basement.UArray.Mutable

-- | A Mutable array of types built on top of GHC primitive.
--   
--   Element in this array can be modified in place.
data MUArray ty st
MUArray :: {-# UNPACK #-} !Offset ty -> {-# UNPACK #-} !CountOf ty -> !MUArrayBackend ty st -> MUArray ty st
sizeInMutableBytesOfContent :: forall ty s. PrimType ty => MUArray ty s -> CountOf Word8

-- | return the numbers of elements in a mutable array
mutableLength :: PrimType ty => MUArray ty st -> CountOf ty
mutableOffset :: MUArray ty st -> Offset ty
mutableSame :: MUArray ty st -> MUArray ty st -> Bool
onMutableBackend :: PrimMonad prim => (MutableBlock ty (PrimState prim) -> prim a) -> (FinalPtr ty -> prim a) -> MUArray ty (PrimState prim) -> prim a

-- | Create a new mutable array of size @n.
--   
--   When memory for a new array is allocated, we decide if that memory
--   region should be pinned (will not be copied around by GC) or unpinned
--   (can be moved around by GC) depending on its size.
--   
--   You can change the threshold value used by setting the environment
--   variable <tt>HS_FOUNDATION_UARRAY_UNPINNED_MAX</tt>.
new :: (PrimMonad prim, PrimType ty) => CountOf ty -> prim (MUArray ty (PrimState prim))

-- | Create a new pinned mutable array of size @n.
--   
--   all the cells are uninitialized and could contains invalid values.
--   
--   All mutable arrays are allocated on a 64 bits aligned addresses
newPinned :: forall prim ty. (PrimMonad prim, PrimType ty) => CountOf ty -> prim (MUArray ty (PrimState prim))
newNative :: (PrimMonad prim, PrimType ty) => CountOf ty -> (MutableBlock ty (PrimState prim) -> prim a) -> prim (a, MUArray ty (PrimState prim))

-- | Same as newNative but expect no extra return value from f
newNative_ :: (PrimMonad prim, PrimType ty) => CountOf ty -> (MutableBlock ty (PrimState prim) -> prim ()) -> prim (MUArray ty (PrimState prim))
mutableForeignMem :: (PrimMonad prim, PrimType ty) => FinalPtr ty -> Int -> prim (MUArray ty (PrimState prim))

-- | Copy a number of elements from an array to another array with offsets
copyAt :: forall prim ty. (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> MUArray ty (PrimState prim) -> Offset ty -> CountOf ty -> prim ()

-- | Copy from a pointer, <tt>count</tt> elements, into the mutable array
copyFromPtr :: forall prim ty. (PrimMonad prim, PrimType ty) => Ptr ty -> CountOf ty -> MUArray ty (PrimState prim) -> prim ()

-- | Copy all the block content to the memory starting at the destination
--   address
copyToPtr :: forall ty prim. (PrimType ty, PrimMonad prim) => MUArray ty (PrimState prim) -> Ptr ty -> prim ()
sub :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Int -> Int -> prim (MUArray ty (PrimState prim))

-- | write to a cell in a mutable array without bounds checking.
--   
--   Writing with invalid bounds will corrupt memory and your program will
--   become unreliable. use <tt>write</tt> if unsure.
unsafeWrite :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | read from a cell in a mutable array without bounds checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <tt>read</tt> if unsure.
unsafeRead :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> prim ty

-- | Write to a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
write :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> ty -> prim ()

-- | read a cell in a mutable array.
--   
--   If the index is out of bounds, an error is raised.
read :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> prim ty

-- | Create a pointer on the beginning of the mutable array and call a
--   function <tt>f</tt>.
--   
--   The mutable buffer can be mutated by the <tt>f</tt> function and the
--   change will be reflected in the mutable array
--   
--   If the mutable array is unpinned, a trampoline buffer is created and
--   the data is only copied when <tt>f</tt> return.
withMutablePtr :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a
withMutablePtrHint :: forall ty prim a. (PrimMonad prim, PrimType ty) => Bool -> Bool -> MUArray ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a


-- | An unboxed array of primitive types
--   
--   All the cells in the array are in one chunk of contiguous memory.
module Basement.UArray

-- | An array of type built on top of GHC primitive.
--   
--   The elements need to have fixed sized and the representation is a
--   packed contiguous array in memory that can easily be passed to foreign
--   interface
data UArray ty
UArray :: {-# UNPACK #-} !Offset ty -> {-# UNPACK #-} !CountOf ty -> !UArrayBackend ty -> UArray ty

-- | Represent the accessor for types that can be stored in the UArray and
--   MUArray.
--   
--   Types need to be a instance of storable and have fixed sized.
class Eq ty => PrimType ty where {
    
    -- | type level size of the given <tt>ty</tt>
    type PrimSize ty :: Nat;
}

-- | get the size in bytes of a ty element
primSizeInBytes :: PrimType ty => Proxy ty -> CountOf Word8

-- | get the shift size
primShiftToBytes :: PrimType ty => Proxy ty -> Int

-- | return the element stored at a specific index
primBaUIndex :: PrimType ty => ByteArray# -> Offset ty -> ty

-- | Read an element at an index in a mutable array
primMbaURead :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> prim ty

-- | Write an element to a specific cell in a mutable array.
primMbaUWrite :: (PrimType ty, PrimMonad prim) => MutableByteArray# (PrimState prim) -> Offset ty -> ty -> prim ()

-- | Read from Address, without a state. the value read should be
--   considered a constant for all pratical purpose, otherwise bad thing
--   will happens.
primAddrIndex :: PrimType ty => Addr# -> Offset ty -> ty

-- | Read a value from Addr in a specific primitive monad
primAddrRead :: (PrimType ty, PrimMonad prim) => Addr# -> Offset ty -> prim ty

-- | Write a value to Addr in a specific primitive monad
primAddrWrite :: (PrimType ty, PrimMonad prim) => Addr# -> Offset ty -> ty -> prim ()

-- | Copy every cells of an existing array to a new array
copy :: PrimType ty => UArray ty -> UArray ty

-- | Copy <tt>n</tt> sequential elements from the specified offset in a
--   source array to the specified position in a destination array.
--   
--   This function does not check bounds. Accessing invalid memory can
--   return unpredictable and invalid values.
unsafeCopyAtRO :: forall prim ty. (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> UArray ty -> Offset ty -> CountOf ty -> prim ()

-- | Recast an array of type a to an array of b
--   
--   a and b need to have the same size otherwise this raise an async
--   exception
recast :: forall a b. (PrimType a, PrimType b) => UArray a -> UArray b

-- | Unsafely recast an UArray containing <tt>a</tt> to an UArray
--   containing <tt>b</tt>
--   
--   The offset and size are converted from units of <tt>a</tt> to units of
--   <tt>b</tt>, but no check are performed to make sure this is
--   compatible.
--   
--   use <a>recast</a> if unsure.
unsafeRecast :: (PrimType a, PrimType b) => UArray a -> UArray b
length :: UArray ty -> CountOf ty

-- | Freeze a MUArray into a UArray by copying all the content is a
--   pristine new buffer
--   
--   The MUArray in parameter can be still be used after the call without
--   changing the resulting frozen data.
freeze :: (PrimType ty, PrimMonad prim) => MUArray ty (PrimState prim) -> prim (UArray ty)

-- | Freeze a mutable array into an array.
--   
--   the MUArray must not be changed after freezing.
unsafeFreeze :: PrimMonad prim => MUArray ty (PrimState prim) -> prim (UArray ty)

-- | Thaw an array to a mutable array.
--   
--   the array is not modified, instead a new mutable array is created and
--   every values is copied, before returning the mutable array.
thaw :: (PrimMonad prim, PrimType ty) => UArray ty -> prim (MUArray ty (PrimState prim))

-- | Thaw an immutable array.
--   
--   The UArray must not be used after thawing.
unsafeThaw :: (PrimType ty, PrimMonad prim) => UArray ty -> prim (MUArray ty (PrimState prim))

-- | Make an array from a list of elements with a size hint.
--   
--   The list should be of the same size as the hint, as otherwise:
--   
--   <ul>
--   <li>The length of the list is smaller than the hint: the array
--   allocated is of the size of the hint, but is sliced to only represent
--   the valid bits</li>
--   <li>The length of the list is bigger than the hint: The allocated
--   array is the size of the hint, and the list is truncated to fit.</li>
--   </ul>
vFromListN :: forall ty. PrimType ty => CountOf ty -> [ty] -> UArray ty

-- | Create a new mutable array of size @n.
--   
--   When memory for a new array is allocated, we decide if that memory
--   region should be pinned (will not be copied around by GC) or unpinned
--   (can be moved around by GC) depending on its size.
--   
--   You can change the threshold value used by setting the environment
--   variable <tt>HS_FOUNDATION_UARRAY_UNPINNED_MAX</tt>.
new :: (PrimMonad prim, PrimType ty) => CountOf ty -> prim (MUArray ty (PrimState prim))

-- | Create a new array of size <tt>n by settings each cells through the
--   function </tt>f.
create :: forall ty. PrimType ty => CountOf ty -> (Offset ty -> ty) -> UArray ty

-- | Create a pinned array that is filled by a <tt>filler</tt> function
--   (typically an IO call like hGetBuf)
createFromIO :: PrimType ty => CountOf ty -> (Ptr ty -> IO (CountOf ty)) -> IO (UArray ty)

-- | Freeze a chunk of memory pointed, of specific size into a new unboxed
--   array
createFromPtr :: PrimType ty => Ptr ty -> CountOf ty -> IO (UArray ty)
sub :: PrimType ty => UArray ty -> Offset ty -> Offset ty -> UArray ty

-- | Copy all the block content to the memory starting at the destination
--   address
copyToPtr :: forall ty prim. (PrimType ty, PrimMonad prim) => UArray ty -> Ptr ty -> prim ()

-- | Get a Ptr pointing to the data in the UArray.
--   
--   Since a UArray is immutable, this Ptr shouldn't be to use to modify
--   the contents
--   
--   If the UArray is pinned, then its address is returned as is, however
--   if it's unpinned, a pinned copy of the UArray is made before getting
--   the address.
withPtr :: forall ty prim a. (PrimMonad prim, PrimType ty) => UArray ty -> (Ptr ty -> prim a) -> prim a

-- | Create a pointer on the beginning of the mutable array and call a
--   function <tt>f</tt>.
--   
--   The mutable buffer can be mutated by the <tt>f</tt> function and the
--   change will be reflected in the mutable array
--   
--   If the mutable array is unpinned, a trampoline buffer is created and
--   the data is only copied when <tt>f</tt> return.
withMutablePtr :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> (Ptr ty -> prim a) -> prim a
unsafeFreezeShrink :: (PrimType ty, PrimMonad prim) => MUArray ty (PrimState prim) -> CountOf ty -> prim (UArray ty)

-- | Just like <a>freeze</a> but copy only the first n bytes
--   
--   The size requested need to be smaller or equal to the length of the
--   MUArray, otherwise a Out of Bounds exception is raised
freezeShrink :: (PrimType ty, PrimMonad prim) => MUArray ty (PrimState prim) -> CountOf ty -> prim (UArray ty)

-- | Create a UArray from a Block
--   
--   The block is still used by the uarray
fromBlock :: PrimType ty => Block ty -> UArray ty

-- | Create a Block from a UArray.
--   
--   Note that because of the slice, the destination block is re-allocated
--   and copied, unless the slice point at the whole array
toBlock :: PrimType ty => UArray ty -> Block ty

-- | update an array by creating a new array with the updates.
--   
--   the operation copy the previous array, modify it in place, then freeze
--   it.
update :: PrimType ty => UArray ty -> [(Offset ty, ty)] -> UArray ty
unsafeUpdate :: PrimType ty => UArray ty -> [(Offset ty, ty)] -> UArray ty

-- | Return the element at a specific index from an array without bounds
--   checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <tt>index</tt> if unsure.
unsafeIndex :: forall ty. PrimType ty => UArray ty -> Offset ty -> ty
unsafeIndexer :: (PrimMonad prim, PrimType ty) => UArray ty -> ((Offset ty -> ty) -> prim a) -> prim a
unsafeDewrap :: (Block ty -> Offset ty -> a) -> (Ptr ty -> Offset ty -> ST s a) -> UArray ty -> a

-- | read from a cell in a mutable array without bounds checking.
--   
--   Reading from invalid memory can return unpredictable and invalid
--   values. use <tt>read</tt> if unsure.
unsafeRead :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> prim ty

-- | write to a cell in a mutable array without bounds checking.
--   
--   Writing with invalid bounds will corrupt memory and your program will
--   become unreliable. use <tt>write</tt> if unsure.
unsafeWrite :: (PrimMonad prim, PrimType ty) => MUArray ty (PrimState prim) -> Offset ty -> ty -> prim ()
equalMemcmp :: PrimType ty => UArray ty -> UArray ty -> Bool
singleton :: PrimType ty => ty -> UArray ty
replicate :: PrimType ty => CountOf ty -> ty -> UArray ty
map :: (PrimType a, PrimType b) => (a -> b) -> UArray a -> UArray b
mapIndex :: (PrimType a, PrimType b) => (Offset b -> a -> b) -> UArray a -> UArray b
findIndex :: PrimType ty => ty -> UArray ty -> Maybe (Offset ty)
revFindIndex :: PrimType ty => ty -> UArray ty -> Maybe (Offset ty)

-- | Return the element at a specific index from an array.
--   
--   If the index @n is out of bounds, an error is raised.
index :: PrimType ty => UArray ty -> Offset ty -> ty
null :: UArray ty -> Bool

-- | Take a count of elements from the array and create an array with just
--   those elements
take :: CountOf ty -> UArray ty -> UArray ty
unsafeTake :: CountOf ty -> UArray ty -> UArray ty

-- | Drop a count of elements from the array and return the new array minus
--   those dropped elements
drop :: CountOf ty -> UArray ty -> UArray ty
unsafeDrop :: CountOf ty -> UArray ty -> UArray ty

-- | Split an array into two, with a count of at most N elements in the
--   first one and the remaining in the other.
splitAt :: CountOf ty -> UArray ty -> (UArray ty, UArray ty)

-- | Drop the N elements from the end of the array
revDrop :: CountOf ty -> UArray ty -> UArray ty

-- | Take the N elements from the end of the array
revTake :: CountOf ty -> UArray ty -> UArray ty

-- | Split an array at the N element from the end, and return the last N
--   elements in the first part of the tuple, and whatever first elements
--   remaining in the second
revSplitAt :: CountOf ty -> UArray ty -> (UArray ty, UArray ty)
splitOn :: PrimType ty => (ty -> Bool) -> UArray ty -> [UArray ty]
break :: forall ty. PrimType ty => (ty -> Bool) -> UArray ty -> (UArray ty, UArray ty)

-- | Similar to break but start the search of the breakpoint from the end
--   
--   <pre>
--   breakEnd (&gt; 0) [1,2,3,0,0,0]
--   </pre>
--   
--   ([1,2,3], [0,0,0])
breakEnd :: forall ty. PrimType ty => (ty -> Bool) -> UArray ty -> (UArray ty, UArray ty)
breakElem :: PrimType ty => ty -> UArray ty -> (UArray ty, UArray ty)

-- | Similar to breakElem specialized to split on linefeed
--   
--   it either returns: * Left. no line has been found, and whether the
--   last character is a CR * Right, a line has been found with an optional
--   CR, and it returns the array of bytes on the left of the CR/LF, and
--   the the array of bytes on the right of the LF.
breakLine :: UArray Word8 -> Either Bool (UArray Word8, UArray Word8)
elem :: PrimType ty => ty -> UArray ty -> Bool
indices :: PrimType ty => UArray ty -> UArray ty -> [Offset ty]
intersperse :: forall ty. PrimType ty => ty -> UArray ty -> UArray ty
span :: PrimType ty => (ty -> Bool) -> UArray ty -> (UArray ty, UArray ty)
spanEnd :: PrimType ty => (ty -> Bool) -> UArray ty -> (UArray ty, UArray ty)
cons :: PrimType ty => ty -> UArray ty -> UArray ty
snoc :: PrimType ty => UArray ty -> ty -> UArray ty
uncons :: PrimType ty => UArray ty -> Maybe (ty, UArray ty)
unsnoc :: PrimType ty => UArray ty -> Maybe (UArray ty, ty)
find :: PrimType ty => (ty -> Bool) -> UArray ty -> Maybe ty
sortBy :: forall ty. PrimType ty => (ty -> ty -> Ordering) -> UArray ty -> UArray ty
filter :: forall ty. PrimType ty => (ty -> Bool) -> UArray ty -> UArray ty
reverse :: forall ty. PrimType ty => UArray ty -> UArray ty

-- | Replace all the occurrencies of <tt>needle</tt> with
--   <tt>replacement</tt> in the <tt>haystack</tt> string.
replace :: PrimType ty => UArray ty -> UArray ty -> UArray ty -> UArray ty
foldr :: PrimType ty => (ty -> a -> a) -> a -> UArray ty -> a
foldl' :: PrimType ty => (a -> ty -> a) -> a -> UArray ty -> a
foldr1 :: PrimType ty => (ty -> ty -> ty) -> NonEmpty (UArray ty) -> ty
foldl1' :: PrimType ty => (ty -> ty -> ty) -> NonEmpty (UArray ty) -> ty
all :: PrimType ty => (ty -> Bool) -> UArray ty -> Bool
any :: PrimType ty => (ty -> Bool) -> UArray ty -> Bool
isPrefixOf :: PrimType ty => UArray ty -> UArray ty -> Bool
isSuffixOf :: PrimType ty => UArray ty -> UArray ty -> Bool
foreignMem :: PrimType ty => FinalPtr ty -> CountOf ty -> UArray ty

-- | Create a foreign UArray from foreign memory and given offset/size
--   
--   No check are performed to make sure this is valid, so this is unsafe.
--   
--   This is particularly useful when dealing with foreign memory and
--   <tt>ByteString</tt>
fromForeignPtr :: PrimType ty => (ForeignPtr ty, Int, Int) -> UArray ty
builderAppend :: (PrimType ty, PrimMonad state) => ty -> Builder (UArray ty) (MUArray ty) ty state err ()
builderBuild :: (PrimType ty, PrimMonad m) => Int -> Builder (UArray ty) (MUArray ty) ty m err () -> m (Either err (UArray ty))
builderBuild_ :: (PrimType ty, PrimMonad m) => Int -> Builder (UArray ty) (MUArray ty) ty m () () -> m (UArray ty)
toHexadecimal :: PrimType ty => UArray ty -> UArray Word8
toBase64Internal :: PrimType ty => Addr# -> UArray ty -> Bool -> UArray Word8


-- | A AsciiString type backed by a <tt>ASCII</tt> encoded byte array and
--   all the necessary functions to manipulate the string.
module Basement.Types.AsciiString

-- | Opaque packed array of characters in the ASCII encoding
newtype AsciiString
AsciiString :: UArray Char7 -> AsciiString
[toBytes] :: AsciiString -> UArray Char7
newtype MutableAsciiString st
MutableAsciiString :: MUArray Char7 st -> MutableAsciiString st

-- | Convert a Byte Array representing ASCII data directly to an
--   AsciiString without checking for ASCII validity
--   
--   If the input contains invalid Char7 value (anything above 0x7f), it
--   will trigger runtime async errors when processing data.
--   
--   In doubt, use <a>fromBytes</a>
fromBytesUnsafe :: UArray Word8 -> AsciiString

-- | Convert a Byte Array representing ASCII checking validity.
--   
--   If the byte array is not valid, then Nothing is returned
fromBytes :: UArray Word8 -> Maybe AsciiString
instance GHC.Classes.Ord Basement.Types.AsciiString.AsciiString
instance GHC.Classes.Eq Basement.Types.AsciiString.AsciiString
instance GHC.Base.Monoid Basement.Types.AsciiString.AsciiString
instance GHC.Base.Semigroup Basement.Types.AsciiString.AsciiString
instance GHC.Show.Show Basement.Types.AsciiString.AsciiString
instance Data.String.IsString Basement.Types.AsciiString.AsciiString
instance GHC.IsList.IsList Basement.Types.AsciiString.AsciiString

module Basement.Sized.UVect
data UVect (n :: Nat) a
data MUVect (n :: Nat) ty st
unUVect :: UVect n a -> UArray a
toUVect :: forall n ty. (PrimType ty, KnownNat n, Countable ty n) => UArray ty -> Maybe (UVect n ty)
empty :: PrimType ty => UVect 0 ty
singleton :: PrimType ty => ty -> UVect 1 ty
replicate :: forall n ty. (KnownNat n, Countable ty n, PrimType ty) => ty -> UVect n ty
thaw :: (KnownNat n, PrimMonad prim, PrimType ty) => UVect n ty -> prim (MUVect n ty (PrimState prim))
freeze :: (PrimMonad prim, PrimType ty, Countable ty n) => MUVect n ty (PrimState prim) -> prim (UVect n ty)
index :: forall i n ty. PrimType ty => UVect n ty -> Offset ty -> ty
map :: (PrimType a, PrimType b) => (a -> b) -> UVect n a -> UVect n b
foldl' :: PrimType ty => (a -> ty -> a) -> a -> UVect n ty -> a
foldr :: PrimType ty => (ty -> a -> a) -> a -> UVect n ty -> a
cons :: PrimType ty => ty -> UVect n ty -> UVect (n + 1) ty
snoc :: PrimType ty => UVect n ty -> ty -> UVect (n + 1) ty
elem :: PrimType ty => ty -> UVect n ty -> Bool
sub :: forall i j n ty. ((i <=? n) ~ 'True, (j <=? n) ~ 'True, (i <=? j) ~ 'True, PrimType ty, KnownNat i, KnownNat j, Offsetable ty i, Offsetable ty j) => UVect n ty -> UVect (j - i) ty
uncons :: forall n ty. (CmpNat 0 n ~ 'LT, PrimType ty, KnownNat n, Offsetable ty n) => UVect n ty -> (ty, UVect (n - 1) ty)
unsnoc :: forall n ty. (CmpNat 0 n ~ 'LT, KnownNat n, PrimType ty, Offsetable ty n) => UVect n ty -> (UVect (n - 1) ty, ty)
splitAt :: forall i n ty. (CmpNat i n ~ 'LT, PrimType ty, KnownNat i, Countable ty i) => UVect n ty -> (UVect i ty, UVect (n - i) ty)
all :: PrimType ty => (ty -> Bool) -> UVect n ty -> Bool
any :: PrimType ty => (ty -> Bool) -> UVect n ty -> Bool
find :: PrimType ty => (ty -> Bool) -> UVect n ty -> Maybe ty
reverse :: PrimType ty => UVect n ty -> UVect n ty
sortBy :: PrimType ty => (ty -> ty -> Ordering) -> UVect n ty -> UVect n ty
intersperse :: (CmpNat n 1 ~ 'GT, PrimType ty) => ty -> UVect n ty -> UVect ((n + n) - 1) ty
instance (Basement.PrimType.PrimType a, GHC.Show.Show a) => GHC.Show.Show (Basement.Sized.UVect.UVect n a)
instance Basement.PrimType.PrimType a => GHC.Classes.Eq (Basement.Sized.UVect.UVect n a)
instance Basement.NormalForm.NormalForm (Basement.Sized.UVect.UVect n a)

module Basement.Types.CharUTF8

-- | Represent an already encoded UTF8 Char where the the lowest 8 bits is
--   the start of the sequence. If this contains a multi bytes sequence
--   then each higher 8 bits are filled with the remaining sequence 8 bits
--   per 8 bits.
--   
--   For example: <tt>A</tt> =&gt; U+0041 =&gt; 41 =&gt; 0x00000041 '€
--   =&gt; U+20AC =&gt; E2 82 AC =&gt; 0x00AC82E2 <tt>𐍈</tt> =&gt; U+10348
--   =&gt; F0 90 8D 88 =&gt; 0x888D90F0
newtype CharUTF8
CharUTF8 :: Word32 -> CharUTF8

-- | Encode a Char into a CharUTF8
encodeCharUTF8 :: Char -> CharUTF8

-- | decode a CharUTF8 into a Char
--   
--   If the value inside a CharUTF8 is not properly encoded, this will
--   result in violation of the Char invariants
decodeCharUTF8 :: CharUTF8 -> Char


-- | re-export of all the base prelude and basic primitive stuffs
module Basement.Imports

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | morphism composition
(.) :: forall (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | the identity morphism
id :: forall (a :: k). Category cat => cat a a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | stop execution and displays an error message
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => String -> a

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class () => Show a

-- | Use the Show class to create a String.
--   
--   Note that this is not efficient, since an intermediate [Char] is going
--   to be created before turning into a real String.
show :: Show a => a -> String

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class () => Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class () => Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data () => Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
data () => Bool
False :: Bool
True :: Bool

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | Offset in a data structure consisting of elements of type <tt>ty</tt>.
--   
--   Int is a terrible backing type which is hard to get away from,
--   considering that GHC/Haskell are mostly using this for offset. Trying
--   to bring some sanity by a lightweight wrapping.
data Offset ty

-- | CountOf of a data structure.
--   
--   More specifically, it represents the number of elements of type
--   <tt>ty</tt> that fit into the data structure.
--   
--   <pre>
--   &gt;&gt;&gt; length (fromList ['a', 'b', 'c', '🌟']) :: CountOf Char
--   CountOf 4
--   </pre>
--   
--   Same caveats as <a>Offset</a> apply here.
data CountOf ty

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | Represent the accessor for types that can be stored in the UArray and
--   MUArray.
--   
--   Types need to be a instance of storable and have fixed sized.
class Eq ty => PrimType ty

-- | ASCII value between 0x0 and 0x7f
data Char7

-- | Opaque packed array of characters in the ASCII encoding
data AsciiString

-- | Opaque packed array of characters in the UTF8 encoding
data String

-- | An array of type built on top of GHC primitive.
--   
--   The elements need to have fixed sized and the representation is a
--   packed contiguous array in memory that can easily be passed to foreign
--   interface
data UArray ty

-- | Array of a
data Array a

-- | Integral Literal support
--   
--   e.g. 123 :: Integer 123 :: Word8
class Integral a
fromInteger :: Integral a => Integer -> a

-- | Fractional Literal support
--   
--   e.g. 1.2 :: Double 0.03 :: Float
class Fractional a
fromRational :: Fractional a => Rational -> a

-- | Negation support
--   
--   e.g. -(f x)
class HasNegation a
negate :: HasNegation a => a -> a

-- | 8-bit signed integer type
data () => Int8

-- | 16-bit signed integer type
data () => Int16

-- | 32-bit signed integer type
data () => Int32

-- | 64-bit signed integer type
data () => Int64

-- | 8-bit unsigned integer type
data () => Word8

-- | 16-bit unsigned integer type
data () => Word16

-- | 32-bit unsigned integer type
data () => Word32

-- | 64-bit unsigned integer type
data () => Word64

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a

-- | IEEE754 Floating point Binary32, simple precision (Also known as
--   Float)
type FP32 = Float

-- | IEEE754 Floating point Binary64, double precision (Also known as
--   Double)
type FP64 = Double

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class () => IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type family Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class () => IsString a
fromString :: IsString a => String -> a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a where {
    
    -- | Generic representation type
    type family Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data () => Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type within generic folding is <tt>r -&gt;
--   r</tt>. So the result of folding is a function to which we finally
--   pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data () => DataType

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data () => Ptr a
Ptr :: Addr# -> Ptr a

-- | for support of if .. then .. else
ifThenElse :: Bool -> a -> a -> a

module Basement.Environment

-- | Returns a list of the program's command line arguments (not including
--   the program name).
getArgs :: IO [String]

-- | Lookup variable in the environment
lookupEnv :: String -> IO (Maybe String)


-- | A String type backed by a UTF8 encoded byte array and all the
--   necessary functions to manipulate the string.
--   
--   You can think of String as a specialization of a byte array that have
--   element of type Char.
--   
--   The String data must contain UTF8 valid data.
module Basement.String

-- | Opaque packed array of characters in the UTF8 encoding
newtype String
String :: UArray Word8 -> String

-- | Mutable String Buffer.
--   
--   Use as an *append* buffer, as UTF8 variable encoding doesn't really
--   allow to change previously written character without potentially
--   shifting bytes.
newtype MutableString st
MutableString :: MUArray Word8 st -> MutableString st

-- | Unsafely create a string of up to <tt>sz</tt> bytes.
--   
--   The callback <tt>f</tt> needs to return the number of bytes filled in
--   the underlaying bytes buffer. No check is made on the callback return
--   values, and if it's not contained without the bounds, bad things will
--   happen.
create :: PrimMonad prim => CountOf Word8 -> (MutableString (PrimState prim) -> prim (Offset Word8)) -> prim String

-- | Replicate a character <tt>c</tt> <tt>n</tt> times to create a string
--   of length <tt>n</tt>
replicate :: CountOf Char -> Char -> String

-- | Length of a String using CountOf
--   
--   this size is available in o(n)
length :: String -> CountOf Char

-- | Various String Encoding that can be use to convert to and from bytes
data Encoding
ASCII7 :: Encoding
UTF8 :: Encoding
UTF16 :: Encoding
UTF32 :: Encoding
ISO_8859_1 :: Encoding

-- | Convert a ByteArray to a string assuming a specific encoding.
--   
--   It returns a 3-tuple of:
--   
--   <ul>
--   <li>The string that has been succesfully converted without any
--   error</li>
--   <li>An optional validation error</li>
--   <li>The remaining buffer that hasn't been processed (either as a
--   result of an error, or because the encoded sequence is not fully
--   available)</li>
--   </ul>
--   
--   Considering a stream of data that is fetched chunk by chunk, it's
--   valid to assume that some sequence might fall in a chunk boundary.
--   When converting chunks, if the error is Nothing and the remaining
--   buffer is not empty, then this buffer need to be prepended to the next
--   chunk
fromBytes :: Encoding -> UArray Word8 -> (String, Maybe ValidationFailure, UArray Word8)

-- | Decode a stream of binary chunks containing UTF8 encoding in a list of
--   valid String
--   
--   Chunk not necessarily contains a valid string, as a UTF8 sequence
--   could be split over 2 chunks.
fromChunkBytes :: [UArray Word8] -> [String]

-- | Convert a Byte Array representing UTF8 data directly to a string
--   without checking for UTF8 validity
--   
--   If the input contains invalid sequences, it will trigger runtime async
--   errors when processing data.
--   
--   In doubt, use <a>fromBytes</a>
fromBytesUnsafe :: UArray Word8 -> String

-- | Convert a UTF8 array of bytes to a String.
--   
--   If there's any error in the stream, it will automatically insert
--   replacement bytes to replace invalid sequences.
--   
--   In the case of sequence that fall in the middle of 2 chunks, the
--   remaining buffer is supposed to be preprended to the next chunk, and
--   resume the parsing.
fromBytesLenient :: UArray Word8 -> (String, UArray Word8)

-- | Convert a String to a bytearray in a specific encoding
--   
--   if the encoding is UTF8, the underlying buffer is returned without
--   extra allocation or any processing
--   
--   In any other encoding, some allocation and processing are done to
--   convert.
toBytes :: Encoding -> String -> UArray Word8

-- | Similar to <a>validate</a> but works on a <tt>MutableByteArray</tt>
mutableValidate :: PrimMonad prim => MUArray Word8 (PrimState prim) -> Offset Word8 -> CountOf Word8 -> prim (Offset Word8, Maybe ValidationFailure)

-- | Copy the String
--   
--   The slice of memory is copied to a new slice, making the new string
--   independent from the original string..
copy :: String -> String

-- | Possible failure related to validating bytes of UTF8 sequences.
data ValidationFailure
InvalidHeader :: ValidationFailure
InvalidContinuation :: ValidationFailure
MissingByte :: ValidationFailure
BuildingFailure :: ValidationFailure

-- | Return the nth character in a String
--   
--   Compared to an array, the string need to be scanned from the beginning
--   since the UTF8 encoding is variable.
index :: String -> Offset Char -> Maybe Char

-- | Check if a String is null
null :: String -> Bool

-- | Create a string with the remaining Chars after dropping @n Chars from
--   the beginning
drop :: CountOf Char -> String -> String

-- | Create a string composed of a number @n of Chars (Unicode code
--   points).
--   
--   if the input @s contains less characters than required, then the input
--   string is returned.
take :: CountOf Char -> String -> String

-- | Split a string at the Offset specified (in Char) returning both the
--   leading part and the remaining part.
splitAt :: CountOf Char -> String -> (String, String)

-- | Similar to <a>drop</a> but from the end
revDrop :: CountOf Char -> String -> String

-- | Similar to <a>take</a> but from the end
revTake :: CountOf Char -> String -> String

-- | Similar to <a>splitAt</a> but from the end
revSplitAt :: CountOf Char -> String -> (String, String)

-- | Split on the input string using the predicate as separator
--   
--   e.g.
--   
--   <pre>
--   splitOn (== ',') ","          == ["",""]
--   splitOn (== ',') ",abc,"      == ["","abc",""]
--   splitOn (== ':') "abc"        == ["abc"]
--   splitOn (== ':') "abc::def"   == ["abc","","def"]
--   splitOn (== ':') "::abc::def" == ["","","abc","","def"]
--   </pre>
splitOn :: (Char -> Bool) -> String -> [String]

-- | Internal call to make a substring given offset in bytes.
--   
--   This is unsafe considering that one can create a substring starting
--   and/or ending on the middle of a UTF8 sequence.
sub :: String -> Offset8 -> Offset8 -> String

-- | Return whereas the string contains a specific character or not
elem :: Char -> String -> Bool

-- | Finds where are the insertion points when we search for a
--   <tt>needle</tt> within an <tt>haystack</tt>.
indices :: String -> String -> [Offset8]

-- | Intersperse the character <tt>sep</tt> between each character in the
--   string
--   
--   <pre>
--   intersperse ' ' "Hello Foundation"
--   </pre>
--   
--   "H e l l o F o u n d a t i o n"
intersperse :: Char -> String -> String

-- | Apply a <tt>predicate</tt> to the string to return the longest prefix
--   that satisfy the predicate and the remaining
span :: (Char -> Bool) -> String -> (String, String)

-- | Apply a <tt>predicate</tt> to the string to return the longest suffix
--   that satisfy the predicate and the remaining
spanEnd :: (Char -> Bool) -> String -> (String, String)

-- | Break a string into 2 strings at the location where the predicate
--   return True
break :: (Char -> Bool) -> String -> (String, String)
breakEnd :: (Char -> Bool) -> String -> (String, String)

-- | Break a string into 2 strings at the first occurence of the character
breakElem :: Char -> String -> (String, String)

-- | Same as break but cut on a line feed with an optional carriage return.
--   
--   This is the same operation as 'breakElem LF' dropping the last
--   character of the string if it's a CR.
--   
--   Also for efficiency reason (streaming), it returns if the last
--   character was a CR character.
breakLine :: String -> Either Bool (String, String)

-- | Drop character from the beginning while the predicate is true
dropWhile :: (Char -> Bool) -> String -> String

-- | Create a single element String
singleton :: Char -> String

-- | Monomorphically map the character in a string and return the
--   transformed one
charMap :: (Char -> Char) -> String -> String

-- | Append a Char to the end of the String and return this new String
snoc :: String -> Char -> String

-- | Prepend a Char to the beginning of the String and return this new
--   String
cons :: Char -> String -> String

-- | Extract the String stripped of the last character and the last
--   character if not empty
--   
--   If empty, Nothing is returned
unsnoc :: String -> Maybe (String, Char)

-- | Extract the First character of a string, and the String stripped of
--   the first character.
--   
--   If empty, Nothing is returned
uncons :: String -> Maybe (Char, String)

-- | Look for a predicate in the String and return the matched character,
--   if any.
find :: (Char -> Bool) -> String -> Maybe Char

-- | Return the index in unit of Char of the first occurence of the
--   predicate returning True
--   
--   If not found, Nothing is returned
findIndex :: (Char -> Bool) -> String -> Maybe (Offset Char)

-- | Sort the character in a String using a specific sort function
--   
--   TODO: optimise not going through a list
sortBy :: (Char -> Char -> Ordering) -> String -> String

-- | Filter characters of a string using the predicate
filter :: (Char -> Bool) -> String -> String

-- | Reverse a string
reverse :: String -> String

-- | Replace all the occurrencies of <tt>needle</tt> with
--   <tt>replacement</tt> in the <tt>haystack</tt> string.
replace :: String -> String -> String -> String

-- | Append a character to a String builder
builderAppend :: PrimMonad state => Char -> Builder String MutableString Word8 state err ()

-- | Create a new String builder using chunks of <tt>sizeChunksI</tt>
builderBuild :: PrimMonad m => Int -> Builder String MutableString Word8 m err () -> m (Either err String)
builderBuild_ :: PrimMonad m => Int -> Builder String MutableString Word8 m () () -> m String
readInteger :: String -> Maybe Integer

-- | Read an Integer from a String
--   
--   Consume an optional minus sign and many digits until end of string.
readIntegral :: (HasNegation i, IntegralUpsize Word8 i, Additive i, Multiplicative i, IsIntegral i) => String -> Maybe i

-- | Read a Natural from a String
--   
--   Consume many digits until end of string.
readNatural :: String -> Maybe Natural

-- | Try to read a Double
readDouble :: String -> Maybe Double

-- | Try to read a floating number as a Rational
--   
--   Note that for safety reason, only exponent between -10000 and 10000 is
--   allowed as otherwise DoS/OOM is very likely. if you don't want this
--   behavior, switching to a scientific type (not provided yet) that
--   represent the exponent separately is the advised solution.
readRational :: String -> Maybe Rational

-- | Read an Floating like number of the form:
--   
--   <ul>
--   <li><i> <a>-</a> </i> <a>numbers</a> [ <a>.</a> <a>numbers</a> ] [ (
--   <tt>e</tt> | <tt>E</tt> ) [ <a>-</a> ] <a>number</a> ]</li>
--   </ul>
--   
--   Call a function with:
--   
--   <ul>
--   <li>A boolean representing if the number is negative</li>
--   <li>The digits part represented as a single natural number (123.456 is
--   represented as 123456)</li>
--   <li>The number of digits in the fractional part (e.g. 123.456 =&gt;
--   3)</li>
--   <li>The exponent if any</li>
--   </ul>
--   
--   The code is structured as a simple state machine that:
--   
--   <ul>
--   <li>Optionally Consume a <a>-</a> sign</li>
--   <li>Consume number for the integral part</li>
--   <li>Optionally</li>
--   <li>Consume <a>.</a></li>
--   <li>Consume remaining digits if not already end of string</li>
--   <li>Optionally Consume a <tt>e</tt> or <tt>E</tt> follow by an
--   optional <a>-</a> and a number</li>
--   </ul>
readFloatingExact :: String -> ReadFloatingCallback a -> Maybe a

-- | Convert a <a>String</a> to the upper-case equivalent.
upper :: String -> String

-- | Convert a <a>String</a> to the upper-case equivalent.
lower :: String -> String

-- | Convert a <a>String</a> to the unicode case fold equivalent.
--   
--   Case folding is mostly used for caseless comparison of strings.
caseFold :: String -> String

-- | Check whether the first string is a prefix of the second string.
isPrefixOf :: String -> String -> Bool

-- | Check whether the first string is a suffix of the second string.
isSuffixOf :: String -> String -> Bool

-- | Check whether the first string is contains within the second string.
--   
--   TODO: implemented the naive way and thus terribly inefficient,
--   reimplement properly
isInfixOf :: String -> String -> Bool

-- | Try to strip a prefix from the start of a String.
--   
--   If the prefix is not starting the string, then Nothing is returned,
--   otherwise the striped string is returned
stripPrefix :: String -> String -> Maybe String

-- | Try to strip a suffix from the end of a String.
--   
--   If the suffix is not ending the string, then Nothing is returned,
--   otherwise the striped string is returned
stripSuffix :: String -> String -> Maybe String
all :: (Char -> Bool) -> String -> Bool
any :: (Char -> Bool) -> String -> Bool

-- | Split lines in a string using newline as separation.
--   
--   Note that carriage return preceding a newline are also strip for
--   maximum compatibility between Windows and Unix system.
lines :: String -> [String]

-- | Split words in a string using spaces as separation
--   
--   <pre>
--   words "Hello Foundation"
--   </pre>
--   
--   <ul>
--   <li><i> <a>Hello</a>, <a>Foundation</a> </i></li>
--   </ul>
words :: String -> [String]

-- | Transform string <tt>src</tt> to base64 binary representation.
toBase64 :: String -> String

-- | Transform string <tt>src</tt> to URL-safe base64 binary
--   representation. The result will be either padded or unpadded,
--   depending on the boolean <tt>padded</tt> argument.
toBase64URL :: Bool -> String -> String

-- | Transform string <tt>src</tt> to OpenBSD base64 binary representation.
toBase64OpenBSD :: String -> String
instance GHC.Enum.Bounded Basement.String.Encoding
instance GHC.Enum.Enum Basement.String.Encoding
instance GHC.Show.Show Basement.String.Encoding
instance GHC.Classes.Ord Basement.String.Encoding
instance GHC.Classes.Eq Basement.String.Encoding
instance Data.Data.Data Basement.String.Encoding
instance Basement.String.Encoding.Encoding.Encoding Basement.String.EncoderUTF8


-- | ANSI Terminal escape for cursor and attributes manipulations
--   
--   On Unix system, it should be supported by most terminal emulators.
--   
--   On Windows system, all escape sequences are empty for maximum
--   compatibility purpose, and easy implementation. newer version of
--   Windows 10 supports ANSI escape now, but we'll need some kind of
--   detection.
module Basement.Terminal.ANSI
type Escape = String
type Displacement = Word64

-- | Simple color component on 8 color terminal (maximum compatibility)
type ColorComponent = Zn64 8

-- | Gray color compent on 256colors terminals
type GrayComponent = Zn64 24

-- | Color compent on 256colors terminals
type RGBComponent = Zn64 6
cursorUp :: Displacement -> Escape
cursorDown :: Displacement -> Escape
cursorForward :: Displacement -> Escape
cursorBack :: Displacement -> Escape
cursorNextLine :: Displacement -> Escape
cursorPrevLine :: Displacement -> Escape
cursorHorizontalAbsolute :: Displacement -> Escape
cursorPosition :: Displacement -> Displacement -> Escape
eraseScreenFromCursor :: Escape
eraseScreenToCursor :: Escape
eraseScreenAll :: Escape
eraseLineFromCursor :: Escape
eraseLineToCursor :: Escape
eraseLineAll :: Escape
scrollUp :: Displacement -> Escape
scrollDown :: Displacement -> Escape

-- | All attribute off
sgrReset :: Escape

-- | 8 Colors + Bold attribute for foreground
sgrForeground :: ColorComponent -> Bool -> Escape

-- | 8 Colors + Bold attribute for background
sgrBackground :: ColorComponent -> Bool -> Escape
sgrForegroundGray24 :: GrayComponent -> Escape
sgrBackgroundGray24 :: GrayComponent -> Escape
sgrForegroundColor216 :: RGBComponent -> RGBComponent -> RGBComponent -> Escape
sgrBackgroundColor216 :: RGBComponent -> RGBComponent -> RGBComponent -> Escape


-- | Flexible Type convertion
--   
--   From is multi parameter type class that allow converting from a to b.
--   
--   Only type that are valid to convert to another type should be From
--   instance; otherwise TryFrom should be used.
--   
--   Into (resp TryInto) allows the contrary instances to be able to
--   specify the destination type before the source. This is practical with
--   TypeApplication
module Basement.From

-- | Class of things that can be converted from a to b.
--   
--   In a valid instance, the source should be always representable by the
--   destination, otherwise the instance should be using <a>TryFrom</a>
class From a b
from :: From a b => a -> b
type Into b a = From a b

-- | Class of things that can mostly be converted from a to b, but with
--   possible error cases.
class TryFrom a b
tryFrom :: TryFrom a b => a -> Maybe b
type TryInto b a = TryFrom a b

-- | Same as from but reverse the type variable so that the destination
--   type can be specified first
--   
--   e.g. converting:
--   
--   from <tt>_ </tt>Word (10 :: Int)
--   
--   into @Word (10 :: Int)
into :: Into b a => a -> b

-- | same as tryFrom but reversed
tryInto :: TryInto b a => a -> Maybe b
instance Basement.From.TryFrom GHC.Types.Int (Basement.Types.OffsetSize.Offset ty)
instance Basement.From.TryFrom GHC.Types.Int (Basement.Types.OffsetSize.CountOf ty)
instance Basement.From.TryFrom (Basement.UArray.Base.UArray GHC.Word.Word8) Basement.UTF8.Base.String
instance (Basement.Nat.NatWithinBound (Basement.Types.OffsetSize.CountOf ty) n, GHC.TypeNats.KnownNat n, Basement.PrimType.PrimType ty) => Basement.From.TryFrom (Basement.Block.Base.Block ty) (Basement.Sized.Block.BlockN n ty)
instance (Basement.Nat.NatWithinBound (Basement.Types.OffsetSize.CountOf ty) n, GHC.TypeNats.KnownNat n, Basement.PrimType.PrimType ty) => Basement.From.TryFrom (Basement.UArray.Base.UArray ty) (Basement.Sized.Block.BlockN n ty)
instance (Basement.Nat.NatWithinBound (Basement.Types.OffsetSize.CountOf ty) n, GHC.TypeNats.KnownNat n, Basement.PrimType.PrimType ty) => Basement.From.TryFrom (Basement.BoxedArray.Array ty) (Basement.Sized.Block.BlockN n ty)
instance Basement.From.From a a
instance Basement.Numerical.Number.IsNatural n => Basement.From.From n GHC.Num.Natural.Natural
instance Basement.Numerical.Number.IsIntegral n => Basement.From.From n GHC.Num.Integer.Integer
instance Basement.From.From GHC.Int.Int8 GHC.Int.Int16
instance Basement.From.From GHC.Int.Int8 GHC.Int.Int32
instance Basement.From.From GHC.Int.Int8 GHC.Int.Int64
instance Basement.From.From GHC.Int.Int8 GHC.Types.Int
instance Basement.From.From GHC.Int.Int16 GHC.Int.Int32
instance Basement.From.From GHC.Int.Int16 GHC.Int.Int64
instance Basement.From.From GHC.Int.Int16 GHC.Types.Int
instance Basement.From.From GHC.Int.Int32 GHC.Int.Int64
instance Basement.From.From GHC.Int.Int32 GHC.Types.Int
instance Basement.From.From GHC.Types.Int GHC.Int.Int64
instance Basement.From.From GHC.Word.Word8 GHC.Word.Word16
instance Basement.From.From GHC.Word.Word8 GHC.Word.Word32
instance Basement.From.From GHC.Word.Word8 GHC.Word.Word64
instance Basement.From.From GHC.Word.Word8 Basement.Types.Word128.Word128
instance Basement.From.From GHC.Word.Word8 Basement.Types.Word256.Word256
instance Basement.From.From GHC.Word.Word8 GHC.Types.Word
instance Basement.From.From GHC.Word.Word8 GHC.Int.Int16
instance Basement.From.From GHC.Word.Word8 GHC.Int.Int32
instance Basement.From.From GHC.Word.Word8 GHC.Int.Int64
instance Basement.From.From GHC.Word.Word8 GHC.Types.Int
instance Basement.From.From GHC.Word.Word16 GHC.Word.Word32
instance Basement.From.From GHC.Word.Word16 GHC.Word.Word64
instance Basement.From.From GHC.Word.Word16 Basement.Types.Word128.Word128
instance Basement.From.From GHC.Word.Word16 Basement.Types.Word256.Word256
instance Basement.From.From GHC.Word.Word16 GHC.Types.Word
instance Basement.From.From GHC.Word.Word16 GHC.Int.Int32
instance Basement.From.From GHC.Word.Word16 GHC.Int.Int64
instance Basement.From.From GHC.Word.Word16 GHC.Types.Int
instance Basement.From.From GHC.Word.Word32 GHC.Word.Word64
instance Basement.From.From GHC.Word.Word32 Basement.Types.Word128.Word128
instance Basement.From.From GHC.Word.Word32 Basement.Types.Word256.Word256
instance Basement.From.From GHC.Word.Word32 GHC.Types.Word
instance Basement.From.From GHC.Word.Word32 GHC.Int.Int64
instance Basement.From.From GHC.Word.Word32 GHC.Types.Int
instance Basement.From.From GHC.Word.Word64 Basement.Types.Word128.Word128
instance Basement.From.From GHC.Word.Word64 Basement.Types.Word256.Word256
instance Basement.From.From GHC.Types.Word GHC.Word.Word64
instance Basement.From.From (GHC.Maybe.Maybe a) (Data.Either.Either () a)
instance Basement.From.From (Basement.Types.OffsetSize.CountOf ty) GHC.Types.Int
instance Basement.From.From (Basement.Types.OffsetSize.CountOf ty) GHC.Types.Word
instance Basement.From.From GHC.Types.Word (Basement.Types.OffsetSize.Offset ty)
instance Basement.From.From GHC.Types.Word (Basement.Types.OffsetSize.CountOf ty)
instance Basement.From.From (Data.Either.Either a b) (Basement.These.These a b)
instance Basement.From.From Basement.Types.Word128.Word128 Basement.Types.Word256.Word256
instance Basement.PrimType.PrimType ty => Basement.From.From (Basement.Block.Base.Block ty) (Basement.UArray.Base.UArray ty)
instance Basement.PrimType.PrimType ty => Basement.From.From (Basement.BoxedArray.Array ty) (Basement.UArray.Base.UArray ty)
instance Basement.PrimType.PrimType ty => Basement.From.From (Basement.UArray.Base.UArray ty) (Basement.Block.Base.Block ty)
instance Basement.PrimType.PrimType ty => Basement.From.From (Basement.BoxedArray.Array ty) (Basement.Block.Base.Block ty)
instance Basement.PrimType.PrimType ty => Basement.From.From (Basement.UArray.Base.UArray ty) (Basement.BoxedArray.Array ty)
instance Basement.From.From Basement.UTF8.Base.String (Basement.UArray.Base.UArray GHC.Word.Word8)
instance Basement.From.From Basement.Types.AsciiString.AsciiString Basement.UTF8.Base.String
instance Basement.From.From Basement.Types.AsciiString.AsciiString (Basement.UArray.Base.UArray GHC.Word.Word8)
instance Basement.From.From (Basement.Sized.Block.BlockN n ty) (Basement.Block.Base.Block ty)
instance (Basement.PrimType.PrimType a, Basement.PrimType.PrimType b, GHC.TypeNats.KnownNat n, GHC.TypeNats.KnownNat m, (Basement.PrimType.PrimSize b GHC.TypeNats.* m) GHC.Types.~ (Basement.PrimType.PrimSize a GHC.TypeNats.* n)) => Basement.From.From (Basement.Sized.Block.BlockN n a) (Basement.Sized.Block.BlockN m b)
instance (Basement.Nat.NatWithinBound GHC.Types.Int n, Basement.PrimType.PrimType ty) => Basement.From.From (Basement.Sized.Block.BlockN n ty) (Basement.UArray.Base.UArray ty)
instance (Basement.Nat.NatWithinBound GHC.Types.Int n, Basement.PrimType.PrimType ty) => Basement.From.From (Basement.Sized.Block.BlockN n ty) (Basement.BoxedArray.Array ty)
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word8 n) => Basement.From.From (Basement.Bounded.Zn64 n) GHC.Word.Word8
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word16 n) => Basement.From.From (Basement.Bounded.Zn64 n) GHC.Word.Word16
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word32 n) => Basement.From.From (Basement.Bounded.Zn64 n) GHC.Word.Word32
instance Basement.From.From (Basement.Bounded.Zn64 n) GHC.Word.Word64
instance Basement.From.From (Basement.Bounded.Zn64 n) Basement.Types.Word128.Word128
instance Basement.From.From (Basement.Bounded.Zn64 n) Basement.Types.Word256.Word256
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word8 n) => Basement.From.From (Basement.Bounded.Zn n) GHC.Word.Word8
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word16 n) => Basement.From.From (Basement.Bounded.Zn n) GHC.Word.Word16
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word32 n) => Basement.From.From (Basement.Bounded.Zn n) GHC.Word.Word32
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.From.From (Basement.Bounded.Zn n) GHC.Word.Word64
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound Basement.Types.Word128.Word128 n) => Basement.From.From (Basement.Bounded.Zn n) Basement.Types.Word128.Word128
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound Basement.Types.Word256.Word256 n) => Basement.From.From (Basement.Bounded.Zn n) Basement.Types.Word256.Word256
instance (GHC.TypeNats.KnownNat n, Basement.Nat.NatWithinBound GHC.Word.Word64 n) => Basement.From.From (Basement.Bounded.Zn n) (Basement.Bounded.Zn64 n)
instance GHC.TypeNats.KnownNat n => Basement.From.From (Basement.Bounded.Zn64 n) (Basement.Bounded.Zn n)


-- | Block builder
module Basement.Block.Builder
data Builder

-- | run the given builder and return the generated block
run :: PrimMonad prim => Builder -> prim (Block Word8)

-- | add a Block in the builder
emit :: Block a -> Builder
emitPrim :: (PrimType ty, ty ~ Word8) => ty -> Builder

-- | add a string in the builder
emitString :: String -> Builder

-- | emit a UTF8 char in the builder
--   
--   this function may be replaced by `emit :: Encoding -&gt; Char -&gt;
--   Builder`
emitUTF8Char :: Char -> Builder

-- | run the given builder and return a UTF8String
--   
--   this action is unsafe as there is no guarantee upon the validity of
--   the content of the built block.
unsafeRunString :: PrimMonad prim => Builder -> prim String
instance GHC.Base.Semigroup Basement.Block.Builder.Builder
instance GHC.Base.Monoid Basement.Block.Builder.Builder


-- | String builder
module Basement.String.Builder
data Builder
run :: PrimMonad prim => Builder -> prim (String, Maybe ValidationFailure, UArray Word8)

-- | run the given builder and return the generated String
--   
--   prefer <a>run</a>
runUnsafe :: PrimMonad prim => Builder -> prim String

-- | add a string in the builder
emit :: String -> Builder

-- | emit a UTF8 char in the builder
emitChar :: Char -> Builder
unsafeStringBuilder :: Builder -> Builder
instance GHC.Base.Monoid Basement.String.Builder.Builder
instance GHC.Base.Semigroup Basement.String.Builder.Builder
