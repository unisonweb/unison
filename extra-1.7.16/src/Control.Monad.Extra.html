<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | Extra functions for &quot;Control.Monad&quot;.</span><span>
</span><span id="line-4"></span><span class="hs-comment">--   These functions provide looping, list operations and booleans.</span><span>
</span><span id="line-5"></span><span class="hs-comment">--   If you need a wider selection of monad loops and list generalisations,</span><span>
</span><span id="line-6"></span><span class="hs-comment">--   see &lt;https://hackage.haskell.org/package/monad-loops monad-loops&gt;.</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Monad.Extra</span><span class="hs-special">(</span><span>
</span><span id="line-8"></span><span>    </span><span class="hs-keyword">module</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span class="hs-special">,</span><span>
</span><span id="line-9"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier">whenJust</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier">whenJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-10"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier">pureIf</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier">whenMaybe</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier">whenMaybeM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-13"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier">maybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier">fromMaybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier">eitherM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Loops</span></span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier">loop</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier">loopM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier">whileM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier">whileJustM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier">untilJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-16"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Lists</span></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier">partitionM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier">concatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier">concatForM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier">mconcatMapM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier">mapMaybeM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier">findM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier">firstJustM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier">fold1M</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier">fold1M_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-19"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Booleans</span></span><span>
</span><span id="line-20"></span><span>    </span><span class="annot"><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier">whenM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier">unlessM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier">ifM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier">notM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator">(||^)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator">(&amp;&amp;^)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier">orM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier">andM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier">anyM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier">allM</span></a></span><span>
</span><span id="line-21"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Exception.Extra.html"><span class="hs-identifier">Control.Exception.Extra</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Monoid</span></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-comment">-- General utilities</span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-comment">-- | Perform some operation on 'Just', given the field inside the 'Just'.</span><span>
</span><span id="line-33"></span><span class="hs-comment">--   This is a specialized 'Data.Foldable.for_'.</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- &gt; whenJust Nothing  print == pure ()</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- &gt; whenJust (Just 1) print == print 1</span><span>
</span><span id="line-37"></span><span id="local-6989586621679068860"><span id="local-6989586621679068861"><span class="annot"><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier hs-type">whenJust</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679068860"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068861"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068861"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068860"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068860"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-38"></span><span id="whenJust"><span class="annot"><span class="annottext">whenJust :: forall (m :: * -&gt; *) a.
Applicative m =&gt;
Maybe a -&gt; (a -&gt; m ()) -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenJust"><span class="hs-identifier hs-var hs-var">whenJust</span></a></span></span><span> </span><span id="local-6989586621679069077"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069077"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679069078"><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679069078"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; (a -&gt; m ()) -&gt; Maybe a -&gt; m ()
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679069078"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069077"><span class="hs-identifier hs-var">mg</span></a></span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="annot"><span class="hs-comment">-- | Like 'whenJust', but where the test can be monadic.</span></span><span>
</span><span id="line-41"></span><span id="local-6989586621679068868"><span id="local-6989586621679068869"><span class="annot"><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier hs-type">whenJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068869"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068869"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068868"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-42"></span><span class="hs-comment">-- Can't reuse whenMaybe on GHC 7.8 or lower because Monad does not imply Applicative</span><span>
</span><span id="line-43"></span><span id="whenJustM"><span class="annot"><span class="annottext">whenJustM :: forall (m :: * -&gt; *) a.
Monad m =&gt;
m (Maybe a) -&gt; (a -&gt; m ()) -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenJustM"><span class="hs-identifier hs-var hs-var">whenJustM</span></a></span></span><span> </span><span id="local-6989586621679069085"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069085"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679069086"><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679069086"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; (a -&gt; m ()) -&gt; m (Maybe a) -&gt; m ()
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; m ()
</span><a href="#local-6989586621679069086"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069085"><span class="hs-identifier hs-var">mg</span></a></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-comment">-- | Return either a `pure` value if a condition is `True`, otherwise `empty`.</span><span>
</span><span id="line-46"></span><span class="hs-comment">--</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- &gt; pureIf @Maybe True  5 == Just 5</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- &gt; pureIf @Maybe False 5 == Nothing</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- &gt; pureIf @[]    True  5 == [5]</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- &gt; pureIf @[]    False 5 == []</span><span>
</span><span id="line-51"></span><span id="local-6989586621679068876"><span id="local-6989586621679068878"><span class="annot"><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier hs-type">pureIf</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679068876"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068878"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068876"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068878"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-52"></span><span id="pureIf"><span class="annot"><span class="annottext">pureIf :: forall (m :: * -&gt; *) a. Alternative m =&gt; Bool -&gt; a -&gt; m a
</span><a href="Control.Monad.Extra.html#pureIf"><span class="hs-identifier hs-var hs-var">pureIf</span></a></span></span><span> </span><span id="local-6989586621679069093"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069093"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679069094"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069094"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069093"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069094"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">m a
forall a. m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-comment">-- | Like 'when', but return either 'Nothing' if the predicate was 'False',</span><span>
</span><span id="line-55"></span><span class="hs-comment">--   or 'Just' with the result of the computation.</span><span>
</span><span id="line-56"></span><span class="hs-comment">--</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- &gt; whenMaybe True  (print 1) == fmap Just (print 1)</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- &gt; whenMaybe False (print 1) == pure Nothing</span><span>
</span><span id="line-59"></span><span id="local-6989586621679068883"><span id="local-6989586621679068884"><span class="annot"><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier hs-type">whenMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679068883"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068883"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068884"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068883"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068884"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-60"></span><span id="whenMaybe"><span class="annot"><span class="annottext">whenMaybe :: forall (m :: * -&gt; *) a. Applicative m =&gt; Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#whenMaybe"><span class="hs-identifier hs-var hs-var">whenMaybe</span></a></span></span><span> </span><span id="local-6989586621679069101"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069101"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679069102"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069102"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069101"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; m a -&gt; m (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069102"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="annot"><span class="hs-comment">-- | Like 'whenMaybe', but where the test can be monadic.</span></span><span>
</span><span id="line-63"></span><span id="local-6989586621679068891"><span id="local-6989586621679068892"><span class="annot"><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier hs-type">whenMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068892"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068891"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068892"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-64"></span><span class="hs-comment">-- Can't reuse whenMaybe on GHC 7.8 or lower because Monad does not imply Applicative</span><span>
</span><span id="line-65"></span><span id="whenMaybeM"><span class="annot"><span class="annottext">whenMaybeM :: forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#whenMaybeM"><span class="hs-identifier hs-var hs-var">whenMaybeM</span></a></span></span><span> </span><span id="local-6989586621679069109"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069109"><span class="hs-identifier hs-var">mb</span></a></span></span><span> </span><span id="local-6989586621679069110"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069110"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-66"></span><span>    </span><span id="local-6989586621679069111"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069111"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069109"><span class="hs-identifier hs-var">mb</span></a></span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069111"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; m a -&gt; m (Maybe a)
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069110"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span class="hs-comment">-- | The identity function which requires the inner argument to be @()@. Useful for functions</span><span>
</span><span id="line-70"></span><span class="hs-comment">--   with overloaded return types.</span><span>
</span><span id="line-71"></span><span class="hs-comment">--</span><span>
</span><span id="line-72"></span><span class="hs-comment">-- &gt; \(x :: Maybe ()) -&gt; unit x == x</span><span>
</span><span id="line-73"></span><span id="local-6989586621679068898"><span class="annot"><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword hs-type">unit</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679068898"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068898"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-74"></span><span id="unit"><span class="annot"><span class="annottext">unit :: forall (m :: * -&gt; *). m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#unit"><span class="hs-keyword hs-var hs-var">unit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m () -&gt; m ()
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="annot"><span class="hs-comment">-- | Monadic generalisation of 'maybe'.</span></span><span>
</span><span id="line-78"></span><span id="local-6989586621679068873"><span id="local-6989586621679068874"><span id="local-6989586621679068875"><span class="annot"><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-type">maybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068874"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068875"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068874"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068875"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068873"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068874"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-79"></span><span id="maybeM"><span class="annot"><span class="annottext">maybeM :: forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var hs-var">maybeM</span></a></span></span><span> </span><span id="local-6989586621679069116"><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679069116"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679069117"><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679069117"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span id="local-6989586621679069118"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069118"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m b -&gt; (a -&gt; m b) -&gt; Maybe a -&gt; m b
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679069116"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679069117"><span class="hs-identifier hs-var">j</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069118"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span class="annot"><span class="hs-comment">-- | Monadic generalisation of 'fromMaybe'.</span></span><span>
</span><span id="line-83"></span><span id="local-6989586621679068907"><span id="local-6989586621679068908"><span class="annot"><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier hs-type">fromMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068907"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068907"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068908"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068907"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068908"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068907"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068908"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-84"></span><span id="fromMaybeM"><span class="annot"><span class="annottext">fromMaybeM :: forall (m :: * -&gt; *) a. Monad m =&gt; m a -&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#fromMaybeM"><span class="hs-identifier hs-var hs-var">fromMaybeM</span></a></span></span><span> </span><span id="local-6989586621679069125"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069125"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679069126"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069126"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; m a) -&gt; m (Maybe a) -&gt; m a
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069125"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069126"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="annot"><span class="hs-comment">-- | Monadic generalisation of 'either'.</span></span><span>
</span><span id="line-88"></span><span id="local-6989586621679068911"><span id="local-6989586621679068912"><span id="local-6989586621679068913"><span id="local-6989586621679068914"><span class="annot"><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier hs-type">eitherM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068911"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068912"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068911"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068913"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068914"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068911"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068913"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068911"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679068912"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068914"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068911"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068913"><span class="hs-identifier hs-type">c</span></a></span></span></span></span></span><span>
</span><span id="line-89"></span><span id="eitherM"><span class="annot"><span class="annottext">eitherM :: forall (m :: * -&gt; *) a c b.
Monad m =&gt;
(a -&gt; m c) -&gt; (b -&gt; m c) -&gt; m (Either a b) -&gt; m c
</span><a href="Control.Monad.Extra.html#eitherM"><span class="hs-identifier hs-var hs-var">eitherM</span></a></span></span><span> </span><span id="local-6989586621679069130"><span class="annot"><span class="annottext">a -&gt; m c
</span><a href="#local-6989586621679069130"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679069131"><span class="annot"><span class="annottext">b -&gt; m c
</span><a href="#local-6989586621679069131"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679069132"><span class="annot"><span class="annottext">m (Either a b)
</span><a href="#local-6989586621679069132"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m c) -&gt; (b -&gt; m c) -&gt; Either a b -&gt; m c
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m c
</span><a href="#local-6989586621679069130"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; m c
</span><a href="#local-6989586621679069131"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">(Either a b -&gt; m c) -&gt; m (Either a b) -&gt; m c
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">m (Either a b)
</span><a href="#local-6989586621679069132"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span class="hs-comment">-- | A variant of 'foldM' that has no base case, and thus may only be applied to non-empty lists.</span><span>
</span><span id="line-92"></span><span class="hs-comment">--</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- &gt; fold1M (\x y -&gt; Just x) [] == undefined</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- &gt; fold1M (\x y -&gt; Just $ x + y) [1, 2, 3] == Just 6</span><span>
</span><span id="line-95"></span><span id="local-6989586621679068923"><span id="local-6989586621679068924"><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-type">fold1M</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Partial.html#Partial"><span class="hs-identifier hs-type">Partial</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068923"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068924"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068924"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068923"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068924"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068924"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068923"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068924"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-96"></span><span id="fold1M"><span class="annot"><span class="annottext">fold1M :: forall (m :: * -&gt; *) a.
(Partial, Monad m) =&gt;
(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
</span><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var hs-var">fold1M</span></a></span></span><span> </span><span id="local-6989586621679069141"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679069141"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679069142"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069142"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679069143"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069143"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; m a) -&gt; a -&gt; [a] -&gt; m a
forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679069141"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069142"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069143"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-97"></span><span class="annot"><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var">fold1M</span></a></span><span> </span><span id="local-6989586621679069144"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679069144"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679069145"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069145"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; m a
forall a. Partial =&gt; [Char] -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;fold1M: empty list&quot;</span></span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="annot"><span class="hs-comment">-- | Like 'fold1M' but discards the result.</span></span><span>
</span><span id="line-100"></span><span id="local-6989586621679068933"><span id="local-6989586621679068934"><span class="annot"><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier hs-type">fold1M_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Partial.html#Partial"><span class="hs-identifier hs-type">Partial</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068933"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068934"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068934"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068933"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068934"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068934"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068933"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-101"></span><span id="fold1M_"><span class="annot"><span class="annottext">fold1M_ :: forall (m :: * -&gt; *) a.
(Partial, Monad m) =&gt;
(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m ()
</span><a href="Control.Monad.Extra.html#fold1M_"><span class="hs-identifier hs-var hs-var">fold1M_</span></a></span></span><span> </span><span id="local-6989586621679069155"><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679069155"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679069156"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069156"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
forall (m :: * -&gt; *) a.
(Partial, Monad m) =&gt;
(a -&gt; a -&gt; m a) -&gt; [a] -&gt; m a
</span><a href="Control.Monad.Extra.html#fold1M"><span class="hs-identifier hs-var">fold1M</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; m a
</span><a href="#local-6989586621679069155"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069156"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m () -&gt; m ()
forall a b. m a -&gt; m b -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; m b -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-comment">-- Data.List for Monad</span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-comment">-- | A version of 'partition' that works with a monadic predicate.</span><span>
</span><span id="line-107"></span><span class="hs-comment">--</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- &gt; partitionM (Just . even) [1,2,3] == Just ([2], [1,3])</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- &gt; partitionM (const Nothing) [1,2,3] == Nothing</span><span>
</span><span id="line-110"></span><span id="local-6989586621679068939"><span id="local-6989586621679068940"><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-type">partitionM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068939"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068940"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068939"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068940"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068939"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068940"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068940"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-111"></span><span id="partitionM"><span class="annot"><span class="annottext">partitionM :: forall (m :: * -&gt; *) a.
Monad m =&gt;
(a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
</span><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var hs-var">partitionM</span></a></span></span><span> </span><span id="local-6989586621679069164"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069164"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([a], [a]) -&gt; m ([a], [a])
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-112"></span><span class="annot"><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var">partitionM</span></a></span><span> </span><span id="local-6989586621679069165"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069165"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679069166"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069166"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679069167"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069167"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-113"></span><span>    </span><span id="local-6989586621679069168"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069168"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069165"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069166"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-114"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679069169"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069169"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679069170"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069170"><span class="hs-identifier hs-var">bs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
forall (m :: * -&gt; *) a.
Monad m =&gt;
(a -&gt; m Bool) -&gt; [a] -&gt; m ([a], [a])
</span><a href="Control.Monad.Extra.html#partitionM"><span class="hs-identifier hs-var">partitionM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069165"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069167"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-115"></span><span>    </span><span class="annot"><span class="annottext">([a], [a]) -&gt; m ([a], [a])
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069166"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069168"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">]</span><span class="annot"><span class="annottext">[a] -&gt; [a] -&gt; [a]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069169"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069166"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069168"><span class="hs-identifier hs-var">res</span></a></span><span class="hs-special">]</span><span class="annot"><span class="annottext">[a] -&gt; [a] -&gt; [a]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069170"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="annot"><span class="hs-comment">-- | A version of 'concatMap' that works with a monadic predicate.</span></span><span>
</span><span id="line-119"></span><span id="local-6989586621679068944"><span id="local-6989586621679068945"><span id="local-6989586621679068946"><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-type">concatMapM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068944"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068945"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068944"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068946"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068945"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068944"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068946"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-120"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-pragma hs-type">concatMapM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-121"></span><span id="concatMapM"><span class="annot"><span class="annottext">concatMapM :: forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m [b]) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-var hs-var">concatMapM</span></a></span></span><span> </span><span id="local-6989586621679069178"><span class="annot"><span class="annottext">a -&gt; m [b]
</span><a href="#local-6989586621679069178"><span class="hs-identifier hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b] -&gt; m [b]) -&gt; m [b] -&gt; [a] -&gt; m [b]
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679069180"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679069180"><span class="annot"><span class="annottext">f :: a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679069180"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679069188"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069188"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679069189"><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069189"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679069190"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069190"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b]
</span><a href="#local-6989586621679069178"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069188"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; Bool
forall a. [a] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069190"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069189"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679069192"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069192"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069189"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; m [b]) -&gt; [b] -&gt; m [b]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069190"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">[b] -&gt; [b] -&gt; [b]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069192"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="hs-comment">-- | Like 'concatMapM', but has its arguments flipped, so can be used</span><span>
</span><span id="line-125"></span><span class="hs-comment">--   instead of the common @fmap concat $ forM@ pattern.</span><span>
</span><span id="line-126"></span><span id="local-6989586621679068957"><span id="local-6989586621679068958"><span id="local-6989586621679068959"><span class="annot"><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier hs-type">concatForM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068957"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068958"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068958"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068957"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068959"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068957"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068959"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-127"></span><span id="concatForM"><span class="annot"><span class="annottext">concatForM :: forall (m :: * -&gt; *) a b. Monad m =&gt; [a] -&gt; (a -&gt; m [b]) -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatForM"><span class="hs-identifier hs-var hs-var">concatForM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; m [b]) -&gt; [a] -&gt; m [b]) -&gt; [a] -&gt; (a -&gt; m [b]) -&gt; m [b]
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b]) -&gt; [a] -&gt; m [b]
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m [b]) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#concatMapM"><span class="hs-identifier hs-var">concatMapM</span></a></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span class="annot"><span class="hs-comment">-- | A version of 'mconcatMap' that works with a monadic predicate.</span></span><span>
</span><span id="line-130"></span><span id="local-6989586621679068966"><span id="local-6989586621679068967"><span id="local-6989586621679068968"><span class="annot"><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier hs-type">mconcatMapM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068966"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679068967"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068968"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068966"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068967"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068968"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068966"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068967"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-131"></span><span id="mconcatMapM"><span class="annot"><span class="annottext">mconcatMapM :: forall (m :: * -&gt; *) b a.
(Monad m, Monoid b) =&gt;
(a -&gt; m b) -&gt; [a] -&gt; m b
</span><a href="Control.Monad.Extra.html#mconcatMapM"><span class="hs-identifier hs-var hs-var">mconcatMapM</span></a></span></span><span> </span><span id="local-6989586621679069203"><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679069203"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([b] -&gt; b) -&gt; m [b] -&gt; m b
forall (m :: * -&gt; *) a1 r. Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
</span><span class="hs-identifier hs-var">liftM</span></span><span> </span><span class="annot"><span class="annottext">[b] -&gt; b
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">(m [b] -&gt; m b) -&gt; ([a] -&gt; m [b]) -&gt; [a] -&gt; m b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; [a] -&gt; m [b]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><a href="#local-6989586621679069203"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="annot"><span class="hs-comment">-- | A version of 'mapMaybe' that works with a monadic predicate.</span></span><span>
</span><span id="line-134"></span><span id="local-6989586621679068980"><span id="local-6989586621679068981"><span id="local-6989586621679068982"><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier hs-type">mapMaybeM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068980"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068981"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068980"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679068982"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068981"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068980"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679068982"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-135"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-pragma hs-type">mapMaybeM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-136"></span><span id="mapMaybeM"><span class="annot"><span class="annottext">mapMaybeM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m [b]
</span><a href="Control.Monad.Extra.html#mapMaybeM"><span class="hs-identifier hs-var hs-var">mapMaybeM</span></a></span></span><span> </span><span id="local-6989586621679069212"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069212"><span class="hs-identifier hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m [b] -&gt; m [b]) -&gt; m [b] -&gt; [a] -&gt; m [b]
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679069213"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679069213"><span class="annot"><span class="annottext">f :: a -&gt; m [b] -&gt; m [b]
</span><a href="#local-6989586621679069213"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679069220"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069220"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679069221"><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069221"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679069222"><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679069222"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069212"><span class="hs-identifier hs-var">op</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069220"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe b
</span><a href="#local-6989586621679069222"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span class="annot"><span class="annottext">Maybe b
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069221"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679069223"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069223"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679069224"><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069224"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m [b]
</span><a href="#local-6989586621679069221"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; m [b]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; m [b]) -&gt; [b] -&gt; m [b]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069223"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">b -&gt; [b] -&gt; [b]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[b]
</span><a href="#local-6989586621679069224"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-comment">-- Looping</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="hs-comment">-- | A looping operation, where the predicate returns 'Left' as a seed for the next loop</span><span>
</span><span id="line-142"></span><span class="hs-comment">--   or 'Right' to abort the loop.</span><span>
</span><span id="line-143"></span><span class="hs-comment">--</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- &gt; loop (\x -&gt; if x &lt; 10 then Left $ x * 2 else Right $ show x) 1 == &quot;16&quot;</span><span>
</span><span id="line-145"></span><span id="local-6989586621679068986"><span id="local-6989586621679068987"><span class="annot"><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-type">loop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068986"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679068986"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068987"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068986"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068987"><span class="hs-identifier hs-type">b</span></a></span></span></span><span>
</span><span id="line-146"></span><span id="loop"><span class="annot"><span class="annottext">loop :: forall a b. (a -&gt; Either a b) -&gt; a -&gt; b
</span><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-var hs-var">loop</span></a></span></span><span> </span><span id="local-6989586621679069225"><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679069225"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679069226"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069226"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679069225"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069226"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-147"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679069227"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069227"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a -&gt; Either a b) -&gt; a -&gt; b
forall a b. (a -&gt; Either a b) -&gt; a -&gt; b
</span><a href="Control.Monad.Extra.html#loop"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; Either a b
</span><a href="#local-6989586621679069225"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069227"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-148"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679069228"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069228"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069228"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span class="hs-comment">-- | A monadic version of 'loop', where the predicate returns 'Left' as a seed for the next loop</span><span>
</span><span id="line-151"></span><span class="hs-comment">--   or 'Right' to abort the loop.</span><span>
</span><span id="line-152"></span><span id="local-6989586621679068990"><span id="local-6989586621679068991"><span id="local-6989586621679068992"><span class="annot"><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-type">loopM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068990"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679068991"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068990"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679068991"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068992"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068991"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068990"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679068992"><span class="hs-identifier hs-type">b</span></a></span></span></span></span><span>
</span><span id="line-153"></span><span id="loopM"><span class="annot"><span class="annottext">loopM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Either a b)) -&gt; a -&gt; m b
</span><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-var hs-var">loopM</span></a></span></span><span> </span><span id="local-6989586621679069234"><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679069234"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span id="local-6989586621679069235"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069235"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-154"></span><span>    </span><span id="local-6989586621679069236"><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679069236"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679069234"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069235"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Either a b
</span><a href="#local-6989586621679069236"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-156"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span id="local-6989586621679069237"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069237"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m (Either a b)) -&gt; a -&gt; m b
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Either a b)) -&gt; a -&gt; m b
</span><a href="Control.Monad.Extra.html#loopM"><span class="hs-identifier hs-var">loopM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Either a b)
</span><a href="#local-6989586621679069234"><span class="hs-identifier hs-var">act</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069237"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-157"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679069238"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069238"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">b -&gt; m b
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679069238"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-comment">-- | Keep running an operation until it becomes 'False'. As an example:</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- whileM $ do sleep 0.1; notM $ doesFileExist &quot;foo.txt&quot;</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- readFile &quot;foo.txt&quot;</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-165"></span><span class="hs-comment">--</span><span>
</span><span id="line-166"></span><span class="hs-comment">--   If you need some state persisted between each test, use 'loopM'.</span><span>
</span><span id="line-167"></span><span id="local-6989586621679068996"><span class="annot"><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-type">whileM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068996"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068996"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068996"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-168"></span><span id="whileM"><span class="annot"><span class="annottext">whileM :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m ()
</span><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-var hs-var">whileM</span></a></span></span><span> </span><span id="local-6989586621679069244"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069244"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-169"></span><span>    </span><span id="local-6989586621679069245"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069245"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069244"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-170"></span><span>    </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069245"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">(m () -&gt; m ()) -&gt; m () -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m ()
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m ()
</span><a href="Control.Monad.Extra.html#whileM"><span class="hs-identifier hs-var">whileM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069244"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span class="hs-comment">-- | Keep running an operation until it becomes a 'Nothing', accumulating the</span><span>
</span><span id="line-173"></span><span class="hs-comment">--   monoid results inside the 'Just's as the result of the overall loop.</span><span>
</span><span id="line-174"></span><span id="local-6989586621679068999"><span id="local-6989586621679069000"><span class="annot"><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier hs-type">whileJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679068999"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="#local-6989586621679069000"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068999"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679069000"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679068999"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679069000"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-175"></span><span id="whileJustM"><span class="annot"><span class="annottext">whileJustM :: forall (m :: * -&gt; *) a. (Monad m, Monoid a) =&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#whileJustM"><span class="hs-identifier hs-var hs-var">whileJustM</span></a></span></span><span> </span><span id="local-6989586621679069253"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069253"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679069254"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">a
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-177"></span><span>    </span><span id="local-6989586621679069254"><span class="annot"><span class="annottext">go :: a -&gt; m a
</span><a href="#local-6989586621679069254"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679069261"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069261"><span class="hs-identifier hs-var">accum</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-178"></span><span>        </span><span id="local-6989586621679069262"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069262"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069253"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-179"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069262"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-180"></span><span>            </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069261"><span class="hs-identifier hs-var">accum</span></a></span><span>
</span><span id="line-181"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679069263"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069263"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
</span><a href="#local-6989586621679069254"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m a) -&gt; a -&gt; m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069261"><span class="hs-identifier hs-var">accum</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069263"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- strict apply, otherwise space leaks</span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span class="hs-comment">-- | Keep running an operation until it becomes a 'Just', then return the value</span><span>
</span><span id="line-184"></span><span class="hs-comment">--   inside the 'Just' as the result of the overall loop.</span><span>
</span><span id="line-185"></span><span id="local-6989586621679069004"><span id="local-6989586621679069005"><span class="annot"><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-type">untilJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069004"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069004"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679069005"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069004"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679069005"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-186"></span><span id="untilJustM"><span class="annot"><span class="annottext">untilJustM :: forall (m :: * -&gt; *) a. Monad m =&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-var hs-var">untilJustM</span></a></span></span><span> </span><span id="local-6989586621679069270"><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069270"><span class="hs-identifier hs-var">act</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-187"></span><span>    </span><span id="local-6989586621679069271"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069271"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069270"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679069271"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-189"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679069272"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069272"><span class="hs-identifier hs-var">r</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069272"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-190"></span><span>        </span><span class="annot"><span class="annottext">Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Maybe a) -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; m (Maybe a) -&gt; m a
</span><a href="Control.Monad.Extra.html#untilJustM"><span class="hs-identifier hs-var">untilJustM</span></a></span><span> </span><span class="annot"><span class="annottext">m (Maybe a)
</span><a href="#local-6989586621679069270"><span class="hs-identifier hs-var">act</span></a></span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span class="hs-comment">-- Booleans</span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span class="annot"><span class="hs-comment">-- | Like 'when', but where the test can be monadic.</span></span><span>
</span><span id="line-195"></span><span id="local-6989586621679069008"><span class="annot"><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier hs-type">whenM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069008"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069008"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069008"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069008"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-196"></span><span id="whenM"><span class="annot"><span class="annottext">whenM :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#whenM"><span class="hs-identifier hs-var hs-var">whenM</span></a></span></span><span> </span><span id="local-6989586621679069277"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069277"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679069278"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679069278"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069277"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679069278"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span>
</span><span id="line-198"></span><span class="annot"><span class="hs-comment">-- | Like 'unless', but where the test can be monadic.</span></span><span>
</span><span id="line-199"></span><span id="local-6989586621679069280"><span class="annot"><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier hs-type">unlessM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069280"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069280"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069280"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069280"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-200"></span><span id="unlessM"><span class="annot"><span class="annottext">unlessM :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m () -&gt; m ()
</span><a href="Control.Monad.Extra.html#unlessM"><span class="hs-identifier hs-var hs-var">unlessM</span></a></span></span><span> </span><span id="local-6989586621679069285"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069285"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679069286"><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679069286"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m () -&gt; m () -&gt; m ()
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069285"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679069286"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span class="annot"><span class="hs-comment">-- | Like @if@, but where the test can be monadic.</span></span><span>
</span><span id="line-203"></span><span id="local-6989586621679069010"><span id="local-6989586621679069011"><span class="annot"><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-type">ifM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069010"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069010"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069010"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679069011"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069010"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679069011"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069010"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679069011"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-204"></span><span id="ifM"><span class="annot"><span class="annottext">ifM :: forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var hs-var">ifM</span></a></span></span><span> </span><span id="local-6989586621679069289"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069289"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621679069290"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069290"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679069291"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069291"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679069292"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069292"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069289"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">;</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679069292"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069290"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679069291"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span class="annot"><span class="hs-comment">-- | Like 'not', but where the test can be monadic.</span></span><span>
</span><span id="line-207"></span><span id="local-6989586621679069015"><span class="annot"><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier hs-type">notM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Functor</span></span><span> </span><span class="annot"><a href="#local-6989586621679069015"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069015"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069015"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-208"></span><span id="notM"><span class="annot"><span class="annottext">notM :: forall (m :: * -&gt; *). Functor m =&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#notM"><span class="hs-identifier hs-var hs-var">notM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; m Bool -&gt; m Bool
forall a b. (a -&gt; b) -&gt; m a -&gt; m b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span class="hs-comment">-- | The lazy '||' operator lifted to a monad. If the first</span><span>
</span><span id="line-211"></span><span class="hs-comment">--   argument evaluates to 'True' the second argument will not</span><span>
</span><span id="line-212"></span><span class="hs-comment">--   be evaluated.</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- &gt; Just True  ||^ undefined  == Just True</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- &gt; Just False ||^ Just True  == Just True</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- &gt; Just False ||^ Just False == Just False</span><span>
</span><span id="line-217"></span><span id="local-6989586621679069020"><span class="annot"><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-type">(||^)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069020"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069020"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069020"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069020"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-218"></span><span id="%7C%7C%5E"><span class="annot"><span class="annottext">||^ :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-var hs-var">(||^)</span></a></span></span><span> </span><span id="local-6989586621679069300"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069300"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679069301"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069301"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069300"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069301"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-219"></span><span>
</span><span id="line-220"></span><span class="hs-comment">-- | The lazy '&amp;&amp;' operator lifted to a monad. If the first</span><span>
</span><span id="line-221"></span><span class="hs-comment">--   argument evaluates to 'False' the second argument will not</span><span>
</span><span id="line-222"></span><span class="hs-comment">--   be evaluated.</span><span>
</span><span id="line-223"></span><span class="hs-comment">--</span><span>
</span><span id="line-224"></span><span class="hs-comment">-- &gt; Just False &amp;&amp;^ undefined  == Just False</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- &gt; Just True  &amp;&amp;^ Just True  == Just True</span><span>
</span><span id="line-226"></span><span class="hs-comment">-- &gt; Just True  &amp;&amp;^ Just False == Just False</span><span>
</span><span id="line-227"></span><span id="local-6989586621679069303"><span class="annot"><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-type">(&amp;&amp;^)</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069303"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-228"></span><span id="%26%26%5E"><span class="annot"><span class="annottext">&amp;&amp;^ :: forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-var hs-var">(&amp;&amp;^)</span></a></span></span><span> </span><span id="local-6989586621679069308"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069308"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679069309"><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069309"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069308"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool
</span><a href="#local-6989586621679069309"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="hs-comment">-- | A version of 'any' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-231"></span><span class="hs-comment">--</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- &gt; anyM Just [False,True ,undefined] == Just True</span><span>
</span><span id="line-233"></span><span class="hs-comment">-- &gt; anyM Just [False,False,undefined] == undefined</span><span>
</span><span id="line-234"></span><span class="hs-comment">-- &gt; \(f :: Int -&gt; Maybe Bool) xs -&gt; anyM f xs == orM (map f xs)</span><span>
</span><span id="line-235"></span><span id="local-6989586621679069023"><span id="local-6989586621679069024"><span class="annot"><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-type">anyM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069023"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679069024"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069023"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069024"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069023"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-236"></span><span id="anyM"><span class="annot"><span class="annottext">anyM :: forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-var hs-var">anyM</span></a></span></span><span> </span><span id="local-6989586621679069316"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069316"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool -&gt; m Bool) -&gt; m Bool -&gt; [a] -&gt; m Bool
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%7C%7C%5E"><span class="hs-operator hs-var">(||^)</span></a></span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool -&gt; m Bool)
-&gt; (a -&gt; m Bool) -&gt; a -&gt; m Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069316"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="hs-comment">-- | A version of 'all' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-239"></span><span class="hs-comment">--</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- &gt; allM Just [True,False,undefined] == Just False</span><span>
</span><span id="line-241"></span><span class="hs-comment">-- &gt; allM Just [True,True ,undefined] == undefined</span><span>
</span><span id="line-242"></span><span class="hs-comment">-- &gt; \(f :: Int -&gt; Maybe Bool) xs -&gt; anyM f xs == orM (map f xs)</span><span>
</span><span id="line-243"></span><span id="local-6989586621679069318"><span id="local-6989586621679069319"><span class="annot"><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-type">allM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069318"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679069319"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069318"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069319"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069318"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-244"></span><span id="allM"><span class="annot"><span class="annottext">allM :: forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-var hs-var">allM</span></a></span></span><span> </span><span id="local-6989586621679069325"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069325"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m Bool -&gt; m Bool) -&gt; m Bool -&gt; [a] -&gt; m Bool
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Control.Monad.Extra.html#%26%26%5E"><span class="hs-operator hs-var">(&amp;&amp;^)</span></a></span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool -&gt; m Bool)
-&gt; (a -&gt; m Bool) -&gt; a -&gt; m Bool -&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069325"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span class="hs-comment">-- | A version of 'or' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-247"></span><span class="hs-comment">--</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- &gt; orM [Just False,Just True ,undefined] == Just True</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- &gt; orM [Just False,Just False,undefined] == undefined</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- &gt; \xs -&gt; Just (or xs) == orM (map Just xs)</span><span>
</span><span id="line-251"></span><span id="local-6989586621679069029"><span class="annot"><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier hs-type">orM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069029"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069029"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069029"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-252"></span><span id="orM"><span class="annot"><span class="annottext">orM :: forall (m :: * -&gt; *). Monad m =&gt; [m Bool] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#orM"><span class="hs-identifier hs-var hs-var">orM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool) -&gt; [m Bool] -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#anyM"><span class="hs-identifier hs-var">anyM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-comment">-- | A version of 'and' lifted to a monad. Retains the short-circuiting behaviour.</span><span>
</span><span id="line-255"></span><span class="hs-comment">--</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- &gt; andM [Just True,Just False,undefined] == Just False</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- &gt; andM [Just True,Just True ,undefined] == undefined</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- &gt; \xs -&gt; Just (and xs) == andM (map Just xs)</span><span>
</span><span id="line-259"></span><span id="local-6989586621679069330"><span class="annot"><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier hs-type">andM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069330"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069330"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069330"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-260"></span><span id="andM"><span class="annot"><span class="annottext">andM :: forall (m :: * -&gt; *). Monad m =&gt; [m Bool] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#andM"><span class="hs-identifier hs-var hs-var">andM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(m Bool -&gt; m Bool) -&gt; [m Bool] -&gt; m Bool
forall (m :: * -&gt; *) a. Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m Bool
</span><a href="Control.Monad.Extra.html#allM"><span class="hs-identifier hs-var">allM</span></a></span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-261"></span><span>
</span><span id="line-262"></span><span class="hs-comment">-- Searching</span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span class="hs-comment">-- | Like 'find', but where the test can be monadic.</span><span>
</span><span id="line-265"></span><span class="hs-comment">--</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- &gt; findM (Just . isUpper) &quot;teST&quot;             == Just (Just 'S')</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- &gt; findM (Just . isUpper) &quot;test&quot;             == Just Nothing</span><span>
</span><span id="line-268"></span><span class="hs-comment">-- &gt; findM (Just . const True) [&quot;x&quot;,undefined] == Just (Just &quot;x&quot;)</span><span>
</span><span id="line-269"></span><span id="local-6989586621679069032"><span id="local-6989586621679069033"><span class="annot"><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier hs-type">findM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069032"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679069033"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069032"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069033"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069032"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679069033"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-270"></span><span id="findM"><span class="annot"><span class="annottext">findM :: forall (m :: * -&gt; *) a.
Monad m =&gt;
(a -&gt; m Bool) -&gt; [a] -&gt; m (Maybe a)
</span><a href="Control.Monad.Extra.html#findM"><span class="hs-identifier hs-var hs-var">findM</span></a></span></span><span> </span><span id="local-6989586621679069339"><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069339"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m (Maybe a) -&gt; m (Maybe a))
-&gt; m (Maybe a) -&gt; [a] -&gt; m (Maybe a)
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679069340"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069340"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m (Maybe a) -&gt; m (Maybe a) -&gt; m (Maybe a)
forall (m :: * -&gt; *) a. Monad m =&gt; m Bool -&gt; m a -&gt; m a -&gt; m a
</span><a href="Control.Monad.Extra.html#ifM"><span class="hs-identifier hs-var">ifM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m Bool
</span><a href="#local-6989586621679069339"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069340"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; m (Maybe a)) -&gt; Maybe a -&gt; m (Maybe a)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069340"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe a -&gt; m (Maybe a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="annot"><span class="hs-comment">-- | Like 'findM', but also allows you to compute some additional information in the predicate.</span></span><span>
</span><span id="line-273"></span><span id="local-6989586621679069036"><span id="local-6989586621679069037"><span id="local-6989586621679069038"><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-type">firstJustM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679069036"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679069037"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069036"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679069038"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679069037"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679069036"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679069038"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-274"></span><span id="firstJustM"><span class="annot"><span class="annottext">firstJustM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
</span><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var hs-var">firstJustM</span></a></span></span><span> </span><span id="local-6989586621679069347"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069347"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe b -&gt; m (Maybe b)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe b
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-275"></span><span class="annot"><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var">firstJustM</span></a></span><span> </span><span id="local-6989586621679069348"><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069348"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679069349"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069349"><span class="hs-identifier hs-var">x</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679069350"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069350"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (Maybe b) -&gt; (b -&gt; m (Maybe b)) -&gt; m (Maybe b) -&gt; m (Maybe b)
forall (m :: * -&gt; *) b a.
Monad m =&gt;
m b -&gt; (a -&gt; m b) -&gt; m (Maybe a) -&gt; m b
</span><a href="Control.Monad.Extra.html#maybeM"><span class="hs-identifier hs-var">maybeM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m (Maybe b)) -&gt; [a] -&gt; m (Maybe b)
</span><a href="Control.Monad.Extra.html#firstJustM"><span class="hs-identifier hs-var">firstJustM</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069348"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679069350"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe b -&gt; m (Maybe b)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; m (Maybe b)) -&gt; (b -&gt; Maybe b) -&gt; b -&gt; m (Maybe b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Maybe b
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; m (Maybe b)
</span><a href="#local-6989586621679069348"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679069349"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-276"></span></pre></body></html>