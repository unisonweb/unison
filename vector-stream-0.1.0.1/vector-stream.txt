-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Streams
--   
--   Simple yet powerful monadic streams that are used as a backbone for
--   vector package fusion functionality.
@package vector-stream
@version 0.1.0.1


-- | Monadic stream combinators.
module Data.Stream.Monadic

-- | Box monad
data Box a
Box :: a -> Box a
[unBox] :: Box a -> a
liftBox :: Monad m => Box a -> m a

-- | Monadic streams
data Stream m a
Stream :: (s -> m (Step s a)) -> s -> Stream m a

-- | Result of taking a single step in a stream
data Step s a
[Yield] :: a -> s -> Step s a
[Skip] :: s -> Step s a
[Done] :: Step s a

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data () => SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | Length of a <a>Stream</a>
length :: Monad m => Stream m a -> m Int

-- | Check if a <a>Stream</a> is empty
null :: Monad m => Stream m a -> m Bool

-- | Empty <a>Stream</a>
empty :: Monad m => Stream m a

-- | Singleton <a>Stream</a>
singleton :: Monad m => a -> Stream m a

-- | Prepend an element
cons :: Monad m => a -> Stream m a -> Stream m a

-- | Append an element
snoc :: Monad m => Stream m a -> a -> Stream m a

-- | Replicate a value to a given length
replicate :: Monad m => Int -> a -> Stream m a

-- | Yield a <a>Stream</a> of values obtained by performing the monadic
--   action the given number of times
replicateM :: Monad m => Int -> m a -> Stream m a
generate :: Monad m => Int -> (Int -> a) -> Stream m a

-- | Generate a stream from its indices
generateM :: Monad m => Int -> (Int -> m a) -> Stream m a

-- | Concatenate two <a>Stream</a>s
(++) :: Monad m => Stream m a -> Stream m a -> Stream m a
infixr 5 ++

-- | First element of the <a>Stream</a> or error if empty
head :: (HasCallStack, Monad m) => Stream m a -> m a

-- | Last element of the <a>Stream</a> or error if empty
last :: (HasCallStack, Monad m) => Stream m a -> m a

-- | Element at the given position
(!!) :: (HasCallStack, Monad m) => Stream m a -> Int -> m a
infixl 9 !!

-- | Element at the given position or <a>Nothing</a> if out of bounds
(!?) :: Monad m => Stream m a -> Int -> m (Maybe a)
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Monad m => Int -> Int -> Stream m a -> Stream m a

-- | All but the last element
init :: (HasCallStack, Monad m) => Stream m a -> Stream m a

-- | All but the first element
tail :: (HasCallStack, Monad m) => Stream m a -> Stream m a

-- | The first <tt>n</tt> elements
take :: Monad m => Int -> Stream m a -> Stream m a

-- | All but the first <tt>n</tt> elements
drop :: Monad m => Int -> Stream m a -> Stream m a

-- | Map a function over a <a>Stream</a>
map :: Monad m => (a -> b) -> Stream m a -> Stream m b

-- | Map a monadic function over a <a>Stream</a>
mapM :: Monad m => (a -> m b) -> Stream m a -> Stream m b

-- | Execute a monadic action for each element of the <a>Stream</a>
mapM_ :: Monad m => (a -> m b) -> Stream m a -> m ()

-- | Transform a <a>Stream</a> to use a different monad
trans :: (Monad m, Monad m') => (forall z. m z -> m' z) -> Stream m a -> Stream m' a
unbox :: Monad m => Stream m (Box a) -> Stream m a
concatMap :: Monad m => (a -> Stream m b) -> Stream m a -> Stream m b

-- | Create a <a>Stream</a> of values from a <a>Stream</a> of streamable
--   things
flatten :: Monad m => (a -> m s) -> (s -> m (Step s b)) -> Stream m a -> Stream m b

-- | Pair each element in a <a>Stream</a> with its index
indexed :: Monad m => Stream m a -> Stream m (Int, a)

-- | Pair each element in a <a>Stream</a> with its index, starting from the
--   right and counting down
indexedR :: Monad m => Int -> Stream m a -> Stream m (Int, a)
zipWithM_ :: Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> m ()

-- | Zip two <a>Stream</a>s with the given monadic function
zipWithM :: Monad m => (a -> b -> m c) -> Stream m a -> Stream m b -> Stream m c
zipWith3M :: Monad m => (a -> b -> c -> m d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
zipWith5M :: Monad m => (a -> b -> c -> d -> e -> m f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
zipWith6M :: Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
zipWith :: Monad m => (a -> b -> c) -> Stream m a -> Stream m b -> Stream m c
zipWith3 :: Monad m => (a -> b -> c -> d) -> Stream m a -> Stream m b -> Stream m c -> Stream m d
zipWith4 :: Monad m => (a -> b -> c -> d -> e) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e
zipWith5 :: Monad m => (a -> b -> c -> d -> e -> f) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f
zipWith6 :: Monad m => (a -> b -> c -> d -> e -> f -> g) -> Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m g
zip :: Monad m => Stream m a -> Stream m b -> Stream m (a, b)
zip3 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m (a, b, c)
zip4 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m (a, b, c, d)
zip5 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m (a, b, c, d, e)
zip6 :: Monad m => Stream m a -> Stream m b -> Stream m c -> Stream m d -> Stream m e -> Stream m f -> Stream m (a, b, c, d, e, f)

-- | Check if two <a>Stream</a>s are equal
eqBy :: Monad m => (a -> b -> Bool) -> Stream m a -> Stream m b -> m Bool

-- | Lexicographically compare two <a>Stream</a>s
cmpBy :: Monad m => (a -> b -> Ordering) -> Stream m a -> Stream m b -> m Ordering

-- | Drop elements which do not satisfy the predicate
filter :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Drop elements which do not satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Drop repeated adjacent elements.
uniq :: (Eq a, Monad m) => Stream m a -> Stream m a
mapMaybe :: Monad m => (a -> Maybe b) -> Stream m a -> Stream m b

-- | Apply monadic function to each element and drop all Nothings
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> Stream m a -> Stream m b
catMaybes :: Monad m => Stream m (Maybe a) -> Stream m a

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Longest prefix of elements that satisfy the monadic predicate
takeWhileM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: Monad m => (a -> Bool) -> Stream m a -> Stream m a

-- | Drop the longest prefix of elements that satisfy the monadic predicate
dropWhileM :: Monad m => (a -> m Bool) -> Stream m a -> Stream m a

-- | Check whether the <a>Stream</a> contains an element
elem :: (Monad m, Eq a) => a -> Stream m a -> m Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: (Monad m, Eq a) => a -> Stream m a -> m Bool
infix 4 `notElem`

-- | Yield <a>Just</a> the first element that satisfies the predicate or
--   <a>Nothing</a> if no such element exists.
find :: Monad m => (a -> Bool) -> Stream m a -> m (Maybe a)

-- | Yield <a>Just</a> the first element that satisfies the monadic
--   predicate or <a>Nothing</a> if no such element exists.
findM :: Monad m => (a -> m Bool) -> Stream m a -> m (Maybe a)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   predicate or <a>Nothing</a> if no such element exists.
findIndex :: Monad m => (a -> Bool) -> Stream m a -> m (Maybe Int)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   monadic predicate or <a>Nothing</a> if no such element exists.
findIndexM :: Monad m => (a -> m Bool) -> Stream m a -> m (Maybe Int)

-- | Left fold
foldl :: Monad m => (a -> b -> a) -> a -> Stream m b -> m a

-- | Left fold with a monadic operator
foldlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Left fold over a non-empty <a>Stream</a>
foldl1 :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Left fold over a non-empty <a>Stream</a> with a monadic operator
foldl1M :: (HasCallStack, Monad m) => (a -> a -> m a) -> Stream m a -> m a

-- | Same as <a>foldlM</a>
foldM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Same as <a>foldl1M</a>
fold1M :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Left fold with a strict accumulator
foldl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> m a

-- | Left fold with a strict accumulator and a monadic operator
foldlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Left fold over a non-empty <a>Stream</a> with a strict accumulator
foldl1' :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Left fold over a non-empty <a>Stream</a> with a strict accumulator and
--   a monadic operator
foldl1M' :: (HasCallStack, Monad m) => (a -> a -> m a) -> Stream m a -> m a

-- | Same as <a>foldlM'</a>
foldM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> m a

-- | Same as <a>foldl1M'</a>
fold1M' :: Monad m => (a -> a -> m a) -> Stream m a -> m a

-- | Right fold
foldr :: Monad m => (a -> b -> b) -> b -> Stream m a -> m b

-- | Right fold with a monadic operator
foldrM :: Monad m => (a -> b -> m b) -> b -> Stream m a -> m b

-- | Right fold over a non-empty stream
foldr1 :: Monad m => (a -> a -> a) -> Stream m a -> m a

-- | Right fold over a non-empty stream with a monadic operator
foldr1M :: (HasCallStack, Monad m) => (a -> a -> m a) -> Stream m a -> m a
and :: Monad m => Stream m Bool -> m Bool
or :: Monad m => Stream m Bool -> m Bool
concatMapM :: Monad m => (a -> m (Stream m b)) -> Stream m a -> Stream m b

-- | Unfold
unfoldr :: Monad m => (s -> Maybe (a, s)) -> s -> Stream m a

-- | Unfold with a monadic function
unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Stream m a
unfoldrN :: Monad m => Int -> (s -> Maybe (a, s)) -> s -> Stream m a

-- | Unfold at most <tt>n</tt> elements with a monadic function.
unfoldrNM :: Monad m => Int -> (s -> m (Maybe (a, s))) -> s -> Stream m a

-- | Unfold exactly <tt>n</tt> elements
unfoldrExactN :: Monad m => Int -> (s -> (a, s)) -> s -> Stream m a

-- | Unfold exactly <tt>n</tt> elements with a monadic function.
unfoldrExactNM :: Monad m => Int -> (s -> m (a, s)) -> s -> Stream m a

-- | <i>O(n)</i> Apply function &lt;math&gt; times to an initial value,
--   producing a stream of &lt;math&gt; values.
iterateN :: Monad m => Int -> (a -> a) -> a -> Stream m a

-- | <i>O(n)</i> Apply monadic function &lt;math&gt; times to an initial
--   value, producing a stream of &lt;math&gt; values.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> Stream m a

-- | Prefix scan
prescanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with a monadic operator
prescanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with strict accumulator
prescanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Prefix scan with strict accumulator and a monadic operator
prescanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Suffix scan
postscanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with a monadic operator
postscanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with strict accumulator
postscanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Suffix scan with strict acccumulator and a monadic operator
postscanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan
scanl :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with a monadic operator
scanlM :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with strict accumulator
scanl' :: Monad m => (a -> b -> a) -> a -> Stream m b -> Stream m a

-- | Haskell-style scan with strict accumulator and a monadic operator
scanlM' :: Monad m => (a -> b -> m a) -> a -> Stream m b -> Stream m a

-- | Initial-value free scan over a <a>Stream</a>
scanl1 :: Monad m => (a -> a -> a) -> Stream m a -> Stream m a

-- | Initial-value free scan over a <a>Stream</a> with a monadic operator
scanl1M :: Monad m => (a -> a -> m a) -> Stream m a -> Stream m a

-- | Initial-value free scan over a <a>Stream</a> with a strict accumulator
scanl1' :: Monad m => (a -> a -> a) -> Stream m a -> Stream m a

-- | Initial-value free scan over a <a>Stream</a> with a strict accumulator
--   and a monadic operator
scanl1M' :: Monad m => (a -> a -> m a) -> Stream m a -> Stream m a

-- | Yield a <a>Stream</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: (Num a, Monad m) => a -> a -> Int -> Stream m a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: (Enum a, Monad m) => a -> a -> Stream m a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operation is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Enum a, Monad m) => a -> a -> a -> Stream m a

-- | Convert a <a>Stream</a> to a list
toList :: Monad m => Stream m a -> m [a]

-- | Convert a list to a <a>Stream</a>
fromList :: Monad m => [a] -> Stream m a

-- | Convert the first <tt>n</tt> elements of a list to a <tt>Bundle</tt>
fromListN :: Monad m => Int -> [a] -> Stream m a
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Stream.Monadic.Stream m)
instance GHC.Base.Functor (Data.Stream.Monadic.Step s)
instance GHC.Base.Functor Data.Stream.Monadic.Box
instance GHC.Base.Applicative Data.Stream.Monadic.Box
instance GHC.Base.Monad Data.Stream.Monadic.Box
