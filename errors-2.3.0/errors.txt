-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simplified error-handling
--   
--   The one-stop shop for all your error-handling needs! Just import
--   <a>Control.Error</a>.
--   
--   This library encourages an error-handling style that directly uses the
--   type system, rather than out-of-band exceptions.
@package errors
@version 2.3.0


-- | This module exports miscellaneous error-handling functions.
module Control.Error.Util

-- | Suppress the <a>Left</a> value of an <a>Either</a>
hush :: Either a b -> Maybe b

-- | Suppress the <a>Left</a> value of an <a>ExceptT</a>
hushT :: Monad m => ExceptT a m b -> MaybeT m b

-- | Tag the <a>Nothing</a> value of a <a>Maybe</a>
note :: a -> Maybe b -> Either a b

-- | Tag the <a>Nothing</a> value of a <a>MaybeT</a>
noteT :: Monad m => a -> MaybeT m b -> ExceptT a m b

-- | Lift a <a>Maybe</a> to the <a>MaybeT</a> monad
hoistMaybe :: Monad m => Maybe b -> MaybeT m b

-- | Upgrade an <a>Either</a> to an <a>ExceptT</a>
hoistEither :: Monad m => Either e a -> ExceptT e m a

-- | Convert a <a>Maybe</a> value into the <a>ExceptT</a> monad
(??) :: Applicative m => Maybe a -> e -> ExceptT e m a

-- | Convert an applicative <a>Maybe</a> value into the <a>ExceptT</a>
--   monad
(!?) :: Applicative m => m (Maybe a) -> e -> ExceptT e m a

-- | Convert a <a>Maybe</a> value into the <a>ExceptT</a> monad
--   
--   Named version of (<a>??</a>) with arguments flipped
failWith :: Applicative m => e -> Maybe a -> ExceptT e m a

-- | Convert an applicative <a>Maybe</a> value into the <a>ExceptT</a>
--   monad
--   
--   Named version of (<a>!?</a>) with arguments flipped
failWithM :: Applicative m => e -> m (Maybe a) -> ExceptT e m a

-- | Case analysis for the <a>Bool</a> type.
--   
--   <pre>
--   bool a b c == if c then b else a
--   </pre>
bool :: a -> a -> Bool -> a

-- | An infix form of <a>fromMaybe</a> with arguments flipped.
(?:) :: Maybe a -> a -> a
infixr 0 ?:

-- | Case analysis for <a>MaybeT</a>
--   
--   Use the first argument if the <a>MaybeT</a> computation fails,
--   otherwise apply the function to the successful result.
maybeT :: Monad m => m b -> (a -> m b) -> MaybeT m a -> m b

-- | Analogous to <a>Just</a> and equivalent to <a>return</a>
just :: Monad m => a -> MaybeT m a

-- | Analogous to <a>Nothing</a> and equivalent to <tt>mzero</tt>
nothing :: Monad m => MaybeT m a

-- | Analogous to <a>isJust</a>, but for <a>MaybeT</a>
isJustT :: Monad m => MaybeT m a -> m Bool

-- | Analogous to <a>isNothing</a>, but for <a>MaybeT</a>
isNothingT :: Monad m => MaybeT m a -> m Bool

-- | Returns whether argument is a <a>Left</a>
isLeft :: Either a b -> Bool

-- | Returns whether argument is a <a>Right</a>
isRight :: Either a b -> Bool

-- | <a>fmap</a> specialized to <a>Either</a>, given a name symmetric to
--   <a>fmapL</a>
fmapR :: (a -> b) -> Either l a -> Either l b

-- | Run multiple <a>Either</a> computations and succeed if all of them
--   succeed
--   
--   <a>mappend</a>s all successes or failures
newtype AllE e r
AllE :: Either e r -> AllE e r
[runAllE] :: AllE e r -> Either e r

-- | Run multiple <a>Either</a> computations and succeed if any of them
--   succeed
--   
--   <a>mappend</a>s all successes or failures
newtype AnyE e r
AnyE :: Either e r -> AnyE e r
[runAnyE] :: AnyE e r -> Either e r

-- | Analogous to <a>isLeft</a>, but for <a>ExceptT</a>
isLeftT :: Monad m => ExceptT a m b -> m Bool

-- | Analogous to <a>isRight</a>, but for <a>ExceptT</a>
isRightT :: Monad m => ExceptT a m b -> m Bool

-- | <a>fmap</a> specialized to <a>ExceptT</a>, given a name symmetric to
--   <a>fmapLT</a>
fmapRT :: Monad m => (a -> b) -> ExceptT l m a -> ExceptT l m b

-- | Fold an <a>ExceptT</a> by providing one continuation for each
--   constructor
exceptT :: Monad m => (a -> m c) -> (b -> m c) -> ExceptT a m b -> m c

-- | Transform the left and right value
bimapExceptT :: Functor m => (e -> f) -> (a -> b) -> ExceptT e m a -> ExceptT f m b

-- | Write a string to standard error
err :: Text -> IO ()

-- | Write a string with a newline to standard error
errLn :: Text -> IO ()

-- | Catch <a>IOException</a>s and convert them to the <a>ExceptT</a> monad
tryIO :: MonadIO m => IO a -> ExceptT IOException m a

-- | Run a monad action which may throw an exception in the <a>ExceptT</a>
--   monad
handleExceptT :: (Exception e, Functor m, MonadCatch m) => (e -> x) -> m a -> ExceptT x m a

-- | Catch all exceptions, except for asynchronous exceptions found in
--   <tt>base</tt> and convert them to the <a>ExceptT</a> monad
syncIO :: MonadIO m => IO a -> ExceptT SomeException m a
instance (GHC.Base.Semigroup e, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Control.Error.Util.AnyE e r)
instance (GHC.Base.Monoid e, GHC.Base.Monoid r) => GHC.Base.Monoid (Control.Error.Util.AnyE e r)
instance (GHC.Base.Semigroup e, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Control.Error.Util.AllE e r)
instance (GHC.Base.Monoid e, GHC.Base.Monoid r) => GHC.Base.Monoid (Control.Error.Util.AllE e r)


-- | This module extends the <tt>safe</tt> library's functions with
--   corresponding versions compatible with <a>Either</a> and
--   <a>ExceptT</a>, and also provides a few <a>Maybe</a>-compatible
--   functions missing from <tt>safe</tt>.
--   
--   I suffix the <a>Either</a>-compatible functions with <tt>Err</tt> and
--   prefix the <a>ExceptT</a>-compatible functions with <tt>try</tt>.
--   
--   Note that this library re-exports the <a>Maybe</a> compatible
--   functions from <tt>safe</tt> in the <a>Control.Error</a> module, so
--   they are not provided here.
--   
--   The '<tt>Z</tt>'-suffixed functions generalize the <a>Maybe</a>
--   functions to also work with anything that implements <a>MonadPlus</a>,
--   including:
--   
--   <ul>
--   <li>Lists</li>
--   <li>Most parsers</li>
--   <li><a>ExceptT</a> (if the left value is a <a>Monoid</a>)</li>
--   </ul>
module Control.Error.Safe

-- | An assertion that fails in the <a>Maybe</a> monad
assertMay :: Bool -> Maybe ()

-- | A <tt>fromRight</tt> that fails in the <a>Maybe</a> monad
rightMay :: Either e a -> Maybe a

-- | A <a>tail</a> that fails in the <a>Either</a> monad
tailErr :: e -> [a] -> Either e [a]

-- | An <a>init</a> that fails in the <a>Either</a> monad
initErr :: e -> [a] -> Either e [a]

-- | A <a>head</a> that fails in the <a>Either</a> monad
headErr :: e -> [a] -> Either e a

-- | A <a>last</a> that fails in the <a>Either</a> monad
lastErr :: e -> [a] -> Either e a

-- | A <a>minimum</a> that fails in the <a>Either</a> monad
minimumErr :: Ord a => e -> [a] -> Either e a

-- | A <a>maximum</a> that fails in the <a>Either</a> monad
maximumErr :: Ord a => e -> [a] -> Either e a

-- | A <a>foldr1</a> that fails in the <a>Either</a> monad
foldr1Err :: e -> (a -> a -> a) -> [a] -> Either e a

-- | A <a>foldl1</a> that fails in the <a>Either</a> monad
foldl1Err :: e -> (a -> a -> a) -> [a] -> Either e a

-- | A <tt>foldl1'</tt> that fails in the <a>Either</a> monad
foldl1Err' :: e -> (a -> a -> a) -> [a] -> Either e a

-- | A (<a>!!</a>) that fails in the <a>Either</a> monad
atErr :: e -> [a] -> Int -> Either e a

-- | A <a>read</a> that fails in the <a>Either</a> monad
readErr :: Read a => e -> String -> Either e a

-- | An assertion that fails in the <a>Either</a> monad
assertErr :: e -> Bool -> Either e ()

-- | A <tt>fromJust</tt> that fails in the <a>Either</a> monad
justErr :: e -> Maybe a -> Either e a

-- | A <a>tail</a> that fails in the <a>ExceptT</a> monad
tryTail :: Monad m => e -> [a] -> ExceptT e m [a]

-- | An <a>init</a> that fails in the <a>ExceptT</a> monad
tryInit :: Monad m => e -> [a] -> ExceptT e m [a]

-- | A <a>head</a> that fails in the <a>ExceptT</a> monad
tryHead :: Monad m => e -> [a] -> ExceptT e m a

-- | A <a>last</a> that fails in the <a>ExceptT</a> monad
tryLast :: Monad m => e -> [a] -> ExceptT e m a

-- | A <a>minimum</a> that fails in the <a>ExceptT</a> monad
tryMinimum :: (Monad m, Ord a) => e -> [a] -> ExceptT e m a

-- | A <a>maximum</a> that fails in the <a>ExceptT</a> monad
tryMaximum :: (Monad m, Ord a) => e -> [a] -> ExceptT e m a

-- | A <a>foldr1</a> that fails in the <a>ExceptT</a> monad
tryFoldr1 :: Monad m => e -> (a -> a -> a) -> [a] -> ExceptT e m a

-- | A <a>foldl1</a> that fails in the <a>ExceptT</a> monad
tryFoldl1 :: Monad m => e -> (a -> a -> a) -> [a] -> ExceptT e m a

-- | A <tt>foldl1'</tt> that fails in the <a>ExceptT</a> monad
tryFoldl1' :: Monad m => e -> (a -> a -> a) -> [a] -> ExceptT e m a

-- | A (<a>!!</a>) that fails in the <a>ExceptT</a> monad
tryAt :: Monad m => e -> [a] -> Int -> ExceptT e m a

-- | A <a>read</a> that fails in the <a>ExceptT</a> monad
tryRead :: (Monad m, Read a) => e -> String -> ExceptT e m a

-- | An assertion that fails in the <a>ExceptT</a> monad
tryAssert :: Monad m => e -> Bool -> ExceptT e m ()

-- | A <tt>fromJust</tt> that fails in the <a>ExceptT</a> monad
tryJust :: Monad m => e -> Maybe a -> ExceptT e m a

-- | A <tt>fromRight</tt> that fails in the <a>ExceptT</a> monad
tryRight :: Monad m => Either e a -> ExceptT e m a

-- | A <a>tail</a> that fails using <a>mzero</a>
tailZ :: MonadPlus m => [a] -> m [a]

-- | An <a>init</a> that fails using <a>mzero</a>
initZ :: MonadPlus m => [a] -> m [a]

-- | A <a>head</a> that fails using <a>mzero</a>
headZ :: MonadPlus m => [a] -> m a

-- | A <a>last</a> that fails using <a>mzero</a>
lastZ :: MonadPlus m => [a] -> m a

-- | A <a>minimum</a> that fails using <a>mzero</a>
minimumZ :: MonadPlus m => Ord a => [a] -> m a

-- | A <a>maximum</a> that fails using <a>mzero</a>
maximumZ :: MonadPlus m => Ord a => [a] -> m a

-- | A <a>foldr1</a> that fails using <a>mzero</a>
foldr1Z :: MonadPlus m => (a -> a -> a) -> [a] -> m a

-- | A <a>foldl1</a> that fails using <a>mzero</a>
foldl1Z :: MonadPlus m => (a -> a -> a) -> [a] -> m a

-- | A <tt>foldl1'</tt> that fails using <a>mzero</a>
foldl1Z' :: MonadPlus m => (a -> a -> a) -> [a] -> m a

-- | A (<a>!!</a>) that fails using <a>mzero</a>
atZ :: MonadPlus m => [a] -> Int -> m a

-- | A <a>read</a> that fails using <a>mzero</a>
readZ :: MonadPlus m => Read a => String -> m a

-- | An assertion that fails using <a>mzero</a>
assertZ :: MonadPlus m => Bool -> m ()

-- | A <tt>fromJust</tt> that fails using <a>mzero</a>
justZ :: MonadPlus m => Maybe a -> m a

-- | A <tt>fromRight</tt> that fails using <a>mzero</a>
rightZ :: MonadPlus m => Either e a -> m a


-- | This module provides <a>throwEither</a> and <a>catchEither</a> for
--   <a>Either</a>. These two functions reside here because
--   <a>throwEither</a> and <a>catchEither</a> correspond to <a>return</a>
--   and (<a>&gt;&gt;=</a>) for the flipped <a>Either</a> monad:
--   <a>EitherR</a>. Additionally, this module defines <a>handleE</a> as
--   the flipped version of <a>catchE</a> for <a>ExceptT</a>.
--   
--   <a>throwEither</a> and <a>catchEither</a> improve upon
--   <tt>MonadError</tt> because:
--   
--   <ul>
--   <li><a>catchEither</a> is more general than <tt>catch</tt> and allows
--   you to change the left value's type</li>
--   <li>Both are Haskell98</li>
--   </ul>
--   
--   More advanced users can use <a>EitherR</a> and <a>ExceptRT</a> to
--   program in an entirely symmetric "success monad" where exceptional
--   results are the norm and successful results terminate the computation.
--   This allows you to chain error-handlers using <tt>do</tt> notation and
--   pass around exceptional values of varying types until you can finally
--   recover from the error:
--   
--   <pre>
--   runExceptRT $ do
--       e2   &lt;- ioExceptionHandler e1
--       bool &lt;- arithmeticExceptionhandler e2
--       when bool $ lift $ putStrLn "DEBUG: Arithmetic handler did something"
--   </pre>
--   
--   If any of the above error handlers <a>succeed</a>, no other handlers
--   are tried.
--   
--   If you choose not to typefully distinguish between the error and
--   sucess monad, then use <a>flipEither</a> and <a>flipET</a>, which swap
--   the type variables without changing the type.
module Data.EitherR

-- | If "<tt>Either e r</tt>" is the error monad, then "<tt>EitherR r
--   e</tt>" is the corresponding success monad, where:
--   
--   <ul>
--   <li><a>return</a> is <a>throwEither</a>.</li>
--   <li>(<a>&gt;&gt;=</a>) is <a>catchEither</a>.</li>
--   <li>Successful results abort the computation</li>
--   </ul>
newtype EitherR r e
EitherR :: Either e r -> EitherR r e
[runEitherR] :: EitherR r e -> Either e r

-- | Complete error handling, returning a result
succeed :: r -> EitherR r e

-- | <a>throwEither</a> in the error monad corresponds to <a>return</a> in
--   the success monad
throwEither :: e -> Either e r

-- | <a>catchEither</a> in the error monad corresponds to
--   (<a>&gt;&gt;=</a>) in the success monad
catchEither :: Either a r -> (a -> Either b r) -> Either b r

-- | <a>catchEither</a> with the arguments flipped
handleEither :: (a -> Either b r) -> Either a r -> Either b r

-- | Map a function over the <a>Left</a> value of an <a>Either</a>
fmapL :: (a -> b) -> Either a r -> Either b r

-- | Flip the type variables of <a>Either</a>
flipEither :: Either a b -> Either b a

-- | <a>EitherR</a> converted into a monad transformer
newtype ExceptRT r m e
ExceptRT :: ExceptT e m r -> ExceptRT r m e
[runExceptRT] :: ExceptRT r m e -> ExceptT e m r

-- | Complete error handling, returning a result
succeedT :: Monad m => r -> ExceptRT r m e

-- | <a>catchE</a> with the arguments flipped
handleE :: Monad m => (a -> ExceptT b m r) -> ExceptT a m r -> ExceptT b m r

-- | Map a function over the <a>Left</a> value of an <a>ExceptT</a>
fmapLT :: Functor m => (a -> b) -> ExceptT a m r -> ExceptT b m r

-- | Flip the type variables of an <a>ExceptT</a>
flipET :: Monad m => ExceptT a m b -> ExceptT b m a
instance GHC.Base.Monad m => GHC.Base.Functor (Data.EitherR.ExceptRT r m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.EitherR.ExceptRT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.EitherR.ExceptRT r m)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Alternative (Data.EitherR.ExceptRT r m)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.MonadPlus (Data.EitherR.ExceptRT r m)
instance Control.Monad.Trans.Class.MonadTrans (Data.EitherR.ExceptRT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.EitherR.ExceptRT r m)
instance GHC.Base.Functor (Data.EitherR.EitherR r)
instance GHC.Base.Applicative (Data.EitherR.EitherR r)
instance GHC.Base.Monad (Data.EitherR.EitherR r)
instance GHC.Base.Monoid r => GHC.Base.Alternative (Data.EitherR.EitherR r)
instance GHC.Base.Monoid r => GHC.Base.MonadPlus (Data.EitherR.EitherR r)


-- | Use this module if you like to write simple scripts with
--   <a>Text</a>-based errors, but you prefer to use <a>ExceptT</a> to
--   handle errors rather than <tt>Control.Exception</tt>.
--   
--   <pre>
--   import Control.Error
--   
--   main = runScript $ do
--       str &lt;- scriptIO getLine
--       n   &lt;- tryRead "Read failed" str
--       scriptIO $ print (n + 1)
--   </pre>
module Control.Error.Script

-- | An <a>IO</a> action that can fail with a <a>Text</a> error message
type Script = ExceptT Text IO

-- | Runs the <a>Script</a> monad
--   
--   Prints the first error to <a>stderr</a> and exits with
--   <a>exitFailure</a>
runScript :: Script a -> IO a

-- | <a>scriptIO</a> resembles <a>lift</a>, except it catches all
--   exceptions and converts them to <a>Text</a>
--   
--   Note that <a>scriptIO</a> is compatible with the <a>Script</a> monad.
scriptIO :: MonadIO m => IO a -> ExceptT Text m a


-- | Import this module in your code to access the entire library's
--   functionality:
--   
--   <pre>
--   import Control.Error
--   </pre>
--   
--   This module exports the entire library as well as useful exports from
--   other standard error-handling libraries:
--   
--   <ul>
--   <li><a>Control.Error.Safe</a>: Generalizes the <tt>safe</tt> library,
--   including <a>Either</a>, <tt>EitherT</tt>, and <tt>MonadPlus</tt>
--   variations on total functions</li>
--   <li><a>Control.Error.Script</a>: Support for simple scripts that catch
--   all errors and transform them to <tt>Text</tt></li>
--   <li><a>Control.Error.Util</a>: Utility functions and conversions
--   between common error-handling types</li>
--   <li><tt>Control.Monad.Trans.Except</tt>: The <a>ExceptT</a> monad
--   transformer</li>
--   <li><tt>Control.Monad.Trans.Maybe</tt>: The <a>MaybeT</a> monad
--   transformer</li>
--   <li><tt>Data.Either</tt>: <a>Either</a> utility functions</li>
--   <li><a>Data.EitherR</a>: throw and catch functions, and their
--   corresponding "success" monads</li>
--   <li><tt>Data.Maybe</tt>: <a>Maybe</a> utility functions</li>
--   <li><tt>Safe</tt>: Total versions of partial Prelude functions</li>
--   </ul>
--   
--   This module does not re-export partial functions from other libraries.
module Control.Error

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype () => MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT (m :: Type -> Type) a
[runMaybeT] :: MaybeT (m :: Type -> Type) a -> m (Maybe a)

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (Maybe a) -> Catch e (MaybeT m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Maybe a) -> Listen w (MaybeT m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Maybe a) -> Pass w (MaybeT m) a

-- | Transform the computation inside a <tt>MaybeT</tt>.
--   
--   <ul>
--   <li><pre><a>runMaybeT</a> (<a>mapMaybeT</a> f m) = f (<a>runMaybeT</a>
--   m)</pre></li>
--   </ul>
mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
foldr1May :: (a -> a -> a) -> [a] -> Maybe a
minimumMay :: Ord a => [a] -> Maybe a
maximumMay :: Ord a => [a] -> Maybe a
findJustDef :: a -> (a -> Bool) -> [a] -> a

-- | New users are recommended to use <a>minimumBound</a> or
--   <a>maximumBound</a> instead.
minimumDef :: Ord a => a -> [a] -> a

-- | New users are recommended to use <a>minimumBound</a> or
--   <a>maximumBound</a> instead.
maximumDef :: Ord a => a -> [a] -> a
foldr1Def :: a -> (a -> a -> a) -> [a] -> a

-- | <pre>
--   tailMay [] = Nothing
--   tailMay [1,3,4] = Just [3,4]
--   </pre>
tailMay :: [a] -> Maybe [a]

-- | <pre>
--   tailDef [12] [] = [12]
--   tailDef [12] [1,3,4] = [3,4]
--   </pre>
tailDef :: [a] -> [a] -> [a]

-- | <pre>
--   tailSafe [] = []
--   tailSafe [1,3,4] = [3,4]
--   </pre>
tailSafe :: [a] -> [a]
initMay :: [a] -> Maybe [a]
initDef :: [a] -> [a] -> [a]
initSafe :: [a] -> [a]
headMay :: [a] -> Maybe a
lastMay :: [a] -> Maybe a
headDef :: a -> [a] -> a
lastDef :: a -> [a] -> a
foldl1May' :: (a -> a -> a) -> [a] -> Maybe a

-- | An alternative name for <a>fromMaybe</a>, to fit the naming scheme of
--   this package. Generally using <a>fromMaybe</a> directly would be
--   considered better style.
fromJustDef :: a -> Maybe a -> a
atMay :: [a] -> Int -> Maybe a
atDef :: a -> [a] -> Int -> a
readMay :: Read a => String -> Maybe a
readDef :: Read a => a -> String -> a
lookupJustDef :: Eq a => b -> a -> [(a, b)] -> b
foldl1Def' :: a -> (a -> a -> a) -> [a] -> a
