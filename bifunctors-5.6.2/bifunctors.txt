-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bifunctors
--   
--   Bifunctors.
@package bifunctors
@version 5.6.2


module Data.Biapplicative
class Bifunctor p => Biapplicative p
bipure :: Biapplicative p => a -> b -> p a b
(<<*>>) :: Biapplicative p => p (a -> b) (c -> d) -> p a c -> p b d

-- | Lift binary functions
biliftA2 :: Biapplicative p => (a -> b -> c) -> (d -> e -> f) -> p a d -> p b e -> p c f

-- | <pre>
--   a <a>*&gt;&gt;</a> b ≡ <a>bimap</a> (<a>const</a> <a>id</a>) (<a>const</a> <a>id</a>) <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(*>>) :: Biapplicative p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;&lt;*</a> b ≡ <a>bimap</a> <a>const</a> <a>const</a> <a>&lt;&lt;$&gt;&gt;</a> a <a>&lt;&lt;*&gt;&gt;</a> b
--   </pre>
(<<*) :: Biapplicative p => p a b -> p c d -> p a b
infixl 4 <<*>>
infixl 4 *>>
infixl 4 <<*
(<<$>>) :: (a -> b) -> a -> b
infixl 4 <<$>>
(<<**>>) :: Biapplicative p => p a c -> p (a -> b) (c -> d) -> p b d
infixl 4 <<**>>

-- | Lift ternary functions
biliftA3 :: Biapplicative w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h

-- | Traverse a <a>Traversable</a> container in a <a>Biapplicative</a>.
--   
--   <a>traverseBia</a> satisfies the following properties:
--   
--   <ul>
--   <li><i><i>Pairing</i></i> <pre><a>traverseBia</a> (,) t = (t,
--   t)</pre></li>
--   <li><i><i>Composition</i></i> <pre><a>traverseBia</a> (<a>Biff</a> .
--   <a>bimap</a> g h . f) = <a>Biff</a> . <a>bimap</a> (<a>traverse</a> g)
--   (<a>traverse</a> h) . <a>traverseBia</a>
--   f</pre><pre><a>traverseBia</a> (<a>Tannen</a> . <a>fmap</a> f . g) =
--   <a>Tannen</a> . <a>fmap</a> (<a>traverseBia</a> f) . <a>traverse</a>
--   g</pre></li>
--   <li><i><i>Naturality</i></i> <pre> t . <a>traverseBia</a> f =
--   <a>traverseBia</a> (t . f)</pre>for every biapplicative transformation
--   <tt>t</tt>.A <i>biapplicative transformation</i> from a
--   <a>Biapplicative</a> <tt>P</tt> to a <a>Biapplicative</a> <tt>Q</tt>
--   is a function<pre>t :: P a b -&gt; Q a b</pre>preserving the
--   <a>Biapplicative</a> operations. That is,<ul><li><pre>t (<a>bipure</a>
--   x y) = <a>bipure</a> x y</pre></li><li><pre>t (x
--   <a>&lt;&lt;*&gt;&gt;</a> y) = t x <a>&lt;&lt;*&gt;&gt;</a> t
--   y</pre></li></ul></li>
--   </ul>
--   
--   <h3>Performance note</h3>
--   
--   <a>traverseBia</a> is fairly efficient, and uses compiler rewrite
--   rules to be even more efficient for a few important types like
--   <tt>[]</tt>. However, if performance is critical, you might consider
--   writing a container-specific implementation.
traverseBia :: (Traversable t, Biapplicative p) => (a -> p b c) -> t a -> p (t b) (t c)

-- | Perform all the <a>Biapplicative</a> actions in a <a>Traversable</a>
--   container and produce a container with all the results.
--   
--   <pre>
--   sequenceBia = <a>traverseBia</a> id
--   </pre>
sequenceBia :: (Traversable t, Biapplicative p) => t (p b c) -> p (t b) (t c)

-- | A version of <a>traverseBia</a> that doesn't care how the traversal is
--   done.
--   
--   <pre>
--   <a>traverseBia</a> = traverseBiaWith traverse
--   </pre>
traverseBiaWith :: forall p a b c s t. Biapplicative p => (forall f x. Applicative f => (a -> f x) -> s -> f (t x)) -> (a -> p b c) -> s -> p (t b) (t c)
instance GHC.Base.Functor (Data.Biapplicative.Mag a b)
instance GHC.Base.Applicative (Data.Biapplicative.Mag a b)
instance Data.Biapplicative.Biapplicative (,)
instance Data.Biapplicative.Biapplicative Data.Semigroup.Arg
instance GHC.Base.Monoid x => Data.Biapplicative.Biapplicative ((,,) x)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y) => Data.Biapplicative.Biapplicative ((,,,) x y)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z) => Data.Biapplicative.Biapplicative ((,,,,) x y z)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w) => Data.Biapplicative.Biapplicative ((,,,,,) x y z w)
instance (GHC.Base.Monoid x, GHC.Base.Monoid y, GHC.Base.Monoid z, GHC.Base.Monoid w, GHC.Base.Monoid v) => Data.Biapplicative.Biapplicative ((,,,,,,) x y z w v)
instance Data.Biapplicative.Biapplicative Data.Tagged.Tagged
instance Data.Biapplicative.Biapplicative Data.Functor.Const.Const


module Data.Bifunctor.Biap

-- | Pointwise lifting of a class over two arguments, using
--   <a>Biapplicative</a>.
--   
--   Classes that can be lifted include <a>Monoid</a>, <a>Num</a> and
--   <a>Bounded</a>. Each method of those classes can be defined as lifting
--   themselves over each argument of <a>Biapplicative</a>.
--   
--   <pre>
--   mempty        = bipure mempty          mempty
--   minBound      = bipure minBound        minBound
--   maxBound      = bipure maxBound        maxBound
--   fromInteger n = bipure (fromInteger n) (fromInteger n)
--   
--   negate = bimap negate negate
--   
--   (+)  = biliftA2 (+)  (+)
--   (&lt;&gt;) = biliftA2 (&lt;&gt;) (&lt;&gt;)
--   </pre>
--   
--   <a>Biap</a> is to <a>Biapplicative</a> as <a>Ap</a> is to
--   <a>Applicative</a>.
--   
--   <a>Biap</a> can be used with <tt>DerivingVia</tt> to derive a numeric
--   instance for pairs:
--   
--   <pre>
--   newtype Numpair a = Np (a, a)
--    deriving (S.Semigroup, Monoid, Num, Bounded)
--    via Biap (,) a a
--   </pre>
newtype Biap bi a b
Biap :: bi a b -> Biap bi a b
[getBiap] :: Biap bi a b -> bi a b
instance Data.Functor.Classes.Ord2 bi => Data.Functor.Classes.Ord2 (Data.Bifunctor.Biap.Biap bi)
instance Data.Functor.Classes.Eq2 bi => Data.Functor.Classes.Eq2 (Data.Bifunctor.Biap.Biap bi)
instance Data.Bifoldable.Bifoldable bi => Data.Bifoldable.Bifoldable (Data.Bifunctor.Biap.Biap bi)
instance Data.Biapplicative.Biapplicative bi => Data.Biapplicative.Biapplicative (Data.Bifunctor.Biap.Biap bi)
instance Data.Bifunctor.Bifunctor bi => Data.Bifunctor.Bifunctor (Data.Bifunctor.Biap.Biap bi)
instance Data.Functor.Classes.Ord1 (bi a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Biap.Biap bi a)
instance Data.Functor.Classes.Eq1 (bi a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Base.MonadPlus (bi a) => GHC.Base.MonadPlus (Data.Bifunctor.Biap.Biap bi a)
instance Control.Monad.Fail.MonadFail (bi a) => Control.Monad.Fail.MonadFail (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Base.Monad (bi a) => GHC.Base.Monad (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Generics.Generic1 (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Generics.Generic (Data.Bifunctor.Biap.Biap bi a b)
instance GHC.Base.Applicative (bi a) => GHC.Base.Applicative (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Base.Alternative (bi a) => GHC.Base.Alternative (Data.Bifunctor.Biap.Biap bi a)
instance Data.Traversable.Traversable (bi a) => Data.Traversable.Traversable (Data.Bifunctor.Biap.Biap bi a)
instance Data.Foldable.Foldable (bi a) => Data.Foldable.Foldable (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Base.Functor (bi a) => GHC.Base.Functor (Data.Bifunctor.Biap.Biap bi a)
instance GHC.Enum.Enum (bi a b) => GHC.Enum.Enum (Data.Bifunctor.Biap.Biap bi a b)
instance GHC.Read.Read (bi a b) => GHC.Read.Read (Data.Bifunctor.Biap.Biap bi a b)
instance GHC.Show.Show (bi a b) => GHC.Show.Show (Data.Bifunctor.Biap.Biap bi a b)
instance GHC.Classes.Ord (bi a b) => GHC.Classes.Ord (Data.Bifunctor.Biap.Biap bi a b)
instance GHC.Classes.Eq (bi a b) => GHC.Classes.Eq (Data.Bifunctor.Biap.Biap bi a b)
instance Data.Bitraversable.Bitraversable bi => Data.Bitraversable.Bitraversable (Data.Bifunctor.Biap.Biap bi)
instance (Data.Biapplicative.Biapplicative bi, GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (Data.Bifunctor.Biap.Biap bi a b)
instance (Data.Biapplicative.Biapplicative bi, GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (Data.Bifunctor.Biap.Biap bi a b)
instance (Data.Biapplicative.Biapplicative bi, GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (Data.Bifunctor.Biap.Biap bi a b)
instance (Data.Biapplicative.Biapplicative bi, GHC.Num.Num a, GHC.Num.Num b) => GHC.Num.Num (Data.Bifunctor.Biap.Biap bi a b)


module Data.Bifunctor.Biff

-- | Compose two <a>Functor</a>s on the inside of a <a>Bifunctor</a>.
newtype Biff p f g a b
Biff :: p (f a) (g b) -> Biff p f g a b
[runBiff] :: Biff p f g a b -> p (f a) (g b)
instance forall k1 k2 (p :: k1 -> k2 -> *) k3 (f :: k3 -> k1) k4 (g :: k4 -> k2) (a :: k3) (b :: k4). GHC.Generics.Generic (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) k3 (f :: k3 -> k1) k4 (g :: k4 -> k2) (a :: k3) (b :: k4). GHC.Read.Read (p (f a) (g b)) => GHC.Read.Read (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) k3 (f :: k3 -> k1) k4 (g :: k4 -> k2) (a :: k3) (b :: k4). GHC.Show.Show (p (f a) (g b)) => GHC.Show.Show (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) k3 (f :: k3 -> k1) k4 (g :: k4 -> k2) (a :: k3) (b :: k4). GHC.Classes.Ord (p (f a) (g b)) => GHC.Classes.Ord (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) k3 (f :: k3 -> k1) k4 (g :: k4 -> k2) (a :: k3) (b :: k4). GHC.Classes.Eq (p (f a) (g b)) => GHC.Classes.Eq (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k1 k2 k3 (p :: k1 -> * -> *) (f :: k2 -> k1) (a :: k2) (g :: k3 -> *). GHC.Base.Functor (p (f a)) => GHC.Generics.Generic1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Functor.Classes.Eq2 p, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Functor.Classes.Eq2 p, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq2 (Data.Bifunctor.Biff.Biff p f g)
instance (Data.Functor.Classes.Ord2 p, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Functor.Classes.Ord2 p, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord2 (Data.Bifunctor.Biff.Biff p f g)
instance (Data.Functor.Classes.Read2 p, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Functor.Classes.Read2 p, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read2 (Data.Bifunctor.Biff.Biff p f g)
instance (Data.Functor.Classes.Show2 p, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Functor.Classes.Show2 p, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show2 (Data.Bifunctor.Biff.Biff p f g)
instance (Data.Bifunctor.Bifunctor p, GHC.Base.Functor f, GHC.Base.Functor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bifunctor.Bifunctor p, GHC.Base.Functor g) => GHC.Base.Functor (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Biapplicative.Biapplicative p, GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bifoldable.Bifoldable p, Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Biff.Biff p f g)
instance (Data.Bifoldable1.Bifoldable1 p, Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Biff.Biff p f g)
instance forall k (p :: * -> * -> *) (g :: * -> *) (f :: k -> *) (a :: k). (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Bifunctor.Biff.Biff p f g a)
instance (Data.Bitraversable.Bitraversable p, Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Biff.Biff p f g)
instance (f GHC.Types.~ g, GHC.Base.Functor f, Data.Bifunctor.Swap.Swap p) => Data.Bifunctor.Swap.Swap (Data.Bifunctor.Biff.Biff p f g)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Clown

-- | Make a <a>Functor</a> over the first argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Clown f a b
Clown :: f a -> Clown f a b
[runClown] :: Clown f a b -> f a
instance forall k1 k2 (f :: k2 -> *) (a :: k2). GHC.Generics.Generic1 (Data.Bifunctor.Clown.Clown f a)
instance forall k1 (f :: k1 -> *) (a :: k1) k2 (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Clown.Clown f a b)
instance forall k1 (f :: k1 -> *) (a :: k1) k2 (b :: k2). GHC.Read.Read (f a) => GHC.Read.Read (Data.Bifunctor.Clown.Clown f a b)
instance forall k1 (f :: k1 -> *) (a :: k1) k2 (b :: k2). GHC.Show.Show (f a) => GHC.Show.Show (Data.Bifunctor.Clown.Clown f a b)
instance forall k1 (f :: k1 -> *) (a :: k1) k2 (b :: k2). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Bifunctor.Clown.Clown f a b)
instance forall k1 (f :: k1 -> *) (a :: k1) k2 (b :: k2). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Bifunctor.Clown.Clown f a b)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Clown.Clown f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq2 (Data.Bifunctor.Clown.Clown f)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Clown.Clown f a)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord2 (Data.Bifunctor.Clown.Clown f)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Clown.Clown f a)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read2 (Data.Bifunctor.Clown.Clown f)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Clown.Clown f a)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show2 (Data.Bifunctor.Clown.Clown f)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). GHC.Base.Functor (Data.Bifunctor.Clown.Clown f a)
instance GHC.Base.Applicative f => Data.Biapplicative.Biapplicative (Data.Bifunctor.Clown.Clown f)
instance Data.Foldable.Foldable f => Data.Bifoldable.Bifoldable (Data.Bifunctor.Clown.Clown f)
instance Data.Foldable1.Foldable1 f => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). Data.Foldable.Foldable (Data.Bifunctor.Clown.Clown f a)
instance Data.Traversable.Traversable f => Data.Bitraversable.Bitraversable (Data.Bifunctor.Clown.Clown f)
instance forall k (f :: k -> *) (a :: k). Data.Traversable.Traversable (Data.Bifunctor.Clown.Clown f a)


module Data.Bifunctor.Fix

-- | Greatest fixpoint of a <a>Bifunctor</a> (a <a>Functor</a> over the
--   first argument with zipping).
newtype Fix p a
In :: p (Fix p a) a -> Fix p a
[out] :: Fix p a -> p (Fix p a) a
instance forall k (p :: * -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Classes.Eq (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Eq (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Classes.Ord (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Classes.Ord (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Show.Show (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Show.Show (Data.Bifunctor.Fix.Fix p a)
instance forall k (p :: * -> k -> *) (a :: k). GHC.Read.Read (p (Data.Bifunctor.Fix.Fix p a) a) => GHC.Read.Read (Data.Bifunctor.Fix.Fix p a)
instance Data.Functor.Classes.Eq2 p => Data.Functor.Classes.Eq1 (Data.Bifunctor.Fix.Fix p)
instance Data.Functor.Classes.Ord2 p => Data.Functor.Classes.Ord1 (Data.Bifunctor.Fix.Fix p)
instance Data.Functor.Classes.Read2 p => Data.Functor.Classes.Read1 (Data.Bifunctor.Fix.Fix p)
instance Data.Functor.Classes.Show2 p => Data.Functor.Classes.Show1 (Data.Bifunctor.Fix.Fix p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Fix.Fix p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Fix.Fix p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Fix.Fix p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Fix.Fix p)

module Data.Bifunctor.Functor

-- | Using parametricity as an approximation of a natural transformation in
--   two arguments.
type (:->) p q = forall a b. p a b -> q a b
infixr 0 :->
class BifunctorFunctor t
bifmap :: BifunctorFunctor t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorMonad t
bireturn :: BifunctorMonad t => p :-> t p
bibind :: BifunctorMonad t => (p :-> t q) -> t p :-> t q
bijoin :: BifunctorMonad t => t (t p) :-> t p
biliftM :: BifunctorMonad t => (p :-> q) -> t p :-> t q
class BifunctorFunctor t => BifunctorComonad t
biextract :: BifunctorComonad t => t p :-> p
biextend :: BifunctorComonad t => (t p :-> q) -> t p :-> t q
biduplicate :: BifunctorComonad t => t p :-> t (t p)
biliftW :: BifunctorComonad t => (p :-> q) -> t p :-> t q


module Data.Bifunctor.Flip

-- | Make a <a>Bifunctor</a> flipping the arguments of a <a>Bifunctor</a>.
newtype Flip p a b
Flip :: p b a -> Flip p a b
[runFlip] :: Flip p a b -> p b a
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Flip.Flip p a b)
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k1) (b :: k2). GHC.Read.Read (p b a) => GHC.Read.Read (Data.Bifunctor.Flip.Flip p a b)
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k1) (b :: k2). GHC.Show.Show (p b a) => GHC.Show.Show (Data.Bifunctor.Flip.Flip p a b)
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k1) (b :: k2). GHC.Classes.Ord (p b a) => GHC.Classes.Ord (Data.Bifunctor.Flip.Flip p a b)
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k1) (b :: k2). GHC.Classes.Eq (p b a) => GHC.Classes.Eq (Data.Bifunctor.Flip.Flip p a b)
instance (Data.Functor.Classes.Eq2 p, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Flip.Flip p a)
instance Data.Functor.Classes.Eq2 p => Data.Functor.Classes.Eq2 (Data.Bifunctor.Flip.Flip p)
instance (Data.Functor.Classes.Ord2 p, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Flip.Flip p a)
instance Data.Functor.Classes.Ord2 p => Data.Functor.Classes.Ord2 (Data.Bifunctor.Flip.Flip p)
instance (Data.Functor.Classes.Read2 p, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Flip.Flip p a)
instance Data.Functor.Classes.Read2 p => Data.Functor.Classes.Read2 (Data.Bifunctor.Flip.Flip p)
instance (Data.Functor.Classes.Show2 p, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Flip.Flip p a)
instance Data.Functor.Classes.Show2 p => Data.Functor.Classes.Show2 (Data.Bifunctor.Flip.Flip p)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Flip.Flip p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Flip.Flip p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable1.Bifoldable1 p => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Flip.Flip p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Flip.Flip p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Flip.Flip p a)
instance Data.Bifunctor.Functor.BifunctorFunctor Data.Bifunctor.Flip.Flip
instance Data.Bifunctor.Assoc.Assoc p => Data.Bifunctor.Assoc.Assoc (Data.Bifunctor.Flip.Flip p)
instance Data.Bifunctor.Swap.Swap p => Data.Bifunctor.Swap.Swap (Data.Bifunctor.Flip.Flip p)


module Data.Bifunctor.Join

-- | Make a <a>Functor</a> over both arguments of a <a>Bifunctor</a>.
newtype Join p a
Join :: p a a -> Join p a
[runJoin] :: Join p a -> p a a
instance forall k (p :: k -> k -> *) (a :: k). GHC.Generics.Generic (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Classes.Eq (p a a) => GHC.Classes.Eq (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Classes.Ord (p a a) => GHC.Classes.Ord (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Show.Show (p a a) => GHC.Show.Show (Data.Bifunctor.Join.Join p a)
instance forall k (p :: k -> k -> *) (a :: k). GHC.Read.Read (p a a) => GHC.Read.Read (Data.Bifunctor.Join.Join p a)
instance Data.Functor.Classes.Eq2 p => Data.Functor.Classes.Eq1 (Data.Bifunctor.Join.Join p)
instance Data.Functor.Classes.Ord2 p => Data.Functor.Classes.Ord1 (Data.Bifunctor.Join.Join p)
instance Data.Functor.Classes.Read2 p => Data.Functor.Classes.Read1 (Data.Bifunctor.Join.Join p)
instance Data.Functor.Classes.Show2 p => Data.Functor.Classes.Show1 (Data.Bifunctor.Join.Join p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Join.Join p)
instance Data.Biapplicative.Biapplicative p => GHC.Base.Applicative (Data.Bifunctor.Join.Join p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Join.Join p)
instance Data.Bifoldable1.Bifoldable1 p => Data.Foldable1.Foldable1 (Data.Bifunctor.Join.Join p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Join.Join p)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Joker

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
--   
--   Mnemonic: C<b>l</b>owns to the <b>l</b>eft (parameter of the
--   Bifunctor), joke<b>r</b>s to the <b>r</b>ight.
newtype Joker g a b
Joker :: g b -> Joker g a b
[runJoker] :: Joker g a b -> g b
instance forall k1 (g :: k1 -> *) k2 (a :: k2). GHC.Generics.Generic1 (Data.Bifunctor.Joker.Joker g a)
instance forall k1 (g :: k1 -> *) k2 (a :: k2) (b :: k1). GHC.Generics.Generic (Data.Bifunctor.Joker.Joker g a b)
instance forall k1 (g :: k1 -> *) k2 (a :: k2) (b :: k1). GHC.Read.Read (g b) => GHC.Read.Read (Data.Bifunctor.Joker.Joker g a b)
instance forall k1 (g :: k1 -> *) k2 (a :: k2) (b :: k1). GHC.Show.Show (g b) => GHC.Show.Show (Data.Bifunctor.Joker.Joker g a b)
instance forall k1 (g :: k1 -> *) k2 (a :: k2) (b :: k1). GHC.Classes.Ord (g b) => GHC.Classes.Ord (Data.Bifunctor.Joker.Joker g a b)
instance forall k1 (g :: k1 -> *) k2 (a :: k2) (b :: k1). GHC.Classes.Eq (g b) => GHC.Classes.Eq (Data.Bifunctor.Joker.Joker g a b)
instance forall k (g :: * -> *) (a :: k). Data.Functor.Classes.Eq1 g => Data.Functor.Classes.Eq1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Functor.Classes.Eq1 g => Data.Functor.Classes.Eq2 (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Functor.Classes.Ord1 g => Data.Functor.Classes.Ord1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Functor.Classes.Ord1 g => Data.Functor.Classes.Ord2 (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Functor.Classes.Read1 g => Data.Functor.Classes.Read1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Functor.Classes.Read1 g => Data.Functor.Classes.Read2 (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Functor.Classes.Show1 g => Data.Functor.Classes.Show1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Functor.Classes.Show1 g => Data.Functor.Classes.Show2 (Data.Bifunctor.Joker.Joker g)
instance GHC.Base.Functor g => Data.Bifunctor.Bifunctor (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). GHC.Base.Functor g => GHC.Base.Functor (Data.Bifunctor.Joker.Joker g a)
instance GHC.Base.Applicative g => Data.Biapplicative.Biapplicative (Data.Bifunctor.Joker.Joker g)
instance Data.Foldable.Foldable g => Data.Bifoldable.Bifoldable (Data.Bifunctor.Joker.Joker g)
instance Data.Foldable1.Foldable1 g => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Foldable.Foldable g => Data.Foldable.Foldable (Data.Bifunctor.Joker.Joker g a)
instance forall k (g :: * -> *) (a :: k). Data.Foldable1.Foldable1 g => Data.Foldable1.Foldable1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Traversable.Traversable g => Data.Bitraversable.Bitraversable (Data.Bifunctor.Joker.Joker g)
instance forall k (g :: * -> *) (a :: k). Data.Traversable.Traversable g => Data.Traversable.Traversable (Data.Bifunctor.Joker.Joker g a)


-- | The product of two bifunctors.
module Data.Bifunctor.Product

-- | Form the product of two bifunctors
data Product f g a b
Pair :: f a b -> g a b -> Product f g a b
instance forall k1 k2 (f :: k2 -> k1 -> *) (g :: k2 -> k1 -> *) (a :: k2). GHC.Generics.Generic1 (Data.Bifunctor.Product.Product f g a)
instance forall k1 k2 (f :: k1 -> k2 -> *) (g :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Product.Product f g a b)
instance forall k1 k2 (f :: k1 -> k2 -> *) (g :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Read.Read (f a b), GHC.Read.Read (g a b)) => GHC.Read.Read (Data.Bifunctor.Product.Product f g a b)
instance forall k1 k2 (f :: k1 -> k2 -> *) (g :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Show.Show (f a b), GHC.Show.Show (g a b)) => GHC.Show.Show (Data.Bifunctor.Product.Product f g a b)
instance forall k1 k2 (f :: k1 -> k2 -> *) (g :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Classes.Ord (f a b), GHC.Classes.Ord (g a b)) => GHC.Classes.Ord (Data.Bifunctor.Product.Product f g a b)
instance forall k1 k2 (f :: k1 -> k2 -> *) (g :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Classes.Eq (f a b), GHC.Classes.Eq (g a b)) => GHC.Classes.Eq (Data.Bifunctor.Product.Product f g a b)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (GHC.Base.Functor (f a), GHC.Base.Functor (g a)) => GHC.Base.Functor (Data.Bifunctor.Product.Product f g a)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (Data.Foldable.Foldable (f a), Data.Foldable.Foldable (g a)) => Data.Foldable.Foldable (Data.Bifunctor.Product.Product f g a)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (Data.Traversable.Traversable (f a), Data.Traversable.Traversable (g a)) => Data.Traversable.Traversable (Data.Bifunctor.Product.Product f g a)
instance (Data.Functor.Classes.Eq2 f, Data.Functor.Classes.Eq2 g, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Product.Product f g a)
instance (Data.Functor.Classes.Eq2 f, Data.Functor.Classes.Eq2 g) => Data.Functor.Classes.Eq2 (Data.Bifunctor.Product.Product f g)
instance (Data.Functor.Classes.Ord2 f, Data.Functor.Classes.Ord2 g, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Product.Product f g a)
instance (Data.Functor.Classes.Ord2 f, Data.Functor.Classes.Ord2 g) => Data.Functor.Classes.Ord2 (Data.Bifunctor.Product.Product f g)
instance (Data.Functor.Classes.Read2 f, Data.Functor.Classes.Read2 g, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Product.Product f g a)
instance (Data.Functor.Classes.Read2 f, Data.Functor.Classes.Read2 g) => Data.Functor.Classes.Read2 (Data.Bifunctor.Product.Product f g)
instance (Data.Functor.Classes.Show2 f, Data.Functor.Classes.Show2 g, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Product.Product f g a)
instance (Data.Functor.Classes.Show2 f, Data.Functor.Classes.Show2 g) => Data.Functor.Classes.Show2 (Data.Bifunctor.Product.Product f g)
instance (Data.Bifunctor.Bifunctor f, Data.Bifunctor.Bifunctor g) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Product.Product f g)
instance (Data.Biapplicative.Biapplicative f, Data.Biapplicative.Biapplicative g) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Product.Product f g)
instance (Data.Bifoldable.Bifoldable f, Data.Bifoldable.Bifoldable g) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Product.Product f g)
instance (Data.Bifoldable1.Bifoldable1 f, Data.Bifoldable1.Bifoldable1 g) => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Product.Product f g)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Product.Product f g)
instance forall k2 k3 (p :: k2 -> k3 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Product.Product p)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Product.Product p)
instance forall k (p :: k -> k -> *) (q :: k -> k -> *). (Control.Category.Category p, Control.Category.Category q) => Control.Category.Category (Data.Bifunctor.Product.Product p q)
instance (Control.Arrow.Arrow p, Control.Arrow.Arrow q) => Control.Arrow.Arrow (Data.Bifunctor.Product.Product p q)
instance (Control.Arrow.ArrowChoice p, Control.Arrow.ArrowChoice q) => Control.Arrow.ArrowChoice (Data.Bifunctor.Product.Product p q)
instance (Control.Arrow.ArrowLoop p, Control.Arrow.ArrowLoop q) => Control.Arrow.ArrowLoop (Data.Bifunctor.Product.Product p q)
instance (Control.Arrow.ArrowZero p, Control.Arrow.ArrowZero q) => Control.Arrow.ArrowZero (Data.Bifunctor.Product.Product p q)
instance (Control.Arrow.ArrowPlus p, Control.Arrow.ArrowPlus q) => Control.Arrow.ArrowPlus (Data.Bifunctor.Product.Product p q)
instance (Data.Bifunctor.Swap.Swap p, Data.Bifunctor.Swap.Swap q) => Data.Bifunctor.Swap.Swap (Data.Bifunctor.Product.Product p q)

module Data.Bifunctor.Sum
data Sum p q a b
L2 :: p a b -> Sum p q a b
R2 :: q a b -> Sum p q a b
instance forall k1 k2 (p :: k2 -> k1 -> *) (q :: k2 -> k1 -> *) (a :: k2). GHC.Generics.Generic1 (Data.Bifunctor.Sum.Sum p q a)
instance forall k1 k2 (p :: k1 -> k2 -> *) (q :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Sum.Sum p q a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (q :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Read.Read (p a b), GHC.Read.Read (q a b)) => GHC.Read.Read (Data.Bifunctor.Sum.Sum p q a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (q :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Show.Show (p a b), GHC.Show.Show (q a b)) => GHC.Show.Show (Data.Bifunctor.Sum.Sum p q a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (q :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Classes.Ord (p a b), GHC.Classes.Ord (q a b)) => GHC.Classes.Ord (Data.Bifunctor.Sum.Sum p q a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (q :: k1 -> k2 -> *) (a :: k1) (b :: k2). (GHC.Classes.Eq (p a b), GHC.Classes.Eq (q a b)) => GHC.Classes.Eq (Data.Bifunctor.Sum.Sum p q a b)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (GHC.Base.Functor (f a), GHC.Base.Functor (g a)) => GHC.Base.Functor (Data.Bifunctor.Sum.Sum f g a)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (Data.Foldable.Foldable (f a), Data.Foldable.Foldable (g a)) => Data.Foldable.Foldable (Data.Bifunctor.Sum.Sum f g a)
instance forall k (f :: k -> * -> *) (a :: k) (g :: k -> * -> *). (Data.Traversable.Traversable (f a), Data.Traversable.Traversable (g a)) => Data.Traversable.Traversable (Data.Bifunctor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq2 f, Data.Functor.Classes.Eq2 g, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq2 f, Data.Functor.Classes.Eq2 g) => Data.Functor.Classes.Eq2 (Data.Bifunctor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord2 f, Data.Functor.Classes.Ord2 g, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Sum.Sum f g a)
instance (Data.Functor.Classes.Ord2 f, Data.Functor.Classes.Ord2 g) => Data.Functor.Classes.Ord2 (Data.Bifunctor.Sum.Sum f g)
instance (Data.Functor.Classes.Read2 f, Data.Functor.Classes.Read2 g, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Sum.Sum f g a)
instance (Data.Functor.Classes.Read2 f, Data.Functor.Classes.Read2 g) => Data.Functor.Classes.Read2 (Data.Bifunctor.Sum.Sum f g)
instance (Data.Functor.Classes.Show2 f, Data.Functor.Classes.Show2 g, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Sum.Sum f g a)
instance (Data.Functor.Classes.Show2 f, Data.Functor.Classes.Show2 g) => Data.Functor.Classes.Show2 (Data.Bifunctor.Sum.Sum f g)
instance (Data.Bifunctor.Bifunctor p, Data.Bifunctor.Bifunctor q) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bifoldable.Bifoldable p, Data.Bifoldable.Bifoldable q) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Sum.Sum p q)
instance (Data.Bitraversable.Bitraversable p, Data.Bitraversable.Bitraversable q) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Sum.Sum p q)
instance forall k2 k3 (p :: k2 -> k3 -> *). Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Sum.Sum p)
instance forall k k1 (p :: k -> k1 -> *). Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Sum.Sum p)
instance (Data.Bifunctor.Swap.Swap p, Data.Bifunctor.Swap.Swap q) => Data.Bifunctor.Swap.Swap (Data.Bifunctor.Sum.Sum p q)


-- | Functions to mechanically derive <a>Bifunctor</a>, <a>Bifoldable</a>,
--   or <a>Bitraversable</a> instances, or to splice their functions
--   directly into source code. You need to enable the
--   <tt>TemplateHaskell</tt> language extension in order to use this
--   module.
module Data.Bifunctor.TH

-- | Generates a <a>Bifunctor</a> instance declaration for the given data
--   type or data family instance.
deriveBifunctor :: Name -> Q [Dec]

-- | Like <a>deriveBifunctor</a>, but takes an <a>Options</a> argument.
deriveBifunctorOptions :: Options -> Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bimap</tt>
--   (without requiring a <a>Bifunctor</a> instance).
makeBimap :: Name -> Q Exp

-- | Like <a>makeBimap</a>, but takes an <a>Options</a> argument.
makeBimapOptions :: Options -> Name -> Q Exp

-- | Generates a <a>Bifoldable</a> instance declaration for the given data
--   type or data family instance.
deriveBifoldable :: Name -> Q [Dec]

-- | Like <a>deriveBifoldable</a>, but takes an <a>Options</a> argument.
deriveBifoldableOptions :: Options -> Name -> Q [Dec]
makeBifold :: Name -> Q Exp

-- | Like <a>makeBifold</a>, but takes an <a>Options</a> argument.
makeBifoldOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldMap</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldMap :: Name -> Q Exp

-- | Like <a>makeBifoldMap</a>, but takes an <a>Options</a> argument.
makeBifoldMapOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldr</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldr :: Name -> Q Exp

-- | Like <a>makeBifoldr</a>, but takes an <a>Options</a> argument.
makeBifoldrOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bifoldl</tt>
--   (without requiring a <a>Bifoldable</a> instance).
makeBifoldl :: Name -> Q Exp

-- | Like <a>makeBifoldl</a>, but takes an <a>Options</a> argument.
makeBifoldlOptions :: Options -> Name -> Q Exp

-- | Generates a <a>Bitraversable</a> instance declaration for the given
--   data type or data family instance.
deriveBitraversable :: Name -> Q [Dec]

-- | Like <a>deriveBitraversable</a>, but takes an <a>Options</a> argument.
deriveBitraversableOptions :: Options -> Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <tt>bitraverse</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBitraverse :: Name -> Q Exp

-- | Like <a>makeBitraverse</a>, but takes an <a>Options</a> argument.
makeBitraverseOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequenceA</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequenceA :: Name -> Q Exp

-- | Like <tt>makeBitraverseA</tt>, but takes an <a>Options</a> argument.
makeBisequenceAOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bimapM</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBimapM :: Name -> Q Exp

-- | Like <a>makeBimapM</a>, but takes an <a>Options</a> argument.
makeBimapMOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <tt>bisequence</tt>
--   (without requiring a <a>Bitraversable</a> instance).
makeBisequence :: Name -> Q Exp

-- | Like <a>makeBisequence</a>, but takes an <a>Options</a> argument.
makeBisequenceOptions :: Options -> Name -> Q Exp

-- | Options that further configure how the functions in
--   <a>Data.Bifunctor.TH</a> should behave.
newtype Options
Options :: Bool -> Options

-- | If <a>True</a>, derived instances for empty data types (i.e., ones
--   with no data constructors) will use the <tt>EmptyCase</tt> language
--   extension. If <a>False</a>, derived instances will simply use
--   <a>seq</a> instead.
[emptyCaseBehavior] :: Options -> Bool

-- | Conservative <a>Options</a> that doesn't attempt to use
--   <tt>EmptyCase</tt> (to prevent users from having to enable that
--   extension at use sites.)
defaultOptions :: Options
instance GHC.Show.Show Data.Bifunctor.TH.Options
instance GHC.Read.Read Data.Bifunctor.TH.Options
instance GHC.Classes.Ord Data.Bifunctor.TH.Options
instance GHC.Classes.Eq Data.Bifunctor.TH.Options
instance GHC.Classes.Eq Data.Bifunctor.TH.BiFun


module Data.Bifunctor.Tannen

-- | Compose a <a>Functor</a> on the outside of a <a>Bifunctor</a>.
newtype Tannen f p a b
Tannen :: f (p a b) -> Tannen f p a b
[runTannen] :: Tannen f p a b -> f (p a b)
instance forall k1 (f :: k1 -> *) k2 k3 (p :: k2 -> k3 -> k1) (a :: k2) (b :: k3). GHC.Generics.Generic (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k1 (f :: k1 -> *) k2 k3 (p :: k2 -> k3 -> k1) (a :: k2) (b :: k3). GHC.Read.Read (f (p a b)) => GHC.Read.Read (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k1 (f :: k1 -> *) k2 k3 (p :: k2 -> k3 -> k1) (a :: k2) (b :: k3). GHC.Show.Show (f (p a b)) => GHC.Show.Show (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k1 (f :: k1 -> *) k2 k3 (p :: k2 -> k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Ord (f (p a b)) => GHC.Classes.Ord (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k1 (f :: k1 -> *) k2 k3 (p :: k2 -> k3 -> k1) (a :: k2) (b :: k3). GHC.Classes.Eq (f (p a b)) => GHC.Classes.Eq (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k1 k2 (f :: * -> *) (p :: k1 -> k2 -> *) (a :: k1). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq2 p, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq2 p) => Data.Functor.Classes.Eq2 (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord2 p, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord2 p) => Data.Functor.Classes.Ord2 (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read2 p, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read2 p) => Data.Functor.Classes.Read2 (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show2 p, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show2 p) => Data.Functor.Classes.Show2 (Data.Bifunctor.Tannen.Tannen f p)
instance GHC.Base.Functor f => Data.Bifunctor.Functor.BifunctorFunctor (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, GHC.Base.Monad f) => Data.Bifunctor.Functor.BifunctorMonad (Data.Bifunctor.Tannen.Tannen f)
instance Control.Comonad.Comonad f => Data.Bifunctor.Functor.BifunctorComonad (Data.Bifunctor.Tannen.Tannen f)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => Data.Bifunctor.Bifunctor (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Functor f, Data.Bifunctor.Bifunctor p) => GHC.Base.Functor (Data.Bifunctor.Tannen.Tannen f p a)
instance (GHC.Base.Applicative f, Data.Biapplicative.Biapplicative p) => Data.Biapplicative.Biapplicative (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Foldable.Foldable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Foldable.Foldable f, Data.Bifoldable.Bifoldable p) => Data.Bifoldable.Bifoldable (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Foldable1.Foldable1 f, Data.Bifoldable1.Bifoldable1 p) => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Tannen.Tannen f p)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Traversable.Traversable (Data.Bifunctor.Tannen.Tannen f p a)
instance (Data.Traversable.Traversable f, Data.Bitraversable.Bitraversable p) => Data.Bitraversable.Bitraversable (Data.Bifunctor.Tannen.Tannen f p)
instance forall k (f :: * -> *) (p :: k -> k -> *). (GHC.Base.Applicative f, Control.Category.Category p) => Control.Category.Category (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.Arrow p) => Control.Arrow.Arrow (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowChoice p) => Control.Arrow.ArrowChoice (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowLoop p) => Control.Arrow.ArrowLoop (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowZero p) => Control.Arrow.ArrowZero (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Applicative f, Control.Arrow.ArrowPlus p) => Control.Arrow.ArrowPlus (Data.Bifunctor.Tannen.Tannen f p)
instance (GHC.Base.Functor f, Data.Bifunctor.Swap.Swap p) => Data.Bifunctor.Swap.Swap (Data.Bifunctor.Tannen.Tannen f p)


module Data.Bifunctor.Wrapped

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype WrappedBifunctor p a b
WrapBifunctor :: p a b -> WrappedBifunctor p a b
[unwrapBifunctor] :: WrappedBifunctor p a b -> p a b
instance forall k1 k2 (p :: k2 -> k1 -> *) (a :: k2). GHC.Generics.Generic1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Generics.Generic (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Read.Read (p a b) => GHC.Read.Read (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Show.Show (p a b) => GHC.Show.Show (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Classes.Ord (p a b) => GHC.Classes.Ord (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Classes.Eq (p a b) => GHC.Classes.Eq (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance (Data.Functor.Classes.Eq2 p, GHC.Classes.Eq a) => Data.Functor.Classes.Eq1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Functor.Classes.Eq2 p => Data.Functor.Classes.Eq2 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance (Data.Functor.Classes.Ord2 p, GHC.Classes.Ord a) => Data.Functor.Classes.Ord1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Functor.Classes.Ord2 p => Data.Functor.Classes.Ord2 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance (Data.Functor.Classes.Read2 p, GHC.Read.Read a) => Data.Functor.Classes.Read1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Functor.Classes.Read2 p => Data.Functor.Classes.Read2 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance (Data.Functor.Classes.Show2 p, GHC.Show.Show a) => Data.Functor.Classes.Show1 (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Functor.Classes.Show2 p => Data.Functor.Classes.Show2 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifunctor.Bifunctor p => Data.Bifunctor.Bifunctor (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifunctor.Bifunctor p => GHC.Base.Functor (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Biapplicative.Biapplicative p => Data.Biapplicative.Biapplicative (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifoldable.Bifoldable p => Data.Foldable.Foldable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bifoldable.Bifoldable p => Data.Bifoldable.Bifoldable (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bifoldable1.Bifoldable1 p => Data.Bifoldable1.Bifoldable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Bitraversable.Bitraversable p => Data.Traversable.Traversable (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Bitraversable.Bitraversable p => Data.Bitraversable.Bitraversable (Data.Bifunctor.Wrapped.WrappedBifunctor p)
