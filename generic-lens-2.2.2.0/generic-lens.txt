-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generically derive traversals, lenses and prisms.
--   
--   This library uses GHC.Generics to derive efficient optics (traversals,
--   lenses and prisms) for algebraic data types in a type-directed way,
--   with a focus on good type inference and error messages when possible.
--   
--   The library exposes a van Laarhoven interface. For an alternative
--   interface, supporting an opaque optic type, see
--   <tt><a>generic-optics</a></tt>.
@package generic-lens
@version 2.2.2.0

module Data.Generics.Internal.VL

-- | Type alias for lens
type Lens' s a = Lens s s a a
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
view :: ((a -> Const a a) -> s -> Const a s) -> s -> a

-- | Getting
(^.) :: s -> ((a -> Const a a) -> s -> Const a s) -> a
infixl 8 ^.
(.~) :: ((a -> Identity b) -> s -> Identity t) -> b -> s -> t
infixr 4 .~
set :: Lens s t a b -> b -> s -> t
over :: ((a -> Identity b) -> s -> Identity t) -> (a -> b) -> s -> t
lens2lensvl :: ALens a b i s t -> Lens s t a b
ravel :: (ALens a b i a b -> ALens a b i s t) -> Lens s t a b
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t
type Iso' s a = forall p f. (Profunctor p, Functor f) => p a (f a) -> p s (f s)
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
fromIso :: Iso s t a b -> Iso b a t s
iso2isovl :: Iso s t a b -> Iso s t a b

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | A type and its generic representation are isomorphic
repIso :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b x)
repIsoN :: (GenericN a, GenericN b) => Iso a b (RepN a x) (RepN b x)
paramIso :: Iso (Param n a) (Param n b) a b

-- | <a>M1</a> is just a wrapper around `f p`
mIso :: Iso (M1 i c f p) (M1 i c g p) (f p) (g p)
kIso :: Iso (K1 r a p) (K1 r b p) a b
recIso :: Iso (Rec r a p) (Rec r b p) a b
prodIso :: Iso ((a :*: b) x) ((a' :*: b') x) (a x, b x) (a' x, b' x)
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Type alias for prism
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
type Prism' s a = Prism s s a a
match :: Prism s t a b -> s -> Either t a
build :: Prism s t a b -> b -> t
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prism2prismvl :: APrism i s t a b -> Prism s t a b
data Market a b s t
Market :: (b -> t) -> (s -> Either t a) -> Market a b s t


-- | Derive record field getters and setters generically.
module Data.Generics.Product.Fields

-- | Records that have a field with a given name.
class HasField (field :: Symbol) s t a b | s field -> a, t field -> b, s field b -> t, t field a -> s

-- | A lens that focuses on a field with a given name. Compatible with the
--   lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. field @"age"
--   50
--   </pre>
--   
--   <h3><i>Type changing</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :t human
--   human :: Human Bool
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t human &amp; field @"other" .~ (42 :: Int)
--   human &amp; field @"other" .~ (42 :: Int) :: Human Int
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"other" .~ 42
--   Human {name = "Tunyasz", age = 50, address = "London", other = 42}
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"weight" .~ 42
--   ...
--   ... The type Human Bool does not contain a field named 'weight'.
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; field @"address" .~ ""
--   ...
--   ... Not all constructors of the type Human Bool
--   ... contain a field named 'address'.
--   ... The offending constructors are:
--   ... HumanNoAddress
--   ...
--   </pre>
field :: HasField field s t a b => Lens s t a b
class HasField' (field :: Symbol) s a | s field -> a
field' :: HasField' field s a => Lens s s a a

-- | Records that have a field with a given name.
--   
--   This is meant to be more general than <a>HasField</a>, but that is not
--   quite the case due to the lack of functional dependencies.
--   
--   The types <tt>s</tt> and <tt>t</tt> must be applications of the same
--   type constructor. In contrast, <a>HasField</a> also requires the
--   parameters of that type constructor to have representational roles.
--   
--   One use case of <a>HasField_</a> over <a>HasField</a> is for records
--   defined with <tt>data instance</tt>.
class HasField_ (field :: Symbol) s t a b
field_ :: HasField_ field s t a b => Lens s t a b

-- | <pre>
--   &gt;&gt;&gt; getField @"age" human
--   50
--   </pre>
getField :: forall f a s. HasField' f s a => s -> a

-- | <pre>
--   &gt;&gt;&gt; setField @"age" 60 human
--   Human {name = "Tunyasz", age = 60, address = "London", other = False}
--   </pre>
setField :: forall f s a. HasField' f s a => a -> s -> s
instance Data.Generics.Product.Internal.Fields.Context' field s a => Data.Generics.Product.Fields.HasField' field s a
instance (Data.Generics.Product.Internal.Fields.Context field s t a b, Data.Generics.Product.Fields.HasField0 field s t a b) => Data.Generics.Product.Fields.HasField field s t a b
instance (Data.Generics.Product.Internal.Fields.Context_ field s t a b, Data.Generics.Product.Fields.HasField0 field s t a b) => Data.Generics.Product.Fields.HasField_ field s t a b
instance Data.Generics.Product.Internal.Fields.Context0 field s t a b => Data.Generics.Product.Fields.HasField0 field s t a b
instance Data.Generics.Product.Fields.HasField' f (Data.Generics.Internal.Void.Void1 a) a
instance Data.Generics.Product.Fields.HasField_ f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Product.Fields.HasField f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Derive an isomorphism between a product type and a flat HList.
module Data.Generics.Product.HList
class IsList (f :: Type) (g :: Type) (as :: [Type]) (bs :: [Type]) | f -> as, g -> bs
list :: IsList f g as bs => Iso f g (HList as) (HList bs)
instance (GHC.Generics.Generic f, GHC.Generics.Generic g, Data.Generics.Product.Internal.HList.GIsList (GHC.Generics.Rep f) (GHC.Generics.Rep g) as bs) => Data.Generics.Product.HList.IsList f g as bs


-- | Derive traversals over type parameters
module Data.Generics.Product.Param
newtype () => Rec p a (x :: k)
Rec :: K1 R a x -> Rec p a (x :: k)
class HasParam (p :: Nat) s t a b | p t a -> s, p s b -> t, p s -> a, p t -> b
param :: HasParam p s t a b => Traversal s t a b
data family Param :: Nat -> j -> k
instance Data.Generics.Product.Internal.Param.Context n s t a b => Data.Generics.Product.Param.HasParam n s t a b
instance Data.Generics.Product.Param.HasParam p (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Derive positional product type getters and setters generically.
module Data.Generics.Product.Positions

-- | Records that have a field at a given position.
class HasPosition (i :: Nat) s t a b | s i -> a, t i -> b, s i b -> t, t i a -> s

-- | A lens that focuses on a field at a given position. Compatible with
--   the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. position @1
--   "Tunyasz"
--   
--   &gt;&gt;&gt; human &amp; position @3 .~ "Berlin"
--   Human {name = "Tunyasz", age = 50, address = "Berlin"}
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human &amp; position @4 .~ "Berlin"
--   ...
--   ... The type Human does not contain a field at position 4
--   ...
--   </pre>
position :: HasPosition i s t a b => Lens s t a b

-- | Records that have a field at a given position.
--   
--   The difference between <a>HasPosition</a> and <a>HasPosition_</a> is
--   similar to the one between <a>HasField</a> and <a>HasField_</a>. See
--   <a>HasField_</a>.
class HasPosition' (i :: Nat) s a | s i -> a
position' :: HasPosition' i s a => Lens s s a a
class HasPosition_ (i :: Nat) s t a b
position_ :: HasPosition_ i s t a b => Lens s t a b

-- | Records that have a field at a given position.
--   
--   This class gives the minimal constraints needed to define this lens.
--   For common uses, see <a>HasPosition</a>.
class HasPosition0 (i :: Nat) s t a b
position0 :: HasPosition0 i s t a b => Lens s t a b

-- | <pre>
--   &gt;&gt;&gt; getPosition @2 human
--   50
--   </pre>
getPosition :: forall i s a. HasPosition' i s a => s -> a

-- | <pre>
--   &gt;&gt;&gt; setPosition @2 60 human
--   Human {name = "Tunyasz", age = 60, address = "London"}
--   </pre>
setPosition :: forall i s a. HasPosition' i s a => a -> s -> s
instance (Data.Generics.Product.Internal.Positions.Context i s t a b, Data.Generics.Product.Positions.HasPosition0 i s t a b) => Data.Generics.Product.Positions.HasPosition i s t a b
instance (Data.Generics.Product.Internal.Positions.Context_ i s t a b, Data.Generics.Product.Positions.HasPosition0 i s t a b) => Data.Generics.Product.Positions.HasPosition_ i s t a b
instance Data.Generics.Product.Internal.Positions.Context0 i s t a b => Data.Generics.Product.Positions.HasPosition0 i s t a b
instance Data.Generics.Product.Internal.Positions.Context' i s a => Data.Generics.Product.Positions.HasPosition' i s a
instance Data.Generics.Product.Positions.HasPosition_ f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Product.Positions.HasPosition f (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Structural subtype relationships between product types.
module Data.Generics.Product.Subtype

-- | Structural subtype relationship
--   
--   <tt>sub</tt> is a (structural) <tt>subtype</tt> of <tt>sup</tt>, if
--   its fields are a subset of those of <tt>sup</tt>.
class Subtype sup sub

-- | Structural subtype lens. Given a subtype relationship <tt>sub :&lt;
--   sup</tt>, we can focus on the <tt>sub</tt> structure of <tt>sup</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. super @Animal
--   Animal {name = "Tunyasz", age = 50}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set (super @Animal) (Animal "dog" 10) human
--   Human {name = "dog", age = 10, address = "London"}
--   </pre>
super :: Subtype sup sub => Lens sub sub sup sup

-- | Cast the more specific subtype to the more general supertype
--   
--   <pre>
--   &gt;&gt;&gt; upcast human :: Animal
--   Animal {name = "Tunyasz", age = 50}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upcast (upcast human :: Animal) :: Human
--   ...
--   ... The type 'Animal' is not a subtype of 'Human'.
--   ... The following fields are missing from 'Animal':
--   ... address
--   ...
--   </pre>
upcast :: Subtype sup sub => sub -> sup

-- | Plug a smaller structure into a larger one
--   
--   <pre>
--   &gt;&gt;&gt; smash (Animal "dog" 10) human
--   Human {name = "dog", age = 10, address = "London"}
--   </pre>
smash :: Subtype sup sub => sup -> sub -> sub
instance Data.Generics.Product.Internal.Subtype.Context a b => Data.Generics.Product.Subtype.Subtype b a
instance Data.Generics.Product.Subtype.Subtype a a
instance Data.Generics.Product.Subtype.Subtype a Data.Generics.Internal.Void.Void
instance Data.Generics.Product.Subtype.Subtype Data.Generics.Internal.Void.Void a


-- | Derive lenses of a given type in a product.
module Data.Generics.Product.Typed

-- | Records that have a field with a unique type.
class HasType a s

-- | A lens that focuses on a field with a unique type in its parent type.
--   Compatible with the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @Int
--   50
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @String
--   ...
--   ...
--   ... The type Human contains multiple values of type [Char].
--   ... The choice of value is thus ambiguous. The offending constructors are:
--   ... Human
--   ... HumanNoTall
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. typed @Bool
--   ...
--   ...
--   ... Not all constructors of the type Human contain a field of type Bool.
--   ... The offending constructors are:
--   ... HumanNoTall
--   ...
--   </pre>
typed :: HasType a s => Lens s s a a

-- | Get field at type.
getTyped :: HasType a s => s -> a

-- | Set field at type.
setTyped :: HasType a s => a -> s -> s
instance Data.Generics.Product.Internal.Typed.Context a s => Data.Generics.Product.Typed.HasType a s
instance Data.Generics.Product.Typed.HasType a a
instance Data.Generics.Product.Typed.HasType a Data.Generics.Internal.Void.Void


-- | Derive a variety of lenses generically.
module Data.Generics.Product.Any
class HasAny sel s t a b | s sel -> a

-- | A lens that focuses on a part of a product as identified by some
--   selector. Currently supported selectors are field names, positions and
--   unique types. Compatible with the lens package's <a>Lens</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @Int
--   50
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @"name"
--   "Tunyasz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; human ^. the @3
--   "London"
--   </pre>
the :: HasAny sel s t a b => Lens s t a b
instance Data.Generics.Product.Positions.HasPosition i s t a b => Data.Generics.Product.Any.HasAny i s t a b
instance Data.Generics.Product.Fields.HasField field s t a b => Data.Generics.Product.Any.HasAny field s t a b
instance (Data.Generics.Product.Typed.HasType a s, t GHC.Types.~ s, a GHC.Types.~ b) => Data.Generics.Product.Any.HasAny a s t a b


-- | Derive traversals of a given type in a product.
module Data.Generics.Product.Types
class () => HasTypes s a

-- | Traverse all types in the given structure.
--   
--   For example, to update all <a>String</a>s in a <tt>WTree (Maybe
--   String) String</tt>, we can write
--   
--   <pre>
--   &gt;&gt;&gt; myTree = WithWeight (Fork (Leaf (Just "hello")) (Leaf Nothing)) "world"
--   
--   &gt;&gt;&gt; over (types @String) (++ "!") myTree
--   WithWeight (Fork (Leaf (Just "hello!")) (Leaf Nothing)) "world!"
--   </pre>
--   
--   The traversal is <i>deep</i>, which means that not just the immediate
--   children are visited, but all nested values too.
types :: forall a s. HasTypes s a => Traversal' s a

-- | The children of a type are the types of its fields. The
--   <a>Children</a> type family maps a type <tt>a</tt> to its set of
--   children.
--   
--   This type family is parameterized by a symbol <tt>ch</tt> (that can be
--   declared as an empty data type). The symbol <a>ChGeneric</a> provides
--   a default definition. You can create new symbols to override the set
--   of children of abstract, non-generic types.
--   
--   The following example declares a <tt>Custom</tt> symbol to redefine
--   <a>Children</a> for some abstract types from the <tt>time</tt>
--   library.
--   
--   <pre>
--   data Custom
--   type instance <a>Children</a> Custom a = ChildrenCustom a
--   
--   type family ChildrenCustom (a :: Type) where
--     ChildrenCustom DiffTime        = '[]
--     ChildrenCustom NominalDiffTime = '[]
--     -- Add more custom mappings here.
--   
--     ChildrenCustom a = Children ChGeneric a
--   </pre>
--   
--   To use this definition, replace <tt>types</tt> with
--   <tt><tt>typesUsing</tt> @Custom</tt>.
type family Children ch a :: [Type]

-- | The default definition of <a>Children</a>. Primitive types from core
--   libraries have no children, and other types are assumed to be
--   <a>Generic</a>.
data () => ChGeneric

class () => HasTypesUsing ch s t a b

typesUsing :: forall ch a s. HasTypesUsing ch s s a a => Traversal' s a

-- | By adding instances to this class, we can override the default
--   behaviour in an ad-hoc manner. For example:
--   
--   <pre>
--   instance HasTypesCustom Custom Opaque Opaque String String where
--     typesCustom f (Opaque str) = Opaque <a>$</a> f str
--   </pre>
class () => HasTypesCustom ch s t a b

-- | This function should never be used directly, only to override the
--   default traversal behaviour. To actually use the custom traversal
--   strategy, see <tt>typesUsing</tt>. This is because <tt>typesUsing</tt>
--   does additional optimisations, like ensuring that nodes with no
--   relevant members will not be traversed at runtime.
typesCustom :: HasTypesCustom ch s t a b => Traversal s t a b


-- | Magic product operations using Generics
--   
--   These classes need not be instantiated manually, as GHC can
--   automatically prove valid instances via Generics. Only the
--   <tt>Generic</tt> class needs to be derived (see examples).
module Data.Generics.Product


-- | Derive constructor-name-based prisms generically.
module Data.Generics.Sum.Constructors

-- | Sums that have a constructor with a given name.
class AsConstructor (ctor :: Symbol) s t a b | ctor s -> a, ctor t -> b

-- | A prism that projects a named constructor from a sum. Compatible with
--   the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Ctor @"Dog"
--   Just (MkDog {name = "Shep", age = 3, fieldA = 30})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Ctor @"Cat"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Ctor @"Cat"
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Ctor @"Cat" # ("Garfield", 6) :: Animal Int
--   Cat "Garfield" 6
--   </pre>
--   
--   <h3><i>Type errors</i></h3>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Ctor @"Turtle"
--   ...
--   ...
--   ... The type Animal Int does not contain a constructor named "Turtle"
--   ...
--   </pre>
_Ctor :: AsConstructor ctor s t a b => Prism s t a b

-- | Sums that have a constructor with a given name.
--   
--   The difference between <tt>HasConstructor</tt> and
--   <tt>HasConstructor_</tt> is similar to the one between <a>HasField</a>
--   and <a>HasField_</a>. See <a>HasField_</a>.
class AsConstructor_ (ctor :: Symbol) s t a b
_Ctor_ :: AsConstructor_ ctor s t a b => Prism s t a b
class AsConstructor' (ctor :: Symbol) s a | ctor s -> a
_Ctor' :: AsConstructor' ctor s a => Prism s s a a

-- | Sums that have a constructor with a given name.
--   
--   This class gives the minimal constraints needed to define this prism.
--   For common uses, see <tt>HasConstructor</tt>.
class AsConstructor0 (ctor :: Symbol) s t a b
_Ctor0 :: AsConstructor0 ctor s t a b => Prism s t a b
instance (Data.Generics.Sum.Internal.Constructors.Context' ctor s a, Data.Generics.Sum.Constructors.AsConstructor0 ctor s s a a) => Data.Generics.Sum.Constructors.AsConstructor' ctor s a
instance (Data.Generics.Sum.Internal.Constructors.Context ctor s t a b, Data.Generics.Sum.Constructors.AsConstructor0 ctor s t a b) => Data.Generics.Sum.Constructors.AsConstructor ctor s t a b
instance (Data.Generics.Sum.Internal.Constructors.Context_ ctor s t a b, Data.Generics.Sum.Constructors.AsConstructor0 ctor s t a b) => Data.Generics.Sum.Constructors.AsConstructor_ ctor s t a b
instance Data.Generics.Sum.Internal.Constructors.Context0 ctor s t a b => Data.Generics.Sum.Constructors.AsConstructor0 ctor s t a b
instance Data.Generics.Sum.Constructors.AsConstructor_ ctor (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b
instance Data.Generics.Sum.Constructors.AsConstructor ctor (Data.Generics.Internal.Void.Void1 a) (Data.Generics.Internal.Void.Void1 b) a b


-- | Structural subtype relationships between sum types.
module Data.Generics.Sum.Subtype

-- | Structural subtyping between sums. A sum <tt>Sub</tt> is a subtype of
--   another sum <tt>Sup</tt> if a value of <tt>Sub</tt> can be given
--   (modulo naming of constructors) whenever a value of <tt>Sup</tt> is
--   expected. In the running example for instance,
--   <tt>FourLeggedAnimal</tt> is a subtype of <tt>Animal</tt> since a
--   value of the former can be given as a value of the latter (renaming
--   <tt>Dog4</tt> to <tt>Dog</tt> and <tt>Cat4</tt> to <tt>Cat</tt>).
class AsSubtype sub sup

-- | A prism that captures structural subtyping. Allows a substructure to
--   be injected (upcast) into a superstructure or a superstructure to be
--   downcast into a substructure (which may fail).
--   
--   <pre>
--   &gt;&gt;&gt; _Sub # dog4 :: Animal
--   Dog (MkDog {name = "Snowy", age = 4})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _Sub :: Maybe FourLeggedAnimal
--   Just (Cat4 "Mog" 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duck ^? _Sub :: Maybe FourLeggedAnimal
--   Nothing
--   </pre>
_Sub :: AsSubtype sub sup => Prism' sup sub

-- | Injects a subtype into a supertype (upcast).
injectSub :: AsSubtype sub sup => sub -> sup

-- | Projects a subtype from a supertype (downcast).
projectSub :: AsSubtype sub sup => sup -> Maybe sub
instance Data.Generics.Sum.Internal.Subtype.Context sub sup => Data.Generics.Sum.Subtype.AsSubtype sub sup
instance Data.Generics.Sum.Subtype.AsSubtype a a
instance Data.Generics.Sum.Subtype.AsSubtype a Data.Generics.Internal.Void.Void
instance Data.Generics.Sum.Subtype.AsSubtype Data.Generics.Internal.Void.Void a


-- | Derive constructor-field-type-based prisms generically.
module Data.Generics.Sum.Typed

-- | Sums that have a constructor with a field of the given type.
class AsType a s

-- | A prism that projects a constructor uniquely identifiable by the type
--   of its field. Compatible with the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _Typed @Dog
--   Just (MkDog {name = "Shep", age = Age 3})
--   
--   &gt;&gt;&gt; cat ^? _Typed @(Name, Age)
--   Just ("Mog",Age 5)
--   
--   &gt;&gt;&gt; dog ^? _Typed @Age
--   ...
--   ...
--   ... The type Animal contains multiple constructors whose fields are of type Age.
--   ... The choice of constructor is thus ambiguous, could be any of:
--   ... Duck
--   ... Turtle
--   ...
--   </pre>
_Typed :: AsType a s => Prism' s a

-- | Inject by type.
injectTyped :: AsType a s => a -> s

-- | Project by type.
projectTyped :: AsType a s => s -> Maybe a
instance Data.Generics.Sum.Internal.Typed.Context a s => Data.Generics.Sum.Typed.AsType a s
instance Data.Generics.Sum.Typed.AsType a Data.Generics.Internal.Void.Void
instance Data.Generics.Sum.Typed.AsType Data.Generics.Internal.Void.Void a


-- | Derive a variety of prisms generically.
module Data.Generics.Sum.Any

-- | Sums that have generic prisms.
class AsAny sel a s | s sel -> a

-- | A prism that projects a sum as identified by some selector. Currently
--   supported selectors are constructor names and unique types. Compatible
--   with the lens package's <a>Prism</a> type.
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @"Dog"
--   Just (MkDog {name = "Shep", age = 3})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @Dog
--   Just (MkDog {name = "Shep", age = 3})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dog ^? _As @"Cat"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _As @(Name, Age)
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cat ^? _As @"Cat"
--   Just ("Mog",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _As @"Cat" # ("Garfield", 6) :: Animal
--   Cat "Garfield" 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; duck ^? _As @Age
--   Just 2
--   </pre>
_As :: AsAny sel a s => Prism s s a a
instance Data.Generics.Sum.Constructors.AsConstructor ctor s s a a => Data.Generics.Sum.Any.AsAny ctor a s
instance Data.Generics.Sum.Typed.AsType a s => Data.Generics.Sum.Any.AsAny a a s


-- | Magic sum operations using Generics
--   
--   These classes need not be instantiated manually, as GHC can
--   automatically prove valid instances via Generics. Only the
--   <tt>Generic</tt> class needs to be derived (see examples).
module Data.Generics.Sum


-- | Provides an (orphan) IsLabel instance for field lenses and constructor
--   prisms. Use at your own risk.
module Data.Generics.Labels

-- | <a>Field</a> is morally the same as <a>HasField</a>, but it is
--   constructed from an incoherent combination of <a>HasField</a> and
--   <a>HasField'</a>. In this way, it can be seamlessly used in the
--   <a>IsLabel</a> instance even when dealing with data types that don't
--   have <a>Field</a> instances (like data instances).
class Field name s t a b | s name -> a, t name -> b, s name b -> t, t name a -> s
fieldLens :: Field name s t a b => Lens s t a b
type Field' name s a = Field name s s a a

-- | <a>Constructor</a> is morally the same as <a>AsConstructor</a>, but it
--   is constructed from an incoherent combination of <a>AsConstructor</a>
--   and <a>AsConstructor'</a>. In this way, it can be seamlessly used in
--   the <a>IsLabel</a> instance even when dealing with data types that
--   don't have <a>Constructor</a> instances (like data instances).
class Constructor name s t a b | name s -> a, name t -> b
constructorPrism :: Constructor name s t a b => Prism s t a b
type Constructor' name s a = Constructor name s s a a
instance forall k1 k2 k3 (labelType :: Data.Generics.Labels.LabelType) (name :: GHC.Types.Symbol) (p :: k1 -> k2 -> *) (f :: k3 -> k2) (s :: k1) (t :: k3) (a :: k1) (b :: k3) pafb psft. (labelType GHC.Types.~ Data.Generics.Labels.ClassifyLabel name, Data.Generics.Labels.IsLabelHelper labelType name p f s t a b, pafb GHC.Types.~ p a (f b), psft GHC.Types.~ p s (f t)) => GHC.OverloadedLabels.IsLabel name (pafb -> psft)
instance forall k (f :: * -> *) (name :: k) s t a b. (GHC.Base.Functor f, Data.Generics.Labels.Field name s t a b) => Data.Generics.Labels.IsLabelHelper 'Data.Generics.Labels.FieldType name (->) f s t a b
instance (GHC.Base.Applicative f, Data.Profunctor.Choice.Choice p, Data.Generics.Labels.Constructor name s t a b, name' GHC.Types.~ GHC.TypeLits.AppendSymbol "_" name) => Data.Generics.Labels.IsLabelHelper 'Data.Generics.Labels.LegacyConstrType name' p f s t a b
instance forall k (f :: * -> *) (p :: * -> * -> *) (name :: k) s t a b. (GHC.Base.Applicative f, Data.Profunctor.Choice.Choice p, Data.Generics.Labels.Constructor name s t a b) => Data.Generics.Labels.IsLabelHelper 'Data.Generics.Labels.ConstrType name p f s t a b
instance Data.Generics.Sum.Constructors.AsConstructor name s t a b => Data.Generics.Labels.Constructor name s t a b
instance Data.Generics.Sum.Constructors.AsConstructor' name s a => Data.Generics.Labels.Constructor name s s a a
instance Data.Generics.Product.Fields.HasField name s t a b => Data.Generics.Labels.Field name s t a b
instance Data.Generics.Product.Fields.HasField' name s a => Data.Generics.Labels.Field name s s a a


-- | Derive an isomorphism between a newtype and its wrapped type.
module Data.Generics.Wrapped

class Wrapped s t a b | s -> a, t -> b

wrappedIso :: Wrapped s t a b => Iso s t a b

wrappedTo :: forall s t a b. Wrapped s t a b => s -> a

wrappedFrom :: forall s t a b. Wrapped s t a b => b -> t

_Unwrapped :: Wrapped s t a b => Iso s t a b

_Wrapped :: Wrapped s t a b => Iso b a t s
instance Data.Generics.Internal.Wrapped.Context s t a b => Data.Generics.Wrapped.Wrapped s t a b
