-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate a Swagger/OpenAPI/OAS 3.0 specification for your servant API.
--   
--   Swagger is a project used to describe and document RESTful APIs. The
--   core of the project is the <a>OpenAPI Specification (OAS)</a>. This
--   library implements v3.0 of the spec. Unlike Servant it is
--   language-agnostic and thus is quite popular among developers in
--   different languages. It has also existed for a longer time and has
--   more helpful tooling.
--   
--   This package provides means to generate a Swagger/OAS specification
--   for a Servant API and also to partially test whether an API conforms
--   with its specification.
--   
--   Generated Swagger specification then can be used for many things such
--   as
--   
--   <ul>
--   <li>displaying interactive documentation using <a>Swagger UI</a>;</li>
--   <li>generating clients and servers in many languages using <a>Swagger
--   Codegen</a>;</li>
--   <li>and <a>many others</a>.</li>
--   </ul>
@package servant-openapi3
@version 2.0.1.6

module Servant.OpenApi.Internal.Orphans
instance (Data.Typeable.Internal.Typeable (Servant.Types.SourceT.SourceT m a), Data.OpenApi.Internal.Schema.ToSchema a) => Data.OpenApi.Internal.Schema.ToSchema (Servant.Types.SourceT.SourceT m a)

module Servant.OpenApi.Internal.TypeLevel.API

-- | Build a list of endpoints from an API.
type family EndpointsList api

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.
type family IsSubAPI sub api :: Constraint

-- | Check that every element of <tt>xs</tt> is an endpoint of
--   <tt>api</tt>.
type family AllIsElem xs api :: Constraint

-- | Apply <tt>(e :&gt;)</tt> to every API in <tt>xs</tt>.
type family MapSub e xs

-- | Append two type-level lists.
type family AppendList xs ys
type family Or (a :: Constraint) (b :: Constraint) :: Constraint
type family IsIn sub api :: Constraint

-- | Check whether a type is a member of a list of types. This is a
--   type-level analogue of <tt><a>elem</a></tt>.
type family Elem x xs

-- | Remove duplicates from a type-level list.
type family Nub xs

-- | Remove element from a type-level list.
type family Remove x xs

-- | Extract a list of unique "body" types for a specific content-type from
--   a servant API.
type BodyTypes c api = Nub (BodyTypes' c api)

-- | <tt><a>AddBodyType</a> c cs a as</tt> adds type <tt>a</tt> to the list
--   <tt>as</tt> only if <tt>c</tt> is in <tt>cs</tt>.
type AddBodyType c cs a as = If (Elem c cs) (a ': as) as

-- | Extract a list of "body" types for a specific content-type from a
--   servant API. To extract unique types see <tt><a>BodyTypes</a></tt>.
--   
--   <tt><a>NoContent</a></tt> is removed from the list and not tested.
--   (This allows for leaving the body completely empty on responses to
--   requests that only accept 'application/json', while setting the
--   content-type in the response accordingly.)
type family BodyTypes' c api :: [*]

module Servant.OpenApi.Internal

-- | Generate a OpenApi specification for a servant API.
--   
--   To generate OpenApi specification, your data types need
--   <tt><a>ToParamSchema</a></tt> and/or <tt><a>ToSchema</a></tt>
--   instances.
--   
--   <tt><a>ToParamSchema</a></tt> is used for <tt><a>Capture</a></tt>,
--   <tt><a>QueryParam</a></tt> and <tt><a>ResponseHeader</a></tt>.
--   <tt><a>ToSchema</a></tt> is used for <tt><a>ReqBody</a></tt> and
--   response data types.
--   
--   You can easily derive those instances via <tt>Generic</tt>. For more
--   information, refer to <a>openapi3 documentation</a>.
--   
--   Example:
--   
--   <pre>
--   newtype Username = Username String deriving (Generic, ToText)
--   
--   instance ToParamSchema Username
--   
--   data User = User
--     { username :: Username
--     , fullname :: String
--     } deriving (Generic)
--   
--   instance ToJSON User
--   instance ToSchema User
--   
--   type MyAPI = QueryParam "username" Username :&gt; Get '[JSON] User
--   
--   myOpenApi :: OpenApi
--   myOpenApi = toOpenApi (Proxy :: Proxy MyAPI)
--   </pre>
class HasOpenApi api

-- | Generate a OpenApi specification for a servant API.
toOpenApi :: HasOpenApi api => Proxy api -> OpenApi

-- | All operations of sub API. This is similar to
--   <tt><a>operationsOf</a></tt> but ensures that operations indeed belong
--   to the API at compile time.
subOperations :: (IsSubAPI sub api, HasOpenApi sub) => Proxy sub -> Proxy api -> Traversal' OpenApi Operation

-- | Make a singleton OpenApi spec (with only one endpoint). For endpoints
--   with no content see <a>mkEndpointNoContent</a>.
mkEndpoint :: forall a cs hs proxy method status. (ToSchema a, AllAccept cs, AllToResponseHeader hs, OpenApiMethod method, KnownNat status) => FilePath -> proxy (Verb method status cs (Headers hs a)) -> OpenApi

-- | Make a singletone <a>OpenApi</a> spec (with only one endpoint) and
--   with no content schema.
mkEndpointNoContent :: forall nocontent cs hs proxy method status. (AllAccept cs, AllToResponseHeader hs, OpenApiMethod method, KnownNat status) => FilePath -> proxy (Verb method status cs (Headers hs nocontent)) -> OpenApi

-- | Like <tt><a>mkEndpoint</a></tt> but with explicit schema reference.
--   Unlike <tt><a>mkEndpoint</a></tt> this function does not update
--   <tt><tt>definitions</tt></tt>.
mkEndpointWithSchemaRef :: forall cs hs proxy method status a. (AllAccept cs, AllToResponseHeader hs, OpenApiMethod method, KnownNat status) => Maybe (Referenced Schema) -> FilePath -> proxy (Verb method status cs (Headers hs a)) -> OpenApi
mkEndpointNoContentVerb :: forall proxy method. OpenApiMethod method => FilePath -> proxy (NoContentVerb method) -> OpenApi

-- | Add parameter to every operation in the spec.
addParam :: Param -> OpenApi -> OpenApi

-- | Add RequestBody to every operations in the spec.
addRequestBody :: RequestBody -> OpenApi -> OpenApi

-- | Format given text as inline code in Markdown.
markdownCode :: Text -> Text
addDefaultResponse404 :: ParamName -> OpenApi -> OpenApi
addDefaultResponse400 :: ParamName -> OpenApi -> OpenApi

-- | Methods, available for OpenApi.
class OpenApiMethod method
openApiMethod :: OpenApiMethod method => proxy method -> Lens' PathItem (Maybe Operation)
class AllAccept cs
allContentType :: AllAccept cs => Proxy cs -> [MediaType]
class ToResponseHeader h
toResponseHeader :: ToResponseHeader h => Proxy h -> (HeaderName, Header)
class AllToResponseHeader hs
toAllResponseHeaders :: AllToResponseHeader hs => Proxy hs -> InsOrdHashMap HeaderName Header
instance forall k1 a (cs :: [*]) (hs :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1). (Data.OpenApi.Internal.Schema.ToSchema a, Servant.OpenApi.Internal.AllAccept cs, Servant.OpenApi.Internal.AllToResponseHeader hs, GHC.TypeNats.KnownNat status, Servant.OpenApi.Internal.OpenApiMethod method) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Verbs.Verb method status cs (Servant.API.ResponseHeaders.Headers hs a))
instance forall k1 (cs :: [*]) (hs :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1). (Servant.OpenApi.Internal.AllAccept cs, Servant.OpenApi.Internal.AllToResponseHeader hs, GHC.TypeNats.KnownNat status, Servant.OpenApi.Internal.OpenApiMethod method) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Verbs.Verb method status cs (Servant.API.ResponseHeaders.Headers hs Servant.API.ContentTypes.NoContent))
instance Servant.OpenApi.Internal.AllToResponseHeader '[]
instance forall a (h :: a) (hs :: [a]). (Servant.OpenApi.Internal.ToResponseHeader h, Servant.OpenApi.Internal.AllToResponseHeader hs) => Servant.OpenApi.Internal.AllToResponseHeader (h : hs)
instance Servant.OpenApi.Internal.AllToResponseHeader hs => Servant.OpenApi.Internal.AllToResponseHeader (Servant.API.ResponseHeaders.HList hs)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a) => Servant.OpenApi.Internal.ToResponseHeader (Servant.API.Header.Header sym a)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Servant.API.UVerb.HasStatus a, Servant.OpenApi.Internal.AllAccept cs, Servant.OpenApi.Internal.OpenApiMethod method, Servant.OpenApi.Internal.HasOpenApi (Servant.API.UVerb.UVerb method cs as)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.UVerb.UVerb method cs (a : as))
instance forall k1 a (cs :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1). (Data.OpenApi.Internal.Schema.ToSchema a, Servant.OpenApi.Internal.AllAccept cs, GHC.TypeNats.KnownNat status, Servant.OpenApi.Internal.OpenApiMethod method) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Verbs.Verb method status cs a)
instance forall k1 (cs :: [*]) (status :: GHC.TypeNats.Nat) (method :: k1). (Servant.OpenApi.Internal.AllAccept cs, GHC.TypeNats.KnownNat status, Servant.OpenApi.Internal.OpenApiMethod method) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Verbs.Verb method status cs Servant.API.ContentTypes.NoContent)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Servant.OpenApi.Internal.AllAccept cs, Servant.OpenApi.Internal.HasOpenApi sub, GHC.TypeLits.KnownSymbol (Servant.API.Description.FoldDescription mods)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.ReqBody.ReqBody' mods cs a Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.AllAccept '[]
instance forall a (c :: a) (cs :: [a]). (Servant.API.ContentTypes.Accept c, Servant.OpenApi.Internal.AllAccept cs) => Servant.OpenApi.Internal.AllAccept (c : cs)
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.GET
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.PUT
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.POST
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.DELETE
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.OPTIONS
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.HEAD
instance Servant.OpenApi.Internal.OpenApiMethod 'Network.HTTP.Types.Method.PATCH
instance forall k1 a ct (status :: GHC.TypeNats.Nat) (method :: k1) fr. (Data.OpenApi.Internal.Schema.ToSchema a, Servant.API.ContentTypes.Accept ct, GHC.TypeNats.KnownNat status, Servant.OpenApi.Internal.OpenApiMethod method) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Stream.Stream method status fr ct a)
instance forall k1 (method :: k1). Servant.OpenApi.Internal.OpenApiMethod method => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Verbs.NoContentVerb method)
instance Servant.OpenApi.Internal.HasOpenApi Servant.API.Raw.Raw
instance Servant.OpenApi.Internal.HasOpenApi Servant.API.Empty.EmptyAPI
instance Servant.OpenApi.Internal.HasOpenApi (Servant.API.UVerb.UVerb method cs '[])
instance (Servant.OpenApi.Internal.HasOpenApi a, Servant.OpenApi.Internal.HasOpenApi b) => Servant.OpenApi.Internal.HasOpenApi (a Servant.API.Alternative.:<|> b)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Data.Vault.Lazy.Vault Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Servant.API.WithNamedContext.WithNamedContext x c sub)
instance (GHC.TypeLits.KnownSymbol sym, Servant.OpenApi.Internal.HasOpenApi sub) => Servant.OpenApi.Internal.HasOpenApi (sym Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a, Servant.OpenApi.Internal.HasOpenApi sub, GHC.TypeLits.KnownSymbol (Servant.API.Description.FoldDescription mods)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a, Servant.OpenApi.Internal.HasOpenApi sub) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Capture.CaptureAll sym a Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol desc, Servant.OpenApi.Internal.HasOpenApi api) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Description.Description desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol desc, Servant.OpenApi.Internal.HasOpenApi api) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Description.Summary desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a, Servant.OpenApi.Internal.HasOpenApi sub, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), GHC.TypeLits.KnownSymbol (Servant.API.Description.FoldDescription mods)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a, Servant.OpenApi.Internal.HasOpenApi sub) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.QueryParam.QueryParams sym a Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Servant.OpenApi.Internal.HasOpenApi sub) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Data.OpenApi.Internal.ParamSchema.ToParamSchema a, Servant.OpenApi.Internal.HasOpenApi sub, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods), GHC.TypeLits.KnownSymbol (Servant.API.Description.FoldDescription mods)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> sub)
instance (Data.OpenApi.Internal.Schema.ToSchema a, Servant.API.ContentTypes.Accept ct, Servant.OpenApi.Internal.HasOpenApi sub, GHC.TypeLits.KnownSymbol (Servant.API.Description.FoldDescription mods)) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Stream.StreamBody' mods fr ct a Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi sub => Servant.OpenApi.Internal.HasOpenApi (Servant.API.Fragment.Fragment a Servant.API.Sub.:> sub)
instance Servant.OpenApi.Internal.HasOpenApi (Servant.API.Generic.ToServantApi sub) => Servant.OpenApi.Internal.HasOpenApi (Servant.API.NamedRoutes.NamedRoutes sub)
instance (Data.Typeable.Internal.Typeable (Servant.API.UVerb.WithStatus s a), Data.OpenApi.Internal.Schema.ToSchema a) => Data.OpenApi.Internal.Schema.ToSchema (Servant.API.UVerb.WithStatus s a)

module Servant.OpenApi.Internal.TypeLevel.TMap

-- | Map a list of constrained types to a list of values.
--   
--   <pre>
--   &gt;&gt;&gt; tmap (Proxy :: Proxy KnownSymbol) symbolVal (Proxy :: Proxy ["hello", "world"])
--   ["hello","world"]
--   </pre>
class TMap (q :: k -> Constraint) (xs :: [k])
tmap :: TMap q xs => p q -> (forall x p'. q x => p' x -> a) -> p'' xs -> [a]
instance forall k (q :: k -> GHC.Types.Constraint). Servant.OpenApi.Internal.TypeLevel.TMap.TMap q '[]
instance forall a (q :: a -> GHC.Types.Constraint) (x :: a) (xs :: [a]). (q x, Servant.OpenApi.Internal.TypeLevel.TMap.TMap q xs) => Servant.OpenApi.Internal.TypeLevel.TMap.TMap q (x : xs)

module Servant.OpenApi.Internal.TypeLevel.Every

-- | Apply multiple constraint constructors to a type.
--   
--   <pre>
--   EveryTF '[Show, Read] a ~ (Show a, Read a)
--   </pre>
--   
--   Note that since this is a type family, you have to alway fully apply
--   <tt><a>EveryTF</a></tt>.
--   
--   For partial application of multiple constraint constructors see
--   <tt><a>Every</a></tt>.
type family EveryTF cs x :: Constraint

-- | Apply multiple constraint constructors to a type as a class.
--   
--   This is different from <tt><a>EveryTF</a></tt> in that it allows
--   partial application.
class EveryTF cs x => Every (cs :: [* -> Constraint]) (x :: *)

-- | Like <tt><a>tmap</a></tt>, but uses <tt><a>Every</a></tt> for multiple
--   constraints.
--   
--   <pre>
--   &gt;&gt;&gt; let zero :: forall p a. (Show a, Num a) =&gt; p a -&gt; String; zero _ = show (0 :: a)
--   
--   &gt;&gt;&gt; tmapEvery (Proxy :: Proxy [Show, Num]) zero (Proxy :: Proxy [Int, Float]) :: [String]
--   ["0","0.0"]
--   </pre>
tmapEvery :: forall a cs p p'' xs. TMap (Every cs) xs => p cs -> (forall x p'. Every cs x => p' x -> a) -> p'' xs -> [a]
instance Servant.OpenApi.Internal.TypeLevel.Every.Every '[] x
instance (c x, Servant.OpenApi.Internal.TypeLevel.Every.Every cs x) => Servant.OpenApi.Internal.TypeLevel.Every.Every (c : cs) x

module Servant.OpenApi.Internal.TypeLevel

module Servant.OpenApi.Internal.Test

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <i>NOTE:</i> <tt><a>validateEveryToJSON</a></tt> does not perform
--   string pattern validation. See
--   <tt><a>validateEveryToJSONWithPatternChecker</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User...
--   ...
--     UserId...
--   ...
--   Finished in ... seconds
--   ...2 examples, 0 failures...
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--   ...No instance for (Arbitrary Contact)
--   ...  arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
--   
--   For validation without patterns see
--   <tt><a>validateEveryToJSON</a></tt>.
validateEveryToJSONWithPatternChecker :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => (Pattern -> Text -> Bool) -> proxy api -> Spec

-- | Construct property tests for each type in a list. The name for each
--   property is the name of the corresponding type.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    hspec $
--      context "read . show == id" $
--        props
--          (Proxy :: Proxy [Eq, Show, Read])
--          (\x -&gt; read (show x) === x)
--          (Proxy :: Proxy [Bool, Int, String])
--   :}
--   
--   read . show == id
--     Bool...
--   ...
--     Int...
--   ...
--     [Char]...
--   ...
--   Finished in ... seconds
--   ...3 examples, 0 failures...
--   </pre>
props :: forall p p'' cs xs. TMap (Every (Typeable ': (Show ': (Arbitrary ': cs)))) xs => p cs -> (forall x. EveryTF cs x => x -> Property) -> p'' xs -> Spec

-- | Pretty print validation errors together with actual JSON and OpenApi
--   Schema (using <a>encodePretty</a>).
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Aeson
--   
--   &gt;&gt;&gt; import Data.Foldable (traverse_)
--   
--   &gt;&gt;&gt; data Person = Person { name :: String, phone :: Integer } deriving (Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Person where toJSON p = object [ "name" .= name p ]
--   
--   &gt;&gt;&gt; instance ToSchema Person
--   
--   &gt;&gt;&gt; let person = Person { name = "John", phone = 123456 }
--   
--   &gt;&gt;&gt; traverse_ putStrLn $ prettyValidateWith validateToJSON person
--   Validation against the schema fails:
--     * property "phone" is required, but not found in "{\"name\":\"John\"}"
--   
--   JSON value:
--   {
--       "name": "John"
--   }
--   
--   OpenApi Schema:
--   {
--       "properties": {
--           "name": {
--               "type": "string"
--           },
--           "phone": {
--               "type": "integer"
--           }
--       },
--       "required": [
--           "name",
--           "phone"
--       ],
--       "type": "object"
--   }
--   </pre>
--   
--   FIXME: this belongs in <a>Data.OpenApi.Schema.Validation</a> (in
--   <tt>swagger2</tt>).
prettyValidateWith :: forall a. (ToJSON a, ToSchema a) => (a -> [ValidationError]) -> a -> Maybe String

-- | Provide a counterexample if there is any.
maybeCounterExample :: Maybe String -> Property
encodePretty :: ToJSON a => a -> ByteString


-- | Automatic tests for servant API against OpenApi spec.
module Servant.OpenApi.Test

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <i>NOTE:</i> <tt><a>validateEveryToJSON</a></tt> does not perform
--   string pattern validation. See
--   <tt><a>validateEveryToJSONWithPatternChecker</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User...
--   ...
--     UserId...
--   ...
--   Finished in ... seconds
--   ...2 examples, 0 failures...
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--   ...No instance for (Arbitrary Contact)
--   ...  arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
--   
--   For validation without patterns see
--   <tt><a>validateEveryToJSON</a></tt>.
validateEveryToJSONWithPatternChecker :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => (Pattern -> Text -> Bool) -> proxy api -> Spec


-- | This module provides means to generate and manipulate OpenApi
--   specification for servant APIs.
--   
--   OpenApi is a project used to describe and document RESTful APIs.
--   
--   The OpenApi specification defines a set of files required to describe
--   such an API. These files can then be used by the OpenApi-UI project to
--   display the API and OpenApi-Codegen to generate clients in various
--   languages. Additional utilities can also take advantage of the
--   resulting files, such as testing tools.
--   
--   For more information see <a>OpenApi documentation</a>.
module Servant.OpenApi

-- | Generate a OpenApi specification for a servant API.
--   
--   To generate OpenApi specification, your data types need
--   <tt><a>ToParamSchema</a></tt> and/or <tt><a>ToSchema</a></tt>
--   instances.
--   
--   <tt><a>ToParamSchema</a></tt> is used for <tt><a>Capture</a></tt>,
--   <tt><a>QueryParam</a></tt> and <tt><a>ResponseHeader</a></tt>.
--   <tt><a>ToSchema</a></tt> is used for <tt><a>ReqBody</a></tt> and
--   response data types.
--   
--   You can easily derive those instances via <tt>Generic</tt>. For more
--   information, refer to <a>openapi3 documentation</a>.
--   
--   Example:
--   
--   <pre>
--   newtype Username = Username String deriving (Generic, ToText)
--   
--   instance ToParamSchema Username
--   
--   data User = User
--     { username :: Username
--     , fullname :: String
--     } deriving (Generic)
--   
--   instance ToJSON User
--   instance ToSchema User
--   
--   type MyAPI = QueryParam "username" Username :&gt; Get '[JSON] User
--   
--   myOpenApi :: OpenApi
--   myOpenApi = toOpenApi (Proxy :: Proxy MyAPI)
--   </pre>
class HasOpenApi api

-- | Generate a OpenApi specification for a servant API.
toOpenApi :: HasOpenApi api => Proxy api -> OpenApi

-- | All operations of sub API. This is similar to
--   <tt><a>operationsOf</a></tt> but ensures that operations indeed belong
--   to the API at compile time.
subOperations :: (IsSubAPI sub api, HasOpenApi sub) => Proxy sub -> Proxy api -> Traversal' OpenApi Operation

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <i>NOTE:</i> <tt><a>validateEveryToJSON</a></tt> does not perform
--   string pattern validation. See
--   <tt><a>validateEveryToJSONWithPatternChecker</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User...
--   ...
--     UserId...
--   ...
--   Finished in ... seconds
--   ...2 examples, 0 failures...
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--   ...No instance for (Arbitrary Contact)
--   ...  arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSONWithPatternChecker</a></tt>.
--   
--   For validation without patterns see
--   <tt><a>validateEveryToJSON</a></tt>.
validateEveryToJSONWithPatternChecker :: forall proxy api. TMap (Every [Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => (Pattern -> Text -> Bool) -> proxy api -> Spec


-- | Useful type families for servant APIs.
module Servant.OpenApi.TypeLevel

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.
type family IsSubAPI sub api :: Constraint

-- | Build a list of endpoints from an API.
type family EndpointsList api

-- | Extract a list of unique "body" types for a specific content-type from
--   a servant API.
type BodyTypes c api = Nub (BodyTypes' c api)
