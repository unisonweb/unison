-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Comonads
--   
--   Comonads.
@package comonad
@version 5.0.8


module Control.Comonad

-- | There are two ways to define a comonad:
--   
--   I. Provide definitions for <a>extract</a> and <a>extend</a> satisfying
--   these laws:
--   
--   <pre>
--   <a>extend</a> <a>extract</a>      = <a>id</a>
--   <a>extract</a> . <a>extend</a> f  = f
--   <a>extend</a> f . <a>extend</a> g = <a>extend</a> (f . <a>extend</a> g)
--   </pre>
--   
--   In this case, you may simply set <a>fmap</a> = <a>liftW</a>.
--   
--   These laws are directly analogous to the laws for monads and perhaps
--   can be made clearer by viewing them as laws stating that Cokleisli
--   composition must be associative, and has extract for a unit:
--   
--   <pre>
--   f <a>=&gt;=</a> <a>extract</a>   = f
--   <a>extract</a> <a>=&gt;=</a> f   = f
--   (f <a>=&gt;=</a> g) <a>=&gt;=</a> h = f <a>=&gt;=</a> (g <a>=&gt;=</a> h)
--   </pre>
--   
--   II. Alternately, you may choose to provide definitions for
--   <a>fmap</a>, <a>extract</a>, and <a>duplicate</a> satisfying these
--   laws:
--   
--   <pre>
--   <a>extract</a> . <a>duplicate</a>      = <a>id</a>
--   <a>fmap</a> <a>extract</a> . <a>duplicate</a> = <a>id</a>
--   <a>duplicate</a> . <a>duplicate</a>    = <a>fmap</a> <a>duplicate</a> . <a>duplicate</a>
--   </pre>
--   
--   In this case you may not rely on the ability to define <a>fmap</a> in
--   terms of <a>liftW</a>.
--   
--   You may of course, choose to define both <a>duplicate</a> <i>and</i>
--   <a>extend</a>. In that case you must also satisfy these laws:
--   
--   <pre>
--   <a>extend</a> f  = <a>fmap</a> f . <a>duplicate</a>
--   <a>duplicate</a> = <a>extend</a> id
--   <a>fmap</a> f    = <a>extend</a> (f . <a>extract</a>)
--   </pre>
--   
--   These are the default definitions of <a>extend</a> and
--   <a>duplicate</a> and the definition of <a>liftW</a> respectively.
class Functor w => Comonad w

-- | <pre>
--   <a>extract</a> . <a>fmap</a> f = f . <a>extract</a>
--   </pre>
extract :: Comonad w => w a -> a

-- | <pre>
--   <a>duplicate</a> = <a>extend</a> <a>id</a>
--   <a>fmap</a> (<a>fmap</a> f) . <a>duplicate</a> = <a>duplicate</a> . <a>fmap</a> f
--   </pre>
duplicate :: Comonad w => w a -> w (w a)

-- | <pre>
--   <a>extend</a> f = <a>fmap</a> f . <a>duplicate</a>
--   </pre>
extend :: Comonad w => (w a -> b) -> w a -> w b

-- | A suitable default definition for <a>fmap</a> for a <a>Comonad</a>.
--   Promotes a function to a comonad.
--   
--   You can only safely use <a>liftW</a> to define <a>fmap</a> if your
--   <a>Comonad</a> defines <a>extend</a>, not just <a>duplicate</a>, since
--   defining <a>extend</a> in terms of duplicate uses <a>fmap</a>!
--   
--   <pre>
--   <a>fmap</a> f = <a>liftW</a> f = <a>extend</a> (f . <a>extract</a>)
--   </pre>
liftW :: Comonad w => (a -> b) -> w a -> w b

-- | Comonadic fixed point à la David Menendez
wfix :: Comonad w => w (w a -> a) -> a

-- | Comonadic fixed point à la Dominic Orchard
cfix :: Comonad w => (w a -> a) -> w a

-- | Comonadic fixed point à la Kenneth Foner:
--   
--   This is the <tt>evaluate</tt> function from his <a>"Getting a Quick
--   Fix on Comonads"</a> talk.
kfix :: ComonadApply w => w (w a -> a) -> w a

-- | Left-to-right <a>Cokleisli</a> composition
(=>=) :: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
infixr 1 =>=

-- | Right-to-left <a>Cokleisli</a> composition
(=<=) :: Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
infixr 1 =<=

-- | <a>extend</a> in operator form
(<<=) :: Comonad w => (w a -> b) -> w a -> w b
infixr 1 <<=

-- | <a>extend</a> with the arguments swapped. Dual to <a>&gt;&gt;=</a> for
--   a <a>Monad</a>.
(=>>) :: Comonad w => w a -> (w a -> b) -> w b
infixl 1 =>>

-- | <tt>ComonadApply</tt> is to <tt>Comonad</tt> like <tt>Applicative</tt>
--   is to <tt>Monad</tt>.
--   
--   Mathematically, it is a strong lax symmetric semi-monoidal comonad on
--   the category <tt>Hask</tt> of Haskell types. That it to say that
--   <tt>w</tt> is a strong lax symmetric semi-monoidal functor on Hask,
--   where both <a>extract</a> and <a>duplicate</a> are symmetric monoidal
--   natural transformations.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;@&gt;</a> v <a>&lt;@&gt;</a> w = u <a>&lt;@&gt;</a> (v <a>&lt;@&gt;</a> w)
--   <a>extract</a> (p <a>&lt;@&gt;</a> q) = <a>extract</a> p (<a>extract</a> q)
--   <a>duplicate</a> (p <a>&lt;@&gt;</a> q) = (<a>&lt;@&gt;</a>) <a>&lt;$&gt;</a> <a>duplicate</a> p <a>&lt;@&gt;</a> <a>duplicate</a> q
--   </pre>
--   
--   If our type is both a <a>ComonadApply</a> and <a>Applicative</a> we
--   further require
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = (<a>&lt;@&gt;</a>)
--   </pre>
--   
--   Finally, if you choose to define (<a>&lt;@</a>) and (<a>@&gt;</a>),
--   the results of your definitions should match the following laws:
--   
--   <pre>
--   a <a>@&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;@&gt;</a> b
--   a <a>&lt;@</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;@&gt;</a> b
--   </pre>
class Comonad w => ComonadApply w
(<@>) :: ComonadApply w => w (a -> b) -> w a -> w b
(<@>) :: (ComonadApply w, Applicative w) => w (a -> b) -> w a -> w b
(@>) :: ComonadApply w => w a -> w b -> w b
(<@) :: ComonadApply w => w a -> w b -> w a
infixl 4 <@>
infixl 4 @>
infixl 4 <@

-- | A variant of <a>&lt;@&gt;</a> with the arguments reversed.
(<@@>) :: ComonadApply w => w a -> w (a -> b) -> w b
infixl 4 <@@>

-- | Lift a binary function into a <a>Comonad</a> with zipping
liftW2 :: ComonadApply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a <a>Comonad</a> with zipping
liftW3 :: ComonadApply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | The <a>Cokleisli</a> <a>Arrow</a>s of a given <a>Comonad</a>
newtype Cokleisli w a b
Cokleisli :: (w a -> b) -> Cokleisli w a b
[runCokleisli] :: Cokleisli w a b -> w a -> b

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>
instance Control.Comonad.Comonad w => Control.Category.Category (Control.Comonad.Cokleisli w)
instance Control.Comonad.Comonad w => Control.Arrow.Arrow (Control.Comonad.Cokleisli w)
instance Control.Comonad.Comonad w => Control.Arrow.ArrowApply (Control.Comonad.Cokleisli w)
instance Control.Comonad.Comonad w => Control.Arrow.ArrowChoice (Control.Comonad.Cokleisli w)
instance Control.Comonad.ComonadApply w => Control.Arrow.ArrowLoop (Control.Comonad.Cokleisli w)
instance forall k (w :: k -> *) (a :: k). GHC.Base.Functor (Control.Comonad.Cokleisli w a)
instance forall k (w :: k -> *) (a :: k). GHC.Base.Applicative (Control.Comonad.Cokleisli w a)
instance forall k (w :: k -> *) (a :: k). GHC.Base.Monad (Control.Comonad.Cokleisli w a)
instance GHC.Base.Semigroup m => Control.Comonad.ComonadApply ((,) m)
instance Control.Comonad.ComonadApply GHC.Base.NonEmpty
instance GHC.Base.Monoid m => Control.Comonad.ComonadApply ((->) m)
instance Control.Comonad.ComonadApply Data.Functor.Identity.Identity
instance Control.Comonad.ComonadApply w => Control.Comonad.ComonadApply (Control.Monad.Trans.Identity.IdentityT w)
instance Control.Comonad.ComonadApply Data.Tree.Tree
instance Control.Comonad.Comonad ((,) e)
instance Control.Comonad.Comonad (Data.Semigroup.Arg e)
instance GHC.Base.Monoid m => Control.Comonad.Comonad ((->) m)
instance Control.Comonad.Comonad Data.Functor.Identity.Identity
instance forall k (s :: k). Control.Comonad.Comonad (Data.Tagged.Tagged s)
instance Control.Comonad.Comonad w => Control.Comonad.Comonad (Control.Monad.Trans.Identity.IdentityT w)
instance Control.Comonad.Comonad Data.Tree.Tree
instance Control.Comonad.Comonad GHC.Base.NonEmpty
instance (Control.Comonad.Comonad f, Control.Comonad.Comonad g) => Control.Comonad.Comonad (Data.Functor.Sum.Sum f g)


module Control.Comonad.Hoist.Class
class ComonadHoist t

-- | Given any comonad-homomorphism from <tt>w</tt> to <tt>v</tt> this
--   yields a comonad homomorphism from <tt>t w</tt> to <tt>t v</tt>.
cohoist :: (ComonadHoist t, Comonad w, Comonad v) => (forall x. w x -> v x) -> t w a -> t v a
instance Control.Comonad.Hoist.Class.ComonadHoist Control.Monad.Trans.Identity.IdentityT


module Control.Comonad.Trans.Class
class ComonadTrans t
lower :: (ComonadTrans t, Comonad w) => t w a -> w a
instance Control.Comonad.Trans.Class.ComonadTrans Control.Monad.Trans.Identity.IdentityT


-- | The environment comonad holds a value along with some retrievable
--   context.
--   
--   This module specifies the environment comonad transformer (aka
--   coreader), which is left adjoint to the reader comonad.
--   
--   The following sets up an experiment that retains its initial value in
--   the background:
--   
--   <pre>
--   &gt;&gt;&gt; let initial = env 0 0
--   </pre>
--   
--   Extract simply retrieves the value:
--   
--   <pre>
--   &gt;&gt;&gt; extract initial
--   0
--   </pre>
--   
--   Play around with the value, in our case producing a negative value:
--   
--   <pre>
--   &gt;&gt;&gt; let experiment = fmap (+ 10) initial
--   
--   &gt;&gt;&gt; extract experiment
--   10
--   </pre>
--   
--   Oh noes, something went wrong, 10 isn't very negative! Better restore
--   the initial value using the default:
--   
--   <pre>
--   &gt;&gt;&gt; let initialRestored = experiment =&gt;&gt; ask
--   
--   &gt;&gt;&gt; extract initialRestored
--   0
--   </pre>
module Control.Comonad.Trans.Env
type Env e = EnvT e Identity

-- | Create an Env using an environment and a value
env :: e -> a -> Env e a
runEnv :: Env e a -> (e, a)
data EnvT e w a
EnvT :: e -> w a -> EnvT e w a
runEnvT :: EnvT e w a -> (e, w a)

-- | Gets rid of the environment. This differs from <a>extract</a> in that
--   it will not continue extracting the value from the contained comonad.
lowerEnvT :: EnvT e w a -> w a

-- | Retrieves the environment.
ask :: EnvT e w a -> e

-- | Like <a>ask</a>, but modifies the resulting value with a function.
--   
--   <pre>
--   asks = f . ask
--   </pre>
asks :: (e -> f) -> EnvT e w a -> f

-- | Modifies the environment using the specified function.
local :: (e -> e') -> EnvT e w a -> EnvT e' w a
instance (Data.Data.Data e, Data.Typeable.Internal.Typeable w, Data.Data.Data (w a), Data.Data.Data a) => Data.Data.Data (Control.Comonad.Trans.Env.EnvT e w a)
instance GHC.Base.Functor w => GHC.Base.Functor (Control.Comonad.Trans.Env.EnvT e w)
instance Control.Comonad.Comonad w => Control.Comonad.Comonad (Control.Comonad.Trans.Env.EnvT e w)
instance Control.Comonad.Trans.Class.ComonadTrans (Control.Comonad.Trans.Env.EnvT e)
instance (GHC.Base.Monoid e, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Comonad.Trans.Env.EnvT e m)
instance Control.Comonad.Hoist.Class.ComonadHoist (Control.Comonad.Trans.Env.EnvT e)
instance (GHC.Base.Semigroup e, Control.Comonad.ComonadApply w) => Control.Comonad.ComonadApply (Control.Comonad.Trans.Env.EnvT e w)
instance Data.Foldable.Foldable w => Data.Foldable.Foldable (Control.Comonad.Trans.Env.EnvT e w)
instance Data.Traversable.Traversable w => Data.Traversable.Traversable (Control.Comonad.Trans.Env.EnvT e w)


module Control.Comonad.Trans.Identity

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
newtype () => IdentityT (f :: k -> Type) (a :: k)
IdentityT :: f a -> IdentityT (f :: k -> Type) (a :: k)
[runIdentityT] :: IdentityT (f :: k -> Type) (a :: k) -> f a


module Control.Comonad.Identity


-- | The store comonad holds a constant value along with a modifiable
--   <i>accessor</i> function, which maps the <i>stored value</i> to the
--   <i>focus</i>.
--   
--   This module defines the strict store (aka state-in-context/costate)
--   comonad transformer.
--   
--   <tt>stored value = (1, 5)</tt>, <tt>accessor = fst</tt>, <tt>resulting
--   focus = 1</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    let
--      storeTuple :: Store (Int, Int) Int
--      storeTuple = store fst (1, 5)
--   :}
--   </pre>
--   
--   Add something to the focus:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    let
--      addToFocus :: Int -&gt; Store (Int, Int) Int -&gt; Int
--      addToFocus x wa = x + extract wa
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     let
--       added3 :: Store (Int, Int) Int
--       added3 = extend (addToFocus 3) storeTuple
--   :}
--   </pre>
--   
--   The focus of added3 is now <tt>1 + 3 = 4</tt>. However, this action
--   changed only the accessor function and therefore the focus but not the
--   stored value:
--   
--   <pre>
--   &gt;&gt;&gt; pos added3
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extract added3
--   4
--   </pre>
--   
--   The strict store (state-in-context/costate) comonad transformer is
--   subject to the laws:
--   
--   <pre>
--   x = seek (pos x) x
--   y = pos (seek y x)
--   seek y x = seek y (seek z x)
--   </pre>
--   
--   Thanks go to Russell O'Connor and Daniel Peebles for their help
--   formulating and proving the laws for this comonad transformer.
module Control.Comonad.Trans.Store
type Store s = StoreT s Identity

-- | Create a Store using an accessor function and a stored value
store :: (s -> a) -> s -> Store s a
runStore :: Store s a -> (s -> a, s)
data StoreT s w a
StoreT :: w (s -> a) -> s -> StoreT s w a
runStoreT :: StoreT s w a -> (w (s -> a), s)

-- | Read the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos $ store fst (1,5)
--   (1,5)
--   </pre>
pos :: StoreT s w a -> s

-- | Set the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos . seek (3,7) $ store fst (1,5)
--   (3,7)
--   </pre>
--   
--   Seek satisfies the law
--   
--   <pre>
--   seek s = peek s . duplicate
--   </pre>
seek :: s -> StoreT s w a -> StoreT s w a

-- | Modify the stored value
--   
--   <pre>
--   &gt;&gt;&gt; pos . seeks swap $ store fst (1,5)
--   (5,1)
--   </pre>
--   
--   Seeks satisfies the law
--   
--   <pre>
--   seeks f = peeks f . duplicate
--   </pre>
seeks :: (s -> s) -> StoreT s w a -> StoreT s w a

-- | Peek at what the current focus would be for a different stored value
--   
--   Peek satisfies the law
--   
--   <pre>
--   peek x . extend (peek y) = peek y
--   </pre>
peek :: Comonad w => s -> StoreT s w a -> a

-- | Peek at what the current focus would be if the stored value was
--   modified by some function
peeks :: Comonad w => (s -> s) -> StoreT s w a -> a

-- | Applies a functor-valued function to the stored value, and then uses
--   the new accessor to read the resulting focus.
--   
--   <pre>
--   &gt;&gt;&gt; let f x = if x &gt; 0 then Just (x^2) else Nothing
--   
--   &gt;&gt;&gt; experiment f $ store (+1) 2
--   Just 5
--   
--   &gt;&gt;&gt; experiment f $ store (+1) (-2)
--   Nothing
--   </pre>
experiment :: (Comonad w, Functor f) => (s -> f s) -> StoreT s w a -> f a
instance GHC.Base.Functor w => GHC.Base.Functor (Control.Comonad.Trans.Store.StoreT s w)
instance (Control.Comonad.ComonadApply w, GHC.Base.Semigroup s) => Control.Comonad.ComonadApply (Control.Comonad.Trans.Store.StoreT s w)
instance (GHC.Base.Applicative w, GHC.Base.Monoid s) => GHC.Base.Applicative (Control.Comonad.Trans.Store.StoreT s w)
instance Control.Comonad.Comonad w => Control.Comonad.Comonad (Control.Comonad.Trans.Store.StoreT s w)
instance Control.Comonad.Trans.Class.ComonadTrans (Control.Comonad.Trans.Store.StoreT s)
instance Control.Comonad.Hoist.Class.ComonadHoist (Control.Comonad.Trans.Store.StoreT s)


-- | The trace comonad builds up a result by prepending monoidal values to
--   each other.
--   
--   This module specifies the traced comonad transformer (aka the cowriter
--   or exponential comonad transformer).
module Control.Comonad.Trans.Traced
type Traced m = TracedT m Identity
traced :: (m -> a) -> Traced m a
runTraced :: Traced m a -> m -> a
newtype TracedT m w a
TracedT :: w (m -> a) -> TracedT m w a
[runTracedT] :: TracedT m w a -> w (m -> a)
trace :: Comonad w => m -> TracedT m w a -> a
listen :: Functor w => TracedT m w a -> TracedT m w (a, m)
listens :: Functor w => (m -> b) -> TracedT m w a -> TracedT m w (a, b)
censor :: Functor w => (m -> m) -> TracedT m w a -> TracedT m w a
instance GHC.Base.Functor w => GHC.Base.Functor (Control.Comonad.Trans.Traced.TracedT m w)
instance (Control.Comonad.ComonadApply w, GHC.Base.Monoid m) => Control.Comonad.ComonadApply (Control.Comonad.Trans.Traced.TracedT m w)
instance GHC.Base.Applicative w => GHC.Base.Applicative (Control.Comonad.Trans.Traced.TracedT m w)
instance (Control.Comonad.Comonad w, GHC.Base.Monoid m) => Control.Comonad.Comonad (Control.Comonad.Trans.Traced.TracedT m w)
instance GHC.Base.Monoid m => Control.Comonad.Trans.Class.ComonadTrans (Control.Comonad.Trans.Traced.TracedT m)
instance Control.Comonad.Hoist.Class.ComonadHoist (Control.Comonad.Trans.Traced.TracedT m)
instance Data.Distributive.Distributive w => Data.Distributive.Distributive (Control.Comonad.Trans.Traced.TracedT m w)
instance WithIndex.FunctorWithIndex i w => WithIndex.FunctorWithIndex (s, i) (Control.Comonad.Trans.Traced.TracedT s w)


module Control.Comonad.Traced.Class
class Comonad w => ComonadTraced m w | w -> m
trace :: ComonadTraced m w => m -> w a -> a
traces :: ComonadTraced m w => (a -> m) -> w a -> a
instance (Control.Comonad.Comonad w, GHC.Base.Monoid m) => Control.Comonad.Traced.Class.ComonadTraced m (Control.Comonad.Trans.Traced.TracedT m w)
instance GHC.Base.Monoid m => Control.Comonad.Traced.Class.ComonadTraced m ((->) m)
instance Control.Comonad.Traced.Class.ComonadTraced m w => Control.Comonad.Traced.Class.ComonadTraced m (Control.Monad.Trans.Identity.IdentityT w)
instance Control.Comonad.Traced.Class.ComonadTraced m w => Control.Comonad.Traced.Class.ComonadTraced m (Control.Comonad.Trans.Env.EnvT e w)
instance Control.Comonad.Traced.Class.ComonadTraced m w => Control.Comonad.Traced.Class.ComonadTraced m (Control.Comonad.Trans.Store.StoreT s w)


module Control.Comonad.Traced
class Comonad w => ComonadTraced m w | w -> m
trace :: ComonadTraced m w => m -> w a -> a
traces :: ComonadTraced m w => (a -> m) -> w a -> a
type Traced m = TracedT m Identity
traced :: (m -> a) -> Traced m a
runTraced :: Traced m a -> m -> a
newtype TracedT m w a
TracedT :: w (m -> a) -> TracedT m w a
[runTracedT] :: TracedT m w a -> w (m -> a)


module Control.Comonad.Store.Class
class Comonad w => ComonadStore s w | w -> s
pos :: ComonadStore s w => w a -> s
peek :: ComonadStore s w => s -> w a -> a
peeks :: ComonadStore s w => (s -> s) -> w a -> a
seek :: ComonadStore s w => s -> w a -> w a
seeks :: ComonadStore s w => (s -> s) -> w a -> w a
experiment :: (ComonadStore s w, Functor f) => (s -> f s) -> w a -> f a
lowerPos :: (ComonadTrans t, ComonadStore s w) => t w a -> s
lowerPeek :: (ComonadTrans t, ComonadStore s w) => s -> t w a -> a
instance Control.Comonad.Comonad w => Control.Comonad.Store.Class.ComonadStore s (Control.Comonad.Trans.Store.StoreT s w)
instance Control.Comonad.Store.Class.ComonadStore s w => Control.Comonad.Store.Class.ComonadStore s (Control.Monad.Trans.Identity.IdentityT w)
instance Control.Comonad.Store.Class.ComonadStore s w => Control.Comonad.Store.Class.ComonadStore s (Control.Comonad.Trans.Env.EnvT e w)
instance (Control.Comonad.Store.Class.ComonadStore s w, GHC.Base.Monoid m) => Control.Comonad.Store.Class.ComonadStore s (Control.Comonad.Trans.Traced.TracedT m w)


module Control.Comonad.Store
class Comonad w => ComonadStore s w | w -> s
pos :: ComonadStore s w => w a -> s
peek :: ComonadStore s w => s -> w a -> a
peeks :: ComonadStore s w => (s -> s) -> w a -> a
seek :: ComonadStore s w => s -> w a -> w a
seeks :: ComonadStore s w => (s -> s) -> w a -> w a
experiment :: (ComonadStore s w, Functor f) => (s -> f s) -> w a -> f a
type Store s = StoreT s Identity

-- | Create a Store using an accessor function and a stored value
store :: (s -> a) -> s -> Store s a
runStore :: Store s a -> (s -> a, s)
data StoreT s w a
StoreT :: w (s -> a) -> s -> StoreT s w a
runStoreT :: StoreT s w a -> (w (s -> a), s)


module Control.Comonad.Env.Class
class Comonad w => ComonadEnv e w | w -> e
ask :: ComonadEnv e w => w a -> e
asks :: ComonadEnv e w => (e -> e') -> w a -> e'
instance Control.Comonad.Comonad w => Control.Comonad.Env.Class.ComonadEnv e (Control.Comonad.Trans.Env.EnvT e w)
instance Control.Comonad.Env.Class.ComonadEnv e ((,) e)
instance Control.Comonad.Env.Class.ComonadEnv e (Data.Semigroup.Arg e)
instance Control.Comonad.Env.Class.ComonadEnv e w => Control.Comonad.Env.Class.ComonadEnv e (Control.Comonad.Trans.Store.StoreT t w)
instance Control.Comonad.Env.Class.ComonadEnv e w => Control.Comonad.Env.Class.ComonadEnv e (Control.Monad.Trans.Identity.IdentityT w)
instance (Control.Comonad.Env.Class.ComonadEnv e w, GHC.Base.Monoid m) => Control.Comonad.Env.Class.ComonadEnv e (Control.Comonad.Trans.Traced.TracedT m w)


-- | The Env comonad (aka the Coreader, Environment, or Product comonad)
--   
--   A co-Kleisli arrow in the Env comonad is isomorphic to a Kleisli arrow
--   in the reader monad.
--   
--   (a -&gt; e -&gt; m) ~ (a, e) -&gt; m ~ Env e a -&gt; m
module Control.Comonad.Env
class Comonad w => ComonadEnv e w | w -> e
ask :: ComonadEnv e w => w a -> e
asks :: ComonadEnv e w => (e -> e') -> w a -> e'

-- | Modifies the environment using the specified function.
local :: (e -> e') -> EnvT e w a -> EnvT e' w a
type Env e = EnvT e Identity

-- | Create an Env using an environment and a value
env :: e -> a -> Env e a
runEnv :: Env e a -> (e, a)
data EnvT e w a
EnvT :: e -> w a -> EnvT e w a
runEnvT :: EnvT e w a -> (e, w a)

module Data.Functor.Composition

-- | We often need to distinguish between various forms of Functor-like
--   composition in Haskell in order to please the type system. This lets
--   us work with these representations uniformly.
class Composition o
decompose :: Composition o => o f g x -> f (g x)
compose :: Composition o => f (g x) -> o f g x
instance Data.Functor.Composition.Composition Data.Functor.Compose.Compose
