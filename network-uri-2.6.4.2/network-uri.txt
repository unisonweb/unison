-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | URI manipulation
--   
--   This package provides facilities for parsing and unparsing URIs, and
--   creating and resolving relative URI references, closely following the
--   URI spec, <a>IETF RFC 3986</a>.
--   
--   <h2>Backward-compatibility</h2>
--   
--   In <tt>network-2.6</tt> the <a>Network.URI</a> module was split off
--   from the <tt>network</tt> package into this package. If you're using
--   the <a>Network.URI</a> module you can be backward compatible and
--   automatically get it from the right package by using the
--   <a>network-uri-flag pseudo-package</a> in your <tt>.cabal</tt> file's
--   build-depends (along with dependencies for both <tt>network-uri</tt>
--   and <tt>network</tt>):
--   
--   <pre>
--   build-depends:
--      network-uri-flag == 0.1.*
--   </pre>
--   
--   Or you can do the same manually by adding this boilerplate to your
--   <tt>.cabal</tt> file:
--   
--   <pre>
--   flag network-uri
--     description: Get Network.URI from the network-uri package
--     default: True
--   
--   library
--     -- ...
--     if flag(network-uri)
--       build-depends: network-uri &gt;= 2.6, network &gt;= 2.6
--     else
--       build-depends: network-uri &lt; 2.6, network &lt; 2.6
--   </pre>
--   
--   That is, get the module from either <tt>network &lt; 2.6</tt> or from
--   <tt>network-uri &gt;= 2.6</tt>.
@package network-uri
@version 2.6.4.2


-- | This module defines functions for handling URIs. It presents
--   substantially the same interface as the older GHC Network.URI module,
--   but is implemented using Parsec rather than a Regex library that is
--   not available with Hugs. The internal representation of URI has been
--   changed so that URI strings are more completely preserved when
--   round-tripping to a URI value and back.
--   
--   In addition, four methods are provided for parsing different kinds of
--   URI string (as noted in RFC3986): <a>parseURI</a>,
--   <a>parseURIReference</a>, <a>parseRelativeReference</a> and
--   <a>parseAbsoluteURI</a>.
--   
--   Further, four methods are provided for classifying different kinds of
--   URI string (as noted in RFC3986): <a>isURI</a>, <a>isURIReference</a>,
--   <a>isRelativeReference</a> and <a>isAbsoluteURI</a>.
--   
--   The long-standing official reference for URI handling was RFC2396 [1],
--   as updated by RFC 2732 [2], but this was replaced by a new
--   specification, RFC3986 [3] in January 2005. This latter specification
--   has been used as the primary reference for constructing the URI parser
--   implemented here, and it is intended that there is a direct
--   relationship between the syntax definition in that document and this
--   parser implementation.
--   
--   RFC 1808 [4] contains a number of test cases for relative URI
--   handling. Dan Connolly's Python module <tt>uripath.py</tt> [5] also
--   contains useful details and test cases.
--   
--   Some of the code has been copied from the previous GHC implementation,
--   but the parser is replaced with one that performs more complete syntax
--   checking of the URI itself, according to RFC3986 [3].
--   
--   References
--   
--   <ol>
--   <li><a>http://www.ietf.org/rfc/rfc2396.txt</a></li>
--   <li><a>http://www.ietf.org/rfc/rfc2732.txt</a></li>
--   <li><a>http://www.ietf.org/rfc/rfc3986.txt</a></li>
--   <li><a>http://www.ietf.org/rfc/rfc1808.txt</a></li>
--   <li><a>http://www.w3.org/2000/10/swap/uripath.py</a></li>
--   </ol>
module Network.URI

-- | Represents a general universal resource identifier using its component
--   parts.
--   
--   For example, for the URI
--   
--   <pre>
--   foo://anonymous@www.haskell.org:42/ghc?query#frag
--   </pre>
--   
--   the components are:
data URI
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI

-- | <pre>
--   foo:
--   </pre>
[uriScheme] :: URI -> String

-- | <pre>
--   //anonymous@www.haskell.org:42
--   </pre>
[uriAuthority] :: URI -> Maybe URIAuth

-- | <pre>
--   /ghc
--   </pre>
[uriPath] :: URI -> String

-- | <pre>
--   ?query
--   </pre>
[uriQuery] :: URI -> String

-- | <pre>
--   #frag
--   </pre>
[uriFragment] :: URI -> String

-- | Type for authority value within a URI
data URIAuth
URIAuth :: String -> String -> String -> URIAuth

-- | <pre>
--   anonymous@
--   </pre>
[uriUserInfo] :: URIAuth -> String

-- | <pre>
--   www.haskell.org
--   </pre>
[uriRegName] :: URIAuth -> String

-- | <pre>
--   :42
--   </pre>
[uriPort] :: URIAuth -> String

-- | Blank URI
nullURI :: URI

-- | Blank URIAuth.
nullURIAuth :: URIAuth

-- | Given a URI in "nonstandard" form (lacking required separator
--   characters), return one that is standard.
rectify :: URI -> URI

-- | Given a URIAuth in "nonstandard" form (lacking required separator
--   characters), return one that is standard.
rectifyAuth :: URIAuth -> URIAuth

-- | Turn a string containing a URI into a <a>URI</a>. Returns
--   <a>Nothing</a> if the string is not a valid URI; (an absolute URI with
--   optional fragment identifier).
--   
--   NOTE: this is different from the previous network.URI, whose
--   <tt>parseURI</tt> function works like <a>parseURIReference</a> in this
--   module.
parseURI :: String -> Maybe URI

-- | Parse a URI reference to a <a>URI</a> value. Returns <a>Nothing</a> if
--   the string is not a valid URI reference. (an absolute or relative URI
--   with optional fragment identifier).
parseURIReference :: String -> Maybe URI

-- | Parse a relative URI to a <a>URI</a> value. Returns <a>Nothing</a> if
--   the string is not a valid relative URI. (a relative URI with optional
--   fragment identifier).
parseRelativeReference :: String -> Maybe URI

-- | Parse an absolute URI to a <a>URI</a> value. Returns <a>Nothing</a> if
--   the string is not a valid absolute URI. (an absolute URI without a
--   fragment identifier).
parseAbsoluteURI :: String -> Maybe URI

-- | Test if string contains a valid URI (an absolute URI with optional
--   fragment identifier).
isURI :: String -> Bool

-- | Test if string contains a valid URI reference (an absolute or relative
--   URI with optional fragment identifier).
isURIReference :: String -> Bool

-- | Test if string contains a valid relative URI (a relative URI with
--   optional fragment identifier).
isRelativeReference :: String -> Bool

-- | Test if string contains a valid absolute URI (an absolute URI without
--   a fragment identifier).
isAbsoluteURI :: String -> Bool

-- | Test if string contains a valid IPv6 address
isIPv6address :: String -> Bool

-- | Test if string contains a valid IPv4 address
isIPv4address :: String -> Bool
uriIsAbsolute :: URI -> Bool
uriIsRelative :: URI -> Bool

-- | Returns a new <a>URI</a> which represents the value of the first
--   <a>URI</a> interpreted as relative to the second <a>URI</a>.
--   
--   Algorithm from RFC3986 [3], section 5.2
relativeTo :: URI -> URI -> URI

-- | Returns a new <a>URI</a> which represents the value of the first
--   <a>URI</a> interpreted as relative to the second <a>URI</a>. For
--   example:
--   
--   <pre>
--   "foo" `relativeTo` "http://bar.org/" = "http://bar.org/foo"
--   "http:foo" `nonStrictRelativeTo` "http://bar.org/" = "http://bar.org/foo"
--   </pre>
--   
--   Algorithm from RFC3986 [3], section 5.2.2
nonStrictRelativeTo :: URI -> URI -> URI

-- | Returns a new <a>URI</a> which represents the relative location of the
--   first <a>URI</a> with respect to the second <a>URI</a>. Thus, the
--   values supplied are expected to be absolute URIs, and the result
--   returned may be a relative URI.
--   
--   Example:
--   
--   <pre>
--   "http://example.com/Root/sub1/name2#frag"
--     `relativeFrom` "http://example.com/Root/sub2/name2#frag"
--     == "../sub1/name2#frag"
--   </pre>
--   
--   There is no single correct implementation of this function, but any
--   acceptable implementation must satisfy the following:
--   
--   <pre>
--   (uabs `relativeFrom` ubase) `relativeTo` ubase == uabs
--   </pre>
--   
--   For any valid absolute URI. (cf.
--   <a>http://lists.w3.org/Archives/Public/uri/2003Jan/0008.html</a>
--   <a>http://lists.w3.org/Archives/Public/uri/2003Jan/0005.html</a>)
relativeFrom :: URI -> URI -> URI

-- | Turn a <a>URI</a> into a string.
--   
--   Uses a supplied function to map the userinfo part of the URI.
--   
--   The Show instance for URI uses a mapping that hides any password that
--   may be present in the URI. Use this function with argument <tt>id</tt>
--   to preserve the password in the formatted output.
uriToString :: (String -> String) -> URI -> ShowS
uriAuthToString :: (String -> String) -> Maybe URIAuth -> ShowS

-- | Returns <a>True</a> if the character is a "reserved" character in a
--   URI. To include a literal instance of one of these characters in a
--   component of a URI, it must be escaped.
isReserved :: Char -> Bool

-- | Returns <a>True</a> if the character is an "unreserved" character in a
--   URI. These characters do not need to be escaped in a URI. The only
--   characters allowed in a URI are either "reserved", "unreserved", or an
--   escape sequence (<tt>%</tt> followed by two hex digits).
isUnreserved :: Char -> Bool

-- | Returns <a>True</a> if the character is allowed in a URI.
isAllowedInURI :: Char -> Bool

-- | Returns <a>True</a> if the character is allowed unescaped in a URI.
--   
--   <pre>
--   &gt;&gt;&gt; escapeURIString isUnescapedInURI "http://haskell.org:80?some_param=true&amp;other_param=їґ"
--   "http://haskell.org:80?some_param=true&amp;other_param=%D1%97%D2%91"
--   </pre>
isUnescapedInURI :: Char -> Bool

-- | Returns <a>True</a> if the character is allowed unescaped in a URI
--   component.
--   
--   <pre>
--   &gt;&gt;&gt; escapeURIString isUnescapedInURIComponent "http://haskell.org:80?some_param=true&amp;other_param=їґ"
--   "http%3A%2F%2Fhaskell.org%3A80%3Fsome_param%3Dtrue%26other_param%3D%D1%97%D2%91"
--   </pre>
isUnescapedInURIComponent :: Char -> Bool

-- | Escape character if supplied predicate is not satisfied, otherwise
--   return character as singleton string.
escapeURIChar :: (Char -> Bool) -> Char -> String

-- | Can be used to make a string valid for use in a URI.
escapeURIString :: (Char -> Bool) -> String -> String

-- | Turns all instances of escaped characters in the string back into
--   literal characters.
unEscapeString :: String -> String

-- | Returns the segments of the path component. E.g., pathSegments
--   <a>$</a> parseURI "<a>http://example.org/foo/bar/baz"</a> == ["foo",
--   "bar", "baz"]
pathSegments :: URI -> [String]

-- | Case normalization; cf. RFC3986 section 6.2.2.1 NOTE: authority case
--   normalization is not performed
normalizeCase :: String -> String

-- | Encoding normalization; cf. RFC3986 section 6.2.2.2
normalizeEscape :: String -> String

-- | Path segment normalization; cf. RFC3986 section 6.2.2.3
normalizePathSegments :: String -> String

-- | <i>Deprecated: use parseAbsoluteURI</i>
parseabsoluteURI :: String -> Maybe URI

-- | <i>Deprecated: use escapeURIString, and note the flipped arguments</i>
escapeString :: String -> (Char -> Bool) -> String

-- | <i>Deprecated: use isReserved</i>
reserved :: Char -> Bool

-- | <i>Deprecated: use isUnreserved</i>
unreserved :: Char -> Bool

-- | <i>Deprecated: use uriScheme</i>
scheme :: URI -> String

-- | <i>Deprecated: use uriAuthority, and note changed functionality</i>
authority :: URI -> String

-- | <i>Deprecated: use uriPath</i>
path :: URI -> String

-- | <i>Deprecated: use uriQuery, and note changed functionality</i>
query :: URI -> String

-- | <i>Deprecated: use uriFragment, and note changed functionality</i>
fragment :: URI -> String
instance GHC.Generics.Generic Network.URI.URIAuth
instance Data.Data.Data Network.URI.URIAuth
instance GHC.Show.Show Network.URI.URIAuth
instance GHC.Classes.Ord Network.URI.URIAuth
instance GHC.Classes.Eq Network.URI.URIAuth
instance GHC.Generics.Generic Network.URI.URI
instance Data.Data.Data Network.URI.URI
instance GHC.Classes.Ord Network.URI.URI
instance GHC.Classes.Eq Network.URI.URI
instance Language.Haskell.TH.Syntax.Lift Network.URI.URI
instance Language.Haskell.TH.Syntax.Lift Network.URI.URIAuth
instance Control.DeepSeq.NFData Network.URI.URI
instance GHC.Show.Show Network.URI.URI
instance Control.DeepSeq.NFData Network.URI.URIAuth


-- | Network uri lenses
module Network.URI.Lens
uriRegNameLens :: Lens' URIAuth String
uriUserInfoLens :: Lens' URIAuth String
uriPortLens :: Lens' URIAuth String
uriAuthorityLens :: Lens' URI (Maybe URIAuth)
uriSchemeLens :: Lens' URI String
uriPathLens :: Lens' URI String
uriQueryLens :: Lens' URI String
uriFragmentLens :: Lens' URI String

module Network.URI.Static

-- | <a>uri</a> is a quasi quoter for <a>staticURI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [uri|http://www.google.com/|]
--   http://www.google.com/
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [uri|http://www.google.com/##|]
--   
--   &lt;interactive&gt;...
--   ... Invalid URI: http://www.google.com/##
--   ...
--   </pre>
uri :: QuasiQuoter

-- | <a>staticURI</a> parses a specified string at compile time and return
--   an expression representing the URI when it's a valid URI. Otherwise,
--   it emits an error.
--   
--   <pre>
--   &gt;&gt;&gt; $$(staticURI "http://www.google.com/")
--   http://www.google.com/
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; $$(staticURI "http://www.google.com/##")
--   
--   &lt;interactive&gt;...
--   ... Invalid URI: http://www.google.com/##
--   ...
--   </pre>
staticURI :: String -> SpliceQ URI

-- | <a>staticURI'</a> parses a specified string at compile time.
--   
--   The typed template haskell <a>staticURI</a> is available only with
--   GHC-7.8+.
staticURI' :: String -> ExpQ

-- | <a>relativeReference</a> is a quasi quoter for
--   <a>staticRelativeReference</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [relativeReference|/foo?bar=baz#quux|]
--   /foo?bar=baz#quux
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [relativeReference|http://www.google.com/|]
--   
--   &lt;interactive&gt;...
--   ... Invalid relative reference: http://www.google.com/
--   ...
--   </pre>
relativeReference :: QuasiQuoter

-- | <a>staticRelativeReference</a> parses a specified string at compile
--   time and return an expression representing the URI when it's a valid
--   relative reference. Otherwise, it emits an error.
--   
--   <pre>
--   &gt;&gt;&gt; $$(staticRelativeReference "/foo?bar=baz#quux")
--   /foo?bar=baz#quux
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; $$(staticRelativeReference "http://www.google.com/")
--   
--   &lt;interactive&gt;...
--   ... Invalid relative reference: http://www.google.com/
--   ...
--   </pre>
staticRelativeReference :: String -> SpliceQ URI

-- | <a>staticRelativeReference'</a> parses a specified string at compile
--   time and return an expression representing the URI when it's a valid
--   relative reference. Otherwise, it emits an error.
--   
--   The typed template haskell <a>staticRelativeReference</a> is available
--   only with GHC-7.8+.
staticRelativeReference' :: String -> ExpQ
