-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Non-empty vectors
--   
--   Performant, non-empty mutable and immutable vectors
@package nonempty-vector
@version 0.2.3


-- | Internal module exposing the constructors for <a>NonEmptyVector</a>
--   and <a>NonEmptyMVector</a>.
--   
--   <i>Warning</i>: Since the constructors are exposed here, by using this
--   module, you take on the risks that you break the non-emptiness
--   invariants of the main modules. Use at your own risk.
module Data.Vector.NonEmpty.Internal

-- | <a>NonEmptyVector</a> is a thin wrapper around <tt>Vector</tt> that
--   witnesses an API requiring non-empty construction, initialization, and
--   generation of non-empty vectors by design.
--   
--   A newtype wrapper was chosen so that no new pointer indirection is
--   introduced when working with <tt>Vector</tt>s, and all performance
--   characteristics inherited from the <tt>Vector</tt> API still apply.
newtype NonEmptyVector a
NonEmptyVector :: Vector a -> NonEmptyVector a
[_neVec] :: NonEmptyVector a -> Vector a

-- | <a>NonEmptyMVector</a> is a thin wrapper around <a>MVector</a> that
--   witnesses an API requiring non-empty construction, initialization, and
--   generation of non-empty vectors by design.
--   
--   A newtype wrapper was chosen so that no new pointer indirection is
--   introduced when working with <a>MVector</a>s, and all performance
--   characteristics inherited from the <a>MVector</a> API still apply.
newtype NonEmptyMVector s a
NonEmptyMVector :: MVector s a -> NonEmptyMVector s a
[_nemVec] :: NonEmptyMVector s a -> MVector s a

-- | <a>NonEmptyMVector</a> parametrized by <tt>PrimState</tt>
type NonEmptyIOVector = NonEmptyMVector RealWorld

-- | <a>NonEmptyMVector</a> parametrized by <a>ST</a>
type NonEmptySTVector s = NonEmptyMVector s
instance GHC.Base.Semigroup (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance Control.Monad.Zip.MonadZip Data.Vector.NonEmpty.Internal.NonEmptyVector
instance GHC.Base.Monad Data.Vector.NonEmpty.Internal.NonEmptyVector
instance GHC.Base.Applicative Data.Vector.NonEmpty.Internal.NonEmptyVector
instance GHC.Base.Functor Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance Data.Data.Data a => Data.Data.Data (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance Data.Functor.Classes.Show1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Data.Functor.Classes.Ord1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Data.Functor.Classes.Eq1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Vector.NonEmpty.Internal.NonEmptyVector a)
instance Data.Functor.Classes.Read1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Data.Foldable.Foldable Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Data.Foldable1.Foldable1 Data.Vector.NonEmpty.Internal.NonEmptyVector
instance Data.Traversable.Traversable Data.Vector.NonEmpty.Internal.NonEmptyVector


-- | A library for non-empty boxed vectors (that is, polymorphic arrays
--   capable of holding any Haskell value). Non-empty vectors come in two
--   flavors:
--   
--   <ul>
--   <li>mutable</li>
--   <li>immutable</li>
--   </ul>
--   
--   This library attempts to provide support for all standard
--   <a>Vector</a> operations in the API, with some slight variation in
--   types and implementation. For example, since <a>head</a> and
--   <a>foldr</a> are always gauranteed to be over a non-empty
--   <a>Vector</a>, it is safe to make use of the 'unsafe-*' <a>Vector</a>
--   operations and semigroupal folds available in the API in lieu of the
--   standard implementations.
--   
--   In contrast, some operations such as <a>filter</a> may "break out" of
--   a <a>NonEmptyVector</a> due to the fact that there are no guarantees
--   that may be made on the types of <a>Bool</a>-valued functions passed
--   in, hence one could write the following:
--   
--   <pre>
--   filter (const false) v
--   </pre>
--   
--   which always produces an empty vector. Thus, some operations must
--   return either a <a>Maybe</a> containing a <a>NonEmptyVector</a> or a
--   <a>Vector</a> whenever appropriate. Generally The former is used in
--   initialization and generation operations, and the latter is used in
--   iterative operations where the intent is not to create an instance of
--   <a>NonEmptyVector</a>.
--   
--   Credit to Roman Leshchinskiy for the original Vector library upon
--   which this is based.
module Data.Vector.NonEmpty

-- | <a>NonEmptyVector</a> is a thin wrapper around <tt>Vector</tt> that
--   witnesses an API requiring non-empty construction, initialization, and
--   generation of non-empty vectors by design.
--   
--   A newtype wrapper was chosen so that no new pointer indirection is
--   introduced when working with <tt>Vector</tt>s, and all performance
--   characteristics inherited from the <tt>Vector</tt> API still apply.
data NonEmptyVector a

-- | <i>O(1)</i> Length.
--   
--   <pre>
--   &gt;&gt;&gt; length $ unsafeFromList [1..10]
--   10
--   </pre>
length :: NonEmptyVector a -> Int

-- | <i>O(1)</i> First element. Since head is gauranteed, bounds checks are
--   bypassed by deferring to <tt>unsafeHead</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; head $ unsafeFromList [1..10]
--   1
--   </pre>
head :: NonEmptyVector a -> a

-- | <i>O(1)</i> Last element. Since a last element is gauranteed, bounds
--   checks are bypassed by deferring to <tt>unsafeLast</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; last $ unsafeFromList [1..10]
--   10
--   </pre>
last :: NonEmptyVector a -> a

-- | <i>O(1)</i> Indexing.
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [1..10]) ! 0
--   1
--   </pre>
(!) :: NonEmptyVector a -> Int -> a

-- | <i>O(1)</i> Safe indexing.
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [1..10]) !? 0
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [1..10]) !? 11
--   Nothing
--   </pre>
(!?) :: NonEmptyVector a -> Int -> Maybe a

-- | <i>O(1)</i> Unsafe indexing without bounds checking
unsafeIndex :: NonEmptyVector a -> Int -> a

-- | <i>O(1)</i> First element of a non-empty vector in a monad.
--   
--   See <a>indexM</a> for an explanation of why this is useful.
--   
--   Note that this function defers to <tt>unsafeHeadM</tt> since head is
--   gauranteed to be safe by construction.
--   
--   <pre>
--   &gt;&gt;&gt; headM @[] (unsafeFromList [1..10])
--   [1]
--   </pre>
headM :: Monad m => NonEmptyVector a -> m a

-- | <i>O(1)</i> Last element of a non-empty vector in a monad. See
--   <a>indexM</a> for an explanation of why this is useful.
--   
--   Note that this function defers to <tt>unsafeHeadM</tt> since a last
--   element is gauranteed.
--   
--   <pre>
--   &gt;&gt;&gt; lastM @[] (unsafeFromList [1..10])
--   [10]
--   </pre>
lastM :: Monad m => NonEmptyVector a -> m a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the non-empty vector when
--   necessary.
--   
--   See <a>indexM</a> for more details
--   
--   <pre>
--   &gt;&gt;&gt; indexM @[] (unsafeFromList [1..10]) 3
--   [4]
--   </pre>
indexM :: Monad m => NonEmptyVector a -> Int -> m a

-- | O(1) Indexing in a monad without bounds checks. See <a>indexM</a> for
--   an explanation of why this is useful.
unsafeIndexM :: Monad m => NonEmptyVector a -> Int -> m a

-- | <i>O(1)</i> Yield all but the first element without copying. Since the
--   vector returned may be empty (i.e. input was a singleton), this
--   function returns a normal <a>Vector</a>
--   
--   <pre>
--   &gt;&gt;&gt; tail (unsafeFromList [1..10])
--   [2,3,4,5,6,7,8,9,10]
--   </pre>
tail :: NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield a slice of the non-empty vector without copying it.
--   The vector must contain at least i+n elements. Because this is not
--   guaranteed, this function returns a <a>Vector</a> which could be empty
--   
--   <pre>
--   &gt;&gt;&gt; slice 0 3 (unsafeFromList [1..10])
--   [1,2,3]
--   </pre>
slice :: Int -> Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. Since the
--   vector returned may be empty (i.e. input was a singleton), this
--   function returns a normal <a>Vector</a>
--   
--   <pre>
--   &gt;&gt;&gt; init (unsafeFromList [1..3])
--   [1,2]
--   </pre>
init :: NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield at the first n elements without copying. The
--   non-empty vector may contain less than n elements in which case it is
--   returned as a vector unchanged.
--   
--   <pre>
--   &gt;&gt;&gt; take 2 (unsafeFromList [1..3])
--   [1,2]
--   </pre>
take :: Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield all but the first n elements without copying. The
--   non-empty vector may contain less than n elements in which case an
--   empty vector is returned.
--   
--   <pre>
--   &gt;&gt;&gt; drop 2 (unsafeFromList [1..3])
--   [3]
--   </pre>
drop :: Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield a slice of a non-empty vector without copying at the
--   <tt>0</tt>th and <tt>1</tt>st indices.
--   
--   <pre>
--   &gt;&gt;&gt; uncons (unsafeFromList [1..10])
--   (1,[2,3,4,5,6,7,8,9,10])
--   </pre>
uncons :: NonEmptyVector a -> (a, Vector a)

-- | <i>O(1)</i> Yield a slice of a non-empty vector without copying at the
--   <tt>n-1</tt>th and <tt>nth</tt> indices
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (unsafeFromList [1..10])
--   ([1,2,3,4,5,6,7,8,9],10)
--   </pre>
unsnoc :: NonEmptyVector a -> (Vector a, a)

-- | <i>O(1)</i> Yield the first n elements paired with the remainder
--   without copying.
--   
--   This function returns a pair of vectors, as one may slice a (0, n+1).
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 2 (unsafeFromList [1..3])
--   ([1,2],[3])
--   </pre>
splitAt :: Int -> NonEmptyVector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least i+n elements but this is not checked.
unsafeSlice :: Int -> Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield the first n elements without copying. The vector
--   must contain at least n elements but this is not checked.
unsafeTake :: Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Yield all but the first n elements without copying. The
--   vector must contain at least n elements but this is not checked.
unsafeDrop :: Int -> NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Non-empty vector with exactly one element
--   
--   <pre>
--   &gt;&gt;&gt; singleton "a"
--   ["a"]
--   </pre>
singleton :: a -> NonEmptyVector a

-- | <i>O(n)</i> Non-empty vector of the given length with the same value
--   in each position.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 3 "a"
--   Just ["a","a","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 "a"
--   Nothing
--   </pre>
replicate :: Int -> a -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Non-empty vector of the given length with the same value
--   in each position.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 3 "a"
--   ["a","a","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 0 "a"
--   ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1 (-1) "a"
--   ["a"]
--   </pre>
replicate1 :: Int -> a -> NonEmptyVector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 1 f
--   Just ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 0 f
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate 2 f
--   Just ["a","k"]
--   </pre>
generate :: Int -> (Int -> a) -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; let f 0 = "a"; f _ = "k"; f :: Int -&gt; String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1 2 f
--   ["a","k"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1 0 f
--   ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1 (-1) f
--   ["a"]
--   </pre>
generate1 :: Int -> (Int -> a) -> NonEmptyVector a

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN 3 (+1) 0
--   Just [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN 0 (+1) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN (-1) (+1) 0
--   Nothing
--   </pre>
iterateN :: Int -> (a -> a) -> a -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Apply function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 3 (+1) 0
--   [0,1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 0 (+1) 0
--   [0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1 (-1) (+1) 0
--   [0]
--   </pre>
iterateN1 :: Int -> (a -> a) -> a -> NonEmptyVector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 3 (Just "a")
--   Just (Just ["a","a","a"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe 0 (Just "a")
--   Just Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM @Maybe (-1) (Just "a")
--   Just Nothing
--   </pre>
replicateM :: Monad m => Int -> m a -> m (Maybe (NonEmptyVector a))

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 3 (Just "a")
--   Just ["a","a","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 3 Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe 0 (Just "a")
--   Just ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; replicate1M @Maybe (-1) (Just "a")
--   Just ["a"]
--   </pre>
replicate1M :: Monad m => Int -> m a -> m (NonEmptyVector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; generateM 3 (\i -&gt; if i P.&lt; 1 then ["a"] else ["b"])
--   [Just ["a","b","b"]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Int 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @[] @Int 0 (const [1])
--   [Nothing]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generateM @Maybe @Int (-1) (const Nothing)
--   Just Nothing
--   </pre>
generateM :: Monad m => Int -> (Int -> m a) -> m (Maybe (NonEmptyVector a))

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 3 (\i -&gt; if i P.&lt; 1 then Just "a" else Just "b")
--   Just ["a","b","b"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 3 (const [])
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M 0 (const $ Just 1)
--   Just [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate1M (-1) (const Nothing)
--   Nothing
--   </pre>
generate1M :: Monad m => Int -> (Int -> m a) -> m (NonEmptyVector a)

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   When given a index n &lt;= 0, then <a>Nothing</a> is returned,
--   otherwise <a>Just</a>.
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 3 return "a"
--   Just (Just ["a","a","a"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateNM @Maybe 0 return "a"
--   Just Nothing
--   </pre>
iterateNM :: Monad m => Int -> (a -> m a) -> a -> m (Maybe (NonEmptyVector a))

-- | <i>O(n)</i> Apply monadic function n times to value. Zeroth element is
--   original value.
--   
--   This variant takes <tt>max n 1</tt> for the supplied length parameter.
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 3 return "a"
--   Just ["a","a","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 3 (const Nothing) "a"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe 0 return "a"
--   Just ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iterateN1M @Maybe (-1) return "a"
--   Just ["a"]
--   </pre>
iterateN1M :: Monad m => Int -> (a -> m a) -> a -> m (NonEmptyVector a)

-- | Execute the monadic action and freeze the resulting non-empty vector.
create :: (forall s. ST s (MVector s a)) -> Maybe (NonEmptyVector a)

-- | Execute the monadic action and freeze the resulting non-empty vector,
--   bypassing emptiness checks.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreate :: (forall s. ST s (MVector s a)) -> NonEmptyVector a

-- | Execute the monadic action and freeze the resulting non-empty vector.
createT :: Traversable t => (forall s. ST s (t (MVector s a))) -> t (Maybe (NonEmptyVector a))

-- | Execute the monadic action and freeze the resulting non-empty vector.
--   
--   The onus is on the caller to guarantee the created vector is
--   non-empty.
unsafeCreateT :: Traversable t => (forall s. ST s (t (MVector s a))) -> t (NonEmptyVector a)

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a non-empty vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "a"
--   Just ["a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (const Nothing) "a"
--   Nothing
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   generator function to a seed and a first element.
--   
--   This variant of <a>unfoldr</a> guarantees the resulting vector is non-
--   empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 (\b -&gt; case b of "a" -&gt; Just ("a", "b"); _ -&gt;  Nothing) "first" "a"
--   ["first","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1 (const Nothing) "first" "a"
--   ["first"]
--   </pre>
unfoldr1 :: (b -> Maybe (a, b)) -> a -> b -> NonEmptyVector a

-- | <i>O(n)</i> Construct a vector with at most n elements by repeatedly
--   applying the generator function to a seed. The generator function
--   yields <a>Just</a> the next element and the new seed or <a>Nothing</a>
--   if there are no more elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a non-empty vector is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 3 (\b -&gt; Just (b+1, b+1)) 0
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 3 (const Nothing) 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldrN 0 (\b -&gt; Just (b+1, b+1)) 0
--   Nothing
--   </pre>
unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Construct a vector with at most n elements by repeatedly
--   applying the generator function to a seed. The generator function
--   yields <a>Just</a> the next element and the new seed or <a>Nothing</a>
--   if there are no more elements.
--   
--   This variant of <a>unfoldrN</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 3 (\b -&gt; Just (b+1, b+1)) 0 0
--   [0,1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 3 (const Nothing) 0 0
--   [0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr1N 0 (\b -&gt; Just (b+1, b+1)) 0 0
--   [0]
--   </pre>
unfoldr1N :: Int -> (b -> Maybe (a, b)) -> a -> b -> NonEmptyVector a

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a non-empty vector is
--   returned.
unfoldrM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m (Maybe (NonEmptyVector a))

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1M :: Monad m => (b -> m (Maybe (a, b))) -> a -> b -> m (NonEmptyVector a)

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   If an unfold does not create meaningful values, <a>Nothing</a> is
--   returned. Otherwise, <a>Just</a> containing a non-empty vector is
--   returned.
unfoldrNM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> b -> m (Maybe (NonEmptyVector a))

-- | <i>O(n)</i> Construct a non-empty vector by repeatedly applying the
--   monadic generator function to a seed. The generator function yields
--   Just the next element and the new seed or Nothing if there are no more
--   elements.
--   
--   This variant of <a>unfoldrNM</a> guarantees the resulting vector is
--   non- empty by supplying an initial element <tt>a</tt>.
unfoldr1NM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> a -> b -> m (NonEmptyVector a)

-- | <i>O(n)</i> Construct a non-empty vector with n elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   If <a>constructN</a> does not create meaningful values, <a>Nothing</a>
--   is returned. Otherwise, <a>Just</a> containing a non-empty vector is
--   returned.
constructN :: Int -> (Vector a -> a) -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Construct a vector with n elements from right to left by
--   repeatedly applying the generator function to the already constructed
--   part of the vector.
--   
--   If <a>constructrN</a> does not create meaningful values,
--   <a>Nothing</a> is returned. Otherwise, <a>Just</a> containing a
--   non-empty vector is returned.
constructrN :: Int -> (Vector a -> a) -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Yield a non-emptyvector of the given length containing the
--   values x, x+1 etc. This operation is usually more efficient than
--   <a>enumFromTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a non-empty vector.
enumFromN :: Num a => a -> Int -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Yield a non-emptyvector of length <tt>max n 1</tt>
--   containing the values x, x+1 etc. This operation is usually more
--   efficient than <a>enumFromTo</a>.
enumFromN1 :: Num a => a -> Int -> NonEmptyVector a

-- | <i>O(n)</i> Yield a non-empty vector of the given length containing
--   the values x, x+y, x+y+y etc. This operations is usually more
--   efficient than <a>enumFromThenTo</a>.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a non-empty vector.
enumFromStepN :: Num a => a -> a -> Int -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Yield a non-empty vector of length <tt>max n 1</tt>
--   containing the values x, x+y, x+y+y etc. This operations is usually
--   more efficient than <a>enumFromThenTo</a>.
enumFromStepN1 :: Num a => a -> a -> Int -> NonEmptyVector a

-- | <i>O(n)</i> Enumerate values from x to y.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a non-empty vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromN</a> instead.
enumFromTo :: Enum a => a -> a -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Enumerate values from x to y with a specific step z.
--   
--   If an enumeration does not use meaningful indices, <a>Nothing</a> is
--   returned, otherwise, <a>Just</a> containing a non-empty vector.
--   
--   <i>WARNING</i>: This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Prepend an element
--   
--   <pre>
--   &gt;&gt;&gt; cons 1 (unsafeFromList [2,3])
--   [1,2,3]
--   </pre>
cons :: a -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Prepend an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; consV 1 (V.fromList [2,3])
--   [1,2,3]
--   </pre>
consV :: a -> Vector a -> NonEmptyVector a

-- | <i>O(n)</i> Append an element
--   
--   <pre>
--   &gt;&gt;&gt; snoc (unsafeFromList [1,2]) 3
--   [1,2,3]
--   </pre>
snoc :: NonEmptyVector a -> a -> NonEmptyVector a

-- | <i>O(n)</i> Append an element to a Vector
--   
--   <pre>
--   &gt;&gt;&gt; snocV (V.fromList [1,2]) 3
--   [1,2,3]
--   </pre>
snocV :: Vector a -> a -> NonEmptyVector a

-- | <i>O(m+n)</i> Concatenate two non-empty vectors
--   
--   <pre>
--   &gt;&gt;&gt; (unsafeFromList [1..3]) ++ (unsafeFromList [4..6])
--   [1,2,3,4,5,6]
--   </pre>
(++) :: NonEmptyVector a -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Concatenate all non-empty vectors in the list
--   
--   If list is empty, <a>Nothing</a> is returned, otherwise <a>Just</a>
--   containing the concatenated non-empty vectors
--   
--   <pre>
--   &gt;&gt;&gt; concat [(unsafeFromList [1..3]), (unsafeFromList [4..6])]
--   Just [1,2,3,4,5,6]
--   </pre>
concat :: [NonEmptyVector a] -> Maybe (NonEmptyVector a)

-- | O(n) Concatenate all non-empty vectors in a non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; concat1 ((unsafeFromList [1..3]) :| [(unsafeFromList [4..6])])
--   [1,2,3,4,5,6]
--   </pre>
concat1 :: NonEmpty (NonEmptyVector a) -> NonEmptyVector a

-- | <i>O(n)</i> Yield the argument but force it not to retain any extra
--   memory, possibly by copying it.
force :: NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Convert a non-empty vector to a non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (unsafeFromList [1..3])
--   1 :| [2,3]
--   </pre>
toNonEmpty :: NonEmptyVector a -> NonEmpty a

-- | O(n) Convert from a non-empty list to a non-empty vector.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty (1 :| [2,3])
--   [1,2,3]
--   </pre>
fromNonEmpty :: NonEmpty a -> NonEmptyVector a

-- | O(n) Convert from the first n-elements of a non-empty list to a
--   non-empty vector.
--   
--   Returns <a>Nothing</a> if indices are &lt;= 0, otherwise <a>Just</a>
--   containing the non-empty vector.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmptyN 3 (1 :| [2..5])
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmptyN 0 (1 :| [2..5])
--   Nothing
--   </pre>
fromNonEmptyN :: Int -> NonEmpty a -> Maybe (NonEmptyVector a)

-- | O(n) Convert from the first n-elements of a non-empty list to a
--   non-empty vector. This is a safe version of <a>fromNonEmptyN</a> which
--   takes <tt>max n 1</tt> of the first n-elements of the non-empty list.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmptyN1 3 (1 :| [2..5])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmptyN1 0 (1 :| [2..5])
--   [1]
--   </pre>
fromNonEmptyN1 :: Int -> NonEmpty a -> NonEmptyVector a

-- | <i>O(n)</i> Convert from a list to a non-empty vector.
--   
--   <i>Warning</i>: the onus is on the user to ensure that their vector is
--   not empty, otherwise all bets are off!
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromList [1..3]
--   [1,2,3]
--   </pre>
unsafeFromList :: [a] -> NonEmptyVector a

-- | <i>O(1)</i> Convert from a non-empty vector to a vector.
--   
--   <pre>
--   &gt;&gt;&gt; let nev :: NonEmptyVector Int = unsafeFromList [1..3] in toVector nev
--   [1,2,3]
--   </pre>
toVector :: NonEmptyVector a -> Vector a

-- | <i>O(1)</i> Convert from a vector to a non-empty vector.
--   
--   If the vector is empty, then <a>Nothing</a> is returned, otherwise
--   <a>Just</a> containing the non-empty vector.
--   
--   <pre>
--   &gt;&gt;&gt; fromVector $ V.fromList [1..3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromVector $ V.fromList []
--   Nothing
--   </pre>
fromVector :: Vector a -> Maybe (NonEmptyVector a)

-- | <i>O(1)</i> Convert from a vector to a non-empty vector without
--   checking bounds.
--   
--   <i>Warning</i>: the onus is on the user to ensure that their vector is
--   not empty, otherwise all bets are off!
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromVector $ V.fromList [1..3]
--   [1,2,3]
--   </pre>
unsafeFromVector :: Vector a -> NonEmptyVector a

-- | <i>O(n)</i> Convert from a non-empty vector to a list.
--   
--   <pre>
--   &gt;&gt;&gt; let nev :: NonEmptyVector Int = unsafeFromList [1..3] in toList nev
--   [1,2,3]
--   </pre>
toList :: NonEmptyVector a -> [a]

-- | <i>O(n)</i> Convert from a list to a non-empty vector.
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1..3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList []
--   Nothing
--   </pre>
fromList :: [a] -> Maybe (NonEmptyVector a)

-- | <i>O(n)</i> Convert the first n elements of a list to a non-empty
--   vector.
--   
--   If the list is empty or &lt;= 0 elements are chosen, <a>Nothing</a> is
--   returned, otherwise <a>Just</a> containing the non-empty vector
--   
--   <pre>
--   &gt;&gt;&gt; fromListN 3 [1..5]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromListN 3 []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromListN 0 [1..5]
--   Nothing
--   </pre>
fromListN :: Int -> [a] -> Maybe (NonEmptyVector a)

-- | <i>O(m+n)</i> For each pair (i,a) from the list, replace the non-empty
--   vector element at position i by a.
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromList [1..3] // [(2,4)]
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromList [1..3] // []
--   [1,2,3]
--   </pre>
(//) :: NonEmptyVector a -> [(Int, a)] -> NonEmptyVector a

-- | O(m+n) For each pair (i,a) from the vector of index/value pairs,
--   replace the vector element at position i by a.
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromList [1..3] `update` V.fromList [(2,4)]
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeFromList [1..3] `update` V.empty
--   [1,2,3]
--   </pre>
update :: NonEmptyVector a -> Vector (Int, a) -> NonEmptyVector a

-- | <i>O(m+min(n1,n2))</i> For each index i from the index vector and the
--   corresponding value a from the value vector, replace the element of
--   the initial vector at position i by a.
--   
--   <pre>
--   &gt;&gt;&gt; update_ (unsafeFromList [1..3]) (V.fromList [2]) (V.fromList [4])
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; update_ (unsafeFromList [1..3]) V.empty V.empty
--   [1,2,3]
--   </pre>
update_ :: NonEmptyVector a -> Vector Int -> Vector a -> NonEmptyVector a

-- | Same as <a>(//)</a> but without bounds checking.
unsafeUpd :: NonEmptyVector a -> [(Int, a)] -> NonEmptyVector a

-- | Same as <a>update</a> but without bounds checking.
unsafeUpdate :: NonEmptyVector a -> Vector (Int, a) -> NonEmptyVector a

-- | Same as <a>update_</a> but without bounds checking.
unsafeUpdate_ :: NonEmptyVector a -> Vector Int -> Vector a -> NonEmptyVector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the non-empty list,
--   replace the non-empty vector element <tt>a</tt> at position <tt>i</tt>
--   by <tt>f a b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; accum (+) (unsafeFromList [1..3]) [(2,10)]
--   [1,2,13]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; accum (+) (unsafeFromList [1..3]) []
--   [1,2,3]
--   </pre>
accum :: (a -> b -> a) -> NonEmptyVector a -> [(Int, b)] -> NonEmptyVector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the non-empty vector element <tt>a</tt> at position <tt>i</tt>
--   by <tt>f a b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; accumulate (+) (unsafeFromList [1..3]) (V.fromList [(2,10)])
--   [1,2,13]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; accumulate (+) (unsafeFromList [1..3]) V.empty
--   [1,2,3]
--   </pre>
accumulate :: (a -> b -> a) -> NonEmptyVector a -> Vector (Int, b) -> NonEmptyVector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial non-empty vector at position
--   <tt>i</tt> by <tt>f a b</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; accumulate_ (+) (unsafeFromList [1..3]) (V.fromList [2]) (V.fromList [10])
--   [1,2,13]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; accumulate_ (+) (unsafeFromList [1..3]) V.empty V.empty
--   [1,2,3]
--   </pre>
accumulate_ :: (a -> b -> a) -> NonEmptyVector a -> Vector Int -> Vector b -> NonEmptyVector a

-- | Same as <a>accum</a> but without bounds checking.
unsafeAccum :: (a -> b -> a) -> NonEmptyVector a -> [(Int, b)] -> NonEmptyVector a

-- | Same as <a>accumulate</a> but without bounds checking.
unsafeAccumulate :: (a -> b -> a) -> NonEmptyVector a -> Vector (Int, b) -> NonEmptyVector a

-- | Same as <a>accumulate_</a> but without bounds checking.
unsafeAccumulate_ :: (a -> b -> a) -> NonEmptyVector a -> Vector Int -> Vector b -> NonEmptyVector a

-- | <i>O(n)</i> Reverse a non-empty vector
--   
--   <pre>
--   &gt;&gt;&gt; reverse $ unsafeFromList [1..3]
--   [3,2,1]
--   </pre>
reverse :: NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Yield the non-empty vector obtained by replacing each
--   element <tt>i</tt> of the non-empty index vector by
--   <tt>xs<a>!</a>i</tt>. This is equivalent to <tt><a>map</a>
--   (xs<a>!</a>) is</tt> but is often much more efficient.
--   
--   <pre>
--   &gt;&gt;&gt; backpermute (unsafeFromList [1..3]) (unsafeFromList [2,0])
--   [3,1]
--   </pre>
backpermute :: NonEmptyVector a -> NonEmptyVector Int -> NonEmptyVector a

-- | Same as <a>backpermute</a> but without bounds checking.
unsafeBackpermute :: NonEmptyVector a -> NonEmptyVector Int -> NonEmptyVector a

-- | Apply a destructive operation to a non-empty vector. The operation
--   will be performed in place if it is safe to do so and will modify a
--   copy of the non-empty vector otherwise.
modify :: (forall s. MVector s a -> ST s ()) -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Pair each element in a vector with its index.
--   
--   <pre>
--   &gt;&gt;&gt; indexed $ unsafeFromList ["a","b","c"]
--   [(0,"a"),(1,"b"),(2,"c")]
--   </pre>
indexed :: NonEmptyVector a -> NonEmptyVector (Int, a)

-- | <i>O(n)</i> Map a function over a non-empty vector.
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) $ unsafeFromList [1..3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Apply a function to every element of a non-empty vector
--   and its index.
--   
--   <pre>
--   &gt;&gt;&gt; imap (\i a -&gt; if i == 2 then a+1 else a+0) $ unsafeFromList [1..3]
--   [1,2,4]
--   </pre>
imap :: (Int -> a -> b) -> NonEmptyVector a -> NonEmptyVector b

-- | Map a function over a vector and concatenate the results.
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\a -&gt; unsafeFromList [a,a]) (unsafeFromList [1,2,3])
--   [1,1,2,2,3,3]
--   </pre>
concatMap :: (a -> NonEmptyVector b) -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the non-empty
--   vector, yielding non-empty vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM Just (unsafeFromList [1..3])
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM (const Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
mapM :: Monad m => (a -> m b) -> NonEmptyVector a -> m (NonEmptyVector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a non-empty
--   vector and its index, yielding a non-empty vector of results.
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\i a -&gt; if i == 1 then Just a else Just 0) (unsafeFromList [1..3])
--   Just [0,2,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM (\_ _ -&gt; Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
imapM :: Monad m => (Int -> a -> m b) -> NonEmptyVector a -> m (NonEmptyVector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a non-empty
--   vector and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const $ Just ()) (unsafeFromList [1..3])
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ (const Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
mapM_ :: Monad m => (a -> m b) -> NonEmptyVector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a non-emptpy
--   vector and its index, ignoring the results
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\i a -&gt; if i == 1 then P.print a else P.putStrLn "0") (unsafeFromList [1..3])
--   0
--   2
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imapM_ (\_ _ -&gt; Nothing) (unsafeFromList [1..3])
--   Nothing
--   </pre>
imapM_ :: Monad m => (Int -> a -> m b) -> NonEmptyVector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the non-empty
--   vector, yielding a non0empty vector of results.
--   
--   Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: Monad m => NonEmptyVector a -> (a -> m b) -> m (NonEmptyVector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a non-empty
--   vector and ignore the results.
--   
--   Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: Monad m => NonEmptyVector a -> (a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two non-empty vectors with the given function.
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) (unsafeFromList [1..3]) (unsafeFromList [1..3])
--   [2,4,6]
--   </pre>
zipWith :: (a -> b -> c) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c

-- | Zip three non-empty vectors with the given function.
zipWith3 :: (a -> b -> c -> d) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d

-- | Zip four non-empty vectors with the given function.
zipWith4 :: (a -> b -> c -> d -> e) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e

-- | Zip five non-empty vectors with the given function.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector f

-- | Zip six non-empty vectors with the given function.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector f -> NonEmptyVector g

-- | <i>O(min(m,n))</i> Zip two non-empty vectors with a function that also
--   takes the elements' indices.
izipWith :: (Int -> a -> b -> c) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c

-- | Zip three non-empty vectors and their indices with the given function.
izipWith3 :: (Int -> a -> b -> c -> d) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d

-- | Zip four non-empty vectors and their indices with the given function.
izipWith4 :: (Int -> a -> b -> c -> d -> e) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e

-- | Zip five non-empty vectors and their indices with the given function.
izipWith5 :: (Int -> a -> b -> c -> d -> e -> f) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector f

-- | Zip six non-empty vectors and their indices with the given function.
izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g) -> NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector f -> NonEmptyVector g

-- | <i>O(min(n,m))</i> Elementwise pairing of non-empty vector elements.
--   This is a special case of <a>zipWith</a> where the function argument
--   is <tt>(,)</tt>
zip :: NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector (a, b)

-- | Zip together three non-empty vectors.
zip3 :: NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector (a, b, c)

-- | Zip together four non-empty vectors.
zip4 :: NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector (a, b, c, d)

-- | Zip together five non-empty vectors.
zip5 :: NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector (a, b, c, d, e)

-- | Zip together six non-empty vectors.
zip6 :: NonEmptyVector a -> NonEmptyVector b -> NonEmptyVector c -> NonEmptyVector d -> NonEmptyVector e -> NonEmptyVector f -> NonEmptyVector (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two non-empty vectors with the monadic
--   action and yield a non-empty vector of results.
zipWithM :: Monad m => (a -> b -> m c) -> NonEmptyVector a -> NonEmptyVector b -> m (NonEmptyVector c)

-- | <i>O(min(m,n))</i> Zip the two non-empty vectors with the monadic
--   action and ignore the results.
zipWithM_ :: Monad m => (a -> b -> m c) -> NonEmptyVector a -> NonEmptyVector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two non-empty vectors with a monadic action
--   that also takes the element index and yield a vector of results.
izipWithM :: Monad m => (Int -> a -> b -> m c) -> NonEmptyVector a -> NonEmptyVector b -> m (NonEmptyVector c)

-- | <i>O(min(m,n))</i> Zip the two non-empty vectors with a monadic action
--   that also takes the element index and ignore the results.
izipWithM_ :: Monad m => (Int -> a -> b -> m c) -> NonEmptyVector a -> NonEmptyVector b -> m ()

-- | <i>O(min(m,n))</i> Unzip a non-empty vector of pairs.
unzip :: NonEmptyVector (a, b) -> (NonEmptyVector a, NonEmptyVector b)

-- | Unzip a non-empty vector of triples.
unzip3 :: NonEmptyVector (a, b, c) -> (NonEmptyVector a, NonEmptyVector b, NonEmptyVector c)

-- | Unzip a non-empty vector of quadruples.
unzip4 :: NonEmptyVector (a, b, c, d) -> (NonEmptyVector a, NonEmptyVector b, NonEmptyVector c, NonEmptyVector d)

-- | Unzip a non-empty vector of quintuples.
unzip5 :: NonEmptyVector (a, b, c, d, e) -> (NonEmptyVector a, NonEmptyVector b, NonEmptyVector c, NonEmptyVector d, NonEmptyVector e)

-- | Unzip a non-empty vector of sextuples.
unzip6 :: NonEmptyVector (a, b, c, d, e, f) -> (NonEmptyVector a, NonEmptyVector b, NonEmptyVector c, NonEmptyVector d, NonEmptyVector e, NonEmptyVector f)

-- | <i>O(n)</i> Drop repeated adjacent elements.
--   
--   <pre>
--   &gt;&gt;&gt; uniq $ unsafeFromList [1,1,2,2,3,3,1]
--   [1,2,3,1]
--   </pre>
uniq :: Eq a => NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Drop elements when predicate returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\a -&gt; if a == 2 then Nothing else Just a) (unsafeFromList [1..3])
--   [1,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> NonEmptyVector a -> Vector b

-- | <i>O(n)</i> Drop elements when predicate, applied to index and value,
--   returns Nothing
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; imapMaybe (\i a -&gt; if a == 2 || i == 2 then Nothing else Just a) (unsafeFromList [1..3])
--   [1]
--   </pre>
imapMaybe :: (Int -> a -> Maybe b) -> NonEmptyVector a -> Vector b

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; filter (\a -&gt; if a == 2 then False else True) (unsafeFromList [1..3])
--   [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter (const False) (unsafeFromList [1..3])
--   []
--   </pre>
filter :: (a -> Bool) -> NonEmptyVector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the predicate which is
--   applied to values and their indices.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\i a -&gt; if a == 2 || i == 0 then False else True) (unsafeFromList [1..3])
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilter (\_ _ -&gt; False) (unsafeFromList [1..3])
--   []
--   </pre>
ifilter :: (Int -> a -> Bool) -> NonEmptyVector a -> Vector a

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Just False else Just True) (unsafeFromList [1..3])
--   Just [1,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (\a -&gt; if a == 2 then Nothing else Just True) (unsafeFromList [1..3])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filterM (const $ Just False) (unsafeFromList [1..3])
--   Just []
--   </pre>
filterM :: Monad m => (a -> m Bool) -> NonEmptyVector a -> m (Vector a)

-- | <i>O(n)</i> Drop elements that do not satisfy the monadic predicate
--   that is a function of index and value.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   TODO: this should be a more efficient function in <tt>vector</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\i a -&gt; if a == 2 || i == 0 then Just False else Just True) (unsafeFromList [1..3])
--   Just [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\i a -&gt; if a == 2 || i == 0 then Nothing else Just True) (unsafeFromList [1..3])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifilterM (\_ _ -&gt; Just False) (unsafeFromList [1..3])
--   Just []
--   </pre>
ifilterM :: Monad m => (Int -> a -> m Bool) -> NonEmptyVector a -> m (Vector a)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate without copying.
--   
--   If no elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (/= 3) (unsafeFromList [1..3])
--   [1,2]
--   </pre>
takeWhile :: (a -> Bool) -> NonEmptyVector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
--   
--   If all elements satisfy the predicate, the resulting vector may be
--   empty.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (/= 3) (unsafeFromList [1..3])
--   [3]
--   </pre>
dropWhile :: (a -> Bool) -> NonEmptyVector a -> Vector a

-- | <i>O(n)</i> Split the non-empty vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The relative order of the elements is preserved
--   at the cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; partition (&lt; 3) (unsafeFromList [1..5])
--   ([1,2],[3,4,5])
--   </pre>
partition :: (a -> Bool) -> NonEmptyVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the non-empty vector in two parts, the first one
--   containing the Left elements and the second containing the Right
--   elements. The relative order of the elements is preserved.
--   
--   If all elements produce a Left (or Right), one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; partitionWith (\a -&gt; if a &lt; 3 then Left a else Right (P.show a)) (unsafeFromList [1..5])
--   ([1,2],["3","4","5"])
--   </pre>
partitionWith :: (a -> Either b c) -> NonEmptyVector a -> (Vector b, Vector c)

-- | <i>O(n)</i> Split the non-empty vector in two parts, the first one
--   containing those elements that satisfy the predicate and the second
--   one those that don't. The order of the elements is not preserved but
--   the operation is often faster than <a>partition</a>.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
unstablePartition :: (a -> Bool) -> NonEmptyVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the non-empty vector into the longest prefix of
--   elements that satisfy the predicate and the rest without copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; span (== 1) (unsafeFromList [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
span :: (a -> Bool) -> NonEmptyVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
--   
--   If all or no elements satisfy the predicate, one of the resulting
--   vectors may be empty.
--   
--   <pre>
--   &gt;&gt;&gt; break (== 2) (unsafeFromList [1,1,2,3,1])
--   ([1,1],[2,3,1])
--   </pre>
break :: (a -> Bool) -> NonEmptyVector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Check if the non-empty vector contains an element
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 $ unsafeFromList [1..3]
--   True
--   
--   &gt;&gt;&gt; elem 4 $ unsafeFromList [1..3]
--   False
--   </pre>
elem :: Eq a => a -> NonEmptyVector a -> Bool

-- | <i>O(n)</i> Check if the non-empty vector does not contain an element
--   (inverse of <a>elem</a>)
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1 $ unsafeFromList [1..3]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 4 $ unsafeFromList [1..3]
--   True
--   </pre>
notElem :: Eq a => a -> NonEmptyVector a -> Bool

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 2) $ unsafeFromList [1..3]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) $ unsafeFromList [1..3]
--   Nothing
--   </pre>
find :: (a -> Bool) -> NonEmptyVector a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 2) $ unsafeFromList [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndex (&lt; 0) $ unsafeFromList [1..3]
--   Nothing
--   </pre>
findIndex :: (a -> Bool) -> NonEmptyVector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 3) $ unsafeFromList [1..3]
--   [0,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (&lt; 0) $ unsafeFromList [1..3]
--   []
--   </pre>
findIndices :: (a -> Bool) -> NonEmptyVector a -> Vector Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurence of the
--   given element or <a>Nothing</a> if the non-empty vector does not
--   contain the element. This is a specialised version of
--   <a>findIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 1 $ unsafeFromList [1..3]
--   Just 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 0 $ unsafeFromList [1..3]
--   Nothing
--   </pre>
elemIndex :: Eq a => a -> NonEmptyVector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 1 $ unsafeFromList [1,2,3,1]
--   [0,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 0 $ unsafeFromList [1..3]
--   []
--   </pre>
elemIndices :: Eq a => a -> NonEmptyVector a -> Vector Int

-- | <i>O(n)</i> Left monoidal fold
foldl :: (a -> b -> a) -> a -> NonEmptyVector b -> a

-- | <i>O(n)</i> Left semigroupal fold
foldl1 :: (a -> a -> a) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Strict Left monoidal fold
foldl' :: (a -> b -> a) -> a -> NonEmptyVector b -> a

-- | <i>O(n)</i> Strict Left semigroupal fold
foldl1' :: (a -> a -> a) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Right monoidal fold
foldr :: (a -> b -> b) -> b -> NonEmptyVector a -> b

-- | <i>O(n)</i> Right semigroupal fold
foldr1 :: (a -> a -> a) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Strict right monoidal fold
foldr' :: (a -> b -> b) -> b -> NonEmptyVector a -> b

-- | <i>O(n)</i> Strict right semigroupal fold
foldr1' :: (a -> a -> a) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Left monoidal fold with function applied to each element
--   and its index
ifoldl :: (a -> Int -> b -> a) -> a -> NonEmptyVector b -> a

-- | <i>O(n)</i> Strict left monoidal fold with function applied to each
--   element and its index
ifoldl' :: (a -> Int -> b -> a) -> a -> NonEmptyVector b -> a

-- | <i>O(n)</i> Right monoidal fold with function applied to each element
--   and its index
ifoldr :: (Int -> a -> b -> b) -> b -> NonEmptyVector a -> b

-- | <i>O(n)</i> strict right monoidal fold with function applied to each
--   element and its index
ifoldr' :: (Int -> a -> b -> b) -> b -> NonEmptyVector a -> b

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
all :: (a -> Bool) -> NonEmptyVector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
any :: (a -> Bool) -> NonEmptyVector a -> Bool

-- | <i>O(n)</i> Check if all elements are <tt>True</tt>.
and :: NonEmptyVector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <tt>True</tt>
or :: NonEmptyVector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements
sum :: Num a => NonEmptyVector a -> a

-- | <i>O(n)</i> Compute the produce of the elements
product :: Num a => NonEmptyVector a -> a

-- | <i>O(n)</i> Yield the maximum element of the non-empty vector.
maximum :: Ord a => NonEmptyVector a -> a

-- | <i>O(n)</i> Yield the maximum element of a non-empty vector according
--   to the given comparison function.
maximumBy :: (a -> a -> Ordering) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector.
minimum :: Ord a => NonEmptyVector a -> a

-- | <i>O(n)</i> Yield the minimum element of the non-empty vector
--   according to the given comparison function.
minimumBy :: (a -> a -> Ordering) -> NonEmptyVector a -> a

-- | <i>O(n)</i> Yield the index of the maximum element of the non-empty
--   vector.
maxIndex :: Ord a => NonEmptyVector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function.
maxIndexBy :: (a -> a -> Ordering) -> NonEmptyVector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the non-empty
--   vector.
minIndex :: Ord a => NonEmptyVector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function.
minIndexBy :: (a -> a -> Ordering) -> NonEmptyVector a -> Int

-- | <i>O(n)</i> Monadic fold
foldM :: Monad m => (a -> b -> m a) -> a -> NonEmptyVector b -> m a

-- | <i>O(n)</i> Strict monadic fold
foldM' :: Monad m => (a -> b -> m a) -> a -> NonEmptyVector b -> m a

-- | <i>O(n)</i> Monadic semigroupal fold
fold1M :: Monad m => (a -> a -> m a) -> NonEmptyVector a -> m a

-- | <i>O(n)</i> Strict monadic semigroupal fold
fold1M' :: Monad m => (a -> a -> m a) -> NonEmptyVector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result
foldM_ :: Monad m => (a -> b -> m a) -> a -> NonEmptyVector b -> m ()

-- | <i>O(n)</i> Strict monadic fold that discards the result
foldM'_ :: Monad m => (a -> b -> m a) -> a -> NonEmptyVector b -> m ()

-- | <i>O(n)</i> Monadic semigroupal fold that discards the result
fold1M_ :: Monad m => (a -> a -> m a) -> NonEmptyVector a -> m ()

-- | <i>O(n)</i> Strict monadic semigroupal fold that discards the result
fold1M'_ :: Monad m => (a -> a -> m a) -> NonEmptyVector a -> m ()

-- | <i>O(n)</i> Monadic fold (action applied to each element and its
--   index)
ifoldM :: Monad m => (a -> Int -> b -> m a) -> a -> NonEmptyVector b -> m a

-- | <i>O(n)</i> Strict monadic fold (action applied to each element and
--   its index)
ifoldM' :: Monad m => (a -> Int -> b -> m a) -> a -> NonEmptyVector b -> m a

-- | <i>O(n)</i> Monadic fold that discards the result (action applied to
--   each element and its index)
ifoldM_ :: Monad m => (a -> Int -> b -> m a) -> a -> NonEmptyVector b -> m ()

-- | <i>O(n)</i> Strict monadic fold that discards the result (action
--   applied to each element and its index)
ifoldM'_ :: Monad m => (a -> Int -> b -> m a) -> a -> NonEmptyVector b -> m ()

-- | Evaluate each action and collect the results
sequence :: Monad m => NonEmptyVector (m a) -> m (NonEmptyVector a)

-- | Evaluate each action and discard the results
sequence_ :: Monad m => NonEmptyVector (m a) -> m ()

-- | <i>O(n)</i> Prescan
prescanl :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Prescan with strict accumulator
prescanl' :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Scan
postscanl :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Scan with a strict accumulator
postscanl' :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Haskell-style scan
scanl :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Haskell-style scan with strict accumulator
scanl' :: (a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Semigroupal left scan
scanl1 :: (a -> a -> a) -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Strict semigroupal scan
scanl1' :: (a -> a -> a) -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Scan over a vector with its index
iscanl :: (Int -> a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Scan over a vector with its index with strict accumulator
iscanl' :: (Int -> a -> b -> a) -> a -> NonEmptyVector b -> NonEmptyVector a

-- | <i>O(n)</i> Right-to-left prescan
prescanr :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator
prescanr' :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left scan
postscanr :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator
postscanr' :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan
scanr :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left Haskell-style scan with strict accumulator
scanr' :: (a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left Haskell-style semigroupal scan
scanr1 :: (a -> a -> a) -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Right-to-left Haskell-style semigroupal scan with strict
--   accumulator
scanr1' :: (a -> a -> a) -> NonEmptyVector a -> NonEmptyVector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index
iscanr :: (Int -> a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b

-- | <i>O(n)</i> Right-to-left scan over a vector with its index and a
--   strict accumulator
iscanr' :: (Int -> a -> b -> b) -> b -> NonEmptyVector a -> NonEmptyVector b


-- | Non-empty mutable boxed vectors.
module Data.Vector.NonEmpty.Mutable

-- | <a>NonEmptyMVector</a> is a thin wrapper around <a>MVector</a> that
--   witnesses an API requiring non-empty construction, initialization, and
--   generation of non-empty vectors by design.
--   
--   A newtype wrapper was chosen so that no new pointer indirection is
--   introduced when working with <a>MVector</a>s, and all performance
--   characteristics inherited from the <a>MVector</a> API still apply.
data NonEmptyMVector s a

-- | <a>NonEmptyMVector</a> parametrized by <tt>PrimState</tt>
type NonEmptyIOVector = NonEmptyMVector RealWorld

-- | <a>NonEmptyMVector</a> parametrized by <a>ST</a>
type NonEmptySTVector s = NonEmptyMVector s

-- | Length of the mutable vector.
length :: NonEmptyMVector s a -> Int

-- | Yield a part of the mutable vector without copying.
slice :: Int -> Int -> NonEmptyMVector s a -> MVector s a

-- | Yield all but the last element without copying.
init :: NonEmptyMVector s a -> MVector s a

-- | Yield all but the first element without copying.
tail :: NonEmptyMVector s a -> MVector s a

-- | Yield at the first n elements without copying.
take :: Int -> NonEmptyMVector s a -> MVector s a

-- | Yield all but the first n elements without copying.
drop :: Int -> NonEmptyMVector s a -> MVector s a

-- | Yield the first n elements paired with the remainder without copying.
splitAt :: Int -> NonEmptyMVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Int -> Int -> NonEmptyMVector s a -> MVector s a

-- | Yield the first n elements without copying. The vector must contain at
--   least n elements but this is not checked.
unsafeTake :: Int -> NonEmptyMVector s a -> MVector s a

-- | Yield all but the first n elements without copying. The vector must
--   contain at least n elements but this is not checked.
unsafeDrop :: Int -> NonEmptyMVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: NonEmptyMVector s a -> NonEmptyMVector s a -> Bool

-- | Convert a mutable vector to a non-empty mutable vector
fromMVector :: MVector s a -> Maybe (NonEmptyMVector s a)

-- | Convert a non-empty mutable vector to a mutable vector
toMVector :: NonEmptyMVector s a -> MVector s a

-- | Convert a mutable vector to a non-empty mutable vector
--   
--   <i>Warning:</i> this function is unsafe and can result in empty
--   non-empty mutable vectors. If you call this function, the onus is on
--   you to make sure the mutable vector being converted is not empty.
unsafeFromMVector :: MVector s a -> NonEmptyMVector s a

-- | Create a mutable vector of the given length.
new :: PrimMonad m => Int -> m (Maybe (NonEmptyMVector (PrimState m) a))

-- | Create a mutable vector of the given length which is <tt>max n 1</tt>.
new1 :: PrimMonad m => Int -> m (NonEmptyMVector (PrimState m) a)

-- | Create a mutable vector of the given length. The memory is not
--   initialized.
unsafeNew :: PrimMonad m => Int -> m (Maybe (NonEmptyMVector (PrimState m) a))

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: PrimMonad m => Int -> a -> m (Maybe (NonEmptyMVector (PrimState m) a))

-- | Create a mutable vector of the length <tt>max n 1</tt> for a given
--   length, and fill it with an initial value.
replicate1 :: PrimMonad m => Int -> a -> m (NonEmptyMVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: PrimMonad m => Int -> m a -> m (Maybe (NonEmptyMVector (PrimState m) a))

-- | Create a mutable vector of the length <tt>max n 1</tt> for a given
--   length, and fill it with values produced by repeatedly executing the
--   monadic action.
replicate1M :: PrimMonad m => Int -> m a -> m (Maybe (NonEmptyMVector (PrimState m) a))

-- | Create a copy of a mutable vector.
clone :: PrimMonad m => NonEmptyMVector (PrimState m) a -> m (NonEmptyMVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive.
grow :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> m (NonEmptyMVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   positive but this is not checked.
unsafeGrow :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> m (NonEmptyMVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: PrimMonad m => NonEmptyMVector (PrimState m) a -> m ()

-- | Yield the element at the given position.
read :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position.
write :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: PrimMonad m => NonEmptyMVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> Int -> m ()

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: PrimMonad m => NonEmptyMVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: PrimMonad m => NonEmptyMVector (PrimState m) a -> Int -> Int -> m ()

-- | Compute the next (lexicographically) permutation of given vector
--   in-place. Returns False when input is the last permtuation
nextPermutation :: (PrimMonad m, Ord e) => NonEmptyMVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: PrimMonad m => NonEmptyMVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: PrimMonad m => NonEmptyMVector (PrimState m) a -> NonEmptyMVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: PrimMonad m => NonEmptyMVector (PrimState m) a -> NonEmptyMVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap. This is not checked.
unsafeCopy :: PrimMonad m => NonEmptyMVector (PrimState m) a -> NonEmptyMVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: PrimMonad m => NonEmptyMVector (PrimState m) a -> NonEmptyMVector (PrimState m) a -> m ()
