-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | pretty printer for data types with a 'Show' instance.
--   
--   Please see <a>README.md</a>.
@package pretty-simple
@version 4.1.2.0


module Text.Pretty.Simple.Internal.Color

-- | These options are for colorizing the output of functions like
--   <tt>pPrint</tt>.
--   
--   If you don't want to use a color for one of the options, use
--   <a>colorNull</a>.
data ColorOptions
ColorOptions :: Style -> Style -> Style -> Style -> [Style] -> ColorOptions

-- | Color to use for quote characters (<tt>"</tt>) around strings.
[colorQuote] :: ColorOptions -> Style

-- | Color to use for strings.
[colorString] :: ColorOptions -> Style

-- | Color for errors, e.g. unmatched brackets.
[colorError] :: ColorOptions -> Style

-- | Color to use for numbers.
[colorNum] :: ColorOptions -> Style

-- | A list of colors to use for rainbow parenthesis output. Use '[]' if
--   you don't want rainbow parenthesis. Use just a single item if you want
--   all the rainbow parenthesis to be colored the same.
[colorRainbowParens] :: ColorOptions -> [Style]

-- | Default color options for use on a dark background.
defaultColorOptionsDarkBg :: ColorOptions

-- | Default color options for use on a light background.
defaultColorOptionsLightBg :: ColorOptions

-- | No styling.
colorNull :: Style

-- | Ways to style terminal output.
data Style
Style :: Maybe (Color, Intensity) -> Bool -> Bool -> Bool -> Style
[styleColor] :: Style -> Maybe (Color, Intensity)
[styleBold] :: Style -> Bool
[styleItalic] :: Style -> Bool
[styleUnderlined] :: Style -> Bool
color :: Intensity -> Color -> Style
colorBold :: Intensity -> Color -> Style
convertStyle :: Style -> AnsiStyle
instance GHC.Show.Show Text.Pretty.Simple.Internal.Color.Style
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Color.Style
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Color.Style
instance GHC.Show.Show Text.Pretty.Simple.Internal.Color.ColorOptions
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Color.ColorOptions
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Color.ColorOptions


module Text.Pretty.Simple.Internal.Expr
newtype CommaSeparated a
CommaSeparated :: [a] -> CommaSeparated a
[unCommaSeparated] :: CommaSeparated a -> [a]
data Expr
Brackets :: !CommaSeparated [Expr] -> Expr
Braces :: !CommaSeparated [Expr] -> Expr
Parens :: !CommaSeparated [Expr] -> Expr
StringLit :: !String -> Expr
CharLit :: !String -> Expr

-- | We could store this as a <a>Rational</a>, say, instead of a
--   <a>String</a>. However, we will never need to use its value for
--   anything. Indeed, the only thing we will be doing with it is turning
--   it <i>back</i> into a string at some stage, so we might as well cut
--   out the middle man and store it directly like this.
NumberLit :: !String -> Expr
Other :: !String -> Expr
instance GHC.Show.Show a => GHC.Show.Show (Text.Pretty.Simple.Internal.Expr.CommaSeparated a)
instance GHC.Generics.Generic (Text.Pretty.Simple.Internal.Expr.CommaSeparated a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Pretty.Simple.Internal.Expr.CommaSeparated a)
instance Data.Data.Data a => Data.Data.Data (Text.Pretty.Simple.Internal.Expr.CommaSeparated a)
instance GHC.Show.Show Text.Pretty.Simple.Internal.Expr.Expr
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Expr.Expr
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Expr.Expr
instance Data.Data.Data Text.Pretty.Simple.Internal.Expr.Expr


module Text.Pretty.Simple.Internal.ExprParser

-- | <a>testString1</a> and <a>testString2</a> are convenient to use in
--   GHCi when playing around with how parsing works.
testString1 :: String

-- | See <a>testString1</a>.
testString2 :: String
expressionParse :: String -> [Expr]
parseExpr :: String -> (Expr, String)

-- | Parse multiple expressions.
--   
--   <pre>
--   &gt;&gt;&gt; parseExprs "Just 'a'"
--   ([Other "Just ",CharLit "a"],"")
--   </pre>
--   
--   Handle escaped characters correctly
--   
--   <pre>
--   &gt;&gt;&gt; parseExprs $ "Foo \"hello \\\"world!\""
--   ([Other "Foo ",StringLit "hello \\\"world!"],"")
--   
--   &gt;&gt;&gt; parseExprs $ "'\\''"
--   ([CharLit "\\'"],"")
--   </pre>
parseExprs :: String -> ([Expr], String)
parseCSep :: Char -> String -> ([[Expr]], String)

-- | Parse string literals until a trailing double quote.
--   
--   <pre>
--   &gt;&gt;&gt; parseStringLit "foobar\" baz"
--   ("foobar"," baz")
--   </pre>
--   
--   Keep literal back slashes:
--   
--   <pre>
--   &gt;&gt;&gt; parseStringLit "foobar\\\" baz\" after"
--   ("foobar\\\" baz"," after")
--   </pre>
parseStringLit :: String -> (String, String)

-- | Parse character literals until a trailing single quote.
--   
--   <pre>
--   &gt;&gt;&gt; parseCharLit "a' foobar"
--   ("a"," foobar")
--   </pre>
--   
--   Keep literal back slashes:
--   
--   <pre>
--   &gt;&gt;&gt; parseCharLit "\\'' hello"
--   ("\\'"," hello")
--   </pre>
parseCharLit :: String -> (String, String)

-- | Parses integers and reals, like <tt>123</tt> and <tt>45.67</tt>.
--   
--   To be more precise, any numbers matching the regex
--   <tt>\d+(\.\d+)?</tt> should get parsed by this function.
--   
--   <pre>
--   &gt;&gt;&gt; parseNumberLit '3' "456hello world []"
--   ("3456","hello world []")
--   
--   &gt;&gt;&gt; parseNumberLit '0' ".12399880 foobar"
--   ("0.12399880"," foobar")
--   </pre>
parseNumberLit :: Char -> String -> (String, String)

-- | This function consumes input, stopping only when it hits a special
--   character or a digit. However, if the digit is in the middle of a
--   Haskell-style identifier (e.g. <tt>foo123</tt>), then keep going
--   anyway.
--   
--   This is almost the same as the function
--   
--   <pre>
--   parseOtherSimple = span $ \c -&gt;
--     notElem c ("{[()]}\"," :: String) &amp;&amp; not (isDigit c) &amp;&amp; (c /= '\'')
--   </pre>
--   
--   except <a>parseOther</a> ignores digits and single quotes that appear
--   in Haskell-like identifiers.
--   
--   <pre>
--   &gt;&gt;&gt; parseOther "hello world []"
--   ("hello world ","[]")
--   
--   &gt;&gt;&gt; parseOther "hello234 world"
--   ("hello234 world","")
--   
--   &gt;&gt;&gt; parseOther "hello 234 world"
--   ("hello ","234 world")
--   
--   &gt;&gt;&gt; parseOther "hello{[ 234 world"
--   ("hello","{[ 234 world")
--   
--   &gt;&gt;&gt; parseOther "H3110 World"
--   ("H3110 World","")
--   
--   &gt;&gt;&gt; parseOther "Node' (Leaf' 1) (Leaf' 2)"
--   ("Node' ","(Leaf' 1) (Leaf' 2)")
--   
--   &gt;&gt;&gt; parseOther "I'm One"
--   ("I'm One","")
--   
--   &gt;&gt;&gt; parseOther "I'm 2"
--   ("I'm ","2")
--   </pre>
parseOther :: String -> (String, String)


module Text.Pretty.Simple.Internal.Printer

-- | Determines whether pretty-simple should check if the output
--   <a>Handle</a> is a TTY device. Normally, users only want to print in
--   color if the output <a>Handle</a> is a TTY device.
data CheckColorTty

-- | Check if the output <a>Handle</a> is a TTY device. If the output
--   <a>Handle</a> is a TTY device, determine whether to print in color
--   based on <a>outputOptionsColorOptions</a>. If not, then set
--   <a>outputOptionsColorOptions</a> to <a>Nothing</a> so the output does
--   not get colorized.
CheckColorTty :: CheckColorTty

-- | Don't check if the output <a>Handle</a> is a TTY device. Determine
--   whether to colorize the output based solely on the value of
--   <a>outputOptionsColorOptions</a>.
NoCheckColorTty :: CheckColorTty

-- | Control how escaped and non-printable are output for strings.
--   
--   See <a>outputOptionsStringStyle</a> for what the output looks like
--   with each of these options.
data StringOutputStyle

-- | Output string literals by printing the source characters exactly.
--   
--   For examples: without this option the printer will insert a newline in
--   place of <tt>"n"</tt>, with this options the printer will output
--   <tt>'\'</tt> and <tt><tt>n</tt></tt>. Similarly the exact escape codes
--   used in the input string will be replicated, so <tt>"65"</tt> will be
--   printed as <tt>"65"</tt> and not <tt><a>A</a></tt>.
Literal :: StringOutputStyle

-- | Replace non-printable characters with hexadecimal escape sequences.
EscapeNonPrintable :: StringOutputStyle

-- | Output non-printable characters without modification.
DoNotEscapeNonPrintable :: StringOutputStyle

-- | Data-type wrapping up all the options available when rendering the
--   list of <tt>Output</tt>s.
data OutputOptions
OutputOptions :: Int -> Int -> Bool -> Bool -> Int -> Maybe ColorOptions -> StringOutputStyle -> OutputOptions

-- | Number of spaces to use when indenting. It should probably be either 2
--   or 4.
[outputOptionsIndentAmount] :: OutputOptions -> Int

-- | The maximum number of characters to fit on to one line.
[outputOptionsPageWidth] :: OutputOptions -> Int

-- | Use less vertical (and more horizontal) space.
[outputOptionsCompact] :: OutputOptions -> Bool

-- | Group closing parentheses on to a single line.
[outputOptionsCompactParens] :: OutputOptions -> Bool

-- | Indent the whole output by this amount.
[outputOptionsInitialIndent] :: OutputOptions -> Int

-- | If this is <a>Nothing</a>, then don't colorize the output. If this is
--   <tt><a>Just</a> colorOptions</tt>, then use <tt>colorOptions</tt> to
--   colorize the output.
[outputOptionsColorOptions] :: OutputOptions -> Maybe ColorOptions

-- | Controls how string literals are output.
--   
--   By default, the pPrint functions escape non-printable characters, but
--   print all printable characters:
--   
--   <pre>
--   &gt;&gt;&gt; pPrintString "\"A \\x42 Ä \\xC4 \\x1 \\n\""
--   "A B Ä Ä \x1
--   "
--   </pre>
--   
--   Here, you can see that the character <tt>A</tt> has been printed
--   as-is. <tt>x42</tt> has been printed in the non-escaped version,
--   <tt>B</tt>. The non-printable character <tt>x1</tt> has been printed
--   as <tt>x1</tt>. Newlines will be removed to make the output easier to
--   read.
--   
--   This corresponds to the <a>StringOutputStyle</a> called
--   <a>EscapeNonPrintable</a>.
--   
--   (Note that in the above and following examples, the characters have to
--   be double-escaped, which makes it somewhat confusing...)
--   
--   Another output style is <a>DoNotEscapeNonPrintable</a>. This is
--   similar to <a>EscapeNonPrintable</a>, except that non-printable
--   characters get printed out literally to the screen.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintStringOpt CheckColorTty defaultOutputOptionsDarkBg{ outputOptionsStringStyle = DoNotEscapeNonPrintable } "\"A \\x42 Ä \\xC4 \\n\""
--   "A B Ä Ä
--   "
--   </pre>
--   
--   If you change the above example to contain <tt>x1</tt>, you can see
--   that it is output as a literal, non-escaped character. Newlines are
--   still removed for readability.
--   
--   Another output style is <a>Literal</a>. This just outputs all escape
--   characters.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintStringOpt CheckColorTty defaultOutputOptionsDarkBg{ outputOptionsStringStyle = Literal } "\"A \\x42 Ä \\xC4 \\x1 \\n\""
--   "A \x42 Ä \xC4 \x1 \n"
--   </pre>
--   
--   You can see that all the escape characters get output literally,
--   including newline.
[outputOptionsStringStyle] :: OutputOptions -> StringOutputStyle

-- | Default values for <a>OutputOptions</a> when printing to a console
--   with a dark background. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>defaultColorOptionsDarkBg</a>.
defaultOutputOptionsDarkBg :: OutputOptions

-- | Default values for <a>OutputOptions</a> when printing to a console
--   with a light background. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>defaultColorOptionsLightBg</a>.
defaultOutputOptionsLightBg :: OutputOptions

-- | Default values for <a>OutputOptions</a> when printing using using ANSI
--   escape sequences for color. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>Nothing</a>.
defaultOutputOptionsNoColor :: OutputOptions

-- | Given <a>OutputOptions</a>, disable colorful output if the given
--   handle is not connected to a TTY.
hCheckTTY :: MonadIO m => Handle -> OutputOptions -> m OutputOptions

-- | Parse a string, and generate an intermediate representation, suitable
--   for passing to any <i>prettyprinter</i> backend. Used by
--   <a>pString</a> etc.
layoutString :: OutputOptions -> String -> SimpleDocStream Style
layoutStringAbstract :: OutputOptions -> String -> SimpleDocStream Annotation

-- | Slight adjustment of <a>prettyExprs</a> for the outermost level, to
--   avoid indenting everything.
prettyExprs' :: OutputOptions -> [Expr] -> Doc Annotation

-- | Construct a <a>Doc</a> from multiple <a>Expr</a>s.
prettyExprs :: OutputOptions -> [Expr] -> Doc Annotation

-- | Construct a <a>Doc</a> from a single <a>Expr</a>.
prettyExpr :: OutputOptions -> Expr -> Doc Annotation

-- | Determine whether this expression should be displayed on a single
--   line.
isSimple :: Expr -> Bool

-- | Traverse the stream, using a <a>Tape</a> to keep track of the current
--   style.
annotateStyle :: OutputOptions -> SimpleDocStream Annotation -> SimpleDocStream Style

-- | An abstract annotation type, representing the various elements we may
--   want to highlight.
data Annotation
Open :: Annotation
Close :: Annotation
Comma :: Annotation
Quote :: Annotation
String :: Annotation
Num :: Annotation

-- | Replace non-printable characters with hex escape sequences.
--   
--   <pre>
--   &gt;&gt;&gt; escapeNonPrintable "\x1\x2"
--   "\\x1\\x2"
--   </pre>
--   
--   Newlines will not be escaped.
--   
--   <pre>
--   &gt;&gt;&gt; escapeNonPrintable "hello\nworld"
--   "hello\nworld"
--   </pre>
--   
--   Printable characters will not be escaped.
--   
--   <pre>
--   &gt;&gt;&gt; escapeNonPrintable "h\101llo"
--   "hello"
--   </pre>
escapeNonPrintable :: String -> String

-- | Replace an unprintable character except a newline with a hex escape
--   sequence.
escape :: Char -> ShowS

-- | A bidirectional Turing-machine tape: infinite in both directions, with
--   a head pointing to one element.
data Tape a
Tape :: Stream a -> a -> Stream a -> Tape a

-- | the side of the <a>Tape</a> left of <a>tapeHead</a>
[tapeLeft] :: Tape a -> Stream a

-- | the focused element
[tapeHead] :: Tape a -> a

-- | the side of the <a>Tape</a> right of <a>tapeHead</a>
[tapeRight] :: Tape a -> Stream a

-- | Move the head left
moveL :: Tape a -> Tape a

-- | Move the head right
moveR :: Tape a -> Tape a

-- | An infinite list
data Stream a
(:..) :: a -> Stream a -> Stream a

-- | Analogous to <a>repeat</a>
streamRepeat :: t -> Stream t

-- | Analogous to <a>cycle</a> While the inferred signature here is more
--   general, it would diverge on an empty structure
streamCycle :: NonEmpty a -> Stream a
instance GHC.Show.Show Text.Pretty.Simple.Internal.Printer.CheckColorTty
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Printer.CheckColorTty
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Printer.CheckColorTty
instance GHC.Show.Show Text.Pretty.Simple.Internal.Printer.StringOutputStyle
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Printer.StringOutputStyle
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Printer.StringOutputStyle
instance GHC.Show.Show Text.Pretty.Simple.Internal.Printer.OutputOptions
instance GHC.Generics.Generic Text.Pretty.Simple.Internal.Printer.OutputOptions
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Printer.OutputOptions
instance GHC.Show.Show Text.Pretty.Simple.Internal.Printer.Annotation
instance GHC.Classes.Eq Text.Pretty.Simple.Internal.Printer.Annotation
instance GHC.Show.Show a => GHC.Show.Show (Text.Pretty.Simple.Internal.Printer.Stream a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Pretty.Simple.Internal.Printer.Tape a)


module Text.Pretty.Simple.Internal


-- | This module contains the functions <a>pPrint</a>, <a>pShow</a>, and
--   <a>pString</a> for pretty-printing any Haskell data type with a
--   <a>Show</a> instance.
--   
--   <a>pPrint</a> is the main go-to function when debugging Haskell code.
--   <a>pShow</a> and <a>pString</a> are slight variations on
--   <a>pPrint</a>.
--   
--   <a>pPrint</a>, <a>pShow</a>, and <a>pString</a> will pretty-print in
--   color using ANSI escape codes. They look good on a console with a dark
--   (black) background. The variations <a>pPrintLightBg</a>,
--   <a>pShowLightBg</a>, and <a>pStringLightBg</a> are for printing in
--   color to a console with a light (white) background. The variations
--   <a>pPrintNoColor</a>, <a>pShowNoColor</a>, and <a>pStringNoColor</a>
--   are for pretty-printing without using color.
--   
--   <a>pPrint</a> and <a>pPrintLightBg</a> will intelligently decide
--   whether or not to use ANSI escape codes for coloring depending on
--   whether or not the output is a TTY. This works in most cases. If you
--   want to force color output, you can use the <a>pPrintForceColor</a> or
--   <a>pPrintForceColorLightBg</a> functions.
--   
--   The variations <a>pPrintOpt</a>, <a>pShowOpt</a>, and
--   <a>pStringOpt</a> are used when specifying the <a>OutputOptions</a>.
--   Most users can ignore these.
--   
--   There are a few other functions available that are similar to
--   <a>pPrint</a>.
--   
--   See the Examples section at the end of this module for examples of
--   acutally using <a>pPrint</a>. See the <a>README.md</a> for examples of
--   printing in color.
module Text.Pretty.Simple

-- | Pretty-print any data type that has a <a>Show</a> instance.
--   
--   If you've never seen <a>MonadIO</a> before, you can think of this
--   function as having the following type signature:
--   
--   <pre>
--   pPrint :: Show a =&gt; a -&gt; IO ()
--   </pre>
--   
--   This function will only use colors if it detects it's printing to a
--   TTY.
--   
--   This function is for printing to a dark background. Use
--   <a>pPrintLightBg</a> for printing to a terminal with a light
--   background. Different colors are used.
--   
--   Prints to <a>stdout</a>. Use <a>pHPrint</a> to print to a different
--   <a>Handle</a>.
--   
--   <pre>
--   &gt;&gt;&gt; pPrint [Just (1, "hello")]
--   [ Just
--       ( 1
--       , "hello"
--       )
--   ]
--   </pre>
pPrint :: (MonadIO m, Show a) => a -> m ()

-- | Similar to <a>pPrint</a>, but take a <a>Handle</a> to print to.
--   
--   <pre>
--   &gt;&gt;&gt; pHPrint stdout [Just (1, "hello")]
--   [ Just
--       ( 1
--       , "hello"
--       )
--   ]
--   </pre>
pHPrint :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Similar to <a>pPrint</a>, but the first argument is a <a>String</a>
--   representing a data type that has already been <a>show</a>ed.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintString $ show [ Just (1, "hello"), Nothing ]
--   [ Just
--       ( 1
--       , "hello"
--       )
--   , Nothing
--   ]
--   </pre>
pPrintString :: MonadIO m => String -> m ()

-- | Similar to <a>pHPrintString</a>, but take a <a>Handle</a> to print to.
--   
--   <pre>
--   &gt;&gt;&gt; pHPrintString stdout $ show [ Just (1, "hello"), Nothing ]
--   [ Just
--       ( 1
--       , "hello"
--       )
--   , Nothing
--   ]
--   </pre>
pHPrintString :: MonadIO m => Handle -> String -> m ()

-- | Similar to <a>pPrint</a>, but print in color regardless of whether the
--   output goes to a TTY or not.
--   
--   See <a>pPrint</a> for an example of how to use this function.
pPrintForceColor :: (MonadIO m, Show a) => a -> m ()

-- | Similar to <a>pPrintForceColor</a>, but take a <a>Handle</a> to print
--   to.
--   
--   See <a>pHPrint</a> for an example of how to use this function.
pHPrintForceColor :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Similar to <a>pPrintString</a>, but print in color regardless of
--   whether the output goes to a TTY or not.
--   
--   See <a>pPrintString</a> for an example of how to use this function.
pPrintStringForceColor :: MonadIO m => String -> m ()

-- | Similar to <a>pHPrintString</a>, but print in color regardless of
--   whether the output goes to a TTY or not.
--   
--   See <a>pHPrintString</a> for an example of how to use this function.
pHPrintStringForceColor :: MonadIO m => Handle -> String -> m ()

-- | Similar to <a>pPrintForceColor</a>, but just return the resulting
--   pretty-printed data type as a <a>Text</a> instead of printing it to
--   the screen.
--   
--   This function is for printing to a dark background.
--   
--   See <a>pShowNoColor</a> for an example of how to use this function.
pShow :: Show a => a -> Text

-- | Similar to <a>pShow</a>, but the first argument is a <a>String</a>
--   representing a data type that has already been <a>show</a>ed.
--   
--   This will work on any <a>String</a> that is similar to a Haskell data
--   type. The only requirement is that the strings are quoted, and braces,
--   parentheses, and brackets are correctly used to represent indentation.
--   For example, <a>pString</a> will correctly pretty-print JSON.
--   
--   This function is for printing to a dark background.
--   
--   See <a>pStringNoColor</a> for an example of how to use this function.
pString :: String -> Text

-- | Alias for <a>pPrint</a>.
pPrintDarkBg :: (MonadIO m, Show a) => a -> m ()

-- | Alias for <a>pHPrint</a>.
pHPrintDarkBg :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Alias for <a>pPrintString</a>.
pPrintStringDarkBg :: MonadIO m => String -> m ()

-- | Alias for <a>pHPrintString</a>.
pHPrintStringDarkBg :: MonadIO m => Handle -> String -> m ()

-- | Alias for <a>pPrintForceColor</a>.
pPrintForceColorDarkBg :: (MonadIO m, Show a) => a -> m ()

-- | Alias for <a>pHPrintForceColor</a>.
pHPrintForceColorDarkBg :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Alias for <a>pPrintStringForceColor</a>.
pPrintStringForceColorDarkBg :: MonadIO m => String -> m ()

-- | Alias for <a>pHPrintStringForceColor</a>.
pHPrintStringForceColorDarkBg :: MonadIO m => Handle -> String -> m ()

-- | Alias for <a>pShow</a>.
pShowDarkBg :: Show a => a -> Text

-- | Alias for <a>pString</a>.
pStringDarkBg :: String -> Text

-- | Just like <a>pPrintDarkBg</a>, but for printing to a light background.
pPrintLightBg :: (MonadIO m, Show a) => a -> m ()

-- | Just like <a>pHPrintDarkBg</a>, but for printing to a light
--   background.
pHPrintLightBg :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Just like <a>pPrintStringDarkBg</a>, but for printing to a light
--   background.
pPrintStringLightBg :: MonadIO m => String -> m ()

-- | Just like <a>pHPrintStringDarkBg</a>, but for printing to a light
--   background.
pHPrintStringLightBg :: MonadIO m => Handle -> String -> m ()

-- | Just like <a>pPrintForceColorDarkBg</a>, but for printing to a light
--   background.
pPrintForceColorLightBg :: (MonadIO m, Show a) => a -> m ()

-- | Just like <a>pHPrintForceColorDarkBg</a>, but for printing to a light
--   background.
pHPrintForceColorLightBg :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Just like <a>pPrintStringForceColorDarkBg</a>, but for printing to a
--   light background.
pPrintStringForceColorLightBg :: MonadIO m => String -> m ()

-- | Just like <a>pHPrintStringForceColorDarkBg</a>, but for printing to a
--   light background.
pHPrintStringForceColorLightBg :: MonadIO m => Handle -> String -> m ()

-- | Just like <a>pShowDarkBg</a>, but for printing to a light background.
pShowLightBg :: Show a => a -> Text

-- | Just like <a>pStringDarkBg</a>, but for printing to a light
--   background.
pStringLightBg :: String -> Text

-- | Similar to <a>pPrint</a>, but doesn't print in color. However, data
--   types will still be indented nicely.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintNoColor $ Just ["hello", "bye"]
--   Just
--       [ "hello"
--       , "bye"
--       ]
--   </pre>
pPrintNoColor :: (MonadIO m, Show a) => a -> m ()

-- | Like <a>pPrintNoColor</a>, but take a <a>Handle</a> to determine where
--   to print to.
--   
--   <pre>
--   &gt;&gt;&gt; pHPrintNoColor stdout $ Just ["hello", "bye"]
--   Just
--       [ "hello"
--       , "bye"
--       ]
--   </pre>
pHPrintNoColor :: (MonadIO m, Show a) => Handle -> a -> m ()

-- | Similar to <a>pPrintString</a>, but doesn't print in color. However,
--   data types will still be indented nicely.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintStringNoColor $ show $ Just ["hello", "bye"]
--   Just
--       [ "hello"
--       , "bye"
--       ]
--   </pre>
pPrintStringNoColor :: MonadIO m => String -> m ()

-- | Like <a>pPrintStringNoColor</a>, but take a <a>Handle</a> to determine
--   where to print to.
--   
--   <pre>
--   &gt;&gt;&gt; pHPrintStringNoColor stdout $ show $ Just ["hello", "bye"]
--   Just
--       [ "hello"
--       , "bye"
--       ]
--   </pre>
pHPrintStringNoColor :: MonadIO m => Handle -> String -> m ()

-- | Like <a>pShow</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pShowNoColor [ Nothing, Just (1, "hello") ]
--   "[ Nothing\n, Just\n    ( 1\n    , \"hello\"\n    )\n]"
--   </pre>
pShowNoColor :: Show a => a -> Text

-- | LIke <a>pString</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pStringNoColor $ show [1, 2, 3]
--   "[ 1\n, 2\n, 3\n]"
--   </pre>
pStringNoColor :: String -> Text

-- | Similar to <a>pPrint</a> but takes <a>OutputOptions</a> to change how
--   the pretty-printing is done.
--   
--   For example, <a>pPrintOpt</a> can be used to make the indentation much
--   smaller than normal.
--   
--   This is what the normal indentation looks like:
--   
--   <pre>
--   &gt;&gt;&gt; pPrintOpt NoCheckColorTty defaultOutputOptionsNoColor $ Just ("hello", "bye")
--   Just
--       ( "hello"
--       , "bye"
--       )
--   </pre>
--   
--   This is what smaller indentation looks like:
--   
--   <pre>
--   &gt;&gt;&gt; let smallIndent = defaultOutputOptionsNoColor {outputOptionsIndentAmount = 1}
--   
--   &gt;&gt;&gt; pPrintOpt CheckColorTty smallIndent $ Just ("hello", "bye")
--   Just
--    ( "hello"
--    , "bye"
--    )
--   </pre>
--   
--   Lines in strings get indented
--   
--   <pre>
--   &gt;&gt;&gt; pPrintOpt NoCheckColorTty defaultOutputOptionsNoColor (1, (2, "foo\nbar\nbaz", 3))
--   ( 1
--   ,
--       ( 2
--       , "foo
--         bar
--         baz"
--       , 3
--       )
--   )
--   </pre>
--   
--   Lines get indented even in custom show instances
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo
--   
--   &gt;&gt;&gt; instance Show Foo where show _ = "foo\nbar\nbaz"
--   
--   &gt;&gt;&gt; pPrintOpt CheckColorTty defaultOutputOptionsNoColor (1, (2, Foo, 3))
--   ( 1
--   ,
--       ( 2
--       , foo
--         bar
--         baz
--       , 3
--       )
--   )
--   </pre>
--   
--   <a>CheckColorTty</a> determines whether to test <a>stdout</a> for
--   whether or not it is connected to a TTY.
--   
--   If set to <a>NoCheckColorTty</a>, then <a>pPrintOpt</a> won't check if
--   <a>stdout</a> is a TTY. It will print in color depending on the value
--   of <a>outputOptionsColorOptions</a>.
--   
--   If set to <a>CheckColorTty</a>, then <a>pPrintOpt</a> will check if
--   <a>stdout</a> is conneted to a TTY. If <a>stdout</a> is determined to
--   be connected to a TTY, then it will print in color depending on the
--   value of <a>outputOptionsColorOptions</a>. If <a>stdout</a> is
--   determined to NOT be connected to a TTY, then it will NOT print in
--   color, regardless of the value of <a>outputOptionsColorOptions</a>.
pPrintOpt :: (MonadIO m, Show a) => CheckColorTty -> OutputOptions -> a -> m ()

-- | Similar to <a>pPrintOpt</a>, but take a <a>Handle</a> to determine
--   where to print to.
pHPrintOpt :: (MonadIO m, Show a) => CheckColorTty -> OutputOptions -> Handle -> a -> m ()

-- | Similar to <a>pPrintOpt</a>, but the last argument is a string
--   representing a data structure that has already been <a>show</a>ed.
--   
--   <pre>
--   &gt;&gt;&gt; let foo = show (1, (2, "hello", 3))
--   
--   &gt;&gt;&gt; pPrintStringOpt CheckColorTty defaultOutputOptionsNoColor foo
--   ( 1
--   ,
--       ( 2
--       , "hello"
--       , 3
--       )
--   )
--   </pre>
pPrintStringOpt :: MonadIO m => CheckColorTty -> OutputOptions -> String -> m ()

-- | Similar to <a>pPrintStringOpt</a>, but take a <a>Handle</a> to
--   determine where to print to.
--   
--   <pre>
--   &gt;&gt;&gt; let foo = show (1, (2, "hello", 3))
--   
--   &gt;&gt;&gt; pHPrintStringOpt CheckColorTty defaultOutputOptionsNoColor stdout foo
--   ( 1
--   ,
--       ( 2
--       , "hello"
--       , 3
--       )
--   )
--   </pre>
pHPrintStringOpt :: MonadIO m => CheckColorTty -> OutputOptions -> Handle -> String -> m ()

-- | Like <a>pShow</a> but takes <a>OutputOptions</a> to change how the
--   pretty-printing is done.
pShowOpt :: Show a => OutputOptions -> a -> Text

-- | Like <a>pString</a> but takes <a>OutputOptions</a> to change how the
--   pretty-printing is done.
pStringOpt :: OutputOptions -> String -> Text

-- | Data-type wrapping up all the options available when rendering the
--   list of <tt>Output</tt>s.
data OutputOptions
OutputOptions :: Int -> Int -> Bool -> Bool -> Int -> Maybe ColorOptions -> StringOutputStyle -> OutputOptions

-- | Number of spaces to use when indenting. It should probably be either 2
--   or 4.
[outputOptionsIndentAmount] :: OutputOptions -> Int

-- | The maximum number of characters to fit on to one line.
[outputOptionsPageWidth] :: OutputOptions -> Int

-- | Use less vertical (and more horizontal) space.
[outputOptionsCompact] :: OutputOptions -> Bool

-- | Group closing parentheses on to a single line.
[outputOptionsCompactParens] :: OutputOptions -> Bool

-- | Indent the whole output by this amount.
[outputOptionsInitialIndent] :: OutputOptions -> Int

-- | If this is <a>Nothing</a>, then don't colorize the output. If this is
--   <tt><a>Just</a> colorOptions</tt>, then use <tt>colorOptions</tt> to
--   colorize the output.
[outputOptionsColorOptions] :: OutputOptions -> Maybe ColorOptions

-- | Controls how string literals are output.
--   
--   By default, the pPrint functions escape non-printable characters, but
--   print all printable characters:
--   
--   <pre>
--   &gt;&gt;&gt; pPrintString "\"A \\x42 Ä \\xC4 \\x1 \\n\""
--   "A B Ä Ä \x1
--   "
--   </pre>
--   
--   Here, you can see that the character <tt>A</tt> has been printed
--   as-is. <tt>x42</tt> has been printed in the non-escaped version,
--   <tt>B</tt>. The non-printable character <tt>x1</tt> has been printed
--   as <tt>x1</tt>. Newlines will be removed to make the output easier to
--   read.
--   
--   This corresponds to the <a>StringOutputStyle</a> called
--   <a>EscapeNonPrintable</a>.
--   
--   (Note that in the above and following examples, the characters have to
--   be double-escaped, which makes it somewhat confusing...)
--   
--   Another output style is <a>DoNotEscapeNonPrintable</a>. This is
--   similar to <a>EscapeNonPrintable</a>, except that non-printable
--   characters get printed out literally to the screen.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintStringOpt CheckColorTty defaultOutputOptionsDarkBg{ outputOptionsStringStyle = DoNotEscapeNonPrintable } "\"A \\x42 Ä \\xC4 \\n\""
--   "A B Ä Ä
--   "
--   </pre>
--   
--   If you change the above example to contain <tt>x1</tt>, you can see
--   that it is output as a literal, non-escaped character. Newlines are
--   still removed for readability.
--   
--   Another output style is <a>Literal</a>. This just outputs all escape
--   characters.
--   
--   <pre>
--   &gt;&gt;&gt; pPrintStringOpt CheckColorTty defaultOutputOptionsDarkBg{ outputOptionsStringStyle = Literal } "\"A \\x42 Ä \\xC4 \\x1 \\n\""
--   "A \x42 Ä \xC4 \x1 \n"
--   </pre>
--   
--   You can see that all the escape characters get output literally,
--   including newline.
[outputOptionsStringStyle] :: OutputOptions -> StringOutputStyle

-- | Control how escaped and non-printable are output for strings.
--   
--   See <a>outputOptionsStringStyle</a> for what the output looks like
--   with each of these options.
data StringOutputStyle

-- | Output string literals by printing the source characters exactly.
--   
--   For examples: without this option the printer will insert a newline in
--   place of <tt>"n"</tt>, with this options the printer will output
--   <tt>'\'</tt> and <tt><tt>n</tt></tt>. Similarly the exact escape codes
--   used in the input string will be replicated, so <tt>"65"</tt> will be
--   printed as <tt>"65"</tt> and not <tt><a>A</a></tt>.
Literal :: StringOutputStyle

-- | Replace non-printable characters with hexadecimal escape sequences.
EscapeNonPrintable :: StringOutputStyle

-- | Output non-printable characters without modification.
DoNotEscapeNonPrintable :: StringOutputStyle

-- | Default values for <a>OutputOptions</a> when printing to a console
--   with a dark background. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>defaultColorOptionsDarkBg</a>.
defaultOutputOptionsDarkBg :: OutputOptions

-- | Default values for <a>OutputOptions</a> when printing to a console
--   with a light background. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>defaultColorOptionsLightBg</a>.
defaultOutputOptionsLightBg :: OutputOptions

-- | Default values for <a>OutputOptions</a> when printing using using ANSI
--   escape sequences for color. <a>outputOptionsIndentAmount</a> is 4, and
--   <a>outputOptionsColorOptions</a> is <a>Nothing</a>.
defaultOutputOptionsNoColor :: OutputOptions

-- | Determines whether pretty-simple should check if the output
--   <a>Handle</a> is a TTY device. Normally, users only want to print in
--   color if the output <a>Handle</a> is a TTY device.
data CheckColorTty

-- | Check if the output <a>Handle</a> is a TTY device. If the output
--   <a>Handle</a> is a TTY device, determine whether to print in color
--   based on <a>outputOptionsColorOptions</a>. If not, then set
--   <a>outputOptionsColorOptions</a> to <a>Nothing</a> so the output does
--   not get colorized.
CheckColorTty :: CheckColorTty

-- | Don't check if the output <a>Handle</a> is a TTY device. Determine
--   whether to colorize the output based solely on the value of
--   <a>outputOptionsColorOptions</a>.
NoCheckColorTty :: CheckColorTty

-- | Default color options for use on a dark background.
defaultColorOptionsDarkBg :: ColorOptions

-- | Default color options for use on a light background.
defaultColorOptionsLightBg :: ColorOptions

-- | These options are for colorizing the output of functions like
--   <tt>pPrint</tt>.
--   
--   If you don't want to use a color for one of the options, use
--   <a>colorNull</a>.
data ColorOptions
ColorOptions :: Style -> Style -> Style -> Style -> [Style] -> ColorOptions

-- | Color to use for quote characters (<tt>"</tt>) around strings.
[colorQuote] :: ColorOptions -> Style

-- | Color to use for strings.
[colorString] :: ColorOptions -> Style

-- | Color for errors, e.g. unmatched brackets.
[colorError] :: ColorOptions -> Style

-- | Color to use for numbers.
[colorNum] :: ColorOptions -> Style

-- | A list of colors to use for rainbow parenthesis output. Use '[]' if
--   you don't want rainbow parenthesis. Use just a single item if you want
--   all the rainbow parenthesis to be colored the same.
[colorRainbowParens] :: ColorOptions -> [Style]

-- | Ways to style terminal output.
data Style
Style :: Maybe (Color, Intensity) -> Bool -> Bool -> Bool -> Style
[styleColor] :: Style -> Maybe (Color, Intensity)
[styleBold] :: Style -> Bool
[styleItalic] :: Style -> Bool
[styleUnderlined] :: Style -> Bool

-- | The 8 ANSI terminal colors.
data () => Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color

-- | Dull or vivid coloring, as supported by ANSI terminals.
data () => Intensity
Vivid :: Intensity
Dull :: Intensity

-- | No styling.
colorNull :: Style


-- | This module contains the same functionality with Prelude's
--   <a>Debug.Trace</a> module, with pretty printing the debug strings.
--   
--   Warning: This module also shares the same unsafety of
--   <a>Debug.Trace</a> module.
module Debug.Pretty.Simple

-- | The <a>pTrace</a> function pretty prints the trace message given as
--   its first argument, before returning the second argument as its
--   result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   pTrace ("calling f with x = " ++ show x) (f x)
--   </pre>
--   
--   The <a>pTrace</a> function should <i>only</i> be used for debugging,
--   or for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.

-- | <i>Warning: <a>pTrace</a> remains in code</i>
pTrace :: String -> a -> a

-- | Like <a>pTrace</a> but returns the message instead of a third value.

-- | <i>Warning: <a>pTraceId</a> remains in code</i>
pTraceId :: String -> String

-- | Like <a>pTrace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>z</tt>:
--   
--   <pre>
--   f x y =
--       pTraceShow (x, z) $ result
--     where
--       z = ...
--       ...
--   </pre>

-- | <i>Warning: <a>pTraceShow</a> remains in code</i>
pTraceShow :: Show a => a -> b -> b

-- | Like <a>pTraceShow</a> but returns the shown value instead of a third
--   value.

-- | <i>Warning: <a>pTraceShowId</a> remains in code</i>
pTraceShowId :: Show a => a -> a

-- | The <a>pTraceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.

-- | <i>Warning: <a>pTraceIO</a> remains in code</i>
pTraceIO :: String -> IO ()

-- | Like <a>pTrace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>pTraceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>pTraceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <tt>MonadIO</tt>, <tt>liftIO . pTraceIO</tt> may be a
--   better option.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     pTraceM $ "x: " ++ show x
--     y &lt;- ...
--     pTraceM $ "y: " ++ show y
--   </pre>

-- | <i>Warning: <a>pTraceM</a> remains in code</i>
pTraceM :: Applicative f => String -> f ()

-- | Like <a>pTraceM</a>, but uses <a>show</a> on the argument to convert
--   it to a <a>String</a>.
--   
--   <pre>
--   ... = do
--     x &lt;- ...
--     pTraceShowM $ x
--     y &lt;- ...
--     pTraceShowM $ x + y
--   </pre>

-- | <i>Warning: <a>pTraceShowM</a> remains in code</i>
pTraceShowM :: (Show a, Applicative f) => a -> f ()

-- | like <a>pTrace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>pTraceStack</a> behaves exactly like <a>pTrace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.

-- | <i>Warning: <a>pTraceStack</a> remains in code</i>
pTraceStack :: String -> a -> a

-- | The <a>pTraceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>pTraceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>pTraceEvent</a>.

-- | <i>Warning: <a>pTraceEvent</a> remains in code</i>
pTraceEvent :: String -> a -> a

-- | The <a>pTraceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>pTraceEvent</a>, <a>pTraceEventIO</a> sequences the
--   event with respect to other IO actions.

-- | <i>Warning: <a>pTraceEventIO</a> remains in code</i>
pTraceEventIO :: String -> IO ()

-- | The <a>pTraceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>pTraceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>pTraceMarker</a>.

-- | <i>Warning: <a>pTraceMarker</a> remains in code</i>
pTraceMarker :: String -> a -> a

-- | The <a>pTraceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>pTraceMarker</a>, <a>pTraceMarkerIO</a> sequences the
--   event with respect to other IO actions.

-- | <i>Warning: <a>pTraceMarkerIO</a> remains in code</i>
pTraceMarkerIO :: String -> IO ()

-- | The <a>pTraceWith</a> function pretty prints the result of applying
--   <tt>f to </tt>a and returns back @a
--   
--   @since ?

-- | <i>Warning: <a>pTraceWith</a> remains in code</i>
pTraceWith :: (a -> String) -> a -> a

-- | The <a>pTraceShowWith</a> function similar to <a>pTraceWith</a> except
--   that @f can return any type that implements Show
--   
--   @since ?

-- | <i>Warning: <a>pTraceShowWith</a> remains in code</i>
pTraceShowWith :: Show b => (a -> b) -> a -> a

-- | Similar to <a>pTrace</a>, but forcing color.

-- | <i>Warning: <a>pTraceForceColor</a> remains in code</i>
pTraceForceColor :: String -> a -> a

-- | Similar to <a>pTraceId</a>, but forcing color.

-- | <i>Warning: <a>pTraceIdForceColor</a> remains in code</i>
pTraceIdForceColor :: String -> String

-- | Similar to <a>pTraceShow</a>, but forcing color.

-- | <i>Warning: <a>pTraceShowForceColor</a> remains in code</i>
pTraceShowForceColor :: Show a => a -> b -> b

-- | Similar to <a>pTraceShowId</a>, but forcing color.

-- | <i>Warning: <a>pTraceShowIdForceColor</a> remains in code</i>
pTraceShowIdForceColor :: Show a => a -> a

-- | Similar to <a>pTraceM</a>, but forcing color.

-- | <i>Warning: <a>pTraceMForceColor</a> remains in code</i>
pTraceMForceColor :: Applicative f => String -> f ()

-- | Similar to <a>pTraceShowM</a>, but forcing color.

-- | <i>Warning: <a>pTraceShowMForceColor</a> remains in code</i>
pTraceShowMForceColor :: (Show a, Applicative f) => a -> f ()

-- | Similar to <a>pTraceStack</a>, but forcing color.

-- | <i>Warning: <a>pTraceStackForceColor</a> remains in code</i>
pTraceStackForceColor :: String -> a -> a

-- | Similar to <a>pTraceEvent</a>, but forcing color.

-- | <i>Warning: <a>pTraceEventForceColor</a> remains in code</i>
pTraceEventForceColor :: String -> a -> a

-- | Similar to <a>pTraceEventIO</a>, but forcing color.

-- | <i>Warning: <a>pTraceEventIOForceColor</a> remains in code</i>
pTraceEventIOForceColor :: String -> IO ()

-- | Similar to <a>pTraceMarker</a>, but forcing color.

-- | <i>Warning: <a>pTraceMarkerForceColor</a> remains in code</i>
pTraceMarkerForceColor :: String -> a -> a

-- | Similar to <a>pTraceMarkerIO</a>, but forcing color.

-- | <i>Warning: <a>pTraceMarkerIOForceColor</a> remains in code</i>
pTraceMarkerIOForceColor :: String -> IO ()

-- | Similar to <a>pTraceIO</a>, but forcing color.

-- | <i>Warning: <a>pTraceIOForceColor</a> remains in code</i>
pTraceIOForceColor :: String -> IO ()

-- | Similar to <a>pTrace</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceNoColor "wow" ()
--   wow
--   ()
--   </pre>

-- | <i>Warning: <a>pTraceNoColor</a> remains in code</i>
pTraceNoColor :: String -> a -> a

-- | Similar to <a>pTraceId</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceIdNoColor "(1, 2, 3)" `seq` ()
--   ( 1
--   , 2
--   , 3
--   )
--   ()
--   </pre>

-- | <i>Warning: <a>pTraceIdNoColor</a> remains in code</i>
pTraceIdNoColor :: String -> String

-- | Similar to <a>pTraceShow</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as M
--   
--   &gt;&gt;&gt; pTraceShowNoColor (M.fromList [(1, True)]) ()
--   fromList
--       [
--           ( 1
--           , True
--           )
--       ]
--   ()
--   </pre>

-- | <i>Warning: <a>pTraceShowNoColor</a> remains in code</i>
pTraceShowNoColor :: Show a => a -> b -> b

-- | Similar to <a>pTraceShowId</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as M
--   
--   &gt;&gt;&gt; pTraceShowIdNoColor (M.fromList [(1, True)]) `seq` ()
--   fromList
--       [
--           ( 1
--           , True
--           )
--       ]
--   ()
--   </pre>

-- | <i>Warning: <a>pTraceShowIdNoColor</a> remains in code</i>
pTraceShowIdNoColor :: Show a => a -> a

-- | Similar to <a>pTraceM</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceMNoColor "wow"
--   wow
--   </pre>

-- | <i>Warning: <a>pTraceMNoColor</a> remains in code</i>
pTraceMNoColor :: Applicative f => String -> f ()

-- | Similar to <a>pTraceShowM</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceShowMNoColor [1,2,3]
--   [ 1
--   , 2
--   , 3
--   ]
--   </pre>

-- | <i>Warning: <a>pTraceShowMNoColor</a> remains in code</i>
pTraceShowMNoColor :: (Show a, Applicative f) => a -> f ()

-- | Similar to <a>pTraceStack</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceStackNoColor "wow" () `seq` ()
--   wow
--   ()
--   </pre>

-- | <i>Warning: <a>pTraceStackNoColor</a> remains in code</i>
pTraceStackNoColor :: String -> a -> a

-- | Similar to <a>pTraceEvent</a>, but without color.

-- | <i>Warning: <a>pTraceEventNoColor</a> remains in code</i>
pTraceEventNoColor :: String -> a -> a

-- | Similar to <a>pTraceEventIO</a>, but without color.

-- | <i>Warning: <a>pTraceEventIONoColor</a> remains in code</i>
pTraceEventIONoColor :: String -> IO ()

-- | Similar to <a>pTraceMarker</a>, but without color.

-- | <i>Warning: <a>pTraceMarkerNoColor</a> remains in code</i>
pTraceMarkerNoColor :: String -> a -> a

-- | Similar to <a>pTraceMarkerIO</a>, but without color.

-- | <i>Warning: <a>pTraceMarkerIONoColor</a> remains in code</i>
pTraceMarkerIONoColor :: String -> IO ()

-- | Similar to <a>pTraceIO</a>, but without color.
--   
--   <pre>
--   &gt;&gt;&gt; pTraceIONoColor "(1, 2, 3)"
--   ( 1
--   , 2
--   , 3
--   )
--   </pre>

-- | <i>Warning: <a>pTraceIONoColor</a> remains in code</i>
pTraceIONoColor :: String -> IO ()

-- | Like <a>pTrace</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceOpt</a> remains in code</i>
pTraceOpt :: CheckColorTty -> OutputOptions -> String -> a -> a

-- | Like <a>pTraceId</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceIdOpt</a> remains in code</i>
pTraceIdOpt :: CheckColorTty -> OutputOptions -> String -> String

-- | Like <a>pTraceShow</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceShowOpt</a> remains in code</i>
pTraceShowOpt :: Show a => CheckColorTty -> OutputOptions -> a -> b -> b

-- | Like <a>pTraceShowId</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceShowIdOpt</a> remains in code</i>
pTraceShowIdOpt :: Show a => CheckColorTty -> OutputOptions -> a -> a

-- | Like <a>pTraceIO</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceOptIO</a> remains in code</i>
pTraceOptIO :: CheckColorTty -> OutputOptions -> String -> IO ()

-- | Like <a>pTraceM</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceOptM</a> remains in code</i>
pTraceOptM :: Applicative f => CheckColorTty -> OutputOptions -> String -> f ()

-- | Like <a>pTraceShowM</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceShowOptM</a> remains in code</i>
pTraceShowOptM :: (Show a, Applicative f) => CheckColorTty -> OutputOptions -> a -> f ()

-- | Like <a>pTraceStack</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceStackOpt</a> remains in code</i>
pTraceStackOpt :: CheckColorTty -> OutputOptions -> String -> a -> a

-- | Like <a>pTraceEvent</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceEventOpt</a> remains in code</i>
pTraceEventOpt :: CheckColorTty -> OutputOptions -> String -> a -> a

-- | Like <a>pTraceEventIO</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceEventOptIO</a> remains in code</i>
pTraceEventOptIO :: CheckColorTty -> OutputOptions -> String -> IO ()

-- | Like <a>pTraceMarker</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceMarkerOpt</a> remains in code</i>
pTraceMarkerOpt :: CheckColorTty -> OutputOptions -> String -> a -> a

-- | Like <a>pTraceMarkerIO</a> but takes OutputOptions.

-- | <i>Warning: <a>pTraceMarkerOptIO</a> remains in code</i>
pTraceMarkerOptIO :: CheckColorTty -> OutputOptions -> String -> IO ()
