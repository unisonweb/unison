-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util-rope
@version 0.0.0

module Unison.Util.Rope
chunks :: Rope a -> [a]
singleton :: Sized a => a -> Rope a
one :: Sized a => a -> Rope a
map :: Sized b => (a -> b) -> Rope a -> Rope b
traverse :: (Applicative f, Sized b) => (a -> f b) -> Rope a -> f (Rope b)
null :: Sized a => Rope a -> Bool
flatten :: Monoid a => Rope a -> a
two :: Sized a => Rope a -> Rope a -> Rope a
cons :: (Sized a, Semigroup a) => a -> Rope a -> Rope a
uncons :: Sized a => Rope a -> Maybe (a, Rope a)
snoc :: (Sized a, Semigroup a) => Rope a -> a -> Rope a
unsnoc :: Sized a => Rope a -> Maybe (Rope a, a)
index :: (Sized a, Index a ch) => Int -> Rope a -> Maybe ch
debugDepth :: Rope a -> Int
class Sized a
size :: Sized a => a -> Int
class Take a
take :: Take a => Int -> a -> a
class Drop a
drop :: Drop a => Int -> a -> a
class Reverse a
reverse :: Reverse a => a -> a
class Index a elem
unsafeIndex :: Index a elem => Int -> a -> elem

-- | Roughly size-balanced binary tree of chunks. There are a few
--   operations that are sloppier about rebalancing as long as that can't
--   lead to trees of more than logarithmic depth.
--   
--   The <a>Int</a> in the <a>Two</a> constructor is a cached size of that
--   subtree.
data Rope a
instance Data.Foldable.Foldable Unison.Util.Rope.Rope
instance Unison.Util.Rope.Reverse a => Unison.Util.Rope.Reverse (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Index a ch) => Unison.Util.Rope.Index (Unison.Util.Rope.Rope a) ch
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a, Unison.Util.Rope.Drop a) => Unison.Util.Rope.Drop (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Take a, Unison.Util.Rope.Drop a, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, Unison.Util.Rope.Take a, Unison.Util.Rope.Drop a, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a, Unison.Util.Rope.Take a) => Unison.Util.Rope.Take (Unison.Util.Rope.Rope a)
instance Unison.Util.Rope.Sized a => Unison.Util.Rope.Sized (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Unison.Util.Rope.Rope a)
instance (Unison.Util.Rope.Sized a, GHC.Base.Semigroup a) => GHC.Base.Monoid (Unison.Util.Rope.Rope a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Unison.Util.Rope.Rope a)
