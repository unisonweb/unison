-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An either-or-both data type.
--   
--   This package provides a data type <tt>These a b</tt> which can hold a
--   value of either type or values of each type. This is usually thought
--   of as an "inclusive or" type (contrasting <tt>Either a b</tt> as
--   "exclusive or") or as an "outer join" type (contrasting <tt>(a,
--   b)</tt> as "inner join").
--   
--   <pre>
--   data These a b = This a | That b | These a b
--   </pre>
--   
--   Since version 1, this package was split into parts:
--   
--   <ul>
--   <li><a>semialign</a> For <tt>Align</tt> and <tt>Zip</tt>
--   type-classes.</li>
--   <li><a>semialign-indexed</a> For <tt>SemialignWithIndex</tt> class,
--   providing <tt>ialignWith</tt> and <tt>izipWith</tt>.</li>
--   <li><a>these-lens</a> For lens combinators.</li>
--   <li><a>monad-chronicle</a> For transformers variant of
--   <tt>These</tt>.</li>
--   </ul>
@package these
@version 1.2.1

module Data.Functor.These
data These1 f g a
This1 :: f a -> These1 f g a
That1 :: g a -> These1 f g a
These1 :: f a -> g a -> These1 f g a
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable a, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.These.These1 f g a)
instance GHC.Generics.Generic1 (Data.Functor.These.These1 f g)
instance GHC.Generics.Generic (Data.Functor.These.These1 f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.These.These1 f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.These.These1 f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.These.These1 f g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.These.These1 f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.These.These1 f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.These.These1 f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.These.These1 f g)
instance (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a), GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.These.These1 f g a)
instance (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a), GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.These.These1 f g a)
instance (GHC.Show.Show (f a), GHC.Show.Show (g a), GHC.Show.Show a) => GHC.Show.Show (Data.Functor.These.These1 f g a)
instance (GHC.Read.Read (f a), GHC.Read.Read (g a), GHC.Read.Read a) => GHC.Read.Read (Data.Functor.These.These1 f g a)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.These.These1 f g)
instance (Control.DeepSeq.NFData (f a), Control.DeepSeq.NFData (g a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Functor.These.These1 f g a)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.These.These1 f g)


-- | The <a>These</a> type and associated operations.
module Data.These

-- | The <a>These</a> type represents values with two non-exclusive
--   possibilities.
--   
--   This can be useful to represent combinations of two values, where the
--   combination is defined if either input is. Algebraically, the type
--   <tt><a>These</a> A B</tt> represents <tt>(A + B + AB)</tt>, which
--   doesn't factor easily into sums and products--a type like
--   <tt><a>Either</a> A (B, <tt>Maybe</tt> A)</tt> is unclear and awkward
--   to use.
--   
--   <a>These</a> has straightforward instances of <a>Functor</a>,
--   <a>Monad</a>, &amp;c., and behaves like a hybrid error/writer monad,
--   as would be expected.
--   
--   For zipping and unzipping of structures with <a>These</a> values, see
--   <a>Data.Align</a>.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b

-- | Case analysis for the <a>These</a> type.
these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c

-- | Takes two default values and produces a tuple.
fromThese :: a -> b -> These a b -> (a, b)

-- | Coalesce with the provided operation.
mergeThese :: (a -> a -> a) -> These a a -> a

-- | <a>bimap</a> and coalesce results with the provided operation.
mergeTheseWith :: (a -> c) -> (b -> c) -> (c -> c -> c) -> These a b -> c

-- | Select each constructor and partition them into separate lists.
partitionThese :: [These a b] -> ([a], [b], [(a, b)])

-- | Select <tt>here</tt> and <tt>there</tt> elements and partition them
--   into separate lists.
partitionHereThere :: [These a b] -> ([a], [b])

-- | Like <a>partitionEithers</a> but for <a>NonEmpty</a> types.
--   
--   <ul>
--   <li>either all are <a>Left</a></li>
--   <li>either all are <a>Right</a></li>
--   <li>or there is both <a>Left</a> and <a>Right</a> stuff</li>
--   </ul>
--   
--   <i>Note:</i> this is not online algorithm. In the worst case it will
--   traverse the whole list before deciding the result constructor.
--   
--   <pre>
--   &gt;&gt;&gt; partitionEithersNE $ Left 'x' :| [Right 'y']
--   These ('x' :| "") ('y' :| "")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partitionEithersNE $ Left 'x' :| map Left "yz"
--   This ('x' :| "yz")
--   </pre>
partitionEithersNE :: NonEmpty (Either a b) -> These (NonEmpty a) (NonEmpty b)
distrThesePair :: These (a, b) c -> (These a c, These b c)
undistrThesePair :: (These a c, These b c) -> These (a, b) c
distrPairThese :: (These a b, c) -> These (a, c) (b, c)
undistrPairThese :: These (a, c) (b, c) -> (These a b, c)
instance GHC.Generics.Generic1 (Data.These.These a)
instance GHC.Generics.Generic (Data.These.These a b)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.These.These a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.These.These a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.These.These a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.These.These a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.These.These a b)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (Data.These.These a b)
instance GHC.Base.Functor (Data.These.These a)
instance Data.Foldable.Foldable (Data.These.These a)
instance Data.Traversable.Traversable (Data.These.These a)
instance Data.Bifunctor.Bifunctor Data.These.These
instance Data.Bifoldable.Bifoldable Data.These.These
instance Data.Bifoldable1.Bifoldable1 Data.These.These
instance Data.Bitraversable.Bitraversable Data.These.These
instance GHC.Base.Semigroup a => GHC.Base.Applicative (Data.These.These a)
instance GHC.Base.Semigroup a => GHC.Base.Monad (Data.These.These a)
instance Data.Functor.Classes.Eq2 Data.These.These
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.These.These a)
instance Data.Functor.Classes.Ord2 Data.These.These
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.These.These a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.These.These a)
instance Data.Functor.Classes.Show2 Data.These.These
instance Data.Functor.Classes.Read2 Data.These.These
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.These.These a)
instance Data.Bifunctor.Swap.Swap Data.These.These
instance Data.Bifunctor.Assoc.Assoc Data.These.These
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.These.These a b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Data.These.These a)
instance Control.DeepSeq.NFData2 Data.These.These
instance (Data.Binary.Class.Binary a, Data.Binary.Class.Binary b) => Data.Binary.Class.Binary (Data.These.These a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (Data.These.These a b)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable1 (Data.These.These a)
instance Data.Hashable.Class.Hashable2 Data.These.These


-- | This module provides
--   
--   <ul>
--   <li>specialised versions of class members e.g.
--   <a>bitraverseThese</a></li>
--   <li>non-lens variants of <a>Data.These.Lens</a> things, e.g
--   <a>justHere</a></li>
--   </ul>
module Data.These.Combinators

-- | <tt>Bifunctor</tt> <a>bimap</a>.
bimapThese :: (a -> c) -> (b -> d) -> These a b -> These c d

-- | <pre>
--   <a>mapHere</a> = <a>over</a> <tt>here</tt>
--   </pre>
mapHere :: (a -> c) -> These a b -> These c b

-- | <pre>
--   <a>mapThere</a> = <a>over</a> <tt>there</tt>
--   </pre>
mapThere :: (b -> d) -> These a b -> These a d

-- | <tt>Bitraversable</tt> <a>bitraverse</a>.
bitraverseThese :: Applicative f => (a -> f c) -> (b -> f d) -> These a b -> f (These c d)

-- | <a>These</a> is commutative.
--   
--   <pre>
--   <a>swapThese</a> . <a>swapThese</a> = <tt>id</tt>
--   </pre>
swapThese :: These a b -> These b a

-- | <a>These</a> is associative.
--   
--   <pre>
--   <a>assocThese</a> . <a>unassocThese</a> = <tt>id</tt>
--   <a>unassocThese</a> . <a>assocThese</a> = <tt>id</tt>
--   </pre>
assocThese :: These (These a b) c -> These a (These b c)

-- | <a>These</a> is associative. See <a>assocThese</a>.
unassocThese :: These a (These b c) -> These (These a b) c
justThis :: These a b -> Maybe a
justThat :: These a b -> Maybe b
justThese :: These a b -> Maybe (a, b)

-- | <pre>
--   &gt;&gt;&gt; justHere (This 'x')
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justHere (That 'y')
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justHere (These 'x' 'y')
--   Just 'x'
--   </pre>
justHere :: These a b -> Maybe a

-- | <pre>
--   &gt;&gt;&gt; justThere (This 'x')
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justThere (That 'y')
--   Just 'y'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; justThere (These 'x' 'y')
--   Just 'y'
--   </pre>
justThere :: These a b -> Maybe b

-- | Select all <a>This</a> constructors from a list.
catThis :: [These a b] -> [a]

-- | Select all <a>That</a> constructors from a list.
catThat :: [These a b] -> [b]

-- | Select all <a>These</a> constructors from a list.
catThese :: [These a b] -> [(a, b)]
catHere :: [These a b] -> [a]
catThere :: [These a b] -> [b]

-- | <pre>
--   <a>isThis</a> = <a>isJust</a> . <a>justThis</a>
--   </pre>
isThis :: These a b -> Bool

-- | <pre>
--   <a>isThat</a> = <a>isJust</a> . <a>justThat</a>
--   </pre>
isThat :: These a b -> Bool

-- | <pre>
--   <a>isThese</a> = <a>isJust</a> . <a>justThese</a>
--   </pre>
isThese :: These a b -> Bool

-- | <pre>
--   <a>hasHere</a> = <a>isJust</a> . <a>justHere</a>
--   </pre>
hasHere :: These a b -> Bool

-- | <pre>
--   <a>hasThere</a> = <a>isJust</a> . <a>justThere</a>
--   </pre>
hasThere :: These a b -> Bool
mapThis :: (a -> a) -> These a b -> These a b
mapThat :: (b -> b) -> These a b -> These a b
mapThese :: ((a, b) -> (a, b)) -> These a b -> These a b
