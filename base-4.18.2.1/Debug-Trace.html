<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Debug.Trace</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">base-4.18.2.1: Core data structures and operations</span><ul class="links" id="page-menu"><li><a href="src/Debug.Trace.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) The University of Glasgow 2001</td></tr><tr><th>License</th><td>BSD-style (see the file libraries/base/LICENSE)</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Unsafe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Debug.Trace</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Tracing</a></li><li><a href="#g:2">Eventlog tracing</a></li><li><a href="#g:3">Execution phase markers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Functions for tracing and monitoring execution.</p><p>These can be useful for investigating bugs or performance problems.
 They should <em>not</em> be used in production code.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:trace">trace</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceId">traceId</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:traceShow">traceShow</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; a -&gt; b -&gt; b</li><li class="src short"><a href="#v:traceShowId">traceShowId</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; a -&gt; a</li><li class="src short"><a href="#v:traceWith">traceWith</a> :: (a -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceShowWith">traceShowWith</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> b =&gt; (a -&gt; b) -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceStack">traceStack</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceIO">traceIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:traceM">traceM</a> :: <a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; f ()</li><li class="src short"><a href="#v:traceShowM">traceShowM</a> :: (<a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a, <a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; a -&gt; f ()</li><li class="src short"><a href="#v:putTraceMsg">putTraceMsg</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:traceEvent">traceEvent</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceEventWith">traceEventWith</a> :: (a -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceEventIO">traceEventIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:flushEventLog">flushEventLog</a> :: <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:traceMarker">traceMarker</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:traceMarkerIO">traceMarkerIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Tracing</h1></a><div class="doc"><p>The <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code>, <code><a href="Debug-Trace.html#v:traceShow" title="Debug.Trace">traceShow</a></code> and <code><a href="Debug-Trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> functions print messages to an output
 stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow
 of execution and printing interesting values.</p><p>All these functions evaluate the message completely before printing
 it; so if the message is not fully defined, none of it will be
 printed.</p><p>The usual output stream is <code><a href="System-IO.html#v:stderr" title="System.IO">stderr</a></code>. For Windows GUI applications
 (that have no stderr) the output is directed to the Windows debug console.
 Some implementations of these functions may decorate the string that's
 output to indicate that you're tracing.</p></div><div class="top"><p class="src"><a id="v:trace" class="def">trace</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="src/Debug.Trace.html#trace" class="link">Source</a> <a href="#v:trace" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code> function outputs the trace message given as its first argument,
before returning the second argument as its result.</p><p>For example, this returns the value of <code>f x</code> and outputs the message to stderr.
Depending on your terminal (settings), they may or may not be mixed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let x = 123; f = show
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>trace (&quot;calling f with x = &quot; ++ show x) (f x)
</code></strong>calling f with x = 123
&quot;123&quot;
</pre><p>The <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code> function should <em>only</em> be used for debugging, or for monitoring
execution. The function is not referentially transparent: its type indicates
that it is a pure function but it has the side effect of outputting the
trace message.</p></div></div><div class="top"><p class="src"><a id="v:traceId" class="def">traceId</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a> <a href="src/Debug.Trace.html#traceId" class="link">Source</a> <a href="#v:traceId" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code> but returns the message instead of a third value.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traceId &quot;hello&quot;
</code></strong>hello
&quot;hello&quot;
</pre><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceShow" class="def">traceShow</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; a -&gt; b -&gt; b <a href="src/Debug.Trace.html#traceShow" class="link">Source</a> <a href="#v:traceShow" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code>, but uses <code><a href="Text-Show.html#v:show" title="Text.Show">show</a></code> on the argument to convert it to a <code><a href="Data-String.html#t:String" title="Data.String">String</a></code>.</p><p>This makes it convenient for printing the values of interesting variables or
expressions inside a function. For example here we print the value of the
variables <code>x</code> and <code>y</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f x y = traceShow (x,y) (x + y) in f (1+2) 5
</code></strong>(3,5)
8
</pre></div></div><div class="top"><p class="src"><a id="v:traceShowId" class="def">traceShowId</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; a -&gt; a <a href="src/Debug.Trace.html#traceShowId" class="link">Source</a> <a href="#v:traceShowId" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:traceShow" title="Debug.Trace">traceShow</a></code> but returns the shown value instead of a third value.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traceShowId (1+2+3, &quot;hello&quot; ++ &quot;world&quot;)
</code></strong>(6,&quot;helloworld&quot;)
(6,&quot;helloworld&quot;)
</pre><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceWith" class="def">traceWith</a> :: (a -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceWith" class="link">Source</a> <a href="#v:traceWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code>, but outputs the result of calling a function on the argument.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traceWith fst (&quot;hello&quot;,&quot;world&quot;)
</code></strong>hello
(&quot;hello&quot;,&quot;world&quot;)
</pre><p><em>Since: base-4.18.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceShowWith" class="def">traceShowWith</a> :: <a href="Text-Show.html#t:Show" title="Text.Show">Show</a> b =&gt; (a -&gt; b) -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceShowWith" class="link">Source</a> <a href="#v:traceShowWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:traceWith" title="Debug.Trace">traceWith</a></code>, but uses <code><a href="Text-Show.html#v:show" title="Text.Show">show</a></code> on the result of the function to convert it to
a <code><a href="Data-String.html#t:String" title="Data.String">String</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traceShowWith length [1,2,3]
</code></strong>3
[1,2,3]
</pre><p><em>Since: base-4.18.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceStack" class="def">traceStack</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceStack" class="link">Source</a> <a href="#v:traceStack" class="selflink">#</a></p><div class="doc"><p>like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code>, but additionally prints a call stack if one is
 available.</p><p>In the current GHC implementation, the call stack is only
 available if the program was compiled with <code>-prof</code>; otherwise
 <code><a href="Debug-Trace.html#v:traceStack" title="Debug.Trace">traceStack</a></code> behaves exactly like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code>.  Entries in the call
 stack correspond to <code>SCC</code> annotations, so it is a good idea to use
 <code>-fprof-auto</code> or <code>-fprof-auto-calls</code> to add SCC annotations automatically.</p><p><em>Since: base-4.5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceIO" class="def">traceIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Debug.Trace.html#traceIO" class="link">Source</a> <a href="#v:traceIO" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> function outputs the trace message from the IO monad.
 This sequences the output with respect to other IO actions.</p><p><em>Since: base-4.5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceM" class="def">traceM</a> :: <a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; f () <a href="src/Debug.Trace.html#traceM" class="link">Source</a> <a href="#v:traceM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code> but returning unit in an arbitrary <code><a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context. Allows
for convenient use in do-notation.</p><p>Note that the application of <code><a href="Debug-Trace.html#v:traceM" title="Debug.Trace">traceM</a></code> is not an action in the <code><a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>
context, as <code><a href="Debug-Trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code> is in the <code><a href="System-IO.html#t:IO" title="System.IO">IO</a></code> type. While the fresh bindings in the
following example will force the <code><a href="Debug-Trace.html#v:traceM" title="Debug.Trace">traceM</a></code> expressions to be reduced every time
the <code>do</code>-block is executed, <code>traceM &quot;not crashed&quot;</code> would only be reduced once,
and the message would only be printed once.  If your monad is in
<code><a href="Control-Monad-IO-Class.html#v:MonadIO" title="Control.Monad.IO.Class">MonadIO</a></code>, <code><code><a href="Control-Monad-IO-Class.html#v:liftIO" title="Control.Monad.IO.Class">liftIO</a></code> . <code><a href="Debug-Trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code></code>
may be a better option.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>do
    x &lt;- Just 3
    traceM (&quot;x: &quot; ++ show x)
    y &lt;- pure 12
    traceM (&quot;y: &quot; ++ show y)
    pure (x*2 + y)
:}
x: 3
y: 12
Just 18
</pre><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceShowM" class="def">traceShowM</a> :: (<a href="Text-Show.html#t:Show" title="Text.Show">Show</a> a, <a href="Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; a -&gt; f () <a href="src/Debug.Trace.html#traceShowM" class="link">Source</a> <a href="#v:traceShowM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:traceM" title="Debug.Trace">traceM</a></code>, but uses <code><a href="Text-Show.html#v:show" title="Text.Show">show</a></code> on the argument to convert it to a <code><a href="Data-String.html#t:String" title="Data.String">String</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>do
    x &lt;- Just 3
    traceShowM x
    y &lt;- pure 12
    traceShowM y
    pure (x*2 + y)
:}
3
12
Just 18
</pre><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:putTraceMsg" class="def">putTraceMsg</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Debug.Trace.html#putTraceMsg" class="link">Source</a> <a href="#v:putTraceMsg" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use <code><a href="Debug-Trace.html#v:traceIO" title="Debug.Trace">traceIO</a></code></p></div></div></div><a href="#g:2" id="g:2"><h1>Eventlog tracing</h1></a><div class="doc"><p>Eventlog tracing is a performance profiling system. These functions emit
 extra events into the eventlog. In combination with eventlog profiling
 tools these functions can be used for monitoring execution and
 investigating performance problems.</p><p>Currently only GHC provides eventlog profiling, see the GHC user guide for
 details on how to use it. These function exists for other Haskell
 implementations but no events are emitted. Note that the string message is
 always evaluated, whether or not profiling is available or enabled.</p></div><div class="top"><p class="src"><a id="v:traceEvent" class="def">traceEvent</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceEvent" class="link">Source</a> <a href="#v:traceEvent" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code> function behaves like <code><a href="Debug-Trace.html#v:trace" title="Debug.Trace">trace</a></code> with the difference that
 the message is emitted to the eventlog, if eventlog profiling is available
 and enabled at runtime.</p><p>It is suitable for use in pure code. In an IO context use <code><a href="Debug-Trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code>
 instead.</p><p>Note that when using GHC's SMP runtime, it is possible (but rare) to get
 duplicate events emitted if two CPUs simultaneously evaluate the same thunk
 that uses <code><a href="Debug-Trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>.</p><p><em>Since: base-4.5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceEventWith" class="def">traceEventWith</a> :: (a -&gt; <a href="Data-String.html#t:String" title="Data.String">String</a>) -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceEventWith" class="link">Source</a> <a href="#v:traceEventWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Debug-Trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>, but emits the result of calling a function on its
 argument.</p><p><em>Since: base-4.18.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceEventIO" class="def">traceEventIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Debug.Trace.html#traceEventIO" class="link">Source</a> <a href="#v:traceEventIO" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code> function emits a message to the eventlog, if eventlog
 profiling is available and enabled at runtime.</p><p>Compared to <code><a href="Debug-Trace.html#v:traceEvent" title="Debug.Trace">traceEvent</a></code>, <code><a href="Debug-Trace.html#v:traceEventIO" title="Debug.Trace">traceEventIO</a></code> sequences the event with respect to
 other IO actions.</p><p><em>Since: base-4.5.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:flushEventLog" class="def">flushEventLog</a> :: <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Debug.Trace.html#flushEventLog" class="link">Source</a> <a href="#v:flushEventLog" class="selflink">#</a></p><div class="doc"><p>Immediately flush the event log, if enabled.</p><p><em>Since: base-4.15.0.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Execution phase markers</h1></a><div class="doc"><p>When looking at a profile for the execution of a program we often want to
 be able to mark certain points or phases in the execution and see that
 visually in the profile.</p><p>For example, a program might have several distinct phases with different
 performance or resource behaviour in each phase. To properly interpret the
 profile graph we really want to see when each phase starts and ends.</p><p>Markers let us do this: we can annotate the program to emit a marker at
 an appropriate point during execution and then see that in a profile.</p><p>Currently this feature is only supported in GHC by the eventlog tracing
 system, but in future it may also be supported by the heap profiling or
 other profiling tools. These function exists for other Haskell
 implementations but they have no effect. Note that the string message is
 always evaluated, whether or not profiling is available or enabled.</p></div><div class="top"><p class="src"><a id="v:traceMarker" class="def">traceMarker</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; a -&gt; a <a href="src/Debug.Trace.html#traceMarker" class="link">Source</a> <a href="#v:traceMarker" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code> function emits a marker to the eventlog, if eventlog
 profiling is available and enabled at runtime. The <code>String</code> is the name of
 the marker. The name is just used in the profiling tools to help you keep
 clear which marker is which.</p><p>This function is suitable for use in pure code. In an IO context use
 <code><a href="Debug-Trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> instead.</p><p>Note that when using GHC's SMP runtime, it is possible (but rare) to get
 duplicate events emitted if two CPUs simultaneously evaluate the same thunk
 that uses <code><a href="Debug-Trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code>.</p><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:traceMarkerIO" class="def">traceMarkerIO</a> :: <a href="Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Debug.Trace.html#traceMarkerIO" class="link">Source</a> <a href="#v:traceMarkerIO" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Debug-Trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> function emits a marker to the eventlog, if eventlog
 profiling is available and enabled at runtime.</p><p>Compared to <code><a href="Debug-Trace.html#v:traceMarker" title="Debug.Trace">traceMarker</a></code>, <code><a href="Debug-Trace.html#v:traceMarkerIO" title="Debug.Trace">traceMarkerIO</a></code> sequences the event with respect to
 other IO actions.</p><p><em>Since: base-4.7.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>