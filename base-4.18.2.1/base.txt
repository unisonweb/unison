-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core data structures and operations
--   
--   Haskell's base library provides, among other things, core types (e.g.
--   <a>Bool</a> and <a>Int</a>), data structures (e.g. <a>List</a>,
--   <a>Tuple</a> and <a>Maybe</a>), the <a>Exception</a> mechanism, and
--   the <a>IO</a> &amp; <a>Concurrency</a> operations. The <a>Prelude</a>
--   module, which is imported by default, exposes a curated set of types
--   and functions from other modules.
--   
--   Other data structures like <a>Map</a>, <a>Set</a> are available in the
--   <a>containers</a> library. To work with textual data, use the
--   <a>text</a> library.
@package base
@version 4.18.2.1


-- | Compatibility module for pre ghc-bignum code.
module GHC.Integer

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer
smallInteger :: Int# -> Integer
wordToInteger :: Word# -> Integer
integerToWord :: Integer -> Word#
integerToInt :: Integer -> Int#
encodeFloatInteger :: Integer -> Int# -> Float#
encodeDoubleInteger :: Integer -> Int# -> Double#
decodeDoubleInteger :: Double# -> (# Integer, Int# #)

-- | Used to implement <tt>(+)</tt> for the <tt>Num</tt> typeclass. This
--   gives the sum of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; plusInteger 3 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (+) 3 2
--   5
--   </pre>
plusInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(-)</tt> for the <tt>Num</tt> typeclass. This
--   gives the difference of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; minusInteger 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-) 3 2
--   1
--   </pre>
minusInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(*)</tt> for the <tt>Num</tt> typeclass. This
--   gives the product of two integers.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; timesInteger 3 2
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (*) 3 2
--   6
--   </pre>
timesInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>negate</tt> for the <tt>Num</tt> typeclass. This
--   changes the sign of whatever integer is passed into it.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; negateInteger (-6)
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; negate (-6)
--   6
--   </pre>
negateInteger :: Integer -> Integer

-- | Used to implement <tt>abs</tt> for the <tt>Num</tt> typeclass. This
--   gives the absolute value of whatever integer is passed into it.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; absInteger (-6)
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abs (-6)
--   6
--   </pre>
absInteger :: Integer -> Integer

-- | Used to implement <tt>signum</tt> for the <tt>Num</tt> typeclass. This
--   gives 1 for a positive integer, and -1 for a negative integer.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; signumInteger 5
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; signum 5
--   1
--   </pre>
signumInteger :: Integer -> Integer

-- | Used to implement <tt>divMod</tt> for the <tt>Integral</tt> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (div x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; divModInteger 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divMod 10 2
--   (5,0)
--   </pre>
divModInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | Used to implement <tt>div</tt> for the <tt>Integral</tt> typeclass.
--   This performs integer division on its two parameters, truncated
--   towards negative infinity.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `divInteger` 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `div` 2
--   </pre>
divInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>mod</tt> for the <tt>Integral</tt> typeclass.
--   This performs the modulo operation, satisfying
--   
--   <pre>
--   ((x `div` y) * y) + (x `mod` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `modInteger` 3
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `mod` 3
--   1
--   </pre>
modInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>quotRem</tt> for the <tt>Integral</tt>
--   typeclass. This gives a tuple equivalent to
--   
--   <pre>
--   (quot x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemInteger 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRem 10 2
--   (5,0)
--   </pre>
quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | Used to implement <tt>quot</tt> for the <tt>Integral</tt> typeclass.
--   This performs integer division on its two parameters, truncated
--   towards zero.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotInteger 10 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quot 10 2
--   5
--   </pre>
quotInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>rem</tt> for the <tt>Integral</tt> typeclass.
--   This gives the remainder after integer division of its two parameters,
--   satisfying
--   
--   <pre>
--   ((x `quot` y) * y) + (x `rem` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; remInteger 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rem 3 2
--   1
--   </pre>
remInteger :: Integer -> Integer -> Integer

-- | Used to implement <tt>(==)</tt> for the <tt>Eq</tt> typeclass. Outputs
--   <a>True</a> if two integers are equal to each other.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 6 `eqInteger` 6
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 == 6
--   True
--   </pre>
eqInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(/=)</tt> for the <tt>Eq</tt> typeclass. Outputs
--   <a>True</a> if two integers are not equal to each other.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 6 `neqInteger` 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 /= 7
--   True
--   </pre>
neqInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&lt;=)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is less than or equal to the
--   second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `leInteger` 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 &lt;= 5
--   True
--   </pre>
leInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&gt;)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is greater than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 5 `gtInteger` 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 &gt; 3
--   True
--   </pre>
gtInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&lt;)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is less than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `ltInteger` 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 &lt; 5
--   True
--   </pre>
ltInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>(&gt;=)</tt> for the <tt>Ord</tt> typeclass.
--   Outputs <a>True</a> if the first argument is greater than or equal to
--   the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 5 `geInteger` 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 &gt;= 3
--   True
--   </pre>
geInteger :: Integer -> Integer -> Bool

-- | Used to implement <tt>compare</tt> for the <tt>Integral</tt>
--   typeclass. This takes two integers, and outputs whether the first is
--   less than, equal to, or greater than the second.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; compareInteger 2 10
--   LT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare 2 10
--   LT
--   </pre>
compareInteger :: Integer -> Integer -> Ordering
eqInteger# :: Integer -> Integer -> Int#
neqInteger# :: Integer -> Integer -> Int#
leInteger# :: Integer -> Integer -> Int#
gtInteger# :: Integer -> Integer -> Int#
ltInteger# :: Integer -> Integer -> Int#
geInteger# :: Integer -> Integer -> Int#
andInteger :: Integer -> Integer -> Integer
orInteger :: Integer -> Integer -> Integer
xorInteger :: Integer -> Integer -> Integer
complementInteger :: Integer -> Integer
shiftLInteger :: Integer -> Int# -> Integer
shiftRInteger :: Integer -> Int# -> Integer
testBitInteger :: Integer -> Int# -> Bool
popCountInteger :: Integer -> Int#
bitInteger :: Int# -> Integer
hashInteger :: Integer -> Int#


-- | Compatibility module for pre ghc-bignum code.
module GHC.Integer.Logarithms
wordLog2# :: Word# -> Int#
integerLog2# :: Integer -> Int#
integerLogBase# :: Integer -> Integer -> Int#


-- | Maybe type
module GHC.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Maybe.Maybe a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Maybe.Maybe a)


-- | Compatibility module for pre ghc-bignum code.
module GHC.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural
pattern NatS# :: Word# -> Natural
pattern NatJ# :: BigNat -> Natural

-- | A lifted BigNat
--   
--   Represented as an array of limbs (Word#) stored in little-endian order
--   (Word# themselves use machine order).
--   
--   Invariant (canonical representation): higher Word# is non-zero.
--   
--   As a consequence, zero is represented with a WordArray# whose size is
--   0.
data () => BigNat
BN# :: BigNat# -> BigNat
[unBigNat] :: BigNat -> BigNat#

-- | Construct <a>Natural</a> value from list of <a>Word</a>s.
mkNatural :: [Word] -> Natural

-- | Test whether all internal invariants are satisfied by <a>Natural</a>
--   value
--   
--   This operation is mostly useful for test-suites and/or code which
--   constructs <a>Integer</a> values directly.
isValidNatural :: Natural -> Bool

-- | <a>Natural</a> Addition
plusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. May <tt><a>throw</a>
--   <a>Underflow</a></tt>.
minusNatural :: Natural -> Natural -> Natural

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural

-- | <a>Natural</a> multiplication
timesNatural :: Natural -> Natural -> Natural
negateNatural :: Natural -> Natural
signumNatural :: Natural -> Natural
quotRemNatural :: Natural -> Natural -> (Natural, Natural)
quotNatural :: Natural -> Natural -> Natural
remNatural :: Natural -> Natural -> Natural

-- | Compute greatest common divisor.
gcdNatural :: Natural -> Natural -> Natural

-- | Compute least common multiple.
lcmNatural :: Natural -> Natural -> Natural
andNatural :: Natural -> Natural -> Natural
orNatural :: Natural -> Natural -> Natural
xorNatural :: Natural -> Natural -> Natural
bitNatural :: Int# -> Natural
testBitNatural :: Natural -> Int -> Bool
popCountNatural :: Natural -> Int
shiftLNatural :: Natural -> Int -> Natural
shiftRNatural :: Natural -> Int -> Natural

naturalToInteger :: Natural -> Integer
naturalToWord :: Natural -> Word

-- | Try downcasting <a>Natural</a> to <a>Word</a> value. Returns
--   <a>Nothing</a> if value doesn't fit in <a>Word</a>.
naturalToWordMaybe :: Natural -> Maybe Word

-- | Construct <a>Natural</a> from <a>Word</a> value.
wordToNatural :: Word -> Natural
wordToNatural# :: Word -> Natural

naturalFromInteger :: Integer -> Natural

-- | "<tt><a>powModNatural</a> <i>b</i> <i>e</i> <i>m</i></tt>" computes
--   base <tt><i>b</i></tt> raised to exponent <tt><i>e</i></tt> modulo
--   <tt><i>m</i></tt>.
powModNatural :: Natural -> Natural -> Natural -> Natural


-- | type definitions for implicit call-stacks. Use <a>GHC.Stack</a> from
--   the base package instead of importing this module directly.
module GHC.Stack.Types

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack
EmptyCallStack :: CallStack
PushCallStack :: [Char] -> SrcLoc -> CallStack -> CallStack

-- | Freeze the stack at the given <tt>CallStack</tt>, preventing any
--   further call-sites from being pushed onto it.
FreezeCallStack :: CallStack -> CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = (?callStack :: CallStack)

-- | The empty <a>CallStack</a>.
emptyCallStack :: CallStack

-- | Freeze a call-stack, preventing any further call-sites from being
--   appended.
--   
--   <pre>
--   pushCallStack callSite (freezeCallStack callStack) = freezeCallStack callStack
--   </pre>
freezeCallStack :: CallStack -> CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Push a call-site onto the stack.
--   
--   This function has no effect on a frozen <a>CallStack</a>.
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int
instance GHC.Classes.Eq GHC.Stack.Types.SrcLoc


-- | The <a>GHC.Err</a> module defines the code for the wired-in error
--   functions, which have a special type in the compiler (with "open
--   tyvars").
--   
--   We cannot define these functions in a module where they might be used
--   (e.g., <a>GHC.Base</a>), because the magical wired-in type will get
--   confused with what the typechecker figures out.
module GHC.Err

-- | Used for compiler-generated error message; encoding saves bytes of
--   string junk.
absentErr :: a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => [Char] -> a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep). forall (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a


-- | Basic data types and classes.
module GHC.Base

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative f

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus m

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | Uninhabited data type
data Void
data Opaque
O :: a -> Opaque

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: <tt><a>liftA</a>
--   f a = <a>pure</a> f <a>&lt;*&gt;</a> a</tt>
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the Applicative instance for Lists:
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) [1, 2]
--   [2,3]
--   </pre>
--   
--   Or the Applicative instance for <a>Maybe</a>
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) (Just 3)
--   Just 4
--   </pre>
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | <tt><a>mapM</a> f</tt> is equivalent to <tt><a>sequence</a> .
--   <a>map</a> f</tt>.
mapM :: Monad m => (a -> m b) -> [a] -> m [b]

-- | Evaluate each action in the sequence from left to right, and collect
--   the results.
sequence :: Monad m => [m a] -> m [a]

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b
failIO :: String -> IO a

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values. It is implemented in
--   terms of <tt>fmap absurd</tt>.
vacuous :: Functor f => f Void -> f a

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a
unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | This <a>String</a> equality predicate is used when desugaring
--   pattern-matches against strings.
eqString :: String -> String -> Bool
returnIO :: a -> IO a
bindIO :: IO a -> (a -> IO b) -> IO b
thenIO :: IO a -> IO b -> IO b
mapFB :: (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
unsafeChr :: Int -> Char
maxInt :: Int
minInt :: Int

-- | Returns the tag of a constructor application; this function is used by
--   the deriving code for Eq, Ord and Enum.
getTag :: a -> Int#

-- | Used to implement <tt>quot</tt> for the <a>Integral</a> typeclass.
--   This performs integer division on its two parameters, truncated
--   towards zero.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotInt 10 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quot 10 2
--   5
--   </pre>
quotInt :: Int -> Int -> Int

-- | Used to implement <tt>rem</tt> for the <a>Integral</a> typeclass. This
--   gives the remainder after integer division of its two parameters,
--   satisfying
--   
--   <pre>
--   ((x `quot` y) * y) + (x `rem` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; remInt 3 2
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; rem 3 2
--   1
--   </pre>
remInt :: Int -> Int -> Int

-- | Used to implement <tt>div</tt> for the <a>Integral</a> typeclass. This
--   performs integer division on its two parameters, truncated towards
--   negative infinity.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `divInt` 2
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10 `div` 2
--   5
--   </pre>
divInt :: Int -> Int -> Int

-- | Used to implement <tt>mod</tt> for the <a>Integral</a> typeclass. This
--   performs the modulo operation, satisfying
--   
--   <pre>
--   ((x `div` y) * y) + (x `mod` y) == x
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `modInt` 3
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 7 `mod` 3
--   1
--   </pre>
modInt :: Int -> Int -> Int

-- | Used to implement <tt>quotRem</tt> for the <a>Integral</a> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (quot x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; quotRemInt 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quotRem 10 2
--   (5,0)
--   </pre>
quotRemInt :: Int -> Int -> (Int, Int)

-- | Used to implement <tt>divMod</tt> for the <a>Integral</a> typeclass.
--   This gives a tuple equivalent to
--   
--   <pre>
--   (div x y, mod x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; divModInt 10 2
--   (5,0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divMod 10 2
--   (5,0)
--   </pre>
divModInt :: Int -> Int -> (Int, Int)

-- | This function is used to implement branchless shifts. If the number of
--   bits to shift is greater than or equal to the type size in bits, then
--   the shift must return 0. Instead of doing a test, we use a mask
--   obtained via this function which is branchless too.
--   
--   shift_mask m b | b &lt; m = 0xFF..FF | otherwise = 0
shift_mask :: Int# -> Int# -> Int#
instance GHC.Classes.Ord GHC.Base.Void
instance GHC.Classes.Eq GHC.Base.Void
instance GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Base.NonEmpty a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.NonEmpty a)
instance GHC.Base.Monoid [a]
instance GHC.Base.Monoid b => GHC.Base.Monoid (a -> b)
instance GHC.Base.Monoid ()
instance GHC.Base.Monoid a => GHC.Base.Monoid (Solo a)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (a, b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monoid (a, b, c)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d) => GHC.Base.Monoid (a, b, c, d)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d, GHC.Base.Monoid e) => GHC.Base.Monoid (a, b, c, d, e)
instance GHC.Base.Monoid GHC.Types.Ordering
instance GHC.Base.Semigroup a => GHC.Base.Monoid (GHC.Maybe.Maybe a)
instance GHC.Base.Monoid a => GHC.Base.Applicative ((,) a)
instance GHC.Base.Monoid a => GHC.Base.Monad ((,) a)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Applicative ((,,) a b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monad ((,,) a b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Applicative ((,,,) a b c)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monad ((,,,) a b c)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a)
instance GHC.Base.Semigroup [a]
instance GHC.Base.Semigroup GHC.Base.Void
instance GHC.Base.Semigroup (GHC.Base.NonEmpty a)
instance GHC.Base.Semigroup b => GHC.Base.Semigroup (a -> b)
instance GHC.Base.Semigroup ()
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Solo a)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (a, b)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c) => GHC.Base.Semigroup (a, b, c)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d) => GHC.Base.Semigroup (a, b, c, d)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d, GHC.Base.Semigroup e) => GHC.Base.Semigroup (a, b, c, d, e)
instance GHC.Base.Semigroup GHC.Types.Ordering
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Maybe.Maybe a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Types.IO a)
instance GHC.Base.Functor GHC.Base.NonEmpty
instance GHC.Base.Applicative GHC.Base.NonEmpty
instance GHC.Base.Monad GHC.Base.NonEmpty
instance GHC.Base.MonadPlus GHC.Maybe.Maybe
instance GHC.Base.MonadPlus []
instance GHC.Base.MonadPlus GHC.Types.IO
instance GHC.Base.Alternative GHC.Maybe.Maybe
instance GHC.Base.Alternative []
instance GHC.Base.Alternative GHC.Types.IO
instance GHC.Base.Monad Solo
instance GHC.Base.Monad ((->) r)
instance GHC.Base.Monad GHC.Maybe.Maybe
instance GHC.Base.Monad []
instance GHC.Base.Functor GHC.Types.IO
instance GHC.Base.Monad GHC.Types.IO
instance GHC.Base.Applicative Solo
instance GHC.Base.Applicative ((->) r)
instance GHC.Base.Applicative GHC.Maybe.Maybe
instance GHC.Base.Applicative []
instance GHC.Base.Applicative GHC.Types.IO
instance GHC.Base.Functor ((,,) a b)
instance GHC.Base.Functor ((,,,) a b c)
instance GHC.Base.Functor ((,,,,) a b c d)
instance GHC.Base.Functor ((,,,,,) a b c d e)
instance GHC.Base.Functor ((,,,,,,) a b c d e f)
instance GHC.Base.Functor ((->) r)
instance GHC.Base.Functor Solo
instance GHC.Base.Functor ((,) a)
instance GHC.Base.Functor GHC.Maybe.Maybe
instance GHC.Base.Functor []


module GHC.Profiling

-- | Start attributing ticks to cost centres. This is called by the RTS on
--   startup.
startProfTimer :: IO ()

-- | Stop attributing ticks to cost centres. Allocations will still be
--   attributed.
stopProfTimer :: IO ()

-- | Start heap profiling. This is called normally by the RTS on start-up,
--   but can be disabled using the rts flag `--no-automatic-heap-samples`
--   Note: This won't do anything unless you also specify a profiling mode
--   on the command line using the normal RTS options.
startHeapProfTimer :: IO ()

-- | Stop heap profiling. Note: This won't do anything unless you also
--   specify a profiling mode on the command line using the normal RTS
--   options.
stopHeapProfTimer :: IO ()

-- | Request a heap census on the next context switch. The census can be
--   requested whether or not the heap profiling timer is running. Note:
--   This won't do anything unless you also specify a profiling mode on the
--   command line using the normal RTS options.
requestHeapCensus :: IO ()


-- | The <a>Num</a> class and the <a>Integer</a> type.
module GHC.Num

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | <i>Deprecated: Use integerQuotRem# instead</i>
quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a
instance GHC.Num.Num GHC.Types.Int
instance GHC.Num.Num GHC.Types.Word
instance GHC.Num.Num GHC.Num.Integer.Integer
instance GHC.Num.Num GHC.Num.Natural.Natural


-- | The MVar type
module GHC.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a
MVar :: MVar# RealWorld a -> MVar a

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | Add a finalizer to an <a>MVar</a> (GHC only). See
--   <a>Foreign.ForeignPtr</a> and <a>System.Mem.Weak</a> for more about
--   finalizers.
addMVarFinalizer :: MVar a -> IO () -> IO ()
instance GHC.Classes.Eq (GHC.MVar.MVar a)


-- | Unsafe IO operations
module GHC.IO.Unsafe

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
--   
--   WARNING: If you're looking for "a way to get a <a>String</a> from an
--   'IO String'", then <a>unsafePerformIO</a> is not the way to go. Learn
--   about do-notation and the <tt>&lt;-</tt> syntax element before you
--   proceed.
unsafePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeDupableInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To ensure that the computation is performed
--   only once, use <a>unsafeInterleaveIO</a> instead.
unsafeDupableInterleaveIO :: IO a -> IO a

-- | Ensures that the suspensions under evaluation by the current thread
--   are unique; that is, the current thread is not evaluating anything
--   that is also under evaluation by another thread that has also executed
--   <a>noDuplicate</a>.
--   
--   This operation is used in the definition of <a>unsafePerformIO</a> to
--   prevent the IO action from being executed multiple times, which is
--   usually undesirable.
noDuplicate :: IO ()

module GHC.IO.Encoding.CodePage


-- | The GHCi Monad lifting interface.
--   
--   EXPERIMENTAL! DON'T USE.

-- | <i>Warning: This is an unstable interface.</i>
module GHC.GHCi

-- | A monad that can execute GHCi statements by lifting them out of m into
--   the IO monad. (e.g state monads)
class (Monad m) => GHCiSandboxIO m
ghciStepIO :: GHCiSandboxIO m => m a -> IO a

-- | A monad that doesn't allow any IO.
data NoIO a
instance GHC.Base.Functor GHC.GHCi.NoIO
instance GHC.Base.Applicative GHC.GHCi.NoIO
instance GHC.Base.Monad GHC.GHCi.NoIO
instance GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO
instance GHC.GHCi.GHCiSandboxIO GHC.Types.IO


-- | Methods for the RealFrac instances for <a>Float</a> and <a>Double</a>,
--   with specialised versions for <a>Int</a>.
--   
--   Moved to their own module to not bloat GHC.Float further.
module GHC.Float.RealFracMethods
properFractionDoubleInteger :: Double -> (Integer, Double)
truncateDoubleInteger :: Double -> Integer
floorDoubleInteger :: Double -> Integer
ceilingDoubleInteger :: Double -> Integer
roundDoubleInteger :: Double -> Integer
properFractionDoubleInt :: Double -> (Int, Double)
floorDoubleInt :: Double -> Int
ceilingDoubleInt :: Double -> Int
roundDoubleInt :: Double -> Int
double2Int :: Double -> Int
int2Double :: Int -> Double
properFractionFloatInteger :: Float -> (Integer, Float)
truncateFloatInteger :: Float -> Integer
floorFloatInteger :: Float -> Integer
ceilingFloatInteger :: Float -> Integer
roundFloatInteger :: Float -> Integer
properFractionFloatInt :: Float -> (Int, Float)
floorFloatInt :: Float -> Int
ceilingFloatInt :: Float -> Int
roundFloatInt :: Float -> Int
float2Int :: Float -> Int
int2Float :: Int -> Float


-- | Utilities for conversion between Double/Float and Rational
module GHC.Float.ConversionUtils
elimZerosInteger :: Integer -> Int# -> (# Integer, Int# #)
elimZerosInt# :: Int# -> Int# -> (# Integer, Int# #)

module GHC.Constants


-- | NB. the contents of this module are only available on Windows.
--   
--   Installing Win32 console handlers.
module GHC.ConsoleHandler


-- | Functions associated with the tuple data types.
module Data.Tuple

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data () => Solo a
MkSolo :: a -> Solo a
pattern Solo :: a -> Solo a

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)


-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt>, lets you apply any
--   function of type <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Just 1)  --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   Just "1"                --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing   --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   Nothing                 --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show [1,2,3]   --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   ["1","2","3"]           --  (Int -&gt; String) -&gt; [Int]     -&gt; [String]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fmap show []        --  (a   -&gt; b)      -&gt; f a       -&gt; f b
--   []                      --  (Int -&gt; String) -&gt; [Int]     -&gt; [String]
--   </pre>
--   
--   The <a>fmap</a> function is also available as the infix operator
--   <a>&lt;$&gt;</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Just 1) --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   Just "1"
--   
--   &gt;&gt;&gt; show &lt;$&gt; (Just 1)  --  (Int -&gt; String) -&gt; Maybe Int -&gt; Maybe String
--   Just "1"
--   </pre>
module Data.Functor

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()


-- | Equality
module Data.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=


-- | Safe coercions between data types.
--   
--   More in-depth information can be found on the <a>Roles wiki page</a>
module Data.Coerce

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)


-- | The <a>Bool</a> type and related functions.
module Data.Bool
data () => Bool
False :: Bool
True :: Bool

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Basic operations on type-level Booleans.
module Data.Type.Bool

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>
type family If cond tru fls

-- | Type-level "and"
type family a && b
infixr 3 &&

-- | Type-level "or"
type family a || b
infixr 2 ||

-- | Type-level "not". An injective type family since <tt>4.10.0.0</tt>.
type family Not a = res | res -> a


-- | Simple combinators working solely on and with functions.
module Data.Function

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <a>applyWhen</a> applies a function to a value if a condition is true,
--   otherwise, it returns the value unchanged.
--   
--   It is equivalent to <tt><a>flip</a> (<a>bool</a> <a>id</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>applyWhen <a>True</a> = <a>id</a></pre></li>
--   <li><pre>applyWhen <a>False</a> f = <a>id</a></pre></li>
--   </ul>
applyWhen :: Bool -> (a -> a) -> a -> a


-- | Transitional module providing the <a>MonadFail</a> class and primitive
--   instances.
--   
--   This module can be imported for defining forward compatible
--   <a>MonadFail</a> instances:
--   
--   <pre>
--   import qualified Control.Monad.Fail as Fail
--   
--   instance Monad Foo where
--     (&gt;&gt;=) = {- ...bind impl... -}
--   
--     -- Provide legacy <a>fail</a> implementation for when
--     -- new-style MonadFail desugaring is not enabled.
--     fail = Fail.fail
--   
--   instance Fail.MonadFail Foo where
--     fail = {- ...fail implementation... -}
--   </pre>
--   
--   See
--   <a>https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail</a>
--   for more details.
module Control.Monad.Fail

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a
instance Control.Monad.Fail.MonadFail GHC.Maybe.Maybe
instance Control.Monad.Fail.MonadFail []
instance Control.Monad.Fail.MonadFail GHC.Types.IO


-- | The Maybe type, and associated operations.
module Data.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   ...
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching instead.
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]


-- | The List data type and its operations
module GHC.List

-- | The builtin list type, usually written in its non-prefix form
--   <tt>[a]</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Unless the OverloadedLists extension is enabled, list literals are
--   syntactic sugar for repeated applications of <tt>:</tt> and
--   <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 1:2:3:4:[] == [1,2,3,4]
--   True
--   </pre>
--   
--   Similarly, unless the OverloadedStrings extension is enabled, string
--   literals are syntactic sugar for a lists of characters.
--   
--   <pre>
--   &gt;&gt;&gt; ['h','e','l','l','o'] == "hello"
--   True
--   </pre>
data () => [] a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr'</a> is a variant of <a>foldr</a> that begins list reduction
--   from the last element and evaluates the accumulator strictly as it
--   unwinds the stack back to the beginning of the list. The input list
--   <i>must</i> be finite, otherwise <a>foldr'</a> runs out of space
--   (<i>diverges</i>).
--   
--   Note that if the function that combines the accumulated value with
--   each element is strict in the accumulator, other than a possible
--   improvement in the constant factor, you get the same &lt;math&gt;
--   space cost as with just <a>foldr</a>.
--   
--   If you want a strict right fold in constant space, you need a
--   structure that supports faster than &lt;math&gt; access to the
--   right-most element, such as <tt>Seq</tt> from the <tt>containers</tt>
--   package.
--   
--   Use of this function is a hint that the <tt>[]</tt> structure may be a
--   poor fit for the task at hand. If the order in which the elements are
--   combined is not important, use <a>foldl'</a> instead.
--   
--   <pre>
--   &gt;&gt;&gt; foldr' (+) [1..4]  -- Use foldl' instead!
--   10
--   
--   &gt;&gt;&gt; foldr' (&amp;&amp;) [True, False, True, True] -- Use foldr instead!
--   False
--   
--   &gt;&gt;&gt; foldr' (||) [False, False, True, True] -- Use foldr instead!
--   True
--   </pre>
foldr' :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldr</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldr1 (+) []
--   *** Exception: Prelude.foldr1: empty list
--   
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; force $ foldr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
foldr1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 0 [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl (+) 42 []
--   42
--   
--   &gt;&gt;&gt; foldl (-) 100 [1..4]
--   90
--   
--   &gt;&gt;&gt; foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   "dcbafoo"
--   
--   &gt;&gt;&gt; foldl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldl</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | &lt;math&gt;. Test whether a list is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   
--   &gt;&gt;&gt; null [1]
--   False
--   
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: [a] -> Bool

-- | &lt;math&gt;. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: [a] -> Int

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   
--   &gt;&gt;&gt; 3 `elem` [4..]
--   * Hangs forever *
--   </pre>
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   
--   &gt;&gt;&gt; 3 `notElem` [4..]
--   * Hangs forever *
--   </pre>
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   
--   &gt;&gt;&gt; maximum [42]
--   42
--   
--   &gt;&gt;&gt; maximum [55, -12, 7, 0, -89]
--   55
--   
--   &gt;&gt;&gt; maximum [1..]
--   * Hangs forever *
--   </pre>
maximum :: (Ord a, HasCallStack) => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   
--   &gt;&gt;&gt; minimum [42]
--   42
--   
--   &gt;&gt;&gt; minimum [55, -12, 7, 0, -89]
--   -89
--   
--   &gt;&gt;&gt; minimum [1..]
--   * Hangs forever *
--   </pre>
minimum :: (Ord a, HasCallStack) => [a] -> a

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   
--   &gt;&gt;&gt; sum [42]
--   42
--   
--   &gt;&gt;&gt; sum [1..10]
--   55
--   
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   
--   &gt;&gt;&gt; product [42]
--   42
--   
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: Num a => [a] -> a

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   
--   &gt;&gt;&gt; and [True]
--   True
--   
--   &gt;&gt;&gt; and [False]
--   False
--   
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
--   False
--   
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   
--   &gt;&gt;&gt; or [True]
--   True
--   
--   &gt;&gt;&gt; or [False]
--   False
--   
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
--   True
--   
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: (a -> Bool) -> [a] -> Bool

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
--   
--   <pre>
--   &gt;&gt;&gt; concat []
--   []
--   
--   &gt;&gt;&gt; concat [[42]]
--   [42]
--   
--   &gt;&gt;&gt; concat [[1,2,3], [4,5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: [[a]] -> [a]

-- | Map a function returning a list over a list and concatenate the
--   results. <a>concatMap</a> can be seen as the composition of
--   <a>concat</a> and <a>map</a>.
--   
--   <pre>
--   concatMap f xs == (concat . map f) xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) []
--   []
--   
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) [1,2,3]
--   [-1,1,-2,2,-3,3]
--   </pre>
concatMap :: (a -> [b]) -> [a] -> [b]

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
errorEmptyList :: HasCallStack => String -> a

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]


-- | The <a>Show</a> class, and related operations.
module GHC.Show

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | Like <a>showLitString</a> (expand escape characters using Haskell
--   escape conventions), but * break the string into multiple lines * wrap
--   the entire thing in double quotes Example: <tt>showMultiLineString
--   "hellongoodbyenblah"</tt> returns <tt>[""hello\n\", "\goodbyen\",
--   "\blah""]</tt>
showMultiLineString :: String -> [String]

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS
showList__ :: (a -> ShowS) -> [a] -> ShowS
showCommaSpace :: ShowS
showSpace :: ShowS

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Same as <a>showLitChar</a>, but for strings It converts the string to
--   a string using Haskell escape conventions for non-printable
--   characters. Does not add double-quotes around the whole thing; the
--   caller should do that. The main difference from showLitChar (apart
--   from the fact that the argument is a string not a list) is that we
--   must escape double-quotes
showLitString :: String -> ShowS
protectEsc :: (Char -> Bool) -> ShowS -> ShowS

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char
showSignedInt :: Int -> Int -> ShowS
appPrec :: Int
appPrec1 :: Int
asciiTab :: [String]
instance GHC.Show.Show GHC.Base.Void
instance GHC.Show.Show ()
instance GHC.Show.Show a => GHC.Show.Show (Solo a)
instance GHC.Show.Show GHC.Types.Bool
instance GHC.Show.Show GHC.Types.Ordering
instance GHC.Show.Show a => GHC.Show.Show (GHC.Maybe.Maybe a)
instance GHC.Show.Show a => GHC.Show.Show (GHC.Base.NonEmpty a)
instance GHC.Show.Show GHC.Stack.Types.SrcLoc
instance GHC.Show.Show GHC.Types.Levity
instance GHC.Show.Show GHC.Types.RuntimeRep
instance GHC.Show.Show GHC.Types.VecCount
instance GHC.Show.Show GHC.Types.VecElem
instance GHC.Show.Show GHC.Types.TypeLitSort
instance GHC.Show.Show a => GHC.Show.Show [a]
instance GHC.Show.Show GHC.Types.Char
instance GHC.Show.Show GHC.Types.Int
instance GHC.Show.Show GHC.Types.Word
instance GHC.Show.Show GHC.Types.TyCon
instance GHC.Show.Show GHC.Types.TrName
instance GHC.Show.Show GHC.Types.Module
instance GHC.Show.Show GHC.Stack.Types.CallStack
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a, b)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (a, b, c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (a, b, c, d)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e) => GHC.Show.Show (a, b, c, d, e)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f) => GHC.Show.Show (a, b, c, d, e, f)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g) => GHC.Show.Show (a, b, c, d, e, f, g)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h) => GHC.Show.Show (a, b, c, d, e, f, g, h)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i) => GHC.Show.Show (a, b, c, d, e, f, g, h, i)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Show.Show GHC.Num.Integer.Integer
instance GHC.Show.Show GHC.Num.Natural.Natural
instance GHC.Show.Show GHC.Types.KindRep


-- | The <a>ST</a> Monad.
module GHC.ST

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
newtype ST s a
ST :: STRep s a -> ST s a
data STret s a
STret :: State# s -> a -> STret s a
type STRep s a = State# s -> (# State# s, a #)

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a
liftST :: ST s a -> State# s -> STret s a

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | <a>unsafeDupableInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To prevent this, use
--   <a>unsafeInterleaveST</a> instead.
unsafeDupableInterleaveST :: ST s a -> ST s a
instance GHC.Base.Functor (GHC.ST.ST s)
instance GHC.Base.Applicative (GHC.ST.ST s)
instance GHC.Base.Monad (GHC.ST.ST s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.ST.ST s a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.ST.ST s a)
instance GHC.Show.Show (GHC.ST.ST s a)


-- | References in the <a>ST</a> monad.
module GHC.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a
STRef :: MutVar# s a -> STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()
instance GHC.Classes.Eq (GHC.STRef.STRef s a)

module GHC.Char

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool


-- | The <a>Enum</a> and <a>Bounded</a> classes.
module GHC.Enum

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]
boundedEnumFrom :: (Enum a, Bounded a) => a -> [a]
boundedEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
toEnumError :: Show a => String -> Int -> (a, a) -> b
fromEnumError :: Show a => String -> a -> b
succError :: String -> a
predError :: String -> a
instance GHC.Enum.Bounded ()
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Solo a)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (a, b)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c) => GHC.Enum.Bounded (a, b, c)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d) => GHC.Enum.Bounded (a, b, c, d)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e) => GHC.Enum.Bounded (a, b, c, d, e)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f) => GHC.Enum.Bounded (a, b, c, d, e, f)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g) => GHC.Enum.Bounded (a, b, c, d, e, f, g)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n, GHC.Enum.Bounded o) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Enum.Bounded GHC.Types.Bool
instance GHC.Enum.Bounded GHC.Types.Ordering
instance GHC.Enum.Bounded GHC.Types.Levity
instance GHC.Enum.Enum GHC.Types.Levity
instance GHC.Enum.Bounded GHC.Types.VecCount
instance GHC.Enum.Enum GHC.Types.VecCount
instance GHC.Enum.Bounded GHC.Types.VecElem
instance GHC.Enum.Enum GHC.Types.VecElem
instance GHC.Enum.Enum ()
instance GHC.Enum.Enum a => GHC.Enum.Enum (Solo a)
instance GHC.Enum.Enum GHC.Types.Bool
instance GHC.Enum.Enum GHC.Types.Ordering
instance GHC.Enum.Enum GHC.Types.Char
instance GHC.Enum.Enum GHC.Types.Int
instance GHC.Enum.Enum GHC.Types.Word
instance GHC.Enum.Enum GHC.Num.Integer.Integer
instance GHC.Enum.Enum GHC.Num.Natural.Natural
instance GHC.Enum.Bounded GHC.Types.Char
instance GHC.Enum.Bounded GHC.Types.Int
instance GHC.Enum.Bounded GHC.Types.Word


-- | The types <a>Ratio</a> and <a>Rational</a>, and the classes
--   <a>Real</a>, <a>Fractional</a>, <a>Integral</a>, and <a>RealFrac</a>.
module GHC.Real
divZeroError :: a
ratioZeroDenominatorError :: a
overflowError :: a
underflowError :: a

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a
(:%) :: !a -> !a -> Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer
ratioPrec :: Int
ratioPrec1 :: Int
infinity :: Rational
notANumber :: Rational

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | <a>reduce</a> is a subsidiary function used only in this module. It
--   normalises a ratio by dividing both numerator and denominator by their
--   greatest common divisor.
reduce :: Integral a => a -> a -> Ratio a

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <a>toInteger</a> should be total, and <a>fromInteger</a>
--   should be a left inverse for it, i.e. <tt>fromInteger (toInteger i) =
--   i</tt>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class (Num a) => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b
numericEnumFrom :: Fractional a => a -> [a]
numericEnumFromThen :: Fractional a => a -> a -> [a]
numericEnumFromTo :: (Ord a, Fractional a) => a -> a -> [a]
numericEnumFromThenTo :: (Ord a, Fractional a) => a -> a -> a -> [a]

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
powImpl :: (Num a, Integral b) => a -> b -> a
powImplAcc :: (Num a, Integral b) => a -> b -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^
(^%^) :: Integral a => Rational -> a -> Rational
(^^%^^) :: Integral a => Rational -> a -> Rational

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a
integralEnumFrom :: (Integral a, Bounded a) => a -> [a]
integralEnumFromThen :: (Integral a, Bounded a) => a -> a -> [a]
integralEnumFromTo :: Integral a => a -> a -> [a]
integralEnumFromThenTo :: Integral a => a -> a -> a -> [a]
data FractionalExponentBase
Base2 :: FractionalExponentBase
Base10 :: FractionalExponentBase
mkRationalBase2 :: Rational -> Integer -> Rational
mkRationalBase10 :: Rational -> Integer -> Rational
mkRationalWithExponentBase :: Rational -> Integer -> FractionalExponentBase -> Rational
instance GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a)
instance GHC.Show.Show GHC.Real.FractionalExponentBase
instance GHC.Real.Integral a => GHC.Real.RealFrac (GHC.Real.Ratio a)
instance GHC.Real.Integral a => GHC.Enum.Enum (GHC.Real.Ratio a)
instance GHC.Real.Integral a => GHC.Real.Fractional (GHC.Real.Ratio a)
instance GHC.Real.Real GHC.Types.Int
instance GHC.Real.Integral GHC.Types.Int
instance GHC.Real.Real GHC.Types.Word
instance GHC.Real.Integral GHC.Types.Word
instance GHC.Real.Integral GHC.Num.Integer.Integer
instance GHC.Real.Integral GHC.Num.Natural.Natural
instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a)
instance GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a)
instance GHC.Real.Integral a => GHC.Real.Real (GHC.Real.Ratio a)
instance GHC.Real.Real GHC.Num.Integer.Integer
instance GHC.Real.Real GHC.Num.Natural.Natural
instance GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a)


-- | GHC's Ix typeclass implementation.
module GHC.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class (Ord a) => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Like <a>index</a>, but without checking that the value is in range.
unsafeIndex :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | like <a>rangeSize</a>, but without checking that the upper bound is in
--   range.
unsafeRangeSize :: Ix a => (a, a) -> Int
indexError :: Show a => (a, a) -> a -> String -> b
instance GHC.Ix.Ix GHC.Types.Char
instance GHC.Ix.Ix GHC.Types.Int
instance GHC.Ix.Ix GHC.Types.Word
instance GHC.Ix.Ix GHC.Num.Integer.Integer
instance GHC.Ix.Ix GHC.Num.Natural.Natural
instance GHC.Ix.Ix GHC.Types.Bool
instance GHC.Ix.Ix GHC.Types.Ordering
instance GHC.Ix.Ix GHC.Base.Void
instance GHC.Ix.Ix ()
instance GHC.Ix.Ix a => GHC.Ix.Ix (Solo a)
instance (GHC.Ix.Ix a, GHC.Ix.Ix b) => GHC.Ix.Ix (a, b)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3) => GHC.Ix.Ix (a1, a2, a3)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4) => GHC.Ix.Ix (a1, a2, a3, a4)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5) => GHC.Ix.Ix (a1, a2, a3, a4, a5)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE)
instance (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE, GHC.Ix.Ix aF) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF)


-- | GHC's array implementation.
module GHC.Arr

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class (Ord a) => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Like <a>index</a>, but without checking that the value is in range.
unsafeIndex :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | like <a>rangeSize</a>, but without checking that the upper bound is in
--   range.
unsafeRangeSize :: Ix a => (a, a) -> Int

-- | The type of immutable non-strict (boxed) arrays with indices in
--   <tt>i</tt> and elements in <tt>e</tt>.
data Array i e
Array :: !i -> !i -> {-# UNPACK #-} !Int -> Array# e -> Array i e

-- | Mutable, boxed, non-strict arrays in the <a>ST</a> monad. The type
--   arguments are as follows:
--   
--   <ul>
--   <li><tt>s</tt>: the state variable argument for the <a>ST</a>
--   type</li>
--   <li><tt>i</tt>: the index type of the array (should be an instance of
--   <a>Ix</a>)</li>
--   <li><tt>e</tt>: the element type of the array.</li>
--   </ul>
data STArray s i e
STArray :: !i -> !i -> {-# UNPACK #-} !Int -> MutableArray# s e -> STArray s i e
arrEleBottom :: a

-- | Construct an array with the specified bounds and containing values for
--   given indices within these bounds.
--   
--   The array is undefined (i.e. bottom) if any index in the list is out
--   of bounds. The Haskell 2010 Report further specifies that if any two
--   associations in the list have the same index, the value at that index
--   is undefined (i.e. bottom). However in GHC's implementation, the value
--   at such an index is the value part of the last association with that
--   index in the list.
--   
--   Because the indices must be checked for these errors, <a>array</a> is
--   strict in the bounds argument and in the indices of the association
--   list, but non-strict in the values. Thus, recurrences such as the
--   following are possible:
--   
--   <pre>
--   a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i &lt;- [2..100]])
--   </pre>
--   
--   Not every index within the bounds of the array need appear in the
--   association list, but the values associated with indices that do not
--   appear will be undefined (i.e. bottom).
--   
--   If, in any dimension, the lower bound is greater than the upper bound,
--   then the array is legal, but empty. Indexing an empty array always
--   gives an array-bounds error, but <a>bounds</a> still yields the bounds
--   with which the array was constructed.
array :: Ix i => (i, i) -> [(i, e)] -> Array i e

-- | Construct an array from a pair of bounds and a list of values in index
--   order.
listArray :: Ix i => (i, i) -> [e] -> Array i e

-- | The value at the given index in an array.
(!) :: Ix i => Array i e -> i -> e
infixl 9 !
safeRangeSize :: Ix i => (i, i) -> Int
negRange :: Int
safeIndex :: Ix i => (i, i) -> Int -> i -> Int

-- | Used to throw exceptions in array bounds-checking functions.
--   
--   ⚠ This function throws <tt>SomeException</tt> in all cases.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; badSafeIndex 2 5
--   *** Exception: Error in array index; 2 not in range [0..5)
--   </pre>
badSafeIndex :: Int -> Int -> Int

-- | The bounds with which an array was constructed.
bounds :: Array i e -> (i, i)

-- | The number of elements in the array.
numElements :: Array i e -> Int
numElementsSTArray :: STArray s i e -> Int

-- | The list of indices of an array in ascending order.
indices :: Ix i => Array i e -> [i]

-- | The list of elements of an array in index order.
elems :: Array i e -> [e]

-- | The list of associations of an array in index order.
assocs :: Ix i => Array i e -> [(i, e)]

-- | The <a>accumArray</a> function deals with repeated indices in the
--   association list using an <i>accumulating function</i> which combines
--   the values of associations with the same index.
--   
--   For example, given a list of values of some index type, <tt>hist</tt>
--   produces a histogram of the number of occurrences of each index within
--   a specified range:
--   
--   <pre>
--   hist :: (Ix a, Num b) =&gt; (a,a) -&gt; [a] -&gt; Array a b
--   hist bnds is = accumArray (+) 0 bnds [(i, 1) | i&lt;-is, inRange bnds i]
--   </pre>
--   
--   <tt>accumArray</tt> is strict in each result of applying the
--   accumulating function, although it is lazy in the initial value. Thus,
--   unlike arrays built with <a>array</a>, accumulated arrays should not
--   in general be recursive.
accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
adjust :: (e -> a -> e) -> MutableArray# s e -> (Int, a) -> STRep s b -> STRep s b

-- | Constructs an array identical to the first argument except that it has
--   been updated by the associations in the right argument. For example,
--   if <tt>m</tt> is a 1-origin, <tt>n</tt> by <tt>n</tt> matrix, then
--   
--   <pre>
--   m//[((i,i), 0) | i &lt;- [1..n]]
--   </pre>
--   
--   is the same matrix, except with the diagonal zeroed.
--   
--   Repeated indices in the association list are handled as for
--   <a>array</a>: Haskell 2010 specifies that the resulting array is
--   undefined (i.e. bottom), but GHC's implementation uses the last
--   association for each index.
(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
infixl 9 //

-- | <tt><a>accum</a> f</tt> takes an array and an association list and
--   accumulates pairs from the list into the array with the accumulating
--   function <tt>f</tt>. Thus <a>accumArray</a> can be defined using
--   <a>accum</a>:
--   
--   <pre>
--   accumArray f z b = accum f (array b [(i, z) | i &lt;- range b])
--   </pre>
--   
--   <tt>accum</tt> is strict in all the results of applying the
--   accumulation. However, it is lazy in the initial values of the array.
accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
amap :: (a -> b) -> Array i a -> Array i b

-- | <a>ixmap</a> allows for transformations on array indices. It may be
--   thought of as providing function composition on the right with the
--   mapping that the original array embodies.
--   
--   A similar transformation of array values may be achieved using
--   <a>fmap</a> from the <a>Array</a> instance of the <a>Functor</a>
--   class.
ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
eqArray :: (Ix i, Eq e) => Array i e -> Array i e -> Bool
cmpArray :: (Ix i, Ord e) => Array i e -> Array i e -> Ordering
cmpIntArray :: Ord e => Array Int e -> Array Int e -> Ordering
newSTArray :: Ix i => (i, i) -> e -> ST s (STArray s i e)
boundsSTArray :: STArray s i e -> (i, i)
readSTArray :: Ix i => STArray s i e -> i -> ST s e
writeSTArray :: Ix i => STArray s i e -> i -> e -> ST s ()
freezeSTArray :: STArray s i e -> ST s (Array i e)
thawSTArray :: Array i e -> ST s (STArray s i e)

-- | A left fold over the elements
foldlElems :: (b -> a -> b) -> b -> Array i a -> b

-- | A strict left fold over the elements
foldlElems' :: (b -> a -> b) -> b -> Array i a -> b

-- | A left fold over the elements with no starting value
foldl1Elems :: (a -> a -> a) -> Array i a -> a

-- | A right fold over the elements
foldrElems :: (a -> b -> b) -> b -> Array i a -> b

-- | A strict right fold over the elements
foldrElems' :: (a -> b -> b) -> b -> Array i a -> b

-- | A right fold over the elements with no starting value
foldr1Elems :: (a -> a -> a) -> Array i a -> a
fill :: MutableArray# s e -> (Int, e) -> STRep s a -> STRep s a
done :: i -> i -> Int -> MutableArray# s e -> STRep s (Array i e)
unsafeArray :: Ix i => (i, i) -> [(Int, e)] -> Array i e
unsafeArray' :: (i, i) -> Int -> [(Int, e)] -> Array i e
lessSafeIndex :: Ix i => (i, i) -> Int -> i -> Int
unsafeAt :: Array i e -> Int -> e
unsafeReplace :: Array i e -> [(Int, e)] -> Array i e
unsafeAccumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(Int, a)] -> Array i e
unsafeAccumArray' :: (e -> a -> e) -> e -> (i, i) -> Int -> [(Int, a)] -> Array i e
unsafeAccum :: (e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e
unsafeReadSTArray :: STArray s i e -> Int -> ST s e
unsafeWriteSTArray :: STArray s i e -> Int -> e -> ST s ()
unsafeFreezeSTArray :: STArray s i e -> ST s (Array i e)
unsafeThawSTArray :: Array i e -> ST s (STArray s i e)
instance GHC.Classes.Eq (GHC.Arr.STArray s i e)
instance GHC.Base.Functor (GHC.Arr.Array i)
instance (GHC.Ix.Ix i, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Arr.Array i e)
instance (GHC.Ix.Ix i, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Arr.Array i e)
instance (GHC.Ix.Ix a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (GHC.Arr.Array a b)


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <a>Integer</a> types are available from this module, and instances for
--   explicitly sized integral types are available from the <a>Data.Int</a>
--   and <a>Data.Word</a> modules.
module GHC.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative). Some instances may throw an <a>Overflow</a> exception
--   if given a negative input.
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>. Some instances may throw an
--   <a>Overflow</a> exception if given a negative input.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b
instance GHC.Bits.FiniteBits GHC.Types.Bool
instance GHC.Bits.Bits GHC.Types.Int
instance GHC.Bits.FiniteBits GHC.Types.Int
instance GHC.Bits.Bits GHC.Types.Word
instance GHC.Bits.FiniteBits GHC.Types.Word
instance GHC.Bits.Bits GHC.Types.Bool
instance GHC.Bits.Bits GHC.Num.Integer.Integer
instance GHC.Bits.Bits GHC.Num.Natural.Natural


-- | This module exports the TypeError family, which is used to provide
--   custom type errors, and the ErrorMessage kind used to define these
--   custom error messages. This is a type-level analogue to the term level
--   error function.
module GHC.TypeError

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:

-- | The type-level equivalent of <a>error</a>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <tt>Show</tt> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A type-level assert function.
--   
--   If the first argument evaluates to true, then the empty constraint is
--   returned, otherwise the second argument (which is intended to be
--   something which reduces to <a>TypeError</a> is used).
--   
--   For example, given some type level predicate <tt>P' :: Type -&gt;
--   Bool</tt>, it is possible to write the type synonym
--   
--   <pre>
--   type P a = Assert (P' a) (NotPError a)
--   </pre>
--   
--   where <tt>NotPError</tt> reduces to a <tt>TypeError</tt> which is
--   reported if the assertion fails.
type family Assert check errMsg


-- | This module exports the Type Literal kinds as well as the comparison
--   type families for those kinds. It is needed to prevent module cycles
--   while still allowing these identifiers to be imported in <a>Ord</a>.
module GHC.TypeLits.Internal

-- | (Kind) This is the kind of type-level symbols.
data () => Symbol

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (m :: Symbol) (n :: Symbol) :: Ordering

-- | Comparison of type-level characters.
type family CmpChar (a :: Char) (b :: Char) :: Ordering


-- | This module exports the Type Nat kind as well as the comparison type
--   family for that kinds. It is needed to prevent module cycles while
--   still allowing these identifiers to be imported in <a>Ord</a>.
module GHC.TypeNats.Internal

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | Comparison of type-level naturals, as a function.
type family CmpNat (m :: Natural) (n :: Natural) :: Ordering


-- | Implementations for the character predicates (isLower, isUpper, etc.)
--   and the conversions (toUpper, toLower). The implementation uses
--   libunicode on Unix systems if that is available.
module GHC.Unicode

-- | Version of Unicode standard used by <tt>base</tt>: <a>15.1.0</a>.
unicodeVersion :: Version

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin
--   capital letter A) and <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral
--   four). This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>UppercaseLetter</a> or
--   <a>TitlecaseLetter</a>.
--   
--   See <a>isUpperCase</a> for a more intuitive predicate. Note that
--   unlike <a>isUpperCase</a>, <a>isUpper</a> does select
--   <i>title-case</i> characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt>
--   Latin capital letter d with small letter z with caron) or <tt>'ᾯ'</tt>
--   (<tt>U+1FAF</tt> Greek capital letter omega with dasia and perispomeni
--   and prosgegrammeni).
isUpper :: Char -> Bool

-- | Selects upper-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Uppercase</tt>, which include letter-like characters such
--   as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin capital letter A) and
--   <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral four).
--   
--   See <a>isUpper</a> for the legacy predicate. Note that unlike
--   <a>isUpperCase</a>, <a>isUpper</a> does select <i>title-case</i>
--   characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt> Latin capital letter
--   d with small letter z with caron) or <tt>'ᾯ'</tt> (<tt>U+1FAF</tt>
--   Greek capital letter omega with dasia and perispomeni and
--   prosgegrammeni).
isUpperCase :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small
--   letter a) and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>LowercaseLetter</a>.
--   
--   See <a>isLowerCase</a> for a more intuitive predicate.
isLower :: Char -> Bool

-- | Selects lower-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Lowercase</tt>, which includes letter-like characters
--   such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small letter a)
--   and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   
--   See <a>isLower</a> for the legacy predicate.
isLowerCase :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char
instance GHC.Ix.Ix GHC.Unicode.GeneralCategory
instance GHC.Enum.Bounded GHC.Unicode.GeneralCategory
instance GHC.Enum.Enum GHC.Unicode.GeneralCategory
instance GHC.Classes.Ord GHC.Unicode.GeneralCategory
instance GHC.Classes.Eq GHC.Unicode.GeneralCategory
instance GHC.Show.Show GHC.Unicode.GeneralCategory


-- | Sized unsigned integral types: <a>Word</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, and <a>Word64</a>.
module GHC.Word

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word
W# :: Word# -> Word

-- | 8-bit unsigned integer type
data {-# CTYPE "HsWord8" #-} Word8
W8# :: Word8# -> Word8

-- | 16-bit unsigned integer type
data {-# CTYPE "HsWord16" #-} Word16
W16# :: Word16# -> Word16

-- | 32-bit unsigned integer type
data {-# CTYPE "HsWord32" #-} Word32
W32# :: Word32# -> Word32

-- | 64-bit unsigned integer type
data {-# CTYPE "HsWord64" #-} Word64
W64# :: Word64# -> Word64
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse the order of the bits in a <a>Word8</a>.
bitReverse8 :: Word8 -> Word8

-- | Reverse the order of the bits in a <a>Word16</a>.
bitReverse16 :: Word16 -> Word16

-- | Reverse the order of the bits in a <a>Word32</a>.
bitReverse32 :: Word32 -> Word32

-- | Reverse the order of the bits in a <a>Word64</a>.
bitReverse64 :: Word64 -> Word64
eqWord :: Word -> Word -> Bool
neWord :: Word -> Word -> Bool
gtWord :: Word -> Word -> Bool
geWord :: Word -> Word -> Bool
ltWord :: Word -> Word -> Bool
leWord :: Word -> Word -> Bool
eqWord8 :: Word8 -> Word8 -> Bool
neWord8 :: Word8 -> Word8 -> Bool
gtWord8 :: Word8 -> Word8 -> Bool
geWord8 :: Word8 -> Word8 -> Bool
ltWord8 :: Word8 -> Word8 -> Bool
leWord8 :: Word8 -> Word8 -> Bool
eqWord16 :: Word16 -> Word16 -> Bool
neWord16 :: Word16 -> Word16 -> Bool
gtWord16 :: Word16 -> Word16 -> Bool
geWord16 :: Word16 -> Word16 -> Bool
ltWord16 :: Word16 -> Word16 -> Bool
leWord16 :: Word16 -> Word16 -> Bool
eqWord32 :: Word32 -> Word32 -> Bool
neWord32 :: Word32 -> Word32 -> Bool
gtWord32 :: Word32 -> Word32 -> Bool
geWord32 :: Word32 -> Word32 -> Bool
ltWord32 :: Word32 -> Word32 -> Bool
leWord32 :: Word32 -> Word32 -> Bool
eqWord64 :: Word64 -> Word64 -> Bool
neWord64 :: Word64 -> Word64 -> Bool
gtWord64 :: Word64 -> Word64 -> Bool
geWord64 :: Word64 -> Word64 -> Bool
ltWord64 :: Word64 -> Word64 -> Bool
leWord64 :: Word64 -> Word64 -> Bool
instance GHC.Classes.Eq GHC.Word.Word64
instance GHC.Classes.Ord GHC.Word.Word64
instance GHC.Num.Num GHC.Word.Word64
instance GHC.Enum.Enum GHC.Word.Word64
instance GHC.Real.Integral GHC.Word.Word64
instance GHC.Bits.Bits GHC.Word.Word64
instance GHC.Bits.FiniteBits GHC.Word.Word64
instance GHC.Show.Show GHC.Word.Word64
instance GHC.Real.Real GHC.Word.Word64
instance GHC.Enum.Bounded GHC.Word.Word64
instance GHC.Ix.Ix GHC.Word.Word64
instance GHC.Classes.Eq GHC.Word.Word32
instance GHC.Classes.Ord GHC.Word.Word32
instance GHC.Num.Num GHC.Word.Word32
instance GHC.Enum.Enum GHC.Word.Word32
instance GHC.Real.Integral GHC.Word.Word32
instance GHC.Bits.Bits GHC.Word.Word32
instance GHC.Bits.FiniteBits GHC.Word.Word32
instance GHC.Show.Show GHC.Word.Word32
instance GHC.Real.Real GHC.Word.Word32
instance GHC.Enum.Bounded GHC.Word.Word32
instance GHC.Ix.Ix GHC.Word.Word32
instance GHC.Classes.Eq GHC.Word.Word16
instance GHC.Classes.Ord GHC.Word.Word16
instance GHC.Show.Show GHC.Word.Word16
instance GHC.Num.Num GHC.Word.Word16
instance GHC.Real.Real GHC.Word.Word16
instance GHC.Enum.Enum GHC.Word.Word16
instance GHC.Real.Integral GHC.Word.Word16
instance GHC.Enum.Bounded GHC.Word.Word16
instance GHC.Ix.Ix GHC.Word.Word16
instance GHC.Bits.Bits GHC.Word.Word16
instance GHC.Bits.FiniteBits GHC.Word.Word16
instance GHC.Classes.Eq GHC.Word.Word8
instance GHC.Classes.Ord GHC.Word.Word8
instance GHC.Show.Show GHC.Word.Word8
instance GHC.Num.Num GHC.Word.Word8
instance GHC.Real.Real GHC.Word.Word8
instance GHC.Enum.Enum GHC.Word.Word8
instance GHC.Real.Integral GHC.Word.Word8
instance GHC.Enum.Bounded GHC.Word.Word8
instance GHC.Ix.Ix GHC.Word.Word8
instance GHC.Bits.Bits GHC.Word.Word8
instance GHC.Bits.FiniteBits GHC.Word.Word8


-- | The types <a>Float</a> and <a>Double</a>, the classes <a>Floating</a>
--   and <a>RealFloat</a> and casting between Word32 and Float and Word64
--   and Double.
module GHC.Float

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | <tt><a>log1pexp</a> x</tt> computes <tt><a>log</a> (1 + <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 +
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>-1</tt>, <tt><a>log</a>
--   (1 + <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1pexp :: Floating a => a -> a

-- | <tt><a>log1mexp</a> x</tt> computes <tt><a>log</a> (1 - <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 -
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>1</tt>, <tt><a>log</a> (1
--   - <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1mexp :: Floating a => a -> a
infixr 8 **

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a
data FFFormat
FFExponent :: FFFormat
FFFixed :: FFFormat
FFGeneric :: FFFormat

-- | Used to prevent exponent over/underflow when encoding floating point
--   numbers. This is also the same as
--   
--   <pre>
--   \(x,y) -&gt; max (-x) (min x y)
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; clamp (-10) 5
--   10
--   </pre>
clamp :: Int -> Int -> Int

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: RealFloat a => a -> ShowS

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: RealFloat a => Rational -> a
formatRealFloat :: RealFloat a => FFFormat -> Maybe Int -> a -> String

-- | Default implementation for <tt><a>log1mexp</a></tt> requiring
--   <tt><a>Ord</a></tt> to test against a threshold to decide which
--   implementation variant to use.
log1mexpOrd :: (Ord a, Floating a) => a -> a
plusFloat :: Float -> Float -> Float
minusFloat :: Float -> Float -> Float
negateFloat :: Float -> Float
timesFloat :: Float -> Float -> Float
fabsFloat :: Float -> Float

-- | Convert an Integer to a Float#
integerToFloat# :: Integer -> Float#

-- | Converts a positive integer to a floating-point value.
--   
--   The value nearest to the argument will be returned. If there are two
--   such values, the one with an even significand will be returned (i.e.
--   IEEE roundTiesToEven).
--   
--   The argument must be strictly positive, and <tt>floatRadix (undefined
--   :: a)</tt> must be 2.
integerToBinaryFloat' :: RealFloat a => Integer -> a

-- | Convert a Natural to a Float#
naturalToFloat# :: Natural -> Float#
divideFloat :: Float -> Float -> Float
rationalToFloat :: Integer -> Integer -> Float
fromRat'' :: RealFloat a => Int -> Int -> Integer -> Integer -> a
properFractionFloat :: Integral b => Float -> (b, Float)
truncateFloat :: Integral b => Float -> b
roundFloat :: Integral b => Float -> b
floorFloat :: Integral b => Float -> b
ceilingFloat :: Integral b => Float -> b
expFloat :: Float -> Float
logFloat :: Float -> Float
sqrtFloat :: Float -> Float
sinFloat :: Float -> Float
cosFloat :: Float -> Float
tanFloat :: Float -> Float
asinFloat :: Float -> Float
acosFloat :: Float -> Float
atanFloat :: Float -> Float
sinhFloat :: Float -> Float
coshFloat :: Float -> Float
tanhFloat :: Float -> Float
powerFloat :: Float -> Float -> Float
asinhFloat :: Float -> Float
acoshFloat :: Float -> Float
atanhFloat :: Float -> Float
log1pFloat :: Float -> Float
expm1Float :: Float -> Float
isFloatFinite :: Float -> Int
isFloatNaN :: Float -> Int
isFloatInfinite :: Float -> Int
isFloatDenormalized :: Float -> Int
isFloatNegativeZero :: Float -> Int
showSignedFloat :: RealFloat a => (a -> ShowS) -> Int -> a -> ShowS
plusDouble :: Double -> Double -> Double
minusDouble :: Double -> Double -> Double
negateDouble :: Double -> Double
timesDouble :: Double -> Double -> Double
fabsDouble :: Double -> Double

-- | Convert an Integer to a Double#
integerToDouble# :: Integer -> Double#

-- | Encode a Natural (mantissa) into a Double#
naturalToDouble# :: Natural -> Double#
divideDouble :: Double -> Double -> Double
rationalToDouble :: Integer -> Integer -> Double
expDouble :: Double -> Double
logDouble :: Double -> Double
sqrtDouble :: Double -> Double
sinDouble :: Double -> Double
cosDouble :: Double -> Double
tanDouble :: Double -> Double
asinDouble :: Double -> Double
acosDouble :: Double -> Double
atanDouble :: Double -> Double
sinhDouble :: Double -> Double
coshDouble :: Double -> Double
tanhDouble :: Double -> Double
powerDouble :: Double -> Double -> Double
asinhDouble :: Double -> Double
acoshDouble :: Double -> Double
atanhDouble :: Double -> Double
log1pDouble :: Double -> Double
expm1Double :: Double -> Double
properFractionDouble :: Integral b => Double -> (b, Double)
truncateDouble :: Integral b => Double -> b
roundDouble :: Integral b => Double -> b
ceilingDouble :: Integral b => Double -> b
floorDouble :: Integral b => Double -> b
isDoubleFinite :: Double -> Int
isDoubleNaN :: Double -> Int
isDoubleInfinite :: Double -> Int
isDoubleDenormalized :: Double -> Int
isDoubleNegativeZero :: Double -> Int
formatRealFloatAlt :: RealFloat a => FFFormat -> Maybe Int -> Bool -> a -> String
roundTo :: Int -> Int -> [Int] -> (Int, [Int])
expt :: Integer -> Int -> Integer
roundingMode# :: Integer -> Int# -> Int#
fromRat' :: RealFloat a => Rational -> a
minExpt :: Int
maxExpt :: Int
expts :: Array Int Integer
maxExpt10 :: Int
expts10 :: Array Int Integer
gtFloat :: Float -> Float -> Bool
geFloat :: Float -> Float -> Bool
ltFloat :: Float -> Float -> Bool
leFloat :: Float -> Float -> Bool
gtDouble :: Double -> Double -> Bool
geDouble :: Double -> Double -> Bool
leDouble :: Double -> Double -> Bool
ltDouble :: Double -> Double -> Bool
double2Float :: Double -> Float
float2Double :: Float -> Double
word2Double :: Word -> Double
word2Float :: Word -> Float

-- | <tt><a>castWord32ToFloat</a> w</tt> does a bit-for-bit copy from an
--   integral value to a floating-point value.
castWord32ToFloat :: Word32 -> Float
stgWord32ToFloat :: Word32# -> Float#

-- | <tt><a>castFloatToWord32</a> f</tt> does a bit-for-bit copy from a
--   floating-point value to an integral value.
castFloatToWord32 :: Float -> Word32
stgFloatToWord32 :: Float# -> Word32#

-- | <tt><a>castWord64ToDouble</a> w</tt> does a bit-for-bit copy from an
--   integral value to a floating-point value.
castWord64ToDouble :: Word64 -> Double
stgWord64ToDouble :: Word64# -> Double#

-- | <tt><tt>castFloatToWord64</tt> f</tt> does a bit-for-bit copy from a
--   floating-point value to an integral value.
castDoubleToWord64 :: Double -> Word64
stgDoubleToWord64 :: Double# -> Word64#

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double
D# :: Double# -> Double
data Float# :: TYPE 'FloatRep
data Double# :: TYPE 'DoubleRep
double2Int :: Double -> Int
int2Double :: Int -> Double
float2Int :: Float -> Int
int2Float :: Int -> Float
eqFloat :: Float -> Float -> Bool
eqDouble :: Double -> Double -> Bool
instance GHC.Float.RealFloat GHC.Types.Float
instance GHC.Float.RealFloat GHC.Types.Double
instance GHC.Float.Floating GHC.Types.Float
instance GHC.Float.Floating GHC.Types.Double
instance GHC.Num.Num GHC.Types.Float
instance GHC.Real.Real GHC.Types.Float
instance GHC.Real.Fractional GHC.Types.Float
instance GHC.Real.RealFrac GHC.Types.Float
instance GHC.Show.Show GHC.Types.Float
instance GHC.Num.Num GHC.Types.Double
instance GHC.Real.Real GHC.Types.Double
instance GHC.Real.Fractional GHC.Types.Double
instance GHC.Real.RealFrac GHC.Types.Double
instance GHC.Show.Show GHC.Types.Double
instance GHC.Enum.Enum GHC.Types.Float
instance GHC.Enum.Enum GHC.Types.Double


-- | The arbitrary-precision <a>Natural</a> number type.
module Numeric.Natural

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural


-- | This is a library of parser combinators, originally written by Koen
--   Claessen. It parses all alternatives in parallel, so it never keeps
--   hold of the beginning of the input string, a common source of space
--   leaks with other parsers. The <tt>(<a>+++</a>)</tt> choice combinator
--   is genuinely commutative; it makes no difference which branch is
--   "shorter".
module Text.ParserCombinators.ReadP
data ReadP a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadP Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadP String

-- | Symmetric choice.
(+++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 +++

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadP a -> ReadP a -> ReadP a
infixr 5 <++

-- | Transforms a parser into one that does the same, but in addition
--   returns the exact characters read. IMPORTANT NOTE: <a>gather</a> gives
--   a runtime error if its first argument is built using any occurrences
--   of readS_to_P.
gather :: ReadP a -> ReadP (String, a)

-- | Always fails.
pfail :: ReadP a

-- | Succeeds iff we are at the end of input
eof :: ReadP ()

-- | Consumes and returns the next character, if it satisfies the specified
--   predicate.
satisfy :: (Char -> Bool) -> ReadP Char

-- | Parses and returns the specified character.
char :: Char -> ReadP Char

-- | Parses and returns the specified string.
string :: String -> ReadP String

-- | Parses the first zero or more characters satisfying the predicate.
--   Always succeeds, exactly once having consumed all the characters Hence
--   NOT the same as (many (satisfy p))
munch :: (Char -> Bool) -> ReadP String

-- | Parses the first one or more characters satisfying the predicate.
--   Fails if none, else succeeds exactly once having consumed all the
--   characters Hence NOT the same as (many1 (satisfy p))
munch1 :: (Char -> Bool) -> ReadP String

-- | Skips all whitespace.
skipSpaces :: ReadP ()

-- | Combines all parsers in the specified list.
choice :: [ReadP a] -> ReadP a

-- | <tt>count n p</tt> parses <tt>n</tt> occurrences of <tt>p</tt> in
--   sequence. A list of results is returned.
count :: Int -> ReadP a -> ReadP [a]

-- | <tt>between open close p</tt> parses <tt>open</tt>, followed by
--   <tt>p</tt> and finally <tt>close</tt>. Only the value of <tt>p</tt> is
--   returned.
between :: ReadP open -> ReadP close -> ReadP a -> ReadP a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: a -> ReadP a -> ReadP a

-- | <tt>optional p</tt> optionally parses <tt>p</tt> and always returns
--   <tt>()</tt>.
optional :: ReadP a -> ReadP ()

-- | Parses zero or more occurrences of the given parser.
many :: ReadP a -> ReadP [a]

-- | Parses one or more occurrences of the given parser.
many1 :: ReadP a -> ReadP [a]

-- | Like <a>many</a>, but discards the result.
skipMany :: ReadP a -> ReadP ()

-- | Like <a>many1</a>, but discards the result.
skipMany1 :: ReadP a -> ReadP ()

-- | <tt>sepBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>sepBy1 p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>. Returns a list of values returned by
--   <tt>p</tt>.
sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>endBy p sep</tt> parses one or more occurrences of <tt>p</tt>,
--   separated and ended by <tt>sep</tt>.
endBy1 :: ReadP a -> ReadP sep -> ReadP [a]

-- | <tt>chainr p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>right</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | <tt>chainl p op x</tt> parses zero or more occurrences of <tt>p</tt>,
--   separated by <tt>op</tt>. Returns a value produced by a <i>left</i>
--   associative application of all functions returned by <tt>op</tt>. If
--   there are no occurrences of <tt>p</tt>, <tt>x</tt> is returned.
chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a

-- | Like <a>chainl</a>, but parses one or more occurrences of <tt>p</tt>.
chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | Like <a>chainr</a>, but parses one or more occurrences of <tt>p</tt>.
chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a

-- | <tt>manyTill p end</tt> parses zero or more occurrences of <tt>p</tt>,
--   until <tt>end</tt> succeeds. Returns a list of values returned by
--   <tt>p</tt>.
manyTill :: ReadP a -> ReadP end -> ReadP [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Converts a parser into a Haskell ReadS-style function. This is the
--   main way in which you can "run" a <a>ReadP</a> parser: the expanded
--   type is <tt> readP_to_S :: ReadP a -&gt; String -&gt; [(a,String)]
--   </tt>
readP_to_S :: ReadP a -> ReadS a

-- | Converts a Haskell ReadS-style function into a parser. Warning: This
--   introduces local backtracking in the resulting parser, and therefore a
--   possible inefficiency.
readS_to_P :: ReadS a -> ReadP a
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P


-- | This library defines parser combinators for precedence parsing.
module Text.ParserCombinators.ReadPrec
data ReadPrec a
type Prec = Int
minPrec :: Prec

-- | Lift a precedence-insensitive <a>ReadP</a> to a <a>ReadPrec</a>.
lift :: ReadP a -> ReadPrec a

-- | <tt>(prec n p)</tt> checks whether the precedence context is less than
--   or equal to <tt>n</tt>, and
--   
--   <ul>
--   <li>if not, fails</li>
--   <li>if so, parses <tt>p</tt> in context <tt>n</tt>.</li>
--   </ul>
prec :: Prec -> ReadPrec a -> ReadPrec a

-- | Increases the precedence context by one.
step :: ReadPrec a -> ReadPrec a

-- | Resets the precedence context to zero.
reset :: ReadPrec a -> ReadPrec a

-- | Consumes and returns the next character. Fails if there is no input
--   left.
get :: ReadPrec Char

-- | Look-ahead: returns the part of the input that is left, without
--   consuming it.
look :: ReadPrec String

-- | Symmetric choice.
(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Local, exclusive, left-biased choice: If left parser locally produces
--   any result at all, then right parser is not used.
(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a

-- | Always fails.
pfail :: ReadPrec a

-- | Combines all parsers in the specified list.
choice :: [ReadPrec a] -> ReadPrec a
readPrec_to_P :: ReadPrec a -> Int -> ReadP a
readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
readPrec_to_S :: ReadPrec a -> Int -> ReadS a
readS_to_Prec :: (Int -> ReadS a) -> ReadPrec a
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec


-- | The cut-down Haskell lexer, used by Text.Read
module Text.Read.Lex
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

data Number

numberToInteger :: Number -> Maybe Integer

numberToFixed :: Integer -> Number -> Maybe (Integer, Integer)

numberToRational :: Number -> Rational

numberToRangedRational :: (Int, Int) -> Number -> Maybe Rational
lex :: ReadP Lexeme

expect :: Lexeme -> ReadP ()

-- | Haskell lexer: returns the lexed string, rather than the lexeme
hsLex :: ReadP String
lexChar :: ReadP Char
readBinP :: (Eq a, Num a) => ReadP a
readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
readOctP :: (Eq a, Num a) => ReadP a
readDecP :: (Eq a, Num a) => ReadP a
readHexP :: (Eq a, Num a) => ReadP a
isSymbolChar :: Char -> Bool
instance GHC.Show.Show Text.Read.Lex.Number
instance GHC.Classes.Eq Text.Read.Lex.Number
instance GHC.Show.Show Text.Read.Lex.Lexeme
instance GHC.Classes.Eq Text.Read.Lex.Lexeme


-- | The <a>Read</a> class and instances for basic data types.
module GHC.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme
expectP :: Lexeme -> ReadPrec ()

-- | <tt>(paren p)</tt> parses "(P0)" where <tt>p</tt> parses "P0" in
--   precedence context zero
paren :: ReadPrec a -> ReadPrec a

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | <tt>(list p)</tt> parses a list of things parsed by <tt>p</tt>, using
--   the usual square-bracket syntax.
list :: ReadPrec a -> ReadPrec [a]

-- | Parse the specified lexeme and continue as specified. Esp useful for
--   nullary constructors; e.g. <tt>choose [("A", return A), ("B", return
--   B)]</tt> We match both Ident and Symbol because the constructor might
--   be an operator eg <tt>(:~:)</tt>
choose :: [(String, ReadPrec a)] -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]
readNumber :: Num a => (Lexeme -> ReadPrec a) -> ReadPrec a

-- | <a>Read</a> parser for a record field, of the form
--   <tt>fieldName=value</tt>. The <tt>fieldName</tt> must be an
--   alphanumeric identifier; for symbols (operator-style) field names,
--   e.g. <tt>(#)</tt>, use <a>readSymField</a>). The second argument is a
--   parser for the field value.
readField :: String -> ReadPrec a -> ReadPrec a

-- | <a>Read</a> parser for a record field, of the form
--   <tt>fieldName#=value</tt>. That is, an alphanumeric identifier
--   <tt>fieldName</tt> followed by the symbol <tt>#</tt>. The second
--   argument is a parser for the field value.
--   
--   Note that <a>readField</a> does not suffice for this purpose due to
--   <a>#5041</a>.
readFieldHash :: String -> ReadPrec a -> ReadPrec a

-- | <a>Read</a> parser for a symbol record field, of the form
--   <tt>(###)=value</tt> (where <tt>###</tt> is the field name). The field
--   name must be a symbol (operator-style), e.g. <tt>(#)</tt>. For regular
--   (alphanumeric) field names, use <a>readField</a>. The second argument
--   is a parser for the field value.
readSymField :: String -> ReadPrec a -> ReadPrec a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a
instance GHC.Read.Read GHC.Unicode.GeneralCategory
instance GHC.Read.Read a => GHC.Read.Read (GHC.Base.NonEmpty a)
instance GHC.Read.Read GHC.Base.Void
instance GHC.Read.Read a => GHC.Read.Read (Solo a)
instance GHC.Read.Read GHC.Types.Char
instance GHC.Read.Read GHC.Types.Bool
instance GHC.Read.Read GHC.Types.Ordering
instance GHC.Read.Read a => GHC.Read.Read (GHC.Maybe.Maybe a)
instance GHC.Read.Read a => GHC.Read.Read [a]
instance (GHC.Ix.Ix a, GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (GHC.Arr.Array a b)
instance GHC.Read.Read Text.Read.Lex.Lexeme
instance GHC.Read.Read GHC.Types.Int
instance GHC.Read.Read GHC.Types.Word
instance GHC.Read.Read GHC.Word.Word8
instance GHC.Read.Read GHC.Word.Word16
instance GHC.Read.Read GHC.Word.Word32
instance GHC.Read.Read GHC.Word.Word64
instance GHC.Read.Read GHC.Num.Integer.Integer
instance GHC.Read.Read GHC.Num.Natural.Natural
instance GHC.Read.Read GHC.Types.Float
instance GHC.Read.Read GHC.Types.Double
instance (GHC.Real.Integral a, GHC.Read.Read a) => GHC.Read.Read (GHC.Real.Ratio a)
instance GHC.Read.Read ()
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (a, b)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => GHC.Read.Read (a, b, c)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d) => GHC.Read.Read (a, b, c, d)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e) => GHC.Read.Read (a, b, c, d, e)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f) => GHC.Read.Read (a, b, c, d, e, f)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g) => GHC.Read.Read (a, b, c, d, e, f, g)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h) => GHC.Read.Read (a, b, c, d, e, f, g, h)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i) => GHC.Read.Read (a, b, c, d, e, f, g, h, i)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n, GHC.Read.Read o) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)


-- | Odds and ends, mostly functions for reading and showing
--   <a>RealFloat</a>-like kind of values.
module Numeric

-- | Converts a possibly-negative <a>Real</a> value to a string.
showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS

-- | Shows a <i>non-negative</i> <a>Integral</a> number using the base
--   specified by the first argument, and the character representation
--   specified by the second.
showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 10.
showInt :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 2.
showBin :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 16.
showHex :: Integral a => a -> ShowS

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 8.
showOct :: Integral a => a -> ShowS

-- | Show a signed <a>RealFloat</a> value using scientific (exponential)
--   notation (e.g. <tt>2.45e2</tt>, <tt>1.5e-3</tt>).
--   
--   In the call <tt><a>showEFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showEFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   In the call <tt><a>showFFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showFFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   In the call <tt><a>showGFloat</a> digs val</tt>, if <tt>digs</tt> is
--   <a>Nothing</a>, the value is shown to full precision; if <tt>digs</tt>
--   is <tt><a>Just</a> d</tt>, then at most <tt>d</tt> digits after the
--   decimal point are shown.
showGFloat :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showGFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value to full precision using standard
--   decimal notation for arguments whose absolute value lies between
--   <tt>0.1</tt> and <tt>9,999,999</tt>, and scientific notation
--   otherwise.
showFloat :: RealFloat a => a -> ShowS

-- | Show a floating-point value in the hexadecimal format, similar to the
--   <tt>%a</tt> specifier in C's printf.
--   
--   <pre>
--   &gt;&gt;&gt; showHFloat (212.21 :: Double) ""
--   "0x1.a86b851eb851fp7"
--   
--   &gt;&gt;&gt; showHFloat (-12.76 :: Float) ""
--   "-0x1.9851ecp3"
--   
--   &gt;&gt;&gt; showHFloat (-0 :: Double) ""
--   "-0x0p+0"
--   </pre>
showHFloat :: RealFloat a => a -> ShowS

-- | <a>floatToDigits</a> takes a base and a non-negative <a>RealFloat</a>
--   number, and returns a list of digits and an exponent. In particular,
--   if <tt>x&gt;=0</tt>, and
--   
--   <pre>
--   floatToDigits base x = ([d1,d2,...,dn], e)
--   </pre>
--   
--   then
--   
--   <ol>
--   <li><pre>n &gt;= 1</pre></li>
--   <li><pre>x = 0.d1d2...dn * (base**e)</pre></li>
--   <li><pre>0 &lt;= di &lt;= base-1</pre></li>
--   </ol>
floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)

-- | Reads a <i>signed</i> <a>Real</a> value, given a reader for an
--   unsigned value.
readSigned :: Real a => ReadS a -> ReadS a

-- | Reads an <i>unsigned</i> integral value in an arbitrary base.
readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a

-- | Read an unsigned number in binary notation.
--   
--   <pre>
--   &gt;&gt;&gt; readBin "10011"
--   [(19,"")]
--   </pre>
readBin :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in decimal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readDec "0644"
--   [(644,"")]
--   </pre>
readDec :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in octal notation.
--   
--   <pre>
--   &gt;&gt;&gt; readOct "0644"
--   [(420,"")]
--   </pre>
readOct :: (Eq a, Num a) => ReadS a

-- | Read an unsigned number in hexadecimal notation. Both upper or lower
--   case letters are allowed.
--   
--   <pre>
--   &gt;&gt;&gt; readHex "deadbeef"
--   [(3735928559,"")]
--   </pre>
readHex :: (Eq a, Num a) => ReadS a

-- | Reads an <i>unsigned</i> <a>RealFrac</a> value, expressed in decimal
--   scientific notation.
--   
--   Note that this function takes time linear in the magnitude of its
--   input which can scale exponentially with input size (e.g.
--   <tt>"1e100000000"</tt> is a very large number while having a very
--   small textual form). For this reason, users should take care to avoid
--   using this function on untrusted input. Users needing to parse
--   floating point values (e.g. <a>Float</a>) are encouraged to instead
--   use <tt>read</tt>, which does not suffer from this issue.
readFloat :: RealFrac a => ReadS a

-- | Reads a non-empty string of decimal digits.
lexDigits :: ReadS String

-- | Converts a <a>Rational</a> value into any type in class
--   <a>RealFloat</a>.
fromRat :: RealFloat a => Rational -> a

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | <tt><a>log1pexp</a> x</tt> computes <tt><a>log</a> (1 + <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 +
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>-1</tt>, <tt><a>log</a>
--   (1 + <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1pexp :: Floating a => a -> a

-- | <tt><a>log1mexp</a> x</tt> computes <tt><a>log</a> (1 - <a>exp</a>
--   x)</tt>, but provides more precise results if possible.
--   
--   Examples:
--   
--   <ul>
--   <li>if <tt>x</tt> is a large negative number, <tt><a>log</a> (1 -
--   <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>log1p</a>.</li>
--   <li>if <tt><a>exp</a> x</tt> is close to <tt>1</tt>, <tt><a>log</a> (1
--   - <a>exp</a> x)</tt> will be imprecise for the reasons given in
--   <a>expm1</a>.</li>
--   </ul>
log1mexp :: Floating a => a -> a
infixr 8 **


-- | The <a>Ptr</a> and <a>FunPtr</a> types and operations.
module GHC.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b
instance GHC.Classes.Ord (GHC.Ptr.Ptr a)
instance GHC.Classes.Eq (GHC.Ptr.Ptr a)
instance GHC.Classes.Ord (GHC.Ptr.FunPtr a)
instance GHC.Classes.Eq (GHC.Ptr.FunPtr a)
instance GHC.Show.Show (GHC.Ptr.FunPtr a)
instance GHC.Show.Show (GHC.Ptr.Ptr a)


-- | ⚠ Warning: Starting <tt>base-4.18</tt>, this module is being
--   deprecated. See
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/21461</a> for more
--   information.
--   
--   This module provides a small set of low-level functions for packing
--   and unpacking a chunk of bytes. Used by code emitted by the compiler
--   plus the prelude libraries.
--   
--   The programmer level view of packed strings is provided by a GHC
--   system library PackedString.
module GHC.Pack
packCString# :: [Char] -> ByteArray#
unpackCString :: Ptr a -> [Char]
unpackCString# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackAppendCString# :: Addr# -> [Char] -> [Char]


-- | This module provides typed <tt>const</tt> pointers to foreign data. It
--   is part of the Foreign Function Interface (FFI).
module Foreign.C.ConstPtr

-- | A pointer with the C <tt>const</tt> qualifier. For instance, an
--   argument of type <tt>ConstPtr CInt</tt> would be marshalled as
--   <tt>const int*</tt>.
--   
--   While <tt>const</tt>-ness generally does not matter for <tt>ccall</tt>
--   imports (since <tt>const</tt> and non-<tt>const</tt> pointers
--   typically have equivalent calling conventions), it does matter for
--   <tt>capi</tt> imports. See GHC #22043.
newtype ConstPtr a
ConstPtr :: Ptr a -> ConstPtr a
[unConstPtr] :: ConstPtr a -> Ptr a
instance GHC.Classes.Ord (Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Classes.Eq (Foreign.C.ConstPtr.ConstPtr a)
instance GHC.Show.Show (Foreign.C.ConstPtr.ConstPtr a)

module GHC.Fingerprint.Type
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint


-- | The IOMode type
module GHC.IO.IOMode

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
instance GHC.Show.Show GHC.IO.IOMode.IOMode
instance GHC.Read.Read GHC.IO.IOMode.IOMode
instance GHC.Enum.Enum GHC.IO.IOMode.IOMode
instance GHC.Ix.Ix GHC.IO.IOMode.IOMode
instance GHC.Classes.Ord GHC.IO.IOMode.IOMode
instance GHC.Classes.Eq GHC.IO.IOMode.IOMode


-- | Unsigned integer types.
module Data.Word

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word

-- | 8-bit unsigned integer type
data {-# CTYPE "HsWord8" #-} Word8

-- | 16-bit unsigned integer type
data {-# CTYPE "HsWord16" #-} Word16

-- | 32-bit unsigned integer type
data {-# CTYPE "HsWord32" #-} Word32

-- | 64-bit unsigned integer type
data {-# CTYPE "HsWord64" #-} Word64

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse the order of the bits in a <a>Word8</a>.
bitReverse8 :: Word8 -> Word8

-- | Reverse the order of the bits in a <a>Word16</a>.
bitReverse16 :: Word16 -> Word16

-- | Reverse the order of the bits in a <a>Word32</a>.
bitReverse32 :: Word32 -> Word32

-- | Reverse the order of the bits in a <a>Word64</a>.
bitReverse64 :: Word64 -> Word64

module GHC.Clock

-- | Return monotonic time in seconds, since some unspecified starting
--   point
getMonotonicTime :: IO Double

-- | Return monotonic time in nanoseconds, since some unspecified starting
--   point
getMonotonicTimeNSec :: IO Word64


-- | Definition of propositional equality <tt>(<a>:~:</a>)</tt>.
--   Pattern-matching on a variable of type <tt>(a <a>:~:</a> b)</tt>
--   produces a proof that <tt>a <a>~</a> b</tt>.
module Data.Type.Equality

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data a :~~: b
[HRefl] :: a :~~: a
infix 4 :~~:

-- | Symmetry of equality
sym :: (a :~: b) -> b :~: a

-- | Transitivity of equality
trans :: (a :~: b) -> (b :~: c) -> a :~: c

-- | Type-safe cast, using propositional equality
castWith :: (a :~: b) -> a -> b

-- | Generalized form of type-safe cast using propositional equality
gcastWith :: (a :~: b) -> (a ~ b => r) -> r

-- | Apply one equality to another, respectively
apply :: (f :~: g) -> (a :~: b) -> f a :~: g b

-- | Extract equality of the arguments from an equality of applied types
inner :: (f a :~: g b) -> a :~: b

-- | Extract equality of type constructors from an equality of applied
--   types
outer :: (f a :~: g b) -> f :~: g

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>.
--   
--   The result should be <tt>Just Refl</tt> if and only if the types
--   applied to <tt>f</tt> are equal:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b
--   </pre>
--   
--   Typically, only singleton types should inhabit this class. In that
--   case type argument equality coincides with term equality:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b ⟺ x = y
--   </pre>
--   
--   <pre>
--   isJust (testEquality x y) = x == y
--   </pre>
--   
--   Singleton types are not required, however, and so the latter two
--   would-be laws are not in fact valid in general.
class TestEquality f

-- | Conditionally prove the equality of <tt>a</tt> and <tt>b</tt>.
testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)

-- | A type family to compute Boolean equality.
type family a == b
infix 4 ==
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Eq (a Data.Type.Equality.:~~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Show.Show (a Data.Type.Equality.:~~: b)
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Ord (a Data.Type.Equality.:~~: b)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Read.Read (a Data.Type.Equality.:~~: b)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~~: b)
instance forall k (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a)
instance forall k1 k2 (a :: k1) (b :: k2). (a GHC.Types.~~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~~: b)
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b)


-- | Definition of representational equality (<a>Coercion</a>).
module Data.Type.Coercion

-- | Representational equality. If <tt>Coercion a b</tt> is inhabited by
--   some terminating value, then the type <tt>a</tt> has the same
--   underlying representation as the type <tt>b</tt>.
--   
--   To use this equality in practice, pattern-match on the <tt>Coercion a
--   b</tt> to get out the <tt>Coercible a b</tt> instance, and then use
--   <a>coerce</a> to apply it.
data Coercion a b
[Coercion] :: Coercible a b => Coercion a b

-- | Type-safe cast, using representational equality
coerceWith :: Coercion a b -> a -> b

-- | Generalized form of type-safe cast using representational equality
gcoerceWith :: Coercion a b -> (Coercible a b => r) -> r

-- | Symmetry of representational equality
sym :: Coercion a b -> Coercion b a

-- | Transitivity of representational equality
trans :: Coercion a b -> Coercion b c -> Coercion a c

-- | Convert propositional (nominal) equality to representational equality
repr :: (a :~: b) -> Coercion a b

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestCoercion f

-- | Conditionally prove the representational equality of <tt>a</tt> and
--   <tt>b</tt>.
testCoercion :: TestCoercion f => f a -> f b -> Maybe (Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a)
instance forall k1 k (a :: k1). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a)
instance forall k (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a)
instance forall k (a :: k) (b :: k). GHC.Types.Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b)


module Control.Category

-- | A class for categories. Instances should satisfy the laws
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
class Category cat

-- | the identity morphism
id :: Category cat => cat a a

-- | morphism composition
(.) :: Category cat => cat b c -> cat a b -> cat a c
infixr 9 .

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>
instance Control.Category.Category (->)
instance Control.Category.Category (Data.Type.Equality.:~:)
instance Control.Category.Category (Data.Type.Equality.:~~:)
instance Control.Category.Category Data.Type.Coercion.Coercion


-- | Definition of a Proxy type (poly-kinded in GHC)
module Data.Proxy

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy t
Proxy :: Proxy t

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Proxy :: Proxy Word8)
--   asProxyTypeOf 123 (Proxy :: Proxy Word8) :: Word8
--   </pre>
--   
--   Note the lower-case <tt>proxy</tt> in the definition. This allows any
--   type constructor with just one argument to be passed to the function,
--   for example we could also write
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Just (undefined :: Word8))
--   asProxyTypeOf 123 (Just (undefined :: Word8)) :: Word8
--   </pre>
asProxyTypeOf :: a -> proxy a -> a

-- | A concrete, promotable proxy type, for use at the kind level. There
--   are no instances for this because it is intended at the kind level
--   only
data KProxy (t :: Type)
KProxy :: KProxy (t :: Type)
instance forall k (t :: k). GHC.Read.Read (Data.Proxy.Proxy t)
instance forall k (t :: k). GHC.Enum.Bounded (Data.Proxy.Proxy t)
instance forall k (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Show.Show (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Ix.Ix (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Semigroup (Data.Proxy.Proxy s)
instance forall k (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s)
instance GHC.Base.Functor Data.Proxy.Proxy
instance GHC.Base.Applicative Data.Proxy.Proxy
instance GHC.Base.Alternative Data.Proxy.Proxy
instance GHC.Base.Monad Data.Proxy.Proxy
instance GHC.Base.MonadPlus Data.Proxy.Proxy


-- | The Either type, and associated operations.
module Data.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b)
instance GHC.Base.Functor (Data.Either.Either a)
instance GHC.Base.Semigroup (Data.Either.Either a b)
instance GHC.Base.Applicative (Data.Either.Either e)
instance GHC.Base.Monad (Data.Either.Either e)


-- | Converting strings to values.
--   
--   The <a>Text.Read</a> library is the canonical library to import for
--   <a>Read</a>-class facilities. For GHC only, it offers an extended and
--   much improved <a>Read</a> class, which constitutes a proposed
--   alternative to the Haskell 2010 <a>Read</a>. In particular, writing
--   parsers is easier, and the parsers are much more efficient.
module Text.Read

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String
data Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result. A <a>Left</a> value indicates a parse error.
--   
--   <pre>
--   &gt;&gt;&gt; readEither "123" :: Either String Int
--   Right 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readEither "hello" :: Either String Int
--   Left "Prelude.read: no parse"
--   </pre>
readEither :: Read a => String -> Either String a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a


-- | The Char type and associated operations.
module Data.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small
--   letter a) and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>LowercaseLetter</a>.
--   
--   See <a>isLowerCase</a> for a more intuitive predicate.
isLower :: Char -> Bool

-- | Selects lower-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Lowercase</tt>, which includes letter-like characters
--   such as: <tt>'ⓐ'</tt> (<tt>U+24D0</tt> circled Latin small letter a)
--   and <tt>'ⅳ'</tt> (<tt>U+2173</tt> small Roman numeral four).
--   
--   See <a>isLower</a> for the legacy predicate.
isLowerCase :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
--   
--   <b>Note:</b> this predicate does <i>not</i> work for letter-like
--   characters such as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin
--   capital letter A) and <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral
--   four). This is due to selecting only characters with the
--   <a>GeneralCategory</a> <a>UppercaseLetter</a> or
--   <a>TitlecaseLetter</a>.
--   
--   See <a>isUpperCase</a> for a more intuitive predicate. Note that
--   unlike <a>isUpperCase</a>, <a>isUpper</a> does select
--   <i>title-case</i> characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt>
--   Latin capital letter d with small letter z with caron) or <tt>'ᾯ'</tt>
--   (<tt>U+1FAF</tt> Greek capital letter omega with dasia and perispomeni
--   and prosgegrammeni).
isUpper :: Char -> Bool

-- | Selects upper-case Unicode letter-like characters.
--   
--   <b>Note:</b> this predicate selects characters with the Unicode
--   property <tt>Uppercase</tt>, which include letter-like characters such
--   as: <tt>'Ⓐ'</tt> (<tt>U+24B6</tt> circled Latin capital letter A) and
--   <tt>'Ⅳ'</tt> (<tt>U+2163</tt> Roman numeral four).
--   
--   See <a>isUpper</a> for the legacy predicate. Note that unlike
--   <a>isUpperCase</a>, <a>isUpper</a> does select <i>title-case</i>
--   characters such as <tt>'ǅ'</tt> (<tt>U+01C5</tt> Latin capital letter
--   d with small letter z with caron) or <tt>'ᾯ'</tt> (<tt>U+1FAF</tt>
--   Greek capital letter omega with dasia and perispomeni and
--   prosgegrammeni).
isUpperCase :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char


-- | This module defines bitwise operations for signed and unsigned
--   integers. Instances of the class <a>Bits</a> for the <a>Int</a> and
--   <tt>Integer</tt> types are available from this module, and instances
--   for explicitly sized integral types are available from the
--   <a>Data.Int</a> and <a>Data.Word</a> modules.
module Data.Bits

-- | The <a>Bits</a> class defines bitwise operations over integral types.
--   
--   <ul>
--   <li>Bits are numbered from 0 with bit 0 being the least significant
--   bit.</li>
--   </ul>
class Eq a => Bits a

-- | Bitwise "and"
(.&.) :: Bits a => a -> a -> a

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a

-- | Reverse all the bits in the argument
complement :: Bits a => a -> a

-- | <tt><a>shift</a> x i</tt> shifts <tt>x</tt> left by <tt>i</tt> bits if
--   <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise. Right
--   shifts perform sign extension on signed number types; i.e. they fill
--   the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this unified <a>shift</a> or
--   <a>shiftL</a> and <a>shiftR</a>, depending on which is more convenient
--   for the type in question.
shift :: Bits a => a -> Int -> a

-- | <tt><a>rotate</a> x i</tt> rotates <tt>x</tt> left by <tt>i</tt> bits
--   if <tt>i</tt> is positive, or right by <tt>-i</tt> bits otherwise.
--   
--   For unbounded types like <a>Integer</a>, <a>rotate</a> is equivalent
--   to <a>shift</a>.
--   
--   An instance can define either this unified <a>rotate</a> or
--   <a>rotateL</a> and <a>rotateR</a>, depending on which is more
--   convenient for the type in question.
rotate :: Bits a => a -> Int -> a

-- | <a>zeroBits</a> is the value with all bits unset.
--   
--   The following laws ought to hold (for all valid bit indices
--   <tt><i>n</i></tt>):
--   
--   <ul>
--   <li><pre><a>clearBit</a> <a>zeroBits</a> <i>n</i> ==
--   <a>zeroBits</a></pre></li>
--   <li><pre><a>setBit</a> <a>zeroBits</a> <i>n</i> == <a>bit</a>
--   <i>n</i></pre></li>
--   <li><pre><a>testBit</a> <a>zeroBits</a> <i>n</i> == False</pre></li>
--   <li><pre><a>popCount</a> <a>zeroBits</a> == 0</pre></li>
--   </ul>
--   
--   This method uses <tt><a>clearBit</a> (<a>bit</a> 0) 0</tt> as its
--   default implementation (which ought to be equivalent to
--   <a>zeroBits</a> for types which possess a 0th bit).
zeroBits :: Bits a => a

-- | <tt>bit <i>i</i></tt> is a value with the <tt><i>i</i></tt>th bit set
--   and all other bits clear.
--   
--   Can be implemented using <a>bitDefault</a> if <tt>a</tt> is also an
--   instance of <a>Num</a>.
--   
--   See also <a>zeroBits</a>.
bit :: Bits a => Int -> a

-- | <tt>x `setBit` i</tt> is the same as <tt>x .|. bit i</tt>
setBit :: Bits a => a -> Int -> a

-- | <tt>x `clearBit` i</tt> is the same as <tt>x .&amp;. complement (bit
--   i)</tt>
clearBit :: Bits a => a -> Int -> a

-- | <tt>x `complementBit` i</tt> is the same as <tt>x `xor` bit i</tt>
complementBit :: Bits a => a -> Int -> a

-- | <tt>x `testBit` i</tt> is the same as <tt>x .&amp;. bit n /= 0</tt>
--   
--   In other words it returns True if the bit at offset @n is set.
--   
--   Can be implemented using <a>testBitDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
testBit :: Bits a => a -> Int -> Bool

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Returns Nothing for types that do
--   not have a fixed bitsize, like <a>Integer</a>.
bitSizeMaybe :: Bits a => a -> Maybe Int

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. The function <a>bitSize</a> is
--   undefined for types that do not have a fixed bitsize, like
--   <a>Integer</a>.
--   
--   Default implementation based upon <a>bitSizeMaybe</a> provided since
--   4.12.0.0.

-- | <i>Deprecated: Use <a>bitSizeMaybe</a> or <a>finiteBitSize</a>
--   instead</i>
bitSize :: Bits a => a -> Int

-- | Return <a>True</a> if the argument is a signed type. The actual value
--   of the argument is ignored
isSigned :: Bits a => a -> Bool

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative). Some instances may throw an <a>Overflow</a> exception
--   if given a negative input.
--   
--   An instance can define either this and <a>shiftR</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftL :: Bits a => a -> Int -> a

-- | Shift the argument left by the specified number of bits. The result is
--   undefined for negative shift amounts and shift amounts greater or
--   equal to the <a>bitSize</a>.
--   
--   Defaults to <a>shiftL</a> unless defined explicitly by an instance.
unsafeShiftL :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits. The
--   result is undefined for negative shift amounts and shift amounts
--   greater or equal to the <a>bitSize</a>. Some instances may throw an
--   <a>Overflow</a> exception if given a negative input.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   An instance can define either this and <a>shiftL</a> or the unified
--   <a>shift</a>, depending on which is more convenient for the type in
--   question.
shiftR :: Bits a => a -> Int -> a

-- | Shift the first argument right by the specified number of bits, which
--   must be non-negative and smaller than the number of bits in the type.
--   
--   Right shifts perform sign extension on signed number types; i.e. they
--   fill the top bits with 1 if the <tt>x</tt> is negative and with 0
--   otherwise.
--   
--   Defaults to <a>shiftR</a> unless defined explicitly by an instance.
unsafeShiftR :: Bits a => a -> Int -> a

-- | Rotate the argument left by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateR</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateL :: Bits a => a -> Int -> a

-- | Rotate the argument right by the specified number of bits (which must
--   be non-negative).
--   
--   An instance can define either this and <a>rotateL</a> or the unified
--   <a>rotate</a>, depending on which is more convenient for the type in
--   question.
rotateR :: Bits a => a -> Int -> a

-- | Return the number of set bits in the argument. This number is known as
--   the population count or the Hamming weight.
--   
--   Can be implemented using <a>popCountDefault</a> if <tt>a</tt> is also
--   an instance of <a>Num</a>.
popCount :: Bits a => a -> Int
infixl 7 .&.
infixl 5 .|.
infixl 6 `xor`
infixl 8 `shift`
infixl 8 `rotate`
infixl 8 `shiftL`
infixl 8 `shiftR`
infixl 8 `rotateL`
infixl 8 `rotateR`

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | Return the number of bits in the type of the argument. The actual
--   value of the argument is ignored. Moreover, <a>finiteBitSize</a> is
--   total, in contrast to the deprecated <a>bitSize</a> function it
--   replaces.
--   
--   <pre>
--   <a>finiteBitSize</a> = <a>bitSize</a>
--   <a>bitSizeMaybe</a> = <a>Just</a> . <a>finiteBitSize</a>
--   </pre>
finiteBitSize :: FiniteBits b => b -> Int

-- | Count number of zero bits preceding the most significant set bit.
--   
--   <pre>
--   <a>countLeadingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   </pre>
--   
--   <a>countLeadingZeros</a> can be used to compute log base 2 via
--   
--   <pre>
--   logBase2 x = <a>finiteBitSize</a> x - 1 - <a>countLeadingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countLeadingZeros :: FiniteBits b => b -> Int

-- | Count number of zero bits following the least significant set bit.
--   
--   <pre>
--   <a>countTrailingZeros</a> (<a>zeroBits</a> :: a) = finiteBitSize (<a>zeroBits</a> :: a)
--   <a>countTrailingZeros</a> . <a>negate</a> = <a>countTrailingZeros</a>
--   </pre>
--   
--   The related <a>find-first-set operation</a> can be expressed in terms
--   of <a>countTrailingZeros</a> as follows
--   
--   <pre>
--   findFirstSet x = 1 + <a>countTrailingZeros</a> x
--   </pre>
--   
--   Note: The default implementation for this method is intentionally
--   naive. However, the instances provided for the primitive integral
--   types are implemented using CPU specific machine instructions.
countTrailingZeros :: FiniteBits b => b -> Int

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | A more concise version of <tt>complement zeroBits</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; complement (zeroBits :: Word) == (oneBits :: Word)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; complement (oneBits :: Word) == (zeroBits :: Word)
--   True
--   </pre>
--   
--   <h1>Note</h1>
--   
--   The constraint on <a>oneBits</a> is arguably too strong. However, as
--   some types (such as <tt>Natural</tt>) have undefined
--   <a>complement</a>, this is the only safe choice.
oneBits :: FiniteBits a => a

-- | Infix version of <a>xor</a>.
(.^.) :: Bits a => a -> a -> a
infixl 6 .^.

-- | Infix version of <a>shiftR</a>.
(.>>.) :: Bits a => a -> Int -> a
infixl 8 .>>.

-- | Infix version of <a>shiftL</a>.
(.<<.) :: Bits a => a -> Int -> a
infixl 8 .<<.

-- | Infix version of <a>unsafeShiftR</a>.
(!>>.) :: Bits a => a -> Int -> a
infixl 8 !>>.

-- | Infix version of <a>unsafeShiftL</a>.
(!<<.) :: Bits a => a -> Int -> a
infixl 8 !<<.

-- | Monoid under bitwise AND.
--   
--   <pre>
--   &gt;&gt;&gt; getAnd (And 0xab &lt;&gt; And 0x12) :: Word8
--   2
--   </pre>
newtype And a
And :: a -> And a
[getAnd] :: And a -> a

-- | Monoid under bitwise inclusive OR.
--   
--   <pre>
--   &gt;&gt;&gt; getIor (Ior 0xab &lt;&gt; Ior 0x12) :: Word8
--   187
--   </pre>
newtype Ior a
Ior :: a -> Ior a
[getIor] :: Ior a -> a

-- | Monoid under bitwise XOR.
--   
--   <pre>
--   &gt;&gt;&gt; getXor (Xor 0xab &lt;&gt; Xor 0x12) :: Word8
--   185
--   </pre>
newtype Xor a
Xor :: a -> Xor a
[getXor] :: Xor a -> a

-- | Monoid under bitwise 'equality'; defined as <tt>1</tt> if the
--   corresponding bits match, and <tt>0</tt> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; getIff (Iff 0xab &lt;&gt; Iff 0x12) :: Word8
--   70
--   </pre>
newtype Iff a
Iff :: a -> Iff a
[getIff] :: Iff a -> a
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.And a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.And a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.And a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.And a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.And a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.And a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.And a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Ior a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Ior a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Ior a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Ior a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Ior a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Ior a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Ior a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Xor a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Xor a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Xor a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Xor a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Xor a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Xor a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Xor a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Bits.Iff a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bits.Iff a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Iff a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Iff a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Iff a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Iff a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Iff a)
instance GHC.Bits.FiniteBits a => GHC.Base.Semigroup (Data.Bits.Iff a)
instance GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.Iff a)
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Xor a)
instance GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Xor a)
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Ior a)
instance GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Ior a)
instance GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.And a)
instance GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.And a)


-- | The sized integral datatypes, <a>Int8</a>, <a>Int16</a>, <a>Int32</a>,
--   and <a>Int64</a>.
module GHC.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int
I# :: Int# -> Int

-- | 8-bit signed integer type
data {-# CTYPE "HsInt8" #-} Int8
I8# :: Int8# -> Int8

-- | 16-bit signed integer type
data {-# CTYPE "HsInt16" #-} Int16
I16# :: Int16# -> Int16

-- | 32-bit signed integer type
data {-# CTYPE "HsInt32" #-} Int32
I32# :: Int32# -> Int32

-- | 64-bit signed integer type
data {-# CTYPE "HsInt64" #-} Int64
I64# :: Int64# -> Int64
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
shiftRLInt8# :: Int8# -> Int# -> Int8#
shiftRLInt16# :: Int16# -> Int# -> Int16#
shiftRLInt32# :: Int32# -> Int# -> Int32#
eqInt :: Int -> Int -> Bool
neInt :: Int -> Int -> Bool
gtInt :: Int -> Int -> Bool
geInt :: Int -> Int -> Bool
ltInt :: Int -> Int -> Bool
leInt :: Int -> Int -> Bool
eqInt8 :: Int8 -> Int8 -> Bool
neInt8 :: Int8 -> Int8 -> Bool
gtInt8 :: Int8 -> Int8 -> Bool
geInt8 :: Int8 -> Int8 -> Bool
ltInt8 :: Int8 -> Int8 -> Bool
leInt8 :: Int8 -> Int8 -> Bool
eqInt16 :: Int16 -> Int16 -> Bool
neInt16 :: Int16 -> Int16 -> Bool
gtInt16 :: Int16 -> Int16 -> Bool
geInt16 :: Int16 -> Int16 -> Bool
ltInt16 :: Int16 -> Int16 -> Bool
leInt16 :: Int16 -> Int16 -> Bool
eqInt32 :: Int32 -> Int32 -> Bool
neInt32 :: Int32 -> Int32 -> Bool
gtInt32 :: Int32 -> Int32 -> Bool
geInt32 :: Int32 -> Int32 -> Bool
ltInt32 :: Int32 -> Int32 -> Bool
leInt32 :: Int32 -> Int32 -> Bool
eqInt64 :: Int64 -> Int64 -> Bool
neInt64 :: Int64 -> Int64 -> Bool
gtInt64 :: Int64 -> Int64 -> Bool
geInt64 :: Int64 -> Int64 -> Bool
ltInt64 :: Int64 -> Int64 -> Bool
leInt64 :: Int64 -> Int64 -> Bool
instance GHC.Classes.Eq GHC.Int.Int64
instance GHC.Classes.Ord GHC.Int.Int64
instance GHC.Show.Show GHC.Int.Int64
instance GHC.Num.Num GHC.Int.Int64
instance GHC.Enum.Enum GHC.Int.Int64
instance GHC.Real.Integral GHC.Int.Int64
instance GHC.Read.Read GHC.Int.Int64
instance GHC.Bits.Bits GHC.Int.Int64
instance GHC.Bits.FiniteBits GHC.Int.Int64
instance GHC.Real.Real GHC.Int.Int64
instance GHC.Enum.Bounded GHC.Int.Int64
instance GHC.Ix.Ix GHC.Int.Int64
instance GHC.Classes.Eq GHC.Int.Int32
instance GHC.Classes.Ord GHC.Int.Int32
instance GHC.Show.Show GHC.Int.Int32
instance GHC.Num.Num GHC.Int.Int32
instance GHC.Enum.Enum GHC.Int.Int32
instance GHC.Real.Integral GHC.Int.Int32
instance GHC.Read.Read GHC.Int.Int32
instance GHC.Bits.Bits GHC.Int.Int32
instance GHC.Bits.FiniteBits GHC.Int.Int32
instance GHC.Real.Real GHC.Int.Int32
instance GHC.Enum.Bounded GHC.Int.Int32
instance GHC.Ix.Ix GHC.Int.Int32
instance GHC.Classes.Eq GHC.Int.Int16
instance GHC.Classes.Ord GHC.Int.Int16
instance GHC.Show.Show GHC.Int.Int16
instance GHC.Num.Num GHC.Int.Int16
instance GHC.Real.Real GHC.Int.Int16
instance GHC.Enum.Enum GHC.Int.Int16
instance GHC.Real.Integral GHC.Int.Int16
instance GHC.Enum.Bounded GHC.Int.Int16
instance GHC.Ix.Ix GHC.Int.Int16
instance GHC.Read.Read GHC.Int.Int16
instance GHC.Bits.Bits GHC.Int.Int16
instance GHC.Bits.FiniteBits GHC.Int.Int16
instance GHC.Classes.Eq GHC.Int.Int8
instance GHC.Classes.Ord GHC.Int.Int8
instance GHC.Show.Show GHC.Int.Int8
instance GHC.Num.Num GHC.Int.Int8
instance GHC.Real.Real GHC.Int.Int8
instance GHC.Enum.Enum GHC.Int.Int8
instance GHC.Real.Integral GHC.Int.Int8
instance GHC.Enum.Bounded GHC.Int.Int8
instance GHC.Ix.Ix GHC.Int.Int8
instance GHC.Read.Read GHC.Int.Int8
instance GHC.Bits.Bits GHC.Int.Int8
instance GHC.Bits.FiniteBits GHC.Int.Int8


-- | Signed integer types
module Data.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | 8-bit signed integer type
data {-# CTYPE "HsInt8" #-} Int8

-- | 16-bit signed integer type
data {-# CTYPE "HsInt16" #-} Int16

-- | 32-bit signed integer type
data {-# CTYPE "HsInt32" #-} Int32

-- | 64-bit signed integer type
data {-# CTYPE "HsInt64" #-} Int64


-- | Converting values to readable strings: the <a>Show</a> class and
--   associated functions.
module Text.Show

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | Show a list (using square brackets and commas), given a function for
--   showing elements.
showListWith :: (a -> ShowS) -> [a] -> ShowS

module Unsafe.Coerce

-- | Coerce a value from one type to another, bypassing the type-checker.
--   
--   There are several legitimate ways to use <a>unsafeCoerce</a>:
--   
--   <ol>
--   <li>To coerce e.g. <tt>Int</tt> to <tt>HValue</tt>, put it in a list
--   of <tt>HValue</tt>, and then later coerce it back to <tt>Int</tt>
--   before using it.</li>
--   <li>To produce e.g. <tt>(a+b) :~: (b+a)</tt> from <tt>unsafeCoerce
--   Refl</tt>. Here the two sides really are the same type -- so nothing
--   unsafe is happening -- but GHC is not clever enough to see it.</li>
--   <li>In <tt>Data.Typeable</tt> we have</li>
--   </ol>
--   
--   <pre>
--   eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2).
--                TypeRep a -&gt; TypeRep b -&gt; Maybe (a :~~: b)
--   eqTypeRep a b
--     | sameTypeRep a b = Just (unsafeCoerce HRefl)
--     | otherwise       = Nothing
--   
--   </pre>
--   
--   Here again, the <tt>unsafeCoerce HRefl</tt> is safe, because the two
--   types really are the same -- but the proof of that relies on the
--   complex, trusted implementation of <tt>Typeable</tt>.
--   
--   <ol>
--   <li>The "reflection trick", which takes advantage of the fact that in
--   <tt>class C a where { op :: ty }</tt>, we can safely coerce between
--   <tt>C a</tt> and <tt>ty</tt> (which have different kinds!) because
--   it's really just a newtype. Note: there is <i>no guarantee, at all</i>
--   that this behavior will be supported into perpetuity.</li>
--   </ol>
--   
--   For safe zero-cost coercions you can instead use the <a>coerce</a>
--   function from <a>Data.Coerce</a>.
unsafeCoerce :: forall (a :: Type) (b :: Type). a -> b
unsafeCoerceUnlifted :: forall (a :: TYPE ('BoxedRep 'Unlifted)) (b :: TYPE ('BoxedRep 'Unlifted)). a -> b
unsafeCoerceAddr :: forall (a :: TYPE 'AddrRep) (b :: TYPE 'AddrRep). a -> b
unsafeEqualityProof :: forall a b. UnsafeEquality a b

-- | This type is treated magically within GHC. Any pattern match of the
--   form <tt>case unsafeEqualityProof of UnsafeRefl -&gt; body</tt> gets
--   transformed just into <tt>body</tt>. This is ill-typed, but the
--   transformation takes place after type-checking is complete. It is used
--   to implement <a>unsafeCoerce</a>. You probably don't want to use
--   <a>UnsafeRefl</a> in an expression, but you might conceivably want to
--   pattern-match on it. Use <a>unsafeEqualityProof</a> to create one of
--   these.
data UnsafeEquality a b
[UnsafeRefl] :: UnsafeEquality a a

-- | Highly, terribly dangerous coercion from one representation type to
--   another. Misuse of this function can invite the garbage collector to
--   trounce upon your data and then laugh in your face. You don't want
--   this function. Really.
unsafeCoerce# :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE r2). a -> b


-- | Stable pointers.
module GHC.Stable

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   The <tt>StablePtr</tt> 0 is reserved for representing NULL in foreign
--   code.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data {-# CTYPE "HsStablePtr" #-} StablePtr a
StablePtr :: StablePtr# a -> StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <a>newStablePtr</a>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address
--   might not refer to an accessible memory location and any attempt to
--   pass it to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a
instance GHC.Classes.Eq (GHC.Stable.StablePtr a)


-- | Helper functions for <a>Foreign.Storable</a>
module GHC.Storable
readWideCharOffPtr :: Ptr Char -> Int -> IO Char
readIntOffPtr :: Ptr Int -> Int -> IO Int
readWordOffPtr :: Ptr Word -> Int -> IO Word
readPtrOffPtr :: Ptr (Ptr a) -> Int -> IO (Ptr a)
readFunPtrOffPtr :: Ptr (FunPtr a) -> Int -> IO (FunPtr a)
readFloatOffPtr :: Ptr Float -> Int -> IO Float
readDoubleOffPtr :: Ptr Double -> Int -> IO Double
readStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> IO (StablePtr a)
readInt8OffPtr :: Ptr Int8 -> Int -> IO Int8
readInt16OffPtr :: Ptr Int16 -> Int -> IO Int16
readInt32OffPtr :: Ptr Int32 -> Int -> IO Int32
readInt64OffPtr :: Ptr Int64 -> Int -> IO Int64
readWord8OffPtr :: Ptr Word8 -> Int -> IO Word8
readWord16OffPtr :: Ptr Word16 -> Int -> IO Word16
readWord32OffPtr :: Ptr Word32 -> Int -> IO Word32
readWord64OffPtr :: Ptr Word64 -> Int -> IO Word64
writeWideCharOffPtr :: Ptr Char -> Int -> Char -> IO ()
writeIntOffPtr :: Ptr Int -> Int -> Int -> IO ()
writeWordOffPtr :: Ptr Word -> Int -> Word -> IO ()
writePtrOffPtr :: Ptr (Ptr a) -> Int -> Ptr a -> IO ()
writeFunPtrOffPtr :: Ptr (FunPtr a) -> Int -> FunPtr a -> IO ()
writeFloatOffPtr :: Ptr Float -> Int -> Float -> IO ()
writeDoubleOffPtr :: Ptr Double -> Int -> Double -> IO ()
writeStablePtrOffPtr :: Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()
writeInt8OffPtr :: Ptr Int8 -> Int -> Int8 -> IO ()
writeInt16OffPtr :: Ptr Int16 -> Int -> Int16 -> IO ()
writeInt32OffPtr :: Ptr Int32 -> Int -> Int32 -> IO ()
writeInt64OffPtr :: Ptr Int64 -> Int -> Int64 -> IO ()
writeWord8OffPtr :: Ptr Word8 -> Int -> Word8 -> IO ()
writeWord16OffPtr :: Ptr Word16 -> Int -> Word16 -> IO ()
writeWord32OffPtr :: Ptr Word32 -> Int -> Word32 -> IO ()
writeWord64OffPtr :: Ptr Word64 -> Int -> Word64 -> IO ()


-- | The module <a>Foreign.Storable</a> provides most elementary support
--   for marshalling and is part of the language-independent portion of the
--   Foreign Function Interface (FFI), and will normally be imported via
--   the <a>Foreign</a> module.
module Foreign.Storable

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument is not used.
sizeOf :: Storable a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The alignment must be a power of two if this instance is
--   to be used with <tt>alloca</tt> or <tt>allocaArray</tt>. The value of
--   the argument is not used.
alignment :: Storable a => a -> Int

-- | Read a value from a memory area regarded as an array of values of the
--   same kind. The first argument specifies the start address of the array
--   and the second the index into the array (the first element of the
--   array has index <tt>0</tt>). The following equality holds,
--   
--   <pre>
--   peekElemOff addr idx = IOExts.fixIO $ \result -&gt;
--     peek (addr `plusPtr` (idx * sizeOf result))
--   </pre>
--   
--   Note that this is only a specification, not necessarily the concrete
--   implementation of the function.
peekElemOff :: Storable a => Ptr a -> Int -> IO a

-- | Write a value to a memory area regarded as an array of values of the
--   same kind. The following equality holds:
--   
--   <pre>
--   pokeElemOff addr idx x = 
--     poke (addr `plusPtr` (idx * sizeOf x)) x
--   </pre>
pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from a memory location given by a base address and
--   offset. The following equality holds:
--   
--   <pre>
--   peekByteOff addr off = peek (addr `plusPtr` off)
--   </pre>
peekByteOff :: Storable a => Ptr b -> Int -> IO a

-- | Write a value to a memory location given by a base address and offset.
--   The following equality holds:
--   
--   <pre>
--   pokeByteOff addr off x = poke (addr `plusPtr` off) x
--   </pre>
pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()
instance Foreign.Storable.Storable (Foreign.C.ConstPtr.ConstPtr a)
instance Foreign.Storable.Storable ()
instance Foreign.Storable.Storable GHC.Types.Bool
instance Foreign.Storable.Storable GHC.Types.Char
instance Foreign.Storable.Storable GHC.Types.Int
instance Foreign.Storable.Storable GHC.Types.Word
instance Foreign.Storable.Storable (GHC.Ptr.Ptr a)
instance Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
instance Foreign.Storable.Storable (GHC.Stable.StablePtr a)
instance Foreign.Storable.Storable GHC.Types.Float
instance Foreign.Storable.Storable GHC.Types.Double
instance Foreign.Storable.Storable GHC.Word.Word8
instance Foreign.Storable.Storable GHC.Word.Word16
instance Foreign.Storable.Storable GHC.Word.Word32
instance Foreign.Storable.Storable GHC.Word.Word64
instance Foreign.Storable.Storable GHC.Int.Int8
instance Foreign.Storable.Storable GHC.Int.Int16
instance Foreign.Storable.Storable GHC.Int.Int32
instance Foreign.Storable.Storable GHC.Int.Int64
instance (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a)
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint


-- | This module provides typed pointers to foreign data. It is part of the
--   Foreign Function Interface (FFI) and will normally be imported via the
--   <a>Foreign</a> module.
module Foreign.Ptr

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a

-- | The constant <a>nullPtr</a> contains a distinguished value of
--   <a>Ptr</a> that is not associated with a valid memory location.
nullPtr :: Ptr a

-- | The <a>castPtr</a> function casts a pointer from one type to another.
castPtr :: Ptr a -> Ptr b

-- | Advances the given address by the given offset in bytes.
plusPtr :: Ptr a -> Int -> Ptr b

-- | Given an arbitrary address and an alignment constraint,
--   <a>alignPtr</a> yields the next higher address that fulfills the
--   alignment constraint. An alignment constraint <tt>x</tt> is fulfilled
--   by any address divisible by <tt>x</tt>. This operation is idempotent.
alignPtr :: Ptr a -> Int -> Ptr a

-- | Computes the offset required to get from the second to the first
--   argument. We have
--   
--   <pre>
--   p2 == p1 `plusPtr` (p2 `minusPtr` p1)
--   </pre>
minusPtr :: Ptr a -> Ptr b -> Int

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a

-- | The constant <a>nullFunPtr</a> contains a distinguished value of
--   <a>FunPtr</a> that is not associated with a valid memory location.
nullFunPtr :: FunPtr a

-- | Casts a <a>FunPtr</a> to a <a>FunPtr</a> of a different type.
castFunPtr :: FunPtr a -> FunPtr b

-- | Casts a <a>FunPtr</a> to a <a>Ptr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castFunPtrToPtr :: FunPtr a -> Ptr b

-- | Casts a <a>Ptr</a> to a <a>FunPtr</a>.
--   
--   <i>Note:</i> this is valid only on architectures where data and
--   function pointers range over the same set of addresses, and should
--   only be used for bindings to external libraries whose interface
--   already relies on this assumption.
castPtrToFunPtr :: Ptr a -> FunPtr b

-- | Release the storage associated with the given <a>FunPtr</a>, which
--   must have been obtained from a wrapper stub. This should be called
--   whenever the return value from a foreign import wrapper function is no
--   longer required; otherwise, the storage it uses will leak.
freeHaskellFunPtr :: FunPtr a -> IO ()

-- | A signed integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>intptr_t</tt>, and can be marshalled to and from that type safely.
newtype {-# CTYPE "intptr_t" #-} IntPtr
IntPtr :: Int -> IntPtr

-- | casts a <tt>Ptr</tt> to an <tt>IntPtr</tt>
ptrToIntPtr :: Ptr a -> IntPtr

-- | casts an <tt>IntPtr</tt> to a <tt>Ptr</tt>
intPtrToPtr :: IntPtr -> Ptr a

-- | An unsigned integral type that can be losslessly converted to and from
--   <tt>Ptr</tt>. This type is also compatible with the C99 type
--   <tt>uintptr_t</tt>, and can be marshalled to and from that type
--   safely.
newtype {-# CTYPE "uintptr_t" #-} WordPtr
WordPtr :: Word -> WordPtr

-- | casts a <tt>Ptr</tt> to a <tt>WordPtr</tt>
ptrToWordPtr :: Ptr a -> WordPtr

-- | casts a <tt>WordPtr</tt> to a <tt>Ptr</tt>
wordPtrToPtr :: WordPtr -> Ptr a
instance GHC.Ix.Ix Foreign.Ptr.WordPtr
instance GHC.Bits.FiniteBits Foreign.Ptr.WordPtr
instance GHC.Bits.Bits Foreign.Ptr.WordPtr
instance GHC.Real.Integral Foreign.Ptr.WordPtr
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr
instance GHC.Real.Real Foreign.Ptr.WordPtr
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr
instance GHC.Enum.Enum Foreign.Ptr.WordPtr
instance GHC.Num.Num Foreign.Ptr.WordPtr
instance GHC.Classes.Ord Foreign.Ptr.WordPtr
instance GHC.Classes.Eq Foreign.Ptr.WordPtr
instance GHC.Show.Show Foreign.Ptr.WordPtr
instance GHC.Read.Read Foreign.Ptr.WordPtr
instance GHC.Ix.Ix Foreign.Ptr.IntPtr
instance GHC.Bits.FiniteBits Foreign.Ptr.IntPtr
instance GHC.Bits.Bits Foreign.Ptr.IntPtr
instance GHC.Real.Integral Foreign.Ptr.IntPtr
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr
instance GHC.Real.Real Foreign.Ptr.IntPtr
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr
instance GHC.Enum.Enum Foreign.Ptr.IntPtr
instance GHC.Num.Num Foreign.Ptr.IntPtr
instance GHC.Classes.Ord Foreign.Ptr.IntPtr
instance GHC.Classes.Eq Foreign.Ptr.IntPtr
instance GHC.Show.Show Foreign.Ptr.IntPtr
instance GHC.Read.Read Foreign.Ptr.IntPtr


-- | Mapping of C types to corresponding Haskell types.
module Foreign.C.Types

-- | Haskell type representing the C <tt>char</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "char" #-} CChar
CChar :: Int8 -> CChar

-- | Haskell type representing the C <tt>signed char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "signed char" #-} CSChar
CSChar :: Int8 -> CSChar

-- | Haskell type representing the C <tt>unsigned char</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "unsigned char" #-} CUChar
CUChar :: Word8 -> CUChar

-- | Haskell type representing the C <tt>short</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "short" #-} CShort
CShort :: Int16 -> CShort

-- | Haskell type representing the C <tt>unsigned short</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "unsigned short" #-} CUShort
CUShort :: Word16 -> CUShort

-- | Haskell type representing the C <tt>int</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "int" #-} CInt
CInt :: Int32 -> CInt

-- | Haskell type representing the C <tt>unsigned int</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "unsigned int" #-} CUInt
CUInt :: Word32 -> CUInt

-- | Haskell type representing the C <tt>long</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "long" #-} CLong
CLong :: Int64 -> CLong

-- | Haskell type representing the C <tt>unsigned long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "unsigned long" #-} CULong
CULong :: Word64 -> CULong

-- | Haskell type representing the C <tt>ptrdiff_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "ptrdiff_t" #-} CPtrdiff
CPtrdiff :: Int64 -> CPtrdiff

-- | Haskell type representing the C <tt>size_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "size_t" #-} CSize
CSize :: Word64 -> CSize

-- | Haskell type representing the C <tt>wchar_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "wchar_t" #-} CWchar
CWchar :: Int32 -> CWchar

-- | Haskell type representing the C <tt>sig_atomic_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i> See Note [Lack of signals on wasm32-wasi].
newtype {-# CTYPE "sig_atomic_t" #-} CSigAtomic
CSigAtomic :: Int32 -> CSigAtomic

-- | Haskell type representing the C <tt>long long</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "long long" #-} CLLong
CLLong :: Int64 -> CLLong

-- | Haskell type representing the C <tt>unsigned long long</tt> type.
--   <i>(The concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "unsigned long long" #-} CULLong
CULLong :: Word64 -> CULLong

-- | Haskell type representing the C <tt>bool</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "bool" #-} CBool
CBool :: Word8 -> CBool
newtype {-# CTYPE "intptr_t" #-} CIntPtr
CIntPtr :: Int64 -> CIntPtr
newtype {-# CTYPE "uintptr_t" #-} CUIntPtr
CUIntPtr :: Word64 -> CUIntPtr
newtype {-# CTYPE "intmax_t" #-} CIntMax
CIntMax :: Int64 -> CIntMax
newtype {-# CTYPE "uintmax_t" #-} CUIntMax
CUIntMax :: Word64 -> CUIntMax

-- | Haskell type representing the C <tt>clock_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "clock_t" #-} CClock
CClock :: Int64 -> CClock

-- | Haskell type representing the C <tt>time_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "time_t" #-} CTime
CTime :: Int64 -> CTime

-- | Haskell type representing the C <tt>useconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "useconds_t" #-} CUSeconds
CUSeconds :: Word32 -> CUSeconds

-- | Haskell type representing the C <tt>suseconds_t</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
newtype {-# CTYPE "suseconds_t" #-} CSUSeconds
CSUSeconds :: Int64 -> CSUSeconds

-- | Haskell type representing the C <tt>float</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "float" #-} CFloat
CFloat :: Float -> CFloat

-- | Haskell type representing the C <tt>double</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
newtype {-# CTYPE "double" #-} CDouble
CDouble :: Double -> CDouble

-- | Haskell type representing the C <tt>FILE</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
data CFile

-- | Haskell type representing the C <tt>fpos_t</tt> type. <i>(The concrete
--   types of <a>Foreign.C.Types#platform</a> are platform-specific.)</i>
data CFpos

-- | Haskell type representing the C <tt>jmp_buf</tt> type. <i>(The
--   concrete types of <a>Foreign.C.Types#platform</a> are
--   platform-specific.)</i>
data CJmpBuf
instance GHC.Ix.Ix Foreign.C.Types.CChar
instance GHC.Bits.FiniteBits Foreign.C.Types.CChar
instance GHC.Bits.Bits Foreign.C.Types.CChar
instance GHC.Real.Integral Foreign.C.Types.CChar
instance GHC.Enum.Bounded Foreign.C.Types.CChar
instance GHC.Real.Real Foreign.C.Types.CChar
instance Foreign.Storable.Storable Foreign.C.Types.CChar
instance GHC.Enum.Enum Foreign.C.Types.CChar
instance GHC.Num.Num Foreign.C.Types.CChar
instance GHC.Classes.Ord Foreign.C.Types.CChar
instance GHC.Classes.Eq Foreign.C.Types.CChar
instance GHC.Show.Show Foreign.C.Types.CChar
instance GHC.Read.Read Foreign.C.Types.CChar
instance GHC.Ix.Ix Foreign.C.Types.CSChar
instance GHC.Bits.FiniteBits Foreign.C.Types.CSChar
instance GHC.Bits.Bits Foreign.C.Types.CSChar
instance GHC.Real.Integral Foreign.C.Types.CSChar
instance GHC.Enum.Bounded Foreign.C.Types.CSChar
instance GHC.Real.Real Foreign.C.Types.CSChar
instance Foreign.Storable.Storable Foreign.C.Types.CSChar
instance GHC.Enum.Enum Foreign.C.Types.CSChar
instance GHC.Num.Num Foreign.C.Types.CSChar
instance GHC.Classes.Ord Foreign.C.Types.CSChar
instance GHC.Classes.Eq Foreign.C.Types.CSChar
instance GHC.Show.Show Foreign.C.Types.CSChar
instance GHC.Read.Read Foreign.C.Types.CSChar
instance GHC.Ix.Ix Foreign.C.Types.CUChar
instance GHC.Bits.FiniteBits Foreign.C.Types.CUChar
instance GHC.Bits.Bits Foreign.C.Types.CUChar
instance GHC.Real.Integral Foreign.C.Types.CUChar
instance GHC.Enum.Bounded Foreign.C.Types.CUChar
instance GHC.Real.Real Foreign.C.Types.CUChar
instance Foreign.Storable.Storable Foreign.C.Types.CUChar
instance GHC.Enum.Enum Foreign.C.Types.CUChar
instance GHC.Num.Num Foreign.C.Types.CUChar
instance GHC.Classes.Ord Foreign.C.Types.CUChar
instance GHC.Classes.Eq Foreign.C.Types.CUChar
instance GHC.Show.Show Foreign.C.Types.CUChar
instance GHC.Read.Read Foreign.C.Types.CUChar
instance GHC.Ix.Ix Foreign.C.Types.CShort
instance GHC.Bits.FiniteBits Foreign.C.Types.CShort
instance GHC.Bits.Bits Foreign.C.Types.CShort
instance GHC.Real.Integral Foreign.C.Types.CShort
instance GHC.Enum.Bounded Foreign.C.Types.CShort
instance GHC.Real.Real Foreign.C.Types.CShort
instance Foreign.Storable.Storable Foreign.C.Types.CShort
instance GHC.Enum.Enum Foreign.C.Types.CShort
instance GHC.Num.Num Foreign.C.Types.CShort
instance GHC.Classes.Ord Foreign.C.Types.CShort
instance GHC.Classes.Eq Foreign.C.Types.CShort
instance GHC.Show.Show Foreign.C.Types.CShort
instance GHC.Read.Read Foreign.C.Types.CShort
instance GHC.Ix.Ix Foreign.C.Types.CUShort
instance GHC.Bits.FiniteBits Foreign.C.Types.CUShort
instance GHC.Bits.Bits Foreign.C.Types.CUShort
instance GHC.Real.Integral Foreign.C.Types.CUShort
instance GHC.Enum.Bounded Foreign.C.Types.CUShort
instance GHC.Real.Real Foreign.C.Types.CUShort
instance Foreign.Storable.Storable Foreign.C.Types.CUShort
instance GHC.Enum.Enum Foreign.C.Types.CUShort
instance GHC.Num.Num Foreign.C.Types.CUShort
instance GHC.Classes.Ord Foreign.C.Types.CUShort
instance GHC.Classes.Eq Foreign.C.Types.CUShort
instance GHC.Show.Show Foreign.C.Types.CUShort
instance GHC.Read.Read Foreign.C.Types.CUShort
instance GHC.Ix.Ix Foreign.C.Types.CInt
instance GHC.Bits.FiniteBits Foreign.C.Types.CInt
instance GHC.Bits.Bits Foreign.C.Types.CInt
instance GHC.Real.Integral Foreign.C.Types.CInt
instance GHC.Enum.Bounded Foreign.C.Types.CInt
instance GHC.Real.Real Foreign.C.Types.CInt
instance Foreign.Storable.Storable Foreign.C.Types.CInt
instance GHC.Enum.Enum Foreign.C.Types.CInt
instance GHC.Num.Num Foreign.C.Types.CInt
instance GHC.Classes.Ord Foreign.C.Types.CInt
instance GHC.Classes.Eq Foreign.C.Types.CInt
instance GHC.Show.Show Foreign.C.Types.CInt
instance GHC.Read.Read Foreign.C.Types.CInt
instance GHC.Ix.Ix Foreign.C.Types.CUInt
instance GHC.Bits.FiniteBits Foreign.C.Types.CUInt
instance GHC.Bits.Bits Foreign.C.Types.CUInt
instance GHC.Real.Integral Foreign.C.Types.CUInt
instance GHC.Enum.Bounded Foreign.C.Types.CUInt
instance GHC.Real.Real Foreign.C.Types.CUInt
instance Foreign.Storable.Storable Foreign.C.Types.CUInt
instance GHC.Enum.Enum Foreign.C.Types.CUInt
instance GHC.Num.Num Foreign.C.Types.CUInt
instance GHC.Classes.Ord Foreign.C.Types.CUInt
instance GHC.Classes.Eq Foreign.C.Types.CUInt
instance GHC.Show.Show Foreign.C.Types.CUInt
instance GHC.Read.Read Foreign.C.Types.CUInt
instance GHC.Ix.Ix Foreign.C.Types.CLong
instance GHC.Bits.FiniteBits Foreign.C.Types.CLong
instance GHC.Bits.Bits Foreign.C.Types.CLong
instance GHC.Real.Integral Foreign.C.Types.CLong
instance GHC.Enum.Bounded Foreign.C.Types.CLong
instance GHC.Real.Real Foreign.C.Types.CLong
instance Foreign.Storable.Storable Foreign.C.Types.CLong
instance GHC.Enum.Enum Foreign.C.Types.CLong
instance GHC.Num.Num Foreign.C.Types.CLong
instance GHC.Classes.Ord Foreign.C.Types.CLong
instance GHC.Classes.Eq Foreign.C.Types.CLong
instance GHC.Show.Show Foreign.C.Types.CLong
instance GHC.Read.Read Foreign.C.Types.CLong
instance GHC.Ix.Ix Foreign.C.Types.CULong
instance GHC.Bits.FiniteBits Foreign.C.Types.CULong
instance GHC.Bits.Bits Foreign.C.Types.CULong
instance GHC.Real.Integral Foreign.C.Types.CULong
instance GHC.Enum.Bounded Foreign.C.Types.CULong
instance GHC.Real.Real Foreign.C.Types.CULong
instance Foreign.Storable.Storable Foreign.C.Types.CULong
instance GHC.Enum.Enum Foreign.C.Types.CULong
instance GHC.Num.Num Foreign.C.Types.CULong
instance GHC.Classes.Ord Foreign.C.Types.CULong
instance GHC.Classes.Eq Foreign.C.Types.CULong
instance GHC.Show.Show Foreign.C.Types.CULong
instance GHC.Read.Read Foreign.C.Types.CULong
instance GHC.Ix.Ix Foreign.C.Types.CLLong
instance GHC.Bits.FiniteBits Foreign.C.Types.CLLong
instance GHC.Bits.Bits Foreign.C.Types.CLLong
instance GHC.Real.Integral Foreign.C.Types.CLLong
instance GHC.Enum.Bounded Foreign.C.Types.CLLong
instance GHC.Real.Real Foreign.C.Types.CLLong
instance Foreign.Storable.Storable Foreign.C.Types.CLLong
instance GHC.Enum.Enum Foreign.C.Types.CLLong
instance GHC.Num.Num Foreign.C.Types.CLLong
instance GHC.Classes.Ord Foreign.C.Types.CLLong
instance GHC.Classes.Eq Foreign.C.Types.CLLong
instance GHC.Show.Show Foreign.C.Types.CLLong
instance GHC.Read.Read Foreign.C.Types.CLLong
instance GHC.Ix.Ix Foreign.C.Types.CULLong
instance GHC.Bits.FiniteBits Foreign.C.Types.CULLong
instance GHC.Bits.Bits Foreign.C.Types.CULLong
instance GHC.Real.Integral Foreign.C.Types.CULLong
instance GHC.Enum.Bounded Foreign.C.Types.CULLong
instance GHC.Real.Real Foreign.C.Types.CULLong
instance Foreign.Storable.Storable Foreign.C.Types.CULLong
instance GHC.Enum.Enum Foreign.C.Types.CULLong
instance GHC.Num.Num Foreign.C.Types.CULLong
instance GHC.Classes.Ord Foreign.C.Types.CULLong
instance GHC.Classes.Eq Foreign.C.Types.CULLong
instance GHC.Show.Show Foreign.C.Types.CULLong
instance GHC.Read.Read Foreign.C.Types.CULLong
instance GHC.Ix.Ix Foreign.C.Types.CBool
instance GHC.Bits.FiniteBits Foreign.C.Types.CBool
instance GHC.Bits.Bits Foreign.C.Types.CBool
instance GHC.Real.Integral Foreign.C.Types.CBool
instance GHC.Enum.Bounded Foreign.C.Types.CBool
instance GHC.Real.Real Foreign.C.Types.CBool
instance Foreign.Storable.Storable Foreign.C.Types.CBool
instance GHC.Enum.Enum Foreign.C.Types.CBool
instance GHC.Num.Num Foreign.C.Types.CBool
instance GHC.Classes.Ord Foreign.C.Types.CBool
instance GHC.Classes.Eq Foreign.C.Types.CBool
instance GHC.Show.Show Foreign.C.Types.CBool
instance GHC.Read.Read Foreign.C.Types.CBool
instance GHC.Float.RealFloat Foreign.C.Types.CFloat
instance GHC.Real.RealFrac Foreign.C.Types.CFloat
instance GHC.Float.Floating Foreign.C.Types.CFloat
instance GHC.Real.Fractional Foreign.C.Types.CFloat
instance GHC.Real.Real Foreign.C.Types.CFloat
instance Foreign.Storable.Storable Foreign.C.Types.CFloat
instance GHC.Enum.Enum Foreign.C.Types.CFloat
instance GHC.Num.Num Foreign.C.Types.CFloat
instance GHC.Classes.Ord Foreign.C.Types.CFloat
instance GHC.Classes.Eq Foreign.C.Types.CFloat
instance GHC.Show.Show Foreign.C.Types.CFloat
instance GHC.Read.Read Foreign.C.Types.CFloat
instance GHC.Float.RealFloat Foreign.C.Types.CDouble
instance GHC.Real.RealFrac Foreign.C.Types.CDouble
instance GHC.Float.Floating Foreign.C.Types.CDouble
instance GHC.Real.Fractional Foreign.C.Types.CDouble
instance GHC.Real.Real Foreign.C.Types.CDouble
instance Foreign.Storable.Storable Foreign.C.Types.CDouble
instance GHC.Enum.Enum Foreign.C.Types.CDouble
instance GHC.Num.Num Foreign.C.Types.CDouble
instance GHC.Classes.Ord Foreign.C.Types.CDouble
instance GHC.Classes.Eq Foreign.C.Types.CDouble
instance GHC.Show.Show Foreign.C.Types.CDouble
instance GHC.Read.Read Foreign.C.Types.CDouble
instance GHC.Ix.Ix Foreign.C.Types.CPtrdiff
instance GHC.Bits.FiniteBits Foreign.C.Types.CPtrdiff
instance GHC.Bits.Bits Foreign.C.Types.CPtrdiff
instance GHC.Real.Integral Foreign.C.Types.CPtrdiff
instance GHC.Enum.Bounded Foreign.C.Types.CPtrdiff
instance GHC.Real.Real Foreign.C.Types.CPtrdiff
instance Foreign.Storable.Storable Foreign.C.Types.CPtrdiff
instance GHC.Enum.Enum Foreign.C.Types.CPtrdiff
instance GHC.Num.Num Foreign.C.Types.CPtrdiff
instance GHC.Classes.Ord Foreign.C.Types.CPtrdiff
instance GHC.Classes.Eq Foreign.C.Types.CPtrdiff
instance GHC.Show.Show Foreign.C.Types.CPtrdiff
instance GHC.Read.Read Foreign.C.Types.CPtrdiff
instance GHC.Ix.Ix Foreign.C.Types.CSize
instance GHC.Bits.FiniteBits Foreign.C.Types.CSize
instance GHC.Bits.Bits Foreign.C.Types.CSize
instance GHC.Real.Integral Foreign.C.Types.CSize
instance GHC.Enum.Bounded Foreign.C.Types.CSize
instance GHC.Real.Real Foreign.C.Types.CSize
instance Foreign.Storable.Storable Foreign.C.Types.CSize
instance GHC.Enum.Enum Foreign.C.Types.CSize
instance GHC.Num.Num Foreign.C.Types.CSize
instance GHC.Classes.Ord Foreign.C.Types.CSize
instance GHC.Classes.Eq Foreign.C.Types.CSize
instance GHC.Show.Show Foreign.C.Types.CSize
instance GHC.Read.Read Foreign.C.Types.CSize
instance GHC.Ix.Ix Foreign.C.Types.CWchar
instance GHC.Bits.FiniteBits Foreign.C.Types.CWchar
instance GHC.Bits.Bits Foreign.C.Types.CWchar
instance GHC.Real.Integral Foreign.C.Types.CWchar
instance GHC.Enum.Bounded Foreign.C.Types.CWchar
instance GHC.Real.Real Foreign.C.Types.CWchar
instance Foreign.Storable.Storable Foreign.C.Types.CWchar
instance GHC.Enum.Enum Foreign.C.Types.CWchar
instance GHC.Num.Num Foreign.C.Types.CWchar
instance GHC.Classes.Ord Foreign.C.Types.CWchar
instance GHC.Classes.Eq Foreign.C.Types.CWchar
instance GHC.Show.Show Foreign.C.Types.CWchar
instance GHC.Read.Read Foreign.C.Types.CWchar
instance GHC.Ix.Ix Foreign.C.Types.CSigAtomic
instance GHC.Bits.FiniteBits Foreign.C.Types.CSigAtomic
instance GHC.Bits.Bits Foreign.C.Types.CSigAtomic
instance GHC.Real.Integral Foreign.C.Types.CSigAtomic
instance GHC.Enum.Bounded Foreign.C.Types.CSigAtomic
instance GHC.Real.Real Foreign.C.Types.CSigAtomic
instance Foreign.Storable.Storable Foreign.C.Types.CSigAtomic
instance GHC.Enum.Enum Foreign.C.Types.CSigAtomic
instance GHC.Num.Num Foreign.C.Types.CSigAtomic
instance GHC.Classes.Ord Foreign.C.Types.CSigAtomic
instance GHC.Classes.Eq Foreign.C.Types.CSigAtomic
instance GHC.Show.Show Foreign.C.Types.CSigAtomic
instance GHC.Read.Read Foreign.C.Types.CSigAtomic
instance GHC.Real.Real Foreign.C.Types.CClock
instance Foreign.Storable.Storable Foreign.C.Types.CClock
instance GHC.Enum.Enum Foreign.C.Types.CClock
instance GHC.Num.Num Foreign.C.Types.CClock
instance GHC.Classes.Ord Foreign.C.Types.CClock
instance GHC.Classes.Eq Foreign.C.Types.CClock
instance GHC.Show.Show Foreign.C.Types.CClock
instance GHC.Read.Read Foreign.C.Types.CClock
instance GHC.Real.Real Foreign.C.Types.CTime
instance Foreign.Storable.Storable Foreign.C.Types.CTime
instance GHC.Enum.Enum Foreign.C.Types.CTime
instance GHC.Num.Num Foreign.C.Types.CTime
instance GHC.Classes.Ord Foreign.C.Types.CTime
instance GHC.Classes.Eq Foreign.C.Types.CTime
instance GHC.Show.Show Foreign.C.Types.CTime
instance GHC.Read.Read Foreign.C.Types.CTime
instance GHC.Real.Real Foreign.C.Types.CUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CUSeconds
instance GHC.Num.Num Foreign.C.Types.CUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CUSeconds
instance GHC.Show.Show Foreign.C.Types.CUSeconds
instance GHC.Read.Read Foreign.C.Types.CUSeconds
instance GHC.Real.Real Foreign.C.Types.CSUSeconds
instance Foreign.Storable.Storable Foreign.C.Types.CSUSeconds
instance GHC.Enum.Enum Foreign.C.Types.CSUSeconds
instance GHC.Num.Num Foreign.C.Types.CSUSeconds
instance GHC.Classes.Ord Foreign.C.Types.CSUSeconds
instance GHC.Classes.Eq Foreign.C.Types.CSUSeconds
instance GHC.Show.Show Foreign.C.Types.CSUSeconds
instance GHC.Read.Read Foreign.C.Types.CSUSeconds
instance GHC.Ix.Ix Foreign.C.Types.CIntPtr
instance GHC.Bits.FiniteBits Foreign.C.Types.CIntPtr
instance GHC.Bits.Bits Foreign.C.Types.CIntPtr
instance GHC.Real.Integral Foreign.C.Types.CIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CIntPtr
instance GHC.Real.Real Foreign.C.Types.CIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CIntPtr
instance GHC.Num.Num Foreign.C.Types.CIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CIntPtr
instance GHC.Show.Show Foreign.C.Types.CIntPtr
instance GHC.Read.Read Foreign.C.Types.CIntPtr
instance GHC.Ix.Ix Foreign.C.Types.CUIntPtr
instance GHC.Bits.FiniteBits Foreign.C.Types.CUIntPtr
instance GHC.Bits.Bits Foreign.C.Types.CUIntPtr
instance GHC.Real.Integral Foreign.C.Types.CUIntPtr
instance GHC.Enum.Bounded Foreign.C.Types.CUIntPtr
instance GHC.Real.Real Foreign.C.Types.CUIntPtr
instance Foreign.Storable.Storable Foreign.C.Types.CUIntPtr
instance GHC.Enum.Enum Foreign.C.Types.CUIntPtr
instance GHC.Num.Num Foreign.C.Types.CUIntPtr
instance GHC.Classes.Ord Foreign.C.Types.CUIntPtr
instance GHC.Classes.Eq Foreign.C.Types.CUIntPtr
instance GHC.Show.Show Foreign.C.Types.CUIntPtr
instance GHC.Read.Read Foreign.C.Types.CUIntPtr
instance GHC.Ix.Ix Foreign.C.Types.CIntMax
instance GHC.Bits.FiniteBits Foreign.C.Types.CIntMax
instance GHC.Bits.Bits Foreign.C.Types.CIntMax
instance GHC.Real.Integral Foreign.C.Types.CIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CIntMax
instance GHC.Real.Real Foreign.C.Types.CIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CIntMax
instance GHC.Enum.Enum Foreign.C.Types.CIntMax
instance GHC.Num.Num Foreign.C.Types.CIntMax
instance GHC.Classes.Ord Foreign.C.Types.CIntMax
instance GHC.Classes.Eq Foreign.C.Types.CIntMax
instance GHC.Show.Show Foreign.C.Types.CIntMax
instance GHC.Read.Read Foreign.C.Types.CIntMax
instance GHC.Ix.Ix Foreign.C.Types.CUIntMax
instance GHC.Bits.FiniteBits Foreign.C.Types.CUIntMax
instance GHC.Bits.Bits Foreign.C.Types.CUIntMax
instance GHC.Real.Integral Foreign.C.Types.CUIntMax
instance GHC.Enum.Bounded Foreign.C.Types.CUIntMax
instance GHC.Real.Real Foreign.C.Types.CUIntMax
instance Foreign.Storable.Storable Foreign.C.Types.CUIntMax
instance GHC.Enum.Enum Foreign.C.Types.CUIntMax
instance GHC.Num.Num Foreign.C.Types.CUIntMax
instance GHC.Classes.Ord Foreign.C.Types.CUIntMax
instance GHC.Classes.Eq Foreign.C.Types.CUIntMax
instance GHC.Show.Show Foreign.C.Types.CUIntMax
instance GHC.Read.Read Foreign.C.Types.CUIntMax


-- | Orderings
module Data.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>).
--   
--   If <tt>a</tt> has an <tt><a>Ord</a></tt> instance associated with it
--   then comparing two values thus wrapped will give you the opposite of
--   their normal sort order. This is particularly useful when sorting in
--   generalised list comprehensions, as in: <tt>then sortWith by
--   <a>Down</a> x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; compare True False
--   GT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare (Down True) (Down False)
--   LT
--   </pre>
--   
--   If <tt>a</tt> has a <tt><a>Bounded</a></tt> instance then the wrapped
--   instance also respects the reversed ordering by exchanging the values
--   of <tt><a>minBound</a></tt> and <tt><a>maxBound</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Int
--   -9223372036854775808
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Down Int
--   Down 9223372036854775807
--   </pre>
--   
--   All other instances of <tt><a>Down</a> a</tt> behave as they do for
--   <tt>a</tt>.
newtype Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | <pre>
--   clamp (low, high) a = min high (max a low)
--   </pre>
--   
--   Function for ensuring the value <tt>a</tt> is within the inclusive
--   bounds given by <tt>low</tt> and <tt>high</tt>. If it is, <tt>a</tt>
--   is returned unchanged. The result is otherwise <tt>low</tt> if <tt>a
--   &lt;= low</tt>, or <tt>high</tt> if <tt>high &lt;= a</tt>.
--   
--   When clamp is used at Double and Float, it has NaN propagating
--   semantics in its second argument. That is, <tt>clamp (l,h) NaN =
--   NaN</tt>, but <tt>clamp (NaN, NaN) x = x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; clamp (0, 10) 2
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; clamp ('a', 'm') 'x'
--   'm'
--   </pre>
clamp :: Ord a => (a, a) -> a -> a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Ord.Down a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Ord.Down a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Ord.Down a)
instance GHC.Real.Real a => GHC.Real.Real (Data.Ord.Down a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Data.Ord.Down a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Ord.Down a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Ord.Down a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Ord.Down a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Ord.Down a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Ord.Down a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Ord.Down a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Ord.Down a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Ord.Down a)
instance (GHC.Enum.Enum a, GHC.Enum.Bounded a, GHC.Classes.Eq a) => GHC.Enum.Enum (Data.Ord.Down a)
instance GHC.Base.Functor Data.Ord.Down
instance GHC.Base.Applicative Data.Ord.Down
instance GHC.Base.Monad Data.Ord.Down


-- | Basic operations on type-level Orderings.
module Data.Type.Ord

-- | <a>Compare</a> branches on the kind of its arguments to either compare
--   by <a>Symbol</a> or <tt>Nat</tt>.
type family Compare (a :: k) (b :: k) :: Ordering

-- | Ordering data type for type literals that provides proof of their
--   ordering.
data OrderingI a b
[LTI] :: Compare a b ~ 'LT => OrderingI a b
[EQI] :: Compare a a ~ 'EQ => OrderingI a a
[GTI] :: Compare a b ~ 'GT => OrderingI a b

-- | Comparison (&lt;=) of comparable types, as a constraint.
type x <= y = Assert (x <=? y) (LeErrMsg x y)
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type m <=? n = OrdCond (Compare m n) 'True 'True 'False
infix 4 <=?

-- | Comparison (&gt;=) of comparable types, as a constraint.
type x >= y = Assert (x >=? y) (GeErrMsg x y)
infix 4 >=

-- | Comparison (&gt;=) of comparable types, as a function.
type m >=? n = OrdCond (Compare m n) 'False 'True 'True
infix 4 >=?

-- | Comparison (&gt;) of comparable types, as a constraint.
type x > y = Assert (x >? y) (GtErrMsg x y)
infix 4 >

-- | Comparison (&gt;) of comparable types, as a function.
type m >? n = OrdCond (Compare m n) 'False 'False 'True
infix 4 >?

-- | Comparison (&lt;) of comparable types, as a constraint.
type x < y = Assert (x <? y) (LtErrMsg x y)
infix 4 <

-- | Comparison (&lt;) of comparable types, as a function.
type m <? n = OrdCond (Compare m n) 'True 'False 'False
infix 4 <?

-- | Maximum between two comparable types.
type Max m n = OrdCond (Compare m n) n n m

-- | Minimum between two comparable types.
type Min m n = OrdCond (Compare m n) m m n

-- | A case statement on <a>Ordering</a>.
--   
--   <tt>OrdCond c l e g</tt> is <tt>l</tt> when <tt>c ~ LT</tt>,
--   <tt>e</tt> when <tt>c ~ EQ</tt>, and <tt>g</tt> when <tt>c ~ GT</tt>.
type family OrdCond o lt eq gt
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Ord.OrderingI a b)
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Ord.OrderingI a b)


-- | This module is an internal GHC module. It declares the constants used
--   in the implementation of type-level natural numbers. The programmer
--   interface for working with type-level naturals should be defined in a
--   separate library.
module GHC.TypeNats

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | A type synonym for <a>Natural</a>.
--   
--   Prevously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
natSing :: KnownNat n => SNat n

natVal :: forall n proxy. KnownNat n => proxy n -> Natural

natVal' :: forall n. KnownNat n => Proxy# n -> Natural

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Natural -> SomeNat

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: forall a b proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | A value-level witness for a type-level natural number. This is
--   commonly referred to as a <i>singleton</i> type, as for each
--   <tt>n</tt>, there is a single value that inhabits the type
--   <tt><a>SNat</a> n</tt> (aside from bottom).
--   
--   The definition of <a>SNat</a> is intentionally left abstract. To
--   obtain an <a>SNat</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>natSing</a> method of <a>KnownNat</a>.</li>
--   <li>The <tt>SNat</tt> pattern synonym.</li>
--   <li>The <a>withSomeSNat</a> function, which creates an <a>SNat</a>
--   from a <a>Natural</a> number.</li>
--   </ol>
data SNat (n :: Nat)

-- | A explicitly bidirectional pattern synonym relating an <a>SNat</a> to
--   a <a>KnownNat</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SNat</a> n</tt>
--   value from an implicit <tt><a>KnownNat</a> n</tt> constraint:
--   
--   <pre>
--   SNat @n :: <a>KnownNat</a> n =&gt; <a>SNat</a> n
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SNat</a> n</tt>
--   value bringing an implicit <tt><a>KnownNat</a> n</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SNat</a> n -&gt; ..
--   f SNat = {- SNat n in scope -}
--   </pre>
pattern SNat :: forall n. () => KnownNat n => SNat n

-- | Return the <a>Natural</a> number corresponding to <tt>n</tt> in an
--   <tt><a>SNat</a> n</tt> value.
fromSNat :: SNat n -> Natural

-- | Convert a <a>Natural</a> number into an <tt><a>SNat</a> n</tt> value,
--   where <tt>n</tt> is a fresh type-level natural number.
withSomeSNat :: forall rep (r :: TYPE rep). Natural -> (forall n. SNat n -> r) -> r

-- | Convert an explicit <tt><a>SNat</a> n</tt> value into an implicit
--   <tt><a>KnownNat</a> n</tt> constraint.
withKnownNat :: forall n rep (r :: TYPE rep). SNat n -> (KnownNat n => r) -> r

-- | Comparison (&lt;=) of comparable types, as a constraint.
type x <= y = Assert (x <=? y) (LeErrMsg x y)
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type m <=? n = OrdCond (Compare m n) 'True 'True 'False
infix 4 <=?

-- | Addition of type-level naturals.
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +

-- | Multiplication of type-level naturals.
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -

-- | Comparison of type-level naturals, as a function.
type family CmpNat (m :: Natural) (n :: Natural) :: Ordering

-- | Like <a>sameNat</a>, but if the numbers aren't equal, this
--   additionally provides proof of LT or GT.
cmpNat :: forall a b proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (m :: Nat) :: Nat
instance GHC.Classes.Eq GHC.TypeNats.SomeNat
instance GHC.Classes.Ord GHC.TypeNats.SomeNat
instance GHC.Show.Show GHC.TypeNats.SomeNat
instance GHC.Read.Read GHC.TypeNats.SomeNat
instance GHC.Show.Show (GHC.TypeNats.SNat n)
instance Data.Type.Equality.TestEquality GHC.TypeNats.SNat
instance Data.Type.Coercion.TestCoercion GHC.TypeNats.SNat


-- | GHC's <tt>DataKinds</tt> language extension lifts data constructors,
--   natural numbers, and strings to the type level. This module provides
--   the primitives needed for working with type-level numbers (the
--   <tt>Nat</tt> kind), strings (the <a>Symbol</a> kind), and characters
--   (the <a>Char</a> kind). It also defines the <a>TypeError</a> type
--   family, a feature that makes use of type-level strings to support user
--   defined type errors.
--   
--   For now, this module is the API for working with type-level literals.
--   However, please note that it is a work in progress and is subject to
--   change. Once the design of the <tt>DataKinds</tt> feature is more
--   stable, this will be considered only an internal GHC module, and the
--   programmer interface for working with type-level data will be defined
--   in a separate library.
module GHC.TypeLits

-- | Natural number
--   
--   Invariant: numbers &lt;= 0xffffffffffffffff use the <a>NS</a>
--   constructor
data () => Natural

-- | A type synonym for <a>Natural</a>.
--   
--   Prevously, this was an opaque data type, but it was changed to a type
--   synonym.
type Nat = Natural

-- | (Kind) This is the kind of type-level symbols.
data () => Symbol

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
natSing :: KnownNat n => SNat n

natVal :: forall n proxy. KnownNat n => proxy n -> Integer

natVal' :: forall n. KnownNat n => Proxy# n -> Integer

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)
symbolSing :: KnownSymbol n => SSymbol n

symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String

symbolVal' :: forall n. KnownSymbol n => Proxy# n -> String

class KnownChar (n :: Char)
charSing :: KnownChar n => SChar n
charVal :: forall n proxy. KnownChar n => proxy n -> Char
charVal' :: forall n. KnownChar n => Proxy# n -> Char

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | This type represents unknown type-level symbols.
data SomeSymbol

SomeSymbol :: Proxy n -> SomeSymbol
data SomeChar
SomeChar :: Proxy n -> SomeChar

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Integer -> Maybe SomeNat

-- | Convert a string into an unknown type-level symbol.
someSymbolVal :: String -> SomeSymbol

-- | Convert a character into an unknown type-level char.
someCharVal :: Char -> SomeChar

-- | We either get evidence that this function was instantiated with the
--   same type-level numbers, or <a>Nothing</a>.
sameNat :: forall a b proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level symbols, or <a>Nothing</a>.
sameSymbol :: forall a b proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | We either get evidence that this function was instantiated with the
--   same type-level characters, or <a>Nothing</a>.
sameChar :: forall a b proxy1 proxy2. (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)

-- | Ordering data type for type literals that provides proof of their
--   ordering.
data OrderingI a b
[LTI] :: Compare a b ~ 'LT => OrderingI a b
[EQI] :: Compare a a ~ 'EQ => OrderingI a a
[GTI] :: Compare a b ~ 'GT => OrderingI a b

-- | Like <a>sameNat</a>, but if the numbers aren't equal, this
--   additionally provides proof of LT or GT.
cmpNat :: forall a b proxy1 proxy2. (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Like <a>sameSymbol</a>, but if the symbols aren't equal, this
--   additionally provides proof of LT or GT.
cmpSymbol :: forall a b proxy1 proxy2. (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | Like <a>sameChar</a>, but if the Chars aren't equal, this additionally
--   provides proof of LT or GT.
cmpChar :: forall a b proxy1 proxy2. (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> OrderingI a b

-- | A value-level witness for a type-level natural number. This is
--   commonly referred to as a <i>singleton</i> type, as for each
--   <tt>n</tt>, there is a single value that inhabits the type
--   <tt><a>SNat</a> n</tt> (aside from bottom).
--   
--   The definition of <a>SNat</a> is intentionally left abstract. To
--   obtain an <a>SNat</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>natSing</a> method of <a>KnownNat</a>.</li>
--   <li>The <tt>SNat</tt> pattern synonym.</li>
--   <li>The <a>withSomeSNat</a> function, which creates an <a>SNat</a>
--   from a <a>Natural</a> number.</li>
--   </ol>
data SNat (n :: Nat)

-- | A value-level witness for a type-level symbol. This is commonly
--   referred to as a <i>singleton</i> type, as for each <tt>s</tt>, there
--   is a single value that inhabits the type <tt><a>SSymbol</a> s</tt>
--   (aside from bottom).
--   
--   The definition of <a>SSymbol</a> is intentionally left abstract. To
--   obtain an <a>SSymbol</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>symbolSing</a> method of <a>KnownSymbol</a>.</li>
--   <li>The <tt>SSymbol</tt> pattern synonym.</li>
--   <li>The <a>withSomeSSymbol</a> function, which creates an
--   <a>SSymbol</a> from a <a>String</a>.</li>
--   </ol>
data SSymbol (s :: Symbol)

-- | A value-level witness for a type-level character. This is commonly
--   referred to as a <i>singleton</i> type, as for each <tt>c</tt>, there
--   is a single value that inhabits the type <tt><a>SChar</a> c</tt>
--   (aside from bottom).
--   
--   The definition of <a>SChar</a> is intentionally left abstract. To
--   obtain an <a>SChar</a> value, use one of the following:
--   
--   <ol>
--   <li>The <a>charSing</a> method of <a>KnownChar</a>.</li>
--   <li>The <tt>SChar</tt> pattern synonym.</li>
--   <li>The <a>withSomeSChar</a> function, which creates an <a>SChar</a>
--   from a <a>Char</a>.</li>
--   </ol>
data SChar (s :: Char)

-- | A explicitly bidirectional pattern synonym relating an <a>SNat</a> to
--   a <a>KnownNat</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SNat</a> n</tt>
--   value from an implicit <tt><a>KnownNat</a> n</tt> constraint:
--   
--   <pre>
--   SNat @n :: <a>KnownNat</a> n =&gt; <a>SNat</a> n
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SNat</a> n</tt>
--   value bringing an implicit <tt><a>KnownNat</a> n</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SNat</a> n -&gt; ..
--   f SNat = {- SNat n in scope -}
--   </pre>
pattern SNat :: forall n. () => KnownNat n => SNat n

-- | A explicitly bidirectional pattern synonym relating an <a>SSymbol</a>
--   to a <a>KnownSymbol</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SSymbol</a>
--   s</tt> value from an implicit <tt><a>KnownSymbol</a> s</tt>
--   constraint:
--   
--   <pre>
--   SSymbol @s :: <a>KnownSymbol</a> s =&gt; <a>SSymbol</a> s
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SSymbol</a> s</tt>
--   value bringing an implicit <tt><a>KnownSymbol</a> s</tt> constraint
--   into scope:
--   
--   <pre>
--   f :: <a>SSymbol</a> s -&gt; ..
--   f SSymbol = {- SSymbol s in scope -}
--   </pre>
pattern SSymbol :: forall s. () => KnownSymbol s => SSymbol s

-- | A explicitly bidirectional pattern synonym relating an <a>SChar</a> to
--   a <a>KnownChar</a> constraint.
--   
--   As an <b>expression</b>: Constructs an explicit <tt><a>SChar</a>
--   c</tt> value from an implicit <tt><a>KnownChar</a> c</tt> constraint:
--   
--   <pre>
--   SChar @c :: <a>KnownChar</a> c =&gt; <a>SChar</a> c
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt><a>SChar</a> c</tt>
--   value bringing an implicit <tt><a>KnownChar</a> c</tt> constraint into
--   scope:
--   
--   <pre>
--   f :: <a>SChar</a> c -&gt; ..
--   f SChar = {- SChar c in scope -}
--   </pre>
pattern SChar :: forall c. () => KnownChar c => SChar c

-- | Return the <a>Integer</a> corresponding to <tt>n</tt> in an
--   <tt><tt>SNat</tt> n</tt> value. The returned <a>Integer</a> is always
--   non-negative.
--   
--   For a version of this function that returns a <tt>Natural</tt> instead
--   of an <a>Integer</a>, see <a>fromSNat</a> in <a>GHC.TypeNats</a>.
fromSNat :: SNat n -> Integer

-- | Return the String corresponding to <tt>s</tt> in an <tt><a>SSymbol</a>
--   s</tt> value.
fromSSymbol :: SSymbol s -> String

-- | Return the <a>Char</a> corresponding to <tt>c</tt> in an
--   <tt><a>SChar</a> c</tt> value.
fromSChar :: SChar c -> Char

-- | Attempt to convert an <a>Integer</a> into an <tt><tt>SNat</tt> n</tt>
--   value, where <tt>n</tt> is a fresh type-level natural number. If the
--   <a>Integer</a> argument is non-negative, invoke the continuation with
--   <tt>Just sn</tt>, where <tt>sn</tt> is the <tt><tt>SNat</tt> n</tt>
--   value. If the <a>Integer</a> argument is negative, invoke the
--   continuation with <a>Nothing</a>.
--   
--   For a version of this function where the continuation uses
--   <tt>'SNat</tt> n<tt> instead of </tt><a>Maybe</a> (<tt>SNat</tt> n)@,
--   see <a>withSomeSNat</a> in <a>GHC.TypeNats</a>.
withSomeSNat :: forall rep (r :: TYPE rep). Integer -> (forall n. Maybe (SNat n) -> r) -> r

-- | Convert a <a>String</a> into an <tt><a>SSymbol</a> s</tt> value, where
--   <tt>s</tt> is a fresh type-level symbol.
withSomeSSymbol :: forall rep (r :: TYPE rep). String -> (forall s. SSymbol s -> r) -> r

-- | Convert a <a>Char</a> into an <tt><a>SChar</a> c</tt> value, where
--   <tt>c</tt> is a fresh type-level character.
withSomeSChar :: forall rep (r :: TYPE rep). Char -> (forall c. SChar c -> r) -> r

-- | Convert an explicit <tt><a>SNat</a> n</tt> value into an implicit
--   <tt><a>KnownNat</a> n</tt> constraint.
withKnownNat :: forall n rep (r :: TYPE rep). SNat n -> (KnownNat n => r) -> r

-- | Convert an explicit <tt><a>SSymbol</a> s</tt> value into an implicit
--   <tt><a>KnownSymbol</a> s</tt> constraint.
withKnownSymbol :: forall s rep (r :: TYPE rep). SSymbol s -> (KnownSymbol s => r) -> r

-- | Convert an explicit <tt><a>SChar</a> c</tt> value into an implicit
--   <tt><a>KnownChar</a> c</tt> constraint.
withKnownChar :: forall c rep (r :: TYPE rep). SChar c -> (KnownChar c => r) -> r

-- | Comparison (&lt;=) of comparable types, as a constraint.
type x <= y = Assert (x <=? y) (LeErrMsg x y)
infix 4 <=

-- | Comparison (&lt;=) of comparable types, as a function.
type m <=? n = OrdCond (Compare m n) 'True 'True 'False
infix 4 <=?

-- | Addition of type-level naturals.
type family (m :: Nat) + (n :: Nat) :: Nat
infixl 6 +

-- | Multiplication of type-level naturals.
type family (m :: Nat) * (n :: Nat) :: Nat
infixl 7 *

-- | Exponentiation of type-level naturals.
type family (m :: Nat) ^ (n :: Nat) :: Nat
infixr 8 ^

-- | Subtraction of type-level naturals.
type family (m :: Nat) - (n :: Nat) :: Nat
infixl 6 -

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (m :: Nat) (n :: Nat) :: Nat
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (m :: Nat) :: Nat

-- | Concatenation of type-level symbols.
type family AppendSymbol (m :: Symbol) (n :: Symbol) :: Symbol

-- | Comparison of type-level naturals, as a function.
type family CmpNat (m :: Natural) (n :: Natural) :: Ordering

-- | Comparison of type-level symbols, as a function.
type family CmpSymbol (m :: Symbol) (n :: Symbol) :: Ordering

-- | Comparison of type-level characters.
type family CmpChar (a :: Char) (b :: Char) :: Ordering

-- | Extending a type-level symbol with a type-level character
type family ConsSymbol (a :: Char) (b :: Symbol) :: Symbol

-- | This type family yields type-level <a>Just</a> storing the first
--   character of a symbol and its tail if it is defined and <a>Nothing</a>
--   otherwise.
type family UnconsSymbol (a :: Symbol) :: Maybe (Char, Symbol)

-- | Convert a character to its Unicode code point (cf. <a>ord</a>)
type family CharToNat (c :: Char) :: Nat

-- | Convert a Unicode code point to a character (cf. <a>chr</a>)
type family NatToChar (n :: Nat) :: Char

-- | The type-level equivalent of <a>error</a>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <tt>Show</tt> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
Text :: Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
ShowType :: t -> ErrorMessage

-- | Put two pieces of error message next to each other.
(:<>:) :: ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
(:$$:) :: ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:
instance GHC.Classes.Eq GHC.TypeLits.SomeChar
instance GHC.Classes.Ord GHC.TypeLits.SomeChar
instance GHC.Show.Show GHC.TypeLits.SomeChar
instance GHC.Read.Read GHC.TypeLits.SomeChar
instance GHC.Show.Show (GHC.TypeLits.SChar c)
instance Data.Type.Equality.TestEquality GHC.TypeLits.SChar
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SChar
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol
instance GHC.Show.Show GHC.TypeLits.SomeSymbol
instance GHC.Read.Read GHC.TypeLits.SomeSymbol
instance GHC.Show.Show (GHC.TypeLits.SSymbol s)
instance Data.Type.Equality.TestEquality GHC.TypeLits.SSymbol
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SSymbol


-- | If you're using <tt>GHC.Generics</tt>, you should consider using the
--   <a>http://hackage.haskell.org/package/generic-deriving</a> package,
--   which contains many useful generic functions.
module GHC.Generics

-- | Void: used for datatypes without constructors
data V1 (p :: k)

-- | Unit: used for constructors without arguments
data U1 (p :: k)
U1 :: U1 (p :: k)

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
[unPar1] :: Par1 p -> p

-- | Recursive calls of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled)
newtype Rec1 (f :: k -> Type) (p :: k)
Rec1 :: f p -> Rec1 (f :: k -> Type) (p :: k)
[unRec1] :: Rec1 (f :: k -> Type) (p :: k) -> f p

-- | Constants, additional parameters and recursion of kind <tt>*</tt>
newtype K1 (i :: Type) c (p :: k)
K1 :: c -> K1 (i :: Type) c (p :: k)
[unK1] :: K1 (i :: Type) c (p :: k) -> c

-- | Meta-information (constructor names, etc.)
newtype M1 (i :: Type) (c :: Meta) (f :: k -> Type) (p :: k)
M1 :: f p -> M1 (i :: Type) (c :: Meta) (f :: k -> Type) (p :: k)
[unM1] :: M1 (i :: Type) (c :: Meta) (f :: k -> Type) (p :: k) -> f p

-- | Sums: encode choice between constructors
data (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
L1 :: f p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
R1 :: g p -> (:+:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 5 :+:

-- | Products: encode multiple arguments to constructors
data (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Composition of functors
newtype (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
Comp1 :: f (g p) -> (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1)
[unComp1] :: (:.:) (f :: k2 -> Type) (g :: k1 -> k2) (p :: k1) -> f (g p)
infixr 7 :.:

-- | Constants of unlifted kinds
data family URec (a :: Type) (p :: k)

-- | Type synonym for <tt><a>URec</a> <a>Addr#</a></tt>
type UAddr = URec (Ptr ())

-- | Type synonym for <tt><a>URec</a> <a>Char#</a></tt>
type UChar = URec Char

-- | Type synonym for <tt><a>URec</a> <a>Double#</a></tt>
type UDouble = URec Double

-- | Type synonym for <tt><a>URec</a> <a>Float#</a></tt>
type UFloat = URec Float

-- | Type synonym for <tt><a>URec</a> <a>Int#</a></tt>
type UInt = URec Int

-- | Type synonym for <tt><a>URec</a> <a>Word#</a></tt>
type UWord = URec Word

-- | Type synonym for encoding recursion (of kind <tt>Type</tt>)
type Rec0 = K1 R

-- | Tag for K1: recursion (of kind <tt>Type</tt>)
data R

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Class for datatypes that represent datatypes
class Datatype d

-- | The name of the datatype (unqualified)
datatypeName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | The fully-qualified name of the module where the type is declared
moduleName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | The package name of the module where the type is declared
packageName :: Datatype d => t d (f :: k -> Type) (a :: k) -> [Char]

-- | Marks if the datatype is actually a newtype
isNewtype :: Datatype d => t d (f :: k -> Type) (a :: k) -> Bool

-- | Class for datatypes that represent data constructors
class Constructor c

-- | The name of the constructor
conName :: Constructor c => t c (f :: k -> Type) (a :: k) -> [Char]

-- | The fixity of the constructor
conFixity :: Constructor c => t c (f :: k -> Type) (a :: k) -> Fixity

-- | Marks if this constructor is a record
conIsRecord :: Constructor c => t c (f :: k -> Type) (a :: k) -> Bool

-- | Class for datatypes that represent records
class Selector s

-- | The name of the selector
selName :: Selector s => t s (f :: k -> Type) (a :: k) -> [Char]

-- | The selector's unpackedness annotation (if any)
selSourceUnpackedness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceUnpackedness

-- | The selector's strictness annotation (if any)
selSourceStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> SourceStrictness

-- | The strictness that the compiler inferred for the selector
selDecidedStrictness :: Selector s => t s (f :: k -> Type) (a :: k) -> DecidedStrictness

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | This variant of <a>Fixity</a> appears at the type level.
data FixityI
PrefixI :: FixityI
InfixI :: Associativity -> Nat -> FixityI

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | The unpackedness of a field as the user wrote it in the source code.
--   For example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor     Int
--              {-# NOUNPACK #-} Int
--              {-#   UNPACK #-} Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceUnpackedness</a>, <a>SourceNoUnpack</a>, and
--   <a>SourceUnpack</a>, respectively.
data SourceUnpackedness
NoSourceUnpackedness :: SourceUnpackedness
SourceNoUnpack :: SourceUnpackedness
SourceUnpack :: SourceUnpackedness

-- | The strictness of a field as the user wrote it in the source code. For
--   example, in the following data type:
--   
--   <pre>
--   data E = ExampleConstructor Int ~Int !Int
--   </pre>
--   
--   The fields of <tt>ExampleConstructor</tt> have
--   <a>NoSourceStrictness</a>, <a>SourceLazy</a>, and <a>SourceStrict</a>,
--   respectively.
data SourceStrictness
NoSourceStrictness :: SourceStrictness
SourceLazy :: SourceStrictness
SourceStrict :: SourceStrictness

-- | The strictness that GHC infers for a field during compilation. Whereas
--   there are nine different combinations of <a>SourceUnpackedness</a> and
--   <a>SourceStrictness</a>, the strictness that GHC decides will
--   ultimately be one of lazy, strict, or unpacked. What GHC decides is
--   affected both by what the user writes in the source code and by GHC
--   flags. As an example, consider this data type:
--   
--   <pre>
--   data E = ExampleConstructor {-# UNPACK #-} !Int !Int Int
--   </pre>
--   
--   <ul>
--   <li>If compiled without optimization or other language extensions,
--   then the fields of <tt>ExampleConstructor</tt> will have
--   <a>DecidedStrict</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   <li>If compiled with <tt>-XStrictData</tt> enabled, then the fields
--   will have <a>DecidedStrict</a>, <a>DecidedStrict</a>, and
--   <a>DecidedStrict</a>, respectively.</li>
--   <li>If compiled with <tt>-O2</tt> enabled, then the fields will have
--   <a>DecidedUnpack</a>, <a>DecidedStrict</a>, and <a>DecidedLazy</a>,
--   respectively.</li>
--   </ul>
data DecidedStrictness
DecidedLazy :: DecidedStrictness
DecidedStrict :: DecidedStrictness
DecidedUnpack :: DecidedStrictness

-- | Datatype to represent metadata associated with a datatype
--   (<tt>MetaData</tt>), constructor (<tt>MetaCons</tt>), or field
--   selector (<tt>MetaSel</tt>).
--   
--   <ul>
--   <li>In <tt>MetaData n m p nt</tt>, <tt>n</tt> is the datatype's name,
--   <tt>m</tt> is the module in which the datatype is defined, <tt>p</tt>
--   is the package in which the datatype is defined, and <tt>nt</tt> is
--   <tt>'True</tt> if the datatype is a <tt>newtype</tt>.</li>
--   <li>In <tt>MetaCons n f s</tt>, <tt>n</tt> is the constructor's name,
--   <tt>f</tt> is its fixity, and <tt>s</tt> is <tt>'True</tt> if the
--   constructor contains record selectors.</li>
--   <li>In <tt>MetaSel mn su ss ds</tt>, if the field uses record syntax,
--   then <tt>mn</tt> is <a>Just</a> the record name. Otherwise,
--   <tt>mn</tt> is <a>Nothing</a>. <tt>su</tt> and <tt>ss</tt> are the
--   field's unpackedness and strictness annotations, and <tt>ds</tt> is
--   the strictness that GHC infers for the field.</li>
--   </ul>
data Meta
MetaData :: Symbol -> Symbol -> Symbol -> Bool -> Meta
MetaCons :: Symbol -> FixityI -> Bool -> Meta
MetaSel :: Maybe Symbol -> SourceUnpackedness -> SourceStrictness -> DecidedStrictness -> Meta

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a where {
    
    -- | Generic representation type
    type Rep a :: Type -> Type;
}

-- | Convert from the datatype to its representation
from :: Generic a => a -> Rep a x

-- | Convert from the representation to the datatype
to :: Generic a => Rep a x -> a

-- | Representable types of kind <tt>* -&gt; *</tt> (or kind <tt>k -&gt;
--   *</tt>, when <tt>PolyKinds</tt> is enabled). This class is derivable
--   in GHC with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic1</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from1</a> . <a>to1</a> ≡ <a>id</a>
--   <a>to1</a> . <a>from1</a> ≡ <a>id</a>
--   </pre>
class Generic1 (f :: k -> Type) where {
    
    -- | Generic representation type
    type Rep1 f :: k -> Type;
}

-- | Convert from the datatype to its representation
from1 :: Generic1 f => f a -> Rep1 f a

-- | Convert from the representation to the datatype
to1 :: Generic1 f => Rep1 f a -> f a

-- | A datatype whose instances are defined generically, using the
--   <a>Generic</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic1</a>.
--   
--   Generic instances can be derived via <tt><a>Generically</a> A</tt>
--   using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock Generic
--   
--     deriving (Semigroup, Monoid)
--     via Generically (V4 a)
--   </pre>
--   
--   This corresponds to <a>Semigroup</a> and <a>Monoid</a> instances
--   defined by pointwise lifting:
--   
--   <pre>
--   instance Semigroup a =&gt; Semigroup (V4 a) where
--     (&lt;&gt;) :: V4 a -&gt; V4 a -&gt; V4 a
--     V4 a1 b1 c1 d1 &lt;&gt; V4 a2 b2 c2 d2 =
--       V4 (a1 &lt;&gt; a2) (b1 &lt;&gt; b2) (c1 &lt;&gt; c2) (d1 &lt;&gt; d2)
--   
--   instance Monoid a =&gt; Monoid (V4 a) where
--     mempty :: V4 a
--     mempty = V4 mempty mempty mempty mempty
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically</a> decouples the instance from the
--   type class.
newtype Generically a
Generically :: a -> Generically a

-- | A type whose instances are defined generically, using the
--   <a>Generic1</a> representation. <a>Generically1</a> is a higher-kinded
--   version of <a>Generically</a> that uses <a>Generic</a>.
--   
--   Generic instances can be derived for type constructors via
--   <tt><a>Generically1</a> F</tt> using <tt>-XDerivingVia</tt>.
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric      #-}
--   {-# LANGUAGE DerivingStrategies #-}
--   {-# LANGUAGE DerivingVia        #-}
--   
--   import GHC.Generics (Generic)
--   
--   data V4 a = V4 a a a a
--     deriving stock (Functor, Generic1)
--   
--     deriving Applicative
--     via Generically1 V4
--   </pre>
--   
--   This corresponds to <a>Applicative</a> instances defined by pointwise
--   lifting:
--   
--   <pre>
--   instance Applicative V4 where
--     pure :: a -&gt; V4 a
--     pure a = V4 a a a a
--   
--     liftA2 :: (a -&gt; b -&gt; c) -&gt; (V4 a -&gt; V4 b -&gt; V4 c)
--     liftA2 (·) (V4 a1 b1 c1 d1) (V4 a2 b2 c2 d2) =
--       V4 (a1 · a2) (b1 · b2) (c1 · c2) (d1 · d2)
--   </pre>
--   
--   Historically this required modifying the type class to include generic
--   method definitions (<tt>-XDefaultSignatures</tt>) and deriving it with
--   the <tt>anyclass</tt> strategy (<tt>-XDeriveAnyClass</tt>). Having a
--   /via type/ like <a>Generically1</a> decouples the instance from the
--   type class.
newtype Generically1 f a
[Generically1] :: forall {k} f a. f a -> Generically1 @k f a
instance GHC.Generics.Generic GHC.Generics.DecidedStrictness
instance GHC.Ix.Ix GHC.Generics.DecidedStrictness
instance GHC.Enum.Bounded GHC.Generics.DecidedStrictness
instance GHC.Enum.Enum GHC.Generics.DecidedStrictness
instance GHC.Read.Read GHC.Generics.DecidedStrictness
instance GHC.Classes.Ord GHC.Generics.DecidedStrictness
instance GHC.Show.Show GHC.Generics.DecidedStrictness
instance GHC.Classes.Eq GHC.Generics.DecidedStrictness
instance GHC.Generics.Generic GHC.Generics.SourceStrictness
instance GHC.Ix.Ix GHC.Generics.SourceStrictness
instance GHC.Enum.Bounded GHC.Generics.SourceStrictness
instance GHC.Enum.Enum GHC.Generics.SourceStrictness
instance GHC.Read.Read GHC.Generics.SourceStrictness
instance GHC.Classes.Ord GHC.Generics.SourceStrictness
instance GHC.Show.Show GHC.Generics.SourceStrictness
instance GHC.Classes.Eq GHC.Generics.SourceStrictness
instance GHC.Generics.Generic GHC.Generics.SourceUnpackedness
instance GHC.Ix.Ix GHC.Generics.SourceUnpackedness
instance GHC.Enum.Bounded GHC.Generics.SourceUnpackedness
instance GHC.Enum.Enum GHC.Generics.SourceUnpackedness
instance GHC.Read.Read GHC.Generics.SourceUnpackedness
instance GHC.Classes.Ord GHC.Generics.SourceUnpackedness
instance GHC.Show.Show GHC.Generics.SourceUnpackedness
instance GHC.Classes.Eq GHC.Generics.SourceUnpackedness
instance GHC.Generics.Generic GHC.Generics.Associativity
instance GHC.Ix.Ix GHC.Generics.Associativity
instance GHC.Enum.Bounded GHC.Generics.Associativity
instance GHC.Enum.Enum GHC.Generics.Associativity
instance GHC.Read.Read GHC.Generics.Associativity
instance GHC.Classes.Ord GHC.Generics.Associativity
instance GHC.Show.Show GHC.Generics.Associativity
instance GHC.Classes.Eq GHC.Generics.Associativity
instance GHC.Generics.Generic GHC.Generics.Fixity
instance GHC.Read.Read GHC.Generics.Fixity
instance GHC.Classes.Ord GHC.Generics.Fixity
instance GHC.Show.Show GHC.Generics.Fixity
instance GHC.Classes.Eq GHC.Generics.Fixity
instance GHC.Generics.Generic1 (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Base.Functor (GHC.Generics.URec (GHC.Ptr.Ptr ()))
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec (GHC.Ptr.Ptr ()) p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Char)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Char p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Char p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Double)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Double p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Double p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Float)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Float p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Float p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Int)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Int p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Int p)
instance GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Word p)
instance GHC.Base.Functor (GHC.Generics.URec GHC.Types.Word)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Word p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Word p)
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Generics.Generic ((GHC.Generics.:.:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:.: g)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p)
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:+:) f g p)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p)
instance GHC.Generics.Generic1 (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Generics.Generic (GHC.Generics.K1 i c p)
instance GHC.Base.Functor (GHC.Generics.K1 i c)
instance forall i c k (p :: k). GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p)
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.Rec1 f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p)
instance GHC.Generics.Generic1 GHC.Generics.Par1
instance GHC.Generics.Generic (GHC.Generics.Par1 p)
instance GHC.Base.Functor GHC.Generics.Par1
instance GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p)
instance GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p)
instance GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p)
instance GHC.Generics.Generic1 GHC.Generics.U1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.U1 p)
instance GHC.Generics.Generic1 GHC.Generics.V1
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.V1 p)
instance GHC.Base.Functor GHC.Generics.V1
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.V1 p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.M1 i c f p)
instance GHC.Base.Functor f => GHC.Base.Functor (GHC.Generics.M1 i c f)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p)
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p)
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.U1 p)
instance GHC.Base.Semigroup p => GHC.Base.Semigroup (GHC.Generics.Par1 p)
instance GHC.Base.Monoid p => GHC.Base.Monoid (GHC.Generics.Par1 p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.Rec1 f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.Rec1 f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.Rec1 f p)
instance forall k (f :: k -> *) (p :: k). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.Rec1 f p)
instance forall k c i (p :: k). GHC.Base.Semigroup c => GHC.Base.Semigroup (GHC.Generics.K1 i c p)
instance forall k c i (p :: k). GHC.Base.Monoid c => GHC.Base.Monoid (GHC.Generics.K1 i c p)
instance GHC.Base.Applicative f => GHC.Base.Applicative (GHC.Generics.M1 i c f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (GHC.Generics.M1 i c f)
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.M1 i c f)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (GHC.Generics.M1 i c f)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.M1 i c f p)
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.M1 i c f p)
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Semigroup (f (g p)) => GHC.Base.Semigroup ((GHC.Generics.:.:) f g p)
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Monoid (f (g p)) => GHC.Base.Monoid ((GHC.Generics.:.:) f g p)
instance GHC.Generics.Generic GHC.Base.Void
instance GHC.Generics.Generic [a]
instance GHC.Generics.Generic (GHC.Base.NonEmpty a)
instance GHC.Generics.Generic (GHC.Maybe.Maybe a)
instance GHC.Generics.Generic (Data.Either.Either a b)
instance GHC.Generics.Generic GHC.Types.Bool
instance GHC.Generics.Generic GHC.Types.Ordering
instance forall k (t :: k). GHC.Generics.Generic (Data.Proxy.Proxy t)
instance GHC.Generics.Generic ()
instance GHC.Generics.Generic (Solo a)
instance GHC.Generics.Generic (a, b)
instance GHC.Generics.Generic (a, b, c)
instance GHC.Generics.Generic (a, b, c, d)
instance GHC.Generics.Generic (a, b, c, d, e)
instance GHC.Generics.Generic (a, b, c, d, e, f)
instance GHC.Generics.Generic (a, b, c, d, e, f, g)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Generics.Generic (Data.Ord.Down a)
instance GHC.Generics.Generic GHC.Stack.Types.SrcLoc
instance GHC.Generics.Generic GHC.Unicode.GeneralCategory
instance GHC.Generics.Generic GHC.Fingerprint.Type.Fingerprint
instance GHC.Generics.Generic1 []
instance GHC.Generics.Generic1 GHC.Base.NonEmpty
instance GHC.Generics.Generic1 GHC.Maybe.Maybe
instance GHC.Generics.Generic1 (Data.Either.Either a)
instance GHC.Generics.Generic1 Data.Proxy.Proxy
instance GHC.Generics.Generic1 Solo
instance GHC.Generics.Generic1 ((,) a)
instance GHC.Generics.Generic1 ((,,) a b)
instance GHC.Generics.Generic1 ((,,,) a b c)
instance GHC.Generics.Generic1 ((,,,,) a b c d)
instance GHC.Generics.Generic1 ((,,,,,) a b c d e)
instance GHC.Generics.Generic1 ((,,,,,,) a b c d e f)
instance GHC.Generics.Generic1 ((,,,,,,,) a b c d e f g)
instance GHC.Generics.Generic1 ((,,,,,,,,) a b c d e f g h)
instance GHC.Generics.Generic1 ((,,,,,,,,,) a b c d e f g h i)
instance GHC.Generics.Generic1 ((,,,,,,,,,,) a b c d e f g h i j)
instance GHC.Generics.Generic1 ((,,,,,,,,,,,) a b c d e f g h i j k)
instance GHC.Generics.Generic1 ((,,,,,,,,,,,,) a b c d e f g h i j k l)
instance GHC.Generics.Generic1 ((,,,,,,,,,,,,,) a b c d e f g h i j k l m)
instance GHC.Generics.Generic1 ((,,,,,,,,,,,,,,) a b c d e f g h i j k l m n)
instance GHC.Generics.Generic1 Data.Ord.Down
instance (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol p, GHC.Generics.SingI nt) => GHC.Generics.Datatype ('GHC.Generics.MetaData n m p nt)
instance (GHC.TypeLits.KnownSymbol n, GHC.Generics.SingI f, GHC.Generics.SingI r) => GHC.Generics.Constructor ('GHC.Generics.MetaCons n f r)
instance (GHC.Generics.SingI mn, GHC.Generics.SingI su, GHC.Generics.SingI ss, GHC.Generics.SingI ds) => GHC.Generics.Selector ('GHC.Generics.MetaSel mn su ss ds)
instance GHC.Generics.SingKind GHC.Types.Symbol
instance GHC.Generics.SingKind GHC.Types.Bool
instance GHC.Generics.SingKind a => GHC.Generics.SingKind (GHC.Maybe.Maybe a)
instance GHC.Generics.SingKind GHC.Generics.FixityI
instance GHC.Generics.SingKind GHC.Generics.Associativity
instance GHC.Generics.SingKind GHC.Generics.SourceUnpackedness
instance GHC.Generics.SingKind GHC.Generics.SourceStrictness
instance GHC.Generics.SingKind GHC.Generics.DecidedStrictness
instance GHC.TypeLits.KnownSymbol a => GHC.Generics.SingI a
instance GHC.Generics.SingI 'GHC.Types.True
instance GHC.Generics.SingI 'GHC.Types.False
instance GHC.Generics.SingI 'GHC.Maybe.Nothing
instance forall a1 (a2 :: a1). GHC.Generics.SingI a2 => GHC.Generics.SingI ('GHC.Maybe.Just a2)
instance GHC.Generics.SingI 'GHC.Generics.PrefixI
instance (GHC.Generics.SingI a, GHC.TypeNats.KnownNat n) => GHC.Generics.SingI ('GHC.Generics.InfixI a n)
instance GHC.Generics.SingI 'GHC.Generics.LeftAssociative
instance GHC.Generics.SingI 'GHC.Generics.RightAssociative
instance GHC.Generics.SingI 'GHC.Generics.NotAssociative
instance GHC.Generics.SingI 'GHC.Generics.NoSourceUnpackedness
instance GHC.Generics.SingI 'GHC.Generics.SourceNoUnpack
instance GHC.Generics.SingI 'GHC.Generics.SourceUnpack
instance GHC.Generics.SingI 'GHC.Generics.NoSourceStrictness
instance GHC.Generics.SingI 'GHC.Generics.SourceLazy
instance GHC.Generics.SingI 'GHC.Generics.SourceStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedLazy
instance GHC.Generics.SingI 'GHC.Generics.DecidedStrict
instance GHC.Generics.SingI 'GHC.Generics.DecidedUnpack
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Eq (GHC.Generics.Rep1 f a)) => GHC.Classes.Eq (GHC.Generics.Generically1 f a)
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Ord (GHC.Generics.Rep1 f a)) => GHC.Classes.Ord (GHC.Generics.Generically1 f a)
instance (GHC.Generics.Generic1 f, GHC.Base.Functor (GHC.Generics.Rep1 f)) => GHC.Base.Functor (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, GHC.Base.Applicative (GHC.Generics.Rep1 f)) => GHC.Base.Applicative (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic1 f, GHC.Base.Alternative (GHC.Generics.Rep1 f)) => GHC.Base.Alternative (GHC.Generics.Generically1 f)
instance (GHC.Generics.Generic a, GHC.Base.Semigroup (GHC.Generics.Rep a ())) => GHC.Base.Semigroup (GHC.Generics.Generically a)
instance (GHC.Generics.Generic a, GHC.Base.Monoid (GHC.Generics.Rep a ())) => GHC.Base.Monoid (GHC.Generics.Generically a)
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.V1 p)
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.U1 p)
instance GHC.Base.Functor GHC.Generics.U1
instance GHC.Base.Applicative GHC.Generics.U1
instance GHC.Base.Alternative GHC.Generics.U1
instance GHC.Base.Monad GHC.Generics.U1
instance GHC.Base.MonadPlus GHC.Generics.U1
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.U1 p)
instance forall k (p :: k). GHC.Base.Monoid (GHC.Generics.U1 p)
instance GHC.Base.Applicative GHC.Generics.Par1
instance GHC.Base.Monad GHC.Generics.Par1
instance GHC.Base.Monad f => GHC.Base.Monad (GHC.Generics.Rec1 f)
instance GHC.Base.Monoid c => GHC.Base.Applicative (GHC.Generics.K1 i c)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:*: g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (f GHC.Generics.:*: g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (f GHC.Generics.:*: g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Semigroup (f p), GHC.Base.Semigroup (g p)) => GHC.Base.Semigroup ((GHC.Generics.:*:) f g p)
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Monoid (f p), GHC.Base.Monoid (g p)) => GHC.Base.Monoid ((GHC.Generics.:*:) f g p)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f GHC.Generics.:.: g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (f GHC.Generics.:.: g)


-- | A type <tt>a</tt> is a <a>Monoid</a> if it provides an associative
--   function (<a>&lt;&gt;</a>) that lets you combine any two values of
--   type <tt>a</tt> into one, and a neutral element (<a>mempty</a>) such
--   that
--   
--   <pre>
--   a &lt;&gt; mempty == mempty &lt;&gt; a == a
--   </pre>
--   
--   A <a>Monoid</a> is a <a>Semigroup</a> with the added requirement of a
--   neutral element. Thus any <a>Monoid</a> is a <a>Semigroup</a>, but not
--   the other way around.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>Sum</a> monoid is defined by the numerical addition operator
--   and `0` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; mempty :: Sum Int
--   Sum {getSum = 0}
--   
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; Sum 3 &lt;&gt; Sum 4 :: Sum Int
--   Sum {getSum = 10}
--   </pre>
--   
--   We can combine multiple values in a list into a single value using the
--   <a>mconcat</a> function. Note that we have to specify the type here
--   since <a>Int</a> is a monoid under several different operations:
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Sum Int
--   Sum {getSum = 10}
--   
--   &gt;&gt;&gt; mconcat [] :: Sum Int
--   Sum {getSum = 0}
--   </pre>
--   
--   Another valid monoid instance of <a>Int</a> is <a>Product</a> It is
--   defined by multiplication and `1` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; Product 1 &lt;&gt; Product 2 &lt;&gt; Product 3 &lt;&gt; Product 4 :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [] :: Product Int
--   Product {getProduct = 1}
--   </pre>
module Data.Monoid

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the leftmost non-<a>Nothing</a> value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   Beware that <tt>Data.Monoid.</tt><a>First</a> is different from
--   <tt>Data.Semigroup.</tt><a>First</a>. The former returns the first
--   non-<a>Nothing</a>, so <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>. The latter simply returns the first value, thus
--   <tt>Data.Semigroup.First Nothing &lt;&gt; x = Data.Semigroup.First
--   Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world")
--   First {getFirst = Just "hello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; First Nothing &lt;&gt; mempty
--   First {getFirst = Nothing}
--   </pre>
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-<a>Nothing</a> value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <tt>Data.Semigroup.</tt><a>Last</a>. The former returns the last
--   non-<a>Nothing</a>, so <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>. The latter simply returns the last value, thus <tt>x &lt;&gt;
--   Data.Semigroup.Last Nothing = Data.Semigroup.Last Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world")
--   Last {getLast = Just "world"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Last Nothing &lt;&gt; mempty
--   Last {getLast = Nothing}
--   </pre>
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   Alt l &lt;&gt; Alt r == Alt (l &lt;|&gt; r)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Alt (Just 12) &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Alt Nothing &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 24}
--   </pre>
newtype Alt f a
Alt :: f a -> Alt f a
[getAlt] :: Alt f a -> f a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Ap (Just [1, 2, 3]) &lt;&gt; Ap Nothing
--   Ap {getAp = Nothing}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ap [Sum 10, Sum 20] &lt;&gt; Ap [Sum 1, Sum 2]
--   Ap {getAp = [Sum {getSum = 11},Sum {getSum = 12},Sum {getSum = 21},Sum {getSum = 22}]}
--   </pre>
newtype Ap f a
Ap :: f a -> Ap f a
[getAp] :: Ap f a -> f a
instance GHC.Base.Monad Data.Monoid.First
instance GHC.Base.Applicative Data.Monoid.First
instance GHC.Base.Functor Data.Monoid.First
instance GHC.Generics.Generic1 Data.Monoid.First
instance GHC.Generics.Generic (Data.Monoid.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a)
instance GHC.Base.Monad Data.Monoid.Last
instance GHC.Base.Applicative Data.Monoid.Last
instance GHC.Base.Functor Data.Monoid.Last
instance GHC.Generics.Generic1 Data.Monoid.Last
instance GHC.Generics.Generic (Data.Monoid.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Ap f a)
instance GHC.Base.MonadPlus f => GHC.Base.MonadPlus (Data.Monoid.Ap f)
instance Control.Monad.Fail.MonadFail f => Control.Monad.Fail.MonadFail (Data.Monoid.Ap f)
instance GHC.Base.Monad f => GHC.Base.Monad (Data.Monoid.Ap f)
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Ap f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Monoid.Ap f)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Ap f a)
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Ap f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Monoid.Ap f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Monoid.Ap f)
instance (GHC.Base.Applicative f, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Enum.Bounded a) => GHC.Enum.Bounded (Data.Monoid.Ap f a)
instance (GHC.Base.Applicative f, GHC.Num.Num a) => GHC.Num.Num (Data.Monoid.Ap f a)
instance GHC.Base.Semigroup (Data.Monoid.Last a)
instance GHC.Base.Monoid (Data.Monoid.Last a)
instance GHC.Base.Semigroup (Data.Monoid.First a)
instance GHC.Base.Monoid (Data.Monoid.First a)


-- | This legacy module provides access to the list-specialised operations
--   of <a>Data.List</a>. This module may go away again in future GHC
--   versions and is provided as transitional tool to access some of the
--   list-specialised operations that had to be generalised due to the
--   implementation of the <a>Foldable/Traversable-in-Prelude Proposal
--   (FTP)</a>.
--   
--   If the operations needed are available in <a>GHC.List</a>, it's
--   recommended to avoid importing this module and use <a>GHC.List</a>
--   instead for now.
module GHC.OldList

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | Produce singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
singleton :: a -> [a]

-- | &lt;math&gt;. Test whether a list is empty.
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   
--   &gt;&gt;&gt; null [1]
--   False
--   
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: [a] -> Bool

-- | &lt;math&gt;. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <a>genericLength</a>, the result type of which may be any kind of
--   number.
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: [a] -> Int

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
--   
--   For this reason the outer list must be finite; otherwise
--   <a>transpose</a> hangs:
--   
--   <pre>
--   &gt;&gt;&gt; transpose (repeat [])
--   * Hangs forever *
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 8 $ subsequences ['a'..]
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   The <a>permutations</a> function is maximally lazy: for each
--   <tt>n</tt>, the value of <tt><a>permutations</a> xs</tt> starts with
--   those permutations that permute <tt><a>take</a> n xs</tt> and keep
--   <tt><a>drop</a> n xs</tt>.
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 6 $ map (take 3) $ permutations ['a'..]
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   Note that the order of permutations is not lexicographic. It satisfies
--   the following property:
--   
--   <pre>
--   map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]
--   </pre>
permutations :: [a] -> [[a]]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a list, reduces the
--   list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 0 [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl (+) 42 []
--   42
--   
--   &gt;&gt;&gt; foldl (-) 100 [1..4]
--   90
--   
--   &gt;&gt;&gt; foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   "dcbafoo"
--   
--   &gt;&gt;&gt; foldl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | A strict version of <a>foldl</a>.
foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldl</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a list, reduces
--   the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty lists. Note that
--   unlike <a>foldr</a>, the accumulated value must be of the same type as
--   the list elements.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   
--   &gt;&gt;&gt; foldr1 (+) []
--   *** Exception: Prelude.foldr1: empty list
--   
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   
--   &gt;&gt;&gt; force $ foldr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
foldr1 :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Concatenate a list of lists.
--   
--   <pre>
--   &gt;&gt;&gt; concat []
--   []
--   
--   &gt;&gt;&gt; concat [[42]]
--   [42]
--   
--   &gt;&gt;&gt; concat [[1,2,3], [4,5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: [[a]] -> [a]

-- | Map a function returning a list over a list and concatenate the
--   results. <a>concatMap</a> can be seen as the composition of
--   <a>concat</a> and <a>map</a>.
--   
--   <pre>
--   concatMap f xs == (concat . map f) xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) []
--   []
--   
--   &gt;&gt;&gt; concatMap (\i -&gt; [-i,i]) [1,2,3]
--   [-1,1,-2,2,-3,3]
--   </pre>
concatMap :: (a -> [b]) -> [a] -> [b]

-- | <a>and</a> returns the conjunction of a Boolean list. For the result
--   to be <a>True</a>, the list must be finite; <a>False</a>, however,
--   results from a <a>False</a> value at a finite index of a finite or
--   infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   
--   &gt;&gt;&gt; and [True]
--   True
--   
--   &gt;&gt;&gt; and [False]
--   False
--   
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
--   False
--   
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: [Bool] -> Bool

-- | <a>or</a> returns the disjunction of a Boolean list. For the result to
--   be <a>False</a>, the list must be finite; <a>True</a>, however,
--   results from a <a>True</a> value at a finite index of a finite or
--   infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   
--   &gt;&gt;&gt; or [True]
--   True
--   
--   &gt;&gt;&gt; or [False]
--   False
--   
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
--   True
--   
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: [Bool] -> Bool

-- | Applied to a predicate and a list, <a>any</a> determines if any
--   element of the list satisfies the predicate. For the result to be
--   <a>False</a>, the list must be finite; <a>True</a>, however, results
--   from a <a>True</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: (a -> Bool) -> [a] -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate. For the result to be
--   <a>True</a>, the list must be finite; <a>False</a>, however, results
--   from a <a>False</a> value for the predicate applied to an element at a
--   finite index of a finite or infinite list.
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: (a -> Bool) -> [a] -> Bool

-- | The <a>sum</a> function computes the sum of a finite list of numbers.
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   
--   &gt;&gt;&gt; sum [42]
--   42
--   
--   &gt;&gt;&gt; sum [1..10]
--   55
--   
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: Num a => [a] -> a

-- | The <a>product</a> function computes the product of a finite list of
--   numbers.
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   
--   &gt;&gt;&gt; product [42]
--   42
--   
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: Num a => [a] -> a

-- | <a>maximum</a> returns the maximum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>maximumBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   
--   &gt;&gt;&gt; maximum [42]
--   42
--   
--   &gt;&gt;&gt; maximum [55, -12, 7, 0, -89]
--   55
--   
--   &gt;&gt;&gt; maximum [1..]
--   * Hangs forever *
--   </pre>
maximum :: (Ord a, HasCallStack) => [a] -> a

-- | <a>minimum</a> returns the minimum value from a list, which must be
--   non-empty, finite, and of an ordered type. It is a special case of
--   <a>minimumBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   
--   &gt;&gt;&gt; minimum [42]
--   42
--   
--   &gt;&gt;&gt; minimum [55, -12, 7, 0, -89]
--   -89
--   
--   &gt;&gt;&gt; minimum [1..]
--   * Hangs forever *
--   </pre>
minimum :: (Ord a, HasCallStack) => [a] -> a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from left to right, and returning a
--   final value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a list,
--   passing an accumulating parameter from right to left, and returning a
--   final value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result is non-empty and all elements are
--   equal to the first one. For example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   <a>group</a> is a special case of <a>groupBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   It's often preferable to use <tt>Data.List.NonEmpty.</tt><a>group</a>,
--   which provides type-level guarantees of non-emptiness of inner lists.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
--   
--   <a>inits</a> is semantically equivalent to <tt><a>map</a>
--   <a>reverse</a> . <a>scanl</a> (<a>flip</a> (:)) []</tt>, but under the
--   hood uses a queue to amortize costs of <a>reverse</a>.
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite;
--   <a>False</a>, however, results from any mismatch:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [1..]
--   False
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isPrefixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..]
--   * Hangs forever *
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
--   
--   The second list must be finite; however the first list may be
--   infinite:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSuffixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isSuffixOf` [0..]
--   * Hangs forever *
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [20..50] `isInfixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [20..50]
--   False
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [0..]
--   * Hangs forever *
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <a>elem</a> is the list membership predicate, usually written in infix
--   form, e.g., <tt>x `elem` xs</tt>. For the result to be <a>False</a>,
--   the list must be finite; <a>True</a>, however, results from an element
--   equal to <tt>x</tt> found at a finite index of a finite or infinite
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   
--   &gt;&gt;&gt; 3 `elem` [4..]
--   * Hangs forever *
--   </pre>
elem :: Eq a => a -> [a] -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   
--   &gt;&gt;&gt; 3 `notElem` [4..]
--   * Hangs forever *
--   </pre>
notElem :: Eq a => a -> [a] -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a list and returns the
--   first element in the list matching the predicate, or <a>Nothing</a> if
--   there is no such element. For the result to be <a>Nothing</a>, the
--   list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 4) [1..]
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&lt; 0) [1..10]
--   Nothing
--   </pre>
find :: (a -> Bool) -> [a] -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
--   
--   If the order of outputs does not matter and there exists <tt>instance
--   Ord a</tt>, it's faster to use <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> .
--   <tt>Data.List.NonEmpty.</tt><a>group</a> . <a>sort</a>, which takes
--   only &lt;math&gt; time.
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus <tt>(xs ++ ys) \\ xs == ys</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..4])
--   [0,1,5,6,7]
--   
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..])
--   * Hangs forever *
--   </pre>
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. It
--   is a special case of <a>unionBy</a>, which allows the programmer to
--   supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used. If the second list contains equal elements, only
--   the first one will be retained:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; union [Arg () "dog"] [Arg () "cow"]
--   [Arg () "dog"]
--   
--   &gt;&gt;&gt; union [] [Arg () "dog", Arg () "cow"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result:
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `union` "duck"
--   "cootduk"
--   
--   &gt;&gt;&gt; "duck" `union` "coot"
--   "duckot"
--   </pre>
--   
--   <a>union</a> is productive even if both arguments are infinite.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used, and all duplicates from the second list quashed:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `intersect` "heron"
--   "oo"
--   
--   &gt;&gt;&gt; "heron" `intersect` "coot"
--   "o"
--   </pre>
--   
--   If the second list is infinite, <a>intersect</a> either hangs or
--   returns its first argument in full. Otherwise if the first list is
--   infinite, <a>intersect</a> might be productive:
--   
--   <pre>
--   &gt;&gt;&gt; intersect [100..] [0..]
--   [100,101,102,103...
--   
--   &gt;&gt;&gt; intersect [0] [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect [1..] [0]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect (cycle [1..3]) [2]
--   [2,2,2,2...
--   </pre>
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   The argument must be finite.
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt><a>sortOn</a> f</tt> is equivalent to <tt><a>sortBy</a>
--   (<a>comparing</a> f)</tt>, but has the performance advantage of only
--   evaluating <tt>f</tt> once for each element in the input list. This is
--   called the decorate-sort-undecorate paradigm, or <a>Schwartzian
--   transform</a>.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The argument must be finite.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed. This is the non-overloaded version of
--   <a>(\\)</a>.
--   
--   The second list must be finite, but the first may be infinite.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>. Both arguments may be infinite.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>. It is productive for infinite arguments only if the
--   first one is a subset of the second.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
--   
--   When a supplied relation is not transitive, it is important to
--   remember that equality is checked against the first element in the
--   group, not against the nearest neighbour:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (\a b -&gt; b - a &lt; 5) [0..19]
--   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
--   </pre>
--   
--   It's often preferable to use
--   <tt>Data.List.NonEmpty.</tt><a>groupBy</a>, which provides type-level
--   guarantees of non-emptiness of inner lists.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>. The argument must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The supplied comparison relation is supposed to be reflexive and
--   antisymmetric, otherwise, e. g., for <tt>_ _ -&gt; GT</tt>, the
--   ordered list simply does not exist. The relation is also expected to
--   be transitive: if it is not then <a>sortBy</a> might fail to find an
--   ordered permutation, even if it exists.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>maximumBy</a> function is the non-overloaded version of
--   <a>maximum</a>, which takes a comparison function and a list and
--   returns the greatest element of the list by the comparison function.
--   The list must be finite and non-empty.
--   
--   We can use this to find the longest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
maximumBy :: (a -> a -> Ordering) -> [a] -> a

-- | The <a>minimumBy</a> function is the non-overloaded version of
--   <a>minimum</a>, which takes a comparison function and a list and
--   returns the least element of the list by the comparison function. The
--   list must be finite and non-empty.
--   
--   We can use this to find the shortest entry of a list:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (\x y -&gt; compare (length x) (length y)) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
minimumBy :: (a -> a -> Ordering) -> [a] -> a

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
--   
--   Users should take care to pick a return type that is wide enough to
--   contain the full length of the list. If the width is insufficient, the
--   overflow behaviour will depend on the <tt>(+)</tt> implementation in
--   the selected <a>Num</a> instance. The following example overflows
--   because the actual list length of 200 lies outside of the
--   <tt>Int8</tt> range of <tt>-128..127</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1..200] :: Int8
--   -56
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Class of data structures that can be folded to a summary value.
module Data.Foldable

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable t

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A left-associative variant of <a>foldMap</a> that is strict in the
--   accumulator. Use this method for strict reduction when partial results
--   are merged via <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Define a <a>Monoid</a> over finite bit strings under <tt>xor</tt>. Use
--   it to strictly compute the <tt>xor</tt> of a list of <a>Int</a>
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving
--   
--   &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)
--   
--   &gt;&gt;&gt; import Data.Foldable (foldMap')
--   
--   &gt;&gt;&gt; import Numeric (showHex)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]
--   
--   &gt;&gt;&gt; (\ (X a) -&gt; showString "0x" . showHex a $ "") $ foldMap' X bits
--   "0x42"
--   </pre>
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | <a>foldr'</a> is a variant of <a>foldr</a> that performs strict
--   reduction from right to left, i.e. starting with the right-most
--   element. The input structure <i>must</i> be finite, otherwise
--   <a>foldr'</a> runs out of space (<i>diverges</i>).
--   
--   If you want a strict right fold in constant space, you need a
--   structure that supports faster than <i>O(n)</i> access to the
--   right-most element, such as <tt>Seq</tt> from the <tt>containers</tt>
--   package.
--   
--   This method does not run in constant space for structures such as
--   lists that don't support efficient right-to-left iteration and so
--   require <i>O(n)</i> space to perform right-to-left reduction. Use of
--   this method with such a structure is a hint that the chosen structure
--   may be a poor fit for the task at hand. If the order in which the
--   elements are combined is not important, use <a>foldl'</a> instead.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
--   
--   <a>sequenceA_</a> is just like <a>sequence_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance Data.Foldable.Foldable Solo
instance Data.Foldable.Foldable GHC.Generics.V1
instance Data.Foldable.Foldable GHC.Generics.Par1
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.Rec1 f)
instance Data.Foldable.Foldable (GHC.Generics.K1 i c)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.M1 i c f)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:+: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:*: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:.: g)
instance Data.Foldable.Foldable GHC.Generics.UAddr
instance Data.Foldable.Foldable GHC.Generics.UChar
instance Data.Foldable.Foldable GHC.Generics.UDouble
instance Data.Foldable.Foldable GHC.Generics.UFloat
instance Data.Foldable.Foldable GHC.Generics.UInt
instance Data.Foldable.Foldable GHC.Generics.UWord
instance Data.Foldable.Foldable Data.Ord.Down
instance Data.Foldable.Foldable GHC.Maybe.Maybe
instance Data.Foldable.Foldable []
instance Data.Foldable.Foldable GHC.Base.NonEmpty
instance Data.Foldable.Foldable (Data.Either.Either a)
instance Data.Foldable.Foldable ((,) a)
instance Data.Foldable.Foldable (GHC.Arr.Array i)
instance Data.Foldable.Foldable Data.Proxy.Proxy
instance Data.Foldable.Foldable Data.Semigroup.Internal.Dual
instance Data.Foldable.Foldable Data.Semigroup.Internal.Sum
instance Data.Foldable.Foldable Data.Semigroup.Internal.Product
instance Data.Foldable.Foldable Data.Monoid.First
instance Data.Foldable.Foldable Data.Monoid.Last
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Semigroup.Internal.Alt f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Monoid.Ap f)
instance Data.Foldable.Foldable GHC.Generics.U1


module Data.Functor.Const

-- | The <a>Const</a> functor.
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
instance forall a k (b :: k). Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Real a => GHC.Real.Real (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Num.Num a => GHC.Num.Num (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Const.Const a b)
instance GHC.Generics.Generic1 (Data.Functor.Const.Const a)
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Const.Const a b)
instance forall a k (b :: k). GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Const.Const a b)
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Const.Const a b)
instance Data.Foldable.Foldable (Data.Functor.Const.Const m)
instance GHC.Base.Functor (Data.Functor.Const.Const m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Data.Functor.Const.Const m)


-- | This module is part of the Foreign Function Interface (FFI) and will
--   usually be imported via the module <a>Foreign</a>.
module Foreign.StablePtr

-- | A <i>stable pointer</i> is a reference to a Haskell expression that is
--   guaranteed not to be affected by garbage collection, i.e., it will
--   neither be deallocated nor will the value of the stable pointer itself
--   change during garbage collection (ordinary references may be relocated
--   during garbage collection). Consequently, stable pointers can be
--   passed to foreign code, which can treat it as an opaque reference to a
--   Haskell value.
--   
--   The <tt>StablePtr</tt> 0 is reserved for representing NULL in foreign
--   code.
--   
--   A value of type <tt>StablePtr a</tt> is a stable pointer to a Haskell
--   expression of type <tt>a</tt>.
data {-# CTYPE "HsStablePtr" #-} StablePtr a

-- | Create a stable pointer referring to the given Haskell value.
newStablePtr :: a -> IO (StablePtr a)

-- | Obtain the Haskell value referenced by a stable pointer, i.e., the
--   same value that was passed to the corresponding call to
--   <a>newStablePtr</a>. If the argument to <a>deRefStablePtr</a> has
--   already been freed using <a>freeStablePtr</a>, the behaviour of
--   <a>deRefStablePtr</a> is undefined.
deRefStablePtr :: StablePtr a -> IO a

-- | Dissolve the association between the stable pointer and the Haskell
--   value. Afterwards, if the stable pointer is passed to
--   <a>deRefStablePtr</a> or <a>freeStablePtr</a>, the behaviour is
--   undefined. However, the stable pointer may still be passed to
--   <a>castStablePtrToPtr</a>, but the <tt><a>Ptr</a> ()</tt> value
--   returned by <a>castStablePtrToPtr</a>, in this case, is undefined (in
--   particular, it may be <a>nullPtr</a>). Nevertheless, the call to
--   <a>castStablePtrToPtr</a> is guaranteed not to diverge.
freeStablePtr :: StablePtr a -> IO ()

-- | Coerce a stable pointer to an address. No guarantees are made about
--   the resulting value, except that the original stable pointer can be
--   recovered by <a>castPtrToStablePtr</a>. In particular, the address
--   might not refer to an accessible memory location and any attempt to
--   pass it to the member functions of the class <a>Storable</a> leads to
--   undefined behaviour.
castStablePtrToPtr :: StablePtr a -> Ptr ()

-- | The inverse of <a>castStablePtrToPtr</a>, i.e., we have the identity
--   
--   <pre>
--   sp == castPtrToStablePtr (castStablePtrToPtr sp)
--   </pre>
--   
--   for any stable pointer <tt>sp</tt> on which <a>freeStablePtr</a> has
--   not been executed yet. Moreover, <a>castPtrToStablePtr</a> may only be
--   applied to pointers that have been produced by
--   <a>castStablePtrToPtr</a>.
castPtrToStablePtr :: Ptr () -> StablePtr a


-- | Legacy interface for arrays of arrays. Deprecated, because the
--   <a>Array#</a> type can now store arrays directly. Consider simply
--   using <a>Array#</a> instead of <a>ArrayArray#</a>.
--   
--   Use GHC.Exts instead of importing this module directly.
module GHC.ArrayArray
newtype ArrayArray#
ArrayArray# :: Array# ByteArray# -> ArrayArray#
newtype MutableArrayArray# s
MutableArrayArray# :: MutableArray# s ByteArray# -> MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the <a>ArrayArray#</a> to the specified region in the
--   <a>MutableArrayArray#</a>. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Compare the underlying pointers of two arrays of arrays.
sameArrayArray# :: ArrayArray# -> ArrayArray# -> Int#

-- | Compare the underlying pointers of two mutable arrays of arrays.
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#


-- | This provides a type-indexed type representation mechanism, similar to
--   that described by,
--   
--   <ul>
--   <li>Simon Peyton-Jones, Stephanie Weirich, Richard Eisenberg,
--   Dimitrios Vytiniotis. "<a>A reflection on types</a>". <i>Proc. Philip
--   Wadler's 60th birthday Festschrift</i>, Edinburgh (April 2016).</li>
--   </ul>
--   
--   The interface provides <a>TypeRep</a>, a type representation which can
--   be safely decomposed and composed. See <a>Data.Dynamic</a> for an
--   example of this.
module Type.Reflection

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
typeRep :: Typeable a => TypeRep a

-- | Use a <a>TypeRep</a> as <a>Typeable</a> evidence.
--   
--   The <a>TypeRep</a> pattern synonym brings a <a>Typeable</a> constraint
--   into scope and can be used in place of <a>withTypeable</a>.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f rep = withTypeable {- Typeable a in scope -}
--   
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
withTypeable :: forall k (a :: k) rep (r :: TYPE rep). () => TypeRep a -> (Typeable a => r) -> r

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data a :~~: b
[HRefl] :: a :~~: a
infix 4 :~~:

-- | TypeRep is a concrete representation of a (monomorphic) type.
--   <a>TypeRep</a> supports reasonably efficient equality. See Note [Grand
--   plan for Typeable] in GHC.Tc.Instance.Typeable
data TypeRep a

-- | A explicitly bidirectional pattern synonym to construct a concrete
--   representation of a type.
--   
--   As an <b>expression</b>: Constructs a singleton <tt>TypeRep a</tt>
--   given a implicit 'Typeable a' constraint:
--   
--   <pre>
--   TypeRep @a :: Typeable a =&gt; TypeRep a
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt>TypeRep a</tt> witness
--   bringing an implicit <tt>Typeable a</tt> constraint into scope.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
pattern TypeRep :: forall {k :: Type} (a :: k). () => Typeable @k a => TypeRep @k a
typeOf :: Typeable a => a -> TypeRep a

-- | A type application.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Maybe Int) === App (typeRep @Maybe) (typeRep @Int)
--   </pre>
--   
--   Note that this will also match a function type,
--   
--   <pre>
--   typeRep @(Int# -&gt; Char)
--     ===
--   App (App arrow (typeRep @Int#)) (typeRep @Char)
--   </pre>
--   
--   where <tt>arrow :: TypeRep ((-&gt;) :: TYPE IntRep -&gt; Type -&gt;
--   Type)</tt>.
pattern App :: forall k2 (t :: k2). () => forall k1 (a :: k1 -> k2) (b :: k1). t ~ a b => TypeRep a -> TypeRep b -> TypeRep t

-- | Pattern match on a type constructor
pattern Con :: forall k (a :: k). () => NotApplication a => TyCon -> TypeRep a

-- | Pattern match on a type constructor including its instantiated kind
--   variables.
--   
--   For instance,
--   
--   <pre>
--   App (Con' proxyTyCon ks) intRep = typeRep @(Proxy @Int)
--   </pre>
--   
--   will bring into scope,
--   
--   <pre>
--   proxyTyCon :: TyCon
--   ks         == [someTypeRep <tt>Type] :: [SomeTypeRep]
--   intRep     == typeRep </tt>Int
--   </pre>
pattern Con' :: forall k (a :: k). () => NotApplication a => TyCon -> [SomeTypeRep] -> TypeRep a

-- | The function type constructor.
--   
--   For instance,
--   
--   <pre>
--   typeRep @(Int -&gt; Char) === Fun (typeRep @Int) (typeRep @Char)
--   </pre>
pattern Fun :: forall k (fun :: k). () => forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (arg :: TYPE r1) (res :: TYPE r2). (k ~ Type, fun ~~ (arg -> res)) => TypeRep arg -> TypeRep res -> TypeRep fun

-- | Observe the type constructor of a type representation
typeRepTyCon :: TypeRep a -> TyCon

-- | Helper to fully evaluate <a>TypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfTypeRep :: TypeRep a -> ()

-- | Type equality
eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Maybe (a :~~: b)

-- | Observe the kind of a type.
typeRepKind :: TypeRep (a :: k) -> TypeRep k
splitApps :: TypeRep a -> (TyCon, [SomeTypeRep])

-- | A non-indexed type representation.
data SomeTypeRep
[SomeTypeRep] :: forall k (a :: k). !TypeRep a -> SomeTypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
someTypeRep :: forall proxy a. Typeable a => proxy a -> SomeTypeRep

-- | Observe the type constructor of a quantified type representation.
someTypeRepTyCon :: SomeTypeRep -> TyCon

-- | Helper to fully evaluate <a>SomeTypeRep</a> for use as
--   <tt>NFData(rnf)</tt> implementation
rnfSomeTypeRep :: SomeTypeRep -> ()
data () => TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
data () => Module
moduleName :: Module -> String
modulePackage :: Module -> String

-- | Helper to fully evaluate <a>TyCon</a> for use as <tt>NFData(rnf)</tt>
--   implementation
rnfModule :: Module -> ()


-- | The <a>Typeable</a> class reifies types to some extent by associating
--   type representations to types. These type representations can be
--   compared, and one can in turn define a type-safe cast operation. To
--   this end, an unsafe cast is guarded by a test for type
--   (representation) equivalence. The module <a>Data.Dynamic</a> uses
--   Typeable for an implementation of dynamics. The module
--   <a>Data.Data</a> uses Typeable and type-safe cast (but not dynamics)
--   to support the "Scrap your boilerplate" style of generic programming.
--   
--   <h2>Compatibility Notes</h2>
--   
--   Since GHC 8.2, GHC has supported type-indexed type representations.
--   <a>Data.Typeable</a> provides type representations which are qualified
--   over this index, providing an interface very similar to the
--   <a>Typeable</a> notion seen in previous releases. For the type-indexed
--   interface, see <a>Type.Reflection</a>.
--   
--   Since GHC 7.10, all types automatically have <a>Typeable</a> instances
--   derived. This is in contrast to previous releases where
--   <a>Typeable</a> had to be explicitly derived using the
--   <tt>DeriveDataTypeable</tt> language extension.
--   
--   Since GHC 7.8, <a>Typeable</a> is poly-kinded. The changes required
--   for this might break some old programs involving <a>Typeable</a>. More
--   details on this, including how to fix your code, can be found on the
--   <a>PolyTypeable wiki page</a>
module Data.Typeable

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Observe a type representation for the type of a value.
typeOf :: forall a. Typeable a => a -> TypeRep

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data a :~: b
[Refl] :: a :~: a
infix 4 :~:

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data a :~~: b
[HRefl] :: a :~~: a
infix 4 :~~:

-- | The type-safe cast operation
cast :: forall a b. (Typeable a, Typeable b) => a -> Maybe b

-- | Extract a witness of equality of two types
eqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~: b)

-- | Extract a witness of heterogeneous equality of two types
heqT :: forall a b. (Typeable a, Typeable b) => Maybe (a :~~: b)

-- | A flexible variation parameterised in a type constructor
gcast :: forall a b c. (Typeable a, Typeable b) => c a -> Maybe (c b)

-- | Cast over <tt>k1 -&gt; k2</tt>
gcast1 :: forall c t t' a. (Typeable t, Typeable t') => c (t a) -> Maybe (c (t' a))

-- | Cast over <tt>k1 -&gt; k2 -&gt; k3</tt>
gcast2 :: forall c t t' a b. (Typeable t, Typeable t') => c (t a b) -> Maybe (c (t' a b))

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy t
Proxy :: Proxy t

-- | A quantified type representation.
type TypeRep = SomeTypeRep

-- | Force a <a>TypeRep</a> to normal form.
rnfTypeRep :: TypeRep -> ()

-- | Show a type representation
showsTypeRep :: TypeRep -> ShowS

-- | Build a function type.
mkFunTy :: TypeRep -> TypeRep -> TypeRep

-- | Applies a type to a function type. Returns: <tt>Just u</tt> if the
--   first argument represents a function of type <tt>t -&gt; u</tt> and
--   the second argument represents a function of type <tt>t</tt>.
--   Otherwise, returns <tt>Nothing</tt>.
funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep

-- | Splits a type constructor application. Note that if the type
--   constructor is polymorphic, this will not return the kinds that were
--   used.
splitTyConApp :: TypeRep -> (TyCon, [TypeRep])

-- | Observe the argument types of a type representation
typeRepArgs :: TypeRep -> [TypeRep]

-- | Observe the type constructor of a quantified type representation.
typeRepTyCon :: TypeRep -> TyCon

-- | Takes a value of type <tt>a</tt> and returns a concrete representation
--   of that type.
typeRepFingerprint :: TypeRep -> Fingerprint
data () => TyCon
tyConPackage :: TyCon -> String
tyConModule :: TyCon -> String
tyConName :: TyCon -> String
rnfTyCon :: TyCon -> ()
tyConFingerprint :: TyCon -> Fingerprint
typeOf1 :: forall t (a :: Type). Typeable t => t a -> TypeRep
typeOf2 :: forall t (a :: Type) (b :: Type). Typeable t => t a b -> TypeRep
typeOf3 :: forall t (a :: Type) (b :: Type) (c :: Type). Typeable t => t a b c -> TypeRep
typeOf4 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type). Typeable t => t a b c d -> TypeRep
typeOf5 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type). Typeable t => t a b c d e -> TypeRep
typeOf6 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type). Typeable t => t a b c d e f -> TypeRep
typeOf7 :: forall t (a :: Type) (b :: Type) (c :: Type) (d :: Type) (e :: Type) (f :: Type) (g :: Type). Typeable t => t a b c d e f g -> TypeRep
trLiftedRep :: TypeRep ('BoxedRep 'Lifted)


-- | Exceptions and exception-handling functions.
module GHC.Exception.Type

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException
divZeroException :: SomeException
overflowException :: SomeException
ratioZeroDenomException :: SomeException
underflowException :: SomeException
instance GHC.Classes.Ord GHC.Exception.Type.ArithException
instance GHC.Classes.Eq GHC.Exception.Type.ArithException
instance GHC.Exception.Type.Exception GHC.Exception.Type.ArithException
instance GHC.Show.Show GHC.Exception.Type.ArithException
instance GHC.Show.Show GHC.Exception.Type.SomeException
instance GHC.Exception.Type.Exception GHC.Base.Void
instance GHC.Exception.Type.Exception GHC.Exception.Type.SomeException


-- | Exceptions and exception-handling functions.
module GHC.Exception

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall
errorCallException :: String -> SomeException
errorCallWithCallStackException :: String -> CallStack -> SomeException

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String
prettyCallStackLines :: CallStack -> [String]
showCCSStack :: [String] -> [String]

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String
instance GHC.Classes.Ord GHC.Exception.ErrorCall
instance GHC.Classes.Eq GHC.Exception.ErrorCall
instance GHC.Exception.Type.Exception GHC.Exception.ErrorCall
instance GHC.Show.Show GHC.Exception.ErrorCall


-- | Definitions for the <a>IO</a> monad and its friends.
module GHC.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype () => IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a
unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
liftIO :: IO a -> State# RealWorld -> STret RealWorld a
mplusIO :: IO a -> IO a -> IO a

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
--   
--   WARNING: If you're looking for "a way to get a <a>String</a> from an
--   'IO String'", then <a>unsafePerformIO</a> is not the way to go. Learn
--   about do-notation and the <tt>&lt;-</tt> syntax element before you
--   proceed.
unsafePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeDupableInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To ensure that the computation is performed
--   only once, use <a>unsafeInterleaveIO</a> instead.
unsafeDupableInterleaveIO :: IO a -> IO a

-- | Ensures that the suspensions under evaluation by the current thread
--   are unique; that is, the current thread is not evaluating anything
--   that is also under evaluation by another thread that has also executed
--   <a>noDuplicate</a>.
--   
--   This operation is used in the definition of <a>unsafePerformIO</a> to
--   prevent the IO action from being executed multiple times, which is
--   usually undesirable.
noDuplicate :: IO ()

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a

-- | Convert an <a>IO</a> action into an <a>ST</a> action. The type of the
--   result is constrained to use a <a>RealWorld</a> state thread, and
--   therefore the result cannot be passed to <a>runST</a>.
ioToST :: IO a -> ST RealWorld a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Catch an exception in the <a>IO</a> monad.
--   
--   Note that this function is <i>strict</i> in the action. That is,
--   <tt>catchException undefined b == _|_</tt>. See for details.
catchException :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Catch any <a>Exception</a> type in the <a>IO</a> monad.
--   
--   Note that this function is <i>strict</i> in the action. That is,
--   <tt>catchAny undefined b == _|_</tt>. See for details.
catchAny :: IO a -> (forall e. Exception e => e -> IO a) -> IO a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState
unsafeUnmask :: IO a -> IO a

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a
onException :: IO a -> IO b -> IO a
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
finally :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a
mkUserError :: [Char] -> SomeException
instance GHC.Show.Show GHC.IO.MaskingState
instance GHC.Classes.Eq GHC.IO.MaskingState


-- | The IORef type
module GHC.IORef

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
newtype IORef a
IORef :: STRef RealWorld a -> IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>.
--   
--   Beware that the CPU executing a thread can reorder reads or writes to
--   independent locations. See <a>Data.IORef#memmodel</a> for more
--   details.
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>.
--   
--   This function does not create a memory barrier and can be reordered
--   with other independent reads and writes within a thread, which may
--   cause issues for multithreaded execution. In these cases, consider
--   using <a>atomicWriteIORef</a> instead. See <a>Data.IORef#memmodel</a>
--   for more details.
writeIORef :: IORef a -> a -> IO ()

-- | Atomically apply a function to the contents of an <a>IORef</a>,
--   installing its first component in the <a>IORef</a> and returning the
--   old contents and the result of applying the function. The result of
--   the function application (the pair) is not forced. As a result, this
--   can lead to memory leaks. It is generally better to use
--   <a>atomicModifyIORef2</a>.
atomicModifyIORef2Lazy :: IORef a -> (a -> (a, b)) -> IO (a, (a, b))

-- | Atomically apply a function to the contents of an <a>IORef</a>,
--   installing its first component in the <a>IORef</a> and returning the
--   old contents and the result of applying the function. The result of
--   the function application (the pair) is forced, but neither of its
--   components is.
atomicModifyIORef2 :: IORef a -> (a -> (a, b)) -> IO (a, (a, b))

-- | Atomically apply a function to the contents of an <a>IORef</a> and
--   return the old and new values. The result of the function is not
--   forced. As this can lead to a memory leak, it is usually better to use
--   <a>atomicModifyIORef'_</a>.
atomicModifyIORefLazy_ :: IORef a -> (a -> a) -> IO (a, a)

-- | Atomically apply a function to the contents of an <a>IORef</a> and
--   return the old and new values. The result of the function is forced.
atomicModifyIORef'_ :: IORef a -> (a -> a) -> IO (a, a)

-- | A version of <a>atomicModifyIORef</a> that forces the (pair) result of
--   the function.
atomicModifyIORefP :: IORef a -> (a -> (a, b)) -> IO b

-- | Atomically replace the contents of an <a>IORef</a>, returning the old
--   contents.
atomicSwapIORef :: IORef a -> a -> IO a

-- | Strict version of <a>atomicModifyIORef</a>. This forces both the value
--   stored in the <a>IORef</a> and the value returned. The new value is
--   installed in the <a>IORef</a> before the returned value is forced. So
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (x+1, undefined))
--   </pre>
--   
--   will increment the <a>IORef</a> and then throw an exception in the
--   calling thread.
--   
--   This function imposes a memory barrier, preventing reordering; see
--   <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b
instance GHC.Classes.Eq (GHC.IORef.IORef a)


-- | GHC's implementation of the <a>ForeignPtr</a> data type.
module GHC.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a
ForeignPtr :: Addr# -> ForeignPtrContents -> ForeignPtr a

-- | Controls finalization of a <a>ForeignPtr</a>, that is, what should
--   happen if the <a>ForeignPtr</a> becomes unreachable. Visually, these
--   data constructors are appropriate in these scenarios:
--   
--   <pre>
--                             Memory backing pointer is
--                              GC-Managed   Unmanaged
--   Finalizer functions are: +------------+-----------------+
--                   Allowed  | MallocPtr  | PlainForeignPtr |
--                            +------------+-----------------+
--                Prohibited  | PlainPtr   | FinalPtr        |
--                            +------------+-----------------+
--   </pre>
data ForeignPtrContents

-- | The pointer refers to unmanaged memory that was allocated by a foreign
--   function (typically using <tt>malloc</tt>). The finalizer frequently
--   calls the C function <tt>free</tt> or some variant of it.
PlainForeignPtr :: !IORef Finalizers -> ForeignPtrContents

-- | The pointer refers to unmanaged memory that should not be freed when
--   the <a>ForeignPtr</a> becomes unreachable. Functions that add
--   finalizers to a <a>ForeignPtr</a> throw exceptions when the
--   <a>ForeignPtr</a> is backed by <a>PlainPtr</a>Most commonly, this is
--   used with <tt>Addr#</tt> literals. See Note [Why FinalPtr].
FinalPtr :: ForeignPtrContents

-- | The pointer refers to a byte array. The <a>MutableByteArray#</a> field
--   means that the <a>MutableByteArray#</a> is reachable (by GC) whenever
--   the <a>ForeignPtr</a> is reachable. When the <a>ForeignPtr</a> becomes
--   unreachable, the runtime's normal GC recovers the memory backing it.
--   Here, the finalizer function intended to be used to <tt>free()</tt>
--   any ancillary *unmanaged* memory pointed to by the
--   <a>MutableByteArray#</a>. See the <tt>zlib</tt> library for an example
--   of this use.
--   
--   <ol>
--   <li>Invariant: The <a>Addr#</a> in the parent <a>ForeignPtr</a> is an
--   interior pointer into this <a>MutableByteArray#</a>.</li>
--   <li>Invariant: The <a>MutableByteArray#</a> is pinned, so the
--   <a>Addr#</a> does not get invalidated by the GC moving the byte
--   array.</li>
--   <li>Invariant: A <a>MutableByteArray#</a> must not be associated with
--   more than one set of finalizers. For example, this is sound:</li>
--   </ol>
--   
--   <pre>
--   incrGood :: ForeignPtr Word8 -&gt; ForeignPtr Word8
--   incrGood (ForeignPtr p (MallocPtr m f)) = ForeignPtr (plusPtr p 1) (MallocPtr m f)
--   </pre>
--   
--   But this is unsound:
--   
--   <pre>
--   incrBad :: ForeignPtr Word8 -&gt; IO (ForeignPtr Word8)
--   incrBad (ForeignPtr p (MallocPtr m _)) = do
--     f &lt;- newIORef NoFinalizers
--     pure (ForeignPtr p (MallocPtr m f))
--   </pre>
MallocPtr :: MutableByteArray# RealWorld -> !IORef Finalizers -> ForeignPtrContents

-- | The pointer refers to a byte array. Finalization is not supported.
--   This optimizes <tt>MallocPtr</tt> by avoiding the allocation of a
--   <tt>MutVar#</tt> when it is known that no one will add finalizers to
--   the <tt>ForeignPtr</tt>. Functions that add finalizers to a
--   <a>ForeignPtr</a> throw exceptions when the <a>ForeignPtr</a> is
--   backed by <a>PlainPtr</a>. The invariants that apply to
--   <a>MallocPtr</a> apply to <a>PlainPtr</a> as well.
PlainPtr :: MutableByteArray# RealWorld -> ForeignPtrContents

-- | Functions called when a <a>ForeignPtr</a> is finalized. Note that C
--   finalizers and Haskell finalizers cannot be mixed.
data Finalizers

-- | No finalizer. If there is no intent to add a finalizer at any point in
--   the future, consider <a>FinalPtr</a> or <a>PlainPtr</a> instead since
--   these perform fewer allocations.
NoFinalizers :: Finalizers

-- | Finalizers are all C functions.
CFinalizers :: Weak# () -> Finalizers

-- | Finalizers are all Haskell functions.
HaskellFinalizers :: [IO ()] -> Finalizers

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   GHC notes: <a>mallocPlainForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr
--   created with mallocPlainForeignPtr carries no finalizers. It is not
--   possible to add a finalizer to a ForeignPtr created with
--   mallocPlainForeignPtr. This is useful for ForeignPtrs that will live
--   only inside Haskell (such as those created for packed strings).
--   Attempts to add a finalizer to a ForeignPtr created this way, or to
--   finalize such a pointer, will throw an exception.
mallocPlainForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrBytes</a>, except that
--   the internally an optimised ForeignPtr representation with no
--   finalizer is used. Attempts to add a finalizer will cause an exception
--   to be thrown.
mallocPlainForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrBytes</a>, except that
--   the size and alignment of the memory required is given explicitly as
--   numbers of bytes.
mallocForeignPtrAlignedBytes :: Int -> Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtrAlignedBytes</a>,
--   except that the internally an optimised ForeignPtr representation with
--   no finalizer is used. Attempts to add a finalizer will cause an
--   exception to be thrown.
mallocPlainForeignPtrAlignedBytes :: Int -> Int -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference.
--   
--   When finalization is triggered by GC, the storage manager will start
--   the finalizer, in a separate thread, some time after the last
--   reference to the <tt>ForeignPtr</tt> is dropped. There is <b>no
--   guarantee of promptness</b>, and in fact there is no guarantee that
--   the finalizer will eventually run at all for GC-triggered
--   finalization.
--   
--   When finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   Note that references from a finalizer do not necessarily prevent
--   another object from being finalized. If A's finalizer refers to B
--   (perhaps using <a>touchForeignPtr</a>, then the only guarantee is that
--   B's finalizer will never be started before A's. If both A and B are
--   unreachable, then both finalizers will start together. See
--   <a>touchForeignPtr</a> for more on finalizer ordering.
newConcForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This function adds a finalizer to the given <tt>ForeignPtr</tt>. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
--   
--   This is a variant of <tt>addForeignPtrFinalizer</tt>, where the
--   finalizer is an arbitrary <tt>IO</tt> action. When finalization is
--   triggered by GC, the finalizer will run in a new thread. When
--   finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   NB. Be very careful with these finalizers. One common trap is that if
--   a finalizer references another finalized value, it does not prevent
--   that value from being finalized. In particular, <a>Handle</a>s are
--   finalized objects, so a finalizer should not refer to a <a>Handle</a>
--   (including <a>stdout</a>, <a>stdin</a>, or <a>stderr</a>).
addForeignPtrConcFinalizer :: ForeignPtr a -> IO () -> IO ()

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | This is similar to <a>withForeignPtr</a> but comes with an important
--   caveat: the user must guarantee that the continuation does not diverge
--   (e.g. loop or throw an exception). In exchange for this loss of
--   generality, this function offers the ability of GHC to optimise more
--   aggressively.
--   
--   Specifically, applications of the form: <tt> unsafeWithForeignPtr fptr
--   (<a>forever</a> something) </tt>
--   
--   See GHC issue #17760 for more information about the unsoundness
--   behavior that this function can result in.
unsafeWithForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()
instance GHC.Classes.Eq (GHC.ForeignPtr.ForeignPtr a)
instance GHC.Classes.Ord (GHC.ForeignPtr.ForeignPtr a)
instance GHC.Show.Show (GHC.ForeignPtr.ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Unsafe API Only.
module Foreign.ForeignPtr.Unsafe

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.ForeignPtr
--   instead</i>
module Foreign.ForeignPtr.Safe

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | The <a>ForeignPtr</a> type and operations. This module is part of the
--   Foreign Function Interface (FFI) and will usually be imported via the
--   <a>Foreign</a> module.
--   
--   For non-portable support of Haskell finalizers, see the
--   <a>Foreign.Concurrent</a> module.
module Foreign.ForeignPtr

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr (Ptr a -> IO ())
type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | Buffers used in the IO system
module GHC.IO.Buffer

-- | A mutable array of bytes that can be passed to foreign functions.
--   
--   The buffer is represented by a record, where the record contains the
--   raw buffer and the start/end points of the filled portion. The buffer
--   contents itself is mutable, but the rest of the record is immutable.
--   This is a slightly odd mix, but it turns out to be quite practical: by
--   making all the buffer metadata immutable, we can have operations on
--   buffer metadata outside of the IO monad.
--   
--   The "live" elements of the buffer are those between the <a>bufL</a>
--   and <a>bufR</a> offsets. In an empty buffer, <a>bufL</a> is equal to
--   <a>bufR</a>, but they might not be zero: for example, the buffer might
--   correspond to a memory-mapped file and in which case <a>bufL</a> will
--   point to the next location to be written, which is not necessarily the
--   beginning of the file.
--   
--   On Posix systems the I/O manager has an implicit reliance on doing a
--   file read moving the file pointer. However on Windows async operations
--   the kernel object representing a file does not use the file pointer
--   offset. Logically this makes sense since operations can be performed
--   in any arbitrary order. OVERLAPPED operations don't respect the file
--   pointer offset as their intention is to support arbitrary async reads
--   to anywhere at a much lower level. As such we should explicitly keep
--   track of the file offsets of the target in the buffer. Any operation
--   to seek should also update this entry.
--   
--   In order to keep us sane we try to uphold the invariant that any
--   function being passed a Handle is responsible for updating the handles
--   offset unless other behaviour is documented.
data Buffer e
Buffer :: !RawBuffer e -> BufferState -> !Int -> !Word64 -> !Int -> !Int -> Buffer e
[bufRaw] :: Buffer e -> !RawBuffer e
[bufState] :: Buffer e -> BufferState
[bufSize] :: Buffer e -> !Int
[bufOffset] :: Buffer e -> !Word64
[bufL] :: Buffer e -> !Int
[bufR] :: Buffer e -> !Int
data BufferState
ReadBuffer :: BufferState
WriteBuffer :: BufferState
type CharBuffer = Buffer Char
type CharBufElem = Char
newByteBuffer :: Int -> BufferState -> IO (Buffer Word8)
newCharBuffer :: Int -> BufferState -> IO CharBuffer
newBuffer :: Int -> Int -> BufferState -> IO (Buffer e)
emptyBuffer :: RawBuffer e -> Int -> BufferState -> Buffer e
bufferRemove :: Int -> Buffer e -> Buffer e
bufferAdd :: Int -> Buffer e -> Buffer e

-- | slides the contents of the buffer to the beginning
slideContents :: Buffer Word8 -> IO (Buffer Word8)
bufferAdjustL :: Int -> Buffer e -> Buffer e
bufferAddOffset :: Int -> Buffer e -> Buffer e
bufferAdjustOffset :: Word64 -> Buffer e -> Buffer e
isEmptyBuffer :: Buffer e -> Bool
isFullBuffer :: Buffer e -> Bool
isFullCharBuffer :: Buffer e -> Bool
isWriteBuffer :: Buffer e -> Bool
bufferElems :: Buffer e -> Int
bufferAvailable :: Buffer e -> Int
bufferOffset :: Buffer e -> Word64
summaryBuffer :: Buffer a -> String
withBuffer :: Buffer e -> (Ptr e -> IO a) -> IO a
withRawBuffer :: RawBuffer e -> (Ptr e -> IO a) -> IO a
checkBuffer :: Buffer a -> IO ()
type RawBuffer e = ForeignPtr e
readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
type RawCharBuffer = RawBuffer CharBufElem
peekCharBuf :: RawCharBuffer -> Int -> IO Char
readCharBuf :: RawCharBuffer -> Int -> IO (Char, Int)
writeCharBuf :: RawCharBuffer -> Int -> Char -> IO Int
readCharBufPtr :: Ptr CharBufElem -> Int -> IO (Char, Int)
writeCharBufPtr :: Ptr CharBufElem -> Int -> Char -> IO Int
charSize :: Int
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState


-- | Types for text encoding/decoding
module GHC.IO.Encoding.Types
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <a>mkTextEncoding</a> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state
type CodeBuffer from to = Buffer from -> Buffer to -> IO (CodingProgress, Buffer from, Buffer to)
type EncodeBuffer = CodeBuffer Char Word8
type DecodeBuffer = CodeBuffer Word8 Char

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding


-- | The IOArray type
module GHC.IOArray

-- | An <a>IOArray</a> is a mutable, boxed, non-strict array in the
--   <a>IO</a> monad. The type arguments are as follows:
--   
--   <ul>
--   <li><tt>i</tt>: the index type of the array (should be an instance of
--   <a>Ix</a>)</li>
--   <li><tt>e</tt>: the element type of the array.</li>
--   </ul>
newtype IOArray i e
IOArray :: STArray RealWorld i e -> IOArray i e

-- | Build a new <a>IOArray</a>
newIOArray :: Ix i => (i, i) -> e -> IO (IOArray i e)

-- | Read a value from an <a>IOArray</a>
unsafeReadIOArray :: IOArray i e -> Int -> IO e

-- | Write a new value into an <a>IOArray</a>
unsafeWriteIOArray :: IOArray i e -> Int -> e -> IO ()

-- | Read a value from an <a>IOArray</a>
readIOArray :: Ix i => IOArray i e -> i -> IO e

-- | Write a new value into an <a>IOArray</a>
writeIOArray :: Ix i => IOArray i e -> i -> e -> IO ()
boundsIOArray :: IOArray i e -> (i, i)
instance GHC.Classes.Eq (GHC.IOArray.IOArray i e)


-- | Type classes for I/O providers.
module GHC.IO.Device

-- | A low-level I/O provider where the data is bytes in memory. The Word64
--   offsets currently have no effect on POSIX system or consoles where the
--   implicit behaviour of the C runtime is assume to move the file pointer
--   on every read/write without needing an explicit seek.
class RawIO a

-- | Read up to the specified number of bytes starting from a specified
--   offset, returning the number of bytes actually read. This function
--   should only block if there is no data available. If there is not
--   enough data available, then the function should just return the
--   available data. A return value of zero indicates that the end of the
--   data stream (e.g. end of file) has been reached.
read :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO Int

-- | Read up to the specified number of bytes starting from a specified
--   offset, returning the number of bytes actually read, or <a>Nothing</a>
--   if the end of the stream has been reached.
readNonBlocking :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO (Maybe Int)

-- | Write the specified number of bytes starting at a given offset.
write :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO ()

-- | Write up to the specified number of bytes without blocking starting at
--   a given offset. Returns the actual number of bytes written.
writeNonBlocking :: RawIO a => a -> Ptr Word8 -> Word64 -> Int -> IO Int

-- | I/O operations required for implementing a <a>Handle</a>.
class IODevice a

-- | <tt>ready dev write msecs</tt> returns <a>True</a> if the device has
--   data to read (if <tt>write</tt> is <a>False</a>) or space to write new
--   data (if <tt>write</tt> is <a>True</a>). <tt>msecs</tt> specifies how
--   long to wait, in milliseconds.
ready :: IODevice a => a -> Bool -> Int -> IO Bool

-- | closes the device. Further operations on the device should produce
--   exceptions.
close :: IODevice a => a -> IO ()

-- | returns <a>True</a> if the device is a terminal or console.
isTerminal :: IODevice a => a -> IO Bool

-- | returns <a>True</a> if the device supports <a>seek</a> operations.
isSeekable :: IODevice a => a -> IO Bool

-- | seek to the specified position in the data.
seek :: IODevice a => a -> SeekMode -> Integer -> IO Integer

-- | return the current position in the data.
tell :: IODevice a => a -> IO Integer

-- | return the size of the data.
getSize :: IODevice a => a -> IO Integer

-- | change the size of the data.
setSize :: IODevice a => a -> Integer -> IO ()

-- | for terminal devices, changes whether characters are echoed on the
--   device.
setEcho :: IODevice a => a -> Bool -> IO ()

-- | returns the current echoing status.
getEcho :: IODevice a => a -> IO Bool

-- | some devices (e.g. terminals) support a "raw" mode where characters
--   entered are immediately made available to the program. If available,
--   this operations enables raw mode.
setRaw :: IODevice a => a -> Bool -> IO ()

-- | returns the <a>IODeviceType</a> corresponding to this device.
devType :: IODevice a => a -> IO IODeviceType

-- | duplicates the device, if possible. The new device is expected to
--   share a file pointer with the original device (like Unix
--   <tt>dup</tt>).
dup :: IODevice a => a -> IO a

-- | <tt>dup2 source target</tt> replaces the target device with the source
--   device. The target device is closed first, if necessary, and then it
--   is made into a duplicate of the first device (like Unix
--   <tt>dup2</tt>).
dup2 :: IODevice a => a -> a -> IO a

-- | Type of a device that can be used to back a <a>Handle</a> (see also
--   <a>mkFileHandle</a>). The standard libraries provide creation of
--   <a>Handle</a>s via Posix file operations with file descriptors (see
--   <a>mkHandleFromFD</a>) with FD being the underlying <a>IODevice</a>
--   instance.
--   
--   Users may provide custom instances of <a>IODevice</a> which are
--   expected to conform the following rules:
data IODeviceType

-- | The standard libraries do not have direct support for this device
--   type, but a user implementation is expected to provide a list of file
--   names in the directory, in any order, separated by <tt>'\0'</tt>
--   characters, excluding the <tt>"."</tt> and <tt>".."</tt> names. See
--   also <a>getDirectoryContents</a>. Seek operations are not supported on
--   directories (other than to the zero position).
Directory :: IODeviceType

-- | A duplex communications channel (results in creation of a duplex
--   <a>Handle</a>). The standard libraries use this device type when
--   creating <a>Handle</a>s for open sockets.
Stream :: IODeviceType

-- | A file that may be read or written, and also may be seekable.
RegularFile :: IODeviceType

-- | A "raw" (disk) device which supports block binary read and write
--   operations and may be seekable only to positions of certain
--   granularity (block- aligned).
RawDevice :: IODeviceType

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType
instance GHC.Show.Show GHC.IO.Device.SeekMode
instance GHC.Read.Read GHC.IO.Device.SeekMode
instance GHC.Enum.Enum GHC.IO.Device.SeekMode
instance GHC.Ix.Ix GHC.IO.Device.SeekMode
instance GHC.Classes.Ord GHC.IO.Device.SeekMode
instance GHC.Classes.Eq GHC.IO.Device.SeekMode


-- | Class of buffered IO devices
module GHC.IO.BufferedIO

-- | The purpose of <a>BufferedIO</a> is to provide a common interface for
--   I/O devices that can read and write data through a buffer. Devices
--   that implement <a>BufferedIO</a> include ordinary files, memory-mapped
--   files, and bytestrings. The underlying device implementing a
--   <a>Handle</a> must provide <a>BufferedIO</a>.
class BufferedIO dev

-- | allocate a new buffer. The size of the buffer is at the discretion of
--   the device; e.g. for a memory-mapped file the buffer will probably
--   cover the entire file.
newBuffer :: BufferedIO dev => dev -> BufferState -> IO (Buffer Word8)

-- | reads bytes into the buffer, blocking if there are no bytes available.
--   Returns the number of bytes read (zero indicates end-of-file), and the
--   new buffer.
fillReadBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)

-- | reads bytes into the buffer without blocking. Returns the number of
--   bytes read (Nothing indicates end-of-file), and the new buffer.
fillReadBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)

-- | Prepares an empty write buffer. This lets the device decide how to set
--   up a write buffer: the buffer may need to point to a specific location
--   in memory, for example. This is typically used by the client when
--   switching from reading to writing on a buffered read/write device.
--   
--   There is no corresponding operation for read buffers, because before
--   reading the client will always call <a>fillReadBuffer</a>.
emptyWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush all the data from the supplied write buffer out to the device.
--   The returned buffer should be empty, and ready for writing.
flushWriteBuffer :: BufferedIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)

-- | Flush data from the supplied write buffer out to the device without
--   blocking. Returns the number of bytes written and the remaining
--   buffer.
flushWriteBuffer0 :: BufferedIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)
readBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)
writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
writeBufNonBlocking :: RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)


-- | Basic types for the implementation of IO Handles.
module GHC.IO.Handle.Types

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle
FileHandle :: FilePath -> !MVar Handle__ -> Handle
DuplexHandle :: FilePath -> !MVar Handle__ -> !MVar Handle__ -> Handle
data Handle__
Handle__ :: !dev -> HandleType -> !IORef (Buffer Word8) -> BufferMode -> !IORef (dec_state, Buffer Word8) -> !IORef (Buffer CharBufElem) -> !IORef (BufferList CharBufElem) -> Maybe (TextEncoder enc_state) -> Maybe (TextDecoder dec_state) -> Maybe TextEncoding -> Newline -> Newline -> Maybe (MVar Handle__) -> Handle__
[haDevice] :: Handle__ -> !dev
[haType] :: Handle__ -> HandleType
[haByteBuffer] :: Handle__ -> !IORef (Buffer Word8)
[haBufferMode] :: Handle__ -> BufferMode

-- | The byte buffer just before we did our last batch of decoding.
[haLastDecode] :: Handle__ -> !IORef (dec_state, Buffer Word8)
[haCharBuffer] :: Handle__ -> !IORef (Buffer CharBufElem)
[haBuffers] :: Handle__ -> !IORef (BufferList CharBufElem)
[haEncoder] :: Handle__ -> Maybe (TextEncoder enc_state)
[haDecoder] :: Handle__ -> Maybe (TextDecoder dec_state)
[haCodec] :: Handle__ -> Maybe TextEncoding
[haInputNL] :: Handle__ -> Newline
[haOutputNL] :: Handle__ -> Newline
[haOtherSide] :: Handle__ -> Maybe (MVar Handle__)
showHandle :: FilePath -> String -> String
checkHandleInvariants :: Handle__ -> IO ()
data BufferList e
BufferListNil :: BufferList e
BufferListCons :: RawBuffer e -> BufferList e -> BufferList e
data HandleType
ClosedHandle :: HandleType
SemiClosedHandle :: HandleType
ReadHandle :: HandleType
WriteHandle :: HandleType
AppendHandle :: HandleType
ReadWriteHandle :: HandleType
isReadableHandleType :: HandleType -> Bool
isWritableHandleType :: HandleType -> Bool
isReadWriteHandleType :: HandleType -> Bool
isAppendHandleType :: HandleType -> Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode
instance GHC.Show.Show GHC.IO.Handle.Types.BufferMode
instance GHC.Read.Read GHC.IO.Handle.Types.BufferMode
instance GHC.Classes.Ord GHC.IO.Handle.Types.BufferMode
instance GHC.Classes.Eq GHC.IO.Handle.Types.BufferMode
instance GHC.Show.Show GHC.IO.Handle.Types.Newline
instance GHC.Read.Read GHC.IO.Handle.Types.Newline
instance GHC.Classes.Ord GHC.IO.Handle.Types.Newline
instance GHC.Classes.Eq GHC.IO.Handle.Types.Newline
instance GHC.Show.Show GHC.IO.Handle.Types.NewlineMode
instance GHC.Read.Read GHC.IO.Handle.Types.NewlineMode
instance GHC.Classes.Ord GHC.IO.Handle.Types.NewlineMode
instance GHC.Classes.Eq GHC.IO.Handle.Types.NewlineMode
instance GHC.Classes.Eq GHC.IO.Handle.Types.Handle
instance GHC.Show.Show GHC.IO.Handle.Types.Handle
instance GHC.Show.Show GHC.IO.Handle.Types.HandleType


-- | IO-related Exception types and functions
module GHC.IO.Exception

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar
blockedIndefinitelyOnMVar :: SomeException

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM
blockedIndefinitelyOnSTM :: SomeException

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded
allocationLimitExceeded :: SomeException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed
cannotCompactFunction :: SomeException
cannotCompactPinned :: SomeException
cannotCompactMutable :: SomeException

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException
stackOverflow :: SomeException
heapOverflow :: SomeException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | The exception thrown when an infinite cycle is detected in
--   <a>fixIO</a>.
data FixIOException
FixIOException :: FixIOException
ioException :: IOException -> IO a

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException
IOError :: Maybe Handle -> IOErrorType -> String -> String -> Maybe CInt -> Maybe FilePath -> IOException
[ioe_handle] :: IOException -> Maybe Handle
[ioe_type] :: IOException -> IOErrorType
[ioe_location] :: IOException -> String
[ioe_description] :: IOException -> String
[ioe_errno] :: IOException -> Maybe CInt
[ioe_filename] :: IOException -> Maybe FilePath

-- | An abstract type that contains a value for each variant of
--   <a>IOException</a>.
data IOErrorType
AlreadyExists :: IOErrorType
NoSuchThing :: IOErrorType
ResourceBusy :: IOErrorType
ResourceExhausted :: IOErrorType
EOF :: IOErrorType
IllegalOperation :: IOErrorType
PermissionDenied :: IOErrorType
UserError :: IOErrorType
UnsatisfiedConstraints :: IOErrorType
SystemError :: IOErrorType
ProtocolError :: IOErrorType
OtherError :: IOErrorType
InvalidArgument :: IOErrorType
InappropriateType :: IOErrorType
HardwareFault :: IOErrorType
UnsupportedOperation :: IOErrorType
TimeExpired :: IOErrorType
ResourceVanished :: IOErrorType
Interrupted :: IOErrorType

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError
assertError :: (?callStack :: CallStack) => Bool -> a -> a
unsupportedOperation :: IOError
untangle :: Addr# -> String -> String
instance GHC.Classes.Ord GHC.IO.Exception.AsyncException
instance GHC.Classes.Eq GHC.IO.Exception.AsyncException
instance GHC.Classes.Ord GHC.IO.Exception.ArrayException
instance GHC.Classes.Eq GHC.IO.Exception.ArrayException
instance GHC.Generics.Generic GHC.IO.Exception.ExitCode
instance GHC.Show.Show GHC.IO.Exception.ExitCode
instance GHC.Read.Read GHC.IO.Exception.ExitCode
instance GHC.Classes.Ord GHC.IO.Exception.ExitCode
instance GHC.Classes.Eq GHC.IO.Exception.ExitCode
instance GHC.Exception.Type.Exception GHC.IO.Exception.IOException
instance GHC.Classes.Eq GHC.IO.Exception.IOException
instance GHC.Show.Show GHC.IO.Exception.IOException
instance GHC.Classes.Eq GHC.IO.Exception.IOErrorType
instance GHC.Show.Show GHC.IO.Exception.IOErrorType
instance GHC.Exception.Type.Exception GHC.IO.Exception.ExitCode
instance GHC.Exception.Type.Exception GHC.IO.Exception.FixIOException
instance GHC.Show.Show GHC.IO.Exception.FixIOException
instance GHC.Exception.Type.Exception GHC.IO.Exception.ArrayException
instance GHC.Show.Show GHC.IO.Exception.ArrayException
instance GHC.Exception.Type.Exception GHC.IO.Exception.AsyncException
instance GHC.Show.Show GHC.IO.Exception.AsyncException
instance GHC.Show.Show GHC.IO.Exception.SomeAsyncException
instance GHC.Exception.Type.Exception GHC.IO.Exception.SomeAsyncException
instance GHC.Exception.Type.Exception GHC.IO.Exception.AssertionFailed
instance GHC.Show.Show GHC.IO.Exception.AssertionFailed
instance GHC.Exception.Type.Exception GHC.IO.Exception.CompactionFailed
instance GHC.Show.Show GHC.IO.Exception.CompactionFailed
instance GHC.Exception.Type.Exception GHC.IO.Exception.AllocationLimitExceeded
instance GHC.Show.Show GHC.IO.Exception.AllocationLimitExceeded
instance GHC.Exception.Type.Exception GHC.IO.Exception.Deadlock
instance GHC.Show.Show GHC.IO.Exception.Deadlock
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnMVar


-- | Types for specifying how text encoding/decoding fails
module GHC.IO.Encoding.Failure

-- | The <a>CodingFailureMode</a> is used to construct
--   <a>TextEncoding</a>s, and specifies how they handle illegal sequences.
data CodingFailureMode

-- | Throw an error when an illegal sequence is encountered
ErrorOnCodingFailure :: CodingFailureMode

-- | Attempt to ignore and recover if an illegal sequence is encountered
IgnoreCodingFailure :: CodingFailureMode

-- | Replace with the closest visual match upon an illegal sequence
TransliterateCodingFailure :: CodingFailureMode

-- | Use the private-use escape mechanism to attempt to allow illegal
--   sequences to be roundtripped.
RoundtripFailure :: CodingFailureMode
codingFailureModeSuffix :: CodingFailureMode -> String

-- | Some characters are actually "surrogate" codepoints defined for use in
--   UTF-16. We need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because they
--   won't give valid Unicode.
--   
--   We may also need to signal an invalid character if we detect them when
--   encoding a sequence of <a>Char</a>s into <a>Word8</a>s because the
--   <a>RoundtripFailure</a> mode creates these to round-trip bytes through
--   our internal UTF-16 encoding.
isSurrogate :: Char -> Bool
recoverDecode :: CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)
recoverEncode :: CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode


-- | UTF-8 Codec for the IO library
--   
--   This is one of several UTF-8 implementations provided by GHC; see Note
--   [GHC's many UTF-8 implementations] in <a>GHC.Encoding.UTF8</a> for an
--   overview.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF8
utf8 :: TextEncoding

mkUTF8 :: CodingFailureMode -> TextEncoding
utf8_bom :: TextEncoding
mkUTF8_bom :: CodingFailureMode -> TextEncoding


-- | UTF-32 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF32
utf32 :: TextEncoding

mkUTF32 :: CodingFailureMode -> TextEncoding
utf32_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf32_encode :: IORef Bool -> EncodeBuffer
utf32be :: TextEncoding

mkUTF32be :: CodingFailureMode -> TextEncoding
utf32be_decode :: DecodeBuffer
utf32be_encode :: EncodeBuffer
utf32le :: TextEncoding

mkUTF32le :: CodingFailureMode -> TextEncoding
utf32le_decode :: DecodeBuffer
utf32le_encode :: EncodeBuffer


-- | UTF-16 Codecs for the IO library
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.UTF16
utf16 :: TextEncoding

mkUTF16 :: CodingFailureMode -> TextEncoding
utf16_decode :: IORef (Maybe DecodeBuffer) -> DecodeBuffer
utf16_encode :: IORef Bool -> EncodeBuffer
utf16be :: TextEncoding

mkUTF16be :: CodingFailureMode -> TextEncoding
utf16be_decode :: DecodeBuffer
utf16be_encode :: EncodeBuffer
utf16le :: TextEncoding

mkUTF16le :: CodingFailureMode -> TextEncoding
utf16le_decode :: DecodeBuffer
utf16le_encode :: EncodeBuffer


-- | Single-byte encodings that map directly to Unicode code points.
--   
--   Portions Copyright : (c) Tom Harper 2008-2009, (c) Bryan O'Sullivan
--   2009, (c) Duncan Coutts 2009
module GHC.IO.Encoding.Latin1
latin1 :: TextEncoding

mkLatin1 :: CodingFailureMode -> TextEncoding
latin1_checked :: TextEncoding

mkLatin1_checked :: CodingFailureMode -> TextEncoding

ascii :: TextEncoding

mkAscii :: CodingFailureMode -> TextEncoding
latin1_decode :: DecodeBuffer
ascii_decode :: DecodeBuffer
latin1_encode :: EncodeBuffer
latin1_checked_encode :: EncodeBuffer
ascii_encode :: EncodeBuffer


-- | Routines for testing return values and raising a <a>userError</a>
--   exception in case of values indicating an error state.
module Foreign.Marshal.Error

-- | Execute an <a>IO</a> action, throwing a <a>userError</a> if the
--   predicate yields <a>True</a> when applied to the result returned by
--   the <a>IO</a> action. If no exception is raised, return the result of
--   the computation.
throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a

-- | Like <a>throwIf</a>, but discarding the result
throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()

-- | Guards against negative result values
throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a

-- | Like <a>throwIfNeg</a>, but discarding the result
throwIfNeg_ :: (Ord a, Num a) => (a -> String) -> IO a -> IO ()

-- | Guards against null pointers
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Discard the return value of an <a>IO</a> action

-- | <i>Deprecated: use <a>void</a> instead</i>
void :: IO a -> IO ()


-- | The module <a>Foreign.Marshal.Alloc</a> provides operations to
--   allocate and deallocate blocks of raw memory (i.e., unstructured
--   chunks of memory outside of the area maintained by the Haskell storage
--   manager). These memory blocks are commonly used to pass compound data
--   structures to foreign functions or to provide space in which compound
--   result values are obtained from foreign functions.
--   
--   If any of the allocation functions fails, an exception is thrown. In
--   some cases, memory exhaustion may mean the process is terminated. If
--   <a>free</a> or <a>reallocBytes</a> is applied to a memory area that
--   has been allocated with <a>alloca</a> or <a>allocaBytes</a>, the
--   behaviour is undefined. Any further access to memory areas allocated
--   with <a>alloca</a> or <a>allocaBytes</a>, after the computation that
--   was passed to the allocation function has terminated, leads to
--   undefined behaviour. Any further access to the memory area referenced
--   by a pointer passed to <a>realloc</a>, <a>reallocBytes</a>, or
--   <a>free</a> entails undefined behaviour.
--   
--   All storage allocated by functions that allocate based on a <i>size in
--   bytes</i> must be sufficiently aligned for any of the basic foreign
--   types that fits into the newly allocated storage. All storage
--   allocated by functions that allocate based on a specific type must be
--   sufficiently aligned for that type. Array allocation routines need to
--   obey the same alignment constraints for each array element.
--   
--   The underlying implementation is wrapping the <tt><a>stdlib.h</a></tt>
--   <tt>malloc</tt>, <tt>realloc</tt>, and <tt>free</tt>. In other words
--   it should be safe to allocate using C-<tt>malloc</tt>, and free memory
--   with <a>free</a> from this module.
module Foreign.Marshal.Alloc

-- | <tt><a>alloca</a> f</tt> executes the computation <tt>f</tt>, passing
--   as argument a pointer to a temporarily allocated block of memory
--   sufficient to hold values of type <tt>a</tt>.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
alloca :: forall a b. Storable a => (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytes</a> n f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory of <tt>n</tt> bytes. The block of memory is sufficiently
--   aligned for any of the basic foreign types that fits into a memory
--   block of the allocated size.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytes :: Int -> (Ptr a -> IO b) -> IO b

-- | <tt><a>allocaBytesAligned</a> size align f</tt> executes the
--   computation <tt>f</tt>, passing as argument a pointer to a temporarily
--   allocated block of memory of <tt>size</tt> bytes and aligned to
--   <tt>align</tt> bytes. The value of <tt>align</tt> must be a power of
--   two.
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory that is sufficient to hold values of type
--   <tt>a</tt>. The size of the area allocated is determined by the
--   <a>sizeOf</a> method from the instance of <a>Storable</a> for the
--   appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
malloc :: forall a. Storable a => IO (Ptr a)

-- | Allocate a block of memory of the given number of bytes. The block of
--   memory is sufficiently aligned for any of the basic foreign types that
--   fits into a memory block of the allocated size.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
mallocBytes :: Int -> IO (Ptr a)

-- | Like <a>malloc</a> but memory is filled with bytes of value zero.
calloc :: forall a. Storable a => IO (Ptr a)

-- | Like <a>mallocBytes</a>, but memory is filled with bytes of value
--   zero.
callocBytes :: Int -> IO (Ptr a)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the size needed to store values of type
--   <tt>b</tt>. The returned pointer may refer to an entirely different
--   memory area, but will be suitably aligned to hold values of type
--   <tt>b</tt>. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the size of values of type <tt>b</tt>.
--   
--   If the argument to <a>realloc</a> is <a>nullPtr</a>, <a>realloc</a>
--   behaves like <a>malloc</a>.
realloc :: forall a b. Storable b => Ptr a -> IO (Ptr b)

-- | Resize a memory area that was allocated with <a>malloc</a> or
--   <a>mallocBytes</a> to the given size. The returned pointer may refer
--   to an entirely different memory area, but will be sufficiently aligned
--   for any of the basic foreign types that fits into a memory block of
--   the given size. The contents of the referenced memory area will be the
--   same as of the original pointer up to the minimum of the original size
--   and the given size.
--   
--   If the pointer argument to <a>reallocBytes</a> is <a>nullPtr</a>,
--   <a>reallocBytes</a> behaves like <a>malloc</a>. If the requested size
--   is 0, <a>reallocBytes</a> behaves like <a>free</a>.
reallocBytes :: Ptr a -> Int -> IO (Ptr a)

-- | Free a block of memory that was allocated with <a>malloc</a>,
--   <a>mallocBytes</a>, <a>realloc</a>, <a>reallocBytes</a>, <a>new</a> or
--   any of the <tt>new</tt><i>X</i> functions in
--   <a>Foreign.Marshal.Array</a> or <a>Foreign.C.String</a>.
free :: Ptr a -> IO ()

-- | A pointer to a foreign function equivalent to <a>free</a>, which may
--   be used as a finalizer (cf <a>ForeignPtr</a>) for storage allocated
--   with <a>malloc</a>, <a>mallocBytes</a>, <a>realloc</a> or
--   <a>reallocBytes</a>.
finalizerFree :: FinalizerPtr a


-- | Utilities for primitive marshaling
module Foreign.Marshal.Utils

-- | <tt><a>with</a> val f</tt> executes the computation <tt>f</tt>,
--   passing as argument a pointer to a temporarily allocated block of
--   memory into which <tt>val</tt> has been marshalled (the combination of
--   <a>alloca</a> and <a>poke</a>).
--   
--   The memory is freed when <tt>f</tt> terminates (either normally or via
--   an exception), so the pointer passed to <tt>f</tt> must <i>not</i> be
--   used after this.
with :: Storable a => a -> (Ptr a -> IO b) -> IO b

-- | Allocate a block of memory and marshal a value into it (the
--   combination of <a>malloc</a> and <a>poke</a>). The size of the area
--   allocated is determined by the <a>sizeOf</a> method from the instance
--   of <a>Storable</a> for the appropriate type.
--   
--   The memory may be deallocated using <a>free</a> or
--   <a>finalizerFree</a> when no longer required.
new :: Storable a => a -> IO (Ptr a)

-- | Convert a Haskell <a>Bool</a> to its numeric representation
fromBool :: Num a => Bool -> a

-- | Convert a Boolean in numeric representation to a Haskell value
toBool :: (Eq a, Num a) => a -> Bool

-- | Allocate storage and marshal a storable value wrapped into a
--   <a>Maybe</a>
--   
--   <ul>
--   <li>the <a>nullPtr</a> is used to represent <a>Nothing</a></li>
--   </ul>
maybeNew :: (a -> IO (Ptr b)) -> Maybe a -> IO (Ptr b)

-- | Converts a <tt>withXXX</tt> combinator into one marshalling a value
--   wrapped into a <a>Maybe</a>, using <a>nullPtr</a> to represent
--   <a>Nothing</a>.
maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c

-- | Convert a peek combinator into a one returning <a>Nothing</a> if
--   applied to a <a>nullPtr</a>
maybePeek :: (Ptr a -> IO b) -> Ptr a -> IO (Maybe b)

-- | Replicates a <tt>withXXX</tt> combinator over a list of objects,
--   yielding a list of marshalled objects
withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas may <i>not</i> overlap
copyBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Copies the given number of bytes from the second area (source) into
--   the first (destination); the copied areas <i>may</i> overlap
moveBytes :: Ptr a -> Ptr a -> Int -> IO ()

-- | Fill a given number of bytes in memory area with a byte value.
fillBytes :: Ptr a -> Word8 -> Int -> IO ()


-- | Marshalling support: routines allocating, storing, and retrieving
--   Haskell lists that are represented as arrays in the foreign language
module Foreign.Marshal.Array

-- | Allocate storage for the given number of elements of a storable type
--   (like <a>malloc</a>, but for multiple elements).
mallocArray :: forall a. Storable a => Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but add an extra position to hold a special
--   termination element.
mallocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Temporarily allocate space for the given number of elements (like
--   <a>alloca</a>, but for multiple elements).
allocaArray :: forall a b. Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Like <a>allocaArray</a>, but add an extra position to hold a special
--   termination element.
allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b

-- | Adjust the size of an array
reallocArray :: forall a. Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array including an extra position for the end
--   marker.
reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)

-- | Like <a>mallocArray</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray :: forall a. Storable a => Int -> IO (Ptr a)

-- | Like <a>callocArray0</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray0 :: Storable a => Int -> IO (Ptr a)

-- | Convert an array of given length into a Haskell list. The
--   implementation is tail-recursive and so uses constant stack space.
peekArray :: Storable a => Int -> Ptr a -> IO [a]

-- | Convert an array terminated by the given end marker into a Haskell
--   list
peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]

-- | Write the list elements consecutive into memory
pokeArray :: Storable a => Ptr a -> [a] -> IO ()

-- | Write the list elements consecutive into memory and terminate them
--   with the given marker element
pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values (like <a>new</a>, but for multiple
--   elements).
newArray :: Storable a => [a] -> IO (Ptr a)

-- | Write a list of storable elements into a newly allocated, consecutive
--   sequence of storable values, where the end is fixed by the given end
--   marker
newArray0 :: Storable a => a -> [a] -> IO (Ptr a)

-- | Temporarily store a list of storable values in memory (like
--   <a>with</a>, but for multiple elements).
withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but a terminator indicates where the array ends
withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b

-- | Like <a>withArray</a>, but the action gets the number of values as an
--   additional parameter
withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Like <a>withArrayLen</a>, but a terminator indicates where the array
--   ends
withArrayLen0 :: Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas may <i>not</i> overlap
copyArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Copy the given number of elements from the second array (source) into
--   the first array (destination); the copied areas <i>may</i> overlap
moveArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> IO ()

-- | Return the number of elements in an array, excluding the terminator
lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int

-- | Advance a pointer into an array by the given number of elements
advancePtr :: forall a. Storable a => Ptr a -> Int -> Ptr a


-- | Foreign marshalling support for CStrings with configurable encodings
module GHC.Foreign

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: TextEncoding -> CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: TextEncoding -> CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: TextEncoding -> String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: TextEncoding -> String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: TextEncoding -> String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: TextEncoding -> String -> (CStringLen -> IO a) -> IO a

-- | Marshal a list of Haskell strings into an array of NUL terminated C
--   strings using temporary storage.
--   
--   <ul>
--   <li>the Haskell strings may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringsLen :: TextEncoding -> [String] -> (Int -> Ptr CString -> IO a) -> IO a

-- | Determines whether a character can be accurately encoded in a
--   <a>CString</a>.
--   
--   Pretty much anyone who uses this function is in a state of sin because
--   whether or not a character is encodable will, in general, depend on
--   the context in which it occurs.
charIsRepresentable :: TextEncoding -> Char -> IO Bool


-- | Utilities for primitive marshalling of C strings.
--   
--   The marshalling converts each Haskell character, representing a
--   Unicode code point, to one or more bytes in a manner that, by default,
--   is determined by the current locale. As a consequence, no guarantees
--   can be made about the relative length of a Haskell string and its
--   corresponding C string, and therefore all the marshalling routines
--   include memory allocation. The translation between Unicode and the
--   encoding of the current locale may be lossy.
module Foreign.C.String

-- | A C string is a reference to an array of C characters terminated by
--   NUL.
type CString = Ptr CChar

-- | A string with explicit length information in bytes instead of a
--   terminating NUL (allowing NUL characters in the middle of the string).
type CStringLen = (Ptr CChar, Int)

-- | Marshal a NUL terminated C string into a Haskell string.
peekCString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCStringLen :: String -> (CStringLen -> IO a) -> IO a
charIsRepresentable :: Char -> IO Bool

-- | Convert a Haskell character to a C character. This function is only
--   safe on the first 256 characters.
castCharToCChar :: Char -> CChar

-- | Convert a C byte, representing a Latin-1 character, to the
--   corresponding Haskell character.
castCCharToChar :: CChar -> Char

-- | Convert a Haskell character to a C <tt>unsigned char</tt>. This
--   function is only safe on the first 256 characters.
castCharToCUChar :: Char -> CUChar

-- | Convert a C <tt>unsigned char</tt>, representing a Latin-1 character,
--   to the corresponding Haskell character.
castCUCharToChar :: CUChar -> Char

-- | Convert a Haskell character to a C <tt>signed char</tt>. This function
--   is only safe on the first 256 characters.
castCharToCSChar :: Char -> CSChar

-- | Convert a C <tt>signed char</tt>, representing a Latin-1 character, to
--   the corresponding Haskell character.
castCSCharToChar :: CSChar -> Char

-- | Marshal a NUL terminated C string into a Haskell string.
peekCAString :: CString -> IO String

-- | Marshal a C string with explicit length into a Haskell string.
peekCAStringLen :: CStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAString :: String -> IO CString

-- | Marshal a Haskell string into a C string (ie, character array) with
--   explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C string and must be explicitly
--   freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCAStringLen :: String -> IO CStringLen

-- | Marshal a Haskell string into a NUL terminated C string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAString :: String -> (CString -> IO a) -> IO a

-- | Marshal a Haskell string into a C string (ie, character array) in
--   temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCAStringLen :: String -> (CStringLen -> IO a) -> IO a

-- | A C wide string is a reference to an array of C wide characters
--   terminated by NUL.
type CWString = Ptr CWchar

-- | A wide character string with explicit length information in
--   <a>CWchar</a>s instead of a terminating NUL (allowing NUL characters
--   in the middle of the string).
type CWStringLen = (Ptr CWchar, Int)

-- | Marshal a NUL terminated C wide string into a Haskell string.
peekCWString :: CWString -> IO String

-- | Marshal a C wide string with explicit length into a Haskell string.
peekCWStringLen :: CWStringLen -> IO String

-- | Marshal a Haskell string into a NUL terminated C wide string.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWString :: String -> IO CWString

-- | Marshal a Haskell string into a C wide string (ie, wide character
--   array) with explicit length information.
--   
--   <ul>
--   <li>new storage is allocated for the C wide string and must be
--   explicitly freed using <a>free</a> or <a>finalizerFree</a>.</li>
--   </ul>
newCWStringLen :: String -> IO CWStringLen

-- | Marshal a Haskell string into a NUL terminated C wide string using
--   temporary storage.
--   
--   <ul>
--   <li>the Haskell string may <i>not</i> contain any NUL characters</li>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWString :: String -> (CWString -> IO a) -> IO a

-- | Marshal a Haskell string into a C wide string (i.e. wide character
--   array) in temporary storage, with explicit length information.
--   
--   <ul>
--   <li>the memory is freed when the subcomputation terminates (either
--   normally or via an exception), so the pointer to the temporary storage
--   must <i>not</i> be used after this.</li>
--   </ul>
withCWStringLen :: String -> (CWStringLen -> IO a) -> IO a


-- | Common Timer definitions shared between WinIO and RIO.
module GHC.Event.TimeOut

-- | A priority search queue, with timeouts as priorities.
type TimeoutQueue = PSQ TimeoutCallback

-- | Warning: since the <a>TimeoutCallback</a> is called from the I/O
--   manager, it must not throw an exception or block for a long period of
--   time. In particular, be wary of <a>throwTo</a> and <a>killThread</a>:
--   if the target thread is making a foreign call, these functions will
--   block until the call completes.
type TimeoutCallback = IO ()

-- | An edit to apply to a <a>TimeoutQueue</a>.
type TimeoutEdit = TimeoutQueue -> TimeoutQueue

-- | A timeout registration cookie.
newtype TimeoutKey
TK :: Unique -> TimeoutKey
instance GHC.Classes.Ord GHC.Event.TimeOut.TimeoutKey
instance GHC.Classes.Eq GHC.Event.TimeOut.TimeoutKey


-- | Simple UTF-8 codecs supporting non-streaming encoding/decoding. For
--   encoding where codepoints may be broken across buffers, see
--   <a>GHC.IO.Encoding.UTF8</a>.
--   
--   This is one of several UTF-8 implementations provided by GHC; see Note
--   [GHC's many UTF-8 implementations] in <a>GHC.Encoding.UTF8</a> for an
--   overview.
module GHC.Encoding.UTF8

-- | Decode a single character at the given <a>Addr#</a>.
utf8DecodeCharAddr# :: Addr# -> Int# -> (# Char#, Int# #)

-- | Decode a single codepoint starting at the given <a>Ptr</a>.
utf8DecodeCharPtr :: Ptr Word8 -> (Char, Int)

-- | Decode a single codepoint starting at the given byte offset into a
--   <a>ByteArray#</a>.
utf8DecodeCharByteArray# :: ByteArray# -> Int# -> (# Char#, Int# #)
utf8DecodeByteArray# :: ByteArray# -> [Char]
utf8DecodeForeignPtr :: ForeignPtr Word8 -> Int -> Int -> [Char]
utf8CountCharsByteArray# :: ByteArray# -> Int
utf8CompareByteArray# :: ByteArray# -> ByteArray# -> Ordering
utf8EncodePtr :: Ptr Word8 -> String -> IO ()
utf8EncodeByteArray# :: String -> ByteArray#
utf8EncodedLength :: String -> Int

module GHC.Weak.Finalize

-- | Set the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
setFinalizerExceptionHandler :: (SomeException -> IO ()) -> IO ()

-- | Get the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
getFinalizerExceptionHandler :: IO (SomeException -> IO ())

-- | Run a batch of finalizers from the garbage collector. We're given an
--   array of finalizers and the length of the array, and we just call each
--   one in turn.
runFinalizerBatch :: Int -> Array# (State# RealWorld -> State# RealWorld) -> IO ()


-- | Weak pointers.
module GHC.Weak

-- | A weak pointer object with a key and a value. The value has type
--   <tt>v</tt>.
--   
--   A weak pointer expresses a relationship between two objects, the
--   <i>key</i> and the <i>value</i>: if the key is considered to be alive
--   by the garbage collector, then the value is also alive. A reference
--   from the value to the key does <i>not</i> keep the key alive.
--   
--   A weak pointer may also have a finalizer of type <tt>IO ()</tt>; if it
--   does, then the finalizer will be run at most once, at a time after the
--   key has become unreachable by the program ("dead"). The storage
--   manager attempts to run the finalizer(s) for an object soon after the
--   object dies, but promptness is not guaranteed.
--   
--   It is not guaranteed that a finalizer will eventually run, and no
--   attempt is made to run outstanding finalizers when the program exits.
--   Therefore finalizers should not be relied on to clean up resources -
--   other methods (eg. exception handlers) should be employed, possibly in
--   addition to finalizers.
--   
--   References from the finalizer to the key are treated in the same way
--   as references from the value to the key: they do not keep the key
--   alive. A finalizer may therefore resurrect the key, perhaps by storing
--   it in the same data structure.
--   
--   The finalizer, and the relationship between the key and the value,
--   exist regardless of whether the program keeps a reference to the
--   <a>Weak</a> object or not.
--   
--   There may be multiple weak pointers with the same key. In this case,
--   the finalizers for each of these weak pointers will all be run in some
--   arbitrary order, or perhaps concurrently, when the key dies. If the
--   programmer specifies a finalizer that assumes it has the only
--   reference to an object (for example, a file that it wishes to close),
--   then the programmer must ensure that there is only one such finalizer.
--   
--   If there are no other threads to run, the runtime system will check
--   for runnable finalizers before declaring the system to be deadlocked.
--   
--   WARNING: weak pointers to ordinary non-primitive Haskell types are
--   particularly fragile, because the compiler is free to optimise away or
--   duplicate the underlying data structure. Therefore attempting to place
--   a finalizer on an ordinary Haskell type may well result in the
--   finalizer running earlier than you expected. This is not a problem for
--   caches and memo tables where early finalization is benign.
--   
--   Finalizers <i>can</i> be used reliably for types that are created
--   explicitly and have identity, such as <tt>IORef</tt>, <tt>MVar</tt>,
--   and <tt>TVar</tt>. However, to place a finalizer on one of these
--   types, you should use the specific operation provided for that type,
--   e.g. <tt>mkWeakIORef</tt>, <tt>mkWeakMVar</tt> and <tt>mkWeakTVar</tt>
--   respectively. These operations attach the finalizer to the primitive
--   object inside the box (e.g. <tt>MutVar#</tt> in the case of
--   <tt>IORef</tt>), because attaching the finalizer to the box itself
--   fails when the outer box is optimised away by the compiler.
data Weak v
Weak :: Weak# v -> Weak v

-- | Establishes a weak pointer to <tt>k</tt>, with value <tt>v</tt> and a
--   finalizer.
--   
--   This is the most general interface for building a weak pointer.
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)

-- | Dereferences a weak pointer. If the key is still alive, then
--   <tt><a>Just</a> v</tt> is returned (where <tt>v</tt> is the
--   <i>value</i> in the weak pointer), otherwise <a>Nothing</a> is
--   returned.
--   
--   The return value of <a>deRefWeak</a> depends on when the garbage
--   collector runs, hence it is in the <a>IO</a> monad.
deRefWeak :: Weak v -> IO (Maybe v)

-- | Causes a the finalizer associated with a weak pointer to be run
--   immediately.
finalize :: Weak v -> IO ()

-- | Set the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
setFinalizerExceptionHandler :: (SomeException -> IO ()) -> IO ()

-- | Get the global action called to report exceptions thrown by weak
--   pointer finalizers to the user.
getFinalizerExceptionHandler :: IO (SomeException -> IO ())


-- | Mutable references in the IO monad.
module Data.IORef

-- | A mutable variable in the <a>IO</a> monad.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; r &lt;- newIORef 0
--   
--   &gt;&gt;&gt; readIORef r
--   0
--   
--   &gt;&gt;&gt; writeIORef r 1
--   
--   &gt;&gt;&gt; readIORef r
--   1
--   
--   &gt;&gt;&gt; atomicWriteIORef r 2
--   
--   &gt;&gt;&gt; readIORef r
--   2
--   
--   &gt;&gt;&gt; modifyIORef' r (+ 1)
--   
--   &gt;&gt;&gt; readIORef r
--   3
--   
--   &gt;&gt;&gt; atomicModifyIORef' r (\a -&gt; (a + 1, ()))
--   
--   &gt;&gt;&gt; readIORef r
--   4
--   </pre>
--   
--   See also <a>STRef</a> and <a>MVar</a>.
data IORef a

-- | Build a new <a>IORef</a>
newIORef :: a -> IO (IORef a)

-- | Read the value of an <a>IORef</a>.
--   
--   Beware that the CPU executing a thread can reorder reads or writes to
--   independent locations. See <a>Data.IORef#memmodel</a> for more
--   details.
readIORef :: IORef a -> IO a

-- | Write a new value into an <a>IORef</a>.
--   
--   This function does not create a memory barrier and can be reordered
--   with other independent reads and writes within a thread, which may
--   cause issues for multithreaded execution. In these cases, consider
--   using <a>atomicWriteIORef</a> instead. See <a>Data.IORef#memmodel</a>
--   for more details.
writeIORef :: IORef a -> a -> IO ()

-- | Mutate the contents of an <a>IORef</a>, combining <a>readIORef</a> and
--   <a>writeIORef</a>. This is not an atomic update, consider using
--   <a>atomicModifyIORef</a> when operating in a multithreaded
--   environment.
--   
--   Be warned that <a>modifyIORef</a> does not apply the function
--   strictly. This means if the program calls <a>modifyIORef</a> many
--   times, but seldom uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   IORef as a counter. For example, the following will likely produce a
--   stack overflow:
--   
--   <pre>
--   ref &lt;- newIORef 0
--   replicateM_ 1000000 $ modifyIORef ref (+1)
--   readIORef ref &gt;&gt;= print
--   </pre>
--   
--   To avoid this problem, use <a>modifyIORef'</a> instead.
modifyIORef :: IORef a -> (a -> a) -> IO ()

-- | Strict version of <a>modifyIORef</a>. This is not an atomic update,
--   consider using <a>atomicModifyIORef'</a> when operating in a
--   multithreaded environment.
modifyIORef' :: IORef a -> (a -> a) -> IO ()

-- | Atomically modifies the contents of an <a>IORef</a>.
--   
--   This function is useful for using <a>IORef</a> in a safe way in a
--   multithreaded program. If you only have one <a>IORef</a>, then using
--   <a>atomicModifyIORef</a> to access and modify it will prevent race
--   conditions.
--   
--   Extending the atomicity to multiple <a>IORef</a>s is problematic, so
--   it is recommended that if you need to do anything more complicated
--   then using <a>MVar</a> instead is a good idea.
--   
--   <a>atomicModifyIORef</a> does not apply the function strictly. This is
--   important to know even if all you are doing is replacing the value.
--   For example, this will leak memory:
--   
--   <pre>
--   ref &lt;- newIORef '1'
--   forever $ atomicModifyIORef ref (\_ -&gt; ('2', ()))
--   </pre>
--   
--   Use <a>atomicModifyIORef'</a> or <a>atomicWriteIORef</a> to avoid this
--   problem.
--   
--   This function imposes a memory barrier, preventing reordering; see
--   <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b

-- | Strict version of <a>atomicModifyIORef</a>. This forces both the value
--   stored in the <a>IORef</a> and the value returned. The new value is
--   installed in the <a>IORef</a> before the returned value is forced. So
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (x+1, undefined))
--   </pre>
--   
--   will increment the <a>IORef</a> and then throw an exception in the
--   calling thread.
--   
--   This function imposes a memory barrier, preventing reordering; see
--   <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b

-- | Variant of <a>writeIORef</a>. The prefix "atomic" relates to a fact
--   that it imposes a reordering barrier, similar to
--   <a>atomicModifyIORef</a>. Such a write will not be reordered with
--   other reads or writes even on CPUs with weak memory model.
atomicWriteIORef :: IORef a -> a -> IO ()

-- | Make a <a>Weak</a> pointer to an <a>IORef</a>, using the second
--   argument as a finalizer to run when <a>IORef</a> is garbage-collected
mkWeakIORef :: IORef a -> IO () -> IO (Weak (IORef a))


-- | Marshalling support. Unsafe API.
module Foreign.Marshal.Unsafe

-- | Sometimes an external entity is a pure function, except that it passes
--   arguments and/or results via pointers. The function
--   <tt>unsafeLocalState</tt> permits the packaging of such entities as
--   pure functions.
--   
--   The only IO operations allowed in the IO action passed to
--   <tt>unsafeLocalState</tt> are (a) local allocation (<tt>alloca</tt>,
--   <tt>allocaBytes</tt> and derived operations such as <tt>withArray</tt>
--   and <tt>withCString</tt>), and (b) pointer operations
--   (<tt>Foreign.Storable</tt> and <tt>Foreign.Ptr</tt>) on the pointers
--   to local storage, and (c) foreign functions whose only observable
--   effect is to read and/or write the locally allocated memory. Passing
--   an IO operation that does not obey these rules results in undefined
--   behaviour.
--   
--   It is expected that this operation will be replaced in a future
--   revision of Haskell.
unsafeLocalState :: IO a -> a


-- | FFI datatypes and operations that use or require concurrency (GHC
--   only).
module Foreign.Concurrent

-- | Turns a plain memory reference into a foreign object by associating a
--   finalizer - given by the monadic operation - with the reference.
--   
--   When finalization is triggered by GC, the storage manager will start
--   the finalizer, in a separate thread, some time after the last
--   reference to the <tt>ForeignPtr</tt> is dropped. There is <b>no
--   guarantee of promptness</b>, and in fact there is no guarantee that
--   the finalizer will eventually run at all for GC-triggered
--   finalization.
--   
--   When finalization is triggered by explicitly calling
--   <tt>finalizeForeignPtr</tt>, the finalizer will run immediately on the
--   current Haskell thread.
--   
--   Note that references from a finalizer do not necessarily prevent
--   another object from being finalized. If A's finalizer refers to B
--   (perhaps using <a>touchForeignPtr</a>, then the only guarantee is that
--   B's finalizer will never be started before A's. If both A and B are
--   unreachable, then both finalizers will start together. See
--   <a>touchForeignPtr</a> for more on finalizer ordering.
newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given <a>ForeignPtr</a>. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
--   
--   This is a variant of <a>addForeignPtrFinalizer</a>, where the
--   finalizer is an arbitrary <a>IO</a> action. When it is invoked, the
--   finalizer will run in a new thread.
--   
--   NB. Be very careful with these finalizers. One common trap is that if
--   a finalizer references another finalized value, it does not prevent
--   that value from being finalized. In particular, <a>Handle</a>s are
--   finalized objects, so a finalizer should not refer to a <a>Handle</a>
--   (including <a>stdout</a>, <a>stdin</a>, or <a>stderr</a>).
addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()


-- | C-specific Marshalling support: Handling of C "errno" error codes.
module Foreign.C.Error

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno
Errno :: CInt -> Errno
eOK :: Errno
e2BIG :: Errno
eACCES :: Errno
eADDRINUSE :: Errno
eADDRNOTAVAIL :: Errno
eADV :: Errno
eAFNOSUPPORT :: Errno
eAGAIN :: Errno
eALREADY :: Errno
eBADF :: Errno
eBADMSG :: Errno
eBADRPC :: Errno
eBUSY :: Errno
eCHILD :: Errno
eCOMM :: Errno
eCONNABORTED :: Errno
eCONNREFUSED :: Errno
eCONNRESET :: Errno
eDEADLK :: Errno
eDESTADDRREQ :: Errno
eDIRTY :: Errno
eDOM :: Errno
eDQUOT :: Errno
eEXIST :: Errno
eFAULT :: Errno
eFBIG :: Errno
eFTYPE :: Errno
eHOSTDOWN :: Errno
eHOSTUNREACH :: Errno
eIDRM :: Errno
eILSEQ :: Errno
eINPROGRESS :: Errno
eINTR :: Errno
eINVAL :: Errno
eIO :: Errno
eISCONN :: Errno
eISDIR :: Errno
eLOOP :: Errno
eMFILE :: Errno
eMLINK :: Errno
eMSGSIZE :: Errno
eMULTIHOP :: Errno
eNAMETOOLONG :: Errno
eNETDOWN :: Errno
eNETRESET :: Errno
eNETUNREACH :: Errno
eNFILE :: Errno
eNOBUFS :: Errno
eNODATA :: Errno
eNODEV :: Errno
eNOENT :: Errno
eNOEXEC :: Errno
eNOLCK :: Errno
eNOLINK :: Errno
eNOMEM :: Errno
eNOMSG :: Errno
eNONET :: Errno
eNOPROTOOPT :: Errno
eNOSPC :: Errno
eNOSR :: Errno
eNOSTR :: Errno
eNOSYS :: Errno
eNOTBLK :: Errno
eNOTCONN :: Errno
eNOTDIR :: Errno
eNOTEMPTY :: Errno
eNOTSOCK :: Errno

eNOTSUP :: Errno
eNOTTY :: Errno
eNXIO :: Errno
eOPNOTSUPP :: Errno
ePERM :: Errno
ePFNOSUPPORT :: Errno
ePIPE :: Errno
ePROCLIM :: Errno
ePROCUNAVAIL :: Errno
ePROGMISMATCH :: Errno
ePROGUNAVAIL :: Errno
ePROTO :: Errno
ePROTONOSUPPORT :: Errno
ePROTOTYPE :: Errno
eRANGE :: Errno
eREMCHG :: Errno
eREMOTE :: Errno
eROFS :: Errno
eRPCMISMATCH :: Errno
eRREMOTE :: Errno
eSHUTDOWN :: Errno
eSOCKTNOSUPPORT :: Errno
eSPIPE :: Errno
eSRCH :: Errno
eSRMNT :: Errno
eSTALE :: Errno
eTIME :: Errno
eTIMEDOUT :: Errno
eTOOMANYREFS :: Errno
eTXTBSY :: Errno
eUSERS :: Errno
eWOULDBLOCK :: Errno
eXDEV :: Errno

-- | Yield <a>True</a> if the given <a>Errno</a> value is valid on the
--   system. This implies that the <a>Eq</a> instance of <a>Errno</a> is
--   also system dependent as it is only defined for valid values of
--   <a>Errno</a>.
isValidErrno :: Errno -> Bool

-- | Get the current value of <tt>errno</tt> in the current thread.
--   
--   On GHC, the runtime will ensure that any Haskell thread will only see
--   "its own" <tt>errno</tt>, by saving and restoring the value when
--   Haskell threads are scheduled across OS threads.
getErrno :: IO Errno

-- | Reset the current thread's <tt>errno</tt> value to <a>eOK</a>.
resetErrno :: IO ()

-- | Construct an <a>IOException</a> based on the given <a>Errno</a> value.
--   The optional information can be used to improve the accuracy of error
--   messages.
errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a>.
throwErrno :: String -> IO a

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the result value of the <a>IO</a> action meets the
--   given predicate.
throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIf</a>, but discards the result of the <a>IO</a>
--   action after error handling.
throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | as <a>throwErrnoIf</a>, but retry the <a>IO</a> action when it yields
--   the error code <a>eINTR</a> - this amounts to the standard retry loop
--   for interrupted POSIX system calls.
throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a

-- | as <a>throwErrnoIfRetry</a>, but discards the result.
throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>.
throwErrnoIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns a result of
--   <tt>-1</tt>, but retries in case of an interrupted operation.
throwErrnoIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1</a>, but discards the result.
throwErrnoIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>.
throwErrnoIfNull :: String -> IO (Ptr a) -> IO (Ptr a)

-- | Throw an <a>IOException</a> corresponding to the current value of
--   <a>getErrno</a> if the <a>IO</a> action returns <a>nullPtr</a>, but
--   retry in case of an interrupted operation.
throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfRetry</a>, but additionally if the operation yields
--   the error code <a>eAGAIN</a> or <a>eWOULDBLOCK</a>, an alternative
--   action is executed before retrying.
throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfRetryMayBlock</a>, but discards the result.
throwErrnoIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfMinus1Retry</a>, but checks for operations that
--   would block.
throwErrnoIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a

-- | as <a>throwErrnoIfMinus1RetryMayBlock</a>, but discards the result.
throwErrnoIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()

-- | as <a>throwErrnoIfNullRetry</a>, but checks for operations that would
--   block.
throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)

-- | as <a>throwErrno</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPath :: String -> FilePath -> IO a

-- | as <a>throwErrnoIf</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIf_</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIf_ :: (a -> Bool) -> String -> FilePath -> IO a -> IO ()

-- | as <a>throwErrnoIfNull</a>, but exceptions include the given path when
--   appropriate.
throwErrnoPathIfNull :: String -> FilePath -> IO (Ptr a) -> IO (Ptr a)

-- | as <a>throwErrnoIfMinus1</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1 :: (Eq a, Num a) => String -> FilePath -> IO a -> IO a

-- | as <a>throwErrnoIfMinus1_</a>, but exceptions include the given path
--   when appropriate.
throwErrnoPathIfMinus1_ :: (Eq a, Num a) => String -> FilePath -> IO a -> IO ()
instance GHC.Classes.Eq Foreign.C.Error.Errno


-- | Bundles the C specific FFI library functionality
module Foreign.C


-- | This module contains support for pooled memory management. Under this
--   scheme, (re-)allocations belong to a given pool, and everything in a
--   pool is deallocated when the pool itself is deallocated. This is
--   useful when <a>alloca</a> with its implicit allocation and
--   deallocation is not flexible enough, but explicit uses of
--   <a>malloc</a> and <tt>free</tt> are too awkward.
module Foreign.Marshal.Pool

-- | A memory pool.
data Pool

-- | Allocate a fresh memory pool.
newPool :: IO Pool

-- | Deallocate a memory pool and everything which has been allocated in
--   the pool itself.
freePool :: Pool -> IO ()

-- | Execute an action with a fresh memory pool, which gets automatically
--   deallocated (including its contents) after the action has finished.
withPool :: (Pool -> IO b) -> IO b

-- | Allocate space for storable type in the given pool. The size of the
--   area allocated is determined by the <a>sizeOf</a> method from the
--   instance of <a>Storable</a> for the appropriate type.
pooledMalloc :: forall a. Storable a => Pool -> IO (Ptr a)

-- | Allocate the given number of bytes of storage in the pool.
pooledMallocBytes :: Pool -> Int -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size
--   of the required type.
pooledRealloc :: forall a. Storable a => Pool -> Ptr a -> IO (Ptr a)

-- | Adjust the storage area for an element in the pool to the given size.
--   Note that the previously allocated space is still retained in the same
--   <a>Pool</a> and will only be freed when the entire <a>Pool</a> is
--   freed.
pooledReallocBytes :: Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool.
pooledMallocArray :: forall a. Storable a => Pool -> Int -> IO (Ptr a)

-- | Allocate storage for the given number of elements of a storable type
--   in the pool, but leave room for an extra element to signal the end of
--   the array.
pooledMallocArray0 :: Storable a => Pool -> Int -> IO (Ptr a)

-- | Adjust the size of an array in the given pool.
pooledReallocArray :: forall a. Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Adjust the size of an array with an end marker in the given pool.
pooledReallocArray0 :: Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)

-- | Allocate storage for a value in the given pool and marshal the value
--   into this storage.
pooledNew :: Storable a => Pool -> a -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it.
pooledNewArray :: Storable a => Pool -> [a] -> IO (Ptr a)

-- | Allocate consecutive storage for a list of values in the given pool
--   and marshal these values into it, terminating the end with the given
--   marker.
pooledNewArray0 :: Storable a => Pool -> a -> [a] -> IO (Ptr a)


-- | Marshalling support
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign.Marshal
--   instead</i>
module Foreign.Marshal.Safe


-- | Marshalling support
module Foreign.Marshal


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Foreign instead</i>
module Foreign.Safe


-- | A collection of data types, classes, and functions for interfacing
--   with another programming language.
module Foreign


-- | POSIX data types: Haskell equivalents of the types defined by the
--   <tt>&lt;sys/types.h&gt;</tt> C header on a POSIX system.
module System.Posix.Types
newtype {-# CTYPE "dev_t" #-} CDev
CDev :: Word64 -> CDev
newtype {-# CTYPE "ino_t" #-} CIno
CIno :: Word64 -> CIno
newtype {-# CTYPE "mode_t" #-} CMode
CMode :: Word32 -> CMode
newtype {-# CTYPE "off_t" #-} COff
COff :: Int64 -> COff
newtype {-# CTYPE "pid_t" #-} CPid
CPid :: Int32 -> CPid
newtype {-# CTYPE "ssize_t" #-} CSsize
CSsize :: Int64 -> CSsize
newtype {-# CTYPE "gid_t" #-} CGid
CGid :: Word32 -> CGid
newtype {-# CTYPE "nlink_t" #-} CNlink
CNlink :: Word64 -> CNlink
newtype {-# CTYPE "uid_t" #-} CUid
CUid :: Word32 -> CUid
newtype {-# CTYPE "cc_t" #-} CCc
CCc :: Word8 -> CCc
newtype {-# CTYPE "speed_t" #-} CSpeed
CSpeed :: Word32 -> CSpeed
newtype {-# CTYPE "tcflag_t" #-} CTcflag
CTcflag :: Word32 -> CTcflag
newtype {-# CTYPE "rlim_t" #-} CRLim
CRLim :: Word64 -> CRLim

newtype {-# CTYPE "blksize_t" #-} CBlkSize
CBlkSize :: Int64 -> CBlkSize

newtype {-# CTYPE "blkcnt_t" #-} CBlkCnt
CBlkCnt :: Int64 -> CBlkCnt

newtype {-# CTYPE "clockid_t" #-} CClockId
CClockId :: Int32 -> CClockId

newtype {-# CTYPE "fsblkcnt_t" #-} CFsBlkCnt
CFsBlkCnt :: Word64 -> CFsBlkCnt

newtype {-# CTYPE "fsfilcnt_t" #-} CFsFilCnt
CFsFilCnt :: Word64 -> CFsFilCnt

newtype {-# CTYPE "id_t" #-} CId
CId :: Word32 -> CId

newtype {-# CTYPE "key_t" #-} CKey
CKey :: Int32 -> CKey

newtype {-# CTYPE "timer_t" #-} CTimer
CTimer :: CUIntPtr -> CTimer

newtype {-# CTYPE "socklen_t" #-} CSocklen
CSocklen :: Word32 -> CSocklen

newtype {-# CTYPE "nfds_t" #-} CNfds
CNfds :: Word64 -> CNfds
newtype {-# CTYPE "int" #-} Fd
Fd :: CInt -> Fd
type LinkCount = CNlink
type UserID = CUid
type GroupID = CGid
type ByteCount = CSize
type ClockTick = CClock
type EpochTime = CTime
type FileOffset = COff
type ProcessID = CPid
type ProcessGroupID = CPid
type DeviceID = CDev
type FileID = CIno
type FileMode = CMode
type Limit = CLong
instance GHC.Ix.Ix System.Posix.Types.CDev
instance GHC.Bits.FiniteBits System.Posix.Types.CDev
instance GHC.Bits.Bits System.Posix.Types.CDev
instance GHC.Real.Integral System.Posix.Types.CDev
instance GHC.Enum.Bounded System.Posix.Types.CDev
instance GHC.Real.Real System.Posix.Types.CDev
instance Foreign.Storable.Storable System.Posix.Types.CDev
instance GHC.Enum.Enum System.Posix.Types.CDev
instance GHC.Num.Num System.Posix.Types.CDev
instance GHC.Classes.Ord System.Posix.Types.CDev
instance GHC.Classes.Eq System.Posix.Types.CDev
instance GHC.Show.Show System.Posix.Types.CDev
instance GHC.Read.Read System.Posix.Types.CDev
instance GHC.Ix.Ix System.Posix.Types.CIno
instance GHC.Bits.FiniteBits System.Posix.Types.CIno
instance GHC.Bits.Bits System.Posix.Types.CIno
instance GHC.Real.Integral System.Posix.Types.CIno
instance GHC.Enum.Bounded System.Posix.Types.CIno
instance GHC.Real.Real System.Posix.Types.CIno
instance Foreign.Storable.Storable System.Posix.Types.CIno
instance GHC.Enum.Enum System.Posix.Types.CIno
instance GHC.Num.Num System.Posix.Types.CIno
instance GHC.Classes.Ord System.Posix.Types.CIno
instance GHC.Classes.Eq System.Posix.Types.CIno
instance GHC.Show.Show System.Posix.Types.CIno
instance GHC.Read.Read System.Posix.Types.CIno
instance GHC.Ix.Ix System.Posix.Types.CMode
instance GHC.Bits.FiniteBits System.Posix.Types.CMode
instance GHC.Bits.Bits System.Posix.Types.CMode
instance GHC.Real.Integral System.Posix.Types.CMode
instance GHC.Enum.Bounded System.Posix.Types.CMode
instance GHC.Real.Real System.Posix.Types.CMode
instance Foreign.Storable.Storable System.Posix.Types.CMode
instance GHC.Enum.Enum System.Posix.Types.CMode
instance GHC.Num.Num System.Posix.Types.CMode
instance GHC.Classes.Ord System.Posix.Types.CMode
instance GHC.Classes.Eq System.Posix.Types.CMode
instance GHC.Show.Show System.Posix.Types.CMode
instance GHC.Read.Read System.Posix.Types.CMode
instance GHC.Ix.Ix System.Posix.Types.COff
instance GHC.Bits.FiniteBits System.Posix.Types.COff
instance GHC.Bits.Bits System.Posix.Types.COff
instance GHC.Real.Integral System.Posix.Types.COff
instance GHC.Enum.Bounded System.Posix.Types.COff
instance GHC.Real.Real System.Posix.Types.COff
instance Foreign.Storable.Storable System.Posix.Types.COff
instance GHC.Enum.Enum System.Posix.Types.COff
instance GHC.Num.Num System.Posix.Types.COff
instance GHC.Classes.Ord System.Posix.Types.COff
instance GHC.Classes.Eq System.Posix.Types.COff
instance GHC.Show.Show System.Posix.Types.COff
instance GHC.Read.Read System.Posix.Types.COff
instance GHC.Ix.Ix System.Posix.Types.CPid
instance GHC.Bits.FiniteBits System.Posix.Types.CPid
instance GHC.Bits.Bits System.Posix.Types.CPid
instance GHC.Real.Integral System.Posix.Types.CPid
instance GHC.Enum.Bounded System.Posix.Types.CPid
instance GHC.Real.Real System.Posix.Types.CPid
instance Foreign.Storable.Storable System.Posix.Types.CPid
instance GHC.Enum.Enum System.Posix.Types.CPid
instance GHC.Num.Num System.Posix.Types.CPid
instance GHC.Classes.Ord System.Posix.Types.CPid
instance GHC.Classes.Eq System.Posix.Types.CPid
instance GHC.Show.Show System.Posix.Types.CPid
instance GHC.Read.Read System.Posix.Types.CPid
instance GHC.Ix.Ix System.Posix.Types.CSsize
instance GHC.Bits.FiniteBits System.Posix.Types.CSsize
instance GHC.Bits.Bits System.Posix.Types.CSsize
instance GHC.Real.Integral System.Posix.Types.CSsize
instance GHC.Enum.Bounded System.Posix.Types.CSsize
instance GHC.Real.Real System.Posix.Types.CSsize
instance Foreign.Storable.Storable System.Posix.Types.CSsize
instance GHC.Enum.Enum System.Posix.Types.CSsize
instance GHC.Num.Num System.Posix.Types.CSsize
instance GHC.Classes.Ord System.Posix.Types.CSsize
instance GHC.Classes.Eq System.Posix.Types.CSsize
instance GHC.Show.Show System.Posix.Types.CSsize
instance GHC.Read.Read System.Posix.Types.CSsize
instance GHC.Ix.Ix System.Posix.Types.CGid
instance GHC.Bits.FiniteBits System.Posix.Types.CGid
instance GHC.Bits.Bits System.Posix.Types.CGid
instance GHC.Real.Integral System.Posix.Types.CGid
instance GHC.Enum.Bounded System.Posix.Types.CGid
instance GHC.Real.Real System.Posix.Types.CGid
instance Foreign.Storable.Storable System.Posix.Types.CGid
instance GHC.Enum.Enum System.Posix.Types.CGid
instance GHC.Num.Num System.Posix.Types.CGid
instance GHC.Classes.Ord System.Posix.Types.CGid
instance GHC.Classes.Eq System.Posix.Types.CGid
instance GHC.Show.Show System.Posix.Types.CGid
instance GHC.Read.Read System.Posix.Types.CGid
instance GHC.Ix.Ix System.Posix.Types.CNlink
instance GHC.Bits.FiniteBits System.Posix.Types.CNlink
instance GHC.Bits.Bits System.Posix.Types.CNlink
instance GHC.Real.Integral System.Posix.Types.CNlink
instance GHC.Enum.Bounded System.Posix.Types.CNlink
instance GHC.Real.Real System.Posix.Types.CNlink
instance Foreign.Storable.Storable System.Posix.Types.CNlink
instance GHC.Enum.Enum System.Posix.Types.CNlink
instance GHC.Num.Num System.Posix.Types.CNlink
instance GHC.Classes.Ord System.Posix.Types.CNlink
instance GHC.Classes.Eq System.Posix.Types.CNlink
instance GHC.Show.Show System.Posix.Types.CNlink
instance GHC.Read.Read System.Posix.Types.CNlink
instance GHC.Ix.Ix System.Posix.Types.CUid
instance GHC.Bits.FiniteBits System.Posix.Types.CUid
instance GHC.Bits.Bits System.Posix.Types.CUid
instance GHC.Real.Integral System.Posix.Types.CUid
instance GHC.Enum.Bounded System.Posix.Types.CUid
instance GHC.Real.Real System.Posix.Types.CUid
instance Foreign.Storable.Storable System.Posix.Types.CUid
instance GHC.Enum.Enum System.Posix.Types.CUid
instance GHC.Num.Num System.Posix.Types.CUid
instance GHC.Classes.Ord System.Posix.Types.CUid
instance GHC.Classes.Eq System.Posix.Types.CUid
instance GHC.Show.Show System.Posix.Types.CUid
instance GHC.Read.Read System.Posix.Types.CUid
instance GHC.Real.Real System.Posix.Types.CCc
instance Foreign.Storable.Storable System.Posix.Types.CCc
instance GHC.Enum.Enum System.Posix.Types.CCc
instance GHC.Num.Num System.Posix.Types.CCc
instance GHC.Classes.Ord System.Posix.Types.CCc
instance GHC.Classes.Eq System.Posix.Types.CCc
instance GHC.Show.Show System.Posix.Types.CCc
instance GHC.Read.Read System.Posix.Types.CCc
instance GHC.Real.Real System.Posix.Types.CSpeed
instance Foreign.Storable.Storable System.Posix.Types.CSpeed
instance GHC.Enum.Enum System.Posix.Types.CSpeed
instance GHC.Num.Num System.Posix.Types.CSpeed
instance GHC.Classes.Ord System.Posix.Types.CSpeed
instance GHC.Classes.Eq System.Posix.Types.CSpeed
instance GHC.Show.Show System.Posix.Types.CSpeed
instance GHC.Read.Read System.Posix.Types.CSpeed
instance GHC.Ix.Ix System.Posix.Types.CTcflag
instance GHC.Bits.FiniteBits System.Posix.Types.CTcflag
instance GHC.Bits.Bits System.Posix.Types.CTcflag
instance GHC.Real.Integral System.Posix.Types.CTcflag
instance GHC.Enum.Bounded System.Posix.Types.CTcflag
instance GHC.Real.Real System.Posix.Types.CTcflag
instance Foreign.Storable.Storable System.Posix.Types.CTcflag
instance GHC.Enum.Enum System.Posix.Types.CTcflag
instance GHC.Num.Num System.Posix.Types.CTcflag
instance GHC.Classes.Ord System.Posix.Types.CTcflag
instance GHC.Classes.Eq System.Posix.Types.CTcflag
instance GHC.Show.Show System.Posix.Types.CTcflag
instance GHC.Read.Read System.Posix.Types.CTcflag
instance GHC.Ix.Ix System.Posix.Types.CRLim
instance GHC.Bits.FiniteBits System.Posix.Types.CRLim
instance GHC.Bits.Bits System.Posix.Types.CRLim
instance GHC.Real.Integral System.Posix.Types.CRLim
instance GHC.Enum.Bounded System.Posix.Types.CRLim
instance GHC.Real.Real System.Posix.Types.CRLim
instance Foreign.Storable.Storable System.Posix.Types.CRLim
instance GHC.Enum.Enum System.Posix.Types.CRLim
instance GHC.Num.Num System.Posix.Types.CRLim
instance GHC.Classes.Ord System.Posix.Types.CRLim
instance GHC.Classes.Eq System.Posix.Types.CRLim
instance GHC.Show.Show System.Posix.Types.CRLim
instance GHC.Read.Read System.Posix.Types.CRLim
instance GHC.Ix.Ix System.Posix.Types.CBlkSize
instance GHC.Bits.FiniteBits System.Posix.Types.CBlkSize
instance GHC.Bits.Bits System.Posix.Types.CBlkSize
instance GHC.Real.Integral System.Posix.Types.CBlkSize
instance GHC.Enum.Bounded System.Posix.Types.CBlkSize
instance GHC.Real.Real System.Posix.Types.CBlkSize
instance Foreign.Storable.Storable System.Posix.Types.CBlkSize
instance GHC.Enum.Enum System.Posix.Types.CBlkSize
instance GHC.Num.Num System.Posix.Types.CBlkSize
instance GHC.Classes.Ord System.Posix.Types.CBlkSize
instance GHC.Classes.Eq System.Posix.Types.CBlkSize
instance GHC.Show.Show System.Posix.Types.CBlkSize
instance GHC.Read.Read System.Posix.Types.CBlkSize
instance GHC.Ix.Ix System.Posix.Types.CBlkCnt
instance GHC.Bits.FiniteBits System.Posix.Types.CBlkCnt
instance GHC.Bits.Bits System.Posix.Types.CBlkCnt
instance GHC.Real.Integral System.Posix.Types.CBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CBlkCnt
instance GHC.Real.Real System.Posix.Types.CBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CBlkCnt
instance GHC.Num.Num System.Posix.Types.CBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CBlkCnt
instance GHC.Show.Show System.Posix.Types.CBlkCnt
instance GHC.Read.Read System.Posix.Types.CBlkCnt
instance GHC.Ix.Ix System.Posix.Types.CClockId
instance GHC.Bits.FiniteBits System.Posix.Types.CClockId
instance GHC.Bits.Bits System.Posix.Types.CClockId
instance GHC.Real.Integral System.Posix.Types.CClockId
instance GHC.Enum.Bounded System.Posix.Types.CClockId
instance GHC.Real.Real System.Posix.Types.CClockId
instance Foreign.Storable.Storable System.Posix.Types.CClockId
instance GHC.Enum.Enum System.Posix.Types.CClockId
instance GHC.Num.Num System.Posix.Types.CClockId
instance GHC.Classes.Ord System.Posix.Types.CClockId
instance GHC.Classes.Eq System.Posix.Types.CClockId
instance GHC.Show.Show System.Posix.Types.CClockId
instance GHC.Read.Read System.Posix.Types.CClockId
instance GHC.Ix.Ix System.Posix.Types.CFsBlkCnt
instance GHC.Bits.FiniteBits System.Posix.Types.CFsBlkCnt
instance GHC.Bits.Bits System.Posix.Types.CFsBlkCnt
instance GHC.Real.Integral System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsBlkCnt
instance GHC.Real.Real System.Posix.Types.CFsBlkCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsBlkCnt
instance GHC.Enum.Enum System.Posix.Types.CFsBlkCnt
instance GHC.Num.Num System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Ord System.Posix.Types.CFsBlkCnt
instance GHC.Classes.Eq System.Posix.Types.CFsBlkCnt
instance GHC.Show.Show System.Posix.Types.CFsBlkCnt
instance GHC.Read.Read System.Posix.Types.CFsBlkCnt
instance GHC.Ix.Ix System.Posix.Types.CFsFilCnt
instance GHC.Bits.FiniteBits System.Posix.Types.CFsFilCnt
instance GHC.Bits.Bits System.Posix.Types.CFsFilCnt
instance GHC.Real.Integral System.Posix.Types.CFsFilCnt
instance GHC.Enum.Bounded System.Posix.Types.CFsFilCnt
instance GHC.Real.Real System.Posix.Types.CFsFilCnt
instance Foreign.Storable.Storable System.Posix.Types.CFsFilCnt
instance GHC.Enum.Enum System.Posix.Types.CFsFilCnt
instance GHC.Num.Num System.Posix.Types.CFsFilCnt
instance GHC.Classes.Ord System.Posix.Types.CFsFilCnt
instance GHC.Classes.Eq System.Posix.Types.CFsFilCnt
instance GHC.Show.Show System.Posix.Types.CFsFilCnt
instance GHC.Read.Read System.Posix.Types.CFsFilCnt
instance GHC.Ix.Ix System.Posix.Types.CId
instance GHC.Bits.FiniteBits System.Posix.Types.CId
instance GHC.Bits.Bits System.Posix.Types.CId
instance GHC.Real.Integral System.Posix.Types.CId
instance GHC.Enum.Bounded System.Posix.Types.CId
instance GHC.Real.Real System.Posix.Types.CId
instance Foreign.Storable.Storable System.Posix.Types.CId
instance GHC.Enum.Enum System.Posix.Types.CId
instance GHC.Num.Num System.Posix.Types.CId
instance GHC.Classes.Ord System.Posix.Types.CId
instance GHC.Classes.Eq System.Posix.Types.CId
instance GHC.Show.Show System.Posix.Types.CId
instance GHC.Read.Read System.Posix.Types.CId
instance GHC.Ix.Ix System.Posix.Types.CKey
instance GHC.Bits.FiniteBits System.Posix.Types.CKey
instance GHC.Bits.Bits System.Posix.Types.CKey
instance GHC.Real.Integral System.Posix.Types.CKey
instance GHC.Enum.Bounded System.Posix.Types.CKey
instance GHC.Real.Real System.Posix.Types.CKey
instance Foreign.Storable.Storable System.Posix.Types.CKey
instance GHC.Enum.Enum System.Posix.Types.CKey
instance GHC.Num.Num System.Posix.Types.CKey
instance GHC.Classes.Ord System.Posix.Types.CKey
instance GHC.Classes.Eq System.Posix.Types.CKey
instance GHC.Show.Show System.Posix.Types.CKey
instance GHC.Read.Read System.Posix.Types.CKey
instance Foreign.Storable.Storable System.Posix.Types.CTimer
instance GHC.Classes.Ord System.Posix.Types.CTimer
instance GHC.Classes.Eq System.Posix.Types.CTimer
instance GHC.Show.Show System.Posix.Types.CTimer
instance GHC.Ix.Ix System.Posix.Types.CSocklen
instance GHC.Bits.FiniteBits System.Posix.Types.CSocklen
instance GHC.Bits.Bits System.Posix.Types.CSocklen
instance GHC.Real.Integral System.Posix.Types.CSocklen
instance GHC.Enum.Bounded System.Posix.Types.CSocklen
instance GHC.Real.Real System.Posix.Types.CSocklen
instance Foreign.Storable.Storable System.Posix.Types.CSocklen
instance GHC.Enum.Enum System.Posix.Types.CSocklen
instance GHC.Num.Num System.Posix.Types.CSocklen
instance GHC.Classes.Ord System.Posix.Types.CSocklen
instance GHC.Classes.Eq System.Posix.Types.CSocklen
instance GHC.Show.Show System.Posix.Types.CSocklen
instance GHC.Read.Read System.Posix.Types.CSocklen
instance GHC.Ix.Ix System.Posix.Types.CNfds
instance GHC.Bits.FiniteBits System.Posix.Types.CNfds
instance GHC.Bits.Bits System.Posix.Types.CNfds
instance GHC.Real.Integral System.Posix.Types.CNfds
instance GHC.Enum.Bounded System.Posix.Types.CNfds
instance GHC.Real.Real System.Posix.Types.CNfds
instance Foreign.Storable.Storable System.Posix.Types.CNfds
instance GHC.Enum.Enum System.Posix.Types.CNfds
instance GHC.Num.Num System.Posix.Types.CNfds
instance GHC.Classes.Ord System.Posix.Types.CNfds
instance GHC.Classes.Eq System.Posix.Types.CNfds
instance GHC.Show.Show System.Posix.Types.CNfds
instance GHC.Read.Read System.Posix.Types.CNfds
instance GHC.Ix.Ix System.Posix.Types.Fd
instance GHC.Bits.FiniteBits System.Posix.Types.Fd
instance GHC.Bits.Bits System.Posix.Types.Fd
instance GHC.Real.Integral System.Posix.Types.Fd
instance GHC.Enum.Bounded System.Posix.Types.Fd
instance GHC.Real.Real System.Posix.Types.Fd
instance Foreign.Storable.Storable System.Posix.Types.Fd
instance GHC.Enum.Enum System.Posix.Types.Fd
instance GHC.Num.Num System.Posix.Types.Fd
instance GHC.Classes.Ord System.Posix.Types.Fd
instance GHC.Classes.Eq System.Posix.Types.Fd
instance GHC.Show.Show System.Posix.Types.Fd
instance GHC.Read.Read System.Posix.Types.Fd


-- | POSIX support layer for the standard libraries. This library is built
--   on *every* platform, including Win32.
--   
--   Non-posix compliant in order to support the following features: *
--   S_ISSOCK (no sockets in POSIX)
module System.Posix.Internals
puts :: String -> IO ()
data {-# CTYPE "struct flock" #-} CFLock
data {-# CTYPE "struct group" #-} CGroup
data {-# CTYPE "struct lconv" #-} CLconv
data {-# CTYPE "struct passwd" #-} CPasswd
data {-# CTYPE "struct sigaction" #-} CSigaction
data {-# CTYPE "sigset_t" #-} CSigset
data {-# CTYPE "struct stat" #-} CStat
data {-# CTYPE "struct termios" #-} CTermios
data {-# CTYPE "struct tm" #-} CTm
data {-# CTYPE "struct tms" #-} CTms
data {-# CTYPE "struct utimbuf" #-} CUtimbuf
data {-# CTYPE "struct utsname" #-} CUtsname
type FD = CInt
fdFileSize :: FD -> IO Integer
fileType :: FilePath -> IO IODeviceType
fdStat :: FD -> IO (IODeviceType, CDev, CIno)
fdType :: FD -> IO IODeviceType
statGetType :: Ptr CStat -> IO IODeviceType
ioe_unknownfiletype :: IOException
fdGetMode :: FD -> IO IOMode
withFilePath :: FilePath -> (CString -> IO a) -> IO a
newFilePath :: FilePath -> IO CString
peekFilePath :: CString -> IO FilePath
peekFilePathLen :: CStringLen -> IO FilePath
setEcho :: FD -> Bool -> IO ()
getEcho :: FD -> IO Bool
setCooked :: FD -> Bool -> IO ()
tcSetAttr :: FD -> (Ptr CTermios -> IO a) -> IO a
get_saved_termios :: CInt -> IO (Ptr CTermios)
set_saved_termios :: CInt -> Ptr CTermios -> IO ()
setNonBlockingFD :: FD -> Bool -> IO ()
setCloseOnExec :: FD -> IO ()
type CFilePath = CString

-- | The same as <a>c_safe_open</a>, but an <i>interruptible operation</i>
--   as described in <a>Control.Exception</a>—it respects
--   <a>uninterruptibleMask</a> but not <a>mask</a>.
--   
--   We want to be able to interrupt an openFile call if it's expensive
--   (NFS, FUSE, etc.), and we especially need to be able to interrupt a
--   blocking open call. See #17912.
c_interruptible_open :: CFilePath -> CInt -> CMode -> IO CInt
c_safe_open :: CFilePath -> CInt -> CMode -> IO CInt

-- | Consult the RTS to find whether it is threaded.
hostIsThreaded :: Bool
c_open :: CFilePath -> CInt -> CMode -> IO CInt

c_interruptible_open_ :: CFilePath -> CInt -> CMode -> IO CInt

rtsIsThreaded_ :: Int
c_safe_open_ :: CFilePath -> CInt -> CMode -> IO CInt
c_fstat :: CInt -> Ptr CStat -> IO CInt
lstat :: CFilePath -> Ptr CStat -> IO CInt
c_read :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_safe_read :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_umask :: CMode -> IO CMode
c_write :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_safe_write :: CInt -> Ptr Word8 -> CSize -> IO CSsize
c_pipe :: Ptr CInt -> IO CInt
c_lseek :: CInt -> COff -> CInt -> IO COff
c_access :: CString -> CInt -> IO CInt
c_chmod :: CString -> CMode -> IO CInt
c_close :: CInt -> IO CInt
c_creat :: CString -> CMode -> IO CInt
c_dup :: CInt -> IO CInt
c_dup2 :: CInt -> CInt -> IO CInt
c_isatty :: CInt -> IO CInt
c_unlink :: CString -> IO CInt
c_utime :: CString -> Ptr CUtimbuf -> IO CInt
c_getpid :: IO CPid
c_stat :: CFilePath -> Ptr CStat -> IO CInt
c_ftruncate :: CInt -> COff -> IO CInt
c_fcntl_read :: CInt -> CInt -> IO CInt
c_fcntl_write :: CInt -> CInt -> CLong -> IO CInt
c_fcntl_lock :: CInt -> CInt -> Ptr CFLock -> IO CInt
c_fork :: IO CPid
c_link :: CString -> CString -> IO CInt
c_mkfifo :: CString -> CMode -> IO CInt
c_sigemptyset :: Ptr CSigset -> IO CInt
c_sigaddset :: Ptr CSigset -> CInt -> IO CInt
c_sigprocmask :: CInt -> Ptr CSigset -> Ptr CSigset -> IO CInt
c_tcgetattr :: CInt -> Ptr CTermios -> IO CInt
c_tcsetattr :: CInt -> CInt -> Ptr CTermios -> IO CInt
c_waitpid :: CPid -> Ptr CInt -> CInt -> IO CPid
o_RDONLY :: CInt
o_WRONLY :: CInt
o_RDWR :: CInt
o_APPEND :: CInt
o_CREAT :: CInt
o_EXCL :: CInt
o_TRUNC :: CInt
o_NOCTTY :: CInt
o_NONBLOCK :: CInt
o_BINARY :: CInt
c_s_isreg :: CMode -> CInt
c_s_ischr :: CMode -> CInt
c_s_isblk :: CMode -> CInt
c_s_isdir :: CMode -> CInt
c_s_isfifo :: CMode -> CInt
s_isreg :: CMode -> Bool
s_ischr :: CMode -> Bool
s_isblk :: CMode -> Bool
s_isdir :: CMode -> Bool
s_isfifo :: CMode -> Bool
sizeof_stat :: Int
st_mtime :: Ptr CStat -> IO CTime
st_size :: Ptr CStat -> IO COff
st_mode :: Ptr CStat -> IO CMode
st_dev :: Ptr CStat -> IO CDev
st_ino :: Ptr CStat -> IO CIno
const_echo :: CInt
const_tcsanow :: CInt
const_icanon :: CInt
const_vmin :: CInt
const_vtime :: CInt
const_sigttou :: CInt
const_sig_block :: CInt
const_sig_setmask :: CInt
const_f_getfl :: CInt
const_f_setfl :: CInt
const_f_setfd :: CInt
const_fd_cloexec :: CLong
sizeof_termios :: Int
sizeof_sigset_t :: Int
c_lflag :: Ptr CTermios -> IO CTcflag
poke_c_lflag :: Ptr CTermios -> CTcflag -> IO ()
ptr_c_cc :: Ptr CTermios -> IO (Ptr Word8)
s_issock :: CMode -> Bool
c_s_issock :: CMode -> CInt
dEFAULT_BUFFER_SIZE :: Int
sEEK_CUR :: CInt
sEEK_SET :: CInt
sEEK_END :: CInt


-- | Accessors to GHC RTS flags. Descriptions of flags can be seen in
--   <a>GHC User's Guide</a>, or by running RTS help message using <tt>+RTS
--   --help</tt>.
module GHC.RTS.Flags

-- | <a>RtsTime</a> is defined as a <tt>StgWord64</tt> in
--   <tt>stg/Types.h</tt>
type RtsTime = Word64

-- | Parameters of the runtime system
data RTSFlags
RTSFlags :: GCFlags -> ConcFlags -> MiscFlags -> DebugFlags -> CCFlags -> ProfFlags -> TraceFlags -> TickyFlags -> ParFlags -> RTSFlags
[gcFlags] :: RTSFlags -> GCFlags
[concurrentFlags] :: RTSFlags -> ConcFlags
[miscFlags] :: RTSFlags -> MiscFlags
[debugFlags] :: RTSFlags -> DebugFlags
[costCentreFlags] :: RTSFlags -> CCFlags
[profilingFlags] :: RTSFlags -> ProfFlags
[traceFlags] :: RTSFlags -> TraceFlags
[tickyFlags] :: RTSFlags -> TickyFlags
[parFlags] :: RTSFlags -> ParFlags

-- | Should we produce a summary of the garbage collector statistics after
--   the program has exited?
data GiveGCStats
NoGCStats :: GiveGCStats
CollectGCStats :: GiveGCStats
OneLineGCStats :: GiveGCStats
SummaryGCStats :: GiveGCStats
VerboseGCStats :: GiveGCStats

-- | Parameters of the garbage collector.
data GCFlags
GCFlags :: Maybe FilePath -> GiveGCStats -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Bool -> Double -> Double -> Double -> Word32 -> Bool -> Bool -> Double -> Bool -> Bool -> RtsTime -> Bool -> Word -> Word -> Bool -> Word -> GCFlags
[statsFile] :: GCFlags -> Maybe FilePath
[giveStats] :: GCFlags -> GiveGCStats
[maxStkSize] :: GCFlags -> Word32
[initialStkSize] :: GCFlags -> Word32
[stkChunkSize] :: GCFlags -> Word32
[stkChunkBufferSize] :: GCFlags -> Word32
[maxHeapSize] :: GCFlags -> Word32
[minAllocAreaSize] :: GCFlags -> Word32
[largeAllocLim] :: GCFlags -> Word32
[nurseryChunkSize] :: GCFlags -> Word32
[minOldGenSize] :: GCFlags -> Word32
[heapSizeSuggestion] :: GCFlags -> Word32
[heapSizeSuggestionAuto] :: GCFlags -> Bool
[oldGenFactor] :: GCFlags -> Double
[returnDecayFactor] :: GCFlags -> Double
[pcFreeHeap] :: GCFlags -> Double
[generations] :: GCFlags -> Word32
[squeezeUpdFrames] :: GCFlags -> Bool

-- | True <a>=</a> "compact all the time"
[compact] :: GCFlags -> Bool
[compactThreshold] :: GCFlags -> Double

-- | use "mostly mark-sweep" instead of copying for the oldest generation
[sweep] :: GCFlags -> Bool
[ringBell] :: GCFlags -> Bool
[idleGCDelayTime] :: GCFlags -> RtsTime
[doIdleGC] :: GCFlags -> Bool

-- | address to ask the OS for memory
[heapBase] :: GCFlags -> Word
[allocLimitGrace] :: GCFlags -> Word
[numa] :: GCFlags -> Bool
[numaMask] :: GCFlags -> Word

-- | Parameters concerning context switching
data ConcFlags
ConcFlags :: RtsTime -> Int -> ConcFlags
[ctxtSwitchTime] :: ConcFlags -> RtsTime
[ctxtSwitchTicks] :: ConcFlags -> Int

-- | Miscellaneous parameters
data MiscFlags
MiscFlags :: RtsTime -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Word -> IoSubSystem -> Word32 -> MiscFlags
[tickInterval] :: MiscFlags -> RtsTime
[installSignalHandlers] :: MiscFlags -> Bool
[installSEHHandlers] :: MiscFlags -> Bool
[generateCrashDumpFile] :: MiscFlags -> Bool
[generateStackTrace] :: MiscFlags -> Bool
[machineReadable] :: MiscFlags -> Bool
[disableDelayedOsMemoryReturn] :: MiscFlags -> Bool
[internalCounters] :: MiscFlags -> Bool
[linkerAlwaysPic] :: MiscFlags -> Bool

-- | address to ask the OS for memory for the linker, 0 ==&gt; off
[linkerMemBase] :: MiscFlags -> Word
[ioManager] :: MiscFlags -> IoSubSystem
[numIoWorkerThreads] :: MiscFlags -> Word32

-- | Flags to control debugging output &amp; extra checking in various
--   subsystems.
data DebugFlags
DebugFlags :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> DebugFlags

-- | <pre>
--   s
--   </pre>
[scheduler] :: DebugFlags -> Bool

-- | <pre>
--   i
--   </pre>
[interpreter] :: DebugFlags -> Bool

-- | <pre>
--   w
--   </pre>
[weak] :: DebugFlags -> Bool

-- | <pre>
--   G
--   </pre>
[gccafs] :: DebugFlags -> Bool

-- | <pre>
--   g
--   </pre>
[gc] :: DebugFlags -> Bool

-- | <pre>
--   n
--   </pre>
[nonmoving_gc] :: DebugFlags -> Bool

-- | <pre>
--   b
--   </pre>
[block_alloc] :: DebugFlags -> Bool

-- | <pre>
--   S
--   </pre>
[sanity] :: DebugFlags -> Bool

-- | <pre>
--   t
--   </pre>
[stable] :: DebugFlags -> Bool

-- | <pre>
--   p
--   </pre>
[prof] :: DebugFlags -> Bool

-- | <tt>l</tt> the object linker
[linker] :: DebugFlags -> Bool

-- | <pre>
--   a
--   </pre>
[apply] :: DebugFlags -> Bool

-- | <pre>
--   m
--   </pre>
[stm] :: DebugFlags -> Bool

-- | <tt>z</tt> stack squeezing &amp; lazy blackholing
[squeeze] :: DebugFlags -> Bool

-- | <tt>c</tt> coverage
[hpc] :: DebugFlags -> Bool

-- | <pre>
--   r
--   </pre>
[sparks] :: DebugFlags -> Bool

-- | Should the RTS produce a cost-center summary?
data DoCostCentres
CostCentresNone :: DoCostCentres
CostCentresSummary :: DoCostCentres
CostCentresVerbose :: DoCostCentres
CostCentresAll :: DoCostCentres
CostCentresJSON :: DoCostCentres

-- | Parameters pertaining to the cost-center profiler.
data CCFlags
CCFlags :: DoCostCentres -> Int -> Int -> CCFlags
[doCostCentres] :: CCFlags -> DoCostCentres
[profilerTicks] :: CCFlags -> Int
[msecsPerTick] :: CCFlags -> Int

-- | What sort of heap profile are we collecting?
data DoHeapProfile
NoHeapProfiling :: DoHeapProfile
HeapByCCS :: DoHeapProfile
HeapByMod :: DoHeapProfile
HeapByDescr :: DoHeapProfile
HeapByType :: DoHeapProfile
HeapByRetainer :: DoHeapProfile
HeapByLDV :: DoHeapProfile
HeapByClosureType :: DoHeapProfile
HeapByInfoTable :: DoHeapProfile

-- | Parameters of the cost-center profiler
data ProfFlags
ProfFlags :: DoHeapProfile -> RtsTime -> Word -> Bool -> Bool -> Word -> Word -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> ProfFlags
[doHeapProfile] :: ProfFlags -> DoHeapProfile

-- | time between samples
[heapProfileInterval] :: ProfFlags -> RtsTime

-- | ticks between samples (derived)
[heapProfileIntervalTicks] :: ProfFlags -> Word
[startHeapProfileAtStartup] :: ProfFlags -> Bool
[showCCSOnException] :: ProfFlags -> Bool
[maxRetainerSetSize] :: ProfFlags -> Word
[ccsLength] :: ProfFlags -> Word
[modSelector] :: ProfFlags -> Maybe String
[descrSelector] :: ProfFlags -> Maybe String
[typeSelector] :: ProfFlags -> Maybe String
[ccSelector] :: ProfFlags -> Maybe String
[ccsSelector] :: ProfFlags -> Maybe String
[retainerSelector] :: ProfFlags -> Maybe String
[bioSelector] :: ProfFlags -> Maybe String

-- | Is event tracing enabled?
data DoTrace

-- | no tracing
TraceNone :: DoTrace

-- | send tracing events to the event log
TraceEventLog :: DoTrace

-- | send tracing events to <tt>stderr</tt>
TraceStderr :: DoTrace

-- | Parameters pertaining to event tracing
data TraceFlags
TraceFlags :: DoTrace -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> TraceFlags
[tracing] :: TraceFlags -> DoTrace

-- | show timestamp in stderr output
[timestamp] :: TraceFlags -> Bool

-- | trace scheduler events
[traceScheduler] :: TraceFlags -> Bool

-- | trace GC events
[traceGc] :: TraceFlags -> Bool

-- | trace nonmoving GC heap census samples
[traceNonmovingGc] :: TraceFlags -> Bool

-- | trace spark events by a sampled method
[sparksSampled] :: TraceFlags -> Bool

-- | trace spark events 100% accurately
[sparksFull] :: TraceFlags -> Bool

-- | trace user events (emitted from Haskell code)
[user] :: TraceFlags -> Bool

-- | Parameters pertaining to ticky-ticky profiler
data TickyFlags
TickyFlags :: Bool -> Maybe FilePath -> TickyFlags
[showTickyStats] :: TickyFlags -> Bool
[tickyFile] :: TickyFlags -> Maybe FilePath

-- | Parameters pertaining to parallelism
data ParFlags
ParFlags :: Word32 -> Bool -> Word32 -> Bool -> Word32 -> Bool -> Word32 -> Word32 -> Word32 -> Bool -> ParFlags
[nCapabilities] :: ParFlags -> Word32
[migrate] :: ParFlags -> Bool
[maxLocalSparks] :: ParFlags -> Word32
[parGcEnabled] :: ParFlags -> Bool
[parGcGen] :: ParFlags -> Word32
[parGcLoadBalancingEnabled] :: ParFlags -> Bool
[parGcLoadBalancingGen] :: ParFlags -> Word32
[parGcNoSyncWithIdle] :: ParFlags -> Word32
[parGcThreads] :: ParFlags -> Word32
[setAffinity] :: ParFlags -> Bool

-- | The I/O SubSystem to use in the program.
data IoSubSystem

-- | Use a POSIX I/O Sub-System
IoPOSIX :: IoSubSystem

-- | Use platform native Sub-System. For unix OSes this is the same as
--   IoPOSIX, but on Windows this means use the Windows native APIs for
--   I/O, including IOCP and RIO.
IoNative :: IoSubSystem
getRTSFlags :: IO RTSFlags
getGCFlags :: IO GCFlags
getConcFlags :: IO ConcFlags
getMiscFlags :: IO MiscFlags

-- | Needed to optimize support for different IO Managers on Windows. See
--   Note [The need for getIoManagerFlag]
getIoManagerFlag :: IO IoSubSystem
getDebugFlags :: IO DebugFlags
getCCFlags :: IO CCFlags
getProfFlags :: IO ProfFlags
getTraceFlags :: IO TraceFlags
getTickyFlags :: IO TickyFlags
getParFlags :: IO ParFlags
instance GHC.Generics.Generic GHC.RTS.Flags.GiveGCStats
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats
instance GHC.Show.Show GHC.RTS.Flags.IoSubSystem
instance GHC.Classes.Eq GHC.RTS.Flags.IoSubSystem
instance GHC.Generics.Generic GHC.RTS.Flags.GCFlags
instance GHC.Show.Show GHC.RTS.Flags.GCFlags
instance GHC.Generics.Generic GHC.RTS.Flags.ConcFlags
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags
instance GHC.Generics.Generic GHC.RTS.Flags.MiscFlags
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags
instance GHC.Generics.Generic GHC.RTS.Flags.DebugFlags
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags
instance GHC.Generics.Generic GHC.RTS.Flags.DoCostCentres
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres
instance GHC.Generics.Generic GHC.RTS.Flags.CCFlags
instance GHC.Show.Show GHC.RTS.Flags.CCFlags
instance GHC.Generics.Generic GHC.RTS.Flags.DoHeapProfile
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile
instance GHC.Generics.Generic GHC.RTS.Flags.ProfFlags
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags
instance GHC.Generics.Generic GHC.RTS.Flags.DoTrace
instance GHC.Show.Show GHC.RTS.Flags.DoTrace
instance GHC.Generics.Generic GHC.RTS.Flags.TraceFlags
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags
instance GHC.Generics.Generic GHC.RTS.Flags.TickyFlags
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags
instance GHC.Generics.Generic GHC.RTS.Flags.ParFlags
instance GHC.Show.Show GHC.RTS.Flags.ParFlags
instance GHC.Generics.Generic GHC.RTS.Flags.RTSFlags
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres
instance GHC.Enum.Enum GHC.RTS.Flags.IoSubSystem
instance Foreign.Storable.Storable GHC.RTS.Flags.IoSubSystem
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats


-- | The SubSystem control interface. These methods can be used to
--   disambiguate between the two operations.
module GHC.IO.SubSystem
withIoSubSystem :: (IoSubSystem -> IO a) -> IO a
withIoSubSystem' :: (IoSubSystem -> a) -> a
whenIoSubSystem :: IoSubSystem -> IO () -> IO ()
ioSubSystem :: IoSubSystem

-- | The I/O SubSystem to use in the program.
data IoSubSystem

-- | Use a POSIX I/O Sub-System
IoPOSIX :: IoSubSystem

-- | Use platform native Sub-System. For unix OSes this is the same as
--   IoPOSIX, but on Windows this means use the Windows native APIs for
--   I/O, including IOCP and RIO.
IoNative :: IoSubSystem

-- | Conditionally execute an action depending on the configured I/O
--   subsystem. On POSIX systems always execute the first action. On
--   windows execute the second action if WINIO as active, otherwise fall
--   back to the first action.
conditional :: a -> a -> a

-- | Infix version of <a>conditional</a>. posix <a>!</a> windows ==
--   conditional posix windows
(<!>) :: a -> a -> a
infixl 7 <!>
isWindowsNativeIO :: Bool


-- | The Dynamic interface provides basic support for dynamic types.
--   
--   Operations for injecting values of arbitrary type into a dynamically
--   typed value, Dynamic, are provided, together with operations for
--   converting dynamic values into a concrete (monomorphic) type.
module Data.Dynamic

-- | A value of type <a>Dynamic</a> is an object encapsulated together with
--   its type.
--   
--   A <a>Dynamic</a> may only represent a monomorphic value; an attempt to
--   create a value of type <a>Dynamic</a> from a polymorphically-typed
--   expression will result in an ambiguity error (see <a>toDyn</a>).
--   
--   <a>Show</a>ing a value of type <a>Dynamic</a> returns a pretty-printed
--   representation of the object's type; useful for debugging.
data Dynamic
[Dynamic] :: forall a. TypeRep a -> a -> Dynamic

-- | Converts an arbitrary value into an object of type <a>Dynamic</a>.
--   
--   The type of the object must be an instance of <a>Typeable</a>, which
--   ensures that only monomorphically-typed objects may be converted to
--   <a>Dynamic</a>. To convert a polymorphic object into <a>Dynamic</a>,
--   give it a monomorphic type signature. For example:
--   
--   <pre>
--   toDyn (id :: Int -&gt; Int)
--   </pre>
toDyn :: Typeable a => a -> Dynamic

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDynamic</a>.
fromDyn :: Typeable a => Dynamic -> a -> a

-- | Converts a <a>Dynamic</a> object back into an ordinary Haskell value
--   of the correct type. See also <a>fromDyn</a>.
fromDynamic :: forall a. Typeable a => Dynamic -> Maybe a
dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
dynApp :: Dynamic -> Dynamic -> Dynamic
dynTypeRep :: Dynamic -> SomeTypeRep

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
instance GHC.Show.Show Data.Dynamic.Dynamic
instance GHC.Exception.Type.Exception Data.Dynamic.Dynamic


-- | Basic concurrency stuff.
module GHC.Conc.Sync

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId
showThreadId :: ThreadId -> String

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread. This
--   identifier will be used in the debugging output to make distinction of
--   different threads easier (otherwise you only have the thread state
--   object's address in the heap). It also emits an event to the RTS
--   eventlog.
labelThread :: ThreadId -> String -> IO ()

-- | <a>labelThreadByteArray#</a> sets the label of a thread to the given
--   UTF-8 encoded string contained in a <a>ByteArray#</a>.
labelThreadByteArray# :: ThreadId -> ByteArray# -> IO ()

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | List the Haskell threads of the current process.
listThreads :: IO [ThreadId]

-- | Query the label of thread, returning <a>Nothing</a> if the thread's
--   label has not been set.
threadLabel :: ThreadId -> IO (Maybe String)

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <a>threadDelay</a> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason

-- | Query the current execution status of a thread.
threadStatus :: ThreadId -> IO ThreadStatus

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
--   
--   WARNING: Exceptions in the new thread will not be rethrown in the
--   thread that created it. This means that you might be completely
--   unaware of the problem if/when this happens. You may want to use the
--   <a>async</a> library instead.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | Make a <a>StablePtr</a> that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar a -> IO (StablePtr PrimMVar)
data PrimMVar

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   Using <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a> subverts some of guarantees that STM
--   provides. It makes it possible to run a transaction inside of another
--   transaction, depending on when the thunk is evaluated. If a nested
--   transaction is attempted, an exception is thrown by the runtime. It is
--   possible to safely use <a>atomically</a> inside <a>unsafePerformIO</a>
--   or <a>unsafeInterleaveIO</a>, but the typechecker does not rule out
--   programs that may attempt nested transactions, meaning that the
--   programmer must take special care to prevent these.
--   
--   However, there are functions for creating transactional variables that
--   can always be safely called in <a>unsafePerformIO</a>. See:
--   <a>newTVarIO</a>, <a>newTChanIO</a>, <a>newBroadcastTChanIO</a>,
--   <a>newTQueueIO</a>, <a>newTBQueueIO</a>, and <a>newTMVarIO</a>.
--   
--   Using <a>unsafePerformIO</a> inside of <a>atomically</a> is also
--   dangerous but for different reasons. See <a>unsafeIOToSTM</a> for more
--   on this.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception. If the exception is caught via
--   <a>catchSTM</a>, only the changes enclosed by the catch are rolled
--   back; changes made outside of <a>catchSTM</a> persist.
--   
--   If the exception is not caught inside of the <a>STM</a>, it is
--   re-thrown by <a>atomically</a>, and the entire <a>STM</a> is rolled
--   back.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
--   
--   <tt><a>catchSTM</a> m f</tt> catches any exception thrown by
--   <tt>m</tt> using <a>throwSTM</a>, using the function <tt>f</tt> to
--   handle the exception. If an exception is thrown, any changes made by
--   <tt>m</tt> are rolled back, but changes prior to <tt>m</tt> persist.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: TVar# RealWorld a -> TVar a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Return the current value stored in a <a>TVar</a>. This is equivalent
--   to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a

-- | Provide an <a>IO</a> action with the current value of an <a>MVar</a>.
--   The <a>MVar</a> will be empty for the duration that the action is
--   running.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Modify the value of an <a>MVar</a>.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()
sharedCAF :: a -> (Ptr a -> IO (Ptr a)) -> IO a
instance GHC.Show.Show GHC.Conc.Sync.BlockReason
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus
instance GHC.Classes.Eq (GHC.Conc.Sync.TVar a)
instance GHC.Base.Functor GHC.Conc.Sync.STM
instance GHC.Base.Applicative GHC.Conc.Sync.STM
instance GHC.Base.Monad GHC.Conc.Sync.STM
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Conc.Sync.STM a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Conc.Sync.STM a)
instance GHC.Base.Alternative GHC.Conc.Sync.STM
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM
instance GHC.Show.Show GHC.Conc.Sync.ThreadId
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId


-- | Extensible exceptions, except for multiple handlers.
module Control.Exception.Base

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The exception thrown when an infinite cycle is detected in
--   <a>fixIO</a>.
data FixIOException
FixIOException :: FixIOException

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | Thrown when the program attempts a continuation capture, but no prompt
--   with the given prompt tag exists in the current continuation.
data NoMatchingContinuationPrompt
NoMatchingContinuationPrompt :: NoMatchingContinuationPrompt

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a
recSelError :: Addr# -> a
recConError :: Addr# -> a
impossibleError :: Addr# -> a
impossibleConstraintError :: Addr# -> a
nonExhaustiveGuardsError :: Addr# -> a
patError :: Addr# -> a
noMethodBindingError :: Addr# -> a
typeError :: Addr# -> a
nonTermination :: SomeException
nestedAtomically :: SomeException
noMatchingContinuationPrompt :: SomeException
instance GHC.Show.Show Control.Exception.Base.NoMatchingContinuationPrompt
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMatchingContinuationPrompt
instance GHC.Show.Show Control.Exception.Base.NestedAtomically
instance GHC.Exception.Type.Exception Control.Exception.Base.NestedAtomically
instance GHC.Show.Show Control.Exception.Base.NonTermination
instance GHC.Exception.Type.Exception Control.Exception.Base.NonTermination
instance GHC.Show.Show Control.Exception.Base.TypeError
instance GHC.Exception.Type.Exception Control.Exception.Base.TypeError
instance GHC.Show.Show Control.Exception.Base.NoMethodError
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMethodError
instance GHC.Show.Show Control.Exception.Base.RecUpdError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecUpdError
instance GHC.Show.Show Control.Exception.Base.RecConError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecConError
instance GHC.Show.Show Control.Exception.Base.RecSelError
instance GHC.Exception.Type.Exception Control.Exception.Base.RecSelError
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail
instance GHC.Exception.Type.Exception Control.Exception.Base.PatternMatchFail


-- | Standard IO Errors.
module System.IO.Error

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Construct an <a>IOException</a> of the given type where the second
--   argument describes the error location and the third and fourth
--   argument contain the file handle and file path of the file involved in
--   the error if applicable.
mkIOError :: IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | Adds a location description and maybe a file path and file handle to
--   an <a>IOException</a>. If any of the file handle or file path is not
--   given the corresponding value in the <a>IOException</a> remains
--   unaltered.
annotateIOError :: IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments already exists.
isAlreadyExistsError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments does not exist.
isDoesNotExistError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because one of
--   its arguments is a single-use resource, which is already being used
--   (for example, opening the same file twice for writing might give this
--   error).
isAlreadyInUseError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   device is full.
isFullError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the end
--   of file has been reached.
isEOFError :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   operation was not possible. Any computation which returns an <a>IO</a>
--   result may fail with <a>isIllegalOperation</a>. In some cases, an
--   implementation will not be able to distinguish between the possible
--   error causes. In this case it should fail with
--   <a>isIllegalOperation</a>.
isIllegalOperation :: IOError -> Bool

-- | An error indicating that an <a>IO</a> operation failed because the
--   user does not have sufficient operating system privilege to perform
--   that operation.
isPermissionError :: IOError -> Bool

-- | A programmer-defined error value constructed using <a>userError</a>.
isUserError :: IOError -> Bool

-- | An error indicating that the operation failed because the resource
--   vanished. See <a>resourceVanishedErrorType</a>.
isResourceVanishedError :: IOError -> Bool
ioeGetErrorType :: IOError -> IOErrorType
ioeGetLocation :: IOError -> String
ioeGetErrorString :: IOError -> String
ioeGetHandle :: IOError -> Maybe Handle
ioeGetFileName :: IOError -> Maybe FilePath
ioeSetErrorType :: IOError -> IOErrorType -> IOError
ioeSetErrorString :: IOError -> String -> IOError
ioeSetLocation :: IOError -> String -> IOError
ioeSetHandle :: IOError -> Handle -> IOError
ioeSetFileName :: IOError -> FilePath -> IOError

-- | An abstract type that contains a value for each variant of
--   <a>IOException</a>.
data IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
alreadyExistsErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
doesNotExistErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
alreadyInUseErrorType :: IOErrorType

-- | I/O error where the operation failed because the device is full.
fullErrorType :: IOErrorType

-- | I/O error where the operation failed because the end of file has been
--   reached.
eofErrorType :: IOErrorType

-- | I/O error where the operation is not possible.
illegalOperationErrorType :: IOErrorType

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
permissionErrorType :: IOErrorType

-- | I/O error that is programmer-defined.
userErrorType :: IOErrorType

-- | I/O error where the operation failed because the resource vanished.
--   This happens when, for example, attempting to write to a closed socket
--   or attempting to write to a named pipe that was deleted.
resourceVanishedErrorType :: IOErrorType

-- | I/O error where the operation failed because one of its arguments
--   already exists.
isAlreadyExistsErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments does
--   not exist.
isDoesNotExistErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because one of its arguments is a
--   single-use resource, which is already being used.
isAlreadyInUseErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the device is full.
isFullErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the end of file has been
--   reached.
isEOFErrorType :: IOErrorType -> Bool

-- | I/O error where the operation is not possible.
isIllegalOperationErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the user does not have
--   sufficient operating system privilege to perform that operation.
isPermissionErrorType :: IOErrorType -> Bool

-- | I/O error that is programmer-defined.
isUserErrorType :: IOErrorType -> Bool

-- | I/O error where the operation failed because the resource vanished.
--   See <a>resourceVanishedErrorType</a>.
isResourceVanishedErrorType :: IOErrorType -> Bool

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | The <a>catchIOError</a> function establishes a handler that receives
--   any <a>IOException</a> raised in the action protected by
--   <a>catchIOError</a>. An <a>IOException</a> is caught by the most
--   recent handler established by one of the exception handling functions.
--   These handlers are not selective: all <a>IOException</a>s are caught.
--   Exception propagation must be explicitly provided in a handler by
--   re-raising any unwanted exceptions. For example, in
--   
--   <pre>
--   f = catchIOError g (\e -&gt; if IO.isEOFError e then return [] else ioError e)
--   </pre>
--   
--   the function <tt>f</tt> returns <tt>[]</tt> when an end-of-file
--   exception (cf. <a>isEOFError</a>) occurs in <tt>g</tt>; otherwise, the
--   exception is propagated to the next outer handler.
--   
--   When an exception propagates outside the main program, the Haskell
--   system prints the associated <a>IOException</a> value and exits the
--   program.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>catch</a> from <a>Control.Exception</a>.
catchIOError :: IO a -> (IOError -> IO a) -> IO a

-- | The construct <a>tryIOError</a> <tt>comp</tt> exposes IO errors which
--   occur within a computation, and which are not fully handled.
--   
--   Non-I/O exceptions are not caught by this variant; to catch all
--   exceptions, use <a>try</a> from <a>Control.Exception</a>.
tryIOError :: IO a -> IO (Either IOError a)

-- | Catch any <a>IOException</a> that occurs in the computation and throw
--   a modified version.
modifyIOError :: (IOError -> IOError) -> IO a -> IO a


-- | This module provides support for raising and catching both built-in
--   and user-defined exceptions.
--   
--   In addition to exceptions thrown by <a>IO</a> operations, exceptions
--   may be thrown by pure code (imprecise exceptions) or by external
--   events (asynchronous exceptions), but may only be caught in the
--   <a>IO</a> monad. For more details, see:
--   
--   <ul>
--   <li><i>A semantics for imprecise exceptions</i>, by Simon Peyton
--   Jones, Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson, in
--   <i>PLDI'99</i>.</li>
--   <li><i>Asynchronous exceptions in Haskell</i>, by Simon Marlow, Simon
--   Peyton Jones, Andy Moran and John Reppy, in <i>PLDI'01</i>.</li>
--   <li><i>An Extensible Dynamically-Typed Hierarchy of Exceptions</i>, by
--   Simon Marlow, in <i>Haskell '06</i>.</li>
--   </ul>
module Control.Exception

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Arithmetic exceptions.
data ArithException
Overflow :: ArithException
Underflow :: ArithException
LossOfPrecision :: ArithException
DivideByZero :: ArithException
Denormal :: ArithException

RatioZeroDenominator :: ArithException

-- | Exceptions generated by array operations
data ArrayException

-- | An attempt was made to index an array outside its declared bounds.
IndexOutOfBounds :: String -> ArrayException

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
UndefinedElement :: String -> ArrayException

-- | <a>assert</a> was applied to <a>False</a>.
newtype AssertionFailed
AssertionFailed :: String -> AssertionFailed

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Asynchronous exceptions.
data AsyncException

-- | The current thread's stack exceeded its limit. Since an exception has
--   been raised, the thread's stack will certainly be below its limit
--   again, but the programmer should take remedial action immediately.
StackOverflow :: AsyncException

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has. Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this exception. GHC
--   currently throws this to the same thread that receives
--   <a>UserInterrupt</a>, but this may change in the future.</li>
--   <li>The GHC RTS currently can only recover from heap overflow if it
--   detects that an explicit memory limit (set via RTS flags). has been
--   exceeded. Currently, failure to allocate memory from the operating
--   system results in immediate termination of the program.</li>
--   </ul>
HeapOverflow :: AsyncException

-- | This exception is raised by another thread calling <a>killThread</a>,
--   or by the system if it needs to terminate the thread for some reason.
ThreadKilled :: AsyncException

-- | This exception is raised by default in the main thread of the program
--   when the user requests to terminate the program via the usual
--   mechanism(s) (e.g. Control-C in the console).
UserInterrupt :: AsyncException

asyncExceptionToException :: Exception e => e -> SomeException

asyncExceptionFromException :: Exception e => SomeException -> Maybe e

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
data NonTermination
NonTermination :: NonTermination

-- | Thrown when the program attempts to call <tt>atomically</tt>, from the
--   <tt>stm</tt> package, inside another call to <tt>atomically</tt>.
data NestedAtomically
NestedAtomically :: NestedAtomically

-- | The thread is blocked on an <tt>MVar</tt>, but there are no other
--   references to the <tt>MVar</tt> so it can't ever continue.
data BlockedIndefinitelyOnMVar
BlockedIndefinitelyOnMVar :: BlockedIndefinitelyOnMVar

-- | The thread is waiting to retry an STM transaction, but there are no
--   other references to any <tt>TVar</tt>s involved, so it can't ever
--   continue.
data BlockedIndefinitelyOnSTM
BlockedIndefinitelyOnSTM :: BlockedIndefinitelyOnSTM

-- | This thread has exceeded its allocation limit. See
--   <a>setAllocationCounter</a> and <a>enableAllocationLimit</a>.
data AllocationLimitExceeded
AllocationLimitExceeded :: AllocationLimitExceeded

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects. See
--   <a>compact</a>.
newtype CompactionFailed
CompactionFailed :: String -> CompactionFailed

-- | There are no runnable threads, so the program is deadlocked. The
--   <tt>Deadlock</tt> exception is raised in the main thread only.
data Deadlock
Deadlock :: Deadlock

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called. The
--   <tt>String</tt> gives information about which method it was.
newtype NoMethodError
NoMethodError :: String -> NoMethodError

-- | A pattern match failed. The <tt>String</tt> gives information about
--   the source location of the pattern.
newtype PatternMatchFail
PatternMatchFail :: String -> PatternMatchFail

-- | An uninitialised record field was used. The <tt>String</tt> gives
--   information about the source location where the record was
--   constructed.
newtype RecConError
RecConError :: String -> RecConError

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record selector.
newtype RecSelError
RecSelError :: String -> RecSelError

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another. The <tt>String</tt> gives information about the source
--   location of the record update.
newtype RecUpdError
RecUpdError :: String -> RecUpdError

-- | This is thrown when the user calls <a>error</a>. The first
--   <tt>String</tt> is the argument given to <a>error</a>, second
--   <tt>String</tt> is the location.
data ErrorCall
ErrorCallWithLocation :: String -> String -> ErrorCall
pattern ErrorCall :: String -> ErrorCall

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with -fdefer-type-errors. The <tt>String</tt>
--   gives details about the failed type check.
newtype TypeError
TypeError :: String -> TypeError

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep). forall (a :: TYPE r). forall e. Exception e => e -> a

-- | A variant of <a>throw</a> that can only be used within the <a>IO</a>
--   monad.
--   
--   Although <a>throwIO</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e   `seq` ()  ===&gt; throw e
--   throwIO e `seq` ()  ===&gt; ()
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwIO</a> will only cause
--   an exception to be raised when it is used within the <a>IO</a> monad.
--   
--   The <a>throwIO</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>IO</a> monad because
--   it guarantees ordering with respect to other operations, whereas
--   <a>throw</a> does not. We say that <a>throwIO</a> throws *precise*
--   exceptions and <a>throw</a>, <a>error</a>, etc. all throw *imprecise*
--   exceptions. For example
--   
--   <pre>
--   throw e + error "boom" ===&gt; error "boom"
--   throw e + error "boom" ===&gt; throw e
--   </pre>
--   
--   are both valid reductions and the compiler may pick any (loop, even),
--   whereas
--   
--   <pre>
--   throwIO e &gt;&gt; error "boom" ===&gt; throwIO e
--   </pre>
--   
--   will always throw <tt>e</tt> when executed.
--   
--   See also the <a>GHC wiki page on precise exceptions</a> for a more
--   technical introduction to how GHC optimises around precise vs.
--   imprecise exceptions.
throwIO :: Exception e => e -> IO a

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | This is the simplest of the exception-catching functions. It takes a
--   single argument, runs it, and if an exception is raised the "handler"
--   is executed, with the value of the exception passed as an argument.
--   Otherwise, the result is returned as normal. For example:
--   
--   <pre>
--   catch (readFile f)
--         (\e -&gt; do let err = show (e :: IOException)
--                   hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
--                   return "")
--   </pre>
--   
--   Note that we have to give a type signature to <tt>e</tt>, or the
--   program will not typecheck as the type is ambiguous. While it is
--   possible to catch exceptions of any type, see the section "Catching
--   all exceptions" (in <a>Control.Exception</a>) for an explanation of
--   the problems with doing so.
--   
--   For catching exceptions in pure (non-<a>IO</a>) expressions, see the
--   function <a>evaluate</a>.
--   
--   Note that due to Haskell's unspecified evaluation order, an expression
--   may throw one of several possible exceptions: consider the expression
--   <tt>(error "urk") + (1 `div` 0)</tt>. Does the expression throw
--   <tt>ErrorCall "urk"</tt>, or <tt>DivideByZero</tt>?
--   
--   The answer is "it might throw either"; the choice is
--   non-deterministic. If you are catching any type of exception then you
--   might catch either. If you are calling <tt>catch</tt> with type <tt>IO
--   Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</tt> then the
--   handler may get run with <tt>DivideByZero</tt> as an argument, or an
--   <tt>ErrorCall "urk"</tt> exception may be propagated further up. If
--   you call it again, you might get the opposite behaviour. This is ok,
--   because <a>catch</a> is an <a>IO</a> computation.
catch :: Exception e => IO a -> (e -> IO a) -> IO a

-- | Sometimes you want to catch two different sorts of exception. You
--   could do something like
--   
--   <pre>
--   f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
--            `catch` \ (ex :: IOException)    -&gt; handleIO    ex
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleArith</tt> throws an <tt>IOException</tt> then the second
--   exception handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
--                       Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]
--   </pre>
catches :: IO a -> [Handler a] -> IO a

-- | You need this when using <a>catches</a>.
data Handler a
Handler :: (e -> IO a) -> Handler a

-- | The function <a>catchJust</a> is like <a>catch</a>, but it takes an
--   extra argument which is an <i>exception predicate</i>, a function
--   which selects which type of exceptions we're interested in.
--   
--   <pre>
--   catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
--             (readFile f)
--             (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
--                       return "")
--   </pre>
--   
--   Any other exceptions which are not matched by the predicate are
--   re-raised, and may be caught by an enclosing <a>catch</a>,
--   <a>catchJust</a>, etc.
catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a

-- | A version of <a>catch</a> with the arguments swapped around; useful in
--   situations where the code for the handler is shorter. For example:
--   
--   <pre>
--   do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
--      ...
--   </pre>
handle :: Exception e => (e -> IO a) -> IO a -> IO a

-- | A version of <a>catchJust</a> with the arguments swapped around (see
--   <a>handle</a>).
handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception of type <tt>e</tt> was
--   raised, or <tt>(<a>Left</a> ex)</tt> if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised then it will be propagated up to the next
--   enclosing exception handler.
--   
--   <pre>
--   try a = catch (Right `liftM` a) (return . Left)
--   </pre>
try :: Exception e => IO a -> IO (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught (c.f. <a>catchJust</a>). If the exception
--   does not match the predicate, it is re-thrown.
tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)

-- | Evaluate the argument to weak head normal form.
--   
--   <a>evaluate</a> is typically used to uncover any exceptions that a
--   lazy value may contain, and possibly handle them.
--   
--   <a>evaluate</a> only evaluates to <i>weak head normal form</i>. If
--   deeper evaluation is needed, the <tt>force</tt> function from
--   <tt>Control.DeepSeq</tt> may be handy:
--   
--   <pre>
--   evaluate $ force x
--   </pre>
--   
--   There is a subtle difference between <tt><a>evaluate</a> x</tt> and
--   <tt><a>return</a> <a>$!</a> x</tt>, analogous to the difference
--   between <a>throwIO</a> and <a>throw</a>. If the lazy value <tt>x</tt>
--   throws an exception, <tt><a>return</a> <a>$!</a> x</tt> will fail to
--   return an <a>IO</a> action and will throw an exception instead.
--   <tt><a>evaluate</a> x</tt>, on the other hand, always produces an
--   <a>IO</a> action; that action will throw an exception upon
--   <i>execution</i> iff <tt>x</tt> throws an exception upon
--   <i>evaluation</i>.
--   
--   The practical implication of this difference is that due to the
--   <i>imprecise exceptions</i> semantics,
--   
--   <pre>
--   (return $! error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   may throw either <tt>"foo"</tt> or <tt>"bar"</tt>, depending on the
--   optimizations performed by the compiler. On the other hand,
--   
--   <pre>
--   evaluate (error "foo") &gt;&gt; error "bar"
--   </pre>
--   
--   is guaranteed to throw <tt>"foo"</tt>.
--   
--   The rule of thumb is to use <a>evaluate</a> to force or handle
--   exceptions in lazy values. If, on the other hand, you are forcing a
--   lazy value for efficiency reasons only and do not care about
--   exceptions, you may use <tt><a>return</a> <a>$!</a> x</tt>.
evaluate :: a -> IO a

-- | This function maps one exception into another as proposed in the paper
--   "A semantics for imprecise exceptions".
mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a

-- | Executes an IO computation with asynchronous exceptions <i>masked</i>.
--   That is, any thread which attempts to raise an exception in the
--   current thread with <a>throwTo</a> will be blocked until asynchronous
--   exceptions are unmasked again.
--   
--   The argument passed to <a>mask</a> is a function that takes as its
--   argument another function, which can be used to restore the prevailing
--   masking state within the context of the masked computation. For
--   example, a common way to use <a>mask</a> is to protect the acquisition
--   of a resource:
--   
--   <pre>
--   mask $ \restore -&gt; do
--       x &lt;- acquire
--       restore (do_something_with x) `onException` release
--       release
--   </pre>
--   
--   This code guarantees that <tt>acquire</tt> is paired with
--   <tt>release</tt>, by masking asynchronous exceptions for the critical
--   parts. (Rather than write this code yourself, it would be better to
--   use <a>bracket</a> which abstracts the general pattern).
--   
--   Note that the <tt>restore</tt> action passed to the argument to
--   <a>mask</a> does not necessarily unmask asynchronous exceptions, it
--   just restores the masking state to that of the enclosing context. Thus
--   if asynchronous exceptions are already masked, <a>mask</a> cannot be
--   used to unmask exceptions again. This is so that if you call a library
--   function with exceptions masked, you can be sure that the library call
--   will not be able to unmask exceptions again. If you are writing
--   library code and need to use asynchronous exceptions, the only way is
--   to create a new thread; see <a>forkIOWithUnmask</a>.
--   
--   Asynchronous exceptions may still be received while in the masked
--   state if the masked thread <i>blocks</i> in certain ways; see
--   <a>Control.Exception#interruptible</a>.
--   
--   Threads created by <a>forkIO</a> inherit the <a>MaskingState</a> from
--   the parent; that is, to start a thread in the
--   <a>MaskedInterruptible</a> state, use <tt>mask_ $ forkIO ...</tt>.
--   This is particularly useful if you need to establish an exception
--   handler in the forked thread before any asynchronous exceptions are
--   received. To create a new thread in an unmasked state use
--   <a>forkIOWithUnmask</a>.
mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: IO a -> IO a

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception#interruptible</a>). THIS SHOULD BE USED WITH
--   GREAT CARE, because if a thread executing in
--   <a>uninterruptibleMask</a> blocks for any reason, then the thread (and
--   possibly the program, if this is the main thread) will be unresponsive
--   and unkillable. This function should only be necessary if you need to
--   mask exceptions around an interruptible operation, and you can
--   guarantee that the interruptible operation will only block for a short
--   period of time.
uninterruptibleMask :: ((forall a. IO a -> IO a) -> IO b) -> IO b

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: IO a -> IO a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Returns the <a>MaskingState</a> for the current thread.
getMaskingState :: IO MaskingState

-- | Allow asynchronous exceptions to be raised even inside <a>mask</a>,
--   making the operation interruptible (see the discussion of
--   "Interruptible operations" in <a>Exception</a>).
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
interruptible :: IO a -> IO a

-- | When invoked inside <a>mask</a>, this function allows a masked
--   asynchronous exception to be raised, if one exists. It is equivalent
--   to performing an interruptible operation (see #interruptible), but
--   does not involve any actual blocking.
--   
--   When called outside <a>mask</a>, or inside <a>uninterruptibleMask</a>,
--   this function has no effect.
allowInterrupt :: IO ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <a>bracket</a>, because
--   <a>bracket</a> will install the necessary exception handler to release
--   the resource in the event that an exception is raised during the
--   computation. If an exception is raised, then <a>bracket</a> will
--   re-raise the exception (after performing the release).
--   
--   A common example is opening a file:
--   
--   <pre>
--   bracket
--     (openFile "filename" ReadMode)
--     (hClose)
--     (\fileHandle -&gt; do { ... })
--   </pre>
--   
--   The arguments to <a>bracket</a> are in this order so that we can
--   partially apply it, e.g.:
--   
--   <pre>
--   withFile name mode = bracket (openFile name mode) hClose
--   </pre>
--   
--   Bracket wraps the release action with <a>mask</a>, which is sufficient
--   to ensure that the release action executes to completion when it does
--   not invoke any interruptible actions, even in the presence of
--   asynchronous exceptions. For example, <tt>hClose</tt> is
--   uninterruptible when it is not racing other uses of the handle.
--   Similarly, closing a socket (from "network" package) is also
--   uninterruptible under similar conditions. An example of an
--   interruptible action is <a>killThread</a>. Completion of interruptible
--   release actions can be ensured by wrapping them in in
--   <a>uninterruptibleMask_</a>, but this risks making the program
--   non-responsive to <tt>Control-C</tt>, or timeouts. Another option is
--   to run the release action asynchronously in its own thread:
--   
--   <pre>
--   void $ uninterruptibleMask_ $ forkIO $ do { ... }
--   </pre>
--   
--   The resource will be released as soon as possible, but the thread that
--   invoked bracket will not block in an uninterruptible state.
bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
bracket_ :: IO a -> IO b -> IO c -> IO c

-- | Like <a>bracket</a>, but only performs the final action if there was
--   an exception raised by the in-between computation.
bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c

-- | A specialised variant of <a>bracket</a> with just a computation to run
--   afterward.
finally :: IO a -> IO b -> IO a

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: IO a -> IO b -> IO a
instance GHC.Base.Functor Control.Exception.Handler


-- | "Unsafe" IO operations.
module System.IO.Unsafe

-- | This is the "back door" into the <a>IO</a> monad, allowing <a>IO</a>
--   computation to be performed at any time. For this to be safe, the
--   <a>IO</a> computation should be free of side effects and independent
--   of its environment.
--   
--   If the I/O computation wrapped in <a>unsafePerformIO</a> performs side
--   effects, then the relative order in which those side effects take
--   place (relative to the main I/O trunk, or other calls to
--   <a>unsafePerformIO</a>) is indeterminate. Furthermore, when using
--   <a>unsafePerformIO</a> to cause side-effects, you should take the
--   following precautions to ensure the side effects are performed as many
--   times as you expect them to be. Note that these precautions are
--   necessary for GHC, but may not be sufficient, and other compilers may
--   require different precautions:
--   
--   <ul>
--   <li>Use <tt>{-# NOINLINE foo #-}</tt> as a pragma on any function
--   <tt>foo</tt> that calls <a>unsafePerformIO</a>. If the call is
--   inlined, the I/O may be performed more than once.</li>
--   <li>Use the compiler flag <tt>-fno-cse</tt> to prevent common
--   sub-expression elimination being performed on the module, which might
--   combine two side effects that were meant to be separate. A good
--   example is using multiple global variables (like <tt>test</tt> in the
--   example below).</li>
--   <li>Make sure that the either you switch off let-floating
--   (<tt>-fno-full-laziness</tt>), or that the call to
--   <a>unsafePerformIO</a> cannot float outside a lambda. For example, if
--   you say: <tt> f x = unsafePerformIO (newIORef []) </tt> you may get
--   only one reference cell shared between all calls to <tt>f</tt>. Better
--   would be <tt> f x = unsafePerformIO (newIORef [x]) </tt> because now
--   it can't float outside the lambda.</li>
--   </ul>
--   
--   It is less well known that <a>unsafePerformIO</a> is not type safe.
--   For example:
--   
--   <pre>
--   test :: IORef [a]
--   test = unsafePerformIO $ newIORef []
--   
--   main = do
--           writeIORef test [42]
--           bang &lt;- readIORef test
--           print (bang :: [Char])
--   </pre>
--   
--   This program will core dump. This problem with polymorphic references
--   is well known in the ML community, and does not arise with normal
--   monadic use of references. There is no easy way to make it impossible
--   once you use <a>unsafePerformIO</a>. Indeed, it is possible to write
--   <tt>coerce :: a -&gt; b</tt> with the help of <a>unsafePerformIO</a>.
--   So be careful!
--   
--   WARNING: If you're looking for "a way to get a <a>String</a> from an
--   'IO String'", then <a>unsafePerformIO</a> is not the way to go. Learn
--   about do-notation and the <tt>&lt;-</tt> syntax element before you
--   proceed.
unsafePerformIO :: IO a -> a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a

-- | <a>unsafeInterleaveIO</a> allows an <a>IO</a> computation to be
--   deferred lazily. When passed a value of type <tt>IO a</tt>, the
--   <a>IO</a> will only be performed when the value of the <tt>a</tt> is
--   demanded. This is used to implement lazy file reading, see
--   <a>hGetContents</a>.
unsafeInterleaveIO :: IO a -> IO a

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a


-- | This module provides text encoding/decoding using iconv
module GHC.IO.Encoding.Iconv
iconvEncoding :: String -> IO (Maybe TextEncoding)

-- | Construct an iconv-based <a>TextEncoding</a> for the given character
--   set and <a>CodingFailureMode</a>.
--   
--   As iconv is missing in some minimal environments (e.g. #10298), this
--   checks to ensure that iconv is working properly before returning the
--   encoding, returning <a>Nothing</a> if not.
mkIconvEncoding :: CodingFailureMode -> String -> IO (Maybe TextEncoding)
localeEncodingName :: String


-- | Text codecs for I/O
module GHC.IO.Encoding
data BufferCodec from to state
BufferCodec :: CodeBuffer from to -> (Buffer from -> Buffer to -> IO (Buffer from, Buffer to)) -> IO () -> IO state -> (state -> IO ()) -> BufferCodec from to state

-- | The <tt>encode</tt> function translates elements of the buffer
--   <tt>from</tt> to the buffer <tt>to</tt>. It should translate as many
--   elements as possible given the sizes of the buffers, including
--   translating zero elements if there is either not enough room in
--   <tt>to</tt>, or <tt>from</tt> does not contain a complete multibyte
--   sequence.
--   
--   If multiple CodingProgress returns are possible, OutputUnderflow must
--   be preferred to InvalidSequence. This allows GHC's IO library to
--   assume that if we observe InvalidSequence there is at least a single
--   element available in the output buffer.
--   
--   The fact that as many elements as possible are translated is used by
--   the IO library in order to report translation errors at the point they
--   actually occur, rather than when the buffer is translated.
[encode] :: BufferCodec from to state -> CodeBuffer from to

-- | The <tt>recover</tt> function is used to continue decoding in the
--   presence of invalid or unrepresentable sequences. This includes both
--   those detected by <tt>encode</tt> returning <tt>InvalidSequence</tt>
--   and those that occur because the input byte sequence appears to be
--   truncated.
--   
--   Progress will usually be made by skipping the first element of the
--   <tt>from</tt> buffer. This function should only be called if you are
--   certain that you wish to do this skipping and if the <tt>to</tt>
--   buffer has at least one element of free space. Because this function
--   deals with decoding failure, it assumes that the from buffer has at
--   least one element.
--   
--   <tt>recover</tt> may raise an exception rather than skipping anything.
--   
--   Currently, some implementations of <tt>recover</tt> may mutate the
--   input buffer. In particular, this feature is used to implement
--   transliteration.
[recover] :: BufferCodec from to state -> Buffer from -> Buffer to -> IO (Buffer from, Buffer to)

-- | Resources associated with the encoding may now be released. The
--   <tt>encode</tt> function may not be called again after calling
--   <tt>close</tt>.
[close] :: BufferCodec from to state -> IO ()

-- | Return the current state of the codec.
--   
--   Many codecs are not stateful, and in these case the state can be
--   represented as <tt>()</tt>. Other codecs maintain a state. For
--   example, UTF-16 recognises a BOM (byte-order-mark) character at the
--   beginning of the input, and remembers thereafter whether to use
--   big-endian or little-endian mode. In this case, the state of the codec
--   would include two pieces of information: whether we are at the
--   beginning of the stream (the BOM only occurs at the beginning), and if
--   not, whether to use the big or little-endian encoding.
[getState] :: BufferCodec from to state -> IO state
[setState] :: BufferCodec from to state -> state -> IO ()

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding
TextEncoding :: String -> IO (TextDecoder dstate) -> IO (TextEncoder estate) -> TextEncoding

-- | a string that can be passed to <a>mkTextEncoding</a> to create an
--   equivalent <a>TextEncoding</a>.
[textEncodingName] :: TextEncoding -> String

-- | Creates a means of decoding bytes into characters: the result must not
--   be shared between several byte sequences or simultaneously across
--   threads
[mkTextDecoder] :: TextEncoding -> IO (TextDecoder dstate)

-- | Creates a means of encode characters into bytes: the result must not
--   be shared between several character sequences or simultaneously across
--   threads
[mkTextEncoder] :: TextEncoding -> IO (TextEncoder estate)
type TextEncoder state = BufferCodec CharBufElem Word8 state
type TextDecoder state = BufferCodec Word8 CharBufElem state

data CodingProgress

-- | Stopped because the input contains insufficient available elements, or
--   all of the input sequence has been successfully translated.
InputUnderflow :: CodingProgress

-- | Stopped because the output contains insufficient free elements
OutputUnderflow :: CodingProgress

-- | Stopped because there are sufficient free elements in the output to
--   output at least one encoded ASCII character, but the input contains an
--   invalid or unrepresentable sequence
InvalidSequence :: CodingProgress

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than <tt>'\255'</tt>
--   to a <a>Handle</a> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding
latin1_encode :: CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)
latin1_decode :: Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (little-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (little-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

initLocaleEncoding :: TextEncoding

-- | The Unicode encoding of the current locale
getLocaleEncoding :: IO TextEncoding

-- | The encoding of the current locale, but allowing arbitrary undecodable
--   bytes to be round-tripped through it.
--   
--   Do not expect the encoding to be Unicode-compatible: it could appear
--   to be ASCII or anything else.
--   
--   This <a>TextEncoding</a> is used to decode and encode command line
--   arguments and environment variables on non-Windows platforms.
--   
--   On Windows, this encoding *should not* be used if possible because the
--   use of code pages is deprecated: Strings should be retrieved via the
--   "wide" W-family of UTF-16 APIs instead
getFileSystemEncoding :: IO TextEncoding

-- | The Unicode encoding of the current locale, but where undecodable
--   bytes are replaced with their closest visual match. Used for the
--   <a>CString</a> marshalling functions in <a>Foreign.C.String</a>
getForeignEncoding :: IO TextEncoding

-- | Set locale encoding for your program. The locale affects how
--   <a>Char</a>s are encoded and decoded when serialized to bytes: e. g.,
--   when you read or write files (<a>readFile'</a>, <a>writeFile</a>) or
--   use standard input/output (<a>getLine</a>, <a>putStrLn</a>). For
--   instance, if your program prints non-ASCII characters, it is prudent
--   to execute
--   
--   <pre>
--   setLocaleEncoding utf8
--   </pre>
--   
--   This is necessary, but not enough on Windows, where console is a
--   stateful device, which needs to be configured using
--   <tt>System.Win32.Console.setConsoleOutputCP</tt> and restored back
--   afterwards. These intricacies are covered by <a>code-page</a> package,
--   which offers a crossplatform <tt>System.IO.CodePage.withCodePage</tt>
--   bracket.
--   
--   Wrong locale encoding typically causes error messages like "invalid
--   argument (cannot decode byte sequence starting from ...)" or "invalid
--   argument (cannot encode character ...)".
setLocaleEncoding :: TextEncoding -> IO ()

setFileSystemEncoding :: TextEncoding -> IO ()

setForeignEncoding :: TextEncoding -> IO ()

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Internal encoding of argv
argvEncoding :: IO TextEncoding


-- | Access to GHC's call-stack simulation
module GHC.Stack.CCS

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String


-- | Access to GHC's call-stack simulation
module GHC.Stack

-- | Like the function <a>error</a>, but appends a stack trace to the error
--   message if one is available.

-- | <i>Deprecated: <a>error</a> appends the call stack now</i>
errorWithStackTrace :: String -> a

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | Get the stack trace attached to an object.
whoCreated :: a -> IO [String]

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = (?callStack :: CallStack)

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | The empty <a>CallStack</a>.
emptyCallStack :: CallStack

-- | Freeze a call-stack, preventing any further call-sites from being
--   appended.
--   
--   <pre>
--   pushCallStack callSite (freezeCallStack callStack) = freezeCallStack callStack
--   </pre>
freezeCallStack :: CallStack -> CallStack

-- | Convert a list of call-sites to a <a>CallStack</a>.
fromCallSiteList :: [([Char], SrcLoc)] -> CallStack

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Pop the most recent call-site off the <a>CallStack</a>.
--   
--   This function, like <a>pushCallStack</a>, has no effect on a frozen
--   <a>CallStack</a>.
popCallStack :: CallStack -> CallStack

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String

-- | Push a call-site onto the stack.
--   
--   This function has no effect on a frozen <a>CallStack</a>.
pushCallStack :: ([Char], SrcLoc) -> CallStack -> CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a

-- | A single location in the source code.
data SrcLoc
SrcLoc :: [Char] -> [Char] -> [Char] -> Int -> Int -> Int -> Int -> SrcLoc
[srcLocPackage] :: SrcLoc -> [Char]
[srcLocModule] :: SrcLoc -> [Char]
[srcLocFile] :: SrcLoc -> [Char]
[srcLocStartLine] :: SrcLoc -> Int
[srcLocStartCol] :: SrcLoc -> Int
[srcLocEndLine] :: SrcLoc -> Int
[srcLocEndCol] :: SrcLoc -> Int

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String

-- | A cost-centre stack from GHC's cost-center profiler.
data CostCentreStack

-- | A cost-centre from GHC's cost-center profiler.
data CostCentre

-- | Returns the current <a>CostCentreStack</a> (value is <tt>nullPtr</tt>
--   if the current program was not compiled with profiling support). Takes
--   a dummy argument which can be used to avoid the call to
--   <tt>getCurrentCCS</tt> being floated out by the simplifier, which
--   would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS :: dummy -> IO (Ptr CostCentreStack)

-- | Get the <a>CostCentreStack</a> associated with the given value.
getCCSOf :: a -> IO (Ptr CostCentreStack)

-- | Run a computation with an empty cost-center stack. For example, this
--   is used by the interpreter to run an interpreted computation without
--   the call stack showing that it was invoked from GHC.
clearCCS :: IO a -> IO a

-- | Get the <a>CostCentre</a> at the head of a <a>CostCentreStack</a>.
ccsCC :: Ptr CostCentreStack -> IO (Ptr CostCentre)

-- | Get the tail of a <a>CostCentreStack</a>.
ccsParent :: Ptr CostCentreStack -> IO (Ptr CostCentreStack)

-- | Get the label of a <a>CostCentre</a>.
ccLabel :: Ptr CostCentre -> IO CString

-- | Get the module of a <a>CostCentre</a>.
ccModule :: Ptr CostCentre -> IO CString

-- | Get the source span of a <a>CostCentre</a>.
ccSrcSpan :: Ptr CostCentre -> IO CString

-- | Format a <a>CostCentreStack</a> as a list of lines.
ccsToStrings :: Ptr CostCentreStack -> IO [String]
renderStack :: [String] -> String


-- | Access to GHC's info-table provenance metadata.
module GHC.InfoProv
data InfoProv
InfoProv :: String -> String -> String -> String -> String -> String -> String -> InfoProv
[ipName] :: InfoProv -> String
[ipDesc] :: InfoProv -> String
[ipTyDesc] :: InfoProv -> String
[ipLabel] :: InfoProv -> String
[ipMod] :: InfoProv -> String
[ipSrcFile] :: InfoProv -> String
[ipSrcSpan] :: InfoProv -> String
ipLoc :: InfoProv -> String
ipeProv :: Ptr InfoProvEnt -> Ptr InfoProv

-- | Get information about where a value originated from. This information
--   is stored statically in a binary when `-finfo-table-map` is enabled.
--   The source positions will be greatly improved by also enabled debug
--   information with `-g3`. Finally you can enable
--   `-fdistinct-constructor-tables` to get more precise information about
--   data constructor allocations.
--   
--   The information is collect by looking at the info table address of a
--   specific closure and then consulting a specially generated map (by
--   `-finfo-table-map`) to find out where we think the best source
--   position to describe that info table arose from.
whereFrom :: a -> IO (Maybe InfoProv)
data InfoProvEnt
peekInfoProv :: Ptr InfoProv -> IO InfoProv
instance GHC.Show.Show GHC.InfoProv.InfoProv
instance GHC.Classes.Eq GHC.InfoProv.InfoProv


-- | This module defines the basic operations on I/O "handles". All of the
--   operations defined here are independent of the underlying device.
module GHC.IO.Handle.Internals
withHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a
withHandle' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO (Handle__, a)) -> IO a
withHandle_ :: String -> Handle -> (Handle__ -> IO a) -> IO a
withHandle__' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO Handle__) -> IO ()
withHandle_' :: String -> Handle -> MVar Handle__ -> (Handle__ -> IO a) -> IO a
withAllHandles__ :: String -> Handle -> (Handle__ -> IO Handle__) -> IO ()
wantWritableHandle :: String -> Handle -> (Handle__ -> IO a) -> IO a
wantReadableHandle :: String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a
wantReadableHandle_ :: String -> Handle -> (Handle__ -> IO a) -> IO a
wantSeekableHandle :: String -> Handle -> (Handle__ -> IO a) -> IO a
mkHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> HandleType -> Bool -> Maybe TextEncoding -> NewlineMode -> Maybe HandleFinalizer -> Maybe (MVar Handle__) -> IO Handle

-- | makes a new <a>Handle</a>
mkFileHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | makes a new <a>Handle</a> without a finalizer.
mkFileHandleNoFinalizer :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandleNoFinalizer :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | Add a finalizer to a <a>Handle</a>. Specifically, the finalizer will
--   be added to the <a>MVar</a> of a file handle or the write-side
--   <a>MVar</a> of a duplex handle. See Handle Finalizers for details.
addHandleFinalizer :: Handle -> HandleFinalizer -> IO ()
openTextEncoding :: Maybe TextEncoding -> HandleType -> (forall es ds. Maybe (TextEncoder es) -> Maybe (TextDecoder ds) -> IO a) -> IO a
closeTextCodecs :: Handle__ -> IO ()
initBufferState :: HandleType -> BufferState
dEFAULT_CHAR_BUFFER_SIZE :: Int

-- | syncs the file with the buffer, including moving the file pointer
--   backwards in the case of a read buffer. This can fail on a
--   non-seekable read Handle.
flushBuffer :: Handle__ -> IO ()
flushWriteBuffer :: Handle__ -> IO ()
flushCharReadBuffer :: Handle__ -> IO ()

-- | flushes the Char buffer only. Works on all Handles.
flushCharBuffer :: Handle__ -> IO ()
flushByteReadBuffer :: Handle__ -> IO ()
flushByteWriteBuffer :: Handle__ -> IO ()
readTextDevice :: Handle__ -> CharBuffer -> IO CharBuffer
writeCharBuffer :: Handle__ -> CharBuffer -> IO ()
readTextDeviceNonBlocking :: Handle__ -> CharBuffer -> IO CharBuffer
decodeByteBuf :: Handle__ -> CharBuffer -> IO CharBuffer
augmentIOError :: IOException -> String -> Handle -> IOException
ioe_closedHandle :: IO a
ioe_semiclosedHandle :: IO a
ioe_EOF :: IO a
ioe_notReadable :: IO a
ioe_notWritable :: IO a
ioe_finalizedHandle :: FilePath -> Handle__
ioe_bufsiz :: Int -> IO a

-- | This function exists temporarily to avoid an unused import warning in
--   <tt>bytestring</tt>.
hClose_impl :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
hLookAhead_ :: Handle__ -> IO Char
type HandleFinalizer = FilePath -> MVar Handle__ -> IO ()
handleFinalizer :: FilePath -> MVar Handle__ -> IO ()
debugIO :: String -> IO ()
traceIO :: String -> IO ()

module GHC.Environment

-- | Computation <a>getFullArgs</a> is the "raw" version of <a>getArgs</a>,
--   similar to <tt>argv</tt> in other languages. It returns a list of the
--   program's command line arguments, starting with the program name, and
--   including those normally eaten by the RTS (+RTS ... -RTS).
getFullArgs :: IO [String]


-- | String I/O functions
module GHC.IO.Handle.Text

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()
commitBuffer' :: RawCharBuffer -> Int -> Int -> Bool -> Bool -> Handle__ -> IO CharBuffer

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
memcpy :: Ptr a -> Ptr a -> CSize -> IO (Ptr ())

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
hGetContents' :: Handle -> IO String


-- | An <tt><a>MVar</a> t</tt> is mutable location that is either empty or
--   contains a value of type <tt>t</tt>. It has two fundamental
--   operations: <a>putMVar</a> which fills an <a>MVar</a> if it is empty
--   and blocks otherwise, and <a>takeMVar</a> which empties an <a>MVar</a>
--   if it is full and blocks otherwise. They can be used in multiple
--   different ways:
--   
--   <ol>
--   <li>As synchronized mutable variables,</li>
--   <li>As channels, with <a>takeMVar</a> and <a>putMVar</a> as receive
--   and send, and</li>
--   <li>As a binary semaphore <tt><a>MVar</a> ()</tt>, with
--   <a>takeMVar</a> and <a>putMVar</a> as wait and signal.</li>
--   </ol>
--   
--   They were introduced in the paper <a>"Concurrent Haskell"</a> by Simon
--   Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of
--   their implementation have since then changed (in particular, a put on
--   a full <a>MVar</a> used to error, but now merely blocks.)
--   
--   <h3>Applicability</h3>
--   
--   <a>MVar</a>s offer more flexibility than <a>IORef</a>s, but less
--   flexibility than <a>STM</a>. They are appropriate for building
--   synchronization primitives and performing simple interthread
--   communication; however they are very simple and susceptible to race
--   conditions, deadlocks or uncaught exceptions. Do not use them if you
--   need perform larger atomic operations such as reading from multiple
--   variables: use <a>STM</a> instead.
--   
--   In particular, the "bigger" functions in this module (<a>swapMVar</a>,
--   <a>withMVar</a>, <a>modifyMVar_</a> and <a>modifyMVar</a>) are simply
--   the composition of a <a>takeMVar</a> followed by a <a>putMVar</a> with
--   exception safety. These have atomicity guarantees only if all other
--   threads perform a <a>takeMVar</a> before a <a>putMVar</a> as well;
--   otherwise, they may block.
--   
--   <h3>Fairness</h3>
--   
--   No thread can be blocked indefinitely on an <a>MVar</a> unless another
--   thread holds that <a>MVar</a> indefinitely. One usual implementation
--   of this fairness guarantee is that threads blocked on an <a>MVar</a>
--   are served in a first-in-first-out fashion, but this is not guaranteed
--   in the semantics.
--   
--   <h3>Gotchas</h3>
--   
--   Like many other Haskell data structures, <a>MVar</a>s are lazy. This
--   means that if you place an expensive unevaluated thunk inside an
--   <a>MVar</a>, it will be evaluated by the thread that consumes it, not
--   the thread that produced it. Be sure to <a>evaluate</a> values to be
--   placed in an <a>MVar</a> to the appropriate normal form, or utilize a
--   strict MVar provided by the strict-concurrency package.
--   
--   <h3>Ordering</h3>
--   
--   <a>MVar</a> operations are always observed to take place in the order
--   they are written in the program, regardless of the memory model of the
--   underlying machine. This is in contrast to <a>IORef</a> operations
--   which may appear out-of-order to another thread in some cases.
--   
--   <h3>Example</h3>
--   
--   Consider the following concurrent data structure, a skip channel. This
--   is a channel for an intermittent source of high bandwidth information
--   (for example, mouse movement events.) Writing to the channel never
--   blocks, and reading from the channel only returns the most recent
--   value, or blocks if there are no new values. Multiple readers are
--   supported with a <tt>dupSkipChan</tt> operation.
--   
--   A skip channel is a pair of <a>MVar</a>s. The first <a>MVar</a>
--   contains the current value, and a list of semaphores that need to be
--   notified when it changes. The second <a>MVar</a> is a semaphore for
--   this particular reader: it is full if there is a value in the channel
--   that this reader has not read yet, and empty otherwise.
--   
--   <pre>
--   data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())
--   
--   newSkipChan :: IO (SkipChan a)
--   newSkipChan = do
--       sem &lt;- newEmptyMVar
--       main &lt;- newMVar (undefined, [sem])
--       return (SkipChan main sem)
--   
--   putSkipChan :: SkipChan a -&gt; a -&gt; IO ()
--   putSkipChan (SkipChan main _) v = do
--       (_, sems) &lt;- takeMVar main
--       putMVar main (v, [])
--       mapM_ (sem -&gt; putMVar sem ()) sems
--   
--   getSkipChan :: SkipChan a -&gt; IO a
--   getSkipChan (SkipChan main sem) = do
--       takeMVar sem
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return v
--   
--   dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)
--   dupSkipChan (SkipChan main _) = do
--       sem &lt;- newEmptyMVar
--       (v, sems) &lt;- takeMVar main
--       putMVar main (v, sem:sems)
--       return (SkipChan main sem)
--   </pre>
--   
--   This example was adapted from the original Concurrent Haskell paper.
--   For more examples of <a>MVar</a>s being used to build higher-level
--   synchronization primitives, see <a>Chan</a> and <a>QSem</a>.
module Control.Concurrent.MVar

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Take a value from an <a>MVar</a>, put a new value into the <a>MVar</a>
--   and return the value taken. This function is atomic only if there are
--   no other producers for this <a>MVar</a>. In other words, it cannot
--   guarantee that, by the time <a>swapMVar</a> gets the chance to write
--   to the MVar, the value of the MVar has not been altered by a write
--   operation from another thread.
swapMVar :: MVar a -> a -> IO a

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool

-- | <a>withMVar</a> is an exception-safe wrapper for operating on the
--   contents of an <a>MVar</a>. This operation is exception-safe: it will
--   replace the original contents of the <a>MVar</a> if an exception is
--   raised (see <a>Control.Exception</a>). However, it is only atomic if
--   there are no other producers for this <a>MVar</a>. In other words, it
--   cannot guarantee that, by the time <a>withMVar</a> gets the chance to
--   write to the MVar, the value of the MVar has not been altered by a
--   write operation from another thread.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
withMVarMasked :: MVar a -> (a -> IO b) -> IO b

-- | An exception-safe wrapper for modifying the contents of an
--   <a>MVar</a>. Like <a>withMVar</a>, <a>modifyMVar</a> will replace the
--   original contents of the <a>MVar</a> if an exception is raised during
--   the operation. This function is only atomic if there are no other
--   producers for this <a>MVar</a>. In other words, it cannot guarantee
--   that, by the time <a>modifyMVar_</a> gets the chance to write to the
--   MVar, the value of the MVar has not been altered by a write operation
--   from another thread.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()

-- | A slight variation on <a>modifyMVar_</a> that allows a value to be
--   returned (<tt>b</tt>) in addition to the modified value of the
--   <a>MVar</a>.
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyMVar_</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()

-- | Like <a>modifyMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Make a <a>Weak</a> pointer to an <a>MVar</a>, using the second
--   argument as a finalizer to run when <a>MVar</a> is garbage-collected
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))

-- | <i>Deprecated: use <a>mkWeakMVar</a> instead</i>
addMVarFinalizer :: MVar a -> IO () -> IO ()

module GHC.Conc.Signal
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
runHandlersPtr :: Ptr Word8 -> Signal -> IO ()


-- | Basic concurrency stuff.
module GHC.Conc.IO
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()

-- | Interrupts the current wait of the I/O manager if it is currently
--   blocked. This instructs it to re-read how much it should wait and to
--   process any pending events.
interruptIOManager :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes. Consider using
--   <tt>Control.Concurrent.Thread.Delay.delay</tt> from
--   <tt>unbounded-delays</tt> package.
threadDelay :: Int -> IO ()

-- | Switch the value of returned <a>TVar</a> from initial value
--   <a>False</a> to <a>True</a> after a given number of microseconds. The
--   caveats associated with <a>threadDelay</a> also apply.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()


-- | Raw read/write operations on file descriptors
module GHC.IO.FD
data FD
FD :: {-# UNPACK #-} !CInt -> {-# UNPACK #-} !Int -> FD
[fdFD] :: FD -> {-# UNPACK #-} !CInt
[fdIsNonBlocking] :: FD -> {-# UNPACK #-} !Int

-- | Open a file and make an <a>FD</a> for it. Truncates the file to zero
--   size when the <a>IOMode</a> is <a>WriteMode</a>.
--   
--   <a>openFileWith</a> takes two actions, <tt>act1</tt> and
--   <tt>act2</tt>, to perform after opening the file.
--   
--   <tt>act1</tt> is passed a file descriptor and I/O device type for the
--   newly opened file. If an exception occurs in <tt>act1</tt>, then the
--   file will be closed. <tt>act1</tt> <i>must not</i> close the file
--   itself. If it does so and then receives an exception, then the
--   exception handler will attempt to close it again, which is
--   impermissible.
--   
--   <tt>act2</tt> is performed with asynchronous exceptions masked. It is
--   passed a function to restore the masking state and the result of
--   <tt>act1</tt>. It /must not/ throw an exception (or deliver one via an
--   interruptible operation) without first closing the file or arranging
--   for it to be closed. <tt>act2</tt> <i>may</i> close the file, but is
--   not required to do so. If <tt>act2</tt> leaves the file open, then the
--   file will remain open on return from <a>openFileWith</a>.
--   
--   Code calling <a>openFileWith</a> that wishes to install a finalizer to
--   close the file should do so in <tt>act2</tt>. Doing so in
--   <tt>act1</tt> could potentially close the file in the finalizer first
--   and then in the exception handler. See <a>openFile'</a> for an example
--   of this use. Regardless, the caller is responsible for ensuring that
--   the file is eventually closed, perhaps using <a>bracket</a>.
openFileWith :: FilePath -> IOMode -> Bool -> (FD -> IODeviceType -> IO r) -> ((forall x. IO x -> IO x) -> r -> IO s) -> IO s

-- | Open a file and make an <a>FD</a> for it. Truncates the file to zero
--   size when the <a>IOMode</a> is <a>WriteMode</a>. This function is
--   difficult to use without potentially leaking the file descriptor on
--   exception. In particular, it must be used with exceptions masked,
--   which is a bit rude because the thread will be uninterruptible while
--   the file path is being encoded. Use <a>openFileWith</a> instead.
openFile :: FilePath -> IOMode -> Bool -> IO (FD, IODeviceType)

-- | Make a <a>FD</a> from an existing file descriptor. Fails if the FD
--   refers to a directory. If the FD refers to a file, <a>mkFD</a> locks
--   the file according to the Haskell 2010 single writer/multiple reader
--   locking semantics (this is why we need the <a>IOMode</a> argument
--   too).
mkFD :: CInt -> IOMode -> Maybe (IODeviceType, CDev, CIno) -> Bool -> Bool -> IO (FD, IODeviceType)
release :: FD -> IO ()
setNonBlockingMode :: FD -> Bool -> IO FD
readRawBufferPtr :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int
readRawBufferPtrNoBlock :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int
writeRawBufferPtr :: String -> FD -> Ptr Word8 -> Int -> CSize -> IO CInt
stdin :: FD
stdout :: FD
stderr :: FD
instance GHC.Show.Show GHC.IO.FD.FD
instance GHC.IO.Device.RawIO GHC.IO.FD.FD
instance GHC.IO.Device.IODevice GHC.IO.FD.FD
instance GHC.IO.BufferedIO.BufferedIO GHC.IO.FD.FD


-- | Handle operations implemented by file descriptors (FDs)
module GHC.IO.Handle.FD

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | Computation <a>openFile</a> <tt>file mode</tt> allocates and returns a
--   new, open handle to manage the file <tt>file</tt>. It manages input if
--   <tt>mode</tt> is <a>ReadMode</a>, output if <tt>mode</tt> is
--   <a>WriteMode</a> or <a>AppendMode</a>, and both input and output if
--   mode is <a>ReadWriteMode</a>.
--   
--   If the file does not exist and it is opened for output, it should be
--   created as a new file. If <tt>mode</tt> is <a>WriteMode</a> and the
--   file already exists, then it should be truncated to zero length. Some
--   operating systems delete empty files, so there is no guarantee that
--   the file will exist following an <a>openFile</a> with <tt>mode</tt>
--   <a>WriteMode</a> unless it is subsequently written to successfully.
--   The handle is positioned at the end of the file if <tt>mode</tt> is
--   <a>AppendMode</a>, and otherwise at the beginning (in which case its
--   internal position is 0). The initial buffer mode is
--   implementation-dependent.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isAlreadyInUseError</a> if the file is already open and cannot
--   be reopened;</li>
--   <li><a>isDoesNotExistError</a> if the file does not exist or (on POSIX
--   systems) is a FIFO without a reader and <a>WriteMode</a> was
--   requested; or</li>
--   <li><a>isPermissionError</a> if the user does not have permission to
--   open the file.</li>
--   </ul>
--   
--   On POSIX systems, <a>openFile</a> is an <i>interruptible operation</i>
--   as described in <a>Control.Exception</a>.
--   
--   Note: if you will be working with files containing binary data, you'll
--   want to be using <a>openBinaryFile</a>.
openFile :: FilePath -> IOMode -> IO Handle

-- | <tt><a>withFile</a> name mode act</tt> opens a file like
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | A version of <a>openBinaryFile</a> that takes an action to perform
--   with the handle. If an exception occurs in the action, then the file
--   will be closed automatically. The action <i>should</i> close the file
--   when finished with it so the file does not remain open until the
--   garbage collector collects the handle.
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | Like <a>openFile</a>, but opens the file in ordinary blocking mode.
--   This can be useful for opening a FIFO for writing: if we open in
--   non-blocking mode then the open will fail if there are no readers,
--   whereas a blocking open will block until a reader appear.
--   
--   Note: when blocking happens, an OS thread becomes tied up with the
--   processing, so the program must have at least another OS thread if it
--   wants to unblock itself. By corollary, a non-threaded runtime will
--   need a process-external trigger in order to become unblocked.
--   
--   On POSIX systems, <a>openFileBlocking</a> is an <i>interruptible
--   operation</i> as described in <a>Control.Exception</a>.
openFileBlocking :: FilePath -> IOMode -> IO Handle

-- | <tt><a>withFileBlocking</a> name mode act</tt> opens a file like
--   <a>openFileBlocking</a> and passes the resulting handle to the
--   computation <tt>act</tt>. The handle will be closed on exit from
--   <a>withFileBlocking</a>, whether by normal termination or by raising
--   an exception. If closing the handle raises an exception, then this
--   exception will be raised by <a>withFile</a> rather than any exception
--   raised by <tt>act</tt>.
withFileBlocking :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
mkHandleFromFD :: FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle

-- | Turn an existing file descriptor into a Handle. This is used by
--   various external libraries to make Handles.
--   
--   Makes a binary Handle. This is for historical reasons; it should
--   probably be a text Handle with the default encoding and newline
--   translation instead.
fdToHandle :: FD -> IO Handle

-- | Old API kept to avoid breaking clients
fdToHandle' :: CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle

-- | Turn an existing Handle into a file descriptor. This function throws
--   an IOError if the Handle does not reference a file descriptor.
handleToFd :: Handle -> IO FD


-- | This model abstracts away the platform specific handles that can be
--   toggled through the RTS.
module GHC.IO.StdHandles
stdin :: Handle
stdout :: Handle
stderr :: Handle
openFile :: FilePath -> IOMode -> IO Handle
openBinaryFile :: FilePath -> IOMode -> IO Handle
openFileBlocking :: FilePath -> IOMode -> IO Handle
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
withFileBlocking :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

module GHC.IO.Handle.Lock

-- | Exception thrown by <tt>hLock</tt> on non-Windows platforms that don't
--   support <tt>flock</tt>.
data FileLockingNotSupported
FileLockingNotSupported :: FileLockingNotSupported

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows platforms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
--   
--   Returns <a>True</a> if taking the lock was successful and <a>False</a>
--   otherwise.
hTryLock :: Handle -> LockMode -> IO Bool

-- | Release a lock taken with <a>hLock</a> or <a>hTryLock</a>.
hUnlock :: Handle -> IO ()


-- | External API for GHC's Handle implementation
module GHC.IO.Handle

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | makes a new <a>Handle</a>
mkFileHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> IOMode -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | like <a>mkFileHandle</a>, except that a <a>Handle</a> is created with
--   two independent buffers, one for reading and one for writing. Used for
--   full-duplex streams, such as network sockets.
mkDuplexHandle :: (RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <a>localeEncoding</a>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | The action <a>hFlushAll</a> <tt>hdl</tt> flushes all buffered data in
--   <tt>hdl</tt>, including any buffered read data. Buffered read data is
--   flushed by seeking the file position back to the point before the
--   bufferred data was read, and hence only works if <tt>hdl</tt> is
--   seekable (see <a>hIsSeekable</a>).
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances;</li>
--   <li><a>isIllegalOperation</a> if <tt>hdl</tt> has buffered read data,
--   and is not seekable.</li>
--   </ul>
hFlushAll :: Handle -> IO ()

-- | Returns a duplicate of the original handle, with its own buffer. The
--   two Handles will share a file pointer, however. The original handle's
--   buffer is flushed, including discarding any input data, before the
--   handle is duplicated.
hDuplicate :: Handle -> IO Handle

-- | Makes the second handle a duplicate of the first handle. The second
--   handle will be closed first, if it is not already.
--   
--   This can be used to retarget the standard Handles, for example:
--   
--   <pre>
--   do h &lt;- openFile "mystdout" WriteMode
--      hDuplicateTo h stdout
--   </pre>
hDuplicateTo :: Handle -> Handle -> IO ()

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
--   
--   <a>hClose</a> is an <i>interruptible operation</i> in the sense
--   described in <a>Control.Exception</a>. If <a>hClose</a> is interrupted
--   by an asynchronous exception in the process of flushing its buffers,
--   then the I/O device (e.g., file) will be closed anyway.
hClose :: Handle -> IO ()
hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)

-- | Indicates a mode in which a file should be locked.
data LockMode
SharedLock :: LockMode
ExclusiveLock :: LockMode

-- | If a <a>Handle</a> references a file descriptor, attempt to lock
--   contents of the underlying file in appropriate mode. If the file is
--   already locked in incompatible mode, this function blocks until the
--   lock is established. The lock is automatically released upon closing a
--   <a>Handle</a>.
--   
--   Things to be aware of:
--   
--   1) This function may block inside a C call. If it does, in order to be
--   able to interrupt it with asynchronous exceptions and/or for other
--   threads to continue working, you MUST use threaded version of the
--   runtime system.
--   
--   2) The implementation uses <tt>LockFileEx</tt> on Windows and
--   <tt>flock</tt> otherwise, hence all of their caveats also apply here.
--   
--   3) On non-Windows platforms that don't support <tt>flock</tt> (e.g.
--   Solaris) this function throws <tt>FileLockingNotImplemented</tt>. We
--   deliberately choose to not provide fcntl based locking instead because
--   of its broken semantics.
hLock :: Handle -> LockMode -> IO ()

-- | Non-blocking version of <a>hLock</a>.
--   
--   Returns <a>True</a> if taking the lock was successful and <a>False</a>
--   otherwise.
hTryLock :: Handle -> LockMode -> IO Bool
type HandlePosition = Integer
data HandlePosn
HandlePosn :: Handle -> HandlePosition -> HandlePosn

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode
hIsSeekable :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
--   
--   On Windows the result of <tt>hIsTerminalDevide</tt> might be
--   misleading, because non-native terminals, such as MinTTY used in MSYS
--   and Cygwin environments, are implemented via redirection. Use
--   <tt>System.Win32.Types.withHandleToHANDLE
--   System.Win32.MinTTY.isMinTTYHandle</tt> to recognise it. Also consider
--   <tt>ansi-terminal</tt> package for crossplatform terminal support.
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
hGetContents' :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn
instance GHC.Show.Show GHC.IO.Handle.HandlePosn


-- | The standard IO library.
module System.IO

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a

-- | The implementation of <a>mfix</a> for <a>IO</a>. If the function
--   passed to <a>fixIO</a> inspects its argument, the resulting action
--   will throw <a>FixIOException</a>.
fixIO :: (a -> IO a) -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle
stdin :: Handle
stdout :: Handle
stderr :: Handle
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openFile :: FilePath -> IOMode -> IO Handle

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
--   
--   <a>hClose</a> is an <i>interruptible operation</i> in the sense
--   described in <a>Control.Exception</a>. If <a>hClose</a> is interrupted
--   by an asynchronous exception in the process of flushing its buffers,
--   then the I/O device (e.g., file) will be closed anyway.
hClose :: Handle -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>readFile'</a> function reads a file and returns the contents of
--   the file as a string. The file is fully read before being returned, as
--   with <a>getContents'</a>.
readFile' :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | For a handle <tt>hdl</tt> which attached to a physical file,
--   <a>hFileSize</a> <tt>hdl</tt> returns the size of that file in 8-bit
--   bytes.
hFileSize :: Handle -> IO Integer

-- | <a>hSetFileSize</a> <tt>hdl</tt> <tt>size</tt> truncates the physical
--   file with handle <tt>hdl</tt> to <tt>size</tt> bytes.
hSetFileSize :: Handle -> Integer -> IO ()

-- | For a readable handle <tt>hdl</tt>, <a>hIsEOF</a> <tt>hdl</tt> returns
--   <a>True</a> if no further input can be taken from <tt>hdl</tt> or for
--   a physical file, if the current I/O position is equal to the length of
--   the file. Otherwise, it returns <a>False</a>.
--   
--   NOTE: <a>hIsEOF</a> may block, because it has to attempt to read from
--   the stream to determine whether there is any more data to be read.
hIsEOF :: Handle -> IO Bool

-- | The computation <a>isEOF</a> is identical to <a>hIsEOF</a>, except
--   that it works only on <a>stdin</a>.
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Computation <a>hSetBuffering</a> <tt>hdl mode</tt> sets the mode of
--   buffering for handle <tt>hdl</tt> on subsequent reads and writes.
--   
--   If the buffer mode is changed from <a>BlockBuffering</a> or
--   <a>LineBuffering</a> to <a>NoBuffering</a>, then
--   
--   <ul>
--   <li>if <tt>hdl</tt> is writable, the buffer is flushed as for
--   <a>hFlush</a>;</li>
--   <li>if <tt>hdl</tt> is not writable, the contents of the buffer is
--   discarded.</li>
--   </ul>
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if the handle has already been used for
--   reading or writing and the implementation does not allow the buffering
--   mode to be changed.</li>
--   </ul>
hSetBuffering :: Handle -> BufferMode -> IO ()

-- | Computation <a>hGetBuffering</a> <tt>hdl</tt> returns the current
--   buffering mode for <tt>hdl</tt>.
hGetBuffering :: Handle -> IO BufferMode

-- | The action <a>hFlush</a> <tt>hdl</tt> causes any items buffered for
--   output in handle <tt>hdl</tt> to be sent immediately to the operating
--   system.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full;</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded. It is unspecified whether the characters in the buffer are
--   discarded or retained under these circumstances.</li>
--   </ul>
hFlush :: Handle -> IO ()

-- | Computation <a>hGetPosn</a> <tt>hdl</tt> returns the current I/O
--   position of <tt>hdl</tt> as a value of the abstract type
--   <a>HandlePosn</a>.
hGetPosn :: Handle -> IO HandlePosn

-- | If a call to <a>hGetPosn</a> <tt>hdl</tt> returns a position
--   <tt>p</tt>, then computation <a>hSetPosn</a> <tt>p</tt> sets the
--   position of <tt>hdl</tt> to the position it held at the time of the
--   call to <a>hGetPosn</a>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSetPosn :: HandlePosn -> IO ()
data HandlePosn

-- | Computation <a>hSeek</a> <tt>hdl mode i</tt> sets the position of
--   handle <tt>hdl</tt> depending on <tt>mode</tt>. The offset <tt>i</tt>
--   is given in terms of 8-bit bytes.
--   
--   If <tt>hdl</tt> is block- or line-buffered, then seeking to a position
--   which is not in the current buffer will first cause any items in the
--   output buffer to be written to the device, and then cause the input
--   buffer to be discarded. Some handles may not be seekable (see
--   <a>hIsSeekable</a>), or only support a subset of the possible
--   positioning operations (for instance, it may only be possible to seek
--   to the end of a tape, or to a positive offset from the beginning or
--   current position). It is not possible to set a negative I/O position,
--   or for a physical file, an I/O position beyond the current
--   end-of-file.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable, or
--   does not support the requested seek mode.</li>
--   <li><a>isPermissionError</a> if a system resource limit would be
--   exceeded.</li>
--   </ul>
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Computation <a>hTell</a> <tt>hdl</tt> returns the current position of
--   the handle <tt>hdl</tt>, as the number of bytes from the beginning of
--   the file. The value returned may be subsequently passed to
--   <a>hSeek</a> to reposition the handle to the current position.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isIllegalOperationError</a> if the Handle is not seekable.</li>
--   </ul>
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool

-- | Is the handle connected to a terminal?
--   
--   On Windows the result of <tt>hIsTerminalDevide</tt> might be
--   misleading, because non-native terminals, such as MinTTY used in MSYS
--   and Cygwin environments, are implemented via redirection. Use
--   <tt>System.Win32.Types.withHandleToHANDLE
--   System.Win32.MinTTY.isMinTTYHandle</tt> to recognise it. Also consider
--   <tt>ansi-terminal</tt> package for crossplatform terminal support.
hIsTerminalDevice :: Handle -> IO Bool

-- | Set the echoing status of a handle connected to a terminal.
hSetEcho :: Handle -> Bool -> IO ()

-- | Get the echoing status of a handle connected to a terminal.
hGetEcho :: Handle -> IO Bool

-- | <a>hShow</a> is in the <a>IO</a> monad, and gives more comprehensive
--   output than the (pure) instance of <a>Show</a> for <a>Handle</a>.
hShow :: Handle -> IO String

-- | Computation <a>hWaitForInput</a> <tt>hdl t</tt> waits until input is
--   available on handle <tt>hdl</tt>. It returns <a>True</a> as soon as
--   input is available on <tt>hdl</tt>, or <a>False</a> if no input is
--   available within <tt>t</tt> milliseconds. Note that
--   <a>hWaitForInput</a> waits until one or more full <i>characters</i>
--   are available, which means that it needs to do decoding, and hence may
--   fail with a decoding error.
--   
--   If <tt>t</tt> is less than zero, then <tt>hWaitForInput</tt> waits
--   indefinitely.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   <li>a decoding error, if the input begins with an invalid byte
--   sequence in this Handle's encoding.</li>
--   </ul>
--   
--   NOTE for GHC users: unless you use the <tt>-threaded</tt> flag,
--   <tt>hWaitForInput hdl t</tt> where <tt>t &gt;= 0</tt> will block all
--   other Haskell threads for the duration of the call. It behaves like a
--   <tt>safe</tt> foreign call in this respect.
hWaitForInput :: Handle -> Int -> IO Bool

-- | Computation <a>hReady</a> <tt>hdl</tt> indicates whether at least one
--   item is available for input from handle <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hReady :: Handle -> IO Bool

-- | Computation <a>hGetChar</a> <tt>hdl</tt> reads a character from the
--   file or channel managed by <tt>hdl</tt>, blocking until a character is
--   available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetChar :: Handle -> IO Char

-- | Computation <a>hGetLine</a> <tt>hdl</tt> reads a line from the file or
--   channel managed by <tt>hdl</tt>. <a>hGetLine</a> does not return the
--   newline as part of the result.
--   
--   A line is separated by the newline set with <a>hSetNewlineMode</a> or
--   <a>nativeNewline</a> by default. The read newline character(s) are not
--   returned as part of the result.
--   
--   If <a>hGetLine</a> encounters end-of-file at any point while reading
--   in the middle of a line, it is treated as a line terminator and the
--   (partial) line is returned.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file is encountered when reading
--   the <i>first</i> character of the line.</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/foo" ReadMode hGetLine &gt;&gt;= putStrLn
--   this is the first line of the file :O
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withFile "/home/user/bar" ReadMode (replicateM 3 . hGetLine)
--   ["this is the first line","this is the second line","this is the third line"]
--   </pre>
hGetLine :: Handle -> IO String

-- | Computation <a>hLookAhead</a> returns the next character from the
--   handle without removing it from the input buffer, blocking until a
--   character is available.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hLookAhead :: Handle -> IO Char

-- | Computation <a>hGetContents</a> <tt>hdl</tt> returns the list of
--   characters corresponding to the unread portion of the channel or file
--   managed by <tt>hdl</tt>, which is put into an intermediate state,
--   <i>semi-closed</i>. In this state, <tt>hdl</tt> is effectively closed,
--   but items are read from <tt>hdl</tt> on demand and accumulated in a
--   special list returned by <a>hGetContents</a> <tt>hdl</tt>.
--   
--   Any operation that fails because a handle is closed, also fails if a
--   handle is semi-closed. The only exception is <a>hClose</a>. A
--   semi-closed handle becomes closed:
--   
--   <ul>
--   <li>if <a>hClose</a> is applied to it;</li>
--   <li>if an I/O error occurs when reading an item from the handle;</li>
--   <li>or once the entire contents of the handle has been read.</li>
--   </ul>
--   
--   Once a semi-closed handle becomes closed, the contents of the
--   associated list becomes fixed. The contents of this final list is only
--   partially specified: it will contain at least all the items of the
--   stream that were evaluated prior to the handle becoming closed.
--   
--   Any I/O errors encountered while a handle is semi-closed are simply
--   discarded.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isEOFError</a> if the end of file has been reached.</li>
--   </ul>
hGetContents :: Handle -> IO String

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
hGetContents' :: Handle -> IO String

-- | Computation <a>hPutChar</a> <tt>hdl ch</tt> writes the character
--   <tt>ch</tt> to the file or channel managed by <tt>hdl</tt>. Characters
--   may be buffered if buffering is enabled for <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutChar :: Handle -> Char -> IO ()

-- | Computation <a>hPutStr</a> <tt>hdl s</tt> writes the string <tt>s</tt>
--   to the file or channel managed by <tt>hdl</tt>.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPutStr :: Handle -> String -> IO ()

-- | The same as <a>hPutStr</a>, but adds a newline character.
hPutStrLn :: Handle -> String -> IO ()

-- | Computation <a>hPrint</a> <tt>hdl t</tt> writes the string
--   representation of <tt>t</tt> given by the <a>shows</a> function to the
--   file or channel managed by <tt>hdl</tt> and appends a newline.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>isFullError</a> if the device is full; or</li>
--   <li><a>isPermissionError</a> if another system resource limit would be
--   exceeded.</li>
--   </ul>
hPrint :: Show a => Handle -> a -> IO ()

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>getContents'</a> operation returns all user input as a single
--   string, which is fully read before being returned (same as
--   <a>hGetContents'</a> <a>stdin</a>).
getContents' :: IO String

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
openBinaryFile :: FilePath -> IOMode -> IO Handle

-- | Select binary mode (<a>True</a>) or text mode (<a>False</a>) on a open
--   handle. (See also <a>openBinaryFile</a>.)
--   
--   This has the same effect as calling <a>hSetEncoding</a> with
--   <a>char8</a>, together with <a>hSetNewlineMode</a> with
--   <a>noNewlineTranslation</a>.
hSetBinaryMode :: Handle -> Bool -> IO ()

-- | <a>hPutBuf</a> <tt>hdl buf count</tt> writes <tt>count</tt> 8-bit
--   bytes from the buffer <tt>buf</tt> to the handle <tt>hdl</tt>. It
--   returns ().
--   
--   <a>hPutBuf</a> ignores any text encoding that applies to the
--   <a>Handle</a>, writing the bytes directly to the underlying file or
--   device.
--   
--   <a>hPutBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and writes bytes directly.
--   
--   This operation may fail with:
--   
--   <ul>
--   <li><a>ResourceVanished</a> if the handle is a pipe or socket, and the
--   reading end is closed. (If this is a POSIX system, and the program has
--   not asked to ignore SIGPIPE, then a SIGPIPE may be delivered instead,
--   whose default action is to terminate the program).</li>
--   </ul>
hPutBuf :: Handle -> Ptr a -> Int -> IO ()

-- | <a>hGetBuf</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is reached
--   or <tt>count</tt> 8-bit bytes have been read. It returns the number of
--   bytes actually read. This may be zero if EOF was reached before any
--   data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBuf</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBuf</a> will behave as if EOF was reached.
--   
--   <a>hGetBuf</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBuf :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufSome</a> <tt>hdl buf count</tt> reads data from the handle
--   <tt>hdl</tt> into the buffer <tt>buf</tt>. If there is any data
--   available to read, then <a>hGetBufSome</a> returns it immediately; it
--   only blocks if there is no data to be read.
--   
--   It returns the number of bytes actually read. This may be zero if EOF
--   was reached before any data was read (or if <tt>count</tt> is zero).
--   
--   <a>hGetBufSome</a> never raises an EOF exception, instead it returns a
--   value smaller than <tt>count</tt>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufSome</a> will behave as if EOF was reached.
--   
--   <a>hGetBufSome</a> ignores the prevailing <a>TextEncoding</a> and
--   <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | <a>hGetBufNonBlocking</a> <tt>hdl buf count</tt> reads data from the
--   handle <tt>hdl</tt> into the buffer <tt>buf</tt> until either EOF is
--   reached, or <tt>count</tt> 8-bit bytes have been read, or there is no
--   more data available to read immediately.
--   
--   <a>hGetBufNonBlocking</a> is identical to <a>hGetBuf</a>, except that
--   it will never block waiting for data to become available, instead it
--   returns only whatever data is available. To wait for data to arrive
--   before calling <a>hGetBufNonBlocking</a>, use <a>hWaitForInput</a>.
--   
--   If the handle is a pipe or socket, and the writing end is closed,
--   <a>hGetBufNonBlocking</a> will behave as if EOF was reached.
--   
--   <a>hGetBufNonBlocking</a> ignores the prevailing <a>TextEncoding</a>
--   and <a>NewlineMode</a> on the <a>Handle</a>, and reads bytes directly.
--   
--   NOTE: on Windows, this function does not work correctly; it behaves
--   identically to <a>hGetBuf</a>.
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int

-- | The function creates a temporary file in ReadWrite mode. The created
--   file isn't deleted automatically, so you need to delete it manually.
--   
--   The file is created with permissions such that only the current user
--   can read/write it.
--   
--   With some exceptions (see below), the file will be created securely in
--   the sense that an attacker should not be able to cause openTempFile to
--   overwrite another file on the filesystem using your credentials, by
--   putting symbolic links (on Unix) in the place where the temporary file
--   is to be created. On Unix the <tt>O_CREAT</tt> and <tt>O_EXCL</tt>
--   flags are used to prevent this attack, but note that <tt>O_EXCL</tt>
--   is sometimes not supported on NFS filesystems, so if you rely on this
--   behaviour it is best to use local filesystems only.
openTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but opens the file in binary mode. See
--   <a>openBinaryFile</a> for more comments.
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openTempFile</a>, but uses the default file permissions
openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | Like <a>openBinaryTempFile</a>, but uses the default file permissions
openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)

-- | The action <a>hSetEncoding</a> <tt>hdl</tt> <tt>encoding</tt> changes
--   the text encoding for the handle <tt>hdl</tt> to <tt>encoding</tt>.
--   The default encoding when a <a>Handle</a> is created is
--   <a>localeEncoding</a>, namely the default encoding for the current
--   locale.
--   
--   To create a <a>Handle</a> with no encoding at all, use
--   <a>openBinaryFile</a>. To stop further encoding or decoding on an
--   existing <a>Handle</a>, use <a>hSetBinaryMode</a>.
--   
--   <a>hSetEncoding</a> may need to flush buffered data in order to change
--   the encoding.
hSetEncoding :: Handle -> TextEncoding -> IO ()

-- | Return the current <a>TextEncoding</a> for the specified
--   <a>Handle</a>, or <a>Nothing</a> if the <a>Handle</a> is in binary
--   mode.
--   
--   Note that the <a>TextEncoding</a> remembers nothing about the state of
--   the encoder/decoder in use on this <a>Handle</a>. For example, if the
--   encoding in use is UTF-16, then using <a>hGetEncoding</a> and
--   <a>hSetEncoding</a> to save and restore the encoding may result in an
--   extra byte-order-mark being written to the file.
hGetEncoding :: Handle -> IO (Maybe TextEncoding)

-- | A <a>TextEncoding</a> is a specification of a conversion scheme
--   between sequences of bytes and sequences of Unicode characters.
--   
--   For example, UTF-8 is an encoding of Unicode characters into a
--   sequence of bytes. The <a>TextEncoding</a> for UTF-8 is <a>utf8</a>.
data TextEncoding

-- | The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to
--   the first 256 Unicode code points, and is thus not a complete Unicode
--   encoding. An attempt to write a character greater than <tt>'\255'</tt>
--   to a <a>Handle</a> using the <a>latin1</a> encoding will result in an
--   error.
latin1 :: TextEncoding

-- | The UTF-8 Unicode encoding
utf8 :: TextEncoding

-- | The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte
--   sequence 0xEF 0xBB 0xBF). This encoding behaves like <a>utf8</a>,
--   except that on input, the BOM sequence is ignored at the beginning of
--   the stream, and on output, the BOM sequence is prepended.
--   
--   The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes
--   used to identify the encoding of a file.
utf8_bom :: TextEncoding

-- | The UTF-16 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf16 :: TextEncoding

-- | The UTF-16 Unicode encoding (little-endian)
utf16le :: TextEncoding

-- | The UTF-16 Unicode encoding (big-endian)
utf16be :: TextEncoding

-- | The UTF-32 Unicode encoding (a byte-order-mark should be used to
--   indicate endianness).
utf32 :: TextEncoding

-- | The UTF-32 Unicode encoding (little-endian)
utf32le :: TextEncoding

-- | The UTF-32 Unicode encoding (big-endian)
utf32be :: TextEncoding

-- | The Unicode encoding of the current locale
--   
--   This is the initial locale encoding: if it has been subsequently
--   changed by <a>setLocaleEncoding</a> this value will not reflect that
--   change.
localeEncoding :: TextEncoding

-- | An encoding in which Unicode code points are translated to bytes by
--   taking the code point modulo 256. When decoding, bytes are translated
--   directly into the equivalent code point.
--   
--   This encoding never fails in either direction. However, encoding
--   discards information, so encode followed by decode is not the
--   identity.
char8 :: TextEncoding

-- | Look up the named Unicode encoding. May fail with
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the encoding is unknown</li>
--   </ul>
--   
--   The set of known encodings is system-dependent, but includes at least:
--   
--   <ul>
--   <li><pre>UTF-8</pre></li>
--   <li><tt>UTF-16</tt>, <tt>UTF-16BE</tt>, <tt>UTF-16LE</tt></li>
--   <li><tt>UTF-32</tt>, <tt>UTF-32BE</tt>, <tt>UTF-32LE</tt></li>
--   </ul>
--   
--   There is additional notation (borrowed from GNU iconv) for specifying
--   how illegal characters are handled:
--   
--   <ul>
--   <li>a suffix of <tt>//IGNORE</tt>, e.g. <tt>UTF-8//IGNORE</tt>, will
--   cause all illegal sequences on input to be ignored, and on output will
--   drop all code points that have no representation in the target
--   encoding.</li>
--   <li>a suffix of <tt>//TRANSLIT</tt> will choose a replacement
--   character for illegal sequences or code points.</li>
--   <li>a suffix of <tt>//ROUNDTRIP</tt> will use a PEP383-style escape
--   mechanism to represent any invalid bytes in the input as Unicode
--   codepoints (specifically, as lone surrogates, which are normally
--   invalid in UTF-32). Upon output, these special codepoints are detected
--   and turned back into the corresponding original byte.</li>
--   </ul>
--   
--   In theory, this mechanism allows arbitrary data to be roundtripped via
--   a <a>String</a> with no loss of data. In practice, there are two
--   limitations to be aware of:
--   
--   <ol>
--   <li>This only stands a chance of working for an encoding which is an
--   ASCII superset, as for security reasons we refuse to escape any bytes
--   smaller than 128. Many encodings of interest are ASCII supersets (in
--   particular, you can assume that the locale encoding is an ASCII
--   superset) but many (such as UTF-16) are not.</li>
--   <li>If the underlying encoding is not itself roundtrippable, this
--   mechanism can fail. Roundtrippable encodings are those which have an
--   injective mapping into Unicode. Almost all encodings meet this
--   criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain
--   several different encodings of the same Unicode codepoint.</li>
--   </ol>
--   
--   On Windows, you can access supported code pages with the prefix
--   <tt>CP</tt>; for example, <tt>"CP1250"</tt>.
mkTextEncoding :: String -> IO TextEncoding

-- | Set the <a>NewlineMode</a> on the specified <a>Handle</a>. All
--   buffered data is flushed first.
hSetNewlineMode :: Handle -> NewlineMode -> IO ()

-- | The representation of a newline in the external file or stream.
data Newline

-- | <pre>
--   '\n'
--   </pre>
LF :: Newline

-- | <pre>
--   '\r\n'
--   </pre>
CRLF :: Newline

-- | The native newline representation for the current platform: <a>LF</a>
--   on Unix systems, <a>CRLF</a> on Windows.
nativeNewline :: Newline

-- | Specifies the translation, if any, of newline characters between
--   internal Strings and the external file or stream. Haskell Strings are
--   assumed to represent newlines with the <tt>'\n'</tt> character; the
--   newline mode specifies how to translate <tt>'\n'</tt> on output, and
--   what to translate into <tt>'\n'</tt> on input.
data NewlineMode
NewlineMode :: Newline -> Newline -> NewlineMode

-- | the representation of newlines on input
[inputNL] :: NewlineMode -> Newline

-- | the representation of newlines on output
[outputNL] :: NewlineMode -> Newline

-- | Do no newline translation at all.
--   
--   <pre>
--   noNewlineTranslation  = NewlineMode { inputNL  = LF, outputNL = LF }
--   </pre>
noNewlineTranslation :: NewlineMode

-- | Map <tt>'\r\n'</tt> into <tt>'\n'</tt> on input, and <tt>'\n'</tt> to
--   the native newline representation on output. This mode can be used on
--   any platform, and works with text files using any newline convention.
--   The downside is that <tt>readFile &gt;&gt;= writeFile</tt> might yield
--   a different file.
--   
--   <pre>
--   universalNewlineMode  = NewlineMode { inputNL  = CRLF,
--                                         outputNL = nativeNewline }
--   </pre>
universalNewlineMode :: NewlineMode

-- | Use the native newline representation on both input and output
--   
--   <pre>
--   nativeNewlineMode  = NewlineMode { inputNL  = nativeNewline
--                                      outputNL = nativeNewline }
--   </pre>
nativeNewlineMode :: NewlineMode

module GHC.Fingerprint
data Fingerprint
Fingerprint :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> Fingerprint
fingerprint0 :: Fingerprint
fingerprintData :: Ptr Word8 -> Int -> IO Fingerprint
fingerprintString :: String -> Fingerprint
fingerprintFingerprints :: [Fingerprint] -> Fingerprint

-- | Computes the hash of a given file. This function loops over the
--   handle, running in constant memory.
getFileHash :: FilePath -> IO Fingerprint


-- | Monadic fixpoints.
--   
--   For a detailed discussion, see Levent Erkok's thesis, <i>Value
--   Recursion in Monadic Computations</i>, Oregon Graduate Institute,
--   2002.
module Control.Monad.Fix

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i>Purity</i> <tt><a>mfix</a> (<a>return</a> . h) = <a>return</a>
--   (<a>fix</a> h)</tt></li>
--   <li><i>Left shrinking (or Tightening)</i> <tt><a>mfix</a> (\x -&gt; a
--   &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y -&gt; <a>mfix</a> (\x -&gt;
--   f x y)</tt></li>
--   <li><i>Sliding</i> <tt><a>mfix</a> (<a>liftM</a> h . f) = <a>liftM</a>
--   h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i>Nesting</i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y -&gt; f x
--   y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class (Monad m) => MonadFix m

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a
instance Control.Monad.Fix.MonadFix Solo
instance Control.Monad.Fix.MonadFix GHC.Maybe.Maybe
instance Control.Monad.Fix.MonadFix []
instance Control.Monad.Fix.MonadFix GHC.Base.NonEmpty
instance Control.Monad.Fix.MonadFix GHC.Types.IO
instance Control.Monad.Fix.MonadFix ((->) r)
instance Control.Monad.Fix.MonadFix (Data.Either.Either e)
instance Control.Monad.Fix.MonadFix (GHC.ST.ST s)
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Dual
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Sum
instance Control.Monad.Fix.MonadFix Data.Semigroup.Internal.Product
instance Control.Monad.Fix.MonadFix Data.Monoid.First
instance Control.Monad.Fix.MonadFix Data.Monoid.Last
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (Data.Monoid.Ap f)
instance Control.Monad.Fix.MonadFix GHC.Generics.Par1
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.Rec1 f)
instance Control.Monad.Fix.MonadFix f => Control.Monad.Fix.MonadFix (GHC.Generics.M1 i c f)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (f GHC.Generics.:*: g)
instance Control.Monad.Fix.MonadFix Data.Ord.Down


-- | The identity functor and monad.
--   
--   This trivial type constructor serves two purposes:
--   
--   <ul>
--   <li>It can be used with functions parameterized by functor or monad
--   classes.</li>
--   <li>It can be used as a base monad to which a series of monad
--   transformers may be applied to construct a composite monad. Most monad
--   transformer modules include the special case of applying the
--   transformer to <a>Identity</a>. For example, <tt>State s</tt> is an
--   abbreviation for <tt>StateT s <a>Identity</a></tt>.</li>
--   </ul>
module Data.Functor.Identity

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Identity.Identity a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
instance GHC.Real.Real a => GHC.Real.Real (Data.Functor.Identity.Identity a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Identity.Identity a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Identity.Identity a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Identity.Identity a)
instance GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Identity.Identity a)
instance GHC.Generics.Generic1 Data.Functor.Identity.Identity
instance GHC.Generics.Generic (Data.Functor.Identity.Identity a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Identity.Identity a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Identity.Identity a)
instance GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Identity.Identity a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Identity.Identity a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
instance GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Identity.Identity a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a)
instance Data.Foldable.Foldable Data.Functor.Identity.Identity
instance GHC.Base.Functor Data.Functor.Identity.Identity
instance GHC.Base.Applicative Data.Functor.Identity.Identity
instance GHC.Base.Monad Data.Functor.Identity.Identity
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity


-- | Basic arrow definitions, based on
--   
--   <ul>
--   <li><i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science
--   of Computer Programming</i> 37, pp67-111, May 2000.</li>
--   </ul>
--   
--   plus a couple of definitions (<a>returnA</a> and <a>loop</a>) from
--   
--   <ul>
--   <li><i>A New Notation for Arrows</i>, by Ross Paterson, in <i>ICFP
--   2001</i>, Firenze, Italy, pp229-240.</li>
--   </ul>
--   
--   These papers and more information on arrows can be found at
--   <a>http://www.haskell.org/arrows/</a>.
module Control.Arrow

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a> assoc =
--   <a>arr</a> assoc &gt;&gt;&gt; <a>first</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow a

-- | Lift a function to an arrow.
arr :: Arrow a => (b -> c) -> a b c

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&

-- | Kleisli arrows of a monad.
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
[runKleisli] :: Kleisli m a b -> a -> m b

-- | The identity arrow, which plays the role of <a>return</a> in arrow
--   notation.
returnA :: Arrow a => a b b

-- | Precomposition with a pure function.
(^>>) :: Arrow a => (b -> c) -> a c d -> a b d
infixr 1 ^>>

-- | Postcomposition with a pure function.
(>>^) :: Arrow a => a b c -> (c -> d) -> a b d
infixr 1 >>^

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | Precomposition with a pure function (right-to-left variant).
(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
infixr 1 <<^

-- | Postcomposition with a pure function (right-to-left variant).
(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
infixr 1 ^<<
class Arrow a => ArrowZero a
zeroArrow :: ArrowZero a => a b c

-- | A monoid on arrows.
class ArrowZero a => ArrowPlus a

-- | An associative operation with identity <a>zeroArrow</a>.
(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
infixr 5 <+>

-- | Choice, for arrows that support it. This class underlies the
--   <tt>if</tt> and <tt>case</tt> constructs in arrow notation.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>left</a> (<a>arr</a> f) = <a>arr</a> (<a>left</a>
--   f)</pre></li>
--   <li><pre><a>left</a> (f &gt;&gt;&gt; g) = <a>left</a> f &gt;&gt;&gt;
--   <a>left</a> g</pre></li>
--   <li><pre>f &gt;&gt;&gt; <a>arr</a> <a>Left</a> = <a>arr</a>
--   <a>Left</a> &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> +++ g) =
--   <a>arr</a> (<a>id</a> +++ g) &gt;&gt;&gt; <a>left</a> f</pre></li>
--   <li><pre><a>left</a> (<a>left</a> f) &gt;&gt;&gt; <a>arr</a> assocsum
--   = <a>arr</a> assocsum &gt;&gt;&gt; <a>left</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assocsum (Left (Left x)) = Left x
--   assocsum (Left (Right y)) = Right (Left y)
--   assocsum (Right z) = Right (Right z)
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Arrow a => ArrowChoice a

-- | Feed marked inputs through the argument arrow, passing the rest
--   through unchanged to the output.
left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)

-- | A mirror image of <a>left</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)

-- | Split the input between the two argument arrows, retagging and merging
--   their outputs. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')

-- | Fanin: Split the input between the two argument arrows and merge their
--   outputs.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
infixr 2 |||
infixr 2 +++

-- | Some arrows allow application of arrow inputs to other inputs.
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>first</a> (<a>arr</a> (\x -&gt; <a>arr</a> (\y -&gt;
--   (x,y)))) &gt;&gt;&gt; <a>app</a> = <a>id</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (g &gt;&gt;&gt;)) &gt;&gt;&gt;
--   <a>app</a> = <a>second</a> g &gt;&gt;&gt; <a>app</a></pre></li>
--   <li><pre><a>first</a> (<a>arr</a> (&gt;&gt;&gt; h)) &gt;&gt;&gt;
--   <a>app</a> = <a>app</a> &gt;&gt;&gt; h</pre></li>
--   </ul>
--   
--   Such arrows are equivalent to monads (see <a>ArrowMonad</a>).
class Arrow a => ArrowApply a
app :: ArrowApply a => a (a b c, b) c

-- | The <a>ArrowApply</a> class is equivalent to <a>Monad</a>: any monad
--   gives rise to a <a>Kleisli</a> arrow, and any instance of
--   <a>ArrowApply</a> defines a monad.
newtype ArrowMonad a b
ArrowMonad :: a () b -> ArrowMonad a b

-- | Any instance of <a>ArrowApply</a> can be made into an instance of
--   <a>ArrowChoice</a> by defining <a>left</a> = <a>leftApp</a>.
leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)

-- | The <a>loop</a> operator expresses computations in which an output
--   value is fed back as input, although the computation occurs only once.
--   It underlies the <tt>rec</tt> value recursion construct in arrow
--   notation. <a>loop</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>extension</i></i> <tt><a>loop</a> (<a>arr</a> f) =
--   <a>arr</a> (\ b -&gt; <a>fst</a> (<a>fix</a> (\ (c,d) -&gt; f
--   (b,d))))</tt></li>
--   <li><i><i>left tightening</i></i> <tt><a>loop</a> (<a>first</a> h
--   &gt;&gt;&gt; f) = h &gt;&gt;&gt; <a>loop</a> f</tt></li>
--   <li><i><i>right tightening</i></i> <tt><a>loop</a> (f &gt;&gt;&gt;
--   <a>first</a> h) = <a>loop</a> f &gt;&gt;&gt; h</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>loop</a> (f &gt;&gt;&gt; <a>arr</a>
--   (<a>id</a> *** k)) = <a>loop</a> (<a>arr</a> (<a>id</a> *** k)
--   &gt;&gt;&gt; f)</tt></li>
--   <li><i><i>vanishing</i></i> <tt><a>loop</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> unassoc &gt;&gt;&gt; f &gt;&gt;&gt; <a>arr</a>
--   assoc)</tt></li>
--   <li><i><i>superposing</i></i> <tt><a>second</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> assoc &gt;&gt;&gt; <a>second</a> f
--   &gt;&gt;&gt; <a>arr</a> unassoc)</tt></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   unassoc (a,(b,c)) = ((a,b),c)
--   </pre>
class Arrow a => ArrowLoop a
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
instance GHC.Generics.Generic (Control.Arrow.Kleisli m a b)
instance GHC.Generics.Generic1 (Control.Arrow.Kleisli m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Arrow.Kleisli m a)
instance Control.Arrow.ArrowLoop (->)
instance Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a)
instance (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a)
instance Control.Arrow.ArrowApply (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m)
instance Control.Arrow.ArrowChoice (->)
instance GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m)
instance GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Arrow.Kleisli m a)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Arrow.Kleisli m a)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Arrow.Kleisli m a)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Arrow.Kleisli m a)
instance GHC.Base.Monad m => Control.Category.Category (Control.Arrow.Kleisli m)
instance GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m)
instance Control.Arrow.Arrow (->)


-- | This module describes a structure intermediate between a functor and a
--   monad (technically, a strong lax monoidal functor). Compared with
--   monads, this interface lacks the full power of the binding operation
--   <a>&gt;&gt;=</a>, but
--   
--   <ul>
--   <li>it has more instances.</li>
--   <li>it is sufficient for many uses, e.g. context-free parsing, or the
--   <a>Traversable</a> class.</li>
--   <li>instances can perform analysis of computations before they are
--   executed, and thus produce shared optimizations.</li>
--   </ul>
--   
--   This interface was introduced for parsers by Niklas Röjemo, because it
--   admits more sharing than the monadic interface. The names here are
--   mostly based on parsing work by Doaitse Swierstra.
--   
--   For more details, see <a>Applicative Programming with Effects</a>, by
--   Conor McBride and Ross Paterson.
module Control.Applicative

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative f

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | The <a>Const</a> functor.
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
[unwrapMonad] :: WrappedMonad m a -> m a
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
[unwrapArrow] :: WrappedArrow a b c -> a b c

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: <tt><a>liftA</a>
--   f a = <a>pure</a> f <a>&lt;*&gt;</a> a</tt>
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the Applicative instance for Lists:
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) [1, 2]
--   [2,3]
--   </pre>
--   
--   Or the Applicative instance for <a>Maybe</a>
--   
--   <pre>
--   &gt;&gt;&gt; liftA (+1) (Just 3)
--   Just 4
--   </pre>
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
instance GHC.Generics.Generic1 Control.Applicative.ZipList
instance GHC.Generics.Generic (Control.Applicative.ZipList a)
instance Data.Foldable.Foldable Control.Applicative.ZipList
instance GHC.Base.Functor Control.Applicative.ZipList
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a)
instance GHC.Base.Applicative Control.Applicative.ZipList
instance GHC.Base.Alternative Control.Applicative.ZipList
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m)


-- | Class of data structures that can be traversed from left to right,
--   performing an action on each element. Instances are expected to
--   satisfy the listed <a>laws</a>.
module Data.Traversable

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forAccumM</a> is <a>mapAccumM</a> with the arguments rearranged.
forAccumM :: (Monad m, Traversable t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumM</a> function behaves like a combination of
--   <a>mapM</a> and <a>mapAccumL</a> that traverses the structure while
--   evaluating the actions and passing an accumulating parameter from left
--   to right. It returns a final value of this accumulator together with
--   the new structure. The accummulator is often used for caching the
--   intermediate results of a computation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let expensiveDouble a = putStrLn ("Doubling " &lt;&gt; show a) &gt;&gt; pure (2 * a)
--   
--   &gt;&gt;&gt; :{
--   mapAccumM (\cache a -&gt; case lookup a cache of
--       Nothing -&gt; expensiveDouble a &gt;&gt;= \double -&gt; pure ((a, double):cache, double)
--       Just double -&gt; pure (cache, double)
--       ) [] [1, 2, 3, 1, 2, 3]
--   :}
--   Doubling 1
--   Doubling 2
--   Doubling 3
--   ([(3,6),(2,4),(1,2)],[2,4,6,2,4,6])
--   </pre>
mapAccumM :: forall m t s a b. (Monad m, Traversable t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance Data.Traversable.Traversable Solo
instance Data.Traversable.Traversable Data.Functor.Identity.Identity
instance Data.Traversable.Traversable GHC.Generics.V1
instance Data.Traversable.Traversable GHC.Generics.Par1
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.Rec1 f)
instance Data.Traversable.Traversable (GHC.Generics.K1 i c)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.M1 i c f)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:+: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:*: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:.: g)
instance Data.Traversable.Traversable GHC.Generics.UAddr
instance Data.Traversable.Traversable GHC.Generics.UChar
instance Data.Traversable.Traversable GHC.Generics.UDouble
instance Data.Traversable.Traversable GHC.Generics.UFloat
instance Data.Traversable.Traversable GHC.Generics.UInt
instance Data.Traversable.Traversable GHC.Generics.UWord
instance Data.Traversable.Traversable Data.Ord.Down
instance Data.Traversable.Traversable GHC.Maybe.Maybe
instance Data.Traversable.Traversable []
instance Data.Traversable.Traversable GHC.Base.NonEmpty
instance Data.Traversable.Traversable (Data.Either.Either a)
instance Data.Traversable.Traversable ((,) a)
instance GHC.Ix.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i)
instance Data.Traversable.Traversable Data.Proxy.Proxy
instance Data.Traversable.Traversable (Data.Functor.Const.Const m)
instance Data.Traversable.Traversable Data.Semigroup.Internal.Dual
instance Data.Traversable.Traversable Data.Semigroup.Internal.Sum
instance Data.Traversable.Traversable Data.Semigroup.Internal.Product
instance Data.Traversable.Traversable Data.Monoid.First
instance Data.Traversable.Traversable Data.Monoid.Last
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Semigroup.Internal.Alt f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Monoid.Ap f)
instance Data.Traversable.Traversable Control.Applicative.ZipList
instance Data.Traversable.Traversable GHC.Generics.U1


-- | Operations on lists.
module Data.List

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | Produce singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
singleton :: a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
--   
--   For this reason the outer list must be finite; otherwise
--   <a>transpose</a> hangs:
--   
--   <pre>
--   &gt;&gt;&gt; transpose (repeat [])
--   * Hangs forever *
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 8 $ subsequences ['a'..]
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   The <a>permutations</a> function is maximally lazy: for each
--   <tt>n</tt>, the value of <tt><a>permutations</a> xs</tt> starts with
--   those permutations that permute <tt><a>take</a> n xs</tt> and keep
--   <tt><a>drop</a> n xs</tt>.
--   
--   This function is productive on infinite inputs:
--   
--   <pre>
--   &gt;&gt;&gt; take 6 $ map (take 3) $ permutations ['a'..]
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
--   
--   Note that the order of permutations is not lexicographic. It satisfies
--   the following property:
--   
--   <pre>
--   map (take n) (take (product [1..n]) (permutations ([1..n] ++ undefined))) == permutations [1..n]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: HasCallStack => (a -> a -> a) -> [a] -> a

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result is non-empty and all elements are
--   equal to the first one. For example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   <a>group</a> is a special case of <a>groupBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   It's often preferable to use <tt>Data.List.NonEmpty.</tt><a>group</a>,
--   which provides type-level guarantees of non-emptiness of inner lists.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
--   
--   <a>inits</a> is semantically equivalent to <tt><a>map</a>
--   <a>reverse</a> . <a>scanl</a> (<a>flip</a> (:)) []</tt>, but under the
--   hood uses a queue to amortize costs of <a>reverse</a>.
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite;
--   <a>False</a>, however, results from any mismatch:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isPrefixOf` [1..]
--   False
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isPrefixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isPrefixOf` [0..]
--   * Hangs forever *
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
--   
--   The second list must be finite; however the first list may be
--   infinite:
--   
--   <pre>
--   &gt;&gt;&gt; [0..] `isSuffixOf` [0..99]
--   False
--   
--   &gt;&gt;&gt; [0..99] `isSuffixOf` [0..]
--   * Hangs forever *
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [20..50] `isInfixOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [20..50]
--   False
--   
--   &gt;&gt;&gt; [0..] `isInfixOf` [0..]
--   * Hangs forever *
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
--   
--   For the result to be <a>True</a>, the first list must be finite; for
--   the result to be <a>False</a>, the second list must be finite:
--   
--   <pre>
--   &gt;&gt;&gt; [0,2..10] `isSubsequenceOf` [0..]
--   True
--   
--   &gt;&gt;&gt; [0..] `isSubsequenceOf` [0,2..10]
--   False
--   
--   &gt;&gt;&gt; [0,2..] `isSubsequenceOf` [0..]
--   * Hangs forever*
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element. For the result to be
--   <a>Nothing</a>, the list must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
--   
--   If the order of outputs does not matter and there exists <tt>instance
--   Ord a</tt>, it's faster to use <a>map</a>
--   <tt>Data.List.NonEmpty.</tt><a>head</a> .
--   <tt>Data.List.NonEmpty.</tt><a>group</a> . <a>sort</a>, which takes
--   only &lt;math&gt; time.
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus <tt>(xs ++ ys) \\ xs == ys</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
--   
--   The second list must be finite, but the first may be infinite.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..4])
--   [0,1,5,6,7]
--   
--   &gt;&gt;&gt; take 5 ([0..] \\ [2..])
--   * Hangs forever *
--   </pre>
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. It
--   is a special case of <a>unionBy</a>, which allows the programmer to
--   supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used. If the second list contains equal elements, only
--   the first one will be retained:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; union [Arg () "dog"] [Arg () "cow"]
--   [Arg () "dog"]
--   
--   &gt;&gt;&gt; union [] [Arg () "dog", Arg () "cow"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result:
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `union` "duck"
--   "cootduk"
--   
--   &gt;&gt;&gt; "duck" `union` "coot"
--   "duckot"
--   </pre>
--   
--   <a>union</a> is productive even if both arguments are infinite.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If equal elements are present in both lists, an element from the first
--   list will be used, and all duplicates from the second list quashed:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; intersect [Arg () "dog"] [Arg () "cow", Arg () "cat"]
--   [Arg () "dog"]
--   </pre>
--   
--   However if the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; "coot" `intersect` "heron"
--   "oo"
--   
--   &gt;&gt;&gt; "heron" `intersect` "coot"
--   "o"
--   </pre>
--   
--   If the second list is infinite, <a>intersect</a> either hangs or
--   returns its first argument in full. Otherwise if the first list is
--   infinite, <a>intersect</a> might be productive:
--   
--   <pre>
--   &gt;&gt;&gt; intersect [100..] [0..]
--   [100,101,102,103...
--   
--   &gt;&gt;&gt; intersect [0] [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect [1..] [0]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; intersect (cycle [1..3]) [2]
--   [2,2,2,2...
--   </pre>
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   The argument must be finite.
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt><a>sortOn</a> f</tt> is equivalent to <tt><a>sortBy</a>
--   (<a>comparing</a> f)</tt>, but has the performance advantage of only
--   evaluating <tt>f</tt> once for each element in the input list. This is
--   called the decorate-sort-undecorate paradigm, or <a>Schwartzian
--   transform</a>.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The argument must be finite.
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed. This is the non-overloaded version of
--   <a>(\\)</a>.
--   
--   The second list must be finite, but the first may be infinite.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>. Both arguments may be infinite.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>. It is productive for infinite arguments only if the
--   first one is a subset of the second.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
--   
--   When a supplied relation is not transitive, it is important to
--   remember that equality is checked against the first element in the
--   group, not against the nearest neighbour:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (\a b -&gt; b - a &lt; 5) [0..19]
--   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19]]
--   </pre>
--   
--   It's often preferable to use
--   <tt>Data.List.NonEmpty.</tt><a>groupBy</a>, which provides type-level
--   guarantees of non-emptiness of inner lists.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>. The argument must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
--   
--   The supplied comparison relation is supposed to be reflexive and
--   antisymmetric, otherwise, e. g., for <tt>_ _ -&gt; GT</tt>, the
--   ordered list simply does not exist. The relation is also expected to
--   be transitive: if it is not then <a>sortBy</a> might fail to find an
--   ordered permutation, even if it exists.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
--   
--   Users should take care to pick a return type that is wide enough to
--   contain the full length of the list. If the width is insufficient, the
--   overflow behaviour will depend on the <tt>(+)</tt> implementation in
--   the selected <a>Num</a> instance. The following example overflows
--   because the actual list length of 200 lies outside of the
--   <tt>Int8</tt> range of <tt>-128..127</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1..200] :: Int8
--   -56
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


-- | Functions for tracing and monitoring execution.
--   
--   These can be useful for investigating bugs or performance problems.
--   They should <i>not</i> be used in production code.
module Debug.Trace

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> and outputs the
--   message to stderr. Depending on your terminal (settings), they may or
--   may not be mixed.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   calling f with x = 123
--   "123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   hello
--   "hello"
--   </pre>
traceId :: String -> String

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but outputs the result of calling a function on the
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; traceWith fst ("hello","world")
--   hello
--   ("hello","world")
--   </pre>
traceWith :: (a -> String) -> a -> a

-- | Like <a>traceWith</a>, but uses <a>show</a> on the result of the
--   function to convert it to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowWith length [1,2,3]
--   3
--   [1,2,3]
--   </pre>
traceShowWith :: Show b => (a -> b) -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: String -> a -> a

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <a>MonadIO</a>, <tt><a>liftIO</a> .
--   <a>traceIO</a></tt> may be a better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()


-- | <i>Deprecated: Use <a>traceIO</a></i>
putTraceMsg :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: String -> a -> a

-- | Like <a>traceEvent</a>, but emits the result of calling a function on
--   its argument.
traceEventWith :: (a -> String) -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | Immediately flush the event log, if enabled.
flushEventLog :: IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: String -> a -> a

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()


-- | The <tt>String</tt> type and associated operations.
module Data.String

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class IsString a
fromString :: IsString a => String -> a

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String
instance forall a k (b :: k). Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b)
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a)
instance (a GHC.Types.~ GHC.Types.Char) => Data.String.IsString [a]


-- | A general library for representation and manipulation of versions.
--   
--   Versioning schemes are many and varied, so the version representation
--   provided by this library is intended to be a compromise between
--   complete generality, where almost no common functionality could
--   reasonably be provided, and fixing a particular versioning scheme,
--   which would probably be too restrictive.
--   
--   So the approach taken here is to provide a representation which
--   subsumes many of the versioning schemes commonly in use, and we
--   provide implementations of <a>Eq</a>, <a>Ord</a> and conversion
--   to/from <a>String</a> which will be appropriate for some applications,
--   but not all.
module Data.Version

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version
Version :: [Int] -> [String] -> Version

-- | The numeric branch for this version. This reflects the fact that most
--   software versions are tree-structured; there is a main trunk which is
--   tagged with versions at various points (1,2,3...), and the first
--   branch off the trunk after version 3 is 3.1, the second branch off the
--   trunk after version 3 is 3.2, and so on. The tree can be branched
--   arbitrarily, just by adding more digits.
--   
--   We represent the branch as a list of <a>Int</a>, so version 3.2.1
--   becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of
--   <a>Ord</a> for <tt>[Int]</tt>) gives the natural ordering of branches.
[versionBranch] :: Version -> [Int]

-- | A version can be tagged with an arbitrary list of strings. The
--   interpretation of the list of tags is entirely dependent on the entity
--   that this version applies to.

-- | <i>Deprecated: See GHC ticket #2496</i>
[versionTags] :: Version -> [String]

-- | Provides one possible concrete representation for <a>Version</a>. For
--   a version with <a>versionBranch</a> <tt>= [1,2,3]</tt> and
--   <a>versionTags</a> <tt>= ["tag1","tag2"]</tt>, the output will be
--   <tt>1.2.3-tag1-tag2</tt>.
showVersion :: Version -> String

-- | A parser for versions in the format produced by <a>showVersion</a>.
parseVersion :: ReadP Version

-- | Construct tag-less <a>Version</a>
makeVersion :: [Int] -> Version
instance GHC.Generics.Generic Data.Version.Version
instance GHC.Show.Show Data.Version.Version
instance GHC.Read.Read Data.Version.Version
instance GHC.Classes.Eq Data.Version.Version
instance GHC.Classes.Ord Data.Version.Version


module GHC.IsList

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]
instance GHC.IsList.IsList [a]
instance GHC.IsList.IsList (Control.Applicative.ZipList a)
instance GHC.IsList.IsList (GHC.Base.NonEmpty a)
instance GHC.IsList.IsList Data.Version.Version
instance GHC.IsList.IsList GHC.Stack.Types.CallStack


-- | The <a>Functor</a>, <a>Monad</a> and <a>MonadPlus</a> classes, with
--   some useful operations on monads.
module Control.Monad

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus m

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results:
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>


-- | The Prelude: a standard module. The Prelude is imported by default
--   into all Haskell modules unless either there is an explicit import
--   statement for it, or the NoImplicitPrelude extension is enabled.
module Prelude
data () => Bool
False :: Bool
True :: Bool

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class () => Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data () => Integer

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   <li><i><b>Coherence with <tt>toInteger</tt></b></i> if the type also
--   implements <a>Integral</a>, then <a>fromInteger</a> is a left inverse
--   for <a>toInteger</a>, i.e. <tt>fromInteger (toInteger i) ==
--   i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | Real numbers.
--   
--   The Haskell report defines no laws for <a>Real</a>, however
--   <a>Real</a> instances are customarily expected to adhere to the
--   following law:
--   
--   <ul>
--   <li><i><b>Coherence with <a>fromRational</a></b></i> if the type also
--   implements <a>Fractional</a>, then <a>fromRational</a> is a left
--   inverse for <a>toRational</a>, i.e. <tt>fromRational (toRational i) =
--   i</tt></li>
--   </ul>
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
--   
--   In addition, <a>toInteger</a> should be total, and <a>fromInteger</a>
--   should be a left inverse for it, i.e. <tt>fromInteger (toInteger i) =
--   i</tt>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
--   
--   WARNING: This function is partial (because it throws when 0 is passed
--   as the divisor) for all the integer types in <tt>base</tt>.
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   <li><i><b>Totality of <a>toRational</a></b></i> <a>toRational</a> is
--   total</li>
--   <li><i><b>Coherence with <a>toRational</a></b></i> if the type also
--   implements <a>Real</a>, then <a>fromRational</a> is a left inverse for
--   <a>toRational</a>, i.e. <tt>fromRational (toRational i) = i</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class (Num a) => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | General coercion from <a>Integral</a> types.
--   
--   WARNING: This function performs silent truncation if the result type
--   is not at least as big as the argument's type.
fromIntegral :: (Integral a, Num b) => a -> b

-- | General coercion to <a>Fractional</a> types.
--   
--   WARNING: This function goes through the <a>Rational</a> type, which
--   does not have values for <tt>NaN</tt> for example. This means it does
--   not round-trip.
--   
--   For <a>Double</a> it also behaves differently with or without -O0:
--   
--   <pre>
--   Prelude&gt; realToFrac nan -- With -O0
--   -Infinity
--   Prelude&gt; realToFrac nan
--   NaN
--   </pre>
realToFrac :: (Real a, Fractional b) => a -> b

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable t

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain <i>O(n)</i> elements
--   long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x y</tt> always evaluates to <tt>x</tt>, ignoring its second
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is representation-polymorphic in its
--   result type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool
--   -&gt; Int#</tt> is well-typed.
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => [Char] -> a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep). forall (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
--   
--   WARNING: This function takes linear time in the number of elements of
--   the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching,
--   <a>uncons</a> or <a>listToMaybe</a> instead.
head :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching, <a>uncons</a> or <a>listToMaybe</a> instead.
last :: HasCallStack => [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use case-matching or
--   <a>uncons</a> instead.
tail :: HasCallStack => [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>reverse</a> with
--   case-matching or <a>uncons</a> instead.
init :: HasCallStack => [a] -> [a]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
--   
--   WARNING: This function is partial. You can use <a>atMay</a> instead.
(!!) :: HasCallStack => [a] -> Int -> a
infixl 9 !!

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: HasCallStack => [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list. For the result to be <a>Nothing</a>, the list must
--   be finite.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data () => IO a

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~


-- | The representations of the types <a>TyCon</a> and <a>TypeRep</a>, and
--   the function <a>mkTyCon</a> which is used by derived instances of
--   <a>Typeable</a> to construct <a>TyCon</a>s.
--   
--   Be warned, these functions can be used to construct ill-kinded type
--   representations.
module Type.Reflection.Unsafe

-- | TypeRep is a concrete representation of a (monomorphic) type.
--   <a>TypeRep</a> supports reasonably efficient equality. See Note [Grand
--   plan for Typeable] in GHC.Tc.Instance.Typeable
data TypeRep a

-- | Construct a representation for a type application.
mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep (a :: k1 -> k2) -> TypeRep (b :: k1) -> TypeRep (a b)

-- | Exquisitely unsafe.
mkTyCon :: String -> String -> String -> Int -> KindRep -> TyCon

-- | Observe the <a>Fingerprint</a> of a type representation
typeRepFingerprint :: TypeRep a -> Fingerprint
someTypeRepFingerprint :: SomeTypeRep -> Fingerprint

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data () => KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep
pattern KindRepTypeLit :: TypeLitSort -> String -> KindRep
data () => TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
TypeLitChar :: TypeLitSort
data () => TyCon

-- | Construct a representation for a type constructor applied at a
--   monomorphic kind.
--   
--   Note that this is unsafe as it allows you to construct ill-kinded
--   types.
mkTrCon :: forall k (a :: k). TyCon -> [SomeTypeRep] -> TypeRep a
tyConKindRep :: TyCon -> KindRep
tyConKindArgs :: TyCon -> Int
tyConFingerprint :: TyCon -> Fingerprint


-- | Optional instance of <a>Show</a> for functions:
--   
--   <pre>
--   instance Show (a -&gt; b) where
--      showsPrec _ _ = showString "&lt;function&gt;"
--   </pre>
module Text.Show.Functions
instance GHC.Show.Show (a -> b)


-- | A C <tt>printf(3)</tt>-like formatter. This version has been extended
--   by Bart Massey as per the recommendations of John Meacham and Simon
--   Marlow
--   <a>http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726</a>
--   to support extensible formatting for new datatypes. It has also been
--   extended to support almost all C <tt>printf(3)</tt> syntax.
module Text.Printf

-- | Format a variable number of arguments with the C-style formatting
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; printf "%s, %d, %.4f" "hello" 123 pi
--   hello, 123, 3.1416
--   </pre>
--   
--   The return value is either <a>String</a> or <tt>(<a>IO</a> a)</tt>
--   (which should be <tt>(<a>IO</a> ())</tt>, but Haskell's type system
--   makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a <i>format character</i> that provides the
--   primary information about how to format the value. The rest of the
--   conversion specification is optional. In order, one may have flag
--   characters, a width specifier, a precision specifier, and
--   type-specific modifier characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
printf :: PrintfType r => String -> r

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <tt>printf(3)</tt> for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See <tt>printf(3)</tt> for the
--   details, which vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: Char -> a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: String -> a

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c
instance Text.Printf.IsChar c => Text.Printf.PrintfType [c]
instance (a GHC.Types.~ ()) => Text.Printf.PrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.PrintfType r) => Text.Printf.PrintfType (a -> r)
instance (a GHC.Types.~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a)
instance (Text.Printf.PrintfArg a, Text.Printf.HPrintfType r) => Text.Printf.HPrintfType (a -> r)
instance Text.Printf.PrintfArg GHC.Types.Char
instance Text.Printf.IsChar c => Text.Printf.PrintfArg [c]
instance Text.Printf.PrintfArg GHC.Types.Int
instance Text.Printf.PrintfArg GHC.Int.Int8
instance Text.Printf.PrintfArg GHC.Int.Int16
instance Text.Printf.PrintfArg GHC.Int.Int32
instance Text.Printf.PrintfArg GHC.Int.Int64
instance Text.Printf.PrintfArg GHC.Types.Word
instance Text.Printf.PrintfArg GHC.Word.Word8
instance Text.Printf.PrintfArg GHC.Word.Word16
instance Text.Printf.PrintfArg GHC.Word.Word32
instance Text.Printf.PrintfArg GHC.Word.Word64
instance Text.Printf.PrintfArg GHC.Num.Integer.Integer
instance Text.Printf.PrintfArg GHC.Num.Natural.Natural
instance Text.Printf.PrintfArg GHC.Types.Float
instance Text.Printf.PrintfArg GHC.Types.Double
instance Text.Printf.IsChar GHC.Types.Char


-- | In general terms, a weak pointer is a reference to an object that is
--   not followed by the garbage collector - that is, the existence of a
--   weak pointer to an object has no effect on the lifetime of that
--   object. A weak pointer can be de-referenced to find out whether the
--   object it refers to is still alive or not, and if so to return the
--   object itself.
--   
--   Weak pointers are particularly useful for caches and memo tables. To
--   build a memo table, you build a data structure mapping from the
--   function argument (the key) to its result (the value). When you apply
--   the function to a new argument you first check whether the key/value
--   pair is already in the memo table. The key point is that the memo
--   table itself should not keep the key and value alive. So the table
--   should contain a weak pointer to the key, not an ordinary pointer. The
--   pointer to the value must not be weak, because the only reference to
--   the value might indeed be from the memo table.
--   
--   So it looks as if the memo table will keep all its values alive for
--   ever. One way to solve this is to purge the table occasionally, by
--   deleting entries whose keys have died.
--   
--   The weak pointers in this library support another approach, called
--   <i>finalization</i>. When the key referred to by a weak pointer dies,
--   the storage manager arranges to run a programmer-specified finalizer.
--   In the case of memo tables, for example, the finalizer could remove
--   the key/value pair from the memo table.
--   
--   Another difficulty with the memo table is that the value of a
--   key/value pair might itself contain a pointer to the key. So the memo
--   table keeps the value alive, which keeps the key alive, even though
--   there may be no other references to the key so both should die. The
--   weak pointers in this library provide a slight generalisation of the
--   basic weak-pointer idea, in which each weak pointer actually contains
--   both a key and a value.
module System.Mem.Weak

-- | A weak pointer object with a key and a value. The value has type
--   <tt>v</tt>.
--   
--   A weak pointer expresses a relationship between two objects, the
--   <i>key</i> and the <i>value</i>: if the key is considered to be alive
--   by the garbage collector, then the value is also alive. A reference
--   from the value to the key does <i>not</i> keep the key alive.
--   
--   A weak pointer may also have a finalizer of type <tt>IO ()</tt>; if it
--   does, then the finalizer will be run at most once, at a time after the
--   key has become unreachable by the program ("dead"). The storage
--   manager attempts to run the finalizer(s) for an object soon after the
--   object dies, but promptness is not guaranteed.
--   
--   It is not guaranteed that a finalizer will eventually run, and no
--   attempt is made to run outstanding finalizers when the program exits.
--   Therefore finalizers should not be relied on to clean up resources -
--   other methods (eg. exception handlers) should be employed, possibly in
--   addition to finalizers.
--   
--   References from the finalizer to the key are treated in the same way
--   as references from the value to the key: they do not keep the key
--   alive. A finalizer may therefore resurrect the key, perhaps by storing
--   it in the same data structure.
--   
--   The finalizer, and the relationship between the key and the value,
--   exist regardless of whether the program keeps a reference to the
--   <a>Weak</a> object or not.
--   
--   There may be multiple weak pointers with the same key. In this case,
--   the finalizers for each of these weak pointers will all be run in some
--   arbitrary order, or perhaps concurrently, when the key dies. If the
--   programmer specifies a finalizer that assumes it has the only
--   reference to an object (for example, a file that it wishes to close),
--   then the programmer must ensure that there is only one such finalizer.
--   
--   If there are no other threads to run, the runtime system will check
--   for runnable finalizers before declaring the system to be deadlocked.
--   
--   WARNING: weak pointers to ordinary non-primitive Haskell types are
--   particularly fragile, because the compiler is free to optimise away or
--   duplicate the underlying data structure. Therefore attempting to place
--   a finalizer on an ordinary Haskell type may well result in the
--   finalizer running earlier than you expected. This is not a problem for
--   caches and memo tables where early finalization is benign.
--   
--   Finalizers <i>can</i> be used reliably for types that are created
--   explicitly and have identity, such as <tt>IORef</tt>, <tt>MVar</tt>,
--   and <tt>TVar</tt>. However, to place a finalizer on one of these
--   types, you should use the specific operation provided for that type,
--   e.g. <tt>mkWeakIORef</tt>, <tt>mkWeakMVar</tt> and <tt>mkWeakTVar</tt>
--   respectively. These operations attach the finalizer to the primitive
--   object inside the box (e.g. <tt>MutVar#</tt> in the case of
--   <tt>IORef</tt>), because attaching the finalizer to the box itself
--   fails when the outer box is optimised away by the compiler.
data Weak v

-- | Establishes a weak pointer to <tt>k</tt>, with value <tt>v</tt> and a
--   finalizer.
--   
--   This is the most general interface for building a weak pointer.
mkWeak :: k -> v -> Maybe (IO ()) -> IO (Weak v)

-- | Dereferences a weak pointer. If the key is still alive, then
--   <tt><a>Just</a> v</tt> is returned (where <tt>v</tt> is the
--   <i>value</i> in the weak pointer), otherwise <a>Nothing</a> is
--   returned.
--   
--   The return value of <a>deRefWeak</a> depends on when the garbage
--   collector runs, hence it is in the <a>IO</a> monad.
deRefWeak :: Weak v -> IO (Maybe v)

-- | Causes a the finalizer associated with a weak pointer to be run
--   immediately.
finalize :: Weak v -> IO ()

-- | A specialised version of <a>mkWeak</a>, where the key and the value
--   are the same object:
--   
--   <pre>
--   mkWeakPtr key finalizer = mkWeak key key finalizer
--   </pre>
mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)

-- | A specialised version of <a>mkWeakPtr</a>, where the <a>Weak</a>
--   object returned is simply thrown away (however the finalizer will be
--   remembered by the garbage collector, and will still be run when the
--   key becomes unreachable).
--   
--   Note: adding a finalizer to a <a>ForeignPtr</a> using
--   <a>addFinalizer</a> won't work; use the specialised version
--   <a>addForeignPtrFinalizer</a> instead. For discussion see the
--   <a>Weak</a> type. .
addFinalizer :: key -> IO () -> IO ()

-- | A specialised version of <a>mkWeak</a> where the value is actually a
--   pair of the key and value passed to <a>mkWeakPair</a>:
--   
--   <pre>
--   mkWeakPair key val finalizer = mkWeak key (key,val) finalizer
--   </pre>
--   
--   The advantage of this is that the key can be retrieved by
--   <a>deRefWeak</a> in addition to the value.
mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))


-- | Memory-related system things.
module System.Mem

-- | Triggers an immediate major garbage collection.
performGC :: IO ()

-- | Triggers an immediate major garbage collection.
performMajorGC :: IO ()

-- | Triggers an immediate minor garbage collection.
performMinorGC :: IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()


-- | Information about the characteristics of the host system lucky enough
--   to run your program.
--   
--   For a comprehensive listing of supported platforms, please refer to
--   <a>https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms</a>
module System.Info

-- | The operating system on which the program is running. Common values
--   include:
--   
--   <ul>
--   <li>"darwin" — macOS</li>
--   <li>"freebsd"</li>
--   <li>"linux"</li>
--   <li>"linux-android"</li>
--   <li>"mingw32" — Windows</li>
--   <li>"netbsd"</li>
--   <li>"openbsd"</li>
--   </ul>
os :: String

-- | The machine architecture on which the program is running. Common
--   values include:
--   
--   <ul>
--   <li>"aarch64"</li>
--   <li>"alpha"</li>
--   <li>"arm"</li>
--   <li>"hppa"</li>
--   <li>"hppa1_1"</li>
--   <li>"i386"</li>
--   <li>"ia64"</li>
--   <li>"m68k"</li>
--   <li>"mips"</li>
--   <li>"mipseb"</li>
--   <li>"mipsel"</li>
--   <li>"nios2"</li>
--   <li>"powerpc"</li>
--   <li>"powerpc64"</li>
--   <li>"powerpc64le"</li>
--   <li>"riscv32"</li>
--   <li>"riscv64"</li>
--   <li>"loongarch32"</li>
--   <li>"loongarch64"</li>
--   <li>"rs6000"</li>
--   <li>"s390"</li>
--   <li>"s390x"</li>
--   <li>"sh4"</li>
--   <li>"sparc"</li>
--   <li>"sparc64"</li>
--   <li>"vax"</li>
--   <li>"x86_64"</li>
--   </ul>
arch :: String

-- | The Haskell implementation with which the program was compiled or is
--   being interpreted. On the GHC platform, the value is "ghc".
compilerName :: String

-- | The version of <a>compilerName</a> with which the program was compiled
--   or is being interpreted.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   ghci&gt; compilerVersion
--   Version {versionBranch = [8,8], versionTags = []}
--   </pre>
compilerVersion :: Version

-- | The full version of <a>compilerName</a> with which the program was
--   compiled or is being interpreted. It includes the major, minor,
--   revision and an additional identifier, generally in the form
--   "<a>year</a><a>month</a><a>day</a>".
fullCompilerVersion :: Version


-- | Exiting the program.
module System.Exit

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <a>Handle</a>s <a>stdout</a> and
--   <a>stderr</a> are flushed automatically; any other buffered
--   <a>Handle</a>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as if it had called
--   <a>exitWith</a> <a>ExitSuccess</a>.
--   
--   As an <a>ExitCode</a> is an <a>Exception</a>, it can be caught using
--   the functions of <a>Control.Exception</a>. This means that cleanup
--   computations added with <a>bracket</a> (from <a>Control.Exception</a>)
--   are also executed properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <a>ExitCode</a> as normal, but the
--   exception will not cause the process itself to exit.
exitWith :: ExitCode -> IO a

-- | The computation <a>exitFailure</a> is equivalent to <a>exitWith</a>
--   <tt>(</tt><a>ExitFailure</a> <i>exitfail</i><tt>)</tt>, where
--   <i>exitfail</i> is implementation-dependent.
exitFailure :: IO a

-- | The computation <a>exitSuccess</a> is equivalent to <a>exitWith</a>
--   <a>ExitSuccess</a>, It terminates the program successfully.
exitSuccess :: IO a

-- | Write given error message to <a>stderr</a> and terminate with
--   <a>exitFailure</a>.
die :: String -> IO a


-- | Miscellaneous information about the system environment.
module System.Environment

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Get an action to query the absolute pathname of the current
--   executable.
--   
--   If the operating system provides a reliable way to determine the
--   current executable, return the query action, otherwise return
--   <tt>Nothing</tt>. The action is defined on FreeBSD, Linux, MacOS,
--   NetBSD, and Windows.
--   
--   Even where the query action is defined, there may be situations where
--   no result is available, e.g. if the executable file was deleted while
--   the program is running. Therefore the result of the query action is a
--   <tt>Maybe FilePath</tt>.
--   
--   Note that for scripts and interactive sessions, the result is the path
--   to the interpreter (e.g. ghci.)
--   
--   Note also that while most operating systems return <tt>Nothing</tt> if
--   the executable file was deleted/unlinked, some (including NetBSD)
--   return the original path.
executablePath :: Maybe (IO (Maybe FilePath))

-- | Returns the absolute pathname of the current executable, or
--   <tt>argv[0]</tt> if the operating system does not provide a reliable
--   way query the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
--   
--   If the executable has been deleted, behaviour is ill-defined and
--   varies by operating system. See <a>executablePath</a> for a more
--   reliable way to query the current executable.
getExecutablePath :: IO FilePath

-- | Computation <a>getEnv</a> <tt>var</tt> returns the value of the
--   environment variable <tt>var</tt>. For the inverse, the <a>setEnv</a>
--   function can be used.
--   
--   This computation may fail with:
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the environment variable does not
--   exist.</li>
--   </ul>
getEnv :: String -> IO String

-- | Return the value of the environment variable <tt>var</tt>, or
--   <tt>Nothing</tt> if there is no such value.
--   
--   For POSIX users, this is equivalent to <a>getEnv</a>.
lookupEnv :: String -> IO (Maybe String)

-- | <tt>setEnv name value</tt> sets the specified environment variable to
--   <tt>value</tt>.
--   
--   Early versions of this function operated under the mistaken belief
--   that setting an environment variable to the <i>empty string</i> on
--   Windows removes that environment variable from the environment. For
--   the sake of compatibility, it adopted that behavior on POSIX. In
--   particular
--   
--   <pre>
--   setEnv name ""
--   </pre>
--   
--   has the same effect as
--   
--   <pre>
--   <a>unsetEnv</a> name
--   </pre>
--   
--   If you'd like to be able to set environment variables to blank
--   strings, use <a>setEnv</a>.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
setEnv :: String -> String -> IO ()

-- | <tt>unsetEnv name</tt> removes the specified environment variable from
--   the environment of the current process.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
unsetEnv :: String -> IO ()

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]


-- | A setEnv implementation that allows blank environment variables.
--   Mimics the <a>Env</a> module from the <tt>unix</tt> package, but with
--   support for Windows too.
--   
--   The matrix of platforms that:
--   
--   <ul>
--   <li>support <tt>putenv(<a>FOO</a>)</tt> to unset environment
--   variables,</li>
--   <li>support <tt>putenv("FOO=")</tt> to unset environment variables or
--   set them to blank values,</li>
--   <li>support <tt>unsetenv</tt> to unset environment variables,</li>
--   <li>support <tt>setenv</tt> to set environment variables,</li>
--   <li>etc.</li>
--   </ul>
--   
--   is very complicated. Some platforms don't support unsetting of
--   environment variables at all.
module System.Environment.Blank

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Returns the absolute pathname of the current executable, or
--   <tt>argv[0]</tt> if the operating system does not provide a reliable
--   way query the current executable.
--   
--   Note that for scripts and interactive sessions, this is the path to
--   the interpreter (e.g. ghci.)
--   
--   Since base 4.11.0.0, <a>getExecutablePath</a> resolves symlinks on
--   Windows. If an executable is launched through a symlink,
--   <a>getExecutablePath</a> returns the absolute path of the original
--   executable.
--   
--   If the executable has been deleted, behaviour is ill-defined and
--   varies by operating system. See <a>executablePath</a> for a more
--   reliable way to query the current executable.
getExecutablePath :: IO FilePath

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]

-- | Similar to <a>lookupEnv</a>.
getEnv :: String -> IO (Maybe String)

-- | Get an environment value or a default value.
getEnvDefault :: String -> String -> IO String

-- | Like <a>setEnv</a>, but allows blank environment values and mimics the
--   function signature of <a>setEnv</a> from the <tt>unix</tt> package.
setEnv :: String -> String -> Bool -> IO ()

-- | Like <a>unsetEnv</a>, but allows for the removal of blank environment
--   variables. May throw an exception if the underlying platform doesn't
--   support unsetting of environment variables.
unsetEnv :: String -> IO ()


-- | This library provides facilities for parsing the command-line options
--   in a standalone program. It is essentially a Haskell port of the GNU
--   <tt>getopt</tt> library.
module System.Console.GetOpt

-- | Process the command-line, and return the list of values that matched
--   (and those that didn't). The arguments are:
--   
--   <ul>
--   <li>The order requirements (see <a>ArgOrder</a>)</li>
--   <li>The option descriptions (see <a>OptDescr</a>)</li>
--   <li>The actual command line arguments (presumably got from
--   <a>getArgs</a>).</li>
--   </ul>
--   
--   <a>getOpt</a> returns a triple consisting of the option arguments, a
--   list of non-options, and a list of error messages.
getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])

-- | This is almost the same as <a>getOpt</a>, but returns a quadruple
--   consisting of the option arguments, a list of non-options, a list of
--   unrecognized options, and a list of error messages.
getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])

-- | Return a string describing the usage of a command, derived from the
--   header (first argument) and the options described by the second
--   argument.
usageInfo :: String -> [OptDescr a] -> String

-- | What to do with options following non-options
data ArgOrder a

-- | no option processing after first non-option
RequireOrder :: ArgOrder a

-- | freely intersperse options and non-options
Permute :: ArgOrder a

-- | wrap non-options into options
ReturnInOrder :: (String -> a) -> ArgOrder a

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a

-- | no argument expected
NoArg :: a -> ArgDescr a

-- | option requires argument
ReqArg :: (String -> a) -> String -> ArgDescr a

-- | optional argument
OptArg :: (Maybe String -> a) -> String -> ArgDescr a
instance GHC.Base.Functor System.Console.GetOpt.OptDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgDescr
instance GHC.Base.Functor System.Console.GetOpt.ArgOrder


-- | The standard CPUTime library.
module System.CPUTime

-- | Computation <a>getCPUTime</a> returns the number of picoseconds CPU
--   time used by the current program. The precision of this result is
--   implementation-dependent.
getCPUTime :: IO Integer

-- | The <a>cpuTimePrecision</a> constant is the smallest measurable
--   difference in CPU time that the implementation can record, and is
--   given as an integral number of picoseconds.
cpuTimePrecision :: Integer


-- | Symbolic references to values.
--   
--   References to values are usually implemented with memory addresses,
--   and this is practical when communicating values between the different
--   pieces of a single process.
--   
--   When values are communicated across different processes running in
--   possibly different machines, though, addresses are no longer useful
--   since each process may use different addresses to store a given value.
--   
--   To solve such concern, the references provided by this module offer a
--   key that can be used to locate the values on each process. Each
--   process maintains a global table of references which can be looked up
--   with a given key. This table is known as the Static Pointer Table. The
--   reference can then be dereferenced to obtain the value.
--   
--   The various communicating processes need to agree on the keys used to
--   refer to the values in the Static Pointer Table, or lookups will fail.
--   Only processes launched from the same program binary are guaranteed to
--   use the same set of keys.
module GHC.StaticPtr

-- | A reference to a value of type <tt>a</tt>.
data StaticPtr a

-- | Dereferences a static pointer.
deRefStaticPtr :: StaticPtr a -> a

-- | A key for <a>StaticPtr</a>s that can be serialized and used with
--   <a>unsafeLookupStaticPtr</a>.
type StaticKey = Fingerprint

-- | The <a>StaticKey</a> that can be used to look up the given
--   <a>StaticPtr</a>.
staticKey :: StaticPtr a -> StaticKey

-- | Looks up a <a>StaticPtr</a> by its <a>StaticKey</a>.
--   
--   If the <a>StaticPtr</a> is not found returns <tt>Nothing</tt>.
--   
--   This function is unsafe because the program behavior is undefined if
--   the type of the returned <a>StaticPtr</a> does not match the expected
--   one.
unsafeLookupStaticPtr :: StaticKey -> IO (Maybe (StaticPtr a))

-- | Miscellaneous information available for debugging purposes.
data StaticPtrInfo
StaticPtrInfo :: String -> String -> (Int, Int) -> StaticPtrInfo

-- | Package key of the package where the static pointer is defined
[spInfoUnitId] :: StaticPtrInfo -> String

-- | Name of the module where the static pointer is defined
[spInfoModuleName] :: StaticPtrInfo -> String

-- | Source location of the definition of the static pointer as a
--   <tt>(Line, Column)</tt> pair.
[spInfoSrcLoc] :: StaticPtrInfo -> (Int, Int)

-- | <a>StaticPtrInfo</a> of the given <a>StaticPtr</a>.
staticPtrInfo :: StaticPtr a -> StaticPtrInfo

-- | A list of all known keys.
staticPtrKeys :: IO [StaticKey]

-- | A class for things buildable from static pointers.
--   
--   GHC wraps each use of the <tt>static</tt> keyword with
--   <a>fromStaticPtr</a>. Because the <tt>static</tt> keyword requires its
--   argument to be an instance of <a>Typeable</a>, <a>fromStaticPtr</a>
--   carries a <a>Typeable</a> constraint as well.
class IsStatic p
fromStaticPtr :: (IsStatic p, Typeable a) => StaticPtr a -> p a
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo
instance GHC.StaticPtr.IsStatic GHC.StaticPtr.StaticPtr


-- | Stable names are a way of performing fast ( &lt;math&gt; ),
--   not-quite-exact comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module GHC.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a
StableName :: StableName# a -> StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool
instance GHC.Classes.Eq (GHC.StableName.StableName a)


-- | Stable names are a way of performing fast ( &lt;math&gt; ),
--   not-quite-exact comparison between objects.
--   
--   Stable names solve the following problem: suppose you want to build a
--   hash table with Haskell objects as keys, but you want to use pointer
--   equality for comparison; maybe because the keys are large and hashing
--   would be slow, or perhaps because the keys are infinite in size. We
--   can't build a hash table using the address of the object as the key,
--   because objects get moved around by the garbage collector, meaning a
--   re-hash would be necessary after every garbage collection.
module System.Mem.StableName

-- | An abstract name for an object, that supports equality and hashing.
--   
--   Stable names have the following property:
--   
--   <ul>
--   <li>If <tt>sn1 :: StableName</tt> and <tt>sn2 :: StableName</tt> and
--   <tt>sn1 == sn2</tt> then <tt>sn1</tt> and <tt>sn2</tt> were created by
--   calls to <tt>makeStableName</tt> on the same object.</li>
--   </ul>
--   
--   The reverse is not necessarily true: if two stable names are not
--   equal, then the objects they name may still be equal. Note in
--   particular that <a>makeStableName</a> may return a different
--   <a>StableName</a> after an object is evaluated.
--   
--   Stable Names are similar to Stable Pointers
--   (<a>Foreign.StablePtr</a>), but differ in the following ways:
--   
--   <ul>
--   <li>There is no <tt>freeStableName</tt> operation, unlike
--   <a>Foreign.StablePtr</a>s. Stable names are reclaimed by the runtime
--   system when they are no longer needed.</li>
--   <li>There is no <tt>deRefStableName</tt> operation. You can't get back
--   from a stable name to the original Haskell object. The reason for this
--   is that the existence of a stable name for an object does not
--   guarantee the existence of the object itself; it can still be garbage
--   collected.</li>
--   </ul>
data StableName a

-- | Makes a <a>StableName</a> for an arbitrary object. The object passed
--   as the first argument is not evaluated by <a>makeStableName</a>.
makeStableName :: a -> IO (StableName a)

-- | Convert a <a>StableName</a> to an <a>Int</a>. The <a>Int</a> returned
--   is not necessarily unique; several <a>StableName</a>s may map to the
--   same <a>Int</a> (in practice however, the chances of this are small,
--   so the result of <a>hashStableName</a> makes a good hash key).
hashStableName :: StableName a -> Int

-- | Equality on <a>StableName</a> that does not require that the types of
--   the arguments match.
eqStableName :: StableName a -> StableName b -> Bool


-- | GCC style response files.
module GHC.ResponseFile

-- | Like <a>getArgs</a>, but can also read arguments supplied via response
--   files.
--   
--   For example, consider a program <tt>foo</tt>:
--   
--   <pre>
--   main :: IO ()
--   main = do
--     args &lt;- getArgsWithResponseFiles
--     putStrLn (show args)
--   </pre>
--   
--   And a response file <tt>args.txt</tt>:
--   
--   <pre>
--   --one 1
--   --'two' 2
--   --"three" 3
--   </pre>
--   
--   Then the result of invoking <tt>foo</tt> with <tt>args.txt</tt> is:
--   
--   <pre>
--   &gt; ./foo @args.txt
--   ["--one","1","--two","2","--three","3"]
--   </pre>
getArgsWithResponseFiles :: IO [String]

-- | Given a string of concatenated strings, separate each by removing a
--   layer of <i>quoting</i> and/or <i>escaping</i> of certain characters.
--   
--   These characters are: any whitespace, single quote, double quote, and
--   the backslash character. The backslash character always escapes (i.e.,
--   passes through without further consideration) the character which
--   follows. Characters can also be escaped in blocks by quoting (i.e.,
--   surrounding the blocks with matching pairs of either single- or
--   double-quotes which are not themselves escaped).
--   
--   Any whitespace which appears outside of either of the quoting and
--   escaping mechanisms, is interpreted as having been added by this
--   special concatenation process to designate where the boundaries are
--   between the original, un-concatenated list of strings. These added
--   whitespace characters are removed from the output.
--   
--   <pre>
--   unescapeArgs "hello\\ \\\"world\\\"\n" == ["hello \"world\""]
--   </pre>
unescapeArgs :: String -> [String]

-- | Given a list of strings, concatenate them into a single string with
--   escaping of certain characters, and the addition of a newline between
--   each string. The escaping is done by adding a single backslash
--   character before any whitespace, single quote, double quote, or
--   backslash character, so this escaping character must be removed.
--   Unescaped whitespace (in this case, newline) is part of this
--   "transport" format to indicate the end of the previous string and the
--   start of a new string.
--   
--   While <a>unescapeArgs</a> allows using quoting (i.e., convenient
--   escaping of many characters) by having matching sets of single- or
--   double-quotes,<a>escapeArgs</a> does not use the quoting mechanism,
--   and thus will always escape any whitespace, quotes, and backslashes.
--   
--   <pre>
--   escapeArgs ["hello \"world\""] == "hello\\ \\\"world\\\"\n"
--   </pre>
escapeArgs :: [String] -> String

-- | Arguments which look like <tt>@foo</tt> will be replaced with the
--   contents of file <tt>foo</tt>. A gcc-like syntax for response files
--   arguments is expected. This must re-constitute the argument list by
--   doing an inverse of the escaping mechanism done by the calling-program
--   side.
--   
--   We quit if the file is not found or reading somehow fails. (A
--   convenience routine for haddock or possibly other clients)
expandResponse :: [String] -> IO [String]


-- | This module defines the <a>HasField</a> class used by the
--   <tt>OverloadedRecordFields</tt> extension. See the
--   &lt;<a>https://gitlab.haskell.org/ghc/ghc/wikis/records/overloaded-record-fields</a>
--   wiki page&gt; for more details.
module GHC.Records

-- | Constraint representing the fact that the field <tt>x</tt> belongs to
--   the record type <tt>r</tt> and has field type <tt>a</tt>. This will be
--   solved automatically, but manual instances may be provided as well.
class HasField x r a | x r -> a

-- | Selector function to extract the field from the record.
getField :: HasField x r a => r -> a


-- | This module defines the <a>IsLabel</a> class used by the
--   <tt>OverloadedLabels</tt> extension. See the <a>wiki page</a> for more
--   details.
--   
--   When <tt>OverloadedLabels</tt> is enabled, if GHC sees an occurrence
--   of the overloaded label syntax <tt>#foo</tt>, it is replaced with
--   
--   <pre>
--   fromLabel @"foo" :: alpha
--   </pre>
--   
--   plus a wanted constraint <tt>IsLabel "foo" alpha</tt>.
--   
--   Note that if <tt>RebindableSyntax</tt> is enabled, the desugaring of
--   overloaded label syntax will make use of whatever <tt>fromLabel</tt>
--   is in scope.
module GHC.OverloadedLabels
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a


-- | Various helpers used by the GHCi shell.
module GHC.GHCi.Helpers
disableBuffering :: IO ()
flushAll :: IO ()
evalWrapper :: String -> [String] -> IO a -> IO a


-- | Target byte ordering.
module GHC.ByteOrder

-- | Byte ordering.
data ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | The byte ordering of the target machine.
targetByteOrder :: ByteOrder
instance GHC.Generics.Generic GHC.ByteOrder.ByteOrder
instance GHC.Show.Show GHC.ByteOrder.ByteOrder
instance GHC.Read.Read GHC.ByteOrder.ByteOrder
instance GHC.Enum.Enum GHC.ByteOrder.ByteOrder
instance GHC.Enum.Bounded GHC.ByteOrder.ByteOrder
instance GHC.Classes.Ord GHC.ByteOrder.ByteOrder
instance GHC.Classes.Eq GHC.ByteOrder.ByteOrder


-- | A logically uninhabited data type, used to indicate that a given term
--   should not exist.
module Data.Void

-- | Uninhabited data type
data Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values. It is implemented in
--   terms of <tt>fmap absurd</tt>.
vacuous :: Functor f => f Void -> f a


-- | An abstract interface to a unique symbol generator.
module Data.Unique

-- | An abstract unique object. Objects of type <a>Unique</a> may be
--   compared for equality and ordering and hashed into <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do x &lt;- newUnique
--      print (x == x)
--      y &lt;- newUnique
--      print (x == y)
--   :}
--   True
--   False
--   </pre>
data Unique

-- | Creates a new object of type <a>Unique</a>. The value returned will
--   not compare equal to any other value of type <a>Unique</a> returned by
--   previous calls to <a>newUnique</a>. There is no limit on the number of
--   times <a>newUnique</a> may be called.
newUnique :: IO Unique

-- | Hashes a <a>Unique</a> into an <a>Int</a>. Two <a>Unique</a>s may hash
--   to the same value, although in practice this is unlikely. The
--   <a>Int</a> returned makes a good hash key.
hashUnique :: Unique -> Int
instance GHC.Classes.Ord Data.Unique.Unique
instance GHC.Classes.Eq Data.Unique.Unique


-- | Mutable references in the (strict) ST monad.
module Data.STRef

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a

-- | Build a new <a>STRef</a> in the current state thread
newSTRef :: a -> ST s (STRef s a)

-- | Read the value of an <a>STRef</a>
readSTRef :: STRef s a -> ST s a

-- | Write a new value into an <a>STRef</a>
writeSTRef :: STRef s a -> a -> ST s ()

-- | Mutate the contents of an <a>STRef</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef ""
--       modifySTRef ref (const "world")
--       modifySTRef ref (++ "!")
--       modifySTRef ref ("Hello, " ++)
--       readSTRef ref )
--   :}
--   "Hello, world!"
--   </pre>
--   
--   Be warned that <a>modifySTRef</a> does not apply the function
--   strictly. This means if the program calls <a>modifySTRef</a> many
--   times, but seldom uses the value, thunks will pile up in memory
--   resulting in a space leak. This is a common mistake made when using an
--   <a>STRef</a> as a counter. For example, the following will leak memory
--   and may produce a stack overflow:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (replicateM_)
--   
--   &gt;&gt;&gt; :{
--   print (runST (do
--       ref &lt;- newSTRef 0
--       replicateM_ 1000 $ modifySTRef ref (+1)
--       readSTRef ref ))
--   :}
--   1000
--   </pre>
--   
--   To avoid this problem, use <a>modifySTRef'</a> instead.
modifySTRef :: STRef s a -> (a -> a) -> ST s ()

-- | Strict version of <a>modifySTRef</a>
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()


-- | Mutable references in the (strict) ST monad (re-export of
--   <a>Data.STRef</a>)
module Data.STRef.Strict


-- | Standard functions on rational numbers
module Data.Ratio

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | Forms the ratio of two integral numbers.
(%) :: Integral a => a -> a -> Ratio a
infixl 7 %

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | <a>approxRational</a>, applied to two real fractional numbers
--   <tt>x</tt> and <tt>epsilon</tt>, returns the simplest rational number
--   within <tt>epsilon</tt> of <tt>x</tt>. A rational number <tt>y</tt> is
--   said to be <i>simpler</i> than another <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> (<a>numerator</a> y) &lt;= <a>abs</a>
--   (<a>numerator</a> y')</tt>, and</li>
--   <li><tt><a>denominator</a> y &lt;= <a>denominator</a> y'</tt>.</li>
--   </ul>
--   
--   Any real interval contains a unique simplest rational; in particular,
--   note that <tt>0/1</tt> is the simplest rational of all.
approxRational :: RealFrac a => a -> a -> Rational


-- | Basic kinds
module Data.Kind

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN


-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   type onto integers. It is used primarily for array indexing (see the
--   array package). <a>Ix</a> uses row-major order.
module Data.Ix

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <tt>elem</tt> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <tt>!!</tt> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <tt>length</tt> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class (Ord a) => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Unsafe API.
module Control.Monad.ST.Unsafe

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | <a>unsafeDupableInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
--   
--   The computation may be performed multiple times by different threads,
--   possibly at the same time. To prevent this, use
--   <a>unsafeInterleaveST</a> instead.
unsafeDupableInterleaveST :: ST s a -> ST s a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   Safe API Only.

-- | <i>Deprecated: Safe is now the default, please use Control.Monad.ST
--   instead</i>
module Control.Monad.ST.Safe

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This library provides support for <i>strict</i> state threads, as
--   described in the PLDI '94 paper by John Launchbury and Simon Peyton
--   Jones <i>Lazy Functional State Threads</i>.
--   
--   References (variables) that can be used within the <tt>ST</tt> monad
--   are provided by <a>Data.STRef</a>, and arrays are provided by
--   <a>Data.Array.ST</a>.
module Control.Monad.ST

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation.
--   
--   Note that if <tt>f</tt> is strict, <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Embed a strict state thread in an <a>IO</a> action. The
--   <a>RealWorld</a> parameter indicates that the internal state used by
--   the <a>ST</a> computation is a special one supplied by the <a>IO</a>
--   monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | The strict ST monad (re-export of <a>Control.Monad.ST</a>)
module Control.Monad.ST.Strict


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   <a>ST</a> operations until a value depending on them is required.
--   
--   Unsafe API.
module Control.Monad.ST.Lazy.Unsafe
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   <a>ST</a> operations until a value depending on them is required.
--   
--   Safe API only.

-- | <i>Deprecated: Safe is now the default, please use
--   Control.Monad.ST.Lazy instead</i>
module Control.Monad.ST.Lazy.Safe

-- | The lazy <tt><a>ST</a></tt> monad. The ST monad allows for destructive
--   updates, but is escapable (unlike <tt>IO</tt>). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and
--   executes in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by an <a>ST</a> computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | A monad transformer embedding lazy <a>ST</a> in the <a>IO</a> monad.
--   The <a>RealWorld</a> parameter indicates that the internal state used
--   by the <a>ST</a> computation is a special one supplied by the
--   <a>IO</a> monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | This module presents an identical interface to
--   <a>Control.Monad.ST</a>, except that the monad delays evaluation of
--   state operations until a value depending on them is required.
module Control.Monad.ST.Lazy

-- | The lazy <tt><a>ST</a></tt> monad. The ST monad allows for destructive
--   updates, but is escapable (unlike <tt>IO</tt>). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and
--   executes in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are not strict in
--   the state. For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2
--   </pre>
data ST s a

-- | Return the value computed by an <a>ST</a> computation. The
--   <tt>forall</tt> ensures that the internal state used by the <a>ST</a>
--   computation is inaccessible to the rest of the program.
runST :: (forall s. ST s a) -> a

-- | Allow the result of an <a>ST</a> computation to be used (lazily)
--   inside the computation. Note that if <tt>f</tt> is strict,
--   <tt><a>fixST</a> f = _|_</tt>.
fixST :: (a -> ST s a) -> ST s a

-- | Convert a strict <a>ST</a> computation into a lazy one. The strict
--   state thread passed to <a>strictToLazyST</a> is not performed until
--   the result of the lazy state thread it returns is demanded.
strictToLazyST :: ST s a -> ST s a

-- | Convert a lazy <a>ST</a> computation into a strict one.
lazyToStrictST :: ST s a -> ST s a

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | A monad transformer embedding lazy <a>ST</a> in the <a>IO</a> monad.
--   The <a>RealWorld</a> parameter indicates that the internal state used
--   by the <a>ST</a> computation is a special one supplied by the
--   <a>IO</a> monad, and thus distinct from those used by invocations of
--   <a>runST</a>.
stToIO :: ST RealWorld a -> IO a


-- | Mutable references in the lazy ST monad.
module Data.STRef.Lazy

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runST (do
--       ref &lt;- newSTRef "hello"
--       x &lt;- readSTRef ref
--       writeSTRef ref (x ++ "world")
--       readSTRef ref )
--   :}
--   "helloworld"
--   </pre>
data STRef s a
newSTRef :: a -> ST s (STRef s a)
readSTRef :: STRef s a -> ST s a
writeSTRef :: STRef s a -> a -> ST s ()
modifySTRef :: STRef s a -> (a -> a) -> ST s ()


-- | <i>This module is DEPRECATED and will be removed in the future!</i>
--   
--   <a>Functor</a> and <a>Monad</a> instances for <tt>(-&gt;) r</tt> and
--   <a>Functor</a> instances for <tt>(,) a</tt> and <tt><a>Either</a>
--   a</tt>.

-- | <i>Deprecated: This module now contains no instances and will be
--   removed in the future</i>
module Control.Monad.Instances

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>


-- | Class of monads based on <tt>IO</tt>.
module Control.Monad.IO.Class

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class (Monad m) => MonadIO m

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
instance Control.Monad.IO.Class.MonadIO GHC.Types.IO


-- | This module provides access to internal garbage collection and memory
--   usage statistics. These statistics are not available unless a program
--   is run with the <tt>-T</tt> RTS flag.
--   
--   This module is GHC-only and should not be considered portable.
module GHC.Stats

-- | Statistics about runtime activity since the start of the program. This
--   is a mirror of the C <tt>struct RTSStats</tt> in <tt>RtsAPI.h</tt>
data RTSStats
RTSStats :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails -> RTSStats

-- | Total number of GCs
[gcs] :: RTSStats -> Word32

-- | Total number of major (oldest generation) GCs
[major_gcs] :: RTSStats -> Word32

-- | Total bytes allocated
[allocated_bytes] :: RTSStats -> Word64

-- | Maximum live data (including large objects + compact regions) in the
--   heap. Updated after a major GC.
[max_live_bytes] :: RTSStats -> Word64

-- | Maximum live data in large objects
[max_large_objects_bytes] :: RTSStats -> Word64

-- | Maximum live data in compact regions
[max_compact_bytes] :: RTSStats -> Word64

-- | Maximum slop
[max_slop_bytes] :: RTSStats -> Word64

-- | Maximum memory in use by the RTS
[max_mem_in_use_bytes] :: RTSStats -> Word64

-- | Sum of live bytes across all major GCs. Divided by major_gcs gives the
--   average live data over the lifetime of the program.
[cumulative_live_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all GCs
[copied_bytes] :: RTSStats -> Word64

-- | Sum of copied_bytes across all parallel GCs
[par_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_max_copied_bytes across all parallel GCs. Deprecated.
[cumulative_par_max_copied_bytes] :: RTSStats -> Word64

-- | Sum of par_balanced_copied bytes across all parallel GCs
[cumulative_par_balanced_copied_bytes] :: RTSStats -> Word64

-- | Total CPU time used by the init phase @since 4.12.0.0
[init_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the init phase @since 4.12.0.0
[init_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the mutator
[mutator_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the mutator
[mutator_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time used by the GC
[gc_cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time used by the GC
[gc_elapsed_ns] :: RTSStats -> RtsTime

-- | Total CPU time (at the previous GC)
[cpu_ns] :: RTSStats -> RtsTime

-- | Total elapsed time (at the previous GC)
[elapsed_ns] :: RTSStats -> RtsTime

-- | The total CPU time used during the post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_cpu_ns] :: RTSStats -> RtsTime

-- | The total time elapsed during the post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_elapsed_ns] :: RTSStats -> RtsTime

-- | The maximum elapsed length of any post-mark pause phase of the
--   concurrent nonmoving GC.
[nonmoving_gc_sync_max_elapsed_ns] :: RTSStats -> RtsTime

-- | The total CPU time used by the nonmoving GC.
[nonmoving_gc_cpu_ns] :: RTSStats -> RtsTime

-- | The total time elapsed during which there is a nonmoving GC active.
[nonmoving_gc_elapsed_ns] :: RTSStats -> RtsTime

-- | The maximum time elapsed during any nonmoving GC cycle.
[nonmoving_gc_max_elapsed_ns] :: RTSStats -> RtsTime

-- | Details about the most recent GC
[gc] :: RTSStats -> GCDetails

-- | Statistics about a single GC. This is a mirror of the C <tt>struct
--   GCDetails</tt> in <tt>RtsAPI.h</tt>, with the field prefixed with
--   <tt>gc_</tt> to avoid collisions with <a>RTSStats</a>.
data GCDetails
GCDetails :: Word32 -> Word32 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> Word64 -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> RtsTime -> GCDetails

-- | The generation number of this GC
[gcdetails_gen] :: GCDetails -> Word32

-- | Number of threads used in this GC
[gcdetails_threads] :: GCDetails -> Word32

-- | Number of bytes allocated since the previous GC
[gcdetails_allocated_bytes] :: GCDetails -> Word64

-- | Total amount of live data in the heap (includes large + compact data).
--   Updated after every GC. Data in uncollected generations (in minor GCs)
--   are considered live.
[gcdetails_live_bytes] :: GCDetails -> Word64

-- | Total amount of live data in large objects
[gcdetails_large_objects_bytes] :: GCDetails -> Word64

-- | Total amount of live data in compact regions
[gcdetails_compact_bytes] :: GCDetails -> Word64

-- | Total amount of slop (wasted memory)
[gcdetails_slop_bytes] :: GCDetails -> Word64

-- | Total amount of memory in use by the RTS
[gcdetails_mem_in_use_bytes] :: GCDetails -> Word64

-- | Total amount of data copied during this GC
[gcdetails_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the max amount of data copied by any one thread.
--   Deprecated.
[gcdetails_par_max_copied_bytes] :: GCDetails -> Word64

-- | In parallel GC, the amount of balanced data copied by all threads
[gcdetails_par_balanced_copied_bytes] :: GCDetails -> Word64

-- | The amount of memory lost due to block fragmentation in bytes. Block
--   fragmentation is the difference between the amount of blocks retained
--   by the RTS and the blocks that are in use. This occurs when megablocks
--   are only sparsely used, eg, when data that cannot be moved retains a
--   megablock.
[gcdetails_block_fragmentation_bytes] :: GCDetails -> Word64

-- | The time elapsed during synchronisation before GC
[gcdetails_sync_elapsed_ns] :: GCDetails -> RtsTime

-- | The CPU time used during GC itself
[gcdetails_cpu_ns] :: GCDetails -> RtsTime

-- | The time elapsed during GC itself
[gcdetails_elapsed_ns] :: GCDetails -> RtsTime

-- | The CPU time used during the post-mark pause phase of the concurrent
--   nonmoving GC.
[gcdetails_nonmoving_gc_sync_cpu_ns] :: GCDetails -> RtsTime

-- | The time elapsed during the post-mark pause phase of the concurrent
--   nonmoving GC.
[gcdetails_nonmoving_gc_sync_elapsed_ns] :: GCDetails -> RtsTime

-- | Time values from the RTS, using a fixed resolution of nanoseconds.
type RtsTime = Int64

-- | Get current runtime system statistics.
getRTSStats :: IO RTSStats

-- | Returns whether GC stats have been enabled (with <tt>+RTS -T</tt>, for
--   example).
getRTSStatsEnabled :: IO Bool
instance GHC.Generics.Generic GHC.Stats.GCDetails
instance GHC.Show.Show GHC.Stats.GCDetails
instance GHC.Read.Read GHC.Stats.GCDetails
instance GHC.Generics.Generic GHC.Stats.RTSStats
instance GHC.Show.Show GHC.Stats.RTSStats
instance GHC.Read.Read GHC.Stats.RTSStats


-- | Internals of the <a>ExecutionStack</a> module
module GHC.ExecutionStack.Internal

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | The state of the execution stack
data StackTrace

-- | List the frames of a stack trace.
stackFrames :: StackTrace -> Maybe [Location]

-- | How many stack frames in the given <a>StackTrace</a>
stackDepth :: StackTrace -> Int

-- | Get an execution stack.
collectStackTrace :: IO (Maybe StackTrace)

-- | Render a stacktrace as a string
showStackFrames :: [Location] -> ShowS

-- | Free the cached debug data.
invalidateDebugCache :: IO ()


-- | This is a module for efficient stack traces. This stack trace
--   implementation is considered low overhead. Basic usage looks like
--   this:
--   
--   <pre>
--   import GHC.ExecutionStack
--   
--   myFunction :: IO ()
--   myFunction = do
--        putStrLn =&lt;&lt; showStackTrace
--   </pre>
--   
--   Your GHC must have been built with <tt>libdw</tt> support for this to
--   work.
--   
--   <pre>
--   user@host:~$ ghc --info | grep libdw
--    ,("RTS expects libdw",<a>YES</a>)
--   </pre>
module GHC.ExecutionStack

-- | Location information about an address from a backtrace.
data Location
Location :: String -> String -> Maybe SrcLoc -> Location
[objectName] :: Location -> String
[functionName] :: Location -> String
[srcLoc] :: Location -> Maybe SrcLoc

-- | A location in the original program source.
data SrcLoc
SrcLoc :: String -> Int -> Int -> SrcLoc
[sourceFile] :: SrcLoc -> String
[sourceLine] :: SrcLoc -> Int
[sourceColumn] :: SrcLoc -> Int

-- | Get a trace of the current execution stack state.
--   
--   Returns <tt>Nothing</tt> if stack trace support isn't available on
--   host machine.
getStackTrace :: IO (Maybe [Location])

-- | Get a string representation of the current execution stack state.
showStackTrace :: IO (Maybe String)


-- | A <a>NonEmpty</a> list is one which always has at least one element,
--   but is otherwise identical to the traditional list type in complexity
--   and in terms of API. You will almost certainly want to import this
--   module <tt>qualified</tt>.
module Data.List.NonEmpty

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Construct a <a>NonEmpty</a> list from a single element.
singleton :: a -> NonEmpty a

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>, starting with the shortest. The
--   result is <a>NonEmpty</a> because the result always contains the empty
--   list as the first element.
--   
--   <pre>
--   inits [1,2,3] == [] :| [[1], [1,2], [1,2,3]]
--   inits [1] == [] :| [[1]]
--   inits [] == [] :| []
--   </pre>
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>inits1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the <a>NonEmpty</a> finite prefixes of <tt>xs</tt>,
--   starting with the shortest.
--   
--   <pre>
--   inits1 (1 :| [2,3]) == (1 :| []) :| [1 :| [2], 1 :| [2,3]]
--   inits1 (1 :| []) == (1 :| []) :| []
--   </pre>
inits1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>, starting with the longest. The result is
--   <a>NonEmpty</a> because the result always contains the empty list as
--   the last element.
--   
--   <pre>
--   tails [1,2,3] == [1,2,3] :| [[2,3], [3], []]
--   tails [1] == [1] :| [[]]
--   tails [] == [] :| []
--   </pre>
tails :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the non-empty suffixes of <tt>xs</tt>, starting with
--   the longest.
--   
--   <pre>
--   tails1 (1 :| [2,3]) == (1 :| [2,3]) :| [2 :| [3], 3 :| []]
--   tails1 (1 :| []) == (1 :| []) :| []
--   </pre>
tails1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | A monomorphic version of <a>&lt;&gt;</a> for <a>NonEmpty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; append (1 :| []) (2 :| [3])
--   1 :| [2,3]
--   </pre>
append :: NonEmpty a -> NonEmpty a -> NonEmpty a

-- | Attach a list at the end of a <a>NonEmpty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; appendList (1 :| [2,3]) []
--   1 :| [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appendList (1 :| [2,3]) [4,5]
--   1 :| [2,3,4,5]
--   </pre>
appendList :: NonEmpty a -> [a] -> NonEmpty a

-- | Attach a list at the beginning of a <a>NonEmpty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; prependList [] (1 :| [2,3])
--   1 :| [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prependList [negate 1, 0] (1 :| [2, 3])
--   -1 :| [0,1,2,3]
--   </pre>
prependList :: [a] -> NonEmpty a -> NonEmpty a

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.

-- | <i>Deprecated: Use unfoldr</i>
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>isPrefixOf</a> function returns <a>True</a> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: HasCallStack => NonEmpty a -> Int -> a
infixl 9 !!

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: HasCallStack => [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | Monadic zipping (used for monad comprehensions)
module Control.Monad.Zip

-- | Instances should satisfy the laws:
--   
--   <ul>
--   <li><i>Naturality</i> <pre><a>liftM</a> (f <a>***</a> g) (<a>mzip</a>
--   ma mb) = <a>mzip</a> (<a>liftM</a> f ma) (<a>liftM</a> g
--   mb)</pre></li>
--   <li><i>Information Preservation</i> <tt><a>liftM</a> (<a>const</a> ())
--   ma = <a>liftM</a> (<a>const</a> ()) mb</tt> implies <tt><a>munzip</a>
--   (<a>mzip</a> ma mb) = (ma, mb)</tt></li>
--   </ul>
class Monad m => MonadZip m
mzip :: MonadZip m => m a -> m b -> m (a, b)
mzipWith :: MonadZip m => (a -> b -> c) -> m a -> m b -> m c
munzip :: MonadZip m => m (a, b) -> (m a, m b)
instance Control.Monad.Zip.MonadZip []
instance Control.Monad.Zip.MonadZip GHC.Base.NonEmpty
instance Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity
instance Control.Monad.Zip.MonadZip Solo
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Dual
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Sum
instance Control.Monad.Zip.MonadZip Data.Semigroup.Internal.Product
instance Control.Monad.Zip.MonadZip GHC.Maybe.Maybe
instance Control.Monad.Zip.MonadZip Data.Monoid.First
instance Control.Monad.Zip.MonadZip Data.Monoid.Last
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (Data.Semigroup.Internal.Alt f)
instance Control.Monad.Zip.MonadZip Data.Proxy.Proxy
instance Control.Monad.Zip.MonadZip GHC.Generics.U1
instance Control.Monad.Zip.MonadZip GHC.Generics.Par1
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.Rec1 f)
instance Control.Monad.Zip.MonadZip f => Control.Monad.Zip.MonadZip (GHC.Generics.M1 i c f)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (f GHC.Generics.:*: g)
instance Control.Monad.Zip.MonadZip Data.Ord.Down


module Data.Bifunctor

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class (forall a. Functor (p a)) => Bifunctor p

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Data.Bifunctor.Bifunctor (,)
instance Data.Bifunctor.Bifunctor ((,,) x1)
instance Data.Bifunctor.Bifunctor ((,,,) x1 x2)
instance Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Data.Bifunctor.Bifunctor Data.Either.Either
instance Data.Bifunctor.Bifunctor Data.Functor.Const.Const
instance Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)


module Data.Bifoldable

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and
--   <tt>(,)</tt>:
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   Some examples below also use the following BiList to showcase empty
--   Bifoldable behaviors when relevant (<a>Either</a> and <tt>(,)</tt>
--   containing always exactly resp. 1 and 2 elements):
--   
--   <pre>
--   data BiList a b = BiList [a] [b]
--   
--   instance Bifoldable BiList where
--     bifoldr f g z (BiList as bs) = foldr f (foldr g z bs) as
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <a>Bifunctor</a> instance, it should satisfy:
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifold</a> . <a>bimap</a> f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   <a>bifoldMap</a> f g . <a>bimap</a> h i ≡ <a>bifoldMap</a> (f . h) (g . i)
--   </pre>
class Bifoldable p

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Right [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Left [5, 6])
--   [5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold ([1, 2, 3], [4, 5])
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Product 6, Product 7)
--   Product {getProduct = 42}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifold (Sum 6, Sum 7)
--   Sum {getSum = 13}
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) ([1..], "89")
--   [1,2,3,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) (Left [1..])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldMap (take 3) (fmap digitToInt) (Right "89")
--   [8,9]
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt; bifoldr (+) (*) 3 (5, 7)
--   26 -- 5 + (7 * 3)
--   
--   &gt; bifoldr (+) (*) 3 (7, 5)
--   22 -- 7 + (5 * 3)
--   
--   &gt; bifoldr (+) (*) 3 (Right 5)
--   15 -- 5 * 3
--   
--   &gt; bifoldr (+) (*) 3 (Left 5)
--   8 -- 5 + 3
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elements of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z
--        ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z . toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt; bifoldl (+) (*) 3 (5, 7)
--   56 -- (5 + 3) * 7
--   
--   &gt; bifoldl (+) (*) 3 (7, 5)
--   50 -- (7 + 3) * 5
--   
--   &gt; bifoldl (+) (*) 3 (Right 5)
--   15 -- 5 * 3
--   
--   &gt; bifoldl (+) (*) 3 (Left 5)
--   8 -- 5 + 3
--   </pre>
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | A variant of <a>bifoldr</a> that has no base case, and thus may only
--   be applied to non-empty structures.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (5, 7)
--   12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (Right 7)
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (Left 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt; bifoldr1 (+) (BiList [1, 2] [3, 4])
--   10 -- 1 + (2 + (3 + 4))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (BiList [1, 2] [])
--   3
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldr1 (+) (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
bifoldr1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | A variant of <a>bifoldl</a> that has no base case, and thus may only
--   be applied to non-empty structures.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (5, 7)
--   12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (Right 7)
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (Left 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt; bifoldl1 (+) (BiList [1, 2] [3, 4])
--   10 -- ((1 + 2) + 3) + 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (BiList [1, 2] [])
--   3
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldl1 (+) (BiList [] [])
--   *** Exception: bifoldl1: empty structure
--   ...
--   </pre>
bifoldl1 :: Bifoldable t => (a -> a -> a) -> t a a -> a

-- | Left associative monadic bifold over a structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 ("Hello", True)
--   "Hello"
--   "True"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Right True)
--   "True"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifoldlM (\a b -&gt; print b &gt;&gt; pure a) (\a c -&gt; print (show c) &gt;&gt; pure a) 42 (Left "Hello")
--   "Hello"
--   42
--   </pre>
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) ("Hello", True)
--   "Hello"
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) (Right True)
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse_ print (print . show) (Left "Hello")
--   "Hello"
--   </pre>
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ ("Hello", True) print (print . show)
--   "Hello"
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ (Right True) print (print . show)
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor_ (Left "Hello") print (print . show)
--   "Hello"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Alias for <a>bitraverse_</a>.
bimapM_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | Alias for <a>bifor_</a>.
biforM_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Alias for <a>biasum</a>.
bimsum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Alias for <a>bisequence_</a>.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (print "Hello", print "World")
--   "Hello"
--   "World"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (Left (print "Hello"))
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence_ (Right (print "World"))
--   "World"
--   </pre>
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Nothing, Nothing)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Nothing, Just 42)
--   Just 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Just 18, Nothing)
--   Just 18
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biasum (Just 18, Just 42)
--   Just 18
--   </pre>
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Collects the list of elements of a structure, from left to right.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biList (18, 42)
--   [18,42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biList (Left 18)
--   [18]
--   </pre>
biList :: Bifoldable t => t a a -> [a]

-- | Test whether the structure is empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; binull (18, 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binull (Right 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binull (BiList [] [])
--   True
--   </pre>
binull :: Bifoldable t => t a b -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bilength (True, 42)
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (Right 42)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (BiList [1,2,3] [4,5])
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bilength (BiList [] [])
--   0
--   </pre>
--   
--   On infinite structures, this function hangs:
--   
--   <pre>
--   &gt; bilength (BiList [1..] [])
--   * Hangs forever *
--   </pre>
bilength :: Bifoldable t => t a b -> Int

-- | Does the element occur in the structure?
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (17, 42)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (17, 43)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (Left 42)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (Right 13)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (BiList [1..5] [1..100])
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bielem 42 (BiList [1..5] [1..41])
--   False
--   </pre>
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The largest element of a non-empty structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (42, 17)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [13, 29, 4] [18, 1, 7])
--   29
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [13, 29, 4] [])
--   29
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximum (BiList [] [])
--   *** Exception: bimaximum: empty structure
--   ...
--   </pre>
bimaximum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The least element of a non-empty structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (42, 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [13, 29, 4] [18, 1, 7])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [13, 29, 4] [])
--   4
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; biminimum (BiList [] [])
--   *** Exception: biminimum: empty structure
--   ...
--   </pre>
biminimum :: forall t a. (Bifoldable t, Ord a) => t a a -> a

-- | The <a>bisum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisum (42, 17)
--   59
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [13, 29, 4] [18, 1, 7])
--   72
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [13, 29, 4] [])
--   46
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisum (BiList [] [])
--   0
--   </pre>
bisum :: (Bifoldable t, Num a) => t a a -> a

-- | The <a>biproduct</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (42, 17)
--   714
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (Right 42)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [13, 29, 4] [18, 1, 7])
--   190008
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [13, 29, 4] [])
--   1508
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biproduct (BiList [] [])
--   1
--   </pre>
biproduct :: (Bifoldable t, Num a) => t a a -> a

-- | Reduces a structure of lists to the concatenation of those lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biconcat ([1, 2, 3], [4, 5])
--   [1,2,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcat (Left [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcat (BiList [[1, 2, 3, 4, 5], [6, 7, 8]] [[9]])
--   [1,2,3,4,5,6,7,8,9]
--   </pre>
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) ([1..], "89")
--   [1,2,3,8,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) (Left [1..])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biconcatMap (take 3) (fmap digitToInt) (Right "89")
--   [8,9]
--   </pre>
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biand (True, False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biand (True, True)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biand (Left True)
--   True
--   </pre>
--   
--   Empty structures yield <a>True</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biand (BiList [] [])
--   True
--   </pre>
--   
--   A <a>False</a> value finitely far from the left end yields
--   <a>False</a> (short circuit):
--   
--   <pre>
--   &gt;&gt;&gt; biand (BiList [True, True, False, True] (repeat True))
--   False
--   </pre>
--   
--   A <a>False</a> value infinitely far from the left end hangs:
--   
--   <pre>
--   &gt; biand (BiList (repeat True) [False])
--   * Hangs forever *
--   </pre>
--   
--   An infinitely <a>True</a> value hangs:
--   
--   <pre>
--   &gt; biand (BiList (repeat True) [])
--   * Hangs forever *
--   </pre>
biand :: Bifoldable t => t Bool Bool -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bior (True, False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bior (False, False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bior (Left True)
--   True
--   </pre>
--   
--   Empty structures yield <a>False</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bior (BiList [] [])
--   False
--   </pre>
--   
--   A <a>True</a> value finitely far from the left end yields <a>True</a>
--   (short circuit):
--   
--   <pre>
--   &gt;&gt;&gt; bior (BiList [False, False, True, False] (repeat False))
--   True
--   </pre>
--   
--   A <a>True</a> value infinitely far from the left end hangs:
--   
--   <pre>
--   &gt; bior (BiList (repeat False) [True])
--   * Hangs forever *
--   </pre>
--   
--   An infinitely <a>False</a> value hangs:
--   
--   <pre>
--   &gt; bior (BiList (repeat False) [])
--   * Hangs forever *
--   </pre>
bior :: Bifoldable t => t Bool Bool -> Bool

-- | Determines whether any element of the structure satisfies its
--   appropriate predicate argument. Empty structures yield <a>False</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (27, 't')
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (27, '8')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (26, 't')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (Left 27)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (Left 26)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (BiList [27, 53] ['t', '8'])
--   True
--   </pre>
--   
--   Empty structures yield <a>False</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biany even isDigit (BiList [] [])
--   False
--   </pre>
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy their
--   appropriate predicate argument. Empty structures yield <a>True</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (27, 't')
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (26, '8')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (Left 27)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (Left 26)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (BiList [26, 52] ['3', '8'])
--   True
--   </pre>
--   
--   Empty structures yield <a>True</a>:
--   
--   <pre>
--   &gt;&gt;&gt; biall even isDigit (BiList [] [])
--   True
--   </pre>
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (42, 17)
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (Left 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (BiList [42, 17, 23] [-5, 18])
--   42
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; bimaximumBy compare (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
bimaximumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (42, 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (Left 17)
--   17
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (BiList [42, 17, 23] [-5, 18])
--   -5
--   </pre>
--   
--   On empty structures, this function throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; biminimumBy compare (BiList [] [])
--   *** Exception: bifoldr1: empty structure
--   ...
--   </pre>
biminimumBy :: Bifoldable t => (a -> a -> Ordering) -> t a a -> a

-- | <a>binotElem</a> is the negation of <a>bielem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (17, 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (17, 43)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (Left 42)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (Right 13)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (BiList [1..5] [1..100])
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; binotElem 42 (BiList [1..5] [1..41])
--   True
--   </pre>
binotElem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (27, 53)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (27, 52)
--   Just 52
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (26, 52)
--   Just 26
--   </pre>
--   
--   Empty structures always yield <a>Nothing</a>:
--   
--   <pre>
--   &gt;&gt;&gt; bifind even (BiList [] [])
--   Nothing
--   </pre>
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a
instance Data.Bifoldable.Bifoldable (,)
instance Data.Bifoldable.Bifoldable Data.Functor.Const.Const
instance Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
instance Data.Bifoldable.Bifoldable ((,,) x)
instance Data.Bifoldable.Bifoldable ((,,,) x y)
instance Data.Bifoldable.Bifoldable ((,,,,) x y z)
instance Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
instance Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
instance Data.Bifoldable.Bifoldable Data.Either.Either


module Data.Bitraversable

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>bitraverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t .
--   <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>Compose</a> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡
--   <a>bitraverse</a> (<a>Compose</a> . <a>fmap</a> g1 . f1)
--   (<a>Compose</a> . <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   Some simple examples are <a>Either</a> and <tt>(,)</tt>:
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable t

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the results produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Left [])
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Left [1, 2, 3])
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) (Right [4, 5])
--   Just (Right 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) ([1, 2, 3], [4, 5])
--   Just (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bitraverse listToMaybe (find odd) ([], [4, 5])
--   Nothing
--   </pre>
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | Alias for <a>bisequence</a>.
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bisequence (Just 4, Nothing)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence (Just 4, Just 5)
--   Just (4,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisequence ([1, 2, 3], [4, 5])
--   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
--   </pre>
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | Alias for <a>bitraverse</a>.
bimapM :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Left []) listToMaybe (find even)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Left [1, 2, 3]) listToMaybe (find even)
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor (Right [4, 5]) listToMaybe (find even)
--   Just (Right 4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor ([1, 2, 3], [4, 5]) listToMaybe (find even)
--   Just (1,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bifor ([], [4, 5]) listToMaybe (find even)
--   Nothing
--   </pre>
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | Alias for <a>bifor</a>.
biforM :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | The <a>bimapAccumL</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldl</a>; it traverses a structure from left to
--   right, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimapAccumL (\acc bool -&gt; (acc + 1, show bool)) (\acc string -&gt; (acc * 2, reverse string)) 3 (True, "foo")
--   (8,("True","oof"))
--   </pre>
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | The <a>bimapAccumR</a> function behaves like a combination of
--   <a>bimap</a> and <a>bifoldr</a>; it traverses a structure from right
--   to left, threading a state of type <tt>a</tt> and using the given
--   actions to compute new elements for the structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bimapAccumR (\acc bool -&gt; (acc + 1, show bool)) (\acc string -&gt; (acc * 2, reverse string)) 3 (True, "foo")
--   (7,("True","oof"))
--   </pre>
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bimapDefault</a> f g ≡
--        <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   </pre>
bimapDefault :: forall t a b c d. Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bifoldMapDefault</a> f g ≡
--       <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
bifoldMapDefault :: forall t m a b. (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bitraversable.Bitraversable (,)
instance Data.Bitraversable.Bitraversable ((,,) x)
instance Data.Bitraversable.Bitraversable ((,,,) x y)
instance Data.Bitraversable.Bitraversable ((,,,,) x y z)
instance Data.Bitraversable.Bitraversable ((,,,,,) x y z w)
instance Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v)
instance Data.Bitraversable.Bitraversable Data.Either.Either
instance Data.Bitraversable.Bitraversable Data.Functor.Const.Const
instance Data.Bitraversable.Bitraversable (GHC.Generics.K1 i)


-- | This module provides scalable event notification for file descriptors
--   and timeouts.
--   
--   This module should be considered GHC internal.
--   
--   <ul>
--   
--   <li>---------------------------------------------------------------------------</li>
--   </ul>
module GHC.Event

-- | The event manager state.
data EventManager

-- | The event manager state.
data TimerManager

-- | Retrieve the system event manager for the capability on which the
--   calling thread is running.
--   
--   This function always returns <a>Just</a> the current thread's event
--   manager when using the threaded RTS and <a>Nothing</a> otherwise.
getSystemEventManager :: IO (Maybe EventManager)

-- | Create a new event manager.
new :: IO EventManager
getSystemTimerManager :: IO TimerManager

-- | An I/O event.
data Event

-- | Data is available to be read.
evtRead :: Event

-- | The file descriptor is ready to accept a write.
evtWrite :: Event

-- | Callback invoked on I/O events.
type IOCallback = FdKey -> Event -> IO ()

-- | A file descriptor registration cookie.
data FdKey

-- | The lifetime of an event registration.
data Lifetime

-- | the registration will be active for only one event
OneShot :: Lifetime

-- | the registration will trigger multiple times
MultiShot :: Lifetime

-- | <tt>registerFd mgr cb fd evs lt</tt> registers interest in the events
--   <tt>evs</tt> on the file descriptor <tt>fd</tt> for lifetime
--   <tt>lt</tt>. <tt>cb</tt> is called for each event that occurs. Returns
--   a cookie that can be handed to <a>unregisterFd</a>.
registerFd :: EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey

-- | Drop a previous file descriptor registration.
unregisterFd :: EventManager -> FdKey -> IO ()

-- | Drop a previous file descriptor registration, without waking the event
--   manager thread. The return value indicates whether the event manager
--   ought to be woken.
unregisterFd_ :: EventManager -> FdKey -> IO Bool

-- | Close a file descriptor in a race-safe way. It might block, although
--   for a very short time; and thus it is interruptible by asynchronous
--   exceptions.
closeFd :: EventManager -> (Fd -> IO ()) -> Fd -> IO ()

-- | Warning: since the <a>TimeoutCallback</a> is called from the I/O
--   manager, it must not throw an exception or block for a long period of
--   time. In particular, be wary of <a>throwTo</a> and <a>killThread</a>:
--   if the target thread is making a foreign call, these functions will
--   block until the call completes.
type TimeoutCallback = IO ()

-- | A timeout registration cookie.
data TimeoutKey

-- | Register a timeout in the given number of microseconds. The returned
--   <a>TimeoutKey</a> can be used to later unregister or update the
--   timeout. The timeout is automatically unregistered after the given
--   time has passed.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
registerTimeout :: TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey

-- | Update an active timeout to fire in the given number of microseconds.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
updateTimeout :: TimerManager -> TimeoutKey -> Int -> IO ()

-- | Unregister an active timeout.
unregisterTimeout :: TimerManager -> TimeoutKey -> IO ()


-- | Basic concurrency stuff.
module GHC.Conc

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId
ThreadId :: ThreadId# -> ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
--   
--   WARNING: Exceptions in the new thread will not be rethrown in the
--   thread that created it. This means that you might be completely
--   unaware of the problem if/when this happens. You may want to use the
--   <a>async</a> library instead.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | the value passed to the <tt>+RTS -N</tt> flag. This is the number of
--   Haskell threads that can run truly simultaneously at any given time,
--   and is typically set to the number of physical processor cores on the
--   machine.
--   
--   Strictly speaking it is better to use <a>getNumCapabilities</a>,
--   because the number of capabilities might vary at runtime.
numCapabilities :: Int

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of CPUs that the machine has
getNumProcessors :: IO Int

-- | Returns the number of sparks currently in the local spark pool
numSparks :: IO Int
childHandler :: SomeException -> IO ()

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()
par :: a -> b -> b
infixr 0 `par`
pseq :: a -> b -> b
infixr 0 `pseq`

-- | Internal function used by the RTS to run sparks.
runSparks :: IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | <a>labelThread</a> stores a string as identifier for this thread. This
--   identifier will be used in the debugging output to make distinction of
--   different threads easier (otherwise you only have the thread state
--   object's address in the heap). It also emits an event to the RTS
--   eventlog.
labelThread :: ThreadId -> String -> IO ()

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | List the Haskell threads of the current process.
listThreads :: IO [ThreadId]

-- | The current status of a thread
data ThreadStatus

-- | the thread is currently runnable or running
ThreadRunning :: ThreadStatus

-- | the thread has finished
ThreadFinished :: ThreadStatus

-- | the thread is blocked on some resource
ThreadBlocked :: BlockReason -> ThreadStatus

-- | the thread received an uncaught exception
ThreadDied :: ThreadStatus
data BlockReason

-- | blocked on <a>MVar</a>
BlockedOnMVar :: BlockReason

-- | blocked on a computation in progress by another thread
BlockedOnBlackHole :: BlockReason

-- | blocked in <a>throwTo</a>
BlockedOnException :: BlockReason

-- | blocked in <a>retry</a> in an STM transaction
BlockedOnSTM :: BlockReason

-- | currently in a foreign call
BlockedOnForeignCall :: BlockReason

-- | blocked on some other resource. Without <tt>-threaded</tt>, I/O and
--   <a>threadDelay</a> show up as <a>BlockedOnOther</a>, with
--   <tt>-threaded</tt> they show up as <a>BlockedOnMVar</a>.
BlockedOnOther :: BlockReason

-- | Query the current execution status of a thread.
threadStatus :: ThreadId -> IO ThreadStatus

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Make a <a>StablePtr</a> that can be passed to the C function
--   <tt>hs_try_putmvar()</tt>. The RTS wants a <a>StablePtr</a> to the
--   underlying <a>MVar#</a>, but a <a>StablePtr#</a> can only refer to
--   lifted types, so we have to cheat by coercing.
newStablePtrPrimMVar :: MVar a -> IO (StablePtr PrimMVar)
data PrimMVar

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes. Consider using
--   <tt>Control.Concurrent.Thread.Delay.delay</tt> from
--   <tt>unbounded-delays</tt> package.
threadDelay :: Int -> IO ()

-- | Switch the value of returned <a>TVar</a> from initial value
--   <a>False</a> to <a>True</a> after a given number of microseconds. The
--   caveats associated with <a>threadDelay</a> also apply.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes.
registerDelay :: Int -> IO (TVar Bool)

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | Close a file descriptor in a concurrency-safe way (GHC only). If you
--   are using <a>threadWaitRead</a> or <a>threadWaitWrite</a> to perform
--   blocking I/O, you <i>must</i> use this function to close file
--   descriptors, or blocked threads may not be woken.
--   
--   Any threads that are blocked on the file descriptor via
--   <a>threadWaitRead</a> or <a>threadWaitWrite</a> will be unblocked by
--   having IO exceptions thrown.
closeFdWith :: (Fd -> IO ()) -> Fd -> IO ()

-- | Every thread has an allocation counter that tracks how much memory has
--   been allocated by the thread. The counter is initialized to zero, and
--   <a>setAllocationCounter</a> sets the current value. The allocation
--   counter counts *down*, so in the absence of a call to
--   <a>setAllocationCounter</a> its value is the negation of the number of
--   bytes of memory allocated by the thread.
--   
--   There are two things that you can do with this counter:
--   
--   <ul>
--   <li>Use it as a simple profiling mechanism, with
--   <a>getAllocationCounter</a>.</li>
--   <li>Use it as a resource limit. See <a>enableAllocationLimit</a>.</li>
--   </ul>
--   
--   Allocation accounting is accurate only to about 4Kbytes.
setAllocationCounter :: Int64 -> IO ()

-- | Return the current value of the allocation counter for the current
--   thread.
getAllocationCounter :: IO Int64

-- | Enables the allocation counter to be treated as a limit for the
--   current thread. When the allocation limit is enabled, if the
--   allocation counter counts down below zero, the thread will be sent the
--   <a>AllocationLimitExceeded</a> asynchronous exception. When this
--   happens, the counter is reinitialised (by default to 100K, but tunable
--   with the <tt>+RTS -xq</tt> option) so that it can handle the exception
--   and perform any necessary clean up. If it exhausts this additional
--   allowance, another <a>AllocationLimitExceeded</a> exception is sent,
--   and so forth. Like other asynchronous exceptions, the
--   <a>AllocationLimitExceeded</a> exception is deferred while the thread
--   is inside <a>mask</a> or an exception handler in <a>catch</a>.
--   
--   Note that memory allocation is unrelated to <i>live memory</i>, also
--   known as <i>heap residency</i>. A thread can allocate a large amount
--   of memory and retain anything between none and all of it. It is better
--   to think of the allocation limit as a limit on <i>CPU time</i>, rather
--   than a limit on memory.
--   
--   Compared to using timeouts, allocation limits don't count time spent
--   blocked or in foreign calls.
enableAllocationLimit :: IO ()

-- | Disable allocation limit processing for the current thread.
disableAllocationLimit :: IO ()

-- | A monad supporting atomic memory transactions.
newtype STM a
STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a

-- | Perform a series of STM actions atomically.
--   
--   Using <a>atomically</a> inside an <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a> subverts some of guarantees that STM
--   provides. It makes it possible to run a transaction inside of another
--   transaction, depending on when the thunk is evaluated. If a nested
--   transaction is attempted, an exception is thrown by the runtime. It is
--   possible to safely use <a>atomically</a> inside <a>unsafePerformIO</a>
--   or <a>unsafeInterleaveIO</a>, but the typechecker does not rule out
--   programs that may attempt nested transactions, meaning that the
--   programmer must take special care to prevent these.
--   
--   However, there are functions for creating transactional variables that
--   can always be safely called in <a>unsafePerformIO</a>. See:
--   <a>newTVarIO</a>, <a>newTChanIO</a>, <a>newBroadcastTChanIO</a>,
--   <a>newTQueueIO</a>, <a>newTBQueueIO</a>, and <a>newTMVarIO</a>.
--   
--   Using <a>unsafePerformIO</a> inside of <a>atomically</a> is also
--   dangerous but for different reasons. See <a>unsafeIOToSTM</a> for more
--   on this.
atomically :: STM a -> IO a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception. If the exception is caught via
--   <a>catchSTM</a>, only the changes enclosed by the catch are rolled
--   back; changes made outside of <a>catchSTM</a> persist.
--   
--   If the exception is not caught inside of the <a>STM</a>, it is
--   re-thrown by <a>atomically</a>, and the entire <a>STM</a> is rolled
--   back.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
--   
--   <tt><a>catchSTM</a> m f</tt> catches any exception thrown by
--   <tt>m</tt> using <a>throwSTM</a>, using the function <tt>f</tt> to
--   handle the exception. If an exception is thrown, any changes made by
--   <tt>m</tt> are rolled back, but changes prior to <tt>m</tt> persist.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a
TVar :: TVar# RealWorld a -> TVar a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | <tt>IO</tt> version of <a>newTVar</a>. This is useful for creating
--   top-level <a>TVar</a>s using <a>unsafePerformIO</a>, because using
--   <a>atomically</a> inside <a>unsafePerformIO</a> isn't possible.
newTVarIO :: a -> IO (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Return the current value stored in a <a>TVar</a>. This is equivalent
--   to
--   
--   <pre>
--   readTVarIO = atomically . readTVar
--   </pre>
--   
--   but works much faster, because it doesn't perform a complete
--   transaction, it just reads the current value of the <a>TVar</a>.
readTVarIO :: TVar a -> IO a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Unsafely performs IO in the STM monad. Beware: this is a highly
--   dangerous thing to do.
--   
--   <ul>
--   <li>The STM implementation will often run transactions multiple times,
--   so you need to be prepared for this if your IO has any side
--   effects.</li>
--   <li>The STM implementation will abort transactions that are known to
--   be invalid and need to be restarted. This may happen in the middle of
--   <a>unsafeIOToSTM</a>, so make sure you don't acquire any resources
--   that need releasing (exception handlers are ignored when aborting the
--   transaction). That includes doing any IO using Handles, for example.
--   Getting this wrong will probably lead to random deadlocks.</li>
--   <li>The transaction may have seen an inconsistent view of memory when
--   the IO runs. Invariants that you expect to be true throughout your
--   program may not be true inside a transaction, due to the way
--   transactions are implemented. Normally this wouldn't be visible to the
--   programmer, but using <a>unsafeIOToSTM</a> can expose it.</li>
--   </ul>
unsafeIOToSTM :: IO a -> STM a

-- | Provide an <a>IO</a> action with the current value of an <a>MVar</a>.
--   The <a>MVar</a> will be empty for the duration that the action is
--   running.
withMVar :: MVar a -> (a -> IO b) -> IO b
type Signal = CInt
type HandlerFun = ForeignPtr Word8 -> IO ()
setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))
runHandlers :: ForeignPtr Word8 -> Signal -> IO ()
ensureIOManagerIsRunning :: IO ()
ioManagerCapabilitiesChanged :: IO ()
setUncaughtExceptionHandler :: (SomeException -> IO ()) -> IO ()
getUncaughtExceptionHandler :: IO (SomeException -> IO ())
reportError :: SomeException -> IO ()
reportStackOverflow :: IO ()
reportHeapOverflow :: IO ()


-- | Support for catching exceptions raised during top-level computations
--   (e.g. <tt>Main.main</tt>, <a>forkIO</a>, and foreign exports)
module GHC.TopHandler

-- | <a>runMainIO</a> is wrapped around <a>main</a> (or whatever main is
--   called in the program). It catches otherwise uncaught exceptions, and
--   also flushes stdout/stderr before exiting.
runMainIO :: IO a -> IO a

-- | <a>runIO</a> is wrapped around every <tt>foreign export</tt> and
--   <tt>foreign import "wrapper"</tt> to mop up any uncaught exceptions.
--   Thus, the result of running <a>exitWith</a> in a foreign-exported
--   function is the same as in the main thread: it terminates the program.
runIO :: IO a -> IO a

-- | Like <a>runIO</a>, but in the event of an exception that causes an
--   exit, we don't shut down the system cleanly, we just exit. This is
--   useful in some cases, because the safe exit version will give other
--   threads a chance to clean up first, which might shut down the system
--   in a different way. For example, try
--   
--   main = forkIO (runIO (exitWith (ExitFailure 1))) &gt;&gt; threadDelay
--   10000
--   
--   This will sometimes exit with "interrupted" and code 0, because the
--   main thread is given a chance to shut down when the child thread calls
--   safeExit. There is a race to shut down between the main and child
--   threads.
runIOFastExit :: IO a -> IO a

-- | The same as <a>runIO</a>, but for non-IO computations. Used for
--   wrapping <tt>foreign export</tt> and <tt>foreign import "wrapper"</tt>
--   when these are used to export Haskell functions with non-IO types.
runNonIO :: a -> IO a
topHandler :: SomeException -> IO a
topHandlerFastExit :: SomeException -> IO a
reportStackOverflow :: IO ()
reportError :: SomeException -> IO ()
flushStdHandles :: IO ()


-- | Quantity semaphores in which each thread may wait for an arbitrary
--   "amount".
module Control.Concurrent.QSemN

-- | <a>QSemN</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data QSemN

-- | Build a new <a>QSemN</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSemN :: Int -> IO QSemN

-- | Wait for the specified quantity to become available
waitQSemN :: QSemN -> Int -> IO ()

-- | Signal that a given quantity is now available from the <a>QSemN</a>.
signalQSemN :: QSemN -> Int -> IO ()


-- | Simple quantity semaphores.
module Control.Concurrent.QSem

-- | <a>QSem</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data QSem

-- | Build a new <a>QSem</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSem :: Int -> IO QSem

-- | Wait for a unit to become available
waitQSem :: QSem -> IO ()

-- | Signal that a unit of the <a>QSem</a> is available
signalQSem :: QSem -> IO ()


-- | Unbounded channels.
--   
--   The channels are implemented with <tt>MVar</tt>s and therefore inherit
--   all the caveats that apply to <tt>MVar</tt>s (possibility of races,
--   deadlocks etc). The stm (software transactional memory) library has a
--   more robust implementation of channels called <tt>TChan</tt>s.
module Control.Concurrent.Chan

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Build and returns a new instance of <a>Chan</a>.
newChan :: IO (Chan a)

-- | Write a value to a <a>Chan</a>.
writeChan :: Chan a -> a -> IO ()

-- | Read the next value from the <a>Chan</a>. Blocks when the channel is
--   empty. Since the read end of a channel is an <a>MVar</a>, this
--   operation inherits fairness guarantees of <a>MVar</a>s (e.g. threads
--   blocked in this operation are woken up in FIFO order).
--   
--   Throws <a>BlockedIndefinitelyOnMVar</a> when the channel is empty and
--   no other thread holds a reference to the channel.
readChan :: Chan a -> IO a

-- | Duplicate a <a>Chan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
--   
--   (Note that a duplicated channel is not equal to its original. So:
--   <tt>fmap (c /=) $ dupChan c</tt> returns <tt>True</tt> for all
--   <tt>c</tt>.)
dupChan :: Chan a -> IO (Chan a)

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like <a>hGetContents</a>.
getChanContents :: Chan a -> IO [a]

-- | Write an entire list of items to a <a>Chan</a>.
writeList2Chan :: Chan a -> [a] -> IO ()
instance GHC.Classes.Eq (Control.Concurrent.Chan.Chan a)


-- | A common interface to a collection of useful concurrency abstractions.
module Control.Concurrent

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
--   
--   WARNING: Exceptions in the new thread will not be rethrown in the
--   thread that created it. This means that you might be completely
--   unaware of the problem if/when this happens. You may want to use the
--   <a>async</a> library instead.
forkIO :: IO () -> IO ThreadId

-- | Fork a thread and call the supplied function when the thread is about
--   to terminate, with an exception or a returned value. The function is
--   called with asynchronous exceptions masked.
--   
--   <pre>
--   forkFinally action and_then =
--     mask $ \restore -&gt;
--       forkIO $ try (restore action) &gt;&gt;= and_then
--   </pre>
--   
--   This function is useful for informing the parent when a child
--   terminates, for example.
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
forkOnWithUnmask :: Int -> ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
setNumCapabilities :: Int -> IO ()

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
threadCapability :: ThreadId -> IO (Int, Bool)

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
--   
--   Be careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes. Consider using
--   <tt>Control.Concurrent.Thread.Delay.delay</tt> from
--   <tt>unbounded-delays</tt> package.
threadDelay :: Int -> IO ()

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

-- | Like <a>forkIO</a>, this sparks off a new thread to run the <a>IO</a>
--   computation passed as the first argument, and returns the
--   <a>ThreadId</a> of the newly created thread.
--   
--   However, <a>forkOS</a> creates a <i>bound</i> thread, which is
--   necessary if you need to call foreign (non-Haskell) libraries that
--   make use of thread-local state, such as OpenGL (see
--   <a>Control.Concurrent#boundthreads</a>).
--   
--   Using <a>forkOS</a> instead of <a>forkIO</a> makes no difference at
--   all to the scheduling behaviour of the Haskell runtime system. It is a
--   common misconception that you need to use <a>forkOS</a> instead of
--   <a>forkIO</a> to avoid blocking all the Haskell threads when making a
--   foreign call; this isn't the case. To allow foreign calls to be made
--   without blocking all the Haskell threads (with GHC), it is only
--   necessary to use the <tt>-threaded</tt> option when linking your
--   program, and to make sure the foreign import is not marked
--   <tt>unsafe</tt>.
forkOS :: IO () -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is a bound thread,
--   as with <a>forkOS</a>.
forkOSWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns <a>True</a> if the calling thread is <i>bound</i>, that is, if
--   it is safe to use foreign libraries that rely on thread-local state
--   from the calling thread.
isCurrentThreadBound :: IO Bool

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is not <i>bound</i>, a bound thread is created
--   temporarily. <tt>runInBoundThread</tt> doesn't finish until the
--   <a>IO</a> computation finishes.
--   
--   You can wrap a series of foreign function calls that rely on
--   thread-local state with <tt>runInBoundThread</tt> so that you can use
--   them without knowing whether the current thread is <i>bound</i>.
runInBoundThread :: IO a -> IO a

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is <i>bound</i>, an unbound thread is created
--   temporarily using <a>forkIO</a>. <tt>runInBoundThread</tt> doesn't
--   finish until the <a>IO</a> computation finishes.
--   
--   Use this function <i>only</i> in the rare case that you have actually
--   observed a performance loss due to the use of bound threads. A program
--   that doesn't need its main thread to be bound and makes <i>heavy</i>
--   use of concurrency (e.g. a web server), might want to wrap its
--   <tt>main</tt> action in <tt>runInUnboundThread</tt>.
--   
--   Note that exceptions which are thrown to the current thread are thrown
--   in turn to the thread that is executing the given computation. This
--   ensures there's always a way of killing the forked thread.
runInUnboundThread :: IO a -> IO a

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)


-- | Attach a timeout event to arbitrary <a>IO</a> computations.
module System.Timeout

-- | An exception thrown to a thread by <a>timeout</a> to interrupt a
--   timed-out computation.
data Timeout

-- | Wrap an <a>IO</a> computation to time out and return <tt>Nothing</tt>
--   in case no result is available within <tt>n</tt> microseconds
--   (<tt>1/10^6</tt> seconds). In case a result is available before the
--   timeout expires, <tt>Just a</tt> is returned. A negative timeout
--   interval means "wait indefinitely". When specifying long timeouts, be
--   careful not to exceed <tt>maxBound :: Int</tt>, which on 32-bit
--   machines is only 2147483647 μs, less than 36 minutes. Consider using
--   <tt>Control.Concurrent.Timeout.timeout</tt> from
--   <tt>unbounded-delays</tt> package.
--   
--   <pre>
--   &gt;&gt;&gt; timeout 1000000 (threadDelay 1000 *&gt; pure "finished on time")
--   Just "finished on time"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timeout 10000 (threadDelay 100000 *&gt; pure "finished on time")
--   Nothing
--   </pre>
--   
--   The design of this combinator was guided by the objective that
--   <tt>timeout n f</tt> should behave exactly the same as <tt>f</tt> as
--   long as <tt>f</tt> doesn't time out. This means that <tt>f</tt> has
--   the same <a>myThreadId</a> it would have without the timeout wrapper.
--   Any exceptions <tt>f</tt> might throw cancel the timeout and propagate
--   further up. It also possible for <tt>f</tt> to receive exceptions
--   thrown to it by another thread.
--   
--   A tricky implementation detail is the question of how to abort an
--   <tt>IO</tt> computation. This combinator relies on asynchronous
--   exceptions internally (namely throwing the computation the
--   <a>Timeout</a> exception). The technique works very well for
--   computations executing inside of the Haskell runtime system, but it
--   doesn't work at all for non-Haskell code. Foreign function calls, for
--   example, cannot be timed out with this combinator simply because an
--   arbitrary C function cannot receive asynchronous exceptions. When
--   <tt>timeout</tt> is used to wrap an FFI call that blocks, no timeout
--   event can be delivered until the FFI call returns, which pretty much
--   negates the purpose of the combinator. In practice, however, this
--   limitation is less severe than it may sound. Standard I/O functions
--   like <a>hGetBuf</a>, <a>hPutBuf</a>, Network.Socket.accept, or
--   <a>hWaitForInput</a> appear to be blocking, but they really don't
--   because the runtime system uses scheduling mechanisms like
--   <tt>select(2)</tt> to perform asynchronous I/O, so it is possible to
--   interrupt standard socket I/O or file I/O using this combinator.
timeout :: Int -> IO a -> IO (Maybe a)
instance GHC.Classes.Eq System.Timeout.Timeout
instance GHC.Show.Show System.Timeout.Timeout
instance GHC.Exception.Type.Exception System.Timeout.Timeout


-- | This module provides the <a>Data</a> class with its primitives for
--   generic programming, along with instances for many datatypes. It
--   corresponds to a merge between the previous
--   <a>Data.Generics.Basics</a> and almost all of
--   <a>Data.Generics.Instances</a>. The instances that are not present in
--   this module were moved to the <tt>Data.Generics.Instances</tt> module
--   in the <tt>syb</tt> package.
--   
--   "Scrap your boilerplate" --- Generic programming in Haskell. See
--   <a>https://wiki.haskell.org/Research_papers/Generics#Scrap_your_boilerplate.21</a>.
module Data.Data

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type within generic folding is <tt>r -&gt;
--   r</tt>. So the result of folding is a function to which we finally
--   pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: forall r r'. Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: forall u. Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: forall m. (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: forall m. (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Representation of datatypes. A package of constructor representations
--   with names of type and module.
data DataType

-- | Constructs an algebraic datatype
mkDataType :: String -> [Constr] -> DataType

-- | Constructs the <a>Int</a> type
mkIntType :: String -> DataType

-- | Constructs the <a>Float</a> type
mkFloatType :: String -> DataType

-- | Constructs the <a>Char</a> type
mkCharType :: String -> DataType

-- | Constructs a non-representation for a non-representable type
mkNoRepType :: String -> DataType

-- | Gets the type constructor including the module
dataTypeName :: DataType -> String

-- | Public representation of datatypes
data DataRep
AlgRep :: [Constr] -> DataRep
IntRep :: DataRep
FloatRep :: DataRep
CharRep :: DataRep
NoRep :: DataRep

-- | Gets the public presentation of a datatype
dataTypeRep :: DataType -> DataRep

-- | Look up a constructor by its representation
repConstr :: DataType -> ConstrRep -> Constr

-- | Test for an algebraic type
isAlgType :: DataType -> Bool

-- | Gets the constructors of an algebraic datatype
dataTypeConstrs :: DataType -> [Constr]

-- | Gets the constructor for an index (algebraic datatypes only)
indexConstr :: DataType -> ConIndex -> Constr

-- | Gets the maximum constructor index of an algebraic datatype
maxConstrIndex :: DataType -> ConIndex

-- | Test for a non-representable type
isNorepType :: DataType -> Bool

-- | Representation of constructors. Note that equality on constructors
--   with different types may not work -- i.e. the constructors for
--   <a>False</a> and <a>Nothing</a> may compare equal.
data Constr

-- | Unique index for datatype constructors, counting from 1 in the order
--   they are given in the program text.
type ConIndex = Int

-- | Fixity of constructors
data Fixity
Prefix :: Fixity
Infix :: Fixity

-- | Constructs a constructor
mkConstr :: DataType -> String -> [String] -> Fixity -> Constr

-- | Constructs a constructor
mkConstrTag :: DataType -> String -> Int -> [String] -> Fixity -> Constr
mkIntegralConstr :: (Integral a, Show a) => DataType -> a -> Constr
mkRealConstr :: (Real a, Show a) => DataType -> a -> Constr

-- | Makes a constructor for <a>Char</a>.
mkCharConstr :: DataType -> Char -> Constr

-- | Gets the datatype of a constructor
constrType :: Constr -> DataType

-- | Public representation of constructors
data ConstrRep
AlgConstr :: ConIndex -> ConstrRep
IntConstr :: Integer -> ConstrRep
FloatConstr :: Rational -> ConstrRep
CharConstr :: Char -> ConstrRep

-- | Gets the public presentation of constructors
constrRep :: Constr -> ConstrRep

-- | Gets the field labels of a constructor. The list of labels is returned
--   in the same order as they were given in the original constructor
--   declaration.
constrFields :: Constr -> [String]

-- | Gets the fixity of a constructor
constrFixity :: Constr -> Fixity

-- | Gets the index of a constructor (algebraic datatypes only)
constrIndex :: Constr -> ConIndex

-- | Gets the string for a constructor
showConstr :: Constr -> String

-- | Lookup a constructor via a string
readConstr :: DataType -> String -> Maybe Constr

-- | Gets the unqualified type constructor: drop *.*.*... before name
tyconUQname :: String -> String

-- | Gets the module of a type constructor: take *.*.*... before name
tyconModule :: String -> String

-- | Build a term skeleton
fromConstr :: Data a => Constr -> a

-- | Build a term and use a generic function for subterms
fromConstrB :: Data a => (forall d. Data d => d) -> Constr -> a

-- | Monadic variation on <a>fromConstrB</a>
fromConstrM :: forall m a. (Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
instance GHC.Show.Show Data.Data.ConstrRep
instance GHC.Classes.Eq Data.Data.ConstrRep
instance GHC.Show.Show Data.Data.Fixity
instance GHC.Classes.Eq Data.Data.Fixity
instance GHC.Show.Show Data.Data.DataRep
instance GHC.Classes.Eq Data.Data.DataRep
instance GHC.Show.Show Data.Data.DataType
instance Data.Data.Data GHC.Types.Bool
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable c, Data.Data.Data (a b c)) => Data.Data.Data (Control.Applicative.WrappedArrow a b c)
instance (Data.Typeable.Internal.Typeable m, Data.Typeable.Internal.Typeable a, Data.Data.Data (m a)) => Data.Data.Data (Control.Applicative.WrappedMonad m a)
instance Data.Data.Data a => Data.Data.Data (Control.Applicative.ZipList a)
instance Data.Data.Data a => Data.Data.Data (GHC.Base.NonEmpty a)
instance Data.Data.Data a => Data.Data.Data (GHC.Maybe.Maybe a)
instance Data.Data.Data GHC.Types.Ordering
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b)
instance Data.Data.Data GHC.Base.Void
instance Data.Data.Data ()
instance Data.Data.Data a => Data.Data.Data (Solo a)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f)
instance (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g)
instance Data.Data.Data a => Data.Data.Data (Foreign.C.ConstPtr.ConstPtr a)
instance Data.Data.Data Foreign.Ptr.IntPtr
instance Data.Data.Data Foreign.Ptr.WordPtr
instance Data.Data.Data t => Data.Data.Data (Data.Proxy.Proxy t)
instance (a GHC.Types.~ b, Data.Data.Data a) => Data.Data.Data (a Data.Type.Equality.:~: b)
instance forall i j (a :: i) (b :: j). (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable j, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, a GHC.Types.~~ b) => Data.Data.Data (a Data.Type.Equality.:~~: b)
instance (GHC.Types.Coercible a b, Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Type.Coercion.Coercion a b)
instance Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). (Data.Typeable.Internal.Typeable k, Data.Data.Data a, Data.Typeable.Internal.Typeable b) => Data.Data.Data (Data.Functor.Const.Const a b)
instance Data.Data.Data Data.Version.Version
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Dual a)
instance Data.Data.Data Data.Semigroup.Internal.All
instance Data.Data.Data Data.Semigroup.Internal.Any
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Sum a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Internal.Product a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.Last a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Semigroup.Internal.Alt f a)
instance (Data.Data.Data (f a), Data.Data.Data a, Data.Typeable.Internal.Typeable f) => Data.Data.Data (Data.Monoid.Ap f a)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.U1 p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.Par1 p)
instance (Data.Data.Data (f p), Data.Typeable.Internal.Typeable f, Data.Data.Data p) => Data.Data.Data (GHC.Generics.Rec1 f p)
instance (Data.Typeable.Internal.Typeable i, Data.Data.Data p, Data.Data.Data c) => Data.Data.Data (GHC.Generics.K1 i c p)
instance (Data.Data.Data p, Data.Data.Data (f p), Data.Typeable.Internal.Typeable c, Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable f) => Data.Data.Data (GHC.Generics.M1 i c f p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:+:) f g p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f (g p))) => Data.Data.Data ((GHC.Generics.:.:) f g p)
instance Data.Data.Data p => Data.Data.Data (GHC.Generics.V1 p)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Data.Data p, Data.Data.Data (f p), Data.Data.Data (g p)) => Data.Data.Data ((GHC.Generics.:*:) f g p)
instance Data.Data.Data GHC.Generics.Fixity
instance Data.Data.Data GHC.Generics.Associativity
instance Data.Data.Data GHC.Generics.SourceUnpackedness
instance Data.Data.Data GHC.Generics.SourceStrictness
instance Data.Data.Data GHC.Generics.DecidedStrictness
instance Data.Data.Data a => Data.Data.Data (Data.Ord.Down a)
instance Data.Data.Data GHC.Types.Char
instance Data.Data.Data GHC.Types.Float
instance Data.Data.Data GHC.Types.Double
instance Data.Data.Data GHC.Types.Int
instance Data.Data.Data GHC.Num.Integer.Integer
instance Data.Data.Data GHC.Num.Natural.Natural
instance Data.Data.Data GHC.Int.Int8
instance Data.Data.Data GHC.Int.Int16
instance Data.Data.Data GHC.Int.Int32
instance Data.Data.Data GHC.Int.Int64
instance Data.Data.Data GHC.Types.Word
instance Data.Data.Data GHC.Word.Word8
instance Data.Data.Data GHC.Word.Word16
instance Data.Data.Data GHC.Word.Word32
instance Data.Data.Data GHC.Word.Word64
instance (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a)
instance Data.Data.Data a => Data.Data.Data [a]
instance Data.Data.Data a => Data.Data.Data (GHC.Ptr.Ptr a)
instance Data.Data.Data a => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a)
instance (Data.Data.Data a, Data.Data.Data b, GHC.Ix.Ix a) => Data.Data.Data (GHC.Arr.Array a b)
instance GHC.Show.Show Data.Data.Constr
instance GHC.Classes.Eq Data.Data.Constr


-- | GHC Extensions: this is the Approved Way to get at GHC-specific
--   extensions.
--   
--   Note: no other base module should import this module.
module GHC.Exts

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data Ptr a
Ptr :: Addr# -> Ptr a

-- | A value of type <tt><a>FunPtr</a> a</tt> is a pointer to a function
--   callable from foreign code. The type <tt>a</tt> will normally be a
--   <i>foreign type</i>, a function type with zero or more arguments where
--   
--   <ul>
--   <li>the argument types are <i>marshallable foreign types</i>, i.e.
--   <a>Char</a>, <a>Int</a>, <a>Double</a>, <a>Float</a>, <a>Bool</a>,
--   <a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>, <a>Word8</a>,
--   <a>Word16</a>, <a>Word32</a>, <a>Word64</a>, <tt><a>Ptr</a> a</tt>,
--   <tt><a>FunPtr</a> a</tt>, <tt><a>StablePtr</a> a</tt> or a renaming of
--   any of these using <tt>newtype</tt>.</li>
--   <li>the return type is either a marshallable foreign type or has the
--   form <tt><a>IO</a> t</tt> where <tt>t</tt> is a marshallable foreign
--   type or <tt>()</tt>.</li>
--   </ul>
--   
--   A value of type <tt><a>FunPtr</a> a</tt> may be a pointer to a foreign
--   function, either returned by another foreign function or imported with
--   a a static address import like
--   
--   <pre>
--   foreign import ccall "stdlib.h &amp;free"
--     p_free :: FunPtr (Ptr a -&gt; IO ())
--   </pre>
--   
--   or a pointer to a Haskell function created using a <i>wrapper</i> stub
--   declared to produce a <a>FunPtr</a> of the correct type. For example:
--   
--   <pre>
--   type Compare = Int -&gt; Int -&gt; Bool
--   foreign import ccall "wrapper"
--     mkCompare :: Compare -&gt; IO (FunPtr Compare)
--   </pre>
--   
--   Calls to wrapper stubs like <tt>mkCompare</tt> allocate storage, which
--   should be released with <a>freeHaskellFunPtr</a> when no longer
--   required.
--   
--   To convert <a>FunPtr</a> values to corresponding Haskell functions,
--   one can define a <i>dynamic</i> stub for the specific foreign type,
--   e.g.
--   
--   <pre>
--   type IntFunction = CInt -&gt; IO ()
--   foreign import ccall "dynamic"
--     mkFun :: FunPtr IntFunction -&gt; IntFunction
--   </pre>
data FunPtr a
FunPtr :: Addr# -> FunPtr a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data () => Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data () => Float
F# :: Float# -> Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data () => Int
I# :: Int# -> Int
data TYPE (a :: RuntimeRep)
data CONSTRAINT (a :: RuntimeRep)
data () => WordBox (a :: TYPE 'WordRep)
MkWordBox :: a -> WordBox (a :: TYPE 'WordRep)
data () => IntBox (a :: TYPE 'IntRep)
MkIntBox :: a -> IntBox (a :: TYPE 'IntRep)
data () => FloatBox (a :: TYPE 'FloatRep)
MkFloatBox :: a -> FloatBox (a :: TYPE 'FloatRep)
data () => DoubleBox (a :: TYPE 'DoubleRep)
MkDoubleBox :: a -> DoubleBox (a :: TYPE 'DoubleRep)

-- | Data type <tt>Dict</tt> provides a simple way to wrap up a (lifted)
--   constraint as a type
data () => DictBox a
MkDictBox :: DictBox a
data () => Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data () => Char
C# :: Char# -> Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data () => Double
D# :: Double# -> Double

-- | The builtin list type, usually written in its non-prefix form
--   <tt>[a]</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Unless the OverloadedLists extension is enabled, list literals are
--   syntactic sugar for repeated applications of <tt>:</tt> and
--   <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 1:2:3:4:[] == [1,2,3,4]
--   True
--   </pre>
--   
--   Similarly, unless the OverloadedStrings extension is enabled, string
--   literals are syntactic sugar for a lists of characters.
--   
--   <pre>
--   &gt;&gt;&gt; ['h','e','l','l','o'] == "hello"
--   True
--   </pre>
data () => [] a
data () => Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~# b => (a :: k) ~ (b :: k)
infix 4 ~

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | (Kind) This is the kind of type-level symbols.
data () => Symbol

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain ⊥),
--   and unlifted ones (that don't).
data () => RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | boxed; represented by a pointer
BoxedRep :: Levity -> RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | Whether a boxed type is lifted or unlifted.
data () => Levity
Lifted :: Levity
Unlifted :: Levity

-- | Length of a SIMD vector type
data () => VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data () => VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem
data () => Multiplicity
One :: Multiplicity
Many :: Multiplicity

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data () => SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | The kind of the empty unboxed tuple type (# #)
type ZeroBitType = TYPE ZeroBitRep

-- | The runtime representation of a zero-width tuple, represented by no
--   bits at all
type ZeroBitRep = 'TupleRep '[] :: [RuntimeRep]

-- | The runtime representation of unlifted types.
type UnliftedRep = 'BoxedRep 'Unlifted

-- | The runtime representation of lifted types.
type LiftedRep = 'BoxedRep 'Lifted

-- | The kind of boxed, unlifted values, for example <tt>Array#</tt> or a
--   user-defined unlifted data type, using <tt>-XUnliftedDataTypes</tt>.
type UnliftedType = TYPE UnliftedRep

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | The type constructor <a>Any</a> is type to which you can unsafely
--   coerce any lifted type, and back. More concretely, for a lifted type
--   <tt>t</tt> and value <tt>x :: t</tt>, <tt>unsafeCoerce (unsafeCoerce x
--   :: Any) :: t</tt> is equivalent to <tt>x</tt>.
type family Any :: k
type Void# = (# #)
type family MultMul (a :: Multiplicity) (b :: Multiplicity) :: Multiplicity
pattern TypeLitChar :: () => TypeLitSort
pattern TypeLitNat :: () => TypeLitSort
pattern TypeLitSymbol :: () => TypeLitSort
pattern KindRepTypeLitD :: () => TypeLitSort -> [Char] -> KindRep
pattern KindRepTypeLitS :: () => TypeLitSort -> Addr# -> KindRep
pattern KindRepTYPE :: () => !RuntimeRep -> KindRep
pattern KindRepFun :: () => KindRep -> KindRep -> KindRep
pattern KindRepApp :: () => KindRep -> KindRep -> KindRep
pattern KindRepVar :: () => !KindBndr -> KindRep
pattern KindRepTyConApp :: () => TyCon -> [KindRep] -> KindRep

-- | Dynamic
pattern TrNameD :: () => [Char] -> TrName

-- | Static
pattern TrNameS :: () => Addr# -> TrName

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool
data Word# :: TYPE 'WordRep
data Int# :: TYPE 'IntRep

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr# :: TYPE 'AddrRep
data Array# (a :: TYPE 'BoxedRep l) :: UnliftedType

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray# :: UnliftedType
data SmallArray# (a :: TYPE 'BoxedRep l) :: UnliftedType
data Char# :: TYPE 'WordRep
data Double# :: TYPE 'DoubleRep
data Float# :: TYPE 'FloatRep
data Int8# :: TYPE 'Int8Rep
data Int16# :: TYPE 'Int16Rep
data Int32# :: TYPE 'Int32Rep
data Int64# :: TYPE 'Int64Rep

-- | Primitive bytecode type.
data BCO
data Weak# (a :: TYPE 'BoxedRep l) :: UnliftedType
data MutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# a :: UnliftedType
data SmallMutableArray# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A shared mutable variable (<i>not</i> the same as a <a>MutVar#</a>!).
--   (Note: in a non-concurrent implementation, <tt>(<a>MVar#</a> a)</tt>
--   can be represented by <tt>(<a>MutVar#</a> (Maybe a))</tt>.)
data MVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A shared I/O port is almost the same as an <a>MVar#</a>. The main
--   difference is that IOPort has no deadlock detection or deadlock
--   breaking code that forcibly releases the lock.
data IOPort# a (b :: TYPE 'BoxedRep l) :: UnliftedType
data TVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | A <a>MutVar#</a> behaves like a single-element mutable array.
data MutVar# a (b :: TYPE 'BoxedRep l) :: UnliftedType

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
data StablePtr# (a :: TYPE 'BoxedRep l) :: TYPE 'AddrRep
data StableName# (a :: TYPE 'BoxedRep l) :: UnliftedType
data Compact# :: UnliftedType

-- | <a>State#</a> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt><a>State#</a> <a>RealWorld</a></tt>, or
--   <tt><a>State#</a> s</tt>, where s is a type variable. The only purpose
--   of the type parameter is to keep different state threads separate. It
--   is represented by nothing at all.
data State# a :: ZeroBitType

-- | The type constructor <a>Proxy#</a> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <a>Proxy#</a> is not
--   only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# (a :: k) :: ZeroBitType

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <a>myThreadId#</a>. The other
--   operations can be omitted.)
data ThreadId# :: UnliftedType
data Word8# :: TYPE 'Word8Rep
data Word16# :: TYPE 'Word16Rep
data Word32# :: TYPE 'Word32Rep
data Word64# :: TYPE 'Word64Rep

-- | Haskell representation of a <tt>StgStack*</tt> that was created
--   (cloned) with a function in <a>GHC.Stack.CloneStack</a>. Please check
--   the documentation in that module for more detailed explanations.
data StackSnapshot# :: UnliftedType

-- | See <a>GHC.Prim#continuations</a>.
data PromptTag# a :: UnliftedType

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN
data TYPE (a :: RuntimeRep)
data CONSTRAINT (a :: RuntimeRep)

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X16# :: TYPE 'VecRep 'Vec16 'Int8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X8# :: TYPE 'VecRep 'Vec8 'Int16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X4# :: TYPE 'VecRep 'Vec4 'Int32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X2# :: TYPE 'VecRep 'Vec2 'Int64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X32# :: TYPE 'VecRep 'Vec32 'Int8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X16# :: TYPE 'VecRep 'Vec16 'Int16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X8# :: TYPE 'VecRep 'Vec8 'Int32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X4# :: TYPE 'VecRep 'Vec4 'Int64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X64# :: TYPE 'VecRep 'Vec64 'Int8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X32# :: TYPE 'VecRep 'Vec32 'Int16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X16# :: TYPE 'VecRep 'Vec16 'Int32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X8# :: TYPE 'VecRep 'Vec8 'Int64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X16# :: TYPE 'VecRep 'Vec16 'Word8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X8# :: TYPE 'VecRep 'Vec8 'Word16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X4# :: TYPE 'VecRep 'Vec4 'Word32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X2# :: TYPE 'VecRep 'Vec2 'Word64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X32# :: TYPE 'VecRep 'Vec32 'Word8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X16# :: TYPE 'VecRep 'Vec16 'Word16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X8# :: TYPE 'VecRep 'Vec8 'Word32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X4# :: TYPE 'VecRep 'Vec4 'Word64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X64# :: TYPE 'VecRep 'Vec64 'Word8ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X32# :: TYPE 'VecRep 'Vec32 'Word16ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X16# :: TYPE 'VecRep 'Vec16 'Word32ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X8# :: TYPE 'VecRep 'Vec8 'Word64ElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX4# :: TYPE 'VecRep 'Vec4 'FloatElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX2# :: TYPE 'VecRep 'Vec2 'DoubleElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX8# :: TYPE 'VecRep 'Vec8 'FloatElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX4# :: TYPE 'VecRep 'Vec4 'DoubleElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX16# :: TYPE 'VecRep 'Vec16 'FloatElemRep

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX8# :: TYPE 'VecRep 'Vec8 'DoubleElemRep
prefetchValue0# :: a -> State# d -> State# d
prefetchAddr0# :: Addr# -> Int# -> State# d -> State# d
prefetchMutableByteArray0# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchByteArray0# :: ByteArray# -> Int# -> State# d -> State# d
prefetchValue1# :: a -> State# d -> State# d
prefetchAddr1# :: Addr# -> Int# -> State# d -> State# d
prefetchMutableByteArray1# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchByteArray1# :: ByteArray# -> Int# -> State# d -> State# d
prefetchValue2# :: a -> State# d -> State# d
prefetchAddr2# :: Addr# -> Int# -> State# d -> State# d
prefetchMutableByteArray2# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchByteArray2# :: ByteArray# -> Int# -> State# d -> State# d
prefetchValue3# :: a -> State# d -> State# d
prefetchAddr3# :: Addr# -> Int# -> State# d -> State# d
prefetchMutableByteArray3# :: MutableByteArray# d -> Int# -> State# d -> State# d
prefetchByteArray3# :: ByteArray# -> Int# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# d -> State# d

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# d -> State# d

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X8# :: Word64# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X16# :: Word32# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X32# :: Word16# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X64# :: Word8# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X4# :: Word64# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X8# :: Word32# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X16# :: Word16# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X32# :: Word8# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X2# :: Word64# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X4# :: Word32# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X8# :: Word16# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X16# :: Word8# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X8# :: Int64# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X16# :: Int32# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X32# :: Int16# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X64# :: Int8# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X4# :: Int64# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X8# :: Int32# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X16# :: Int16# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X32# :: Int8# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X2# :: Int64# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X4# :: Int32# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X8# :: Int16# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X16# :: Int8# -> Int8X16#

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the given
--   length passed as the second argument. The event will be emitted to the
--   <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# d -> State# d

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# d -> State# d

-- | Returns the <tt>InfoProvEnt </tt> for the info table of the given
--   object (value is <tt>NULL</tt> if the table does not exist or there is
--   no information about the closure).
whereFrom# :: a -> State# d -> (# State# d, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <a>getCurrentCCS#</a> being floated out by the simplifier,
--   which would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS# :: a -> State# d -> (# State# d, Addr# #)
getCCSOf# :: a -> State# d -> (# State# d, Addr# #)
getApStackVal# :: a -> Int# -> (# Int#, b #)

-- | <tt><a>closureSize#</a> closure</tt> returns the size of the given
--   closure in machine words.
closureSize# :: a -> Int#

-- | <tt><a>unpackClosure#</a> closure</tt> copies the closure and pointers
--   in the payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | <tt><a>newBCO#</a> instrs lits ptrs arity bitmap</tt> creates a new
--   bytecode object. The resulting object encodes a function of the given
--   arity with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO -> (# a #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   <a>unsafeCoerce#</a>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <a>Addr#</a> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Convert an <a>Addr#</a> to a followable Any type.
addrToAny# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Addr# -> (# a #)
tagToEnum# :: Int# -> a

-- | Evaluates the argument and returns the tag of the result. Tags are
--   Zero-indexed; the first constructor has tag zero.
dataToTag# :: a -> Int#

-- | <tt><a>keepAlive#</a> x s k</tt> keeps the value <tt>x</tt> alive
--   during the execution of the computation <tt>k</tt>.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
keepAlive# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (State# RealWorld -> b) -> b

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# d -> (# State# d, Int# #)
getSpark# :: State# d -> (# State# d, Int#, a #)
seq# :: a -> State# d -> (# State# d, a #)
spark# :: a -> State# d -> (# State# d, a #)
par# :: a -> Int#

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> Int#

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Like <a>compactAdd#</a>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Recursively add a closure and its transitive closure to a
--   <a>Compact#</a> (a CNF), evaluating any unevaluated components at the
--   same time. Note: <a>compactAdd#</a> is not thread-safe, so only one
--   thread may call <a>compactAdd#</a> with a particular <a>Compact#</a>
--   at any given time. The primop does not enforce any mutual exclusion;
--   the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <a>Addr#</a> is a pointer to previous
--   compact block of the CNF or <a>nullAddr#</a> to create a new CNF with
--   a single compact block.
--   
--   The resulting block is not known to the GC until
--   <a>compactFixupPointers#</a> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <a>nullAddr#</a> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
stableNameToInt# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StableName# a -> Int#
makeStableName# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
eqStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
deRefStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
makeStablePtr# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
touch# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). a -> State# RealWorld -> State# RealWorld

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <a>Int#</a> and a (possibly invalid) finalization
--   action. An <a>Int#</a> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
deRefWeak# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)

-- | <tt><a>addCFinalizerToWeak#</a> fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>. <a>addCFinalizerToWeak#</a>
--   returns 1 on success, or 0 if <tt>w</tt> is already dead.
addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE ('BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | <tt><a>mkWeak#</a> k v finalizer s</tt> creates a weak reference to
--   value <tt>k</tt>, with an associated reference to some value
--   <tt>v</tt>. If <tt>k</tt> is still alive then <tt>v</tt> can be
--   retrieved using <a>deRefWeak#</a>. Note that the type of <tt>k</tt>
--   must be represented by a pointer (i.e. of kind <tt><tt>TYPE</tt>
--   '<tt>LiftedRep</tt> or </tt><tt>TYPE</tt> '<tt>UnliftedRep</tt>@).
mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE ('BoxedRep l)) (b :: TYPE ('BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)

-- | Returns an array of the threads started by the program. Note that this
--   threads which have finished execution may or may not be present in
--   this list, depending upon whether they have been collected by the
--   garbage collector.
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)

-- | Get the status of the given thread. Result is <tt>(ThreadStatus,
--   Capability, Locked)</tt> where <tt>ThreadStatus</tt> is one of the
--   status constants defined in <tt>rts/Constants.h</tt>,
--   <tt>Capability</tt> is the number of the capability which currently
--   owns the thread, and <tt>Locked</tt> is a boolean indicating whether
--   the thread is bound to that capability.
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | Get the label of the given thread. Morally of type <tt>ThreadId# -&gt;
--   IO (Maybe ByteArray#)</tt>, with a <tt>1#</tt> tag denoting
--   <tt>Just</tt>.
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
noDuplicate# :: State# d -> State# d
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | Set the label of the given thread. The <tt>ByteArray#</tt> should
--   contain a UTF-8-encoded string.
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
yield# :: State# RealWorld -> State# RealWorld
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
forkOn# :: forall {q :: RuntimeRep} (a :: TYPE q). Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
fork# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# d -> State# d

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# d -> State# d

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# d -> State# d

-- | If <a>IOPort#</a> is full, immediately return with integer 0, throwing
--   an <tt>IOPortException</tt>. Otherwise, store value arg as 'IOPort#''s
--   new contents, and return with integer 1.
writeIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <a>IOPort#</a> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty. Throws an
--   <tt>IOPortException</tt> if another thread is already waiting to read
--   this <a>IOPort#</a>.
readIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)

-- | Create new <a>IOPort#</a>; initially empty.
newIOPort# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, IOPort# d a #)

-- | Return 1 if <a>MVar#</a> is empty; 0 otherwise.
isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>.
tryReadMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | If <a>MVar#</a> is full, immediately return with integer 0. Otherwise,
--   store value arg as 'MVar#''s new contents, and return with integer 1.
tryPutMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)

-- | If <a>MVar#</a> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> a -> State# d -> State# d

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>, and set <a>MVar#</a> empty.
tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then remove and
--   return its contents, and set it empty.
takeMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)

-- | Create new <a>MVar#</a>; initially empty.
newMVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). State# d -> (# State# d, MVar# d a #)

-- | Write contents of <a>TVar#</a>.
writeTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> a -> State# d -> State# d

-- | Read contents of <a>TVar#</a> outside an STM transaction. Does not
--   force evaluation of the result.
readTVarIO# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Read contents of <a>TVar#</a> inside an STM transaction, i.e. within a
--   call to <a>atomically#</a>. Does not force evaluation of the result.
readTVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)

-- | Create a new <a>TVar#</a> holding a specified initial value.
newTVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)
catchSTM# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
catchRetry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
retry# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
atomically# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | See <a>GHC.Prim#continuations</a>.
control0# :: forall {r :: RuntimeRep} a (b :: TYPE r). PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)

-- | See <a>GHC.Prim#continuations</a>.
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | See <a>GHC.Prim#continuations</a>.
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | <tt><tt>unmaskAsyncUninterruptible#</tt> k s</tt> evaluates <tt>k
--   s</tt> such that asynchronous exceptions are unmasked.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
unmaskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>maskUninterruptible#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskUninterruptible# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | <tt><a>maskAsyncExceptions#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
raiseIO# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (# State# RealWorld, b #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseDivZero# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseOverflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseUnderflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raise# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE ('BoxedRep l)) (b :: TYPE r). a -> b

-- | <tt><a>catch#</a> k handler s</tt> evaluates <tt>k s</tt>, invoking
--   <tt>handler</tt> on any exceptions thrown.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
catch# :: forall {q :: RuntimeRep} {k :: Levity} (a :: TYPE q) (b :: TYPE ('BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | Compare-and-swap: perform a pointer equality test between the first
--   value passed to this function and the value stored inside the
--   <a>MutVar#</a>. If the pointers are equal, replace the stored value
--   with the second value passed to this function, otherwise do nothing.
--   Returns the final value stored inside the <a>MutVar#</a>. The
--   <a>Int#</a> indicates whether a swap took place, with <tt>1#</tt>
--   meaning that we didn't swap, and <tt>0#</tt> that we did. Implies a
--   full memory barrier. Because the comparison is done on the level of
--   pointers, all of the difficulties of using
--   <a>reallyUnsafePtrEquality#</a> correctly apply to <a>casMutVar#</a>
--   as well.
casMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar_# :: MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents. Note that this isn't strictly speaking the correct type for
--   this function; it should really be <tt><a>MutVar#</a> s a -&gt; (a
--   -&gt; (a,b)) -&gt; <a>State#</a> s -&gt; (# <a>State#</a> s, a, (a, b)
--   #)</tt>, but we don't know about pairs here.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar2# :: MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)

-- | Write contents of <a>MutVar#</a>.
writeMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> a -> State# d -> State# d

-- | Read contents of <a>MutVar#</a>. Result is not yet evaluated.
readMutVar# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)

-- | Create <a>MutVar#</a> with specified initial value in specified state
--   thread.
newMutVar# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)

-- | Given an address, write a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteWordAddr# :: Addr# -> Word# -> State# d -> State# d

-- | Given an address, read a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadWordAddr# :: Addr# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to XOR, atomically XOR the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to OR, atomically OR the value into the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to NAND, atomically NAND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to AND, atomically AND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to subtract, atomically subtract the
--   value from the element. Returns the value of the element before the
--   operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Given an address, and a value to add, atomically add the value to the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | Compare and swap on a 64 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr64# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)

-- | Compare and swap on a 32 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr32# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)

-- | Compare and swap on a 16 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr16# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)

-- | Compare and swap on a 8 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr8# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)

-- | Compare and swap on a word-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)

-- | Compare and swap on a word-sized memory location.
--   
--   Use as: s -&gt; atomicCasAddrAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   address with the given value. Returns the old value. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeWordAddr# :: Addr# -> Word# -> State# d -> (# State# d, Word# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   first address with the Addr# given as second argument. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# d -> (# State# d, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# d -> State# d

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word64# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int64# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Double# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Float# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Int# #)

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# d -> (# State# d, Char# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32OffAddr# :: Addr# -> Int# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16OffAddr# :: Addr# -> Int# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8OffAddr# :: Addr# -> Int# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64OffAddr# :: Addr# -> Int# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32OffAddr# :: Addr# -> Int# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16OffAddr# :: Addr# -> Int# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8OffAddr# :: Addr# -> Int# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharOffAddr# :: Addr# -> Int# -> Char#
leAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
gtAddr# :: Addr# -> Addr# -> Int#

-- | Coerce directly from int to address.
int2Addr# :: Int# -> Addr#

-- | Coerce directly from address to int.
addr2Int# :: Addr# -> Int#

-- | Return the remainder when the <a>Addr#</a> arg, treated like an
--   <a>Int#</a>, is divided by the <a>Int#</a> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Result is meaningless if two <a>Addr#</a>s are so far apart that their
--   difference doesn't fit in an <a>Int#</a>.
minusAddr# :: Addr# -> Addr# -> Int#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically subtract the value from the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array, an offset in 64 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)

-- | Given an array, an offset in 32 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)

-- | Given an array, an offset in 16 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)

-- | Given an array, an offset in bytes, the expected old value, and the
--   new value, perform an atomic compare and swap i.e. write the new value
--   if the current value matches the provided old value. Returns the value
--   of the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | <tt><a>setByteArray#</a> ba off len c</tt> sets the byte range
--   <tt>[off, off+len)</tt> of the <a>MutableByteArray#</a> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d

-- | Copy a range of the first MutableByteArray# to the specified region in
--   the second MutableByteArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>copyByteArray#</a> src src_ofs dst dst_ofs n</tt> copies the
--   range starting at offset <tt>src_ofs</tt> of length <tt>n</tt> from
--   the <a>ByteArray#</a> <tt>src</tt> to the <a>MutableByteArray#</a>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | <tt><a>compareByteArrays#</a> src1 src1_ofs src2 src2_ofs n</tt>
--   compares <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the
--   first <a>ByteArray#</a> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <a>ByteArray#</a> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <a>Int#</a> less
--   than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | Write a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d

-- | Write a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d

-- | Write a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d

-- | Write a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d

-- | Write a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d

-- | Write a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d

-- | Write a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d

-- | Write a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d

-- | Write a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d

-- | Write a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# d -> Int# -> Double# -> State# d -> State# d

-- | Write a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# d -> Int# -> Float# -> State# d -> State# d

-- | Write a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d

-- | Write a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# d -> Int# -> Word# -> State# d -> State# d

-- | Write a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# d -> Int# -> Int# -> State# d -> State# d

-- | Write a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Write a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# d -> Int# -> Char# -> State# d -> State# d

-- | Read a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)

-- | Read a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)

-- | Read a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)

-- | Read a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)

-- | Read a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)

-- | Read a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)

-- | Read a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)

-- | Read a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)

-- | Read a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)

-- | Read a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)

-- | Read a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)

-- | Read a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)

-- | Read a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)

-- | Read a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)

-- | Read a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)

-- | Read a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#

-- | Read a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#

-- | Read a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#

-- | Read a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#

-- | Read a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#

-- | Read a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#

-- | Read a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32Array# :: ByteArray# -> Int# -> Word32#

-- | Read a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16Array# :: ByteArray# -> Int# -> Word16#

-- | Read a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8Array# :: ByteArray# -> Int# -> Word8#

-- | Read a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64Array# :: ByteArray# -> Int# -> Int64#

-- | Read a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32Array# :: ByteArray# -> Int# -> Int32#

-- | Read a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16Array# :: ByteArray# -> Int# -> Int16#

-- | Read a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8Array# :: ByteArray# -> Int# -> Int8#

-- | Read a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | Read a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | Read a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | Read a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | Read a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | Read a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Return the number of elements in the array.
getSizeofMutableByteArray# :: MutableByteArray# d -> State# d -> (# State# d, Int# #)

-- | Return the size of the array in bytes. Note that this is deprecated as
--   it is unsafe in the presence of shrink and resize operations on the
--   same mutable byte array.
sizeofMutableByteArray# :: MutableByteArray# d -> Int#

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <a>MutableByteArray#</a> is either the original
--   <a>MutableByteArray#</a> resized in-place or, if not possible, a newly
--   allocated (unpinned) <a>MutableByteArray#</a> (with the original
--   content copied over).
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray#</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray#</a> in case a new <a>MutableByteArray#</a> had to
--   be allocated.
resizeMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <a>getSizeofMutableByteArray#</a>.
shrinkMutableByteArray# :: MutableByteArray# d -> Int# -> State# d -> State# d

-- | Intended for use with pinned arrays; otherwise very unsafe!
mutableByteArrayContents# :: MutableByteArray# d -> Addr#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move during
--   GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# d -> Int#

-- | Like <a>newPinnedByteArray#</a> but allow specifying an arbitrary
--   alignment, which must be a power of two.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Like <a>newByteArray#</a> but GC guarantees not to move it.
newPinnedByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread. The size of the memory underlying the array
--   will be rounded up to the platform's word size.
newByteArray# :: Int# -> State# d -> (# State# d, MutableByteArray# d #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <a>casArray#</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int# -> (# a #)

-- | Return the number of elements in the array.
getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)

-- | Return the number of elements in the array. Note that this is
--   deprecated as it is unsafe in the presence of shrink and resize
--   operations on the same small mutable array.
sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int#

-- | Return the number of elements in the array.
sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). SmallArray# a -> Int#

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <a>getSizeofSmallMutableArray#</a>.
shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a boxed value makes this
--   function harder to use correctly than <a>casIntArray#</a>. All of the
--   difficulties of using <a>reallyUnsafePtrEquality#</a> correctly apply
--   to <a>casArray#</a> as well.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> Int# -> Array# a

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int# -> (# a #)

-- | Return the number of elements in the array.
sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int#

-- | Return the number of elements in the array.
sizeofArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)). Array# a -> Int#

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: forall {l :: Levity} d (a :: TYPE ('BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: forall {l :: Levity} (a :: TYPE ('BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)

-- | Convert to integers. First <a>Int#</a> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
float2Double# :: Float# -> Double#
powerFloat# :: Float# -> Float# -> Float#
atanhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#
expFloat# :: Float# -> Float#

-- | Truncates a <a>Float#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
float2Int# :: Float# -> Int#
fabsFloat# :: Float# -> Float#
negateFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
divideFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
plusFloat# :: Float# -> Float# -> Float#
leFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
gtFloat# :: Float# -> Float# -> Int#

-- | Decode <a>Double#</a> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#
atanhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#
expDouble# :: Double# -> Double#
double2Float# :: Double# -> Float#

-- | Truncates a <a>Double#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
double2Int# :: Double# -> Int#
fabsDouble# :: Double# -> Double#
negateDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(>##) :: Double# -> Double# -> Int#
infix 4 >##
narrow32Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow8Word# :: Word# -> Word#
narrow32Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow8Int# :: Int# -> Int#

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word64# -> Word64#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word64# -> Word64#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word64# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word64# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word64# -> Word64# -> Word64#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word64# -> Word64# -> Word64#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#
leWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
word2Int# :: Word# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#
not# :: Word# -> Word#
xor# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
and# :: Word# -> Word# -> Word#

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord# :: Word# -> Word# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
timesWord# :: Word# -> Word# -> Word#
minusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <a>addWordC#</a>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <a>plusWord2#</a>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord# :: Word# -> Word# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Convert an <a>Word#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Double#</a> 1## == 1.0##</tt>
word2Double# :: Word# -> Double#

-- | Convert an <a>Word#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Float#</a> 1## == 1.0#</tt>
word2Float# :: Word# -> Float#

-- | Convert an <a>Int#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Double#</a> 1# == 1.0##</tt>
int2Double# :: Int# -> Double#

-- | Convert an <a>Int#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Float#</a> 1# == 1.0#</tt>
int2Float# :: Int# -> Float#
int2Word# :: Int# -> Word#
chr# :: Int# -> Char#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(>#) :: Int# -> Int# -> Int#
infix 4 >#

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <a>Int#</a>; second member is zero if
--   the true difference fits in an <a>Int#</a>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <a>Int#</a>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <a>Int#</a>; second member is zero if the true sum
--   fits in an <a>Int#</a>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <a>Int#</a>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Unary negation. Since the negative <a>Int#</a> range extends one
--   further than the positive range, <a>negateInt#</a> of the most
--   negative number is an identity operation. This way, <a>negateInt#</a>
--   is always its own inverse.
negateInt# :: Int# -> Int#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)

-- | Satisfies <tt>(<a>quotInt#</a> x y) <a>*#</a> y <a>+#</a>
--   (<a>remInt#</a> x y) == x</tt>. The behavior is undefined if the
--   second argument is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt# :: Int# -> Int# -> Int#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Return a triple (isHighNeeded,high,low) where high and low are
--   respectively the high and low bits of the double-word result.
--   isHighNeeded is a cheap way to test if the high word is a
--   sign-extension of the low word (isHighNeeded = 0#) or not
--   (isHighNeeded = 1#).
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
neWord64# :: Word64# -> Word64# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
eqWord64# :: Word64# -> Word64# -> Int#
word64ToInt64# :: Word64# -> Int64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
not64# :: Word64# -> Word64#
xor64# :: Word64# -> Word64# -> Word64#
or64# :: Word64# -> Word64# -> Word64#
and64# :: Word64# -> Word64# -> Word64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord64# :: Word64# -> Word64# -> Word64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord64# :: Word64# -> Word64# -> Word64#
timesWord64# :: Word64# -> Word64# -> Word64#
subWord64# :: Word64# -> Word64# -> Word64#
plusWord64# :: Word64# -> Word64# -> Word64#
wordToWord64# :: Word# -> Word64#
word64ToWord# :: Word64# -> Word#
neInt64# :: Int64# -> Int64# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
eqInt64# :: Int64# -> Int64# -> Int#
int64ToWord64# :: Int64# -> Word64#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt64# :: Int64# -> Int64# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt64# :: Int64# -> Int64# -> Int64#
timesInt64# :: Int64# -> Int64# -> Int64#
subInt64# :: Int64# -> Int64# -> Int64#
plusInt64# :: Int64# -> Int64# -> Int64#
negateInt64# :: Int64# -> Int64#
intToInt64# :: Int# -> Int64#
int64ToInt# :: Int64# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
eqWord32# :: Word32# -> Word32# -> Int#
word32ToInt32# :: Word32# -> Int32#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
notWord32# :: Word32# -> Word32#
xorWord32# :: Word32# -> Word32# -> Word32#
orWord32# :: Word32# -> Word32# -> Word32#
andWord32# :: Word32# -> Word32# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord32# :: Word32# -> Word32# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord32# :: Word32# -> Word32# -> Word32#
timesWord32# :: Word32# -> Word32# -> Word32#
subWord32# :: Word32# -> Word32# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
wordToWord32# :: Word# -> Word32#
word32ToWord# :: Word32# -> Word#
neInt32# :: Int32# -> Int32# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
eqInt32# :: Int32# -> Int32# -> Int#
int32ToWord32# :: Int32# -> Word32#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt32# :: Int32# -> Int32# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt32# :: Int32# -> Int32# -> Int32#
timesInt32# :: Int32# -> Int32# -> Int32#
subInt32# :: Int32# -> Int32# -> Int32#
plusInt32# :: Int32# -> Int32# -> Int32#
negateInt32# :: Int32# -> Int32#
intToInt32# :: Int# -> Int32#
int32ToInt# :: Int32# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
eqWord16# :: Word16# -> Word16# -> Int#
word16ToInt16# :: Word16# -> Int16#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
notWord16# :: Word16# -> Word16#
xorWord16# :: Word16# -> Word16# -> Word16#
orWord16# :: Word16# -> Word16# -> Word16#
andWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
wordToWord16# :: Word# -> Word16#
word16ToWord# :: Word16# -> Word#
neInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
eqInt16# :: Int16# -> Int16# -> Int#
int16ToWord16# :: Int16# -> Word16#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
negateInt16# :: Int16# -> Int16#
intToInt16# :: Int# -> Int16#
int16ToInt# :: Int16# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
eqWord8# :: Word8# -> Word8# -> Int#
word8ToInt8# :: Word8# -> Int8#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
notWord8# :: Word8# -> Word8#
xorWord8# :: Word8# -> Word8# -> Word8#
orWord8# :: Word8# -> Word8# -> Word8#
andWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
wordToWord8# :: Word# -> Word8#
word8ToWord# :: Word8# -> Word#
neInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
eqInt8# :: Int8# -> Int8# -> Int#
int8ToWord8# :: Int8# -> Word8#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
negateInt8# :: Int8# -> Int8#
intToInt8# :: Int# -> Int8#
int8ToInt# :: Int8# -> Int#
ord# :: Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
gtChar# :: Char# -> Char# -> Int#
rightSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {s :: RuntimeRep} {n :: Multiplicity} {o :: Multiplicity} (a :: TYPE q) (b :: TYPE r) (c :: TYPE s). (a %n -> b %o -> c) -> b %o -> a %n -> c
leftSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {n :: Multiplicity} (a :: TYPE q) (b :: TYPE r). (a %n -> b) -> a %n -> b

-- | Witness for an unboxed <a>Proxy#</a> value, which has no runtime
--   representation.
proxy# :: forall {k} (a :: k). Proxy# a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | The null address.
nullAddr# :: Addr#

-- | This is an alias for the unboxed unit tuple constructor. In earlier
--   versions of GHC, <a>void#</a> was a value of the primitive type
--   <tt>Void#</tt>, which is now defined to be <tt>(# #)</tt>.
void# :: (# #)

-- | The token used in the implementation of the IO monad as a state monad.
--   It does not pass any information at runtime. See also <a>runRW#</a>.
realWorld# :: State# RealWorld

-- | Apply a function to a <tt><a>State#</a> <a>RealWorld</a></tt> token.
--   When manually applying a function to <a>realWorld#</a>, it is
--   necessary to use <tt>NOINLINE</tt> to prevent semantically undesirable
--   floating. <a>runRW#</a> is inlined, but only very late in compilation
--   after all floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
shiftL# :: Word# -> Int# -> Word#

-- | Shift the argument right by the specified number of bits (which must
--   be non-negative). The <a>RL</a> means "right, logical" (as opposed to
--   RA for arithmetic) (although an arithmetic right shift wouldn't make
--   sense for Word#)
shiftRL# :: Word# -> Int# -> Word#

-- | Shift the argument left by the specified number of bits (which must be
--   non-negative).
iShiftL# :: Int# -> Int# -> Int#

-- | Shift the argument right (signed) by the specified number of bits
--   (which must be non-negative). The <a>RA</a> means "right, arithmetic"
--   (as opposed to RL for logical)
iShiftRA# :: Int# -> Int# -> Int#

-- | Shift the argument right (unsigned) by the specified number of bits
--   (which must be non-negative). The <a>RL</a> means "right, logical" (as
--   opposed to RA for arithmetic)
iShiftRL# :: Int# -> Int# -> Int#

-- | Compare the underlying pointers of two values for equality.
--   
--   Returns <tt>1</tt> if the pointers are equal and <tt>0</tt> otherwise.
--   
--   The two values must be of the same type, of kind <tt>Type</tt>. See
--   also <a>reallyUnsafePtrEquality#</a>, which doesn't have such
--   restrictions.
reallyUnsafePtrEquality :: a -> a -> Int#

-- | Compare the underlying pointers of two unlifted values for equality.
--   
--   This is less dangerous than <a>reallyUnsafePtrEquality</a>, since the
--   arguments are guaranteed to be evaluated. This means there is no risk
--   of accidentally comparing a thunk. It's however still more dangerous
--   than e.g. <a>sameArray#</a>.
unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#

-- | Compare two stable names for equality.
eqStableName# :: StableName# a -> StableName# b -> Int#

-- | Compare the underlying pointers of two arrays.
sameArray# :: Array# a -> Array# a -> Int#

-- | Compare the underlying pointers of two mutable arrays.
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#

-- | Compare the underlying pointers of two small arrays.
sameSmallArray# :: SmallArray# a -> SmallArray# a -> Int#

-- | Compare the underlying pointers of two small mutable arrays.
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Compare the pointers of two byte arrays.
sameByteArray# :: ByteArray# -> ByteArray# -> Int#

-- | Compare the underlying pointers of two mutable byte arrays.
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Compare the underlying pointers of two <a>MVar#</a>s.
sameMVar# :: MVar# s a -> MVar# s a -> Int#

-- | Compare the underlying pointers of two <a>MutVar#</a>s.
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#

-- | Compare the underlying pointers of two <a>TVar#</a>s.
sameTVar# :: TVar# s a -> TVar# s a -> Int#

-- | Compare the underlying pointers of two <a>IOPort#</a>s.
sameIOPort# :: IOPort# s a -> IOPort# s a -> Int#

-- | Compare the underlying pointers of two <a>PromptTag#</a>s.
samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#

-- | An implementation of the old <tt>atomicModifyMutVar#</tt> primop in
--   terms of the new <a>atomicModifyMutVar2#</a> primop, for backwards
--   compatibility. The type of this function is a bit bogus. It's best to
--   think of it as having type
--   
--   <pre>
--   atomicModifyMutVar#
--     :: MutVar# s a
--     -&gt; (a -&gt; (a, b))
--     -&gt; State# s
--     -&gt; (# State# s, b #)
--   </pre>
--   
--   but there may be code that uses this with other two-field record
--   types.
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)

-- | Resize a mutable array to new specified size. The returned
--   <a>SmallMutableArray#</a> is either the original
--   <a>SmallMutableArray#</a> resized in-place or, if not possible, a
--   newly allocated <a>SmallMutableArray#</a> with the original content
--   copied over.
--   
--   To avoid undefined behaviour, the original <a>SmallMutableArray#</a>
--   shall not be accessed anymore after a <a>resizeSmallMutableArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>SmallMutableArray#</a> in case a new <a>SmallMutableArray#</a> had
--   to be allocated.
resizeSmallMutableArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   build g = g (:) []
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>build</a> g)</tt>, which may arise after
--   inlining, to <tt>g k z</tt>, which avoids producing an intermediate
--   list.
build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]

-- | A list producer that can be fused with <a>foldr</a>. This function is
--   merely
--   
--   <pre>
--   augment g xs = g (:) xs
--   </pre>
--   
--   but GHC's simplifier will transform an expression of the form
--   <tt><a>foldr</a> k z (<a>augment</a> g xs)</tt>, which may arise after
--   inlining, to <tt>g k (<a>foldr</a> k z xs)</tt>, which avoids
--   producing an intermediate list.
augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l where {
    
    -- | The <a>Item</a> type function returns the type of items of the
    --   structure <tt>l</tt>.
    type Item l;
}

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length and
--   potentially uses it to construct the structure <tt>l</tt> more
--   efficiently compared to <a>fromList</a>. If the given number does not
--   equal to the input list's length the behaviour of <a>fromListN</a> is
--   not specified.
--   
--   <pre>
--   fromListN (length xs) xs == fromList xs
--   </pre>
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>toList</a> function extracts a list of <tt>Item l</tt> from the
--   structure <tt>l</tt>. It should satisfy fromList . toList = id.
toList :: IsList l => l -> [Item l]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>).
--   
--   If <tt>a</tt> has an <tt><a>Ord</a></tt> instance associated with it
--   then comparing two values thus wrapped will give you the opposite of
--   their normal sort order. This is particularly useful when sorting in
--   generalised list comprehensions, as in: <tt>then sortWith by
--   <a>Down</a> x</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; compare True False
--   GT
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; compare (Down True) (Down False)
--   LT
--   </pre>
--   
--   If <tt>a</tt> has a <tt><a>Bounded</a></tt> instance then the wrapped
--   instance also respects the reversed ordering by exchanging the values
--   of <tt><a>minBound</a></tt> and <tt><a>maxBound</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Int
--   -9223372036854775808
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: Down Int
--   Down 9223372036854775807
--   </pre>
--   
--   All other instances of <tt><a>Down</a> a</tt> behave as they do for
--   <tt>a</tt>.
newtype Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | The <a>groupWith</a> function uses the user supplied function which
--   projects an element out of every list element in order to first sort
--   the input list and then to form groups by equality on these projected
--   elements
groupWith :: Ord b => (a -> b) -> [a] -> [[a]]

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
--   
--   In general if the user supplied function is expensive to compute then
--   you should probably be using <a>sortOn</a>, as it only needs to
--   compute it once for each element. <a>sortWith</a>, on the other hand
--   must compute the mapping function for every comparison that it
--   performs.
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | <a>the</a> ensures that all the elements of the list are identical and
--   then returns that unique element
the :: Eq a => [a] -> a

-- | <a>IsString</a> is used in combination with the
--   <tt>-XOverloadedStrings</tt> language extension to convert the
--   literals to different string types.
--   
--   For example, if you use the <a>text</a> package, you can say
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings  #-}
--   
--   myText = "hello world" :: Text
--   </pre>
--   
--   Internally, the extension will convert this to the equivalent of
--   
--   <pre>
--   myText = fromString @Text ("hello world" :: String)
--   </pre>
--   
--   <b>Note:</b> You can use <tt>fromString</tt> in normal code as well,
--   but the usual performance/memory efficiency problems with
--   <a>String</a> apply.
class IsString a
fromString :: IsString a => String -> a
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]

-- | Compute the length of a NUL-terminated string. This address must refer
--   to immutable memory. GHC includes a built-in rule for constant folding
--   when the argument is a statically-known literal. That is, a
--   core-to-core pass reduces the expression <tt>cstringLength#
--   "hello"#</tt> to the constant <tt>5#</tt>.
cstringLength# :: Addr# -> Int#
breakpoint :: a -> a
breakpointCond :: Bool -> a -> a

-- | <i>Deprecated: Use <a>traceEvent</a> or <a>traceEventIO</a></i>
traceEvent :: String -> IO ()

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <a>par</a> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <a>par</a>.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation-polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Semantically, <tt>considerAccessible = True</tt>. But it has special
--   meaning to the pattern-match checker, which will never flag the clause
--   in which <a>considerAccessible</a> occurs as a guard as redundant or
--   inaccessible. Example:
--   
--   <pre>
--   case (x, x) of
--     (True,  True)  -&gt; 1
--     (False, False) -&gt; 2
--     (True,  False) -&gt; 3 -- Warning: redundant
--   </pre>
--   
--   The pattern-match checker will warn here that the third clause is
--   redundant. It will stop doing so if the clause is adorned with
--   <a>considerAccessible</a>:
--   
--   <pre>
--   case (x, x) of
--     (True,  True)  -&gt; 1
--     (False, False) -&gt; 2
--     (True,  False) | considerAccessible -&gt; 3 -- No warning
--   </pre>
--   
--   Put <a>considerAccessible</a> as the last statement of the guard to
--   avoid get confusing results from the pattern-match checker, which
--   takes "consider accessible" by word.
considerAccessible :: Bool
data SpecConstrAnnotation
NoSpecConstr :: SpecConstrAnnotation
ForceSpecConstr :: SpecConstrAnnotation

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data () => SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | Highly, terribly dangerous coercion from one representation type to
--   another. Misuse of this function can invite the garbage collector to
--   trounce upon your data and then laugh in your face. You don't want
--   this function. Really.
unsafeCoerce# :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep) (a :: TYPE r1) (b :: TYPE r2). a -> b

-- | The constraint <tt><a>WithDict</a> cls meth</tt> can be solved when
--   evidence for the constraint <tt>cls</tt> can be provided in the form
--   of a dictionary of type <tt>meth</tt>. This requires <tt>cls</tt> to
--   be a class constraint whose single method has type <tt>meth</tt>.
--   
--   For more (important) details on how this works, see <tt>Note
--   [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC.
class () => WithDict cls meth
withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). WithDict cls meth => meth -> (cls => r) -> r
maxTupleSize :: Int
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation


-- | This module exposes an interface for capturing the state of a thread's
--   execution stack for diagnostics purposes: <a>cloneMyStack</a>,
--   <a>cloneThreadStack</a>.
--   
--   Such a "cloned" stack can be decoded with <a>decode</a> to a stack
--   trace, given that the <tt>-finfo-table-map</tt> is enabled.
module GHC.Stack.CloneStack

-- | A frozen snapshot of the state of an execution stack.
data StackSnapshot
StackSnapshot :: !StackSnapshot# -> StackSnapshot

-- | Representation for the source location where a return frame was pushed
--   on the stack. This happens every time when a <tt>case ... of</tt>
--   scrutinee is evaluated.
data StackEntry
StackEntry :: String -> String -> String -> Word -> StackEntry
[functionName] :: StackEntry -> String
[moduleName] :: StackEntry -> String
[srcLoc] :: StackEntry -> String
[closureType] :: StackEntry -> Word

-- | Clone the stack of the executing thread
cloneMyStack :: IO StackSnapshot

-- | Clone the stack of a thread identified by its <a>ThreadId</a>
cloneThreadStack :: ThreadId -> IO StackSnapshot

-- | Decode a <a>StackSnapshot</a> to a stacktrace (a list of
--   <a>StackEntry</a>). The stack trace is created from return frames with
--   according <a>InfoProvEnt</a> entries. To generate them, use the GHC
--   flag <tt>-finfo-table-map</tt>. If there are no <a>InfoProvEnt</a>
--   entries, an empty list is returned.
--   
--   Please note:
--   
--   <ul>
--   <li>To gather <a>StackEntry</a> from libraries, these have to be
--   compiled with <tt>-finfo-table-map</tt>, too.</li>
--   <li>Due to optimizations by GHC (e.g. inlining) the stacktrace may
--   change with different GHC parameters and versions.</li>
--   <li>The stack trace is empty (by design) if there are no return frames
--   on the stack. (These are pushed every time when a <tt>case ... of</tt>
--   scrutinee is evaluated.)</li>
--   </ul>
decode :: StackSnapshot -> IO [StackEntry]
instance GHC.Classes.Eq GHC.Stack.CloneStack.StackEntry
instance GHC.Show.Show GHC.Stack.CloneStack.StackEntry


-- | Support code for desugaring in GHC
module GHC.Desugar
(>>>) :: forall arr. Arrow arr => forall a b c. arr a b -> arr b c -> arr a c
data AnnotationWrapper
AnnotationWrapper :: a -> AnnotationWrapper
toAnnotationWrapper :: Data a => a -> AnnotationWrapper


-- | A type <tt>a</tt> is a <a>Semigroup</a> if it provides an associative
--   function (<a>&lt;&gt;</a>) that lets you combine any two values of
--   type <tt>a</tt> into one. Where being associative means that the
--   following must always hold:
--   
--   <pre>
--   (a &lt;&gt; b) &lt;&gt; c == a &lt;&gt; (b &lt;&gt; c)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>Min</a> <a>Semigroup</a> instance for <a>Int</a> is defined to
--   always pick the smaller number:
--   
--   <pre>
--   &gt;&gt;&gt; Min 1 &lt;&gt; Min 2 &lt;&gt; Min 3 &lt;&gt; Min 4 :: Min Int
--   Min {getMin = 1}
--   </pre>
--   
--   If we need to combine multiple values we can use the <a>sconcat</a>
--   function to do so. We need to ensure however that we have at least one
--   value to operate on, since otherwise our result would be undefined. It
--   is for this reason that <a>sconcat</a> uses
--   <a>Data.List.NonEmpty.NonEmpty</a> - a list that can never be empty:
--   
--   <pre>
--   &gt;&gt;&gt; (1 :| [])
--   1 :| []               -- equivalent to [1] but guaranteed to be non-empty.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1 :| [2, 3, 4])
--   1 :| [2,3,4]          -- equivalent to [1,2,3,4] but guaranteed to be non-empty.
--   </pre>
--   
--   Equipped with this guaranteed to be non-empty data structure, we can
--   combine values using <a>sconcat</a> and a <a>Semigroup</a> of our
--   choosing. We can try the <a>Min</a> and <a>Max</a> instances of
--   <a>Int</a> which pick the smallest, or largest number respectively:
--   
--   <pre>
--   &gt;&gt;&gt; sconcat (1 :| [2, 3, 4]) :: Min Int
--   Min {getMin = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat (1 :| [2, 3, 4]) :: Max Int
--   Max {getMax = 4}
--   </pre>
--   
--   String concatenation is another example of a <a>Semigroup</a>
--   instance:
--   
--   <pre>
--   &gt;&gt;&gt; "foo" &lt;&gt; "bar"
--   "foobar"
--   </pre>
--   
--   A <a>Semigroup</a> is a generalization of a <a>Monoid</a>. Yet unlike
--   the <a>Semigroup</a>, the <a>Monoid</a> requires the presence of a
--   neutral element (<a>mempty</a>) in addition to the associative
--   operator. The requirement for a neutral element prevents many types
--   from being a full Monoid, like <a>Data.List.NonEmpty.NonEmpty</a>.
--   
--   Note that the use of <tt>(&lt;&gt;)</tt> in this module conflicts with
--   an operator with the same name that is being exported by
--   <a>Data.Monoid</a>. However, this package re-exports (most of) the
--   contents of Data.Monoid, so to use semigroups and monoids in the same
--   package just
--   
--   <pre>
--   import Data.Semigroup
--   </pre>
module Data.Semigroup

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   In many cases, <tt><a>stimes</a> 0 a</tt> for a <a>Monoid</a> will
--   produce <a>mempty</a>. However, there are situations when it cannot do
--   so. In particular, the following situation is fairly common:
--   
--   <pre>
--   data T a = ...
--   
--   class Constraint1 a
--   class Constraint1 a =&gt; Constraint2 a
--   </pre>
--   
--   <pre>
--   instance Constraint1 a =&gt; <a>Semigroup</a> (T a)
--   instance Constraint2 a =&gt; <a>Monoid</a> (T a)
--   </pre>
--   
--   Since <tt>Constraint1</tt> is insufficient to implement <a>mempty</a>,
--   <a>stimes</a> for <tt>T a</tt> cannot do so.
--   
--   When working with such a type, or when working polymorphically with
--   <a>Semigroup</a> instances, <tt>mtimesDefault</tt> should be used when
--   the multiplier might be zero. It is implemented using <a>stimes</a>
--   when the multiplier is nonzero and <a>mempty</a> when it is zero.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 0 "bark"
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 3 "meow"
--   "meowmeowmeow"
--   </pre>
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | The <a>Min</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   smaller element as by the <a>Ord</a> instance and <a>min</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min 42 &lt;&gt; Min 3
--   Min 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Min 1 :| [ Min n | n &lt;- [2 .. 100]]
--   Min {getMin = 1}
--   </pre>
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a

-- | The <a>Max</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   bigger element as by the <a>Ord</a> instance and <a>max</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max 42 &lt;&gt; Max 3
--   Max 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Max 1 :| [ Max n | n &lt;- [2 .. 100]]
--   Max {getMax = 100}
--   </pre>
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>First</a> is different from
--   <tt>Data.Monoid.</tt><a>First</a>. The former simply returns the first
--   value, so <tt>Data.Semigroup.First Nothing &lt;&gt; x =
--   Data.Semigroup.First Nothing</tt>. The latter returns the first
--   non-<a>Nothing</a>, thus <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First 0 &lt;&gt; First 10
--   First 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ First 1 :| [ First n | n &lt;- [2 ..] ]
--   First 1
--   </pre>
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>Last</a> is different from
--   <tt>Data.Monoid.</tt><a>Last</a>. The former simply returns the last
--   value, so <tt>x &lt;&gt; Data.Semigroup.Last Nothing =
--   Data.Semigroup.Last Nothing</tt>. The latter returns the last
--   non-<a>Nothing</a>, thus <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last 0 &lt;&gt; Last 10
--   Last {getLast = 10}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Last 1 :| [ Last n | n &lt;- [2..]]
--   Last {getLast = * hangs forever *
--   </pre>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   let hello = diff "Hello, "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo hello "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; mempty) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (mempty &lt;&gt; hello) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   let world = diff "World"
--   let excl = diff "!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; (world &lt;&gt; excl)) mempty
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo ((hello &lt;&gt; world) &lt;&gt; excl) mempty
--   "Hello, World!"
--   </pre>
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ cycle1 [1, 2, 3]
--   [1,2,3,1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Right 1)
--   Right 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Left 1)
--   * hangs forever *
--   </pre>
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (x * x) x | x &lt;- [-10 .. 10] ]
--   Arg 0 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg 3.8 4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg (-34.0) (-10.0)
--   </pre>
data Arg a b
Arg :: a -> b -> Arg a b

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min (Arg 0 ()) &lt;&gt; Min (Arg 1 ())
--   Min {getMin = Arg 0 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 3 "lea"
--   </pre>
type ArgMin a b = Min (Arg a b)

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max (Arg 0 ()) &lt;&gt; Max (Arg 1 ())
--   Max {getMax = Arg 1 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 9 "violencia"
--   </pre>
type ArgMax a b = Max (Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.Min
instance GHC.Generics.Generic (Data.Semigroup.Min a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a)
instance GHC.Generics.Generic1 Data.Semigroup.Max
instance GHC.Generics.Generic (Data.Semigroup.Max a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a)
instance GHC.Generics.Generic1 (Data.Semigroup.Arg a)
instance GHC.Generics.Generic (Data.Semigroup.Arg a b)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b)
instance GHC.Generics.Generic1 Data.Semigroup.First
instance GHC.Generics.Generic (Data.Semigroup.First a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a)
instance GHC.Generics.Generic1 Data.Semigroup.Last
instance GHC.Generics.Generic (Data.Semigroup.Last a)
instance Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a)
instance GHC.Generics.Generic1 Data.Semigroup.WrappedMonoid
instance GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m)
instance Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m)
instance GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m)
instance GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Bounded m => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m)
instance GHC.Base.Monoid m => GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m)
instance GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a)
instance GHC.Base.Semigroup (Data.Semigroup.Last a)
instance GHC.Base.Functor Data.Semigroup.Last
instance Data.Foldable.Foldable Data.Semigroup.Last
instance Data.Traversable.Traversable Data.Semigroup.Last
instance GHC.Base.Applicative Data.Semigroup.Last
instance GHC.Base.Monad Data.Semigroup.Last
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a)
instance GHC.Base.Semigroup (Data.Semigroup.First a)
instance GHC.Base.Functor Data.Semigroup.First
instance Data.Foldable.Foldable Data.Semigroup.First
instance Data.Traversable.Traversable Data.Semigroup.First
instance GHC.Base.Applicative Data.Semigroup.First
instance GHC.Base.Monad Data.Semigroup.First
instance Control.Monad.Fix.MonadFix Data.Semigroup.First
instance GHC.Base.Functor (Data.Semigroup.Arg a)
instance Data.Foldable.Foldable (Data.Semigroup.Arg a)
instance Data.Traversable.Traversable (Data.Semigroup.Arg a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b)
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Max a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a)
instance GHC.Base.Functor Data.Semigroup.Max
instance Data.Foldable.Foldable Data.Semigroup.Max
instance Data.Traversable.Traversable Data.Semigroup.Max
instance GHC.Base.Applicative Data.Semigroup.Max
instance GHC.Base.Monad Data.Semigroup.Max
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Min a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a)
instance GHC.Base.Functor Data.Semigroup.Min
instance Data.Foldable.Foldable Data.Semigroup.Min
instance Data.Traversable.Traversable Data.Semigroup.Min
instance GHC.Base.Applicative Data.Semigroup.Min
instance GHC.Base.Monad Data.Semigroup.Min
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min
instance GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a)


module Data.Bifoldable1
class Bifoldable t => Bifoldable1 t
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bifoldable1.Bifoldable1 Data.Semigroup.Arg
instance Data.Bifoldable1.Bifoldable1 Data.Either.Either
instance Data.Bifoldable1.Bifoldable1 (,)
instance Data.Bifoldable1.Bifoldable1 ((,,) x)
instance Data.Bifoldable1.Bifoldable1 ((,,,) x y)
instance Data.Bifoldable1.Bifoldable1 ((,,,,) x y z)
instance Data.Bifoldable1.Bifoldable1 Data.Functor.Const.Const


-- | This module defines a "Fixed" type for fixed-precision arithmetic. The
--   parameter to <a>Fixed</a> is any type that's an instance of
--   <a>HasResolution</a>. <a>HasResolution</a> has a single method that
--   gives the resolution of the <a>Fixed</a> type.
--   
--   This module also contains generalisations of <a>div</a>, <a>mod</a>,
--   and <a>divMod</a> to work with any <a>Real</a> instance.
module Data.Fixed

-- | Generalisation of <a>div</a> to any instance of <a>Real</a>
div' :: (Real a, Integral b) => a -> a -> b

-- | Generalisation of <a>mod</a> to any instance of <a>Real</a>
mod' :: Real a => a -> a -> a

-- | Generalisation of <a>divMod</a> to any instance of <a>Real</a>
divMod' :: (Real a, Integral b) => a -> a -> (b, a)

-- | The type parameter should be an instance of <a>HasResolution</a>.
newtype Fixed (a :: k)
MkFixed :: Integer -> Fixed (a :: k)
class HasResolution (a :: k)
resolution :: HasResolution a => p a -> Integer

-- | First arg is whether to chop off trailing zeros
showFixed :: HasResolution a => Bool -> Fixed a -> String
data E0

-- | resolution of 1, this works the same as Integer
type Uni = Fixed E0
data E1

-- | resolution of 10^-1 = .1
type Deci = Fixed E1
data E2

-- | resolution of 10^-2 = .01, useful for many monetary currencies
type Centi = Fixed E2
data E3

-- | resolution of 10^-3 = .001
type Milli = Fixed E3
data E6

-- | resolution of 10^-6 = .000001
type Micro = Fixed E6
data E9

-- | resolution of 10^-9 = .000000001
type Nano = Fixed E9
data E12

-- | resolution of 10^-12 = .000000000001
type Pico = Fixed E12
instance forall k (a :: k). GHC.Classes.Ord (Data.Fixed.Fixed a)
instance forall k (a :: k). GHC.Classes.Eq (Data.Fixed.Fixed a)
instance Data.Fixed.HasResolution Data.Fixed.E12
instance Data.Fixed.HasResolution Data.Fixed.E9
instance Data.Fixed.HasResolution Data.Fixed.E6
instance Data.Fixed.HasResolution Data.Fixed.E3
instance Data.Fixed.HasResolution Data.Fixed.E2
instance Data.Fixed.HasResolution Data.Fixed.E1
instance Data.Fixed.HasResolution Data.Fixed.E0
instance GHC.TypeNats.KnownNat n => Data.Fixed.HasResolution n
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a)
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a)
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a)
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a)
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a)
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a)
instance forall k (a :: k). (Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable a) => Data.Data.Data (Data.Fixed.Fixed a)
instance forall k (a :: k). GHC.Enum.Enum (Data.Fixed.Fixed a)


-- | Complex numbers.
module Data.Complex

-- | A data type representing complex numbers.
--   
--   You can read about complex numbers <a>on wikipedia</a>.
--   
--   In haskell, complex numbers are represented as <tt>a :+ b</tt> which
--   can be thought of as representing &lt;math&gt;. For a complex number
--   <tt>z</tt>, <tt><a>abs</a> z</tt> is a number with the
--   <a>magnitude</a> of <tt>z</tt>, but oriented in the positive real
--   direction, whereas <tt><a>signum</a> z</tt> has the <a>phase</a> of
--   <tt>z</tt>, but unit <a>magnitude</a>. Apart from the loss of
--   precision due to IEEE754 floating point numbers, it holds that <tt>z
--   == <a>abs</a> z * <a>signum</a> z</tt>.
--   
--   Note that <a>Complex</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Complex Float</tt>'s <a>Ord</a>
--   instance has similar problems to <a>Float</a>'s.
--   
--   As can be seen in the examples, the <a>Foldable</a> and
--   <a>Traversable</a> instances traverse the real part first.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; (5.0 :+ 2.5) + 6.5
--   11.5 :+ 2.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abs (1.0 :+ 1.0) - sqrt 2.0
--   0.0 :+ 0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abs (signum (4.0 :+ 3.0))
--   1.0 :+ 0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (:) [] (1 :+ 2)
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapM print (1 :+ 2)
--   1
--   2
--   </pre>
data Complex a

-- | forms a complex number from its real and imaginary rectangular
--   components.
(:+) :: !a -> !a -> Complex a
infix 6 :+

-- | Extracts the real part of a complex number.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; realPart (5.0 :+ 3.0)
--   5.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; realPart ((5.0 :+ 3.0) * (2.0 :+ 3.0))
--   1.0
--   </pre>
realPart :: Complex a -> a

-- | Extracts the imaginary part of a complex number.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; imagPart (5.0 :+ 3.0)
--   3.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; imagPart ((5.0 :+ 3.0) * (2.0 :+ 3.0))
--   21.0
--   </pre>
imagPart :: Complex a -> a

-- | Form a complex number from <a>polar</a> components of <a>magnitude</a>
--   and <a>phase</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; mkPolar 1 (pi / 4)
--   0.7071067811865476 :+ 0.7071067811865475
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkPolar 1 0
--   1.0 :+ 0.0
--   </pre>
mkPolar :: Floating a => a -> a -> Complex a

-- | <tt><a>cis</a> t</tt> is a complex value with <a>magnitude</a>
--   <tt>1</tt> and <a>phase</a> <tt>t</tt> (modulo <tt>2*<a>pi</a></tt>).
--   
--   <pre>
--   <a>cis</a> = <a>mkPolar</a> 1
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; cis 0
--   1.0 :+ 0.0
--   </pre>
--   
--   The following examples are not perfectly zero due to <a>IEEE 754</a>
--   
--   <pre>
--   &gt;&gt;&gt; cis pi
--   (-1.0) :+ 1.2246467991473532e-16
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cis (4 * pi) - cis (2 * pi)
--   0.0 :+ (-2.4492935982947064e-16)
--   </pre>
cis :: Floating a => a -> Complex a

-- | The function <a>polar</a> takes a complex number and returns a
--   (<a>magnitude</a>, <a>phase</a>) pair in canonical form: the
--   <a>magnitude</a> is non-negative, and the <a>phase</a> in the range
--   <tt>(-<a>pi</a>, <a>pi</a>]</tt>; if the <a>magnitude</a> is zero,
--   then so is the <a>phase</a>.
--   
--   <pre>
--   <a>polar</a> z = (<a>magnitude</a> z, <a>phase</a> z)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; polar (1.0 :+ 1.0)
--   (1.4142135623730951,0.7853981633974483)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; polar ((-1.0) :+ 0.0)
--   (1.0,3.141592653589793)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; polar (0.0 :+ 0.0)
--   (0.0,0.0)
--   </pre>
polar :: RealFloat a => Complex a -> (a, a)

-- | The non-negative <a>magnitude</a> of a complex number.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1.0 :+ 1.0)
--   1.4142135623730951
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1.0 + 0.0)
--   1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (0.0 :+ (-5.0))
--   5.0
--   </pre>
magnitude :: RealFloat a => Complex a -> a

-- | The <a>phase</a> of a complex number, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>. If the <a>magnitude</a> is zero, then so is the
--   <a>phase</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; phase (0.5 :+ 0.5) / pi
--   0.25
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; phase (0 :+ 4) / pi
--   0.5
--   </pre>
phase :: RealFloat a => Complex a -> a

-- | The <a>conjugate</a> of a complex number.
--   
--   <pre>
--   conjugate (conjugate x) = x
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; conjugate (3.0 :+ 3.0)
--   3.0 :+ (-3.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; conjugate ((3.0 :+ 3.0) * (2.0 :+ 2.0))
--   0.0 :+ (-12.0)
--   </pre>
conjugate :: Num a => Complex a -> Complex a
instance Data.Traversable.Traversable Data.Complex.Complex
instance Data.Foldable.Foldable Data.Complex.Complex
instance GHC.Base.Functor Data.Complex.Complex
instance GHC.Generics.Generic1 Data.Complex.Complex
instance GHC.Generics.Generic (Data.Complex.Complex a)
instance Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a)
instance Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a)
instance GHC.Base.Applicative Data.Complex.Complex
instance GHC.Base.Monad Data.Complex.Complex
instance Control.Monad.Zip.MonadZip Data.Complex.Complex
instance Control.Monad.Fix.MonadFix Data.Complex.Complex


-- | Liftings of the Prelude classes <a>Eq</a>, <a>Ord</a>, <a>Read</a> and
--   <a>Show</a> to unary and binary type constructors.
--   
--   These classes are needed to express the constraints on arguments of
--   transformers in portable Haskell. Thus for a new transformer
--   <tt>T</tt>, one might write instances like
--   
--   <pre>
--   instance (Eq1 f) =&gt; Eq1 (T f) where ...
--   instance (Ord1 f) =&gt; Ord1 (T f) where ...
--   instance (Read1 f) =&gt; Read1 (T f) where ...
--   instance (Show1 f) =&gt; Show1 (T f) where ...
--   </pre>
--   
--   If these instances can be defined, defining instances of the base
--   classes is mechanical:
--   
--   <pre>
--   instance (Eq1 f, Eq a) =&gt; Eq (T f a) where (==) = eq1
--   instance (Ord1 f, Ord a) =&gt; Ord (T f a) where compare = compare1
--   instance (Read1 f, Read a) =&gt; Read (T f a) where
--     readPrec     = readPrec1
--     readListPrec = readListPrecDefault
--   instance (Show1 f, Show a) =&gt; Show (T f a) where showsPrec = showsPrec1
--   </pre>
module Data.Functor.Classes

-- | Lifting of the <a>Eq</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftEq (==)</tt> = <tt>(==)</tt>
--   
--   This class therefore represents the generalization of <a>Eq</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class (forall a. Eq a => Eq (f a)) => Eq1 f

-- | Lift an equality test through the type constructor.
--   
--   The function will usually be applied to an equality function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftEq :: Eq1 f => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Lift an equality test through the type constructor.
--   
--   The function will usually be applied to an equality function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftEq :: (Eq1 f, f ~ f' c, Eq2 f', Eq c) => (a -> b -> Bool) -> f a -> f b -> Bool

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq1 :: (Eq1 f, Eq a) => f a -> f a -> Bool

-- | Lifting of the <a>Ord</a> class to unary type constructors.
--   
--   Any instance should be subject to the following law that canonicity is
--   preserved:
--   
--   <tt>liftCompare compare</tt> = <a>compare</a>
--   
--   This class therefore represents the generalization of <a>Ord</a> by
--   decomposing its main method into a canonical lifting on a canonical
--   inner method, so that the lifting can be reused for other arguments
--   than the canonical one.
class (Eq1 f, forall a. Ord a => Ord (f a)) => Ord1 f

-- | Lift a <a>compare</a> function through the type constructor.
--   
--   The function will usually be applied to a comparison function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftCompare :: Ord1 f => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Lift a <a>compare</a> function through the type constructor.
--   
--   The function will usually be applied to a comparison function, but the
--   more general type ensures that the implementation uses it to compare
--   elements of the first container with elements of the second.
liftCompare :: (Ord1 f, f ~ f' c, Ord2 f', Ord c) => (a -> b -> Ordering) -> f a -> f b -> Ordering

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare1 :: (Ord1 f, Ord a) => f a -> f a -> Ordering

-- | Lifting of the <a>Read</a> class to unary type constructors.
--   
--   Any instance should be subject to the following laws that canonicity
--   is preserved:
--   
--   <tt>liftReadsPrec readsPrec readList</tt> = <a>readsPrec</a>
--   
--   <tt>liftReadList readsPrec readList</tt> = <a>readList</a>
--   
--   <tt>liftReadPrec readPrec readListPrec</tt> = <a>readPrec</a>
--   
--   <tt>liftReadListPrec readPrec readListPrec</tt> = <a>readListPrec</a>
--   
--   This class therefore represents the generalization of <a>Read</a> by
--   decomposing it's methods into a canonical lifting on a canonical inner
--   method, so that the lifting can be reused for other arguments than the
--   canonical one.
--   
--   Both <a>liftReadsPrec</a> and <a>liftReadPrec</a> exist to match the
--   interface provided in the <a>Read</a> type class, but it is
--   recommended to implement <a>Read1</a> instances using
--   <a>liftReadPrec</a> as opposed to <a>liftReadsPrec</a>, since the
--   former is more efficient than the latter. For example:
--   
--   <pre>
--   instance <a>Read1</a> T where
--     <a>liftReadPrec</a>     = ...
--     <a>liftReadListPrec</a> = <a>liftReadListPrecDefault</a>
--   </pre>
--   
--   For more information, refer to the documentation for the <a>Read</a>
--   class.
class (forall a. Read a => Read (f a)) => Read1 f

-- | <a>readsPrec</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument type.
liftReadsPrec :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)

-- | <a>readList</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument type. The default implementation using standard list syntax
--   is correct for most types.
liftReadList :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]

-- | <a>readPrec</a> function for an application of the type constructor
--   based on <a>readPrec</a> and <a>readListPrec</a> functions for the
--   argument type.
liftReadPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)

-- | <a>readListPrec</a> function for an application of the type
--   constructor based on <a>readPrec</a> and <a>readListPrec</a> functions
--   for the argument type.
--   
--   The default definition uses <a>liftReadList</a>. Instances that define
--   <a>liftReadPrec</a> should also define <a>liftReadListPrec</a> as
--   <a>liftReadListPrecDefault</a>.
liftReadListPrec :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]

-- | Lift the standard <a>readsPrec</a> and <a>readList</a> functions
--   through the type constructor.
readsPrec1 :: (Read1 f, Read a) => Int -> ReadS (f a)

-- | Lift the standard <a>readPrec</a> and <a>readListPrec</a> functions
--   through the type constructor.
readPrec1 :: (Read1 f, Read a) => ReadPrec (f a)

-- | A possible replacement definition for the <a>liftReadList</a> method.
--   This is only needed for <a>Read1</a> instances where
--   <a>liftReadListPrec</a> isn't defined as
--   <a>liftReadListPrecDefault</a>.
liftReadListDefault :: Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]

-- | A possible replacement definition for the <a>liftReadListPrec</a>
--   method, defined using <a>liftReadPrec</a>.
liftReadListPrecDefault :: Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]

-- | Lifting of the <a>Show</a> class to unary type constructors.
--   
--   Any instance should be subject to the following laws that canonicity
--   is preserved:
--   
--   <tt>liftShowsPrec showsPrec showList</tt> = <a>showsPrec</a>
--   
--   <tt>liftShowList showsPrec showList</tt> = <a>showList</a>
--   
--   This class therefore represents the generalization of <a>Show</a> by
--   decomposing it's methods into a canonical lifting on a canonical inner
--   method, so that the lifting can be reused for other arguments than the
--   canonical one.
class (forall a. Show a => Show (f a)) => Show1 f

-- | <a>showsPrec</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument type.
liftShowsPrec :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | <a>showsPrec</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument type.
liftShowsPrec :: (Show1 f, f ~ f' b, Show2 f', Show b) => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS

-- | <a>showList</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument type. The default implementation using standard list syntax
--   is correct for most types.
liftShowList :: Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS

-- | Lift the standard <a>showsPrec</a> and <a>showList</a> functions
--   through the type constructor.
showsPrec1 :: (Show1 f, Show a) => Int -> f a -> ShowS

-- | Lifting of the <a>Eq</a> class to binary type constructors.
class (forall a. Eq a => Eq1 (f a)) => Eq2 f

-- | Lift equality tests through the type constructor.
--   
--   The function will usually be applied to equality functions, but the
--   more general type ensures that the implementation uses them to compare
--   elements of the first container with elements of the second.
liftEq2 :: Eq2 f => (a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool

-- | Lift the standard <tt>(<a>==</a>)</tt> function through the type
--   constructor.
eq2 :: (Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool

-- | Lifting of the <a>Ord</a> class to binary type constructors.
class (Eq2 f, forall a. Ord a => Ord1 (f a)) => Ord2 f

-- | Lift <a>compare</a> functions through the type constructor.
--   
--   The function will usually be applied to comparison functions, but the
--   more general type ensures that the implementation uses them to compare
--   elements of the first container with elements of the second.
liftCompare2 :: Ord2 f => (a -> b -> Ordering) -> (c -> d -> Ordering) -> f a c -> f b d -> Ordering

-- | Lift the standard <a>compare</a> function through the type
--   constructor.
compare2 :: (Ord2 f, Ord a, Ord b) => f a b -> f a b -> Ordering

-- | Lifting of the <a>Read</a> class to binary type constructors.
--   
--   Both <a>liftReadsPrec2</a> and <a>liftReadPrec2</a> exist to match the
--   interface provided in the <a>Read</a> type class, but it is
--   recommended to implement <a>Read2</a> instances using
--   <a>liftReadPrec2</a> as opposed to <a>liftReadsPrec2</a>, since the
--   former is more efficient than the latter. For example:
--   
--   <pre>
--   instance <a>Read2</a> T where
--     <a>liftReadPrec2</a>     = ...
--     <a>liftReadListPrec2</a> = <a>liftReadListPrec2Default</a>
--   </pre>
--   
--   For more information, refer to the documentation for the <a>Read</a>
--   class.
class (forall a. Read a => Read1 (f a)) => Read2 f

-- | <a>readsPrec</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument types.
liftReadsPrec2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> Int -> ReadS (f a b)

-- | <a>readList</a> function for an application of the type constructor
--   based on <a>readsPrec</a> and <a>readList</a> functions for the
--   argument types. The default implementation using standard list syntax
--   is correct for most types.
liftReadList2 :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]

-- | <a>readPrec</a> function for an application of the type constructor
--   based on <a>readPrec</a> and <a>readListPrec</a> functions for the
--   argument types.
liftReadPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)

-- | <a>readListPrec</a> function for an application of the type
--   constructor based on <a>readPrec</a> and <a>readListPrec</a> functions
--   for the argument types.
--   
--   The default definition uses <a>liftReadList2</a>. Instances that
--   define <a>liftReadPrec2</a> should also define
--   <a>liftReadListPrec2</a> as <a>liftReadListPrec2Default</a>.
liftReadListPrec2 :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]

-- | Lift the standard <a>readsPrec</a> function through the type
--   constructor.
readsPrec2 :: (Read2 f, Read a, Read b) => Int -> ReadS (f a b)

-- | Lift the standard <a>readPrec</a> function through the type
--   constructor.
readPrec2 :: (Read2 f, Read a, Read b) => ReadPrec (f a b)

-- | A possible replacement definition for the <a>liftReadList2</a> method.
--   This is only needed for <a>Read2</a> instances where
--   <a>liftReadListPrec2</a> isn't defined as
--   <a>liftReadListPrec2Default</a>.
liftReadList2Default :: Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]

-- | A possible replacement definition for the <a>liftReadListPrec2</a>
--   method, defined using <a>liftReadPrec2</a>.
liftReadListPrec2Default :: Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]

-- | Lifting of the <a>Show</a> class to binary type constructors.
class (forall a. Show a => Show1 (f a)) => Show2 f

-- | <a>showsPrec</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument types.
liftShowsPrec2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS

-- | <a>showList</a> function for an application of the type constructor
--   based on <a>showsPrec</a> and <a>showList</a> functions for the
--   argument types. The default implementation using standard list syntax
--   is correct for most types.
liftShowList2 :: Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [f a b] -> ShowS

-- | Lift the standard <a>showsPrec</a> function through the type
--   constructor.
showsPrec2 :: (Show2 f, Show a, Show b) => Int -> f a b -> ShowS

-- | <tt><a>readsData</a> p d</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readsUnary</a>, <a>readsUnary1</a> and
--   <a>readsBinary1</a>, and combined with <tt>mappend</tt> from the
--   <tt>Monoid</tt> class.
readsData :: (String -> ReadS a) -> Int -> ReadS a

-- | <tt><a>readData</a> p</tt> is a parser for datatypes where each
--   alternative begins with a data constructor. It parses the constructor
--   and passes it to <tt>p</tt>. Parsers for various constructors can be
--   constructed with <a>readUnaryWith</a> and <a>readBinaryWith</a>, and
--   combined with <a>(&lt;|&gt;)</a> from the <a>Alternative</a> class.
readData :: ReadPrec a -> ReadPrec a

-- | <tt><a>readsUnaryWith</a> rp n c n'</tt> matches the name of a unary
--   data constructor and then parses its argument using <tt>rp</tt>.
readsUnaryWith :: (Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readUnaryWith</a> rp n c'</tt> matches the name of a unary data
--   constructor and then parses its argument using <tt>rp</tt>.
readUnaryWith :: ReadPrec a -> String -> (a -> t) -> ReadPrec t

-- | <tt><a>readsBinaryWith</a> rp1 rp2 n c n'</tt> matches the name of a
--   binary data constructor and then parses its arguments using
--   <tt>rp1</tt> and <tt>rp2</tt> respectively.
readsBinaryWith :: (Int -> ReadS a) -> (Int -> ReadS b) -> String -> (a -> b -> t) -> String -> ReadS t

-- | <tt><a>readBinaryWith</a> rp1 rp2 n c'</tt> matches the name of a
--   binary data constructor and then parses its arguments using
--   <tt>rp1</tt> and <tt>rp2</tt> respectively.
readBinaryWith :: ReadPrec a -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t

-- | <tt><a>showsUnaryWith</a> sp n d x</tt> produces the string
--   representation of a unary data constructor with name <tt>n</tt> and
--   argument <tt>x</tt>, in precedence context <tt>d</tt>.
showsUnaryWith :: (Int -> a -> ShowS) -> String -> Int -> a -> ShowS

-- | <tt><a>showsBinaryWith</a> sp1 sp2 n d x y</tt> produces the string
--   representation of a binary data constructor with name <tt>n</tt> and
--   arguments <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.
showsBinaryWith :: (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> String -> Int -> a -> b -> ShowS

-- | <tt><a>readsUnary</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec</a>.

-- | <i>Deprecated: Use <a>readsUnaryWith</a> to define
--   <a>liftReadsPrec</a></i>
readsUnary :: Read a => String -> (a -> t) -> String -> ReadS t

-- | <tt><a>readsUnary1</a> n c n'</tt> matches the name of a unary data
--   constructor and then parses its argument using <a>readsPrec1</a>.

-- | <i>Deprecated: Use <a>readsUnaryWith</a> to define
--   <a>liftReadsPrec</a></i>
readsUnary1 :: (Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t

-- | <tt><a>readsBinary1</a> n c n'</tt> matches the name of a binary data
--   constructor and then parses its arguments using <a>readsPrec1</a>.

-- | <i>Deprecated: Use <a>readsBinaryWith</a> to define
--   <a>liftReadsPrec</a></i>
readsBinary1 :: (Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t

-- | <tt><a>showsUnary</a> n d x</tt> produces the string representation of
--   a unary data constructor with name <tt>n</tt> and argument <tt>x</tt>,
--   in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use <a>showsUnaryWith</a> to define
--   <a>liftShowsPrec</a></i>
showsUnary :: Show a => String -> Int -> a -> ShowS

-- | <tt><a>showsUnary1</a> n d x</tt> produces the string representation
--   of a unary data constructor with name <tt>n</tt> and argument
--   <tt>x</tt>, in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use <a>showsUnaryWith</a> to define
--   <a>liftShowsPrec</a></i>
showsUnary1 :: (Show1 f, Show a) => String -> Int -> f a -> ShowS

-- | <tt><a>showsBinary1</a> n d x y</tt> produces the string
--   representation of a binary data constructor with name <tt>n</tt> and
--   arguments <tt>x</tt> and <tt>y</tt>, in precedence context <tt>d</tt>.

-- | <i>Deprecated: Use <a>showsBinaryWith</a> to define
--   <a>liftShowsPrec</a></i>
showsBinary1 :: (Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS
instance Data.Functor.Classes.Show1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Show1 []
instance Data.Functor.Classes.Show1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Show2 (,)
instance Data.Functor.Classes.Show1 Solo
instance GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a)
instance GHC.Show.Show a => Data.Functor.Classes.Show2 ((,,) a)
instance (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show1 ((,,) a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show2 ((,,,) a b)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => Data.Functor.Classes.Show1 ((,,,) a b c)
instance Data.Functor.Classes.Show2 Data.Either.Either
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a)
instance Data.Functor.Classes.Show1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Show2 Data.Functor.Const.Const
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Show1 Data.Proxy.Proxy
instance Data.Functor.Classes.Show1 Data.Ord.Down
instance Data.Functor.Classes.Show1 Data.Complex.Complex
instance Data.Functor.Classes.Read2 (,)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a)
instance GHC.Read.Read a => Data.Functor.Classes.Read2 ((,,) a)
instance (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read1 ((,,) a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read2 ((,,,) a b)
instance (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => Data.Functor.Classes.Read1 ((,,,) a b c)
instance Data.Functor.Classes.Read2 Data.Either.Either
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a)
instance Data.Functor.Classes.Read2 Data.Functor.Const.Const
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Ord1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Ord1 []
instance Data.Functor.Classes.Ord1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Ord2 (,)
instance Data.Functor.Classes.Ord1 Solo
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord2 ((,,) a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord1 ((,,) a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord2 ((,,,) a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => Data.Functor.Classes.Ord1 ((,,,) a b c)
instance (GHC.Generics.Generic1 f, Data.Functor.Classes.Ord1 (GHC.Generics.Rep1 f)) => Data.Functor.Classes.Ord1 (GHC.Generics.Generically1 f)
instance Data.Functor.Classes.Ord2 Data.Either.Either
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a)
instance Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Ord2 Data.Functor.Const.Const
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Ord1 Data.Proxy.Proxy
instance Data.Functor.Classes.Ord1 Data.Ord.Down
instance Data.Functor.Classes.Eq1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Eq1 []
instance Data.Functor.Classes.Eq1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Eq2 (,)
instance Data.Functor.Classes.Eq1 Solo
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq2 ((,,) a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq1 ((,,) a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq2 ((,,,) a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => Data.Functor.Classes.Eq1 ((,,,) a b c)
instance (GHC.Generics.Generic1 f, Data.Functor.Classes.Eq1 (GHC.Generics.Rep1 f)) => Data.Functor.Classes.Eq1 (GHC.Generics.Generically1 f)
instance Data.Functor.Classes.Eq2 Data.Either.Either
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a)
instance Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Eq2 Data.Functor.Const.Const
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Functor.Const.Const a)
instance Data.Functor.Classes.Eq1 Data.Proxy.Proxy
instance Data.Functor.Classes.Eq1 Data.Ord.Down
instance Data.Functor.Classes.Eq1 Data.Complex.Complex
instance Data.Functor.Classes.Read1 GHC.Maybe.Maybe
instance Data.Functor.Classes.Read1 []
instance Data.Functor.Classes.Read1 GHC.Base.NonEmpty
instance Data.Functor.Classes.Read1 Solo
instance Data.Functor.Classes.Read1 Data.Functor.Identity.Identity
instance Data.Functor.Classes.Read1 Data.Proxy.Proxy
instance Data.Functor.Classes.Read1 Data.Ord.Down
instance Data.Functor.Classes.Read1 Data.Complex.Complex


-- | Sums, lifted to functors.
module Data.Functor.Sum

-- | Lifted sum of functors.
data Sum f g a
InL :: f a -> Sum f g a
InR :: g a -> Sum f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Sum.Sum f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Sum.Sum f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Sum.Sum f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Sum.Sum f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Sum.Sum f g)


-- | Products, lifted to functors.
module Data.Functor.Product

-- | Lifted product of functors.
data Product f g a
Pair :: f a -> g a -> Product f g a
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Product.Product f g)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (g :: k -> *) (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Product.Product f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Product.Product f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Product.Product f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Product.Product f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Product.Product f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Product.Product f g)
instance (GHC.Base.Alternative f, GHC.Base.Alternative g) => GHC.Base.Alternative (Data.Functor.Product.Product f g)
instance (GHC.Base.Monad f, GHC.Base.Monad g) => GHC.Base.Monad (Data.Functor.Product.Product f g)
instance (GHC.Base.MonadPlus f, GHC.Base.MonadPlus g) => GHC.Base.MonadPlus (Data.Functor.Product.Product f g)
instance (Control.Monad.Fix.MonadFix f, Control.Monad.Fix.MonadFix g) => Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f g)
instance (Control.Monad.Zip.MonadZip f, Control.Monad.Zip.MonadZip g) => Control.Monad.Zip.MonadZip (Data.Functor.Product.Product f g)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Semigroup (f a), GHC.Base.Semigroup (g a)) => GHC.Base.Semigroup (Data.Functor.Product.Product f g a)
instance forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Monoid (f a), GHC.Base.Monoid (g a)) => GHC.Base.Monoid (Data.Functor.Product.Product f g a)


-- | Composition of functors.
module Data.Functor.Compose

-- | Right-to-left composition of functors. The composition of applicative
--   functors is always applicative, but the composition of monads is not
--   always a monad.
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
[getCompose] :: Compose f g a -> f (g a)
infixr 9 `Compose`
infixr 9 `Compose`
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Monoid (f (g a)) => GHC.Base.Monoid (Data.Functor.Compose.Compose f g a)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Semigroup (f (g a)) => GHC.Base.Semigroup (Data.Functor.Compose.Compose f g a)
instance forall (f :: * -> *) k (g :: k -> *). GHC.Base.Functor f => GHC.Generics.Generic1 (Data.Functor.Compose.Compose f g)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Generics.Generic (Data.Functor.Compose.Compose f g a)
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable g, Data.Typeable.Internal.Typeable k1, Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) => Data.Data.Data (Data.Functor.Compose.Compose f g a)
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Eq (f (g a)) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a)
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Ord (f (g a)) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a)
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Read.Read (f (g a)) => GHC.Read.Read (Data.Functor.Compose.Compose f g a)
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Show.Show (f (g a)) => GHC.Show.Show (Data.Functor.Compose.Compose f g a)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (Data.Functor.Compose.Compose f g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (Data.Functor.Compose.Compose f g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Alternative f, GHC.Base.Applicative g) => GHC.Base.Alternative (Data.Functor.Compose.Compose f g)
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1). Data.Type.Equality.TestEquality f => Data.Type.Equality.TestEquality (Data.Functor.Compose.Compose f g)


-- | <a>Contravariant</a> functors, sometimes referred to colloquially as
--   <tt>Cofunctor</tt>, even though the dual of a <a>Functor</a> is just a
--   <a>Functor</a>. As with <a>Functor</a> the definition of
--   <a>Contravariant</a> for a given ADT is unambiguous.
module Data.Functor.Contravariant

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap :: (a' -&gt; a) -&gt; (Predicate a -&gt; Predicate a')
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant f
contramap :: Contravariant f => (a' -> a) -> f a -> f a'

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | If <tt>f</tt> is both <a>Functor</a> and <a>Contravariant</a> then by
--   the time you factor in the laws of each of those classes, it can't
--   actually use its argument in any meaningful capacity.
--   
--   This method is surprisingly useful. Where both instances exist and are
--   lawful we have the following laws:
--   
--   <pre>
--   <a>fmap</a>      f ≡ <a>phantom</a>
--   <a>contramap</a> f ≡ <a>phantom</a>
--   </pre>
phantom :: (Functor f, Contravariant f) => f a -> f b

-- | This is an infix alias for <a>contramap</a>.
(>$<) :: Contravariant f => (a -> b) -> f b -> f a
infixl 4 >$<

-- | This is an infix version of <a>contramap</a> with the arguments
--   flipped.
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a
infixl 4 >$$<

-- | This is <a>&gt;$</a> with its arguments flipped.
($<) :: Contravariant f => f b -> b -> f a
infixl 4 $<
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool

-- | Defines a total ordering on a type as per <a>compare</a>.
--   
--   This condition is not checked by the types. You must ensure that the
--   supplied values are valid total orderings yourself.
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering

-- | Compare using <a>compare</a>.
defaultComparison :: Ord a => Comparison a

-- | This data type represents an equivalence relation.
--   
--   Equivalence relations are expected to satisfy three laws:
--   
--   <ul>
--   <li><i>Reflexivity</i> <tt><a>getEquivalence</a> f a a =
--   True</tt></li>
--   <li><i>Symmetry</i> <tt><a>getEquivalence</a> f a b =
--   <a>getEquivalence</a> f b a</tt></li>
--   <li><i>Transitivity</i> If <tt><a>getEquivalence</a> f a b</tt> and
--   <tt><a>getEquivalence</a> f b c</tt> are both <a>True</a> then so is
--   <tt><a>getEquivalence</a> f a c</tt>.</li>
--   </ul>
--   
--   The types alone do not enforce these laws, so you'll have to check
--   them yourself.
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool

-- | Check for equivalence with <a>==</a>.
--   
--   Note: The instances for <a>Double</a> and <a>Float</a> violate
--   reflexivity for <tt>NaN</tt>.
defaultEquivalence :: Eq a => Equivalence a
comparisonEquivalence :: Comparison a -> Equivalence a

-- | Dual function arrows.
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a
instance GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a)
instance GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate
instance GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a)
instance GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (GHC.Generics.M1 i c f)
instance Control.Category.Category Data.Functor.Contravariant.Op
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b)
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Contravariant GHC.Generics.V1
instance Data.Functor.Contravariant.Contravariant GHC.Generics.U1
instance Data.Functor.Contravariant.Contravariant (GHC.Generics.K1 i c)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:*: g)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:.: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (f GHC.Generics.:+: g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Contravariant.Contravariant f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Const.Const a)
instance (GHC.Base.Functor f, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Contravariant.Contravariant Data.Proxy.Proxy


-- | A class of non-empty data structures that can be folded to a summary
--   value.
module Data.Foldable1

-- | Non-empty data structures that can be folded.
class Foldable t => Foldable1 t

-- | Combine the elements of a structure using a semigroup. @since 4.18.0.0
fold1 :: (Foldable1 t, Semigroup m) => t m -> m

-- | Map each element of the structure to a semigroup, and combine the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1 Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap1</a> that is strict in the accumulator.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1' Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1' :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | List of elements of a structure, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (Identity 2)
--   2 :| []
--   </pre>
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | The largest element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; maximum (32 :| [64, 8, 128, 16])
--   128
--   </pre>
maximum :: (Foldable1 t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (32 :| [64, 8, 128, 16])
--   8
--   </pre>
minimum :: (Foldable1 t, Ord a) => t a -> a

-- | The first element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; head (1 :| [2, 3, 4])
--   1
--   </pre>
head :: Foldable1 t => t a -> a

-- | The last element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; last (1 :| [2, 3, 4])
--   4
--   </pre>
last :: Foldable1 t => t a -> a

-- | Generalized <a>foldr1</a>. @since 4.18.0.0
foldrMap1 :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b

-- | Generalized <a>foldl1'</a>. @since 4.18.0.0
foldlMap1' :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b

-- | Generalized <a>foldl1</a>. @since 4.18.0.0
foldlMap1 :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b

-- | Generalized <a>foldr1'</a>. @since 4.18.0.0
foldrMap1' :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   right to left:
--   
--   <pre>
--   foldr1 f [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn1 `f` xn )...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr1</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr1 f = foldr1 f . <a>toNonEmpty</a>
--   </pre>
foldr1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   left to right:
--   
--   <pre>
--   foldl1 f [x1, x2, ..., xn] == (...((x1 `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl1</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl1'</a> instead of <a>foldl1</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>x1 `f`
--   x2</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(`f` x3)</tt>). This results in a thunk chain
--   &lt;math&gt; elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1 f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <tt>length</tt>).
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1' f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Insert an <tt>m</tt> between each pair of <tt>t m</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Map variant of <a>foldrM1</a>.
foldrMapM1 :: (Foldable1 t, Monad m) => (a -> m b) -> (a -> b -> m b) -> t a -> m b

-- | Map variant of <a>foldlM1</a>.
foldlMapM1 :: (Foldable1 t, Monad m) => (a -> m b) -> (b -> a -> m b) -> t a -> m b

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable1 t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable1 t => (a -> a -> Ordering) -> t a -> a
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Semigroup.Internal.Alt f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Monoid.Ap f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.Rec1 f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.M1 i c f)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Foldable1.JoinWith a)
instance Data.Foldable1.Foldable1 GHC.Base.NonEmpty
instance Data.Foldable1.Foldable1 Data.Ord.Down
instance Data.Foldable1.Foldable1 Data.Complex.Complex
instance Data.Foldable1.Foldable1 Solo
instance Data.Foldable1.Foldable1 ((,) a)
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Dual
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Sum
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Product
instance Data.Foldable1.Foldable1 Data.Semigroup.Min
instance Data.Foldable1.Foldable1 Data.Semigroup.Max
instance Data.Foldable1.Foldable1 Data.Semigroup.First
instance Data.Foldable1.Foldable1 Data.Semigroup.Last
instance Data.Foldable1.Foldable1 GHC.Generics.V1
instance Data.Foldable1.Foldable1 GHC.Generics.Par1
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:+: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:*: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:.: g)
instance Data.Foldable1.Foldable1 Data.Functor.Identity.Identity
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Product.Product f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Sum.Sum f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Compose.Compose f g)
instance GHC.Base.Semigroup (Data.Foldable1.FromMaybe b)
instance GHC.Base.Semigroup (Data.Foldable1.NonEmptyDList a)


-- | Derived from <tt>primitive</tt> package.
module Data.Array.Byte

-- | Lifted wrapper for <a>ByteArray#</a>.
--   
--   Since <a>ByteArray#</a> is an unlifted type and not a member of kind
--   <a>Type</a>, things like <tt>[ByteArray#]</tt> or <tt>IO
--   ByteArray#</tt> are ill-typed. To work around this inconvenience this
--   module provides a standard lifted wrapper, inhabiting <a>Type</a>.
--   Clients are expected to use <a>ByteArray</a> in higher-level APIs, but
--   wrap and unwrap <a>ByteArray</a> internally as they please and use
--   functions from <a>GHC.Exts</a>.
data ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Lifted wrapper for <a>MutableByteArray#</a>.
--   
--   Since <a>MutableByteArray#</a> is an unlifted type and not a member of
--   kind <a>Type</a>, things like <tt>[MutableByteArray#]</tt> or <tt>IO
--   MutableByteArray#</tt> are ill-typed. To work around this
--   inconvenience this module provides a standard lifted wrapper,
--   inhabiting <a>Type</a>. Clients are expected to use
--   <a>MutableByteArray</a> in higher-level APIs, but wrap and unwrap
--   <a>MutableByteArray</a> internally as they please and use functions
--   from <a>GHC.Exts</a>.
data MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s
instance Data.Typeable.Internal.Typeable s => Data.Data.Data (Data.Array.Byte.MutableByteArray s)
instance GHC.Classes.Eq (Data.Array.Byte.MutableByteArray s)
instance Data.Data.Data Data.Array.Byte.ByteArray
instance GHC.Show.Show Data.Array.Byte.ByteArray
instance GHC.Classes.Eq Data.Array.Byte.ByteArray
instance GHC.Classes.Ord Data.Array.Byte.ByteArray
instance GHC.Base.Semigroup Data.Array.Byte.ByteArray
instance GHC.Base.Monoid Data.Array.Byte.ByteArray
instance GHC.IsList.IsList Data.Array.Byte.ByteArray
