<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Control.Concurrent.MVar</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">base-4.18.2.1: Core data structures and operations</span><ul class="links" id="page-menu"><li><a href="src/Control.Concurrent.MVar.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) The University of Glasgow 2001</td></tr><tr><th>License</th><td>BSD-style (see the file libraries/base/LICENSE)</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Portability</th><td>non-portable (concurrency)</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.Concurrent.MVar</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1"><code>MVar</code>s</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>An <code><code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> t</code> is mutable location that is either empty or contains a
 value of type <code>t</code>.  It has two fundamental operations: <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>
 which fills an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> if it is empty and blocks otherwise, and
 <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> which empties an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> if it is full and blocks
 otherwise.  They can be used in multiple different ways:</p><ol><li value="1">As synchronized mutable variables,</li><li value="2">As channels, with <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> and <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> as receive and send, and</li><li value="3">As a binary semaphore <code><code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> ()</code>, with <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> and <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> as
      wait and signal.</li></ol><p>They were introduced in the paper
 <a href="https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz">&quot;Concurrent Haskell&quot;</a>
 by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though
 some details of their implementation have since then changed (in
 particular, a put on a full <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> used to error, but now merely
 blocks.)</p><h3>Applicability</h3><p><code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s offer more flexibility than <code><a href="Data-IORef.html#v:IORef" title="Data.IORef">IORef</a></code>s, but less flexibility
 than <code><a href="GHC-Conc.html#v:STM" title="GHC.Conc">STM</a></code>.  They are appropriate for building synchronization
 primitives and performing simple interthread communication; however
 they are very simple and susceptible to race conditions, deadlocks or
 uncaught exceptions.  Do not use them if you need perform larger
 atomic operations such as reading from multiple variables: use <code><a href="GHC-Conc.html#v:STM" title="GHC.Conc">STM</a></code>
 instead.</p><p>In particular, the &quot;bigger&quot; functions in this module (<code><a href="Control-Concurrent-MVar.html#v:swapMVar" title="Control.Concurrent.MVar">swapMVar</a></code>,
 <code><a href="Control-Concurrent-MVar.html#v:withMVar" title="Control.Concurrent.MVar">withMVar</a></code>, <code><a href="Control-Concurrent-MVar.html#v:modifyMVar_" title="Control.Concurrent.MVar">modifyMVar_</a></code> and <code><a href="Control-Concurrent-MVar.html#v:modifyMVar" title="Control.Concurrent.MVar">modifyMVar</a></code>) are simply
 the composition of a <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> followed by a <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> with
 exception safety.
 These have atomicity guarantees only if all other threads
 perform a <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> before a <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> as well;  otherwise, they may
 block.</p><h3>Fairness</h3><p>No thread can be blocked indefinitely on an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> unless another
 thread holds that <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> indefinitely.  One usual implementation of
 this fairness guarantee is that threads blocked on an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> are
 served in a first-in-first-out fashion, but this is not guaranteed
 in the semantics.</p><h3>Gotchas</h3><p>Like many other Haskell data structures, <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s are lazy.  This
 means that if you place an expensive unevaluated thunk inside an
 <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, it will be evaluated by the thread that consumes it, not the
 thread that produced it.  Be sure to <code><a href="Control-Exception-Base.html#v:evaluate" title="Control.Exception.Base">evaluate</a></code> values to be placed
 in an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> to the appropriate normal form, or utilize a strict
 MVar provided by the strict-concurrency package.</p><h3>Ordering</h3><p><code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> operations are always observed to take place in the order
 they are written in the program, regardless of the memory model of
 the underlying machine.  This is in contrast to <code><a href="Data-IORef.html#v:IORef" title="Data.IORef">IORef</a></code> operations
 which may appear out-of-order to another thread in some cases.</p><h3>Example</h3><p>Consider the following concurrent data structure, a skip channel.
 This is a channel for an intermittent source of high bandwidth
 information (for example, mouse movement events.)  Writing to the
 channel never blocks, and reading from the channel only returns the
 most recent value, or blocks if there are no new values.  Multiple
 readers are supported with a <code>dupSkipChan</code> operation.</p><p>A skip channel is a pair of <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s. The first <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> contains the
 current value, and a list of semaphores that need to be notified
 when it changes. The second <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is a semaphore for this particular
 reader: it is full if there is a value in the channel that this
 reader has not read yet, and empty otherwise.</p><pre>    data SkipChan a = SkipChan (MVar (a, [MVar ()])) (MVar ())

    newSkipChan :: IO (SkipChan a)
    newSkipChan = do
        sem &lt;- newEmptyMVar
        main &lt;- newMVar (undefined, [sem])
        return (SkipChan main sem)

    putSkipChan :: SkipChan a -&gt; a -&gt; IO ()
    putSkipChan (SkipChan main _) v = do
        (_, sems) &lt;- takeMVar main
        putMVar main (v, [])
        mapM_ (sem -&gt; putMVar sem ()) sems

    getSkipChan :: SkipChan a -&gt; IO a
    getSkipChan (SkipChan main sem) = do
        takeMVar sem
        (v, sems) &lt;- takeMVar main
        putMVar main (v, sem:sems)
        return v

    dupSkipChan :: SkipChan a -&gt; IO (SkipChan a)
    dupSkipChan (SkipChan main _) = do
        sem &lt;- newEmptyMVar
        (v, sems) &lt;- takeMVar main
        putMVar main (v, sem:sems)
        return (SkipChan main sem)
</pre><p>This example was adapted from the original Concurrent Haskell paper.
 For more examples of <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s being used to build higher-level
 synchronization primitives, see <code><a href="Control-Concurrent.html#v:Chan" title="Control.Concurrent">Chan</a></code> and
 <code><a href="Control-Concurrent.html#v:QSem" title="Control.Concurrent">QSem</a></code>.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:MVar">MVar</a> a</li><li class="src short"><a href="#v:newEmptyMVar">newEmptyMVar</a> :: <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a)</li><li class="src short"><a href="#v:newMVar">newMVar</a> :: a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a)</li><li class="src short"><a href="#v:takeMVar">takeMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a</li><li class="src short"><a href="#v:putMVar">putMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:readMVar">readMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a</li><li class="src short"><a href="#v:swapMVar">swapMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a</li><li class="src short"><a href="#v:tryTakeMVar">tryTakeMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:tryPutMVar">tryPutMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isEmptyMVar">isEmptyMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:withMVar">withMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b</li><li class="src short"><a href="#v:withMVarMasked">withMVarMasked</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b</li><li class="src short"><a href="#v:modifyMVar_">modifyMVar_</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:modifyMVar">modifyMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (a, b)) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b</li><li class="src short"><a href="#v:modifyMVarMasked_">modifyMVarMasked_</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:modifyMVarMasked">modifyMVarMasked</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (a, b)) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b</li><li class="src short"><a href="#v:tryReadMVar">tryReadMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:mkWeakMVar">mkWeakMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="System-Mem-Weak.html#t:Weak" title="System.Mem.Weak">Weak</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a))</li><li class="src short"><a href="#v:addMVarFinalizer">addMVarFinalizer</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1><code>MVar</code>s</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:MVar" class="def">MVar</a> a <a href="src/GHC.MVar.html#MVar" class="link">Source</a> <a href="#t:MVar" class="selflink">#</a></p><div class="doc"><p>An <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> (pronounced &quot;em-var&quot;) is a synchronising variable, used
for communication between concurrent threads.  It can be thought of
as a box, which may be empty or full.</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MVar">Instances</h4><details id="i:MVar" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:MVar:Eq:1"></span> <a href="Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a)</span> <a href="src/GHC.MVar.html#line-46" class="link">Source</a> <a href="#t:MVar" class="selflink">#</a></td><td class="doc"><p><em>Since: base-4.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:MVar:Eq:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="GHC-MVar.html">GHC.MVar</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="../ghc-prim-0.10.0/src/GHC.Classes.html#%3D%3D" class="link">Source</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="../ghc-prim-0.10.0/src/GHC.Classes.html#%2F%3D" class="link">Source</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:newEmptyMVar" class="def">newEmptyMVar</a> :: <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a) <a href="src/GHC.MVar.html#newEmptyMVar" class="link">Source</a> <a href="#v:newEmptyMVar" class="selflink">#</a></p><div class="doc"><p>Create an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> which is initially empty.</p></div></div><div class="top"><p class="src"><a id="v:newMVar" class="def">newMVar</a> :: a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a) <a href="src/GHC.MVar.html#newMVar" class="link">Source</a> <a href="#v:newMVar" class="selflink">#</a></p><div class="doc"><p>Create an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> which contains the supplied value.</p></div></div><div class="top"><p class="src"><a id="v:takeMVar" class="def">takeMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a <a href="src/GHC.MVar.html#takeMVar" class="link">Source</a> <a href="#v:takeMVar" class="selflink">#</a></p><div class="doc"><p>Return the contents of the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.  If the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is currently
 empty, <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> will wait until it is full.  After a <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code>,
 the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is left empty.</p><p>There are two further important properties of <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code>:</p><ul><li><code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> is single-wakeup.  That is, if there are multiple
     threads blocked in <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code>, and the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> becomes full,
     only one thread will be woken up.  The runtime guarantees that
     the woken thread completes its <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> operation.</li><li>When multiple threads are blocked on an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, they are
     woken up in FIFO order.  This is useful for providing
     fairness properties of abstractions built using <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s.</li></ul></div></div><div class="top"><p class="src"><a id="v:putMVar" class="def">putMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/GHC.MVar.html#putMVar" class="link">Source</a> <a href="#v:putMVar" class="selflink">#</a></p><div class="doc"><p>Put a value into an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.  If the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is currently full,
 <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> will wait until it becomes empty.</p><p>There are two further important properties of <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>:</p><ul><li><code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> is single-wakeup.  That is, if there are multiple
     threads blocked in <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>, and the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> becomes empty,
     only one thread will be woken up.  The runtime guarantees that
     the woken thread completes its <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> operation.</li><li>When multiple threads are blocked on an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, they are
     woken up in FIFO order.  This is useful for providing
     fairness properties of abstractions built using <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>s.</li></ul></div></div><div class="top"><p class="src"><a id="v:readMVar" class="def">readMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a <a href="src/GHC.MVar.html#readMVar" class="link">Source</a> <a href="#v:readMVar" class="selflink">#</a></p><div class="doc"><p>Atomically read the contents of an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.  If the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is
 currently empty, <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> will wait until it is full.
 <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> is guaranteed to receive the next <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>.</p><p><code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> is multiple-wakeup, so when multiple readers are
 blocked on an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, all of them are woken up at the same time.</p><p><em>Compatibility note:</em> Prior to base 4.7, <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> was a combination
 of <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code> and <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>.  This mean that in the presence of
 other threads attempting to <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>, <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> could block.
 Furthermore, <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code> would not receive the next <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code> if there
 was already a pending thread blocked on <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code>.  The old behavior
 can be recovered by implementing 'readMVar as follows:</p><pre> readMVar :: MVar a -&gt; IO a
 readMVar m =
   mask_ $ do
     a &lt;- takeMVar m
     putMVar m a
     return a
</pre></div></div><div class="top"><p class="src"><a id="v:swapMVar" class="def">swapMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a <a href="src/Control.Concurrent.MVar.html#swapMVar" class="link">Source</a> <a href="#v:swapMVar" class="selflink">#</a></p><div class="doc"><p>Take a value from an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, put a new value into the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> and
  return the value taken. This function is atomic only if there are
  no other producers for this <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>. In other words, it cannot guarantee
  that, by the time <code><a href="Control-Concurrent-MVar.html#v:swapMVar" title="Control.Concurrent.MVar">swapMVar</a></code> gets the chance to write to the MVar,
  the value of the MVar has not been altered
  by a write operation from another thread.</p></div></div><div class="top"><p class="src"><a id="v:tryTakeMVar" class="def">tryTakeMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/GHC.MVar.html#tryTakeMVar" class="link">Source</a> <a href="#v:tryTakeMVar" class="selflink">#</a></p><div class="doc"><p>A non-blocking version of <code><a href="Control-Concurrent-MVar.html#v:takeMVar" title="Control.Concurrent.MVar">takeMVar</a></code>.  The <code><a href="Control-Concurrent-MVar.html#v:tryTakeMVar" title="Control.Concurrent.MVar">tryTakeMVar</a></code> function
 returns immediately, with <code><a href="Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> was empty, or
 <code><code><a href="Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> a</code> if the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> was full with contents <code>a</code>.  After <code><a href="Control-Concurrent-MVar.html#v:tryTakeMVar" title="Control.Concurrent.MVar">tryTakeMVar</a></code>,
 the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is left empty.</p></div></div><div class="top"><p class="src"><a id="v:tryPutMVar" class="def">tryPutMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/GHC.MVar.html#tryPutMVar" class="link">Source</a> <a href="#v:tryPutMVar" class="selflink">#</a></p><div class="doc"><p>A non-blocking version of <code><a href="Control-Concurrent-MVar.html#v:putMVar" title="Control.Concurrent.MVar">putMVar</a></code>.  The <code><a href="Control-Concurrent-MVar.html#v:tryPutMVar" title="Control.Concurrent.MVar">tryPutMVar</a></code> function
 attempts to put the value <code>a</code> into the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, returning <code><a href="Data-Bool.html#v:True" title="Data.Bool">True</a></code> if
 it was successful, or <code><a href="Data-Bool.html#v:False" title="Data.Bool">False</a></code> otherwise.</p></div></div><div class="top"><p class="src"><a id="v:isEmptyMVar" class="def">isEmptyMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> <a href="Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/GHC.MVar.html#isEmptyMVar" class="link">Source</a> <a href="#v:isEmptyMVar" class="selflink">#</a></p><div class="doc"><p>Check whether a given <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is empty.</p><p>Notice that the boolean value returned  is just a snapshot of
 the state of the MVar. By the time you get to react on its result,
 the MVar may have been filled (or emptied) - so be extremely
 careful when using this operation.   Use <code><a href="Control-Concurrent-MVar.html#v:tryTakeMVar" title="Control.Concurrent.MVar">tryTakeMVar</a></code> instead if possible.</p></div></div><div class="top"><p class="src"><a id="v:withMVar" class="def">withMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b <a href="src/Control.Concurrent.MVar.html#withMVar" class="link">Source</a> <a href="#v:withMVar" class="selflink">#</a></p><div class="doc"><p><code><a href="Control-Concurrent-MVar.html#v:withMVar" title="Control.Concurrent.MVar">withMVar</a></code> is an exception-safe wrapper for operating on the contents
  of an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.  This operation is exception-safe: it will replace the
  original contents of the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> if an exception is raised (see
  <a href="Control-Exception.html">Control.Exception</a>).  However, it is only atomic if there are no
  other producers for this <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>. In other words, it cannot guarantee
  that, by the time <code><a href="Control-Concurrent-MVar.html#v:withMVar" title="Control.Concurrent.MVar">withMVar</a></code> gets the chance to write to the MVar,
  the value of the MVar has not been altered
  by a write operation from another thread.</p></div></div><div class="top"><p class="src"><a id="v:withMVarMasked" class="def">withMVarMasked</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b <a href="src/Control.Concurrent.MVar.html#withMVarMasked" class="link">Source</a> <a href="#v:withMVarMasked" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Control-Concurrent-MVar.html#v:withMVar" title="Control.Concurrent.MVar">withMVar</a></code>, but the <code>IO</code> action in the second argument is executed
  with asynchronous exceptions masked.</p><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:modifyMVar_" class="def">modifyMVar_</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.MVar.html#modifyMVar_" class="link">Source</a> <a href="#v:modifyMVar_" class="selflink">#</a></p><div class="doc"><p>An exception-safe wrapper for modifying the contents of an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.
  Like <code><a href="Control-Concurrent-MVar.html#v:withMVar" title="Control.Concurrent.MVar">withMVar</a></code>, <code><a href="Control-Concurrent-MVar.html#v:modifyMVar" title="Control.Concurrent.MVar">modifyMVar</a></code> will replace the original contents of
  the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> if an exception is raised during the operation.  This
  function is only atomic if there are no other producers for this
  <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>. In other words, it cannot guarantee that, by the time
  <code><a href="Control-Concurrent-MVar.html#v:modifyMVar_" title="Control.Concurrent.MVar">modifyMVar_</a></code> gets the chance to write to the MVar, the value
  of the MVar has not been altered by a write operation from another thread.</p></div></div><div class="top"><p class="src"><a id="v:modifyMVar" class="def">modifyMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (a, b)) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b <a href="src/Control.Concurrent.MVar.html#modifyMVar" class="link">Source</a> <a href="#v:modifyMVar" class="selflink">#</a></p><div class="doc"><p>A slight variation on <code><a href="Control-Concurrent-MVar.html#v:modifyMVar_" title="Control.Concurrent.MVar">modifyMVar_</a></code> that allows a value to be
  returned (<code>b</code>) in addition to the modified value of the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:modifyMVarMasked_" class="def">modifyMVarMasked_</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> a) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.MVar.html#modifyMVarMasked_" class="link">Source</a> <a href="#v:modifyMVarMasked_" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Control-Concurrent-MVar.html#v:modifyMVar_" title="Control.Concurrent.MVar">modifyMVar_</a></code>, but the <code>IO</code> action in the second argument is executed with
  asynchronous exceptions masked.</p><p><em>Since: base-4.6.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:modifyMVarMasked" class="def">modifyMVarMasked</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; (a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (a, b)) -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> b <a href="src/Control.Concurrent.MVar.html#modifyMVarMasked" class="link">Source</a> <a href="#v:modifyMVarMasked" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Control-Concurrent-MVar.html#v:modifyMVar" title="Control.Concurrent.MVar">modifyMVar</a></code>, but the <code>IO</code> action in the second argument is executed with
  asynchronous exceptions masked.</p><p><em>Since: base-4.6.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:tryReadMVar" class="def">tryReadMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/GHC.MVar.html#tryReadMVar" class="link">Source</a> <a href="#v:tryReadMVar" class="selflink">#</a></p><div class="doc"><p>A non-blocking version of <code><a href="Control-Concurrent-MVar.html#v:readMVar" title="Control.Concurrent.MVar">readMVar</a></code>.  The <code><a href="Control-Concurrent-MVar.html#v:tryReadMVar" title="Control.Concurrent.MVar">tryReadMVar</a></code> function
 returns immediately, with <code><a href="Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> was empty, or
 <code><code><a href="Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> a</code> if the <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> was full with contents <code>a</code>.</p><p><em>Since: base-4.7.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:mkWeakMVar" class="def">mkWeakMVar</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> (<a href="System-Mem-Weak.html#t:Weak" title="System.Mem.Weak">Weak</a> (<a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a)) <a href="src/Control.Concurrent.MVar.html#mkWeakMVar" class="link">Source</a> <a href="#v:mkWeakMVar" class="selflink">#</a></p><div class="doc"><p>Make a <code><a href="System-Mem-Weak.html#t:Weak" title="System.Mem.Weak">Weak</a></code> pointer to an <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code>, using the second argument as
 a finalizer to run when <code><a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a></code> is garbage-collected</p><p><em>Since: base-4.6.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:addMVarFinalizer" class="def">addMVarFinalizer</a> :: <a href="Control-Concurrent-MVar.html#t:MVar" title="Control.Concurrent.MVar">MVar</a> a -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () -&gt; <a href="System-IO.html#t:IO" title="System.IO">IO</a> () <a href="src/Control.Concurrent.MVar.html#addMVarFinalizer" class="link">Source</a> <a href="#v:addMVarFinalizer" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: use <code><a href="Control-Concurrent-MVar.html#v:mkWeakMVar" title="Control.Concurrent.MVar">mkWeakMVar</a></code> instead</p></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>