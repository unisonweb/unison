<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE NoImplicitPrelude #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators #-}</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Module      :  Data.Traversable</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- Copyright   :  Conor McBride and Ross Paterson 2005</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- License     :  BSD-style (see the LICENSE file in the distribution)</span><span>
</span><span id="line-15"></span><span class="hs-comment">--</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- Stability   :  stable</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-19"></span><span class="hs-comment">--</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- Class of data structures that can be traversed from left to right,</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- performing an action on each element.  Instances are expected to satisfy</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- the listed [laws](#laws).</span><span>
</span><span id="line-23"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.Traversable</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><span class="hs-comment">-- * The 'Traversable' class</span></span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier">Traversable</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Utility functions</span></span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#for"><span class="hs-identifier">for</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#forM"><span class="hs-identifier">forM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#forAccumM"><span class="hs-identifier">forAccumM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#mapAccumL"><span class="hs-identifier">mapAccumL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#mapAccumR"><span class="hs-identifier">mapAccumR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#mapAccumM"><span class="hs-identifier">mapAccumM</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>    </span><span class="annot"><span class="hs-comment">-- * General definitions for superclass methods</span></span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#fmapDefault"><span class="hs-identifier">fmapDefault</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#foldMapDefault"><span class="hs-identifier">foldMapDefault</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Overview</span></span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><span class="hs-comment">-- $overview</span></span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** The 'traverse' and 'mapM' methods</span></span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><span class="hs-comment">-- $traverse</span></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Their 'Foldable', just the effects, analogues.</span></span><span>
</span><span id="line-46"></span><span>    </span><span class="annot"><span class="hs-comment">-- $effectful</span></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Result multiplicity</span></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><span class="hs-comment">-- $multiplicity</span></span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** The 'sequenceA' and 'sequence' methods</span></span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><span class="hs-comment">-- $sequence</span></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Care with default method implementations</span></span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="hs-comment">-- $seqdefault</span></span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Monadic short circuits</span></span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><span class="hs-comment">-- $seqshort</span></span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Example binary tree instance</span></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><span class="hs-comment">-- $tree_instance</span></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Pre-order and post-order tree traversal</span></span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><span class="hs-comment">-- $tree_order</span></span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Making construction intuitive</span></span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><span class="hs-comment">-- $construction</span></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Advanced traversals</span></span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><span class="hs-comment">-- $advanced</span></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** Coercion</span></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><span class="hs-comment">-- $coercion</span></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Identity: the 'fmapDefault' function</span></span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><span class="hs-comment">-- $identity</span></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** State: the 'mapAccumL', 'mapAccumR' functions</span></span><span>
</span><span id="line-80"></span><span>    </span><span class="annot"><span class="hs-comment">-- $stateful</span></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Const: the 'foldMapDefault' function</span></span><span>
</span><span id="line-83"></span><span>    </span><span class="annot"><span class="hs-comment">-- $phantom</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** ZipList: transposing lists of lists</span></span><span>
</span><span id="line-86"></span><span>    </span><span class="annot"><span class="hs-comment">-- $ziplist</span></span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Laws</span></span><span>
</span><span id="line-89"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-90"></span><span>    </span><span class="annot"><span class="hs-comment">-- $laws</span></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span>    </span><span class="annot"><span class="hs-comment">-- * See also</span></span><span>
</span><span id="line-93"></span><span>    </span><span class="annot"><span class="hs-comment">-- $also</span></span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-comment">-- It is convenient to use 'Const' here but this means we must</span><span>
</span><span id="line-97"></span><span class="hs-comment">-- define a few instances here which really belong in Control.Applicative</span><span>
</span><span id="line-98"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Applicative.html"><span class="hs-identifier">Control.Applicative</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Functor.Const.html#Const"><span class="hs-identifier">Const</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Applicative.html#ZipList"><span class="hs-identifier">ZipList</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Coerce.html"><span class="hs-identifier">Data.Coerce</span></a></span><span>
</span><span id="line-100"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Either.html"><span class="hs-identifier">Data.Either</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Either.html#Either"><span class="hs-identifier">Either</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Foldable.html"><span class="hs-identifier">Data.Foldable</span></a></span><span>
</span><span id="line-102"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Functor.html"><span class="hs-identifier">Data.Functor</span></a></span><span>
</span><span id="line-103"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Functor.Identity.html"><span class="hs-identifier">Data.Functor.Identity</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Functor.Identity.html#Identity"><span class="hs-identifier">Identity</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html"><span class="hs-identifier">Data.Functor.Utils</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#StateL"><span class="hs-identifier">StateL</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#StateR"><span class="hs-identifier">StateR</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#StateT"><span class="hs-identifier">StateT</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Functor.Utils.html#%23."><span class="hs-operator">(#.)</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Monoid.html"><span class="hs-identifier">Data.Monoid</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier">Dual</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier">Sum</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier">Product</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-106"></span><span>                     </span><span class="annot"><a href="Data.Monoid.html#First"><span class="hs-identifier">First</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Monoid.html#Last"><span class="hs-identifier">Last</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Alt"><span class="hs-identifier">Alt</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Monoid.html#Ap"><span class="hs-identifier">Ap</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-107"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Ord.html"><span class="hs-identifier">Data.Ord</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Ord.html#Down"><span class="hs-identifier">Down</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-108"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.Proxy.html"><span class="hs-identifier">Data.Proxy</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.Proxy.html#Proxy"><span class="hs-identifier">Proxy</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Arr.html"><span class="hs-identifier">GHC.Arr</span></a></span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Base.html"><span class="hs-identifier">GHC.Base</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier">Applicative</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier">Monad</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monoid"><span class="hs-identifier">Monoid</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier">Maybe</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#NonEmpty"><span class="hs-identifier">NonEmpty</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-112"></span><span>                  </span><span class="annot"><a href="GHC.Base.html#%24"><span class="hs-operator">($)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#."><span class="hs-operator">(.)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#id"><span class="hs-identifier">id</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#flip"><span class="hs-identifier">flip</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Generics.html"><span class="hs-identifier">GHC.Generics</span></a></span><span>
</span><span id="line-114"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="GHC.List.html"><span class="hs-identifier">GHC.List</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">List</span></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Base.html#foldr"><span class="hs-identifier">foldr</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Tuple.html#/GHC.Tuple.html"><span class="hs-identifier">GHC.Tuple</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Tuple.Prim.html#Solo/GHC.Tuple.Prim.html#Solo"><span class="hs-identifier">Solo</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>
</span><span id="line-117"></span><span class="hs-comment">-- $setup</span><span>
</span><span id="line-118"></span><span class="hs-comment">-- &gt;&gt;&gt; import Prelude</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Maybe (catMaybes, mapMaybe)</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Either (rights)</span><span>
</span><span id="line-121"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Foldable (traverse_)</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-comment">-- XXX: Missing haddock feature.  Links to anchors in other modules</span><span>
</span><span id="line-124"></span><span class="hs-comment">-- don't have a sensible way to name the link within the module itself.</span><span>
</span><span id="line-125"></span><span class="hs-comment">-- Thus, the below &quot;Data.Traversable#overview&quot; works well when shown as</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- @Data.Traversable@ from other modules, but in the home module it should</span><span>
</span><span id="line-127"></span><span class="hs-comment">-- be possible to specify alternative link text. :-(</span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span class="hs-comment">-- | Functors representing data structures that can be transformed to</span><span>
</span><span id="line-130"></span><span class="hs-comment">-- structures of the /same shape/ by performing an 'Applicative' (or,</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- therefore, 'Monad') action on each element from left to right.</span><span>
</span><span id="line-132"></span><span class="hs-comment">--</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- A more detailed description of what /same shape/ means, the various methods,</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- how traversals are constructed, and example advanced use-cases can be found</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- in the __Overview__ section of &quot;Data.Traversable#overview&quot;.</span><span>
</span><span id="line-136"></span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- For the class laws see the __Laws__ section of &quot;Data.Traversable#laws&quot;.</span><span>
</span><span id="line-138"></span><span class="hs-comment">--</span><span>
</span><span id="line-139"></span><span class="hs-keyword">class</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Base.html#Functor"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Foldable.html#Foldable"><span class="hs-identifier hs-type">Foldable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span id="Traversable"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-var">Traversable</span></a></span></span><span> </span><span id="local-6989586621679678341"><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-140"></span><span>    </span><span class="hs-pragma">{-# MINIMAL</span><span> </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-pragma hs-type">traverse</span></a></span><span> </span><span class="hs-pragma">|</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-pragma hs-type">sequenceA</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-comment">-- | Map each element of a structure to an action, evaluate these actions</span><span>
</span><span id="line-143"></span><span>    </span><span class="hs-comment">-- from left to right, and collect the results. For a version that ignores</span><span>
</span><span id="line-144"></span><span>    </span><span class="hs-comment">-- the results see 'Data.Foldable.traverse_'.</span><span>
</span><span id="line-145"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-146"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-148"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-149"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-150"></span><span>    </span><span class="hs-comment">-- In the first two examples we show each evaluated action mapping to the</span><span>
</span><span id="line-151"></span><span>    </span><span class="hs-comment">-- output structure.</span><span>
</span><span id="line-152"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; traverse Just [1,2,3,4]</span><span>
</span><span id="line-154"></span><span>    </span><span class="hs-comment">-- Just [1,2,3,4]</span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-156"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]</span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-comment">-- Right [1,2,3,4]</span><span>
</span><span id="line-158"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-159"></span><span>    </span><span class="hs-comment">-- In the next examples, we show that 'Nothing' and 'Left' values short</span><span>
</span><span id="line-160"></span><span>    </span><span class="hs-comment">-- circuit the created structure.</span><span>
</span><span id="line-161"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-162"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]</span><span>
</span><span id="line-163"></span><span>    </span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-164"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]</span><span>
</span><span id="line-166"></span><span>    </span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-167"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-168"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]</span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-comment">-- Left 0</span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-171"></span><span>    </span><span id="traverse"><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-type">traverse</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679678342"><span id="local-6989586621679678343"><span id="local-6989586621679678344"><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678342"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678343"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678342"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678344"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678343"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678342"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678344"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-pragma hs-type">traverse</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>  </span><span class="hs-comment">-- See Note [Inline default methods]</span><span>
</span><span id="line-173"></span><span>    </span><span id="local-6989586621679678768"><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var">traverse</span></a></span><span> </span><span id="local-6989586621679678774"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678774"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">t (f b) -&gt; f (t b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable t, Applicative f) =&gt;
t (f a) -&gt; f (t a)
forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a)
</span><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-var">sequenceA</span></a></span><span> </span><span class="annot"><span class="annottext">(t (f b) -&gt; f (t b)) -&gt; (t a -&gt; t (f b)) -&gt; t a -&gt; f (t b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; t a -&gt; t (f b)
forall a b. (a -&gt; b) -&gt; t a -&gt; t b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678774"><span class="hs-identifier hs-var">f</span></a></span></span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span>    </span><span class="hs-comment">-- | Evaluate each action in the structure from left to right, and</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">-- collect the results. For a version that ignores the results</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">-- see 'Data.Foldable.sequenceA_'.</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">-- For the first two examples we show sequenceA fully evaluating a</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">-- a structure and collecting the results.</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">-- Just [1,2,3]</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">-- Right [1,2,3]</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">-- The next two example show 'Nothing' and 'Just' will short circuit</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">-- the resulting structure if present in the input. For more context,</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">-- check the 'Traversable' instances for 'Either' and 'Maybe'.</span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-196"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]</span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]</span><span>
</span><span id="line-200"></span><span>    </span><span class="hs-comment">-- Left 4</span><span>
</span><span id="line-201"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-202"></span><span>    </span><span id="sequenceA"><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-type">sequenceA</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679678348"><span id="local-6989586621679678349"><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678348"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678348"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678349"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678348"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678349"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-203"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-pragma hs-type">sequenceA</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>  </span><span class="hs-comment">-- See Note [Inline default methods]</span><span>
</span><span id="line-204"></span><span>    </span><span id="local-6989586621679678775"><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-var hs-var">sequenceA</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(f a -&gt; f a) -&gt; t (f a) -&gt; f (t a)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">f a -&gt; f a
forall a. a -&gt; a
</span><a href="GHC.Base.html#id"><span class="hs-identifier hs-var">id</span></a></span></span><span>
</span><span id="line-205"></span><span>
</span><span id="line-206"></span><span>    </span><span class="hs-comment">-- | Map each element of a structure to a monadic action, evaluate</span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-comment">-- these actions from left to right, and collect the results. For</span><span>
</span><span id="line-208"></span><span>    </span><span class="hs-comment">-- a version that ignores the results see 'Data.Foldable.mapM_'.</span><span>
</span><span id="line-209"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-211"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span>    </span><span class="hs-comment">-- 'mapM' is literally a 'traverse' with a type signature restricted</span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-comment">-- to 'Monad'. Its implementation may be more efficient due to additional</span><span>
</span><span id="line-214"></span><span>    </span><span class="hs-comment">-- power of 'Monad'.</span><span>
</span><span id="line-215"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-216"></span><span>    </span><span id="mapM"><span class="annot"><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-type">mapM</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679678359"><span id="local-6989586621679678360"><span id="local-6989586621679678361"><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678359"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678360"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678359"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678361"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678360"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678359"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678361"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-217"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#mapM"><span class="hs-pragma hs-type">mapM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>  </span><span class="hs-comment">-- See Note [Inline default methods]</span><span>
</span><span id="line-218"></span><span>    </span><span id="local-6989586621679678779"><span class="annot"><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-var hs-var">mapM</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span></span><span>
</span><span id="line-219"></span><span>
</span><span id="line-220"></span><span>    </span><span class="hs-comment">-- | Evaluate each monadic action in the structure from left to</span><span>
</span><span id="line-221"></span><span>    </span><span class="hs-comment">-- right, and collect the results. For a version that ignores the</span><span>
</span><span id="line-222"></span><span>    </span><span class="hs-comment">-- results see 'Data.Foldable.sequence_'.</span><span>
</span><span id="line-223"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-224"></span><span>    </span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-226"></span><span>    </span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-227"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-228"></span><span>    </span><span class="hs-comment">-- The first two examples are instances where the input and</span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-comment">-- and output of 'sequence' are isomorphic.</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-231"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequence $ Right [1,2,3,4]</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-comment">-- [Right 1,Right 2,Right 3,Right 4]</span><span>
</span><span id="line-233"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-234"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]</span><span>
</span><span id="line-235"></span><span>    </span><span class="hs-comment">-- Right [1,2,3,4]</span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-comment">-- The following examples demonstrate short circuit behavior</span><span>
</span><span id="line-238"></span><span>    </span><span class="hs-comment">-- for 'sequence'.</span><span>
</span><span id="line-239"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-240"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequence $ Left [1,2,3,4]</span><span>
</span><span id="line-241"></span><span>    </span><span class="hs-comment">-- Left [1,2,3,4]</span><span>
</span><span id="line-242"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-243"></span><span>    </span><span class="hs-comment">-- &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]</span><span>
</span><span id="line-244"></span><span>    </span><span class="hs-comment">-- Left 0</span><span>
</span><span id="line-245"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-246"></span><span>    </span><span id="sequence"><span class="annot"><a href="Data.Traversable.html#sequence"><span class="hs-identifier hs-type">sequence</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679678366"><span id="local-6989586621679678367"><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678367"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678366"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678341"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678367"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-247"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequence"><span class="hs-pragma hs-type">sequence</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>  </span><span class="hs-comment">-- See Note [Inline default methods]</span><span>
</span><span id="line-248"></span><span>    </span><span id="local-6989586621679678785"><span class="annot"><a href="Data.Traversable.html#sequence"><span class="hs-identifier hs-var hs-var">sequence</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">t (m a) -&gt; m (t a)
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Traversable t, Applicative f) =&gt;
t (f a) -&gt; f (t a)
forall (f :: * -&gt; *) a. Applicative f =&gt; t (f a) -&gt; f (t a)
</span><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-var">sequenceA</span></a></span></span><span>
</span><span id="line-249"></span><span>
</span><span id="line-250"></span><span class="hs-comment">{- Note [Inline default methods]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider

   class ... =&gt; Traversable t where
       ...
       mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
       mapM = traverse   -- Default method

   instance Traversable [] where
       {-# INLINE traverse #-}
       traverse = ...code for traverse on lists ...

This gives rise to a list-instance of mapM looking like this

  $fTraversable[]_$ctraverse = ...code for traverse on lists...
       {-# INLINE $fTraversable[]_$ctraverse #-}
  $fTraversable[]_$cmapM    = $fTraversable[]_$ctraverse

Now the $ctraverse obediently inlines into the RHS of $cmapM, /but/
that's all!  We get

  $fTraversable[]_$cmapM = ...code for traverse on lists...

with NO INLINE pragma!  This happens even though 'traverse' had an
INLINE pragma because the author knew it should be inlined pretty
vigorously.

Indeed, it turned out that the rhs of $cmapM was just too big to
inline, so all uses of mapM on lists used a terribly inefficient
dictionary-passing style, because of its 'Monad m =&gt;' type.  Disaster!

Solution: add an INLINE pragma on the default method:

   class ... =&gt; Traversable t where
       ...
       mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
       {-# INLINE mapM #-}     -- VERY IMPORTANT!
       mapM = traverse
-}</span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span class="hs-comment">-- instances for Prelude types</span><span>
</span><span id="line-292"></span><span>
</span><span id="line-293"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-294"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678798"><span id="local-6989586621679678804"><span id="local-6989586621679678809"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-295"></span><span>    </span><span id="local-6989586621679678819"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Maybe a -&gt; f (Maybe b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe b -&gt; f (Maybe b)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe b
forall a. Maybe a
</span><a href="GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-296"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span id="local-6989586621679678820"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678820"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621679678821"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678821"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Maybe b
forall a. a -&gt; Maybe a
</span><a href="GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Maybe b) -&gt; f b -&gt; f (Maybe b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678820"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678821"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-299"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678831"><span id="local-6989586621679678837"><span id="local-6989586621679678842"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-300"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-pragma hs-type">traverse</span></a></span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="hs-comment">-- so that traverse can fuse</span><span>
</span><span id="line-301"></span><span>    </span><span id="local-6989586621679678849"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679678850"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678850"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; f [b] -&gt; f [b]) -&gt; f [b] -&gt; [a] -&gt; f [b]
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
</span><a href="GHC.Base.html#foldr"><span class="hs-identifier hs-var">List.foldr</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f [b] -&gt; f [b]
</span><a href="#local-6989586621679678851"><span class="hs-identifier hs-var">cons_f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[b] -&gt; f [b]
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>      </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679678851"><span class="annot"><span class="annottext">cons_f :: a -&gt; f [b] -&gt; f [b]
</span><a href="#local-6989586621679678851"><span class="hs-identifier hs-var hs-var">cons_f</span></a></span></span><span> </span><span id="local-6989586621679678854"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678854"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679678855"><span class="annot"><span class="annottext">f [b]
</span><a href="#local-6989586621679678855"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b -&gt; [b] -&gt; [b]) -&gt; f b -&gt; f [b] -&gt; f [b]
forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><a href="GHC.Base.html#liftA2"><span class="hs-identifier hs-var">liftA2</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678850"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678854"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f [b]
</span><a href="#local-6989586621679678855"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-305"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678865"><span id="local-6989586621679678871"><span id="local-6989586621679678876"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Base.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-306"></span><span>  </span><span id="local-6989586621679678884"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; NonEmpty a -&gt; f (NonEmpty b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679678885"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678885"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">~</span><span class="hs-special">(</span><span id="local-6989586621679678886"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678886"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="annot"><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679678888"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679678888"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b -&gt; [b] -&gt; NonEmpty b) -&gt; f b -&gt; f [b] -&gt; f (NonEmpty b)
forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><a href="GHC.Base.html#liftA2"><span class="hs-identifier hs-var">liftA2</span></a></span><span> </span><span class="annot"><span class="annottext">b -&gt; [b] -&gt; NonEmpty b
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><a href="GHC.Base.html#%3A%7C"><span class="hs-operator hs-var">(:|)</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678885"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678886"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; [a] -&gt; f [b]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678885"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679678888"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span class="annot"><span class="hs-comment">-- | @since 4.7.0.0</span></span><span>
</span><span id="line-309"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678404"><span id="local-6989586621679678897"><span id="local-6989586621679678903"><span id="local-6989586621679678908"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678404"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-310"></span><span>    </span><span id="local-6989586621679678916"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Either a a -&gt; f (Either a b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Left"><span class="hs-identifier hs-type">Left</span></a></span><span> </span><span id="local-6989586621679678917"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678917"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Either a b -&gt; f (Either a b)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Either a b
forall a b. a -&gt; Either a b
</span><a href="Data.Either.html#Left"><span class="hs-identifier hs-var">Left</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678917"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-311"></span><span>    </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span id="local-6989586621679678918"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678918"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Either.html#Right"><span class="hs-identifier hs-type">Right</span></a></span><span> </span><span id="local-6989586621679678919"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678919"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Either a b
forall a b. b -&gt; Either a b
</span><a href="Data.Either.html#Right"><span class="hs-identifier hs-var">Right</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Either a b) -&gt; f b -&gt; f (Either a b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678918"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678919"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-312"></span><span>
</span><span id="line-313"></span><span class="annot"><span class="hs-comment">-- | @since 4.15</span></span><span>
</span><span id="line-314"></span><span id="local-6989586621679678927"><span id="local-6989586621679678932"><span id="local-6989586621679678938"><span id="local-6989586621679678943"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Tuple.Prim.html#Solo/GHC.Tuple.Prim.html#Solo"><span class="hs-identifier hs-type">Solo</span></a></span></span></span></span></span><span>
</span><span id="line-315"></span><span>
</span><span id="line-316"></span><span class="annot"><span class="hs-comment">-- | @since 4.7.0.0</span></span><span>
</span><span id="line-317"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678418"><span id="local-6989586621679678955"><span id="local-6989586621679678961"><span id="local-6989586621679678966"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679678418"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-318"></span><span>    </span><span id="local-6989586621679678973"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; (a, a) -&gt; f (a, b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679678974"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678974"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679678975"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678975"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679678976"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678976"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678975"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; (a, b)) -&gt; f b -&gt; f (a, b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679678974"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679678976"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-319"></span><span>
</span><span id="line-320"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-321"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678430"><span id="local-6989586621679678986"><span id="local-6989586621679678992"><span id="local-6989586621679678997"><span class="annot"><a href="GHC.Ix.html#Ix"><span class="hs-identifier hs-type">Ix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678430"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Arr.html#Array"><span class="hs-identifier hs-type">Array</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678430"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-322"></span><span>    </span><span id="local-6989586621679679007"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Array i a -&gt; f (Array i b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679008"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679008"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679679009"><span class="annot"><span class="annottext">Array i a
</span><a href="#local-6989586621679679009"><span class="hs-identifier hs-var">arr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(i, i) -&gt; [b] -&gt; Array i b
forall i e. Ix i =&gt; (i, i) -&gt; [e] -&gt; Array i e
</span><a href="GHC.Arr.html#listArray"><span class="hs-identifier hs-var">listArray</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Array i a -&gt; (i, i)
forall i e. Array i e -&gt; (i, i)
</span><a href="GHC.Arr.html#bounds"><span class="hs-identifier hs-var">bounds</span></a></span><span> </span><span class="annot"><span class="annottext">Array i a
</span><a href="#local-6989586621679679009"><span class="hs-identifier hs-var">arr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([b] -&gt; Array i b) -&gt; f [b] -&gt; f (Array i b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="GHC.Base.html#fmap"><span class="hs-operator hs-var">`fmap`</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; [a] -&gt; f [b]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679008"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Array i a -&gt; [a]
forall i e. Array i e -&gt; [e]
</span><a href="GHC.Arr.html#elems"><span class="hs-identifier hs-var">elems</span></a></span><span> </span><span class="annot"><span class="annottext">Array i a
</span><a href="#local-6989586621679679009"><span class="hs-identifier hs-var">arr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-323"></span><span>
</span><span id="line-324"></span><span class="annot"><span class="hs-comment">-- | @since 4.7.0.0</span></span><span>
</span><span id="line-325"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-type">Proxy</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-326"></span><span>    </span><span id="local-6989586621679679026"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Proxy a -&gt; f (Proxy b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Proxy b -&gt; f (Proxy b)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">Proxy b
forall {k} (t :: k). Proxy t
</span><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-var">Proxy</span></a></span><span>
</span><span id="line-327"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-pragma hs-type">traverse</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-328"></span><span>    </span><span id="local-6989586621679679030"><span class="annot"><span class="annottext">sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; Proxy (f a) -&gt; f (Proxy a)
</span><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequenceA</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy (f a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Proxy a -&gt; f (Proxy a)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">Proxy a
forall {k} (t :: k). Proxy t
</span><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-var">Proxy</span></a></span><span>
</span><span id="line-329"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-pragma hs-type">sequenceA</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-330"></span><span>    </span><span id="local-6989586621679679034"><span class="annot"><span class="annottext">mapM :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
(a -&gt; m b) -&gt; Proxy a -&gt; m (Proxy b)
</span><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-var hs-var hs-var hs-var">mapM</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Proxy a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Proxy b -&gt; m (Proxy b)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">Proxy b
forall {k} (t :: k). Proxy t
</span><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-var">Proxy</span></a></span><span>
</span><span id="line-331"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#mapM"><span class="hs-pragma hs-type">mapM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-332"></span><span>    </span><span id="local-6989586621679679038"><span class="annot"><span class="annottext">sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; Proxy (m a) -&gt; m (Proxy a)
</span><a href="Data.Traversable.html#sequence"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence</span></a></span></span><span> </span><span class="annot"><span class="annottext">Proxy (m a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Proxy a -&gt; m (Proxy a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">Proxy a
forall {k} (t :: k). Proxy t
</span><a href="Data.Proxy.html#Proxy"><span class="hs-identifier hs-var">Proxy</span></a></span><span>
</span><span id="line-333"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequence"><span class="hs-pragma hs-type">sequence</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-334"></span><span>
</span><span id="line-335"></span><span class="annot"><span class="hs-comment">-- | @since 4.7.0.0</span></span><span>
</span><span id="line-336"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678458"><span id="local-6989586621679679047"><span id="local-6989586621679679053"><span id="local-6989586621679679058"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Const.html#Const"><span class="hs-identifier hs-type">Const</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678458"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-337"></span><span>    </span><span id="local-6989586621679679064"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Const m a -&gt; f (Const m b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Const.html#Const"><span class="hs-identifier hs-type">Const</span></a></span><span> </span><span id="local-6989586621679679066"><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679679066"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Const m b -&gt; f (Const m b)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(Const m b -&gt; f (Const m b)) -&gt; Const m b -&gt; f (Const m b)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">m -&gt; Const m b
forall {k} a (b :: k). a -&gt; Const a b
</span><a href="Data.Functor.Const.html#Const"><span class="hs-identifier hs-var">Const</span></a></span><span> </span><span class="annot"><span class="annottext">m
</span><a href="#local-6989586621679679066"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-338"></span><span>
</span><span id="line-339"></span><span class="annot"><span class="hs-comment">-- | @since 4.8.0.0</span></span><span>
</span><span id="line-340"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679075"><span id="local-6989586621679679081"><span id="local-6989586621679679086"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-type">Dual</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-341"></span><span>    </span><span id="local-6989586621679679093"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Dual a -&gt; f (Dual b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679094"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679094"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-type">Dual</span></a></span><span> </span><span id="local-6989586621679679096"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679096"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Dual b
forall a. a -&gt; Dual a
</span><a href="Data.Semigroup.Internal.html#Dual"><span class="hs-identifier hs-var">Dual</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Dual b) -&gt; f b -&gt; f (Dual b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679094"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679096"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="annot"><span class="hs-comment">-- | @since 4.8.0.0</span></span><span>
</span><span id="line-344"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679105"><span id="local-6989586621679679111"><span id="local-6989586621679679116"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-type">Sum</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-345"></span><span>    </span><span id="local-6989586621679679123"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Sum a -&gt; f (Sum b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679124"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679124"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-type">Sum</span></a></span><span> </span><span id="local-6989586621679679126"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679126"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Sum b
forall a. a -&gt; Sum a
</span><a href="Data.Semigroup.Internal.html#Sum"><span class="hs-identifier hs-var">Sum</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Sum b) -&gt; f b -&gt; f (Sum b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679124"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679126"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-346"></span><span>
</span><span id="line-347"></span><span class="annot"><span class="hs-comment">-- | @since 4.8.0.0</span></span><span>
</span><span id="line-348"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679135"><span id="local-6989586621679679141"><span id="local-6989586621679679146"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-type">Product</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-349"></span><span>    </span><span id="local-6989586621679679153"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Product a -&gt; f (Product b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679154"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679154"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-type">Product</span></a></span><span> </span><span id="local-6989586621679679156"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679156"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Product b
forall a. a -&gt; Product a
</span><a href="Data.Semigroup.Internal.html#Product"><span class="hs-identifier hs-var">Product</span></a></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Product b) -&gt; f b -&gt; f (Product b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679154"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679679156"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span class="annot"><span class="hs-comment">-- | @since 4.8.0.0</span></span><span>
</span><span id="line-352"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679165"><span id="local-6989586621679679171"><span id="local-6989586621679679176"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Monoid.html#First"><span class="hs-identifier hs-type">First</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-353"></span><span>    </span><span id="local-6989586621679679185"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; First a -&gt; f (First b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679186"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679186"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Monoid.html#First"><span class="hs-identifier hs-type">First</span></a></span><span> </span><span id="local-6989586621679679188"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679679188"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe b -&gt; First b
forall a. Maybe a -&gt; First a
</span><a href="Data.Monoid.html#First"><span class="hs-identifier hs-var">First</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; First b) -&gt; f (Maybe b) -&gt; f (First b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; Maybe a -&gt; f (Maybe b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Maybe a -&gt; f (Maybe b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679186"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679679188"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span class="annot"><span class="hs-comment">-- | @since 4.8.0.0</span></span><span>
</span><span id="line-356"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679197"><span id="local-6989586621679679203"><span id="local-6989586621679679208"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Monoid.html#Last"><span class="hs-identifier hs-type">Last</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-357"></span><span>    </span><span id="local-6989586621679679217"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Last a -&gt; f (Last b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679218"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679218"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Monoid.html#Last"><span class="hs-identifier hs-type">Last</span></a></span><span> </span><span id="local-6989586621679679220"><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679679220"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe b -&gt; Last b
forall a. Maybe a -&gt; Last a
</span><a href="Data.Monoid.html#Last"><span class="hs-identifier hs-var">Last</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; Last b) -&gt; f (Maybe b) -&gt; f (Last b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; Maybe a -&gt; f (Maybe b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Maybe a -&gt; f (Maybe b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679218"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679679220"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-358"></span><span>
</span><span id="line-359"></span><span class="annot"><span class="hs-comment">-- | @since 4.12.0.0</span></span><span>
</span><span id="line-360"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678515"><span id="local-6989586621679679232"><span id="local-6989586621679679238"><span id="local-6989586621679679243"><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678515"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678515"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-361"></span><span>    </span><span id="local-6989586621679679252"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Alt f a -&gt; f (Alt f b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679253"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679253"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Semigroup.Internal.html#Alt"><span class="hs-identifier hs-type">Alt</span></a></span><span> </span><span id="local-6989586621679679255"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679679255"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f b -&gt; Alt f b
forall {k} (f :: k -&gt; *) (a :: k). f a -&gt; Alt f a
</span><a href="Data.Semigroup.Internal.html#Alt"><span class="hs-identifier hs-var">Alt</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Alt f b) -&gt; f (f b) -&gt; f (Alt f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; f a -&gt; f (f b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679253"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679679255"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="annot"><span class="hs-comment">-- | @since 4.12.0.0</span></span><span>
</span><span id="line-364"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679678529"><span id="local-6989586621679679267"><span id="local-6989586621679679273"><span id="local-6989586621679679278"><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678529"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Monoid.html#Ap"><span class="hs-identifier hs-type">Ap</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678529"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-365"></span><span>    </span><span id="local-6989586621679679287"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; Ap f a -&gt; f (Ap f b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679288"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679288"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Monoid.html#Ap"><span class="hs-identifier hs-type">Ap</span></a></span><span> </span><span id="local-6989586621679679290"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679679290"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f b -&gt; Ap f b
forall {k} (f :: k -&gt; *) (a :: k). f a -&gt; Ap f a
</span><a href="Data.Monoid.html#Ap"><span class="hs-identifier hs-var">Ap</span></a></span><span> </span><span class="annot"><span class="annottext">(f b -&gt; Ap f b) -&gt; f (f b) -&gt; f (Ap f b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; f a -&gt; f (f b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; f a -&gt; f (f b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679288"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679679290"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-366"></span><span>
</span><span id="line-367"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-368"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679679299"><span id="local-6989586621679679305"><span id="local-6989586621679679310"><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Control.Applicative.html#ZipList"><span class="hs-identifier hs-type">ZipList</span></a></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-369"></span><span>    </span><span id="local-6989586621679679319"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; ZipList a -&gt; f (ZipList b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span id="local-6989586621679679320"><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679320"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Applicative.html#ZipList"><span class="hs-identifier hs-type">ZipList</span></a></span><span> </span><span id="local-6989586621679679322"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679679322"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[b] -&gt; ZipList b
forall a. [a] -&gt; ZipList a
</span><a href="Control.Applicative.html#ZipList"><span class="hs-identifier hs-var">ZipList</span></a></span><span> </span><span class="annot"><span class="annottext">([b] -&gt; ZipList b) -&gt; f [b] -&gt; f (ZipList b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; [a] -&gt; f [b]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><a href="#local-6989586621679679320"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679679322"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-372"></span><span id="local-6989586621679679330"><span id="local-6989586621679679335"><span id="local-6989586621679679341"><span id="local-6989586621679679346"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Functor.Identity.html#Identity"><span class="hs-identifier hs-type">Identity</span></a></span></span></span></span></span><span>
</span><span id="line-373"></span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span class="hs-comment">-- Instances for GHC.Generics</span><span>
</span><span id="line-376"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-377"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-type">U1</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-378"></span><span>    </span><span id="local-6989586621679679363"><span class="annot"><span class="annottext">traverse :: forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; U1 a -&gt; f (U1 b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var hs-var hs-var hs-var">traverse</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; f b
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">U1 b -&gt; f (U1 b)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">U1 b
forall k (p :: k). U1 p
</span><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-var">U1</span></a></span><span>
</span><span id="line-379"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#traverse"><span class="hs-pragma hs-type">traverse</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-380"></span><span>    </span><span id="local-6989586621679679367"><span class="annot"><span class="annottext">sequenceA :: forall (f :: * -&gt; *) a. Applicative f =&gt; U1 (f a) -&gt; f (U1 a)
</span><a href="Data.Traversable.html#sequenceA"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequenceA</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 (f a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">U1 a -&gt; f (U1 a)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">U1 a
forall k (p :: k). U1 p
</span><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-var">U1</span></a></span><span>
</span><span id="line-381"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequenceA"><span class="hs-pragma hs-type">sequenceA</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-382"></span><span>    </span><span id="local-6989586621679679371"><span class="annot"><span class="annottext">mapM :: forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; U1 a -&gt; m (U1 b)
</span><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-var hs-var hs-var hs-var">mapM</span></a></span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m b
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">U1 a
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">U1 b -&gt; m (U1 b)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">U1 b
forall k (p :: k). U1 p
</span><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-var">U1</span></a></span><span>
</span><span id="line-383"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#mapM"><span class="hs-pragma hs-type">mapM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-384"></span><span>    </span><span id="local-6989586621679679375"><span class="annot"><span class="annottext">sequence :: forall (m :: * -&gt; *) a. Monad m =&gt; U1 (m a) -&gt; m (U1 a)
</span><a href="Data.Traversable.html#sequence"><span class="hs-identifier hs-var hs-var hs-var hs-var">sequence</span></a></span></span><span> </span><span class="annot"><span class="annottext">U1 (m a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">U1 a -&gt; m (U1 a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">U1 a
forall k (p :: k). U1 p
</span><a href="GHC.Generics.html#U1"><span class="hs-identifier hs-var">U1</span></a></span><span>
</span><span id="line-385"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#sequence"><span class="hs-pragma hs-type">sequence</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-386"></span><span>
</span><span id="line-387"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-388"></span><span id="local-6989586621679679383"><span id="local-6989586621679679388"><span id="local-6989586621679679394"><span id="local-6989586621679679399"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#V1"><span class="hs-identifier hs-type">V1</span></a></span></span></span></span></span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-391"></span><span id="local-6989586621679679410"><span id="local-6989586621679679415"><span id="local-6989586621679679421"><span id="local-6989586621679679426"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#Par1"><span class="hs-identifier hs-type">Par1</span></a></span></span></span></span></span><span>
</span><span id="line-392"></span><span>
</span><span id="line-393"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-394"></span><span id="local-6989586621679678579"><span id="local-6989586621679679440"><span id="local-6989586621679679447"><span id="local-6989586621679679453"><span id="local-6989586621679679458"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678579"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#Rec1"><span class="hs-identifier hs-type">Rec1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678579"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-397"></span><span id="local-6989586621679678588"><span id="local-6989586621679678589"><span id="local-6989586621679679469"><span id="local-6989586621679679474"><span id="local-6989586621679679480"><span id="local-6989586621679679485"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#K1"><span class="hs-identifier hs-type">K1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678588"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678589"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span>
</span><span id="line-398"></span><span>
</span><span id="line-399"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-400"></span><span id="local-6989586621679678604"><span id="local-6989586621679678605"><span id="local-6989586621679678606"><span id="local-6989586621679679499"><span id="local-6989586621679679506"><span id="local-6989586621679679512"><span id="local-6989586621679679517"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678604"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Generics.html#M1"><span class="hs-identifier hs-type">M1</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678605"><span class="hs-identifier hs-type">i</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678606"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678604"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span></span><span>
</span><span id="line-401"></span><span>
</span><span id="line-402"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-403"></span><span id="local-6989586621679678617"><span id="local-6989586621679678618"><span id="local-6989586621679679534"><span id="local-6989586621679679544"><span id="local-6989586621679679550"><span id="local-6989586621679679555"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678617"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678618"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678617"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A%2B%3A"><span class="hs-operator hs-type">:+:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678618"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span>
</span><span id="line-404"></span><span>
</span><span id="line-405"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-406"></span><span id="local-6989586621679678629"><span id="local-6989586621679678630"><span id="local-6989586621679679572"><span id="local-6989586621679679580"><span id="local-6989586621679679586"><span id="local-6989586621679679591"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678629"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678630"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678629"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A%2A%3A"><span class="hs-operator hs-type">:*:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678630"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-409"></span><span id="local-6989586621679678641"><span id="local-6989586621679678642"><span id="local-6989586621679679608"><span id="local-6989586621679679617"><span id="local-6989586621679679623"><span id="local-6989586621679679628"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678641"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678642"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678641"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#%3A.%3A"><span class="hs-operator hs-type">:.:</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678642"><span class="hs-identifier hs-type">g</span></a></span><span class="hs-special">)</span></span></span></span></span></span></span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-412"></span><span id="local-6989586621679679639"><span id="local-6989586621679679643"><span id="local-6989586621679679649"><span id="local-6989586621679679654"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UAddr"><span class="hs-identifier hs-type">UAddr</span></a></span></span></span></span></span><span>
</span><span id="line-413"></span><span>
</span><span id="line-414"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-415"></span><span id="local-6989586621679679665"><span id="local-6989586621679679669"><span id="local-6989586621679679675"><span id="local-6989586621679679680"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UChar"><span class="hs-identifier hs-type">UChar</span></a></span></span></span></span></span><span>
</span><span id="line-416"></span><span>
</span><span id="line-417"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-418"></span><span id="local-6989586621679679691"><span id="local-6989586621679679695"><span id="local-6989586621679679701"><span id="local-6989586621679679706"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UDouble"><span class="hs-identifier hs-type">UDouble</span></a></span></span></span></span></span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-421"></span><span id="local-6989586621679679717"><span id="local-6989586621679679721"><span id="local-6989586621679679727"><span id="local-6989586621679679732"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UFloat"><span class="hs-identifier hs-type">UFloat</span></a></span></span></span></span></span><span>
</span><span id="line-422"></span><span>
</span><span id="line-423"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-424"></span><span id="local-6989586621679679743"><span id="local-6989586621679679747"><span id="local-6989586621679679753"><span id="local-6989586621679679758"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UInt"><span class="hs-identifier hs-type">UInt</span></a></span></span></span></span></span><span>
</span><span id="line-425"></span><span>
</span><span id="line-426"></span><span class="annot"><span class="hs-comment">-- | @since 4.9.0.0</span></span><span>
</span><span id="line-427"></span><span id="local-6989586621679679769"><span id="local-6989586621679679773"><span id="local-6989586621679679779"><span id="local-6989586621679679784"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="GHC.Generics.html#UWord"><span class="hs-identifier hs-type">UWord</span></a></span></span></span></span></span><span>
</span><span id="line-428"></span><span>
</span><span id="line-429"></span><span class="hs-comment">-- Instance for Data.Ord</span><span>
</span><span id="line-430"></span><span class="annot"><span class="hs-comment">-- | @since 4.12.0.0</span></span><span>
</span><span id="line-431"></span><span id="local-6989586621679679795"><span id="local-6989586621679679800"><span id="local-6989586621679679806"><span id="local-6989586621679679811"><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="Data.Ord.html#Down"><span class="hs-identifier hs-type">Down</span></a></span></span></span></span></span><span>
</span><span id="line-432"></span><span>
</span><span id="line-433"></span><span class="hs-comment">-- general functions</span><span>
</span><span id="line-434"></span><span>
</span><span id="line-435"></span><span class="hs-comment">-- | 'for' is 'traverse' with its arguments flipped. For a version</span><span>
</span><span id="line-436"></span><span class="hs-comment">-- that ignores the results see 'Data.Foldable.for_'.</span><span>
</span><span id="line-437"></span><span id="local-6989586621679678672"><span id="local-6989586621679678673"><span id="local-6989586621679678674"><span id="local-6989586621679678675"><span class="annot"><a href="Data.Traversable.html#for"><span class="hs-identifier hs-type">for</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678672"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678673"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678672"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678674"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678674"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678673"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678675"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678673"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678672"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678675"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-438"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#for"><span class="hs-pragma hs-type">for</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-439"></span><span id="for"><span class="annot"><span class="annottext">for :: forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
t a -&gt; (a -&gt; f b) -&gt; f (t b)
</span><a href="Data.Traversable.html#for"><span class="hs-identifier hs-var hs-var">for</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; f b) -&gt; t a -&gt; f (t b)) -&gt; t a -&gt; (a -&gt; f b) -&gt; f (t b)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span class="hs-comment">-- | 'forM' is 'mapM' with its arguments flipped. For a version that</span><span>
</span><span id="line-442"></span><span class="hs-comment">-- ignores the results see 'Data.Foldable.forM_'.</span><span>
</span><span id="line-443"></span><span id="local-6989586621679678683"><span id="local-6989586621679678684"><span id="local-6989586621679678685"><span id="local-6989586621679678686"><span class="annot"><a href="Data.Traversable.html#forM"><span class="hs-identifier hs-type">forM</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678683"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678684"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678683"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678685"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678685"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678684"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678686"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678684"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678683"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678686"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span><span>
</span><span id="line-444"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#forM"><span class="hs-pragma hs-type">forM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-445"></span><span id="forM"><span class="annot"><span class="annottext">forM :: forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
t a -&gt; (a -&gt; m b) -&gt; m (t b)
</span><a href="Data.Traversable.html#forM"><span class="hs-identifier hs-var hs-var">forM</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; m b) -&gt; t a -&gt; m (t b)) -&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-var">mapM</span></a></span><span>
</span><span id="line-446"></span><span>
</span><span id="line-447"></span><span class="hs-comment">-- |The 'mapAccumL' function behaves like a combination of 'fmap'</span><span>
</span><span id="line-448"></span><span class="hs-comment">-- and 'Data.Foldable.foldl'; it applies a function to each element of a structure,</span><span>
</span><span id="line-449"></span><span class="hs-comment">-- passing an accumulating parameter from left to right, and returning</span><span>
</span><span id="line-450"></span><span class="hs-comment">-- a final value of this accumulator together with the new structure.</span><span>
</span><span id="line-451"></span><span class="hs-comment">--</span><span>
</span><span id="line-452"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-453"></span><span class="hs-comment">--</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-455"></span><span class="hs-comment">--</span><span>
</span><span id="line-456"></span><span class="hs-comment">-- &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]</span><span>
</span><span id="line-457"></span><span class="hs-comment">-- (55,[0,1,3,6,10,15,21,28,36,45])</span><span>
</span><span id="line-458"></span><span class="hs-comment">--</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) &quot;0&quot; [1..5]</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- (&quot;012345&quot;,[&quot;0&quot;,&quot;01&quot;,&quot;012&quot;,&quot;0123&quot;,&quot;01234&quot;])</span><span>
</span><span id="line-461"></span><span class="hs-comment">--</span><span>
</span><span id="line-462"></span><span class="annot"><a href="Data.Traversable.html#mapAccumL"><span class="hs-identifier hs-type">mapAccumL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679678691"><span class="annot"><a href="#local-6989586621679678691"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span id="local-6989586621679678692"><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679678693"><span class="annot"><a href="#local-6989586621679678693"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679678694"><span class="annot"><a href="#local-6989586621679678694"><span class="hs-identifier hs-type">b</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678691"><span class="hs-identifier hs-type">t</span></a></span><span>
</span><span id="line-463"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678693"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678694"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678691"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678693"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678691"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678694"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-464"></span><span class="hs-comment">-- See Note [Function coercion] in Data.Functor.Utils.</span><span>
</span><span id="line-465"></span><span id="mapAccumL"><span class="annot"><span class="annottext">mapAccumL :: forall (t :: * -&gt; *) s a b.
Traversable t =&gt;
(s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b)
</span><a href="Data.Traversable.html#mapAccumL"><span class="hs-identifier hs-var hs-var">mapAccumL</span></a></span></span><span> </span><span id="local-6989586621679679831"><span class="annot"><span class="annottext">s -&gt; a -&gt; (s, b)
</span><a href="#local-6989586621679679831"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679679832"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679832"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679679833"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679833"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; StateL s b) -&gt; t a -&gt; StateL s (t b))
-&gt; (a -&gt; s -&gt; (s, b)) -&gt; t a -&gt; s -&gt; (s, t b)
forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#coerce/GHC.Prim.html#coerce"><span class="hs-identifier hs-var">coerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678691"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Utils.html#StateL"><span class="hs-identifier hs-type">StateL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678692"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678693"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678694"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(s -&gt; a -&gt; (s, b)) -&gt; a -&gt; s -&gt; (s, b)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">s -&gt; a -&gt; (s, b)
</span><a href="#local-6989586621679679831"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679833"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679832"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-466"></span><span>
</span><span id="line-467"></span><span class="hs-comment">-- |The 'mapAccumR' function behaves like a combination of 'fmap'</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- and 'Data.Foldable.foldr'; it applies a function to each element of a structure,</span><span>
</span><span id="line-469"></span><span class="hs-comment">-- passing an accumulating parameter from right to left, and returning</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- a final value of this accumulator together with the new structure.</span><span>
</span><span id="line-471"></span><span class="hs-comment">--</span><span>
</span><span id="line-472"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-473"></span><span class="hs-comment">--</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-475"></span><span class="hs-comment">--</span><span>
</span><span id="line-476"></span><span class="hs-comment">-- &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- (55,[54,52,49,45,40,34,27,19,10,0])</span><span>
</span><span id="line-478"></span><span class="hs-comment">--</span><span>
</span><span id="line-479"></span><span class="hs-comment">-- &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) &quot;0&quot; [1..5]</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- (&quot;054321&quot;,[&quot;05432&quot;,&quot;0543&quot;,&quot;054&quot;,&quot;05&quot;,&quot;0&quot;])</span><span>
</span><span id="line-481"></span><span class="hs-comment">--</span><span>
</span><span id="line-482"></span><span class="annot"><a href="Data.Traversable.html#mapAccumR"><span class="hs-identifier hs-type">mapAccumR</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679679835"><span class="annot"><a href="#local-6989586621679679835"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span id="local-6989586621679679836"><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679679837"><span class="annot"><a href="#local-6989586621679679837"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679679838"><span class="annot"><a href="#local-6989586621679679838"><span class="hs-identifier hs-type">b</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679679835"><span class="hs-identifier hs-type">t</span></a></span><span>
</span><span id="line-483"></span><span>          </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679679837"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679679838"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679679835"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679679837"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679679835"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679679838"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-484"></span><span class="hs-comment">-- See Note [Function coercion] in Data.Functor.Utils.</span><span>
</span><span id="line-485"></span><span id="mapAccumR"><span class="annot"><span class="annottext">mapAccumR :: forall (t :: * -&gt; *) s a b.
Traversable t =&gt;
(s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b)
</span><a href="Data.Traversable.html#mapAccumR"><span class="hs-identifier hs-var hs-var">mapAccumR</span></a></span></span><span> </span><span id="local-6989586621679679844"><span class="annot"><span class="annottext">s -&gt; a -&gt; (s, b)
</span><a href="#local-6989586621679679844"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679679845"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679845"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679679846"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679846"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; StateR s b) -&gt; t a -&gt; StateR s (t b))
-&gt; (a -&gt; s -&gt; (s, b)) -&gt; t a -&gt; s -&gt; (s, t b)
forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#coerce/GHC.Prim.html#coerce"><span class="hs-identifier hs-var">coerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679679835"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Utils.html#StateR"><span class="hs-identifier hs-type">StateR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679679836"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679679837"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679679838"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(s -&gt; a -&gt; (s, b)) -&gt; a -&gt; s -&gt; (s, b)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">s -&gt; a -&gt; (s, b)
</span><a href="#local-6989586621679679844"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679846"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679845"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-486"></span><span>
</span><span id="line-487"></span><span class="hs-comment">-- | The `mapAccumM` function behaves like a combination of `mapM` and</span><span>
</span><span id="line-488"></span><span class="hs-comment">-- `mapAccumL` that traverses the structure while evaluating the actions</span><span>
</span><span id="line-489"></span><span class="hs-comment">-- and passing an accumulating parameter from left to right.</span><span>
</span><span id="line-490"></span><span class="hs-comment">-- It returns a final value of this accumulator together with the new structure.</span><span>
</span><span id="line-491"></span><span class="hs-comment">-- The accummulator is often used for caching the intermediate results of a computation.</span><span>
</span><span id="line-492"></span><span class="hs-comment">--</span><span>
</span><span id="line-493"></span><span class="hs-comment">--  @since 4.18.0.0</span><span>
</span><span id="line-494"></span><span class="hs-comment">--</span><span>
</span><span id="line-495"></span><span class="hs-comment">-- ==== __Examples__</span><span>
</span><span id="line-496"></span><span class="hs-comment">--</span><span>
</span><span id="line-497"></span><span class="hs-comment">-- Basic usage:</span><span>
</span><span id="line-498"></span><span class="hs-comment">--</span><span>
</span><span id="line-499"></span><span class="hs-comment">-- &gt;&gt;&gt; let expensiveDouble a = putStrLn (&quot;Doubling &quot; &lt;&gt; show a) &gt;&gt; pure (2 * a)</span><span>
</span><span id="line-500"></span><span class="hs-comment">-- &gt;&gt;&gt; :{</span><span>
</span><span id="line-501"></span><span class="hs-comment">-- mapAccumM (\cache a -&gt; case lookup a cache of</span><span>
</span><span id="line-502"></span><span class="hs-comment">--     Nothing -&gt; expensiveDouble a &gt;&gt;= \double -&gt; pure ((a, double):cache, double)</span><span>
</span><span id="line-503"></span><span class="hs-comment">--     Just double -&gt; pure (cache, double)</span><span>
</span><span id="line-504"></span><span class="hs-comment">--     ) [] [1, 2, 3, 1, 2, 3]</span><span>
</span><span id="line-505"></span><span class="hs-comment">-- :}</span><span>
</span><span id="line-506"></span><span class="hs-comment">-- Doubling 1</span><span>
</span><span id="line-507"></span><span class="hs-comment">-- Doubling 2</span><span>
</span><span id="line-508"></span><span class="hs-comment">-- Doubling 3</span><span>
</span><span id="line-509"></span><span class="hs-comment">-- ([(3,6),(2,4),(1,2)],[2,4,6,2,4,6])</span><span>
</span><span id="line-510"></span><span class="hs-comment">--</span><span>
</span><span id="line-511"></span><span class="annot"><a href="Data.Traversable.html#mapAccumM"><span class="hs-identifier hs-type">mapAccumM</span></a></span><span>
</span><span id="line-512"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679678707"><span class="annot"><a href="#local-6989586621679678707"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679678708"><span class="annot"><a href="#local-6989586621679678708"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span id="local-6989586621679678709"><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679678710"><span class="annot"><a href="#local-6989586621679678710"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679678711"><span class="annot"><a href="#local-6989586621679678711"><span class="hs-identifier hs-type">b</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678707"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678708"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-513"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678710"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678707"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678711"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678708"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678710"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678707"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678708"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678711"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-515"></span><span id="mapAccumM"><span class="annot"><span class="annottext">mapAccumM :: forall (m :: * -&gt; *) (t :: * -&gt; *) s a b.
(Monad m, Traversable t) =&gt;
(s -&gt; a -&gt; m (s, b)) -&gt; s -&gt; t a -&gt; m (s, t b)
</span><a href="Data.Traversable.html#mapAccumM"><span class="hs-identifier hs-var hs-var">mapAccumM</span></a></span></span><span> </span><span id="local-6989586621679679854"><span class="annot"><span class="annottext">s -&gt; a -&gt; m (s, b)
</span><a href="#local-6989586621679679854"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679679855"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679855"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679679856"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679856"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; StateT s m b) -&gt; t a -&gt; StateT s m (t b))
-&gt; (a -&gt; StateT s m b) -&gt; t a -&gt; s -&gt; m (s, t b)
forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#coerce/GHC.Prim.html#coerce"><span class="hs-identifier hs-var">coerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><a href="Data.Traversable.html#mapM"><span class="hs-identifier hs-var">mapM</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678708"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Utils.html#StateT"><span class="hs-identifier hs-type">StateT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678709"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678707"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678710"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678711"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(s -&gt; m (s, b)) -&gt; StateT s m b
forall s (m :: * -&gt; *) a. (s -&gt; m (s, a)) -&gt; StateT s m a
</span><a href="Data.Functor.Utils.html#StateT"><span class="hs-identifier hs-var">StateT</span></a></span><span> </span><span class="annot"><span class="annottext">((s -&gt; m (s, b)) -&gt; StateT s m b)
-&gt; (a -&gt; s -&gt; m (s, b)) -&gt; a -&gt; StateT s m b
forall b c a. Coercible b c =&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="Data.Functor.Utils.html#%23."><span class="hs-operator hs-var">#.</span></a></span><span> </span><span class="annot"><span class="annottext">(s -&gt; a -&gt; m (s, b)) -&gt; a -&gt; s -&gt; m (s, b)
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="GHC.Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">s -&gt; a -&gt; m (s, b)
</span><a href="#local-6989586621679679854"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679856"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679855"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-516"></span><span>
</span><span id="line-517"></span><span class="hs-comment">-- | 'forAccumM' is 'mapAccumM' with the arguments rearranged.</span><span>
</span><span id="line-518"></span><span class="hs-comment">--</span><span>
</span><span id="line-519"></span><span class="hs-comment">-- @since 4.18.0.0</span><span>
</span><span id="line-520"></span><span id="local-6989586621679678726"><span id="local-6989586621679678727"><span id="local-6989586621679678728"><span id="local-6989586621679678729"><span id="local-6989586621679678730"><span class="annot"><a href="Data.Traversable.html#forAccumM"><span class="hs-identifier hs-type">forAccumM</span></a></span><span>
</span><span id="line-521"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678726"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678727"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678728"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678727"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678729"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678728"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678729"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678726"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678728"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678730"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678726"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678728"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679678727"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678730"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span></span></span><span>
</span><span id="line-523"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#forAccumM"><span class="hs-pragma hs-type">forAccumM</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-524"></span><span id="forAccumM"><span class="annot"><span class="annottext">forAccumM :: forall (m :: * -&gt; *) (t :: * -&gt; *) s a b.
(Monad m, Traversable t) =&gt;
s -&gt; t a -&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m (s, t b)
</span><a href="Data.Traversable.html#forAccumM"><span class="hs-identifier hs-var hs-var">forAccumM</span></a></span></span><span> </span><span id="local-6989586621679679862"><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679862"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621679679863"><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679863"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679679864"><span class="annot"><span class="annottext">s -&gt; a -&gt; m (s, b)
</span><a href="#local-6989586621679679864"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(s -&gt; a -&gt; m (s, b)) -&gt; s -&gt; t a -&gt; m (s, t b)
forall (m :: * -&gt; *) (t :: * -&gt; *) s a b.
(Monad m, Traversable t) =&gt;
(s -&gt; a -&gt; m (s, b)) -&gt; s -&gt; t a -&gt; m (s, t b)
</span><a href="Data.Traversable.html#mapAccumM"><span class="hs-identifier hs-var">mapAccumM</span></a></span><span> </span><span class="annot"><span class="annottext">s -&gt; a -&gt; m (s, b)
</span><a href="#local-6989586621679679864"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">s
</span><a href="#local-6989586621679679862"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">t a
</span><a href="#local-6989586621679679863"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span class="hs-comment">-- | This function may be used as a value for `fmap` in a `Functor`</span><span>
</span><span id="line-527"></span><span class="hs-comment">--   instance, provided that 'traverse' is defined. (Using</span><span>
</span><span id="line-528"></span><span class="hs-comment">--   `fmapDefault` with a `Traversable` instance defined only by</span><span>
</span><span id="line-529"></span><span class="hs-comment">--   'sequenceA' will result in infinite recursion.)</span><span>
</span><span id="line-530"></span><span class="hs-comment">--</span><span>
</span><span id="line-531"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-532"></span><span class="hs-comment">-- 'fmapDefault' f &#8801; 'runIdentity' . 'traverse' ('Identity' . f)</span><span>
</span><span id="line-533"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-534"></span><span class="annot"><a href="Data.Traversable.html#fmapDefault"><span class="hs-identifier hs-type">fmapDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679678736"><span class="annot"><a href="#local-6989586621679678736"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span id="local-6989586621679678737"><span class="annot"><a href="#local-6989586621679678737"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679678738"><span class="annot"><a href="#local-6989586621679678738"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678736"><span class="hs-identifier hs-type">t</span></a></span><span>
</span><span id="line-535"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678737"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678738"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678736"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678737"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678736"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678738"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-536"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#fmapDefault"><span class="hs-pragma hs-type">fmapDefault</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-537"></span><span class="hs-comment">-- See Note [Function coercion] in Data.Functor.Utils.</span><span>
</span><span id="line-538"></span><span id="fmapDefault"><span class="annot"><span class="annottext">fmapDefault :: forall (t :: * -&gt; *) a b. Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b
</span><a href="Data.Traversable.html#fmapDefault"><span class="hs-identifier hs-var hs-var">fmapDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; Identity b) -&gt; t a -&gt; Identity (t b))
-&gt; (a -&gt; b) -&gt; t a -&gt; t b
forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#coerce/GHC.Prim.html#coerce"><span class="hs-identifier hs-var">coerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678736"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="Data.Functor.Identity.html#Identity"><span class="hs-identifier hs-type">Identity</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678737"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678738"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span class="hs-comment">-- | This function may be used as a value for `Data.Foldable.foldMap`</span><span>
</span><span id="line-541"></span><span class="hs-comment">-- in a `Foldable` instance.</span><span>
</span><span id="line-542"></span><span class="hs-comment">--</span><span>
</span><span id="line-543"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-544"></span><span class="hs-comment">-- 'foldMapDefault' f &#8801; 'getConst' . 'traverse' ('Const' . f)</span><span>
</span><span id="line-545"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-546"></span><span class="annot"><a href="Data.Traversable.html#foldMapDefault"><span class="hs-identifier hs-type">foldMapDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679678742"><span class="annot"><a href="#local-6989586621679678742"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span id="local-6989586621679678743"><span class="annot"><a href="#local-6989586621679678743"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679678744"><span class="annot"><a href="#local-6989586621679678744"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.Traversable.html#Traversable"><span class="hs-identifier hs-type">Traversable</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678742"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Base.html#Monoid"><span class="hs-identifier hs-type">Monoid</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678743"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-547"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679678744"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678743"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678742"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678744"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679678743"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-548"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.Traversable.html#foldMapDefault"><span class="hs-pragma hs-type">foldMapDefault</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-549"></span><span class="hs-comment">-- See Note [Function coercion] in Data.Functor.Utils.</span><span>
</span><span id="line-550"></span><span id="foldMapDefault"><span class="annot"><span class="annottext">foldMapDefault :: forall (t :: * -&gt; *) m a.
(Traversable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><a href="Data.Traversable.html#foldMapDefault"><span class="hs-identifier hs-var hs-var">foldMapDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((a -&gt; Const m ()) -&gt; t a -&gt; Const m (t ()))
-&gt; (a -&gt; m) -&gt; t a -&gt; m
forall a b. Coercible a b =&gt; a -&gt; b
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#coerce/GHC.Prim.html#coerce"><span class="hs-identifier hs-var">coerce</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="Data.Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678742"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Data.Functor.Const.html#Const"><span class="hs-identifier hs-type">Const</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679678743"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621679678744"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-551"></span><span>
</span><span id="line-552"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-553"></span><span>
</span><span id="line-554"></span><span class="hs-comment">-- $overview</span><span>
</span><span id="line-555"></span><span class="hs-comment">--</span><span>
</span><span id="line-556"></span><span class="hs-comment">-- #overview#</span><span>
</span><span id="line-557"></span><span class="hs-comment">-- Traversable structures support element-wise sequencing of 'Applicative'</span><span>
</span><span id="line-558"></span><span class="hs-comment">-- effects (thus also 'Monad' effects) to construct new structures of</span><span>
</span><span id="line-559"></span><span class="hs-comment">-- __the same shape__ as the input.</span><span>
</span><span id="line-560"></span><span class="hs-comment">--</span><span>
</span><span id="line-561"></span><span class="hs-comment">-- To illustrate what is meant by /same shape/, if the input structure is</span><span>
</span><span id="line-562"></span><span class="hs-comment">-- __@[a]@__, each output structure is a list __@[b]@__ of the same length as</span><span>
</span><span id="line-563"></span><span class="hs-comment">-- the input.  If the input is a __@Tree a@__, each output __@Tree b@__ has the</span><span>
</span><span id="line-564"></span><span class="hs-comment">-- same graph of intermediate nodes and leaves.  Similarly, if the input is a</span><span>
</span><span id="line-565"></span><span class="hs-comment">-- 2-tuple __@(x, a)@__, each output is a 2-tuple __@(x, b)@__, and so forth.</span><span>
</span><span id="line-566"></span><span class="hs-comment">--</span><span>
</span><span id="line-567"></span><span class="hs-comment">-- It is in fact possible to decompose a traversable structure __@t a@__ into</span><span>
</span><span id="line-568"></span><span class="hs-comment">-- its shape (a.k.a. /spine/) of type __@t ()@__ and its element list</span><span>
</span><span id="line-569"></span><span class="hs-comment">-- __@[a]@__.  The original structure can be faithfully reconstructed from its</span><span>
</span><span id="line-570"></span><span class="hs-comment">-- spine and element list.</span><span>
</span><span id="line-571"></span><span class="hs-comment">--</span><span>
</span><span id="line-572"></span><span class="hs-comment">-- The implementation of a @Traversable@ instance for a given structure follows</span><span>
</span><span id="line-573"></span><span class="hs-comment">-- naturally from its type; see the [Construction](#construction) section for</span><span>
</span><span id="line-574"></span><span class="hs-comment">-- details.</span><span>
</span><span id="line-575"></span><span class="hs-comment">-- Instances must satisfy the laws listed in the [Laws section](#laws).</span><span>
</span><span id="line-576"></span><span class="hs-comment">-- The diverse uses of @Traversable@ structures result from the many possible</span><span>
</span><span id="line-577"></span><span class="hs-comment">-- choices of Applicative effects.</span><span>
</span><span id="line-578"></span><span class="hs-comment">-- See the [Advanced Traversals](#advanced) section for some examples.</span><span>
</span><span id="line-579"></span><span class="hs-comment">--</span><span>
</span><span id="line-580"></span><span class="hs-comment">-- Every @Traversable@ structure is both a 'Functor' and 'Foldable' because it</span><span>
</span><span id="line-581"></span><span class="hs-comment">-- is possible to implement the requisite instances in terms of 'traverse' by</span><span>
</span><span id="line-582"></span><span class="hs-comment">-- using 'fmapDefault' for 'fmap' and 'foldMapDefault' for 'foldMap'.  Direct</span><span>
</span><span id="line-583"></span><span class="hs-comment">-- fine-tuned implementations of these superclass methods can in some cases be</span><span>
</span><span id="line-584"></span><span class="hs-comment">-- more efficient.</span><span>
</span><span id="line-585"></span><span>
</span><span id="line-586"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-587"></span><span>
</span><span id="line-588"></span><span class="hs-comment">-- $traverse</span><span>
</span><span id="line-589"></span><span class="hs-comment">-- For an 'Applicative' functor __@f@__ and a @Traversable@ functor __@t@__,</span><span>
</span><span id="line-590"></span><span class="hs-comment">-- the type signatures of 'traverse' and 'fmap' are rather similar:</span><span>
</span><span id="line-591"></span><span class="hs-comment">--</span><span>
</span><span id="line-592"></span><span class="hs-comment">-- &gt; fmap     :: (a -&gt; f b) -&gt; t a -&gt; t (f b)</span><span>
</span><span id="line-593"></span><span class="hs-comment">-- &gt; traverse :: (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><span>
</span><span id="line-594"></span><span class="hs-comment">--</span><span>
</span><span id="line-595"></span><span class="hs-comment">-- The key difference is that 'fmap' produces a structure whose elements (of</span><span>
</span><span id="line-596"></span><span class="hs-comment">-- type __@f b@__) are individual effects, while 'traverse' produces an</span><span>
</span><span id="line-597"></span><span class="hs-comment">-- aggregate effect yielding structures of type __@t b@__.</span><span>
</span><span id="line-598"></span><span class="hs-comment">--</span><span>
</span><span id="line-599"></span><span class="hs-comment">-- For example, when __@f@__ is the __@IO@__ monad, and __@t@__ is __@List@__,</span><span>
</span><span id="line-600"></span><span class="hs-comment">-- 'fmap' yields a list of IO actions, whereas 'traverse' constructs an IO</span><span>
</span><span id="line-601"></span><span class="hs-comment">-- action that evaluates to a list of the return values of the individual</span><span>
</span><span id="line-602"></span><span class="hs-comment">-- actions performed left-to-right.</span><span>
</span><span id="line-603"></span><span class="hs-comment">--</span><span>
</span><span id="line-604"></span><span class="hs-comment">-- &gt; traverse :: (a -&gt; IO b) -&gt; [a] -&gt; IO [b]</span><span>
</span><span id="line-605"></span><span class="hs-comment">--</span><span>
</span><span id="line-606"></span><span class="hs-comment">-- The 'mapM' function is a specialisation of 'traverse' to the case when</span><span>
</span><span id="line-607"></span><span class="hs-comment">-- __@f@__ is a 'Monad'.  For monads, 'mapM' is more idiomatic than 'traverse'.</span><span>
</span><span id="line-608"></span><span class="hs-comment">-- The two are otherwise generally identical (though 'mapM' may be specifically</span><span>
</span><span id="line-609"></span><span class="hs-comment">-- optimised for monads, and could be more efficient than using the more</span><span>
</span><span id="line-610"></span><span class="hs-comment">-- general 'traverse').</span><span>
</span><span id="line-611"></span><span class="hs-comment">--</span><span>
</span><span id="line-612"></span><span class="hs-comment">-- &gt; traverse :: (Applicative f, Traversable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><span>
</span><span id="line-613"></span><span class="hs-comment">-- &gt; mapM     :: (Monad       m, Traversable t) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</span><span>
</span><span id="line-614"></span><span class="hs-comment">--</span><span>
</span><span id="line-615"></span><span class="hs-comment">-- When the traversable term is a simple variable or expression, and the</span><span>
</span><span id="line-616"></span><span class="hs-comment">-- monadic action to run is a non-trivial do block, it can be more natural to</span><span>
</span><span id="line-617"></span><span class="hs-comment">-- write the action last.  This idiom is supported by 'for', 'forM', and</span><span>
</span><span id="line-618"></span><span class="hs-comment">-- 'forAccumM' which are the flipped versions of 'traverse', 'mapM', and</span><span>
</span><span id="line-619"></span><span class="hs-comment">-- 'mapAccumM' respectively.</span><span>
</span><span id="line-620"></span><span>
</span><span id="line-621"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-622"></span><span>
</span><span id="line-623"></span><span class="hs-comment">-- $multiplicity</span><span>
</span><span id="line-624"></span><span class="hs-comment">--</span><span>
</span><span id="line-625"></span><span class="hs-comment">-- #multiplicity#</span><span>
</span><span id="line-626"></span><span class="hs-comment">-- When 'traverse' or 'mapM' is applied to an empty structure __@ts@__ (one for</span><span>
</span><span id="line-627"></span><span class="hs-comment">-- which __@'null' ts@__ is 'True') the return value is __@pure ts@__</span><span>
</span><span id="line-628"></span><span class="hs-comment">-- regardless of the provided function __@g :: a -&gt; f b@__.  It is not possible</span><span>
</span><span id="line-629"></span><span class="hs-comment">-- to apply the function when no values of type __@a@__ are available, but its</span><span>
</span><span id="line-630"></span><span class="hs-comment">-- type determines the relevant instance of 'pure'.</span><span>
</span><span id="line-631"></span><span class="hs-comment">--</span><span>
</span><span id="line-632"></span><span class="hs-comment">-- prop&gt; null ts ==&gt; traverse g ts == pure ts</span><span>
</span><span id="line-633"></span><span class="hs-comment">--</span><span>
</span><span id="line-634"></span><span class="hs-comment">-- Otherwise, when __@ts@__ is non-empty and at least one value of type __@b@__</span><span>
</span><span id="line-635"></span><span class="hs-comment">-- results from each __@f a@__, the structures __@t b@__ have /the same shape/</span><span>
</span><span id="line-636"></span><span class="hs-comment">-- (list length, graph of tree nodes, ...) as the input structure __@t a@__,</span><span>
</span><span id="line-637"></span><span class="hs-comment">-- but the slots previously occupied by elements of type __@a@__ now hold</span><span>
</span><span id="line-638"></span><span class="hs-comment">-- elements of type __@b@__.</span><span>
</span><span id="line-639"></span><span class="hs-comment">--</span><span>
</span><span id="line-640"></span><span class="hs-comment">-- A single traversal may produce one, zero or many such structures.  The zero</span><span>
</span><span id="line-641"></span><span class="hs-comment">-- case happens when one of the effects __@f a@__ sequenced as part of the</span><span>
</span><span id="line-642"></span><span class="hs-comment">-- traversal yields no replacement values.  Otherwise, the many case happens</span><span>
</span><span id="line-643"></span><span class="hs-comment">-- when one of sequenced effects yields multiple values.</span><span>
</span><span id="line-644"></span><span class="hs-comment">--</span><span>
</span><span id="line-645"></span><span class="hs-comment">-- The 'traverse' function does not perform selective filtering of slots in the</span><span>
</span><span id="line-646"></span><span class="hs-comment">-- output structure as with e.g. 'Data.Maybe.mapMaybe'.</span><span>
</span><span id="line-647"></span><span class="hs-comment">--</span><span>
</span><span id="line-648"></span><span class="hs-comment">-- &gt;&gt;&gt; let incOdd n = if odd n then Just $ n + 1 else Nothing</span><span>
</span><span id="line-649"></span><span class="hs-comment">-- &gt;&gt;&gt; mapMaybe incOdd [1, 2, 3]</span><span>
</span><span id="line-650"></span><span class="hs-comment">-- [2,4]</span><span>
</span><span id="line-651"></span><span class="hs-comment">-- &gt;&gt;&gt; traverse incOdd [1, 3, 5]</span><span>
</span><span id="line-652"></span><span class="hs-comment">-- Just [2,4,6]</span><span>
</span><span id="line-653"></span><span class="hs-comment">-- &gt;&gt;&gt; traverse incOdd [1, 2, 3]</span><span>
</span><span id="line-654"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-655"></span><span class="hs-comment">--</span><span>
</span><span id="line-656"></span><span class="hs-comment">-- In the above examples, with 'Maybe' as the 'Applicative' __@f@__, we see</span><span>
</span><span id="line-657"></span><span class="hs-comment">-- that the number of __@t b@__ structures produced by 'traverse' may differ</span><span>
</span><span id="line-658"></span><span class="hs-comment">-- from one: it is zero when the result short-circuits to __@Nothing@__.  The</span><span>
</span><span id="line-659"></span><span class="hs-comment">-- same can happen when __@f@__ is __@List@__ and the result is __@[]@__, or</span><span>
</span><span id="line-660"></span><span class="hs-comment">-- __@f@__ is __@Either e@__ and the result is __@Left (x :: e)@__, or perhaps</span><span>
</span><span id="line-661"></span><span class="hs-comment">-- the 'Control.Applicative.empty' value of some</span><span>
</span><span id="line-662"></span><span class="hs-comment">-- 'Control.Applicative.Alternative' functor.</span><span>
</span><span id="line-663"></span><span class="hs-comment">--</span><span>
</span><span id="line-664"></span><span class="hs-comment">-- When __@f@__ is e.g. __@List@__, and the map __@g :: a -&gt; [b]@__ returns</span><span>
</span><span id="line-665"></span><span class="hs-comment">-- more than one value for some inputs __@a@__ (and at least one for all</span><span>
</span><span id="line-666"></span><span class="hs-comment">-- __@a@__), the result of __@mapM g ts@__ will contain multiple structures of</span><span>
</span><span id="line-667"></span><span class="hs-comment">-- the same shape as __@ts@__:</span><span>
</span><span id="line-668"></span><span class="hs-comment">--</span><span>
</span><span id="line-669"></span><span class="hs-comment">-- prop&gt; length (mapM g ts) == product (fmap (length . g) ts)</span><span>
</span><span id="line-670"></span><span class="hs-comment">--</span><span>
</span><span id="line-671"></span><span class="hs-comment">-- For example:</span><span>
</span><span id="line-672"></span><span class="hs-comment">--</span><span>
</span><span id="line-673"></span><span class="hs-comment">-- &gt;&gt;&gt; length $ mapM (\n -&gt; [1..n]) [1..6]</span><span>
</span><span id="line-674"></span><span class="hs-comment">-- 720</span><span>
</span><span id="line-675"></span><span class="hs-comment">-- &gt;&gt;&gt; product $ length . (\n -&gt; [1..n]) &lt;$&gt; [1..6]</span><span>
</span><span id="line-676"></span><span class="hs-comment">-- 720</span><span>
</span><span id="line-677"></span><span class="hs-comment">--</span><span>
</span><span id="line-678"></span><span class="hs-comment">-- In other words, a traversal with a function __@g :: a -&gt; [b]@__, over an</span><span>
</span><span id="line-679"></span><span class="hs-comment">-- input structure __@t a@__, yields a list __@[t b]@__, whose length is the</span><span>
</span><span id="line-680"></span><span class="hs-comment">-- product of the lengths of the lists that @g@ returns for each element of the</span><span>
</span><span id="line-681"></span><span class="hs-comment">-- input structure!  The individual elements __@a@__ of the structure are</span><span>
</span><span id="line-682"></span><span class="hs-comment">-- replaced by each element of __@g a@__ in turn:</span><span>
</span><span id="line-683"></span><span class="hs-comment">--</span><span>
</span><span id="line-684"></span><span class="hs-comment">-- &gt;&gt;&gt; mapM (\n -&gt; [1..n]) $ Just 3</span><span>
</span><span id="line-685"></span><span class="hs-comment">-- [Just 1,Just 2,Just 3]</span><span>
</span><span id="line-686"></span><span class="hs-comment">-- &gt;&gt;&gt; mapM (\n -&gt; [1..n]) [1..3]</span><span>
</span><span id="line-687"></span><span class="hs-comment">-- [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3]]</span><span>
</span><span id="line-688"></span><span class="hs-comment">--</span><span>
</span><span id="line-689"></span><span class="hs-comment">-- If any element of the structure __@t a@__ is mapped by @g@ to an empty list,</span><span>
</span><span id="line-690"></span><span class="hs-comment">-- then the entire aggregate result is empty, because no value is available to</span><span>
</span><span id="line-691"></span><span class="hs-comment">-- fill one of the slots of the output structure:</span><span>
</span><span id="line-692"></span><span class="hs-comment">--</span><span>
</span><span id="line-693"></span><span class="hs-comment">-- &gt;&gt;&gt; mapM (\n -&gt; [1..n]) $ [0..6] -- [1..0] is empty</span><span>
</span><span id="line-694"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-695"></span><span>
</span><span id="line-696"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-697"></span><span>
</span><span id="line-698"></span><span class="hs-comment">-- $effectful</span><span>
</span><span id="line-699"></span><span class="hs-comment">-- #effectful#</span><span>
</span><span id="line-700"></span><span class="hs-comment">--</span><span>
</span><span id="line-701"></span><span class="hs-comment">-- The 'traverse' and 'mapM' methods have analogues in the &quot;Data.Foldable&quot;</span><span>
</span><span id="line-702"></span><span class="hs-comment">-- module.  These are 'traverse_' and 'mapM_', and their flipped variants</span><span>
</span><span id="line-703"></span><span class="hs-comment">-- 'for_' and 'forM_', respectively.  The result type is __@f ()@__, they don't</span><span>
</span><span id="line-704"></span><span class="hs-comment">-- return an updated structure, and can be used to sequence effects over all</span><span>
</span><span id="line-705"></span><span class="hs-comment">-- the elements of a @Traversable@ (any 'Foldable') structure just for their</span><span>
</span><span id="line-706"></span><span class="hs-comment">-- side-effects.</span><span>
</span><span id="line-707"></span><span class="hs-comment">--</span><span>
</span><span id="line-708"></span><span class="hs-comment">-- If the @Traversable@ structure is empty, the result is __@pure ()@__.  When</span><span>
</span><span id="line-709"></span><span class="hs-comment">-- effects short-circuit, the __@f ()@__ result may, for example, be 'Nothing'</span><span>
</span><span id="line-710"></span><span class="hs-comment">-- if __@f@__ is 'Maybe', or __@'Left' e@__ when it is __@'Either' e@__.</span><span>
</span><span id="line-711"></span><span class="hs-comment">--</span><span>
</span><span id="line-712"></span><span class="hs-comment">-- It is perhaps worth noting that 'Maybe' is not only a potential</span><span>
</span><span id="line-713"></span><span class="hs-comment">-- 'Applicative' functor for the return value of the first argument of</span><span>
</span><span id="line-714"></span><span class="hs-comment">-- 'traverse', but is also itself a 'Traversable' structure with either zero or</span><span>
</span><span id="line-715"></span><span class="hs-comment">-- one element.  A convenient idiom for conditionally executing an action just</span><span>
</span><span id="line-716"></span><span class="hs-comment">-- for its effects on a 'Just' value, and doing nothing otherwise is:</span><span>
</span><span id="line-717"></span><span class="hs-comment">--</span><span>
</span><span id="line-718"></span><span class="hs-comment">-- &gt; -- action :: Monad m =&gt; a -&gt; m ()</span><span>
</span><span id="line-719"></span><span class="hs-comment">-- &gt; -- mvalue :: Maybe a</span><span>
</span><span id="line-720"></span><span class="hs-comment">-- &gt; mapM_ action mvalue -- :: m ()</span><span>
</span><span id="line-721"></span><span class="hs-comment">--</span><span>
</span><span id="line-722"></span><span class="hs-comment">-- which is more concise than:</span><span>
</span><span id="line-723"></span><span class="hs-comment">--</span><span>
</span><span id="line-724"></span><span class="hs-comment">-- &gt; maybe (return ()) action mvalue</span><span>
</span><span id="line-725"></span><span class="hs-comment">--</span><span>
</span><span id="line-726"></span><span class="hs-comment">-- The 'mapM_' idiom works verbatim if the type of __@mvalue@__ is later</span><span>
</span><span id="line-727"></span><span class="hs-comment">-- refactored from __@Maybe a@__ to __@Either e a@__ (assuming it remains OK to</span><span>
</span><span id="line-728"></span><span class="hs-comment">-- silently do nothing in the 'Left' case).</span><span>
</span><span id="line-729"></span><span>
</span><span id="line-730"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-731"></span><span>
</span><span id="line-732"></span><span class="hs-comment">-- $sequence</span><span>
</span><span id="line-733"></span><span class="hs-comment">--</span><span>
</span><span id="line-734"></span><span class="hs-comment">-- #sequence#</span><span>
</span><span id="line-735"></span><span class="hs-comment">-- The 'sequenceA' and 'sequence' methods are useful when what you have is a</span><span>
</span><span id="line-736"></span><span class="hs-comment">-- container of pending applicative or monadic effects, and you want to combine</span><span>
</span><span id="line-737"></span><span class="hs-comment">-- them into a single effect that produces zero or more containers with the</span><span>
</span><span id="line-738"></span><span class="hs-comment">-- computed values.</span><span>
</span><span id="line-739"></span><span class="hs-comment">--</span><span>
</span><span id="line-740"></span><span class="hs-comment">-- &gt; sequenceA :: (Applicative f, Traversable t) =&gt; t (f a) -&gt; f (t a)</span><span>
</span><span id="line-741"></span><span class="hs-comment">-- &gt; sequence  :: (Monad       m, Traversable t) =&gt; t (m a) -&gt; m (t a)</span><span>
</span><span id="line-742"></span><span class="hs-comment">-- &gt; sequenceA = traverse id -- default definition</span><span>
</span><span id="line-743"></span><span class="hs-comment">-- &gt; sequence  = sequenceA   -- default definition</span><span>
</span><span id="line-744"></span><span class="hs-comment">--</span><span>
</span><span id="line-745"></span><span class="hs-comment">-- When the monad __@m@__ is 'System.IO.IO', applying 'sequence' to a list of</span><span>
</span><span id="line-746"></span><span class="hs-comment">-- IO actions, performs each in turn, returning a list of the results:</span><span>
</span><span id="line-747"></span><span class="hs-comment">--</span><span>
</span><span id="line-748"></span><span class="hs-comment">-- &gt; sequence [putStr &quot;Hello &quot;, putStrLn &quot;World!&quot;]</span><span>
</span><span id="line-749"></span><span class="hs-comment">-- &gt;     = (\a b -&gt; [a,b]) &lt;$&gt; putStr &quot;Hello &quot; &lt;*&gt; putStrLn &quot;World!&quot;</span><span>
</span><span id="line-750"></span><span class="hs-comment">-- &gt;     = do u1 &lt;- putStr &quot;Hello &quot;</span><span>
</span><span id="line-751"></span><span class="hs-comment">-- &gt;          u2 &lt;- putStrLn &quot;World!&quot;</span><span>
</span><span id="line-752"></span><span class="hs-comment">-- &gt;          return [u1, u2]         -- In this case  [(), ()]</span><span>
</span><span id="line-753"></span><span class="hs-comment">--</span><span>
</span><span id="line-754"></span><span class="hs-comment">-- For 'sequenceA', the /non-deterministic/ behaviour of @List@ is most easily</span><span>
</span><span id="line-755"></span><span class="hs-comment">-- seen in the case of a list of lists (of elements of some common fixed type).</span><span>
</span><span id="line-756"></span><span class="hs-comment">-- The result is a cross-product of all the sublists:</span><span>
</span><span id="line-757"></span><span class="hs-comment">--</span><span>
</span><span id="line-758"></span><span class="hs-comment">-- &gt;&gt;&gt; sequenceA [[0, 1, 2], [30, 40], [500]]</span><span>
</span><span id="line-759"></span><span class="hs-comment">-- [[0,30,500],[0,40,500],[1,30,500],[1,40,500],[2,30,500],[2,40,500]]</span><span>
</span><span id="line-760"></span><span class="hs-comment">--</span><span>
</span><span id="line-761"></span><span class="hs-comment">-- Because the input list has three (sublist) elements, the result is a list of</span><span>
</span><span id="line-762"></span><span class="hs-comment">-- triples (/same shape/).</span><span>
</span><span id="line-763"></span><span>
</span><span id="line-764"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-765"></span><span>
</span><span id="line-766"></span><span class="hs-comment">-- $seqshort</span><span>
</span><span id="line-767"></span><span class="hs-comment">--</span><span>
</span><span id="line-768"></span><span class="hs-comment">-- #seqshort#</span><span>
</span><span id="line-769"></span><span class="hs-comment">-- When the monad __@m@__ is 'Either' or 'Maybe' (more generally any</span><span>
</span><span id="line-770"></span><span class="hs-comment">-- 'Control.Monad.MonadPlus'), the effect in question is to short-circuit the</span><span>
</span><span id="line-771"></span><span class="hs-comment">-- result on encountering 'Left' or 'Nothing' (more generally</span><span>
</span><span id="line-772"></span><span class="hs-comment">-- 'Control.Monad.mzero').</span><span>
</span><span id="line-773"></span><span class="hs-comment">--</span><span>
</span><span id="line-774"></span><span class="hs-comment">-- &gt;&gt;&gt; sequence [Just 1,Just 2,Just 3]</span><span>
</span><span id="line-775"></span><span class="hs-comment">-- Just [1,2,3]</span><span>
</span><span id="line-776"></span><span class="hs-comment">-- &gt;&gt;&gt; sequence [Just 1,Nothing,Just 3]</span><span>
</span><span id="line-777"></span><span class="hs-comment">-- Nothing</span><span>
</span><span id="line-778"></span><span class="hs-comment">-- &gt;&gt;&gt; sequence [Right 1,Right 2,Right 3]</span><span>
</span><span id="line-779"></span><span class="hs-comment">-- Right [1,2,3]</span><span>
</span><span id="line-780"></span><span class="hs-comment">-- &gt;&gt;&gt; sequence [Right 1,Left &quot;sorry&quot;,Right 3]</span><span>
</span><span id="line-781"></span><span class="hs-comment">-- Left &quot;sorry&quot;</span><span>
</span><span id="line-782"></span><span class="hs-comment">--</span><span>
</span><span id="line-783"></span><span class="hs-comment">-- The result of 'sequence' is all-or-nothing, either structures of exactly the</span><span>
</span><span id="line-784"></span><span class="hs-comment">-- same shape as the input or none at all.  The 'sequence' function does not</span><span>
</span><span id="line-785"></span><span class="hs-comment">-- perform selective filtering as with e.g. 'Data.Maybe.catMaybes' or</span><span>
</span><span id="line-786"></span><span class="hs-comment">-- 'Data.Either.rights':</span><span>
</span><span id="line-787"></span><span class="hs-comment">--</span><span>
</span><span id="line-788"></span><span class="hs-comment">-- &gt;&gt;&gt; catMaybes [Just 1,Nothing,Just 3]</span><span>
</span><span id="line-789"></span><span class="hs-comment">-- [1,3]</span><span>
</span><span id="line-790"></span><span class="hs-comment">-- &gt;&gt;&gt; rights [Right 1,Left &quot;sorry&quot;,Right 3]</span><span>
</span><span id="line-791"></span><span class="hs-comment">-- [1,3]</span><span>
</span><span id="line-792"></span><span>
</span><span id="line-793"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-794"></span><span>
</span><span id="line-795"></span><span class="hs-comment">-- $seqdefault</span><span>
</span><span id="line-796"></span><span class="hs-comment">--</span><span>
</span><span id="line-797"></span><span class="hs-comment">-- #seqdefault#</span><span>
</span><span id="line-798"></span><span class="hs-comment">-- The 'traverse' method has a default implementation in terms of 'sequenceA':</span><span>
</span><span id="line-799"></span><span class="hs-comment">--</span><span>
</span><span id="line-800"></span><span class="hs-comment">-- &gt; traverse g = sequenceA . fmap g</span><span>
</span><span id="line-801"></span><span class="hs-comment">--</span><span>
</span><span id="line-802"></span><span class="hs-comment">-- but relying on this default implementation is not recommended, it requires</span><span>
</span><span id="line-803"></span><span class="hs-comment">-- that the structure is already independently a 'Functor'.  The definition of</span><span>
</span><span id="line-804"></span><span class="hs-comment">-- 'sequenceA' in terms of __@traverse id@__ is much simpler than 'traverse'</span><span>
</span><span id="line-805"></span><span class="hs-comment">-- expressed via a composition of 'sequenceA' and 'fmap'.  Instances should</span><span>
</span><span id="line-806"></span><span class="hs-comment">-- generally implement 'traverse' explicitly.  It may in some cases also make</span><span>
</span><span id="line-807"></span><span class="hs-comment">-- sense to implement a specialised 'mapM'.</span><span>
</span><span id="line-808"></span><span class="hs-comment">--</span><span>
</span><span id="line-809"></span><span class="hs-comment">-- Because 'fmapDefault' is defined in terms of 'traverse' (whose default</span><span>
</span><span id="line-810"></span><span class="hs-comment">-- definition in terms of 'sequenceA' uses 'fmap'), you must not use</span><span>
</span><span id="line-811"></span><span class="hs-comment">-- 'fmapDefault' to define the @Functor@ instance if the @Traversable@ instance</span><span>
</span><span id="line-812"></span><span class="hs-comment">-- directly defines only 'sequenceA'.</span><span>
</span><span id="line-813"></span><span>
</span><span id="line-814"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-815"></span><span>
</span><span id="line-816"></span><span class="hs-comment">-- $tree_instance</span><span>
</span><span id="line-817"></span><span class="hs-comment">--</span><span>
</span><span id="line-818"></span><span class="hs-comment">-- #tree#</span><span>
</span><span id="line-819"></span><span class="hs-comment">-- The definition of a 'Traversable' instance for a binary tree is rather</span><span>
</span><span id="line-820"></span><span class="hs-comment">-- similar to the corresponding instance of 'Functor', given the data type:</span><span>
</span><span id="line-821"></span><span class="hs-comment">--</span><span>
</span><span id="line-822"></span><span class="hs-comment">-- &gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)</span><span>
</span><span id="line-823"></span><span class="hs-comment">--</span><span>
</span><span id="line-824"></span><span class="hs-comment">-- a canonical @Functor@ instance would be</span><span>
</span><span id="line-825"></span><span class="hs-comment">--</span><span>
</span><span id="line-826"></span><span class="hs-comment">-- &gt; instance Functor Tree where</span><span>
</span><span id="line-827"></span><span class="hs-comment">-- &gt;    fmap g Empty        = Empty</span><span>
</span><span id="line-828"></span><span class="hs-comment">-- &gt;    fmap g (Leaf x)     = Leaf (g x)</span><span>
</span><span id="line-829"></span><span class="hs-comment">-- &gt;    fmap g (Node l k r) = Node (fmap g l) (g k) (fmap g r)</span><span>
</span><span id="line-830"></span><span class="hs-comment">--</span><span>
</span><span id="line-831"></span><span class="hs-comment">-- a canonical @Traversable@ instance would be</span><span>
</span><span id="line-832"></span><span class="hs-comment">--</span><span>
</span><span id="line-833"></span><span class="hs-comment">-- &gt; instance Traversable Tree where</span><span>
</span><span id="line-834"></span><span class="hs-comment">-- &gt;    traverse g Empty        = pure Empty</span><span>
</span><span id="line-835"></span><span class="hs-comment">-- &gt;    traverse g (Leaf x)     = Leaf &lt;$&gt; g x</span><span>
</span><span id="line-836"></span><span class="hs-comment">-- &gt;    traverse g (Node l k r) = Node &lt;$&gt; traverse g l &lt;*&gt; g k &lt;*&gt; traverse g r</span><span>
</span><span id="line-837"></span><span class="hs-comment">--</span><span>
</span><span id="line-838"></span><span class="hs-comment">-- This definition works for any __@g :: a -&gt; f b@__, with __@f@__ an</span><span>
</span><span id="line-839"></span><span class="hs-comment">-- Applicative functor, as the laws for @('&lt;*&gt;')@ imply the requisite</span><span>
</span><span id="line-840"></span><span class="hs-comment">-- associativity.</span><span>
</span><span id="line-841"></span><span class="hs-comment">--</span><span>
</span><span id="line-842"></span><span class="hs-comment">-- We can add an explicit non-default 'mapM' if desired:</span><span>
</span><span id="line-843"></span><span class="hs-comment">--</span><span>
</span><span id="line-844"></span><span class="hs-comment">-- &gt;    mapM g Empty        = return Empty</span><span>
</span><span id="line-845"></span><span class="hs-comment">-- &gt;    mapM g (Leaf x)     = Leaf &lt;$&gt; g x</span><span>
</span><span id="line-846"></span><span class="hs-comment">-- &gt;    mapM g (Node l k r) = do</span><span>
</span><span id="line-847"></span><span class="hs-comment">-- &gt;        ml &lt;- mapM g l</span><span>
</span><span id="line-848"></span><span class="hs-comment">-- &gt;        mk &lt;- g k</span><span>
</span><span id="line-849"></span><span class="hs-comment">-- &gt;        mr &lt;- mapM g r</span><span>
</span><span id="line-850"></span><span class="hs-comment">-- &gt;        return $ Node ml mk mr</span><span>
</span><span id="line-851"></span><span class="hs-comment">--</span><span>
</span><span id="line-852"></span><span class="hs-comment">-- See [Construction](#construction) below for a more detailed exploration of</span><span>
</span><span id="line-853"></span><span class="hs-comment">-- the general case, but as mentioned in [Overview](#overview) above, instance</span><span>
</span><span id="line-854"></span><span class="hs-comment">-- definitions are typically rather simple, all the interesting behaviour is a</span><span>
</span><span id="line-855"></span><span class="hs-comment">-- result of an interesting choice of 'Applicative' functor for a traversal.</span><span>
</span><span id="line-856"></span><span>
</span><span id="line-857"></span><span class="hs-comment">-- $tree_order</span><span>
</span><span id="line-858"></span><span class="hs-comment">--</span><span>
</span><span id="line-859"></span><span class="hs-comment">-- It is perhaps worth noting that the traversal defined above gives an</span><span>
</span><span id="line-860"></span><span class="hs-comment">-- /in-order/ sequencing of the elements.  If instead you want either</span><span>
</span><span id="line-861"></span><span class="hs-comment">-- /pre-order/ (parent first, then child nodes) or post-order (child nodes</span><span>
</span><span id="line-862"></span><span class="hs-comment">-- first, then parent) sequencing, you can define the instance accordingly:</span><span>
</span><span id="line-863"></span><span class="hs-comment">--</span><span>
</span><span id="line-864"></span><span class="hs-comment">-- &gt; inOrderNode :: Tree a -&gt; a -&gt; Tree a -&gt; Tree a</span><span>
</span><span id="line-865"></span><span class="hs-comment">-- &gt; inOrderNode l x r = Node l x r</span><span>
</span><span id="line-866"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-867"></span><span class="hs-comment">-- &gt; preOrderNode :: a -&gt; Tree a -&gt; Tree a -&gt; Tree a</span><span>
</span><span id="line-868"></span><span class="hs-comment">-- &gt; preOrderNode x l r = Node l x r</span><span>
</span><span id="line-869"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-870"></span><span class="hs-comment">-- &gt; postOrderNode :: Tree a -&gt; Tree a -&gt; a -&gt; Tree a</span><span>
</span><span id="line-871"></span><span class="hs-comment">-- &gt; postOrderNode l r x = Node l x r</span><span>
</span><span id="line-872"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-873"></span><span class="hs-comment">-- &gt; -- Traversable instance with in-order traversal</span><span>
</span><span id="line-874"></span><span class="hs-comment">-- &gt; instance Traversable Tree where</span><span>
</span><span id="line-875"></span><span class="hs-comment">-- &gt;     traverse g t = case t of</span><span>
</span><span id="line-876"></span><span class="hs-comment">-- &gt;         Empty      -&gt; pure Empty</span><span>
</span><span id="line-877"></span><span class="hs-comment">-- &gt;         Leaf x     -&gt; Leaf &lt;$&gt; g x</span><span>
</span><span id="line-878"></span><span class="hs-comment">-- &gt;         Node l x r -&gt; inOrderNode &lt;$&gt; traverse g l &lt;*&gt; g x &lt;*&gt; traverse g r</span><span>
</span><span id="line-879"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-880"></span><span class="hs-comment">-- &gt; -- Traversable instance with pre-order traversal</span><span>
</span><span id="line-881"></span><span class="hs-comment">-- &gt; instance Traversable Tree where</span><span>
</span><span id="line-882"></span><span class="hs-comment">-- &gt;     traverse g t = case t of</span><span>
</span><span id="line-883"></span><span class="hs-comment">-- &gt;         Empty      -&gt; pure Empty</span><span>
</span><span id="line-884"></span><span class="hs-comment">-- &gt;         Leaf x     -&gt; Leaf &lt;$&gt; g x</span><span>
</span><span id="line-885"></span><span class="hs-comment">-- &gt;         Node l x r -&gt; preOrderNode &lt;$&gt; g x &lt;*&gt; traverse g l &lt;*&gt; traverse g r</span><span>
</span><span id="line-886"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-887"></span><span class="hs-comment">-- &gt; -- Traversable instance with post-order traversal</span><span>
</span><span id="line-888"></span><span class="hs-comment">-- &gt; instance Traversable Tree where</span><span>
</span><span id="line-889"></span><span class="hs-comment">-- &gt;     traverse g t = case t of</span><span>
</span><span id="line-890"></span><span class="hs-comment">-- &gt;         Empty      -&gt; pure Empty</span><span>
</span><span id="line-891"></span><span class="hs-comment">-- &gt;         Leaf x     -&gt; Leaf &lt;$&gt; g x</span><span>
</span><span id="line-892"></span><span class="hs-comment">-- &gt;         Node l x r -&gt; postOrderNode &lt;$&gt; traverse g l &lt;*&gt; traverse g r &lt;*&gt; g x</span><span>
</span><span id="line-893"></span><span class="hs-comment">--</span><span>
</span><span id="line-894"></span><span class="hs-comment">-- Since the same underlying Tree structure is used in all three cases, it is</span><span>
</span><span id="line-895"></span><span class="hs-comment">-- possible to use @newtype@ wrappers to make all three available at the same</span><span>
</span><span id="line-896"></span><span class="hs-comment">-- time!  The user need only wrap the root of the tree in the appropriate</span><span>
</span><span id="line-897"></span><span class="hs-comment">-- @newtype@ for the desired traversal order.  Tne associated instance</span><span>
</span><span id="line-898"></span><span class="hs-comment">-- definitions are shown below (see [coercion](#coercion) if unfamiliar with</span><span>
</span><span id="line-899"></span><span class="hs-comment">-- the use of 'coerce' in the sample code):</span><span>
</span><span id="line-900"></span><span class="hs-comment">--</span><span>
</span><span id="line-901"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-902"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-903"></span><span class="hs-comment">-- &gt; -- Default in-order traversal</span><span>
</span><span id="line-904"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-905"></span><span class="hs-comment">-- &gt; import Data.Coerce (coerce)</span><span>
</span><span id="line-906"></span><span class="hs-comment">-- &gt; import Data.Traversable</span><span>
</span><span id="line-907"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-908"></span><span class="hs-comment">-- &gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)</span><span>
</span><span id="line-909"></span><span class="hs-comment">-- &gt; instance Functor  Tree where fmap    = fmapDefault</span><span>
</span><span id="line-910"></span><span class="hs-comment">-- &gt; instance Foldable Tree where foldMap = foldMapDefault</span><span>
</span><span id="line-911"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-912"></span><span class="hs-comment">-- &gt; instance Traversable Tree where</span><span>
</span><span id="line-913"></span><span class="hs-comment">-- &gt;     traverse _ Empty = pure Empty</span><span>
</span><span id="line-914"></span><span class="hs-comment">-- &gt;     traverse g (Leaf a) = Leaf &lt;$&gt; g a</span><span>
</span><span id="line-915"></span><span class="hs-comment">-- &gt;     traverse g (Node l a r) = Node &lt;$&gt; traverse g l &lt;*&gt; g a &lt;*&gt; traverse g r</span><span>
</span><span id="line-916"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-917"></span><span class="hs-comment">-- &gt; -- Optional pre-order traversal</span><span>
</span><span id="line-918"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-919"></span><span class="hs-comment">-- &gt; newtype PreOrderTree a = PreOrderTree (Tree a)</span><span>
</span><span id="line-920"></span><span class="hs-comment">-- &gt; instance Functor  PreOrderTree where fmap    = fmapDefault</span><span>
</span><span id="line-921"></span><span class="hs-comment">-- &gt; instance Foldable PreOrderTree where foldMap = foldMapDefault</span><span>
</span><span id="line-922"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-923"></span><span class="hs-comment">-- &gt; instance Traversable PreOrderTree where</span><span>
</span><span id="line-924"></span><span class="hs-comment">-- &gt;     traverse _ (PreOrderTree Empty)        = pure $ preOrderEmpty</span><span>
</span><span id="line-925"></span><span class="hs-comment">-- &gt;     traverse g (PreOrderTree (Leaf x))     = preOrderLeaf &lt;$&gt; g x</span><span>
</span><span id="line-926"></span><span class="hs-comment">-- &gt;     traverse g (PreOrderTree (Node l x r)) = preOrderNode</span><span>
</span><span id="line-927"></span><span class="hs-comment">-- &gt;         &lt;$&gt; g x</span><span>
</span><span id="line-928"></span><span class="hs-comment">-- &gt;         &lt;*&gt; traverse g (coerce l)</span><span>
</span><span id="line-929"></span><span class="hs-comment">-- &gt;         &lt;*&gt; traverse g (coerce r)</span><span>
</span><span id="line-930"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-931"></span><span class="hs-comment">-- &gt; preOrderEmpty :: forall a. PreOrderTree a</span><span>
</span><span id="line-932"></span><span class="hs-comment">-- &gt; preOrderEmpty = coerce (Empty @a)</span><span>
</span><span id="line-933"></span><span class="hs-comment">-- &gt; preOrderLeaf :: forall a. a -&gt; PreOrderTree a</span><span>
</span><span id="line-934"></span><span class="hs-comment">-- &gt; preOrderLeaf = coerce (Leaf @a)</span><span>
</span><span id="line-935"></span><span class="hs-comment">-- &gt; preOrderNode :: a -&gt; PreOrderTree a -&gt; PreOrderTree a -&gt; PreOrderTree a</span><span>
</span><span id="line-936"></span><span class="hs-comment">-- &gt; preOrderNode x l r = coerce (Node (coerce l) x (coerce r))</span><span>
</span><span id="line-937"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-938"></span><span class="hs-comment">-- &gt; -- Optional post-order traversal</span><span>
</span><span id="line-939"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-940"></span><span class="hs-comment">-- &gt; newtype PostOrderTree a = PostOrderTree (Tree a)</span><span>
</span><span id="line-941"></span><span class="hs-comment">-- &gt; instance Functor  PostOrderTree where fmap    = fmapDefault</span><span>
</span><span id="line-942"></span><span class="hs-comment">-- &gt; instance Foldable PostOrderTree where foldMap = foldMapDefault</span><span>
</span><span id="line-943"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-944"></span><span class="hs-comment">-- &gt; instance Traversable PostOrderTree where</span><span>
</span><span id="line-945"></span><span class="hs-comment">-- &gt;     traverse _ (PostOrderTree Empty)        = pure postOrderEmpty</span><span>
</span><span id="line-946"></span><span class="hs-comment">-- &gt;     traverse g (PostOrderTree (Leaf x))     = postOrderLeaf &lt;$&gt; g x</span><span>
</span><span id="line-947"></span><span class="hs-comment">-- &gt;     traverse g (PostOrderTree (Node l x r)) = postOrderNode</span><span>
</span><span id="line-948"></span><span class="hs-comment">-- &gt;         &lt;$&gt; traverse g (coerce l)</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- &gt;         &lt;*&gt; traverse g (coerce r)</span><span>
</span><span id="line-950"></span><span class="hs-comment">-- &gt;         &lt;*&gt; g x</span><span>
</span><span id="line-951"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-952"></span><span class="hs-comment">-- &gt; postOrderEmpty :: forall a. PostOrderTree a</span><span>
</span><span id="line-953"></span><span class="hs-comment">-- &gt; postOrderEmpty = coerce (Empty @a)</span><span>
</span><span id="line-954"></span><span class="hs-comment">-- &gt; postOrderLeaf :: forall a. a -&gt; PostOrderTree a</span><span>
</span><span id="line-955"></span><span class="hs-comment">-- &gt; postOrderLeaf = coerce (Leaf @a)</span><span>
</span><span id="line-956"></span><span class="hs-comment">-- &gt; postOrderNode :: PostOrderTree a -&gt; PostOrderTree a -&gt; a -&gt; PostOrderTree a</span><span>
</span><span id="line-957"></span><span class="hs-comment">-- &gt; postOrderNode l r x = coerce (Node (coerce l) x (coerce r))</span><span>
</span><span id="line-958"></span><span class="hs-comment">--</span><span>
</span><span id="line-959"></span><span class="hs-comment">-- With the above, given a sample tree:</span><span>
</span><span id="line-960"></span><span class="hs-comment">--</span><span>
</span><span id="line-961"></span><span class="hs-comment">-- &gt; inOrder :: Tree Int</span><span>
</span><span id="line-962"></span><span class="hs-comment">-- &gt; inOrder = Node (Node (Leaf 10) 3 (Leaf 20)) 5 (Leaf 42)</span><span>
</span><span id="line-963"></span><span class="hs-comment">--</span><span>
</span><span id="line-964"></span><span class="hs-comment">-- we have:</span><span>
</span><span id="line-965"></span><span class="hs-comment">--</span><span>
</span><span id="line-966"></span><span class="hs-comment">-- &gt; import Data.Foldable (toList)</span><span>
</span><span id="line-967"></span><span class="hs-comment">-- &gt; print $ toList inOrder</span><span>
</span><span id="line-968"></span><span class="hs-comment">-- &gt; [10,3,20,5,42]</span><span>
</span><span id="line-969"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-970"></span><span class="hs-comment">-- &gt; print $ toList (coerce inOrder :: PreOrderTree Int)</span><span>
</span><span id="line-971"></span><span class="hs-comment">-- &gt; [5,3,10,20,42]</span><span>
</span><span id="line-972"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-973"></span><span class="hs-comment">-- &gt; print $ toList (coerce inOrder :: PostOrderTree Int)</span><span>
</span><span id="line-974"></span><span class="hs-comment">-- &gt; [10,20,3,42,5]</span><span>
</span><span id="line-975"></span><span class="hs-comment">--</span><span>
</span><span id="line-976"></span><span class="hs-comment">-- You would typically define instances for additional common type classes,</span><span>
</span><span id="line-977"></span><span class="hs-comment">-- such as 'Eq', 'Ord', 'Show', etc.</span><span>
</span><span id="line-978"></span><span>
</span><span id="line-979"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-980"></span><span>
</span><span id="line-981"></span><span class="hs-comment">-- $construction</span><span>
</span><span id="line-982"></span><span class="hs-comment">--</span><span>
</span><span id="line-983"></span><span class="hs-comment">-- #construction#</span><span>
</span><span id="line-984"></span><span class="hs-comment">-- In order to be able to reason about how a given type of 'Applicative'</span><span>
</span><span id="line-985"></span><span class="hs-comment">-- effects will be sequenced through a general 'Traversable' structure by its</span><span>
</span><span id="line-986"></span><span class="hs-comment">-- 'traversable' and related methods, it is helpful to look more closely</span><span>
</span><span id="line-987"></span><span class="hs-comment">-- at how a general 'traverse' method is implemented.  We'll look at how</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- general traversals are constructed primarily with a view to being able</span><span>
</span><span id="line-989"></span><span class="hs-comment">-- to predict their behaviour as a user, even if you're not defining your</span><span>
</span><span id="line-990"></span><span class="hs-comment">-- own 'Traversable' instances.</span><span>
</span><span id="line-991"></span><span class="hs-comment">--</span><span>
</span><span id="line-992"></span><span class="hs-comment">-- Traversable structures __@t a@__ are assembled incrementally from their</span><span>
</span><span id="line-993"></span><span class="hs-comment">-- constituent parts, perhaps by prepending or appending individual elements of</span><span>
</span><span id="line-994"></span><span class="hs-comment">-- type __@a@__, or, more generally, by recursively combining smaller composite</span><span>
</span><span id="line-995"></span><span class="hs-comment">-- traversable building blocks that contain multiple such elements.</span><span>
</span><span id="line-996"></span><span class="hs-comment">--</span><span>
</span><span id="line-997"></span><span class="hs-comment">-- As in the [tree example](#tree) above, the components being combined are</span><span>
</span><span id="line-998"></span><span class="hs-comment">-- typically pieced together by a suitable /constructor/, i.e. a function</span><span>
</span><span id="line-999"></span><span class="hs-comment">-- taking two or more arguments that returns a composite value.</span><span>
</span><span id="line-1000"></span><span class="hs-comment">--</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- The 'traverse' method enriches simple incremental construction with</span><span>
</span><span id="line-1002"></span><span class="hs-comment">-- threading of 'Applicative' effects of some function __@g :: a -&gt; f b@__.</span><span>
</span><span id="line-1003"></span><span class="hs-comment">--</span><span>
</span><span id="line-1004"></span><span class="hs-comment">-- The basic building blocks we'll use to model the construction of 'traverse'</span><span>
</span><span id="line-1005"></span><span class="hs-comment">-- are a hypothetical set of elementary functions, some of which may have</span><span>
</span><span id="line-1006"></span><span class="hs-comment">-- direct analogues in specific @Traversable@ structures.  For example, the</span><span>
</span><span id="line-1007"></span><span class="hs-comment">-- __@(':')@__ constructor is an analogue for lists of @prepend@ or the more</span><span>
</span><span id="line-1008"></span><span class="hs-comment">-- general @combine@.</span><span>
</span><span id="line-1009"></span><span class="hs-comment">--</span><span>
</span><span id="line-1010"></span><span class="hs-comment">-- &gt; empty :: t a               -- build an empty container</span><span>
</span><span id="line-1011"></span><span class="hs-comment">-- &gt; singleton :: a -&gt; t a      -- build a one-element container</span><span>
</span><span id="line-1012"></span><span class="hs-comment">-- &gt; prepend :: a -&gt; t a -&gt; t a -- extend by prepending a new initial element</span><span>
</span><span id="line-1013"></span><span class="hs-comment">-- &gt; append  :: t a -&gt; a -&gt; t a -- extend by appending a new final element</span><span>
</span><span id="line-1014"></span><span class="hs-comment">-- &gt; combine :: a1 -&gt; a2 -&gt; ... -&gt; an -&gt; t a -- combine multiple inputs</span><span>
</span><span id="line-1015"></span><span class="hs-comment">--</span><span>
</span><span id="line-1016"></span><span class="hs-comment">-- * An empty structure has no elements of type __@a@__, so there's nothing</span><span>
</span><span id="line-1017"></span><span class="hs-comment">--   to which __@g@__ can be applied, but since we need an output of type</span><span>
</span><span id="line-1018"></span><span class="hs-comment">--   __@f (t b)@__, we just use the 'pure' instance of __@f@__ to wrap an</span><span>
</span><span id="line-1019"></span><span class="hs-comment">--   empty of type __@t b@__:</span><span>
</span><span id="line-1020"></span><span class="hs-comment">--</span><span>
</span><span id="line-1021"></span><span class="hs-comment">--     &gt; traverse _ (empty :: t a) = pure (empty :: t b)</span><span>
</span><span id="line-1022"></span><span class="hs-comment">--</span><span>
</span><span id="line-1023"></span><span class="hs-comment">--     With the List monad, /empty/ is __@[]@__, while with 'Maybe' it is</span><span>
</span><span id="line-1024"></span><span class="hs-comment">--     'Nothing'.  With __@Either e a@__ we have an /empty/ case for each</span><span>
</span><span id="line-1025"></span><span class="hs-comment">--     value of __@e@__:</span><span>
</span><span id="line-1026"></span><span class="hs-comment">--</span><span>
</span><span id="line-1027"></span><span class="hs-comment">--     &gt; traverse _ (Left e :: Either e a) = pure $ (Left e :: Either e b)</span><span>
</span><span id="line-1028"></span><span class="hs-comment">--</span><span>
</span><span id="line-1029"></span><span class="hs-comment">-- * A singleton structure has just one element of type __@a@__, and</span><span>
</span><span id="line-1030"></span><span class="hs-comment">--   'traverse' can take that __@a@__, apply __@g :: a -&gt; f b@__ getting an</span><span>
</span><span id="line-1031"></span><span class="hs-comment">--   __@f b@__, then __@fmap singleton@__ over that, getting an __@f (t b)@__</span><span>
</span><span id="line-1032"></span><span class="hs-comment">--   as required:</span><span>
</span><span id="line-1033"></span><span class="hs-comment">--</span><span>
</span><span id="line-1034"></span><span class="hs-comment">--     &gt; traverse g (singleton a) = fmap singleton $ g a</span><span>
</span><span id="line-1035"></span><span class="hs-comment">--</span><span>
</span><span id="line-1036"></span><span class="hs-comment">--     Note that if __@f@__ is __@List@__ and __@g@__ returns multiple values</span><span>
</span><span id="line-1037"></span><span class="hs-comment">--     the result will be a list of multiple __@t b@__ singletons!</span><span>
</span><span id="line-1038"></span><span class="hs-comment">--</span><span>
</span><span id="line-1039"></span><span class="hs-comment">--     Since 'Maybe' and 'Either' are either empty or singletons, we have</span><span>
</span><span id="line-1040"></span><span class="hs-comment">--</span><span>
</span><span id="line-1041"></span><span class="hs-comment">--     &gt; traverse _ Nothing = pure Nothing</span><span>
</span><span id="line-1042"></span><span class="hs-comment">--     &gt; traverse g (Just a) = Just &lt;$&gt; g a</span><span>
</span><span id="line-1043"></span><span class="hs-comment">--</span><span>
</span><span id="line-1044"></span><span class="hs-comment">--     &gt; traverse _ (Left e) = pure (Left e)</span><span>
</span><span id="line-1045"></span><span class="hs-comment">--     &gt; traverse g (Right a) = Right &lt;$&gt; g a</span><span>
</span><span id="line-1046"></span><span class="hs-comment">--</span><span>
</span><span id="line-1047"></span><span class="hs-comment">--     For @List@, empty is __@[]@__ and @singleton@ is __@(:[])@__, so we have:</span><span>
</span><span id="line-1048"></span><span class="hs-comment">--</span><span>
</span><span id="line-1049"></span><span class="hs-comment">--     &gt; traverse _ []  = pure []</span><span>
</span><span id="line-1050"></span><span class="hs-comment">--     &gt; traverse g [a] = fmap (:[]) (g a)</span><span>
</span><span id="line-1051"></span><span class="hs-comment">--     &gt;                = (:) &lt;$&gt; (g a) &lt;*&gt; traverse g []</span><span>
</span><span id="line-1052"></span><span class="hs-comment">--     &gt;                = liftA2 (:) (g a) (traverse g [])</span><span>
</span><span id="line-1053"></span><span class="hs-comment">--</span><span>
</span><span id="line-1054"></span><span class="hs-comment">-- * When the structure is built by adding one more element via __@prepend@__</span><span>
</span><span id="line-1055"></span><span class="hs-comment">--   or __@append@__, traversal amounts to:</span><span>
</span><span id="line-1056"></span><span class="hs-comment">--</span><span>
</span><span id="line-1057"></span><span class="hs-comment">--     &gt; traverse g (prepend a t0) = prepend &lt;$&gt; (g a) &lt;*&gt; traverse g t0</span><span>
</span><span id="line-1058"></span><span class="hs-comment">--     &gt;                           = liftA2 prepend (g a) (traverse g t0)</span><span>
</span><span id="line-1059"></span><span class="hs-comment">--</span><span>
</span><span id="line-1060"></span><span class="hs-comment">--     &gt; traverse g (append t0 a) = append &lt;$&gt; traverse g t0 &lt;*&gt; g a</span><span>
</span><span id="line-1061"></span><span class="hs-comment">--     &gt;                          = liftA2 append (traverse g t0) (g a)</span><span>
</span><span id="line-1062"></span><span class="hs-comment">--</span><span>
</span><span id="line-1063"></span><span class="hs-comment">--     The origin of the combinatorial product when __@f@__ is @List@ should now</span><span>
</span><span id="line-1064"></span><span class="hs-comment">--     be apparent, when __@traverse g t0@__ has __@n@__ elements and __@g a@__</span><span>
</span><span id="line-1065"></span><span class="hs-comment">--     has __@m@__ elements, the /non-deterministic/ 'Applicative' instance of</span><span>
</span><span id="line-1066"></span><span class="hs-comment">--     @List@ will produce a result with __@m * n@__ elements.</span><span>
</span><span id="line-1067"></span><span class="hs-comment">--</span><span>
</span><span id="line-1068"></span><span class="hs-comment">-- * When combining larger building blocks, we again use __@('&lt;*&gt;')@__ to</span><span>
</span><span id="line-1069"></span><span class="hs-comment">--   combine the traversals of the components.  With bare elements __@a@__</span><span>
</span><span id="line-1070"></span><span class="hs-comment">--   mapped to __@f b@__ via __@g@__, and composite traversable</span><span>
</span><span id="line-1071"></span><span class="hs-comment">--   sub-structures transformed via __@traverse g@__:</span><span>
</span><span id="line-1072"></span><span class="hs-comment">--</span><span>
</span><span id="line-1073"></span><span class="hs-comment">--     &gt; traverse g (combine a1 a2 ... an) =</span><span>
</span><span id="line-1074"></span><span class="hs-comment">--     &gt;     combine &lt;$&gt; t1 &lt;*&gt; t2 &lt;*&gt; ... &lt;*&gt; tn</span><span>
</span><span id="line-1075"></span><span class="hs-comment">--     &gt;   where</span><span>
</span><span id="line-1076"></span><span class="hs-comment">--     &gt;      t1 = g a1          -- if a1 fills a slot of type @a@</span><span>
</span><span id="line-1077"></span><span class="hs-comment">--     &gt;         = traverse g a1 -- if a1 is a traversable substructure</span><span>
</span><span id="line-1078"></span><span class="hs-comment">--     &gt;      ... ditto for the remaining constructor arguments ...</span><span>
</span><span id="line-1079"></span><span class="hs-comment">--</span><span>
</span><span id="line-1080"></span><span class="hs-comment">-- The above definitions sequence the 'Applicative' effects of __@f@__ in the</span><span>
</span><span id="line-1081"></span><span class="hs-comment">-- expected order while producing results of the expected shape __@t@__.</span><span>
</span><span id="line-1082"></span><span class="hs-comment">--</span><span>
</span><span id="line-1083"></span><span class="hs-comment">-- For lists this becomes:</span><span>
</span><span id="line-1084"></span><span class="hs-comment">--</span><span>
</span><span id="line-1085"></span><span class="hs-comment">-- &gt; traverse g [] = pure []</span><span>
</span><span id="line-1086"></span><span class="hs-comment">-- &gt; traverse g (x:xs) = liftA2 (:) (g a) (traverse g xs)</span><span>
</span><span id="line-1087"></span><span class="hs-comment">--</span><span>
</span><span id="line-1088"></span><span class="hs-comment">-- The actual definition of 'traverse' for lists is an equivalent</span><span>
</span><span id="line-1089"></span><span class="hs-comment">-- right fold in order to facilitate list /fusion/.</span><span>
</span><span id="line-1090"></span><span class="hs-comment">--</span><span>
</span><span id="line-1091"></span><span class="hs-comment">-- &gt; traverse g = foldr (\x r -&gt; liftA2 (:) (g x) r) (pure [])</span><span>
</span><span id="line-1092"></span><span>
</span><span id="line-1093"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1094"></span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- $advanced</span><span>
</span><span id="line-1096"></span><span class="hs-comment">--</span><span>
</span><span id="line-1097"></span><span class="hs-comment">-- #advanced#</span><span>
</span><span id="line-1098"></span><span class="hs-comment">-- In the sections below we'll examine some advanced choices of 'Applicative'</span><span>
</span><span id="line-1099"></span><span class="hs-comment">-- effects that give rise to very different transformations of @Traversable@</span><span>
</span><span id="line-1100"></span><span class="hs-comment">-- structures.</span><span>
</span><span id="line-1101"></span><span class="hs-comment">--</span><span>
</span><span id="line-1102"></span><span class="hs-comment">-- These examples cover the implementations of 'fmapDefault', 'foldMapDefault',</span><span>
</span><span id="line-1103"></span><span class="hs-comment">-- 'mapAccumL' and 'mapAccumR' functions illustrating the use of 'Identity',</span><span>
</span><span id="line-1104"></span><span class="hs-comment">-- 'Const' and stateful 'Applicative' effects.  The [ZipList](#ziplist) example</span><span>
</span><span id="line-1105"></span><span class="hs-comment">-- illustrates the use of a less-well known 'Applicative' instance for lists.</span><span>
</span><span id="line-1106"></span><span class="hs-comment">--</span><span>
</span><span id="line-1107"></span><span class="hs-comment">-- This is optional material, which is not essential to a basic understanding of</span><span>
</span><span id="line-1108"></span><span class="hs-comment">-- @Traversable@ structures.  If this is your first encounter with @Traversable@</span><span>
</span><span id="line-1109"></span><span class="hs-comment">-- structures, you can come back to these at a later date.</span><span>
</span><span id="line-1110"></span><span>
</span><span id="line-1111"></span><span class="hs-comment">-- $coercion</span><span>
</span><span id="line-1112"></span><span class="hs-comment">--</span><span>
</span><span id="line-1113"></span><span class="hs-comment">-- #coercion#</span><span>
</span><span id="line-1114"></span><span class="hs-comment">-- Some of the examples make use of an advanced Haskell feature, namely</span><span>
</span><span id="line-1115"></span><span class="hs-comment">-- @newtype@ /coercion/.  This is done for two reasons:</span><span>
</span><span id="line-1116"></span><span class="hs-comment">--</span><span>
</span><span id="line-1117"></span><span class="hs-comment">-- * Use of 'coerce' makes it possible to avoid cluttering the code with</span><span>
</span><span id="line-1118"></span><span class="hs-comment">--   functions that wrap and unwrap /newtype/ terms, which at runtime are</span><span>
</span><span id="line-1119"></span><span class="hs-comment">--   indistinguishable from the underlying value.  Coercion is particularly</span><span>
</span><span id="line-1120"></span><span class="hs-comment">--   convenient when one would have to otherwise apply multiple newtype</span><span>
</span><span id="line-1121"></span><span class="hs-comment">--   constructors to function arguments, and then peel off multiple layers</span><span>
</span><span id="line-1122"></span><span class="hs-comment">--   of same from the function output.</span><span>
</span><span id="line-1123"></span><span class="hs-comment">--</span><span>
</span><span id="line-1124"></span><span class="hs-comment">-- * Use of 'coerce' can produce more efficient code, by reusing the original</span><span>
</span><span id="line-1125"></span><span class="hs-comment">--   value, rather than allocating space for a wrapped clone.</span><span>
</span><span id="line-1126"></span><span class="hs-comment">--</span><span>
</span><span id="line-1127"></span><span class="hs-comment">-- If you're not familiar with 'coerce', don't worry, it is just a shorthand</span><span>
</span><span id="line-1128"></span><span class="hs-comment">-- that, e.g., given:</span><span>
</span><span id="line-1129"></span><span class="hs-comment">--</span><span>
</span><span id="line-1130"></span><span class="hs-comment">-- &gt; newtype Foo a = MkFoo { getFoo :: a }</span><span>
</span><span id="line-1131"></span><span class="hs-comment">-- &gt; newtype Bar a = MkBar { getBar :: a }</span><span>
</span><span id="line-1132"></span><span class="hs-comment">-- &gt; newtype Baz a = MkBaz { getBaz :: a }</span><span>
</span><span id="line-1133"></span><span class="hs-comment">-- &gt; f :: Baz Int -&gt; Bar (Foo String)</span><span>
</span><span id="line-1134"></span><span class="hs-comment">--</span><span>
</span><span id="line-1135"></span><span class="hs-comment">-- makes it possible to write:</span><span>
</span><span id="line-1136"></span><span class="hs-comment">--</span><span>
</span><span id="line-1137"></span><span class="hs-comment">-- &gt; x :: Int -&gt; String</span><span>
</span><span id="line-1138"></span><span class="hs-comment">-- &gt; x = coerce f</span><span>
</span><span id="line-1139"></span><span class="hs-comment">--</span><span>
</span><span id="line-1140"></span><span class="hs-comment">-- instead of</span><span>
</span><span id="line-1141"></span><span class="hs-comment">--</span><span>
</span><span id="line-1142"></span><span class="hs-comment">-- &gt; x = getFoo . getBar . f . MkBaz</span><span>
</span><span id="line-1143"></span><span>
</span><span id="line-1144"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1145"></span><span>
</span><span id="line-1146"></span><span class="hs-comment">-- $identity</span><span>
</span><span id="line-1147"></span><span class="hs-comment">--</span><span>
</span><span id="line-1148"></span><span class="hs-comment">-- #identity#</span><span>
</span><span id="line-1149"></span><span class="hs-comment">-- The simplest Applicative functor is 'Identity', which just wraps and unwraps</span><span>
</span><span id="line-1150"></span><span class="hs-comment">-- pure values and function application.  This allows us to define</span><span>
</span><span id="line-1151"></span><span class="hs-comment">-- 'fmapDefault':</span><span>
</span><span id="line-1152"></span><span class="hs-comment">--</span><span>
</span><span id="line-1153"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1154"></span><span class="hs-comment">-- &gt; import Data.Coercible (coerce)</span><span>
</span><span id="line-1155"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1156"></span><span class="hs-comment">-- &gt; fmapDefault :: forall t a b. Traversable t =&gt; (a -&gt; b) -&gt; t a -&gt; t b</span><span>
</span><span id="line-1157"></span><span class="hs-comment">-- &gt; fmapDefault = coerce (traverse @t @Identity @a @b)</span><span>
</span><span id="line-1158"></span><span class="hs-comment">--</span><span>
</span><span id="line-1159"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1160"></span><span class="hs-comment">-- unwrap terms via 'Identity' and 'runIdentity'.</span><span>
</span><span id="line-1161"></span><span class="hs-comment">--</span><span>
</span><span id="line-1162"></span><span class="hs-comment">-- As noted in [Overview](#overview), 'fmapDefault' can only be used to define</span><span>
</span><span id="line-1163"></span><span class="hs-comment">-- the requisite 'Functor' instance of a 'Traversable' structure when the</span><span>
</span><span id="line-1164"></span><span class="hs-comment">-- 'traverse' method is explicitly implemented.  An infinite loop would result</span><span>
</span><span id="line-1165"></span><span class="hs-comment">-- if in addition 'traverse' were defined in terms of 'sequenceA' and 'fmap'.</span><span>
</span><span id="line-1166"></span><span>
</span><span id="line-1167"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1168"></span><span>
</span><span id="line-1169"></span><span class="hs-comment">-- $stateful</span><span>
</span><span id="line-1170"></span><span class="hs-comment">--</span><span>
</span><span id="line-1171"></span><span class="hs-comment">-- #stateful#</span><span>
</span><span id="line-1172"></span><span class="hs-comment">-- Applicative functors that thread a changing state through a computation are</span><span>
</span><span id="line-1173"></span><span class="hs-comment">-- an interesting use-case for 'traverse'.  The 'mapAccumL' and 'mapAccumR'</span><span>
</span><span id="line-1174"></span><span class="hs-comment">-- functions in this module are each defined in terms of such traversals.</span><span>
</span><span id="line-1175"></span><span class="hs-comment">--</span><span>
</span><span id="line-1176"></span><span class="hs-comment">-- We first define a simplified (not a monad transformer) version of</span><span>
</span><span id="line-1177"></span><span class="hs-comment">-- 'Control.Monad.Trans.State.State' that threads a state __@s@__ through a</span><span>
</span><span id="line-1178"></span><span class="hs-comment">-- chain of computations left to right.  Its @('&lt;*&gt;')@ operator passes the</span><span>
</span><span id="line-1179"></span><span class="hs-comment">-- input state first to its left argument, and then the resulting state is</span><span>
</span><span id="line-1180"></span><span class="hs-comment">-- passed to its right argument, which returns the final state.</span><span>
</span><span id="line-1181"></span><span class="hs-comment">--</span><span>
</span><span id="line-1182"></span><span class="hs-comment">-- &gt; newtype StateL s a = StateL { runStateL :: s -&gt; (s, a) }</span><span>
</span><span id="line-1183"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1184"></span><span class="hs-comment">-- &gt; instance Functor (StateL s) where</span><span>
</span><span id="line-1185"></span><span class="hs-comment">-- &gt;     fmap f (StateL kx) = StateL $ \ s -&gt;</span><span>
</span><span id="line-1186"></span><span class="hs-comment">-- &gt;         let (s', x) = kx s in (s', f x)</span><span>
</span><span id="line-1187"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1188"></span><span class="hs-comment">-- &gt; instance Applicative (StateL s) where</span><span>
</span><span id="line-1189"></span><span class="hs-comment">-- &gt;     pure a = StateL $ \s -&gt; (s, a)</span><span>
</span><span id="line-1190"></span><span class="hs-comment">-- &gt;     (StateL kf) &lt;*&gt; (StateL kx) = StateL $ \ s -&gt;</span><span>
</span><span id="line-1191"></span><span class="hs-comment">-- &gt;         let { (s',  f) = kf s</span><span>
</span><span id="line-1192"></span><span class="hs-comment">-- &gt;             ; (s'', x) = kx s' } in (s'', f x)</span><span>
</span><span id="line-1193"></span><span class="hs-comment">-- &gt;     liftA2 f (StateL kx) (StateL ky) = StateL $ \ s -&gt;</span><span>
</span><span id="line-1194"></span><span class="hs-comment">-- &gt;         let { (s',  x) = kx s</span><span>
</span><span id="line-1195"></span><span class="hs-comment">-- &gt;             ; (s'', y) = ky s' } in (s'', f x y)</span><span>
</span><span id="line-1196"></span><span class="hs-comment">--</span><span>
</span><span id="line-1197"></span><span class="hs-comment">-- With @StateL@, we can define 'mapAccumL' as follows:</span><span>
</span><span id="line-1198"></span><span class="hs-comment">--</span><span>
</span><span id="line-1199"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1200"></span><span class="hs-comment">-- &gt; mapAccumL :: forall t s a b. Traversable t</span><span>
</span><span id="line-1201"></span><span class="hs-comment">-- &gt;           =&gt; (s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b)</span><span>
</span><span id="line-1202"></span><span class="hs-comment">-- &gt; mapAccumL g s ts = coerce (traverse @t @(StateL s) @a @b) (flip g) ts s</span><span>
</span><span id="line-1203"></span><span class="hs-comment">--</span><span>
</span><span id="line-1204"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1205"></span><span class="hs-comment">-- unwrap __@newtype@__ terms.</span><span>
</span><span id="line-1206"></span><span class="hs-comment">--</span><span>
</span><span id="line-1207"></span><span class="hs-comment">-- The type of __@flip g@__ is coercible to __@a -&gt; StateL b@__, which makes it</span><span>
</span><span id="line-1208"></span><span class="hs-comment">-- suitable for use with 'traverse'.  As part of the Applicative</span><span>
</span><span id="line-1209"></span><span class="hs-comment">-- [construction](#construction) of __@StateL (t b)@__ the state updates will</span><span>
</span><span id="line-1210"></span><span class="hs-comment">-- thread left-to-right along the sequence of elements of __@t a@__.</span><span>
</span><span id="line-1211"></span><span class="hs-comment">--</span><span>
</span><span id="line-1212"></span><span class="hs-comment">-- While 'mapAccumR' has a type signature identical to 'mapAccumL', it differs</span><span>
</span><span id="line-1213"></span><span class="hs-comment">-- in the expected order of evaluation of effects, which must take place</span><span>
</span><span id="line-1214"></span><span class="hs-comment">-- right-to-left.</span><span>
</span><span id="line-1215"></span><span class="hs-comment">--</span><span>
</span><span id="line-1216"></span><span class="hs-comment">-- For this we need a variant control structure @StateR@, which threads the</span><span>
</span><span id="line-1217"></span><span class="hs-comment">-- state right-to-left, by passing the input state to its right argument and</span><span>
</span><span id="line-1218"></span><span class="hs-comment">-- then using the resulting state as an input to its left argument:</span><span>
</span><span id="line-1219"></span><span class="hs-comment">--</span><span>
</span><span id="line-1220"></span><span class="hs-comment">-- &gt; newtype StateR s a = StateR { runStateR :: s -&gt; (s, a) }</span><span>
</span><span id="line-1221"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1222"></span><span class="hs-comment">-- &gt; instance Functor (StateR s) where</span><span>
</span><span id="line-1223"></span><span class="hs-comment">-- &gt;     fmap f (StateR kx) = StateR $ \s -&gt;</span><span>
</span><span id="line-1224"></span><span class="hs-comment">-- &gt;         let (s', x) = kx s in (s', f x)</span><span>
</span><span id="line-1225"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1226"></span><span class="hs-comment">-- &gt; instance Applicative (StateR s) where</span><span>
</span><span id="line-1227"></span><span class="hs-comment">-- &gt;     pure a = StateR $ \s -&gt; (s, a)</span><span>
</span><span id="line-1228"></span><span class="hs-comment">-- &gt;     (StateR kf) &lt;*&gt; (StateR kx) = StateR $ \ s -&gt;</span><span>
</span><span id="line-1229"></span><span class="hs-comment">-- &gt;         let { (s',  x) = kx s</span><span>
</span><span id="line-1230"></span><span class="hs-comment">-- &gt;             ; (s'', f) = kf s' } in (s'', f x)</span><span>
</span><span id="line-1231"></span><span class="hs-comment">-- &gt;     liftA2 f (StateR kx) (StateR ky) = StateR $ \ s -&gt;</span><span>
</span><span id="line-1232"></span><span class="hs-comment">-- &gt;         let { (s',  y) = ky s</span><span>
</span><span id="line-1233"></span><span class="hs-comment">-- &gt;             ; (s'', x) = kx s' } in (s'', f x y)</span><span>
</span><span id="line-1234"></span><span class="hs-comment">--</span><span>
</span><span id="line-1235"></span><span class="hs-comment">-- With @StateR@, we can define 'mapAccumR' as follows:</span><span>
</span><span id="line-1236"></span><span class="hs-comment">--</span><span>
</span><span id="line-1237"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1238"></span><span class="hs-comment">-- &gt; mapAccumR :: forall t s a b. Traversable t</span><span>
</span><span id="line-1239"></span><span class="hs-comment">-- &gt;           =&gt; (s -&gt; a -&gt; (s, b)) -&gt; s -&gt; t a -&gt; (s, t b)</span><span>
</span><span id="line-1240"></span><span class="hs-comment">-- &gt; mapAccumR g s0 ts = coerce (traverse @t @(StateR s) @a @b) (flip g) ts s0</span><span>
</span><span id="line-1241"></span><span class="hs-comment">--</span><span>
</span><span id="line-1242"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1243"></span><span class="hs-comment">-- unwrap __@newtype@__ terms.</span><span>
</span><span id="line-1244"></span><span class="hs-comment">--</span><span>
</span><span id="line-1245"></span><span class="hs-comment">-- Various stateful traversals can be constructed from 'mapAccumL' and</span><span>
</span><span id="line-1246"></span><span class="hs-comment">-- 'mapAccumR' for suitable choices of @g@, or built directly along similar</span><span>
</span><span id="line-1247"></span><span class="hs-comment">-- lines.</span><span>
</span><span id="line-1248"></span><span>
</span><span id="line-1249"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1250"></span><span>
</span><span id="line-1251"></span><span class="hs-comment">-- $phantom</span><span>
</span><span id="line-1252"></span><span class="hs-comment">--</span><span>
</span><span id="line-1253"></span><span class="hs-comment">-- #phantom#</span><span>
</span><span id="line-1254"></span><span class="hs-comment">-- The 'Const' Functor enables applications of 'traverse' that summarise the</span><span>
</span><span id="line-1255"></span><span class="hs-comment">-- input structure to an output value without constructing any output values</span><span>
</span><span id="line-1256"></span><span class="hs-comment">-- of the same type or shape.</span><span>
</span><span id="line-1257"></span><span class="hs-comment">--</span><span>
</span><span id="line-1258"></span><span class="hs-comment">-- As noted [above](#overview), the @Foldable@ superclass constraint is</span><span>
</span><span id="line-1259"></span><span class="hs-comment">-- justified by the fact that it is possible to construct 'foldMap', 'foldr',</span><span>
</span><span id="line-1260"></span><span class="hs-comment">-- etc., from 'traverse'.  The technique used is useful in its own right, and</span><span>
</span><span id="line-1261"></span><span class="hs-comment">-- is explored below.</span><span>
</span><span id="line-1262"></span><span class="hs-comment">--</span><span>
</span><span id="line-1263"></span><span class="hs-comment">-- A key feature of folds is that they can reduce the input structure to a</span><span>
</span><span id="line-1264"></span><span class="hs-comment">-- summary value. Often neither the input structure nor a mutated clone is</span><span>
</span><span id="line-1265"></span><span class="hs-comment">-- needed once the fold is computed, and through list fusion the input may not</span><span>
</span><span id="line-1266"></span><span class="hs-comment">-- even have been memory resident in its entirety at the same time.</span><span>
</span><span id="line-1267"></span><span class="hs-comment">--</span><span>
</span><span id="line-1268"></span><span class="hs-comment">-- The 'traverse' method does not at first seem to be a suitable building block</span><span>
</span><span id="line-1269"></span><span class="hs-comment">-- for folds, because its return value __@f (t b)@__ appears to retain mutated</span><span>
</span><span id="line-1270"></span><span class="hs-comment">-- copies of the input structure.  But the presence of __@t b@__ in the type</span><span>
</span><span id="line-1271"></span><span class="hs-comment">-- signature need not mean that terms of type __@t b@__ are actually embedded</span><span>
</span><span id="line-1272"></span><span class="hs-comment">-- in __@f (t b)@__.  The simplest way to elide the excess terms is by basing</span><span>
</span><span id="line-1273"></span><span class="hs-comment">-- the Applicative functor used with 'traverse' on 'Const'.</span><span>
</span><span id="line-1274"></span><span class="hs-comment">--</span><span>
</span><span id="line-1275"></span><span class="hs-comment">-- Not only does __@Const a b@__ hold just an __@a@__ value, with the __@b@__</span><span>
</span><span id="line-1276"></span><span class="hs-comment">-- parameter merely a /phantom/ type, but when __@m@__ has a 'Monoid' instance,</span><span>
</span><span id="line-1277"></span><span class="hs-comment">-- __@Const m@__ is an 'Applicative' functor:</span><span>
</span><span id="line-1278"></span><span class="hs-comment">--</span><span>
</span><span id="line-1279"></span><span class="hs-comment">-- &gt; import Data.Coerce (coerce)</span><span>
</span><span id="line-1280"></span><span class="hs-comment">-- &gt; newtype Const a b = Const { getConst :: a } deriving (Eq, Ord, Show) -- etc.</span><span>
</span><span id="line-1281"></span><span class="hs-comment">-- &gt; instance Functor (Const m) where fmap = const coerce</span><span>
</span><span id="line-1282"></span><span class="hs-comment">-- &gt; instance Monoid m =&gt; Applicative (Const m) where</span><span>
</span><span id="line-1283"></span><span class="hs-comment">-- &gt;    pure _   = Const mempty</span><span>
</span><span id="line-1284"></span><span class="hs-comment">-- &gt;    (&lt;*&gt;)    = coerce (mappend :: m -&gt; m -&gt; m)</span><span>
</span><span id="line-1285"></span><span class="hs-comment">-- &gt;    liftA2 _ = coerce (mappend :: m -&gt; m -&gt; m)</span><span>
</span><span id="line-1286"></span><span class="hs-comment">--</span><span>
</span><span id="line-1287"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1288"></span><span class="hs-comment">-- unwrap __@newtype@__ terms.</span><span>
</span><span id="line-1289"></span><span class="hs-comment">--</span><span>
</span><span id="line-1290"></span><span class="hs-comment">-- We can therefore define a specialisation of 'traverse':</span><span>
</span><span id="line-1291"></span><span class="hs-comment">--</span><span>
</span><span id="line-1292"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1293"></span><span class="hs-comment">-- &gt; traverseC :: forall t a m. (Monoid m, Traversable t)</span><span>
</span><span id="line-1294"></span><span class="hs-comment">-- &gt;           =&gt; (a -&gt; Const m ()) -&gt; t a -&gt; Const m (t ())</span><span>
</span><span id="line-1295"></span><span class="hs-comment">-- &gt; traverseC = traverse @t @(Const m) @a @()</span><span>
</span><span id="line-1296"></span><span class="hs-comment">--</span><span>
</span><span id="line-1297"></span><span class="hs-comment">-- For which the Applicative [construction](#construction) of 'traverse'</span><span>
</span><span id="line-1298"></span><span class="hs-comment">-- leads to:</span><span>
</span><span id="line-1299"></span><span class="hs-comment">--</span><span>
</span><span id="line-1300"></span><span class="hs-comment">-- prop&gt; null ts ==&gt; traverseC g ts = Const mempty</span><span>
</span><span id="line-1301"></span><span class="hs-comment">-- prop&gt; traverseC g (prepend x xs) = Const (g x) &lt;&gt; traverseC g xs</span><span>
</span><span id="line-1302"></span><span class="hs-comment">--</span><span>
</span><span id="line-1303"></span><span class="hs-comment">-- In other words, this makes it possible to define:</span><span>
</span><span id="line-1304"></span><span class="hs-comment">--</span><span>
</span><span id="line-1305"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1306"></span><span class="hs-comment">-- &gt; foldMapDefault :: forall t a m. (Monoid m, Traversable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><span>
</span><span id="line-1307"></span><span class="hs-comment">-- &gt; foldMapDefault = coerce (traverse @t @(Const m) @a @())</span><span>
</span><span id="line-1308"></span><span class="hs-comment">--</span><span>
</span><span id="line-1309"></span><span class="hs-comment">-- Which is sufficient to define a 'Foldable' superclass instance:</span><span>
</span><span id="line-1310"></span><span class="hs-comment">--</span><span>
</span><span id="line-1311"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1312"></span><span class="hs-comment">-- unwrap __@newtype@__ terms.</span><span>
</span><span id="line-1313"></span><span class="hs-comment">--</span><span>
</span><span id="line-1314"></span><span class="hs-comment">-- &gt; instance Traversable t =&gt; Foldable t where foldMap = foldMapDefault</span><span>
</span><span id="line-1315"></span><span class="hs-comment">--</span><span>
</span><span id="line-1316"></span><span class="hs-comment">-- It may however be instructive to also directly define candidate default</span><span>
</span><span id="line-1317"></span><span class="hs-comment">-- implementations of 'foldr' and 'foldl'', which take a bit more machinery</span><span>
</span><span id="line-1318"></span><span class="hs-comment">-- to construct:</span><span>
</span><span id="line-1319"></span><span class="hs-comment">--</span><span>
</span><span id="line-1320"></span><span class="hs-comment">-- &gt; {-# LANGUAGE ScopedTypeVariables, TypeApplications #-}</span><span>
</span><span id="line-1321"></span><span class="hs-comment">-- &gt; import Data.Coerce (coerce)</span><span>
</span><span id="line-1322"></span><span class="hs-comment">-- &gt; import Data.Functor.Const (Const(..))</span><span>
</span><span id="line-1323"></span><span class="hs-comment">-- &gt; import Data.Semigroup (Dual(..), Endo(..))</span><span>
</span><span id="line-1324"></span><span class="hs-comment">-- &gt; import GHC.Exts (oneShot)</span><span>
</span><span id="line-1325"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1326"></span><span class="hs-comment">-- &gt; foldrDefault :: forall t a b. Traversable t</span><span>
</span><span id="line-1327"></span><span class="hs-comment">-- &gt;              =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1328"></span><span class="hs-comment">-- &gt; foldrDefault f z = \t -&gt;</span><span>
</span><span id="line-1329"></span><span class="hs-comment">-- &gt;     coerce (traverse @t @(Const (Endo b)) @a @()) f t z</span><span>
</span><span id="line-1330"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1331"></span><span class="hs-comment">-- &gt; foldlDefault' :: forall t a b. Traversable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><span>
</span><span id="line-1332"></span><span class="hs-comment">-- &gt; foldlDefault' f z = \t -&gt;</span><span>
</span><span id="line-1333"></span><span class="hs-comment">-- &gt;     coerce (traverse @t @(Const (Dual (Endo b))) @a @()) f' t z</span><span>
</span><span id="line-1334"></span><span class="hs-comment">-- &gt;   where</span><span>
</span><span id="line-1335"></span><span class="hs-comment">-- &gt;     f' :: a -&gt; b -&gt; b</span><span>
</span><span id="line-1336"></span><span class="hs-comment">-- &gt;     f' a = oneShot $ \ b -&gt; b `seq` f b a</span><span>
</span><span id="line-1337"></span><span class="hs-comment">--</span><span>
</span><span id="line-1338"></span><span class="hs-comment">-- In the above we're using the __@'Data.Monoid.Endo' b@__ 'Monoid' and its</span><span>
</span><span id="line-1339"></span><span class="hs-comment">-- 'Dual' to compose a sequence of __@b -&gt; b@__ accumulator updates in either</span><span>
</span><span id="line-1340"></span><span class="hs-comment">-- left-to-right or right-to-left order.</span><span>
</span><span id="line-1341"></span><span class="hs-comment">--</span><span>
</span><span id="line-1342"></span><span class="hs-comment">-- The use of 'seq' in the definition of __@foldlDefault'@__ ensures strictness</span><span>
</span><span id="line-1343"></span><span class="hs-comment">-- in the accumulator.</span><span>
</span><span id="line-1344"></span><span class="hs-comment">--</span><span>
</span><span id="line-1345"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1346"></span><span class="hs-comment">-- unwrap __@newtype@__ terms.</span><span>
</span><span id="line-1347"></span><span class="hs-comment">--</span><span>
</span><span id="line-1348"></span><span class="hs-comment">-- The 'GHC.Exts.oneShot' function gives a hint to the compiler that aids in</span><span>
</span><span id="line-1349"></span><span class="hs-comment">-- correct optimisation of lambda terms that fire at most once (for each</span><span>
</span><span id="line-1350"></span><span class="hs-comment">-- element __@a@__) and so should not try to pre-compute and re-use</span><span>
</span><span id="line-1351"></span><span class="hs-comment">-- subexpressions that pay off only on repeated execution.  Otherwise, it is</span><span>
</span><span id="line-1352"></span><span class="hs-comment">-- just the identity function.</span><span>
</span><span id="line-1353"></span><span>
</span><span id="line-1354"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1355"></span><span>
</span><span id="line-1356"></span><span class="hs-comment">-- $ziplist</span><span>
</span><span id="line-1357"></span><span class="hs-comment">--</span><span>
</span><span id="line-1358"></span><span class="hs-comment">-- #ziplist#</span><span>
</span><span id="line-1359"></span><span class="hs-comment">-- As a warm-up for looking at the 'ZipList' 'Applicative' functor, we'll first</span><span>
</span><span id="line-1360"></span><span class="hs-comment">-- look at a simpler analogue.  First define a fixed width 2-element @Vec2@</span><span>
</span><span id="line-1361"></span><span class="hs-comment">-- type, whose 'Applicative' instance combines a pair of functions with a pair of</span><span>
</span><span id="line-1362"></span><span class="hs-comment">-- values by applying each function to the corresponding value slot:</span><span>
</span><span id="line-1363"></span><span class="hs-comment">--</span><span>
</span><span id="line-1364"></span><span class="hs-comment">-- &gt; data Vec2 a = Vec2 a a</span><span>
</span><span id="line-1365"></span><span class="hs-comment">-- &gt; instance Functor Vec2 where</span><span>
</span><span id="line-1366"></span><span class="hs-comment">-- &gt;     fmap f (Vec2 a b) = Vec2 (f a) (f b)</span><span>
</span><span id="line-1367"></span><span class="hs-comment">-- &gt; instance Applicative Vec2 where</span><span>
</span><span id="line-1368"></span><span class="hs-comment">-- &gt;     pure x = Vec2 x x</span><span>
</span><span id="line-1369"></span><span class="hs-comment">-- &gt;     liftA2 f (Vec2 a b) (Vec2 p q) = Vec2 (f a p) (f b q)</span><span>
</span><span id="line-1370"></span><span class="hs-comment">-- &gt; instance Foldable Vec2 where</span><span>
</span><span id="line-1371"></span><span class="hs-comment">-- &gt;     foldr f z (Vec2 a b) = f a (f b z)</span><span>
</span><span id="line-1372"></span><span class="hs-comment">-- &gt;     foldMap f (Vec2 a b) = f a &lt;&gt; f b</span><span>
</span><span id="line-1373"></span><span class="hs-comment">-- &gt; instance Traversable Vec2 where</span><span>
</span><span id="line-1374"></span><span class="hs-comment">-- &gt;     traverse f (Vec2 a b) = Vec2 &lt;$&gt; f a &lt;*&gt; f b</span><span>
</span><span id="line-1375"></span><span class="hs-comment">--</span><span>
</span><span id="line-1376"></span><span class="hs-comment">-- Along with a similar definition for fixed width 3-element vectors:</span><span>
</span><span id="line-1377"></span><span class="hs-comment">--</span><span>
</span><span id="line-1378"></span><span class="hs-comment">-- &gt; data Vec3 a = Vec3 a a a</span><span>
</span><span id="line-1379"></span><span class="hs-comment">-- &gt; instance Functor Vec3 where</span><span>
</span><span id="line-1380"></span><span class="hs-comment">-- &gt;     fmap f (Vec3 x y z) = Vec3 (f x) (f y) (f z)</span><span>
</span><span id="line-1381"></span><span class="hs-comment">-- &gt; instance Applicative Vec3 where</span><span>
</span><span id="line-1382"></span><span class="hs-comment">-- &gt;     pure x = Vec3 x x x</span><span>
</span><span id="line-1383"></span><span class="hs-comment">-- &gt;     liftA2 f (Vec3 p q r) (Vec3 x y z) = Vec3 (f p x) (f q y) (f r z)</span><span>
</span><span id="line-1384"></span><span class="hs-comment">-- &gt; instance Foldable Vec3 where</span><span>
</span><span id="line-1385"></span><span class="hs-comment">-- &gt;     foldr f z (Vec3 a b c) = f a (f b (f c z))</span><span>
</span><span id="line-1386"></span><span class="hs-comment">-- &gt;     foldMap f (Vec3 a b c) = f a &lt;&gt; f b &lt;&gt; f c</span><span>
</span><span id="line-1387"></span><span class="hs-comment">-- &gt; instance Traversable Vec3 where</span><span>
</span><span id="line-1388"></span><span class="hs-comment">-- &gt;     traverse f (Vec3 a b c) = Vec3 &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; f c</span><span>
</span><span id="line-1389"></span><span class="hs-comment">--</span><span>
</span><span id="line-1390"></span><span class="hs-comment">-- With the above definitions, @'sequenceA'@ (same as @'traverse' 'id'@) acts</span><span>
</span><span id="line-1391"></span><span class="hs-comment">-- as a /matrix transpose/ operation on @Vec2 (Vec3 Int)@ producing a</span><span>
</span><span id="line-1392"></span><span class="hs-comment">-- corresponding @Vec3 (Vec2 Int)@:</span><span>
</span><span id="line-1393"></span><span class="hs-comment">--</span><span>
</span><span id="line-1394"></span><span class="hs-comment">-- Let __@t = Vec2 (Vec3 1 2 3) (Vec3 4 5 6)@__ be our 'Traversable' structure,</span><span>
</span><span id="line-1395"></span><span class="hs-comment">-- and __@g = id :: Vec3 Int -&gt; Vec3 Int@__ be the function used to traverse</span><span>
</span><span id="line-1396"></span><span class="hs-comment">-- __@t@__.  We then have:</span><span>
</span><span id="line-1397"></span><span class="hs-comment">--</span><span>
</span><span id="line-1398"></span><span class="hs-comment">-- &gt; traverse g t = Vec2 &lt;$&gt; (Vec3 1 2 3) &lt;*&gt; (Vec3 4 5 6)</span><span>
</span><span id="line-1399"></span><span class="hs-comment">-- &gt;              = Vec3 (Vec2 1 4) (Vec2 2 5) (Vec2 3 6)</span><span>
</span><span id="line-1400"></span><span class="hs-comment">--</span><span>
</span><span id="line-1401"></span><span class="hs-comment">-- This construction can be generalised from fixed width vectors to variable</span><span>
</span><span id="line-1402"></span><span class="hs-comment">-- length lists via 'Control.Applicative.ZipList'.  This gives a transpose</span><span>
</span><span id="line-1403"></span><span class="hs-comment">-- operation that works well for lists of equal length.  If some of the lists</span><span>
</span><span id="line-1404"></span><span class="hs-comment">-- are longer than others, they're truncated to the longest common length.</span><span>
</span><span id="line-1405"></span><span class="hs-comment">--</span><span>
</span><span id="line-1406"></span><span class="hs-comment">-- We've already looked at the standard 'Applicative' instance of @List@ for</span><span>
</span><span id="line-1407"></span><span class="hs-comment">-- which applying __@m@__ functions __@f1, f2, ..., fm@__ to __@n@__ input</span><span>
</span><span id="line-1408"></span><span class="hs-comment">-- values __@a1, a2, ..., an@__ produces __@m * n@__ outputs:</span><span>
</span><span id="line-1409"></span><span class="hs-comment">--</span><span>
</span><span id="line-1410"></span><span class="hs-comment">-- &gt;&gt;&gt; :set -XTupleSections</span><span>
</span><span id="line-1411"></span><span class="hs-comment">-- &gt;&gt;&gt; [(&quot;f1&quot;,), (&quot;f2&quot;,), (&quot;f3&quot;,)] &lt;*&gt; [1,2]</span><span>
</span><span id="line-1412"></span><span class="hs-comment">-- [(&quot;f1&quot;,1),(&quot;f1&quot;,2),(&quot;f2&quot;,1),(&quot;f2&quot;,2),(&quot;f3&quot;,1),(&quot;f3&quot;,2)]</span><span>
</span><span id="line-1413"></span><span class="hs-comment">--</span><span>
</span><span id="line-1414"></span><span class="hs-comment">-- There are however two more common ways to turn lists into 'Applicative'</span><span>
</span><span id="line-1415"></span><span class="hs-comment">-- control structures.  The first is via __@'Const' [a]@__, since lists are</span><span>
</span><span id="line-1416"></span><span class="hs-comment">-- monoids under concatenation, and we've already seen that __@'Const' m@__ is</span><span>
</span><span id="line-1417"></span><span class="hs-comment">-- an 'Applicative' functor when __@m@__ is a 'Monoid'.  The second, is based</span><span>
</span><span id="line-1418"></span><span class="hs-comment">-- on 'Data.List.zipWith', and is called 'Control.Applicative.ZipList':</span><span>
</span><span id="line-1419"></span><span class="hs-comment">--</span><span>
</span><span id="line-1420"></span><span class="hs-comment">-- &gt; {-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span>
</span><span id="line-1421"></span><span class="hs-comment">-- &gt; newtype ZipList a = ZipList { getZipList :: [a] }</span><span>
</span><span id="line-1422"></span><span class="hs-comment">-- &gt;     deriving (Show, Eq, ..., Functor)</span><span>
</span><span id="line-1423"></span><span class="hs-comment">-- &gt;</span><span>
</span><span id="line-1424"></span><span class="hs-comment">-- &gt; instance Applicative ZipList where</span><span>
</span><span id="line-1425"></span><span class="hs-comment">-- &gt;     liftA2 f (ZipList xs) (ZipList ys) = ZipList $ zipWith f xs ys</span><span>
</span><span id="line-1426"></span><span class="hs-comment">-- &gt;     pure x = repeat x</span><span>
</span><span id="line-1427"></span><span class="hs-comment">--</span><span>
</span><span id="line-1428"></span><span class="hs-comment">-- The 'liftA2' definition is clear enough, instead of applying __@f@__ to each</span><span>
</span><span id="line-1429"></span><span class="hs-comment">-- pair __@(x, y)@__ drawn independently from the __@xs@__ and __@ys@__, only</span><span>
</span><span id="line-1430"></span><span class="hs-comment">-- corresponding pairs at each index in the two lists are used.</span><span>
</span><span id="line-1431"></span><span class="hs-comment">--</span><span>
</span><span id="line-1432"></span><span class="hs-comment">-- The definition of 'pure' may look surprising, but it is needed to ensure</span><span>
</span><span id="line-1433"></span><span class="hs-comment">-- that the instance is lawful:</span><span>
</span><span id="line-1434"></span><span class="hs-comment">--</span><span>
</span><span id="line-1435"></span><span class="hs-comment">-- prop&gt; liftA2 f (pure x) ys == fmap (f x) ys</span><span>
</span><span id="line-1436"></span><span class="hs-comment">--</span><span>
</span><span id="line-1437"></span><span class="hs-comment">-- Since __@ys@__ can have any length, we need to provide an infinite supply</span><span>
</span><span id="line-1438"></span><span class="hs-comment">-- of __@x@__ values in __@pure x@__ in order to have a value to pair with</span><span>
</span><span id="line-1439"></span><span class="hs-comment">-- each element __@y@__.</span><span>
</span><span id="line-1440"></span><span class="hs-comment">--</span><span>
</span><span id="line-1441"></span><span class="hs-comment">-- When 'Control.Applicative.ZipList' is the 'Applicative' functor used in the</span><span>
</span><span id="line-1442"></span><span class="hs-comment">-- [construction](#construction) of a traversal, a ZipList holding a partially</span><span>
</span><span id="line-1443"></span><span class="hs-comment">-- built structure with __@m@__ elements is combined with a component holding</span><span>
</span><span id="line-1444"></span><span class="hs-comment">-- __@n@__ elements via 'zipWith', resulting in __@min m n@__ outputs!</span><span>
</span><span id="line-1445"></span><span class="hs-comment">--</span><span>
</span><span id="line-1446"></span><span class="hs-comment">-- Therefore 'traverse' with __@g :: a -&gt; ZipList b@__ will produce a @ZipList@</span><span>
</span><span id="line-1447"></span><span class="hs-comment">-- of __@t b@__ structures whose element count is the minimum length of the</span><span>
</span><span id="line-1448"></span><span class="hs-comment">-- ZipLists __@g a@__ with __@a@__ ranging over the elements of __@t@__.  When</span><span>
</span><span id="line-1449"></span><span class="hs-comment">-- __@t@__ is empty, the length is infinite (as expected for a minimum of an</span><span>
</span><span id="line-1450"></span><span class="hs-comment">-- empty set).</span><span>
</span><span id="line-1451"></span><span class="hs-comment">--</span><span>
</span><span id="line-1452"></span><span class="hs-comment">-- If the structure __@t@__ holds values of type __@ZipList a@__, we can use</span><span>
</span><span id="line-1453"></span><span class="hs-comment">-- the identity function __@id :: ZipList a -&gt; ZipList a@__ for the first</span><span>
</span><span id="line-1454"></span><span class="hs-comment">-- argument of 'traverse':</span><span>
</span><span id="line-1455"></span><span class="hs-comment">--</span><span>
</span><span id="line-1456"></span><span class="hs-comment">-- &gt; traverse (id :: ZipList a -&gt; ZipList a) :: t (ZipList a) -&gt; ZipList (t a)</span><span>
</span><span id="line-1457"></span><span class="hs-comment">--</span><span>
</span><span id="line-1458"></span><span class="hs-comment">-- The number of elements in the output @ZipList@ will be the length of the</span><span>
</span><span id="line-1459"></span><span class="hs-comment">-- shortest @ZipList@ element of __@t@__.  Each output __@t a@__ will have the</span><span>
</span><span id="line-1460"></span><span class="hs-comment">-- /same shape/ as the input __@t (ZipList a)@__, i.e. will share its number of</span><span>
</span><span id="line-1461"></span><span class="hs-comment">-- elements.</span><span>
</span><span id="line-1462"></span><span class="hs-comment">--</span><span>
</span><span id="line-1463"></span><span class="hs-comment">-- If we think of the elements of __@t (ZipList a)@__ as its rows, and the</span><span>
</span><span id="line-1464"></span><span class="hs-comment">-- elements of each individual @ZipList@ as the columns of that row, we see</span><span>
</span><span id="line-1465"></span><span class="hs-comment">-- that our traversal implements a /transpose/ operation swapping the rows</span><span>
</span><span id="line-1466"></span><span class="hs-comment">-- and columns of __@t@__, after first truncating all the rows to the column</span><span>
</span><span id="line-1467"></span><span class="hs-comment">-- count of the shortest one.</span><span>
</span><span id="line-1468"></span><span class="hs-comment">--</span><span>
</span><span id="line-1469"></span><span class="hs-comment">-- Since in fact __@'traverse' id@__ is just 'sequenceA' the above boils down</span><span>
</span><span id="line-1470"></span><span class="hs-comment">-- to a rather concise definition of /transpose/, with [coercion](#coercion)</span><span>
</span><span id="line-1471"></span><span class="hs-comment">-- used to implicitly wrap and unwrap the @ZipList@ @newtype@ as needed, giving</span><span>
</span><span id="line-1472"></span><span class="hs-comment">-- a function that operates on a list of lists:</span><span>
</span><span id="line-1473"></span><span class="hs-comment">--</span><span>
</span><span id="line-1474"></span><span class="hs-comment">-- &gt;&gt;&gt; {-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-1475"></span><span class="hs-comment">-- &gt;&gt;&gt; import Control.Applicative (ZipList(..))</span><span>
</span><span id="line-1476"></span><span class="hs-comment">-- &gt;&gt;&gt; import Data.Coerce (coerce)</span><span>
</span><span id="line-1477"></span><span class="hs-comment">-- &gt;&gt;&gt;</span><span>
</span><span id="line-1478"></span><span class="hs-comment">-- &gt;&gt;&gt; transpose :: forall a. [[a]] -&gt; [[a]]</span><span>
</span><span id="line-1479"></span><span class="hs-comment">-- &gt;&gt;&gt; transpose = coerce (sequenceA :: [ZipList a] -&gt; ZipList [a])</span><span>
</span><span id="line-1480"></span><span class="hs-comment">-- &gt;&gt;&gt;</span><span>
</span><span id="line-1481"></span><span class="hs-comment">-- &gt;&gt;&gt; transpose [[1,2,3],[4..],[7..]]</span><span>
</span><span id="line-1482"></span><span class="hs-comment">-- [[1,4,7],[2,5,8],[3,6,9]]</span><span>
</span><span id="line-1483"></span><span class="hs-comment">--</span><span>
</span><span id="line-1484"></span><span class="hs-comment">-- The use of [coercion](#coercion) avoids the need to explicitly wrap and</span><span>
</span><span id="line-1485"></span><span class="hs-comment">-- unwrap __@ZipList@__ terms.</span><span>
</span><span id="line-1486"></span><span>
</span><span id="line-1487"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1488"></span><span>
</span><span id="line-1489"></span><span class="hs-comment">-- $laws</span><span>
</span><span id="line-1490"></span><span class="hs-comment">--</span><span>
</span><span id="line-1491"></span><span class="hs-comment">-- #laws#</span><span>
</span><span id="line-1492"></span><span class="hs-comment">-- A definition of 'traverse' must satisfy the following laws:</span><span>
</span><span id="line-1493"></span><span class="hs-comment">--</span><span>
</span><span id="line-1494"></span><span class="hs-comment">-- [Naturality]</span><span>
</span><span id="line-1495"></span><span class="hs-comment">--   @t . 'traverse' f = 'traverse' (t . f)@</span><span>
</span><span id="line-1496"></span><span class="hs-comment">--   for every applicative transformation @t@</span><span>
</span><span id="line-1497"></span><span class="hs-comment">--</span><span>
</span><span id="line-1498"></span><span class="hs-comment">-- [Identity]</span><span>
</span><span id="line-1499"></span><span class="hs-comment">--   @'traverse' 'Identity' = 'Identity'@</span><span>
</span><span id="line-1500"></span><span class="hs-comment">--</span><span>
</span><span id="line-1501"></span><span class="hs-comment">-- [Composition]</span><span>
</span><span id="line-1502"></span><span class="hs-comment">--   @'traverse' ('Data.Functor.Compose.Compose' . 'fmap' g . f)</span><span>
</span><span id="line-1503"></span><span class="hs-comment">--     = 'Data.Functor.Compose.Compose' . 'fmap' ('traverse' g) . 'traverse' f@</span><span>
</span><span id="line-1504"></span><span class="hs-comment">--</span><span>
</span><span id="line-1505"></span><span class="hs-comment">-- A definition of 'sequenceA' must satisfy the following laws:</span><span>
</span><span id="line-1506"></span><span class="hs-comment">--</span><span>
</span><span id="line-1507"></span><span class="hs-comment">-- [Naturality]</span><span>
</span><span id="line-1508"></span><span class="hs-comment">--   @t . 'sequenceA' = 'sequenceA' . 'fmap' t@</span><span>
</span><span id="line-1509"></span><span class="hs-comment">--   for every applicative transformation @t@</span><span>
</span><span id="line-1510"></span><span class="hs-comment">--</span><span>
</span><span id="line-1511"></span><span class="hs-comment">-- [Identity]</span><span>
</span><span id="line-1512"></span><span class="hs-comment">--   @'sequenceA' . 'fmap' 'Identity' = 'Identity'@</span><span>
</span><span id="line-1513"></span><span class="hs-comment">--</span><span>
</span><span id="line-1514"></span><span class="hs-comment">-- [Composition]</span><span>
</span><span id="line-1515"></span><span class="hs-comment">--   @'sequenceA' . 'fmap' 'Data.Functor.Compose.Compose'</span><span>
</span><span id="line-1516"></span><span class="hs-comment">--     = 'Data.Functor.Compose.Compose' . 'fmap' 'sequenceA' . 'sequenceA'@</span><span>
</span><span id="line-1517"></span><span class="hs-comment">--</span><span>
</span><span id="line-1518"></span><span class="hs-comment">-- where an /applicative transformation/ is a function</span><span>
</span><span id="line-1519"></span><span class="hs-comment">--</span><span>
</span><span id="line-1520"></span><span class="hs-comment">-- @t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a@</span><span>
</span><span id="line-1521"></span><span class="hs-comment">--</span><span>
</span><span id="line-1522"></span><span class="hs-comment">-- preserving the 'Applicative' operations, i.e.</span><span>
</span><span id="line-1523"></span><span class="hs-comment">--</span><span>
</span><span id="line-1524"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1525"></span><span class="hs-comment">-- t ('pure' x) = 'pure' x</span><span>
</span><span id="line-1526"></span><span class="hs-comment">-- t (f '&lt;*&gt;' x) = t f '&lt;*&gt;' t x</span><span>
</span><span id="line-1527"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1528"></span><span class="hs-comment">--</span><span>
</span><span id="line-1529"></span><span class="hs-comment">-- and the identity functor 'Identity' and composition functors</span><span>
</span><span id="line-1530"></span><span class="hs-comment">-- 'Data.Functor.Compose.Compose' are from &quot;Data.Functor.Identity&quot; and</span><span>
</span><span id="line-1531"></span><span class="hs-comment">-- &quot;Data.Functor.Compose&quot;.</span><span>
</span><span id="line-1532"></span><span class="hs-comment">--</span><span>
</span><span id="line-1533"></span><span class="hs-comment">-- A result of the naturality law is a purity law for 'traverse'</span><span>
</span><span id="line-1534"></span><span class="hs-comment">--</span><span>
</span><span id="line-1535"></span><span class="hs-comment">-- @'traverse' 'pure' = 'pure'@</span><span>
</span><span id="line-1536"></span><span class="hs-comment">--</span><span>
</span><span id="line-1537"></span><span class="hs-comment">-- The superclass instances should satisfy the following:</span><span>
</span><span id="line-1538"></span><span class="hs-comment">--</span><span>
</span><span id="line-1539"></span><span class="hs-comment">--  * In the 'Functor' instance, 'fmap' should be equivalent to traversal</span><span>
</span><span id="line-1540"></span><span class="hs-comment">--    with the identity applicative functor ('fmapDefault').</span><span>
</span><span id="line-1541"></span><span class="hs-comment">--</span><span>
</span><span id="line-1542"></span><span class="hs-comment">--  * In the 'Foldable' instance, 'Data.Foldable.foldMap' should be</span><span>
</span><span id="line-1543"></span><span class="hs-comment">--    equivalent to traversal with a constant applicative functor</span><span>
</span><span id="line-1544"></span><span class="hs-comment">--    ('foldMapDefault').</span><span>
</span><span id="line-1545"></span><span class="hs-comment">--</span><span>
</span><span id="line-1546"></span><span class="hs-comment">-- Note: the 'Functor' superclass means that (in GHC) Traversable structures</span><span>
</span><span id="line-1547"></span><span class="hs-comment">-- cannot impose any constraints on the element type.  A Haskell implementation</span><span>
</span><span id="line-1548"></span><span class="hs-comment">-- that supports constrained functors could make it possible to define</span><span>
</span><span id="line-1549"></span><span class="hs-comment">-- constrained @Traversable@ structures.</span><span>
</span><span id="line-1550"></span><span>
</span><span id="line-1551"></span><span class="hs-comment">------------------</span><span>
</span><span id="line-1552"></span><span>
</span><span id="line-1553"></span><span class="hs-comment">-- $also</span><span>
</span><span id="line-1554"></span><span class="hs-comment">--</span><span>
</span><span id="line-1555"></span><span class="hs-comment">--  * \&quot;The Essence of the Iterator Pattern\&quot;,</span><span>
</span><span id="line-1556"></span><span class="hs-comment">--    by Jeremy Gibbons and Bruno Oliveira,</span><span>
</span><span id="line-1557"></span><span class="hs-comment">--    in /Mathematically-Structured Functional Programming/, 2006, online at</span><span>
</span><span id="line-1558"></span><span class="hs-comment">--    &lt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&gt;.</span><span>
</span><span id="line-1559"></span><span class="hs-comment">--</span><span>
</span><span id="line-1560"></span><span class="hs-comment">--  * \&quot;Applicative Programming with Effects\&quot;,</span><span>
</span><span id="line-1561"></span><span class="hs-comment">--    by Conor McBride and Ross Paterson,</span><span>
</span><span id="line-1562"></span><span class="hs-comment">--    /Journal of Functional Programming/ 18:1 (2008) 1-13, online at</span><span>
</span><span id="line-1563"></span><span class="hs-comment">--    &lt;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&gt;.</span><span>
</span><span id="line-1564"></span><span class="hs-comment">--</span><span>
</span><span id="line-1565"></span><span class="hs-comment">--  * \&quot;An Investigation of the Laws of Traversals\&quot;,</span><span>
</span><span id="line-1566"></span><span class="hs-comment">--    by Mauro Jaskelioff and Ondrej Rypacek,</span><span>
</span><span id="line-1567"></span><span class="hs-comment">--    in /Mathematically-Structured Functional Programming/, 2012, online at</span><span>
</span><span id="line-1568"></span><span class="hs-comment">--    &lt;http://arxiv.org/pdf/1202.2919&gt;.</span><span>
</span><span id="line-1569"></span></pre></body></html>