<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Unsafe #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE MagicHash, UnboxedTuples, RankNTypes #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# OPTIONS_HADDOCK not-home #-}</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-8"></span><span class="hs-comment">-- Module      :  Control.Monad.ST.Lazy.Imp</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Copyright   :  (c) The University of Glasgow 2001</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- License     :  BSD-style (see the file libraries/base/LICENSE)</span><span>
</span><span id="line-11"></span><span class="hs-comment">--</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- Stability   :  provisional</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- Portability :  non-portable (requires universal quantification for runST)</span><span>
</span><span id="line-15"></span><span class="hs-comment">--</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- This module presents an identical interface to &quot;Control.Monad.ST&quot;,</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- except that the monad delays evaluation of 'ST' operations until</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- a value depending on them is required.</span><span>
</span><span id="line-19"></span><span class="hs-comment">--</span><span>
</span><span id="line-20"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Monad.ST.Lazy.Imp</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-23"></span><span>        </span><span class="annot"><span class="hs-comment">-- * The 'ST' monad</span></span><span>
</span><span id="line-24"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier">ST</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#runST"><span class="hs-identifier">runST</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier">fixST</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Converting between strict and lazy 'ST'</span></span><span>
</span><span id="line-29"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier">strictToLazyST</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier">lazyToStrictST</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Converting 'ST' To 'IO'</span></span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#RealWorld/GHC.Prim.html#RealWorld"><span class="hs-identifier">RealWorld</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#stToIO"><span class="hs-identifier">stToIO</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><span class="hs-comment">-- * Unsafe operations</span></span><span>
</span><span id="line-36"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeInterleaveST"><span class="hs-identifier">unsafeInterleaveST</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeIOToST"><span class="hs-identifier">unsafeIOToST</span></a></span><span>
</span><span id="line-38"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Control.Monad.Fix.html"><span class="hs-identifier">Control.Monad.Fix</span></a></span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Control.Monad.ST.html"><span class="hs-identifier">Control.Monad.ST</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">ST</span></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="Control.Monad.ST.Unsafe.html"><span class="hs-identifier">Control.Monad.ST.Unsafe</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">ST</span></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="GHC.ST.html"><span class="hs-identifier">GHC.ST</span></a></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Base.html"><span class="hs-identifier">GHC.Base</span></a></span><span>
</span><span id="line-47"></span><span>
</span><span id="line-48"></span><span class="hs-comment">-- | The lazy @'ST'@ monad.</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- The ST monad allows for destructive updates, but is escapable (unlike @IO@).</span><span>
</span><span id="line-50"></span><span class="hs-comment">-- A computation of type @'ST' s a@ returns a value of type @a@, and</span><span>
</span><span id="line-51"></span><span class="hs-comment">-- executes in &quot;thread&quot; @s@. The @s@ parameter is either</span><span>
</span><span id="line-52"></span><span class="hs-comment">--</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- * an uninstantiated type variable (inside invocations of 'runST'), or</span><span>
</span><span id="line-54"></span><span class="hs-comment">--</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- * 'RealWorld' (inside invocations of 'stToIO').</span><span>
</span><span id="line-56"></span><span class="hs-comment">--</span><span>
</span><span id="line-57"></span><span class="hs-comment">-- It serves to keep the internal states of different invocations of</span><span>
</span><span id="line-58"></span><span class="hs-comment">-- 'runST' separate from each other and from invocations of 'stToIO'.</span><span>
</span><span id="line-59"></span><span class="hs-comment">--</span><span>
</span><span id="line-60"></span><span class="hs-comment">-- The '&gt;&gt;=' and '&gt;&gt;' operations are not strict in the state.  For example,</span><span>
</span><span id="line-61"></span><span class="hs-comment">--</span><span>
</span><span id="line-62"></span><span class="hs-comment">-- @'runST' (writeSTRef _|_ v &gt;&gt;= readSTRef _|_ &gt;&gt; return 2) = 2@</span><span>
</span><span id="line-63"></span><span class="hs-keyword">newtype</span><span> </span><span id="ST"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span></span><span> </span><span id="local-6989586621679683697"><span class="annot"><a href="#local-6989586621679683697"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span id="local-6989586621679683698"><span class="annot"><a href="#local-6989586621679683698"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ST"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="unST"><span class="annot"><span class="annottext">forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var hs-var">unST</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683697"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679683698"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683697"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- A lifted state token. This can be imagined as a moment in the timeline</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- of a lazy state thread. Forcing the token forces all delayed actions in</span><span>
</span><span id="line-67"></span><span class="hs-comment">-- the thread up until that moment to be performed.</span><span>
</span><span id="line-68"></span><span class="hs-keyword">data</span><span> </span><span id="State"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#State"><span class="hs-identifier hs-var">State</span></a></span></span><span> </span><span id="local-6989586621679683762"><span class="annot"><a href="#local-6989586621679683762"><span class="hs-identifier hs-type">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="S%23"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#State%23/GHC.Prim.html#State%23"><span class="hs-identifier hs-type">State#</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683762"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span class="hs-comment">{- Note [Lazy ST and multithreading]
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We used to imagine that passing a polymorphic state token was all that we
needed to keep state threads separate (see Launchbury and Peyton Jones, 1994:
https://www.microsoft.com/en-us/research/publication/lazy-functional-state-threads/).
But this breaks down in the face of concurrency (see #11760). Whereas a strict
ST computation runs to completion before producing anything, a value produced
by running a lazy ST computation may contain a thunk that, when forced, will
lead to further stateful computations. If such a thunk is entered by more than
one thread, then they may both read from and write to the same references and
arrays, interfering with each other. To work around this, any time we lazily
suspend execution of a lazy ST computation, we bind the result pair to a
NOINLINE binding (ensuring that it is not duplicated) and calculate that
pair using (unsafePerformIO . evaluate), ensuring that only one thread will
enter the thunk. We still use lifted state tokens to actually drive execution,
so in these cases we effectively deal with *two* state tokens: the lifted
one we get from the previous computation, and the unlifted one we pull out of
thin air. -}</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-comment">{- Note [Lazy ST: not producing lazy pairs]
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The fixST and strictToLazyST functions used to construct functions that
produced lazy pairs. Why don't we need that laziness? The ST type is kept
abstract, so no one outside this module can ever get their hands on a (result,
State s) pair. We ourselves never match on such pairs when performing ST
computations unless we also force one of their components. So no one should be
able to detect the change. By refraining from producing such thunks (which
reference delayed ST computations), we avoid having to ask whether we have to
wrap them up with unsafePerformIO. See Note [Lazy ST and multithreading]. -}</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-comment">-- | This is a terrible hack to prevent a thunk from being entered twice.</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- Simon Peyton Jones would very much like to be rid of it.</span><span>
</span><span id="line-102"></span><span id="local-6989586621679683703"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-type">noDup</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679683703"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679683703"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-103"></span><span id="noDup"><span class="annot"><span class="annottext">noDup :: forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var hs-var">noDup</span></a></span></span><span> </span><span id="local-6989586621679683813"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683813"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State# RealWorld -&gt; a) -&gt; a
forall o. (State# RealWorld -&gt; o) -&gt; o
</span><a href="../../ghc-prim-0.10.0/src/GHC.Magic.html#runRW%23/GHC.Magic.html#runRW%23"><span class="hs-identifier hs-var">runRW#</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679683814"><span class="annot"><span class="annottext">State# RealWorld
</span><a href="#local-6989586621679683814"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-104"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">State# RealWorld -&gt; State# RealWorld
forall d. State# d -&gt; State# d
</span><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#noDuplicate%23/GHC.Prim.html#noDuplicate%23"><span class="hs-identifier hs-var">noDuplicate#</span></a></span><span> </span><span class="annot"><span class="annottext">State# RealWorld
</span><a href="#local-6989586621679683814"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-105"></span><span>    </span><span class="annot"><span class="annottext">State# RealWorld
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683813"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-108"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679683714"><span class="annot"><a href="GHC.Base.html#Functor"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683714"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-109"></span><span>    </span><span id="local-6989586621679683819"><span class="annot"><span class="annottext">fmap :: forall a b. (a -&gt; b) -&gt; ST s a -&gt; ST s b
</span><a href="GHC.Base.html#fmap"><span class="hs-identifier hs-var hs-var hs-var hs-var">fmap</span></a></span></span><span> </span><span id="local-6989586621679683820"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679683820"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679683821"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683821"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (b, State s)) -&gt; ST s b
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (b, State s)) -&gt; ST s b)
-&gt; (State s -&gt; (b, State s)) -&gt; ST s b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683822"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683822"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-110"></span><span>      </span><span class="hs-keyword">let</span><span>
</span><span id="line-111"></span><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-112"></span><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683823"><span class="hs-pragma hs-type">res</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-113"></span><span>        </span><span id="local-6989586621679683823"><span class="annot"><span class="annottext">res :: (a, State s)
</span><a href="#local-6989586621679683823"><span class="hs-identifier hs-var hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s) -&gt; (a, State s)
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683821"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683822"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621679683824"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683824"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679683825"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683825"><span class="hs-identifier hs-var">new_s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683823"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-115"></span><span>      </span><span class="hs-keyword">in</span><span>
</span><span id="line-116"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679683820"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683824"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683825"><span class="hs-identifier hs-var">new_s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span>    </span><span id="local-6989586621679683826"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683826"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679683827"><span class="annot"><span class="annottext">&lt;$ :: forall a b. a -&gt; ST s b -&gt; ST s a
</span><a href="#local-6989586621679683827"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;$</span></a></span></span><span> </span><span id="local-6989586621679683829"><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683829"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (a, State s)) -&gt; ST s a
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (a, State s)) -&gt; ST s a)
-&gt; (State s -&gt; (a, State s)) -&gt; ST s a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683830"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683830"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-119"></span><span>      </span><span class="hs-keyword">let</span><span>
</span><span id="line-120"></span><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683831"><span class="hs-pragma hs-type">s'</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-121"></span><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-122"></span><span>        </span><span id="local-6989586621679683831"><span class="annot"><span class="annottext">s' :: State s
</span><a href="#local-6989586621679683831"><span class="hs-identifier hs-var hs-var">s'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">State s -&gt; State s
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b, State s) -&gt; State s
forall a b. (a, b) -&gt; b
</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s b -&gt; State s -&gt; (b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683829"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683830"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683826"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683831"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-126"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679683736"><span class="annot"><a href="GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683736"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-127"></span><span>    </span><span id="local-6989586621679683842"><span class="annot"><span class="annottext">pure :: forall a. a -&gt; ST s a
</span><a href="GHC.Base.html#pure"><span class="hs-identifier hs-var hs-var hs-var hs-var">pure</span></a></span></span><span> </span><span id="local-6989586621679683843"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683843"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (a, State s)) -&gt; ST s a
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (a, State s)) -&gt; ST s a)
-&gt; (State s -&gt; (a, State s)) -&gt; ST s a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683844"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683844"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683843"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683844"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span>    </span><span id="local-6989586621679683845"><span class="annot"><span class="annottext">ST s (a -&gt; b)
</span><a href="#local-6989586621679683845"><span class="hs-identifier hs-var">fm</span></a></span></span><span> </span><span id="local-6989586621679683846"><span class="annot"><span class="annottext">&lt;*&gt; :: forall a b. ST s (a -&gt; b) -&gt; ST s a -&gt; ST s b
</span><a href="GHC.Base.html#%3C%2A%3E"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*&gt;</span></a></span></span><span> </span><span id="local-6989586621679683847"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683847"><span class="hs-identifier hs-var">xm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (b, State s)) -&gt; ST s b
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (b, State s)) -&gt; ST s b)
-&gt; (State s -&gt; (b, State s)) -&gt; ST s b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683848"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683848"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-130"></span><span>       </span><span class="hs-keyword">let</span><span>
</span><span id="line-131"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683849"><span class="hs-pragma hs-type">res1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-132"></span><span>         </span><span class="hs-glyph">!</span><span id="local-6989586621679683849"><span class="annot"><span class="annottext">res1 :: (a -&gt; b, State s)
</span><a href="#local-6989586621679683849"><span class="hs-identifier hs-var hs-var">res1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s (a -&gt; b) -&gt; State s -&gt; (a -&gt; b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s (a -&gt; b)
</span><a href="#local-6989586621679683845"><span class="hs-identifier hs-var">fm</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683848"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-133"></span><span>         </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span id="local-6989586621679683850"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679683850"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683851"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683851"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b, State s)
</span><a href="#local-6989586621679683849"><span class="hs-identifier hs-var">res1</span></a></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683852"><span class="hs-pragma hs-type">res2</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-136"></span><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-137"></span><span>         </span><span id="local-6989586621679683852"><span class="annot"><span class="annottext">res2 :: (a, State s)
</span><a href="#local-6989586621679683852"><span class="hs-identifier hs-var hs-var">res2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s) -&gt; (a, State s)
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683847"><span class="hs-identifier hs-var">xm</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683851"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>         </span><span class="hs-special">(</span><span id="local-6989586621679683853"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683853"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683854"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683854"><span class="hs-identifier hs-var">s''</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683852"><span class="hs-identifier hs-var">res2</span></a></span><span>
</span><span id="line-139"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679683850"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683853"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683854"><span class="hs-identifier hs-var">s''</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-140"></span><span>    </span><span class="hs-comment">-- Why can we use a strict binding for res1? If someone</span><span>
</span><span id="line-141"></span><span>    </span><span class="hs-comment">-- forces the (f x, s'') pair, then they must need</span><span>
</span><span id="line-142"></span><span>    </span><span class="hs-comment">-- f or s''. To get s'', they need s'.</span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span>    </span><span id="local-6989586621679683855"><span class="annot"><span class="annottext">liftA2 :: forall a b c. (a -&gt; b -&gt; c) -&gt; ST s a -&gt; ST s b -&gt; ST s c
</span><a href="#local-6989586621679683855"><span class="hs-identifier hs-var hs-var hs-var hs-var">liftA2</span></a></span></span><span> </span><span id="local-6989586621679683857"><span class="annot"><span class="annottext">a -&gt; b -&gt; c
</span><a href="#local-6989586621679683857"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679683858"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683858"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679683859"><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683859"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (c, State s)) -&gt; ST s c
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (c, State s)) -&gt; ST s c)
-&gt; (State s -&gt; (c, State s)) -&gt; ST s c
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683860"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683860"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-145"></span><span>      </span><span class="hs-keyword">let</span><span>
</span><span id="line-146"></span><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683861"><span class="hs-pragma hs-type">res1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-147"></span><span>        </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-148"></span><span>        </span><span id="local-6989586621679683861"><span class="annot"><span class="annottext">res1 :: (a, State s)
</span><a href="#local-6989586621679683861"><span class="hs-identifier hs-var hs-var">res1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s) -&gt; (a, State s)
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683858"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683860"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-149"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621679683862"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683862"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683863"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683863"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683861"><span class="hs-identifier hs-var">res1</span></a></span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span>        </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683864"><span class="hs-pragma hs-type">res2</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-152"></span><span>        </span><span id="local-6989586621679683864"><span class="annot"><span class="annottext">res2 :: (b, State s)
</span><a href="#local-6989586621679683864"><span class="hs-identifier hs-var hs-var">res2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b, State s) -&gt; (b, State s)
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s b -&gt; State s -&gt; (b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683859"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683863"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621679683865"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679683865"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683866"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683866"><span class="hs-identifier hs-var">s''</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(b, State s)
</span><a href="#local-6989586621679683864"><span class="hs-identifier hs-var">res2</span></a></span><span>
</span><span id="line-154"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; b -&gt; c
</span><a href="#local-6989586621679683857"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683862"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679683865"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683866"><span class="hs-identifier hs-var">s''</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-155"></span><span>    </span><span class="hs-comment">-- We don't get to be strict in liftA2, but we clear out a</span><span>
</span><span id="line-156"></span><span>    </span><span class="hs-comment">-- NOINLINE in comparison to the default definition, which may</span><span>
</span><span id="line-157"></span><span>    </span><span class="hs-comment">-- help the simplifier.</span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span>    </span><span id="local-6989586621679683867"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683867"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679683868"><span class="annot"><span class="annottext">*&gt; :: forall a b. ST s a -&gt; ST s b -&gt; ST s b
</span><a href="GHC.Base.html#%2A%3E"><span class="hs-operator hs-var hs-var hs-var hs-var">*&gt;</span></a></span></span><span> </span><span id="local-6989586621679683869"><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683869"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (b, State s)) -&gt; ST s b
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (b, State s)) -&gt; ST s b)
-&gt; (State s -&gt; (b, State s)) -&gt; ST s b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679683870"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683870"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-160"></span><span>       </span><span class="hs-keyword">let</span><span>
</span><span id="line-161"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683871"><span class="hs-pragma hs-type">s'</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-162"></span><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-163"></span><span>         </span><span id="local-6989586621679683871"><span class="annot"><span class="annottext">s' :: State s
</span><a href="#local-6989586621679683871"><span class="hs-identifier hs-var hs-var">s'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">State s -&gt; State s
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a, State s) -&gt; State s
forall a b. (a, b) -&gt; b
</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683867"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683870"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">ST s b -&gt; State s -&gt; (b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683869"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683871"><span class="hs-identifier hs-var">s'</span></a></span><span>
</span><span id="line-165"></span><span>
</span><span id="line-166"></span><span>    </span><span id="local-6989586621679683872"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683872"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679683873"><span class="annot"><span class="annottext">&lt;* :: forall a b. ST s a -&gt; ST s b -&gt; ST s a
</span><a href="#local-6989586621679683873"><span class="hs-operator hs-var hs-var hs-var hs-var">&lt;*</span></a></span></span><span> </span><span id="local-6989586621679683875"><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683875"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (a, State s)) -&gt; ST s a
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (a, State s)) -&gt; ST s a)
-&gt; (State s -&gt; (a, State s)) -&gt; ST s a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679683876"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683876"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-167"></span><span>       </span><span class="hs-keyword">let</span><span>
</span><span id="line-168"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683877"><span class="hs-pragma hs-type">res1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-169"></span><span>         </span><span class="hs-glyph">!</span><span id="local-6989586621679683877"><span class="annot"><span class="annottext">res1 :: (a, State s)
</span><a href="#local-6989586621679683877"><span class="hs-identifier hs-var hs-var">res1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683872"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683876"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-170"></span><span>         </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span id="local-6989586621679683878"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683878"><span class="hs-identifier hs-var">mr</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683879"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683879"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683877"><span class="hs-identifier hs-var">res1</span></a></span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683880"><span class="hs-pragma hs-type">s''</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-173"></span><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-174"></span><span>         </span><span id="local-6989586621679683880"><span class="annot"><span class="annottext">s'' :: State s
</span><a href="#local-6989586621679683880"><span class="hs-identifier hs-var hs-var">s''</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">State s -&gt; State s
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b, State s) -&gt; State s
forall a b. (a, b) -&gt; b
</span><a href="Data.Tuple.html#snd"><span class="hs-identifier hs-var">snd</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s b -&gt; State s -&gt; (b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s b
</span><a href="#local-6989586621679683875"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683879"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-175"></span><span>       </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683878"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683880"><span class="hs-identifier hs-var">s''</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span>    </span><span class="hs-comment">-- Why can we use a strict binding for res1? The same reason as</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">-- in &lt;*&gt;. If someone demands the (mr, s'') pair, then they will</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">-- force mr or s''. To get s'', they need s'.</span><span>
</span><span id="line-179"></span><span>
</span><span id="line-180"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-181"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679683754"><span id="local-6989586621679683886"><span class="annot"><a href="GHC.Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683754"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-182"></span><span>    </span><span id="local-6989586621679683891"><span class="annot"><span class="annottext">&gt;&gt; :: forall a b. ST s a -&gt; ST s b -&gt; ST s b
</span><a href="GHC.Base.html#%3E%3E"><span class="hs-operator hs-var hs-var hs-var hs-var">(&gt;&gt;)</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; ST s b -&gt; ST s b
forall a b. ST s a -&gt; ST s b -&gt; ST s b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><a href="GHC.Base.html#%2A%3E"><span class="hs-operator hs-var">(*&gt;)</span></a></span><span>
</span><span id="line-183"></span><span>
</span><span id="line-184"></span><span>    </span><span id="local-6989586621679683892"><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683892"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679683893"><span class="annot"><span class="annottext">&gt;&gt;= :: forall a b. ST s a -&gt; (a -&gt; ST s b) -&gt; ST s b
</span><a href="GHC.Base.html#%3E%3E%3D"><span class="hs-operator hs-var hs-var hs-var hs-var">&gt;&gt;=</span></a></span></span><span> </span><span id="local-6989586621679683894"><span class="annot"><span class="annottext">a -&gt; ST s b
</span><a href="#local-6989586621679683894"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (b, State s)) -&gt; ST s b
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (b, State s)) -&gt; ST s b)
-&gt; (State s -&gt; (b, State s)) -&gt; ST s b
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683895"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683895"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-185"></span><span>       </span><span class="hs-keyword">let</span><span>
</span><span id="line-186"></span><span>         </span><span class="hs-comment">-- See Note [Lazy ST and multithreading]</span><span>
</span><span id="line-187"></span><span>         </span><span class="hs-pragma">{-# NOINLINE</span><span> </span><span class="annot"><a href="#local-6989586621679683896"><span class="hs-pragma hs-type">res</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-188"></span><span>         </span><span id="local-6989586621679683896"><span class="annot"><span class="annottext">res :: (a, State s)
</span><a href="#local-6989586621679683896"><span class="hs-identifier hs-var hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s) -&gt; (a, State s)
forall a. a -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#noDup"><span class="hs-identifier hs-var">noDup</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a
</span><a href="#local-6989586621679683892"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683895"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>         </span><span class="hs-special">(</span><span id="local-6989586621679683897"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683897"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679683898"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683898"><span class="hs-identifier hs-var">new_s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683896"><span class="hs-identifier hs-var">res</span></a></span><span>
</span><span id="line-190"></span><span>       </span><span class="hs-keyword">in</span><span>
</span><span id="line-191"></span><span>         </span><span class="annot"><span class="annottext">ST s b -&gt; State s -&gt; (b, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; ST s b
</span><a href="#local-6989586621679683894"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683897"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683898"><span class="hs-identifier hs-var">new_s</span></a></span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span class="hs-comment">-- | Return the value computed by an 'ST' computation.</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- The @forall@ ensures that the internal state used by the 'ST'</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- computation is inaccessible to the rest of the program.</span><span>
</span><span id="line-196"></span><span id="local-6989586621679683760"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#runST"><span class="hs-identifier hs-type">runST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679683759"><span class="annot"><a href="#local-6989586621679683759"><span class="hs-identifier hs-type">s</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683759"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683760"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679683760"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-197"></span><span id="runST"><span class="annot"><span class="annottext">runST :: forall a. (forall s. ST s a) -&gt; a
</span><a href="Control.Monad.ST.Lazy.Imp.html#runST"><span class="hs-identifier hs-var hs-var">runST</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span id="local-6989586621679683899"><span class="annot"><span class="annottext">State RealWorld -&gt; (a, State RealWorld)
</span><a href="#local-6989586621679683899"><span class="hs-identifier hs-var">st</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State# RealWorld -&gt; a) -&gt; a
forall o. (State# RealWorld -&gt; o) -&gt; o
</span><a href="../../ghc-prim-0.10.0/src/GHC.Magic.html#runRW%23/GHC.Magic.html#runRW%23"><span class="hs-identifier hs-var">runRW#</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679683900"><span class="annot"><span class="annottext">State# RealWorld
</span><a href="#local-6989586621679683900"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">State RealWorld -&gt; (a, State RealWorld)
</span><a href="#local-6989586621679683899"><span class="hs-identifier hs-var">st</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State# RealWorld -&gt; State RealWorld
forall s. State# s -&gt; State s
</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a></span><span> </span><span class="annot"><span class="annottext">State# RealWorld
</span><a href="#local-6989586621679683900"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679683901"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683901"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State RealWorld
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683901"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="hs-comment">-- | Allow the result of an 'ST' computation to be used (lazily)</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- inside the computation.</span><span>
</span><span id="line-201"></span><span class="hs-comment">-- Note that if @f@ is strict, @'fixST' f = _|_@.</span><span>
</span><span id="line-202"></span><span id="local-6989586621679683763"><span id="local-6989586621679683764"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier hs-type">fixST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679683763"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683764"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683763"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683764"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683763"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-203"></span><span id="fixST"><span class="annot"><span class="annottext">fixST :: forall a s. (a -&gt; ST s a) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier hs-var hs-var">fixST</span></a></span></span><span> </span><span id="local-6989586621679683902"><span class="annot"><span class="annottext">a -&gt; ST s a
</span><a href="#local-6989586621679683902"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (a, State s)) -&gt; ST s a
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679683903"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683903"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-204"></span><span>                </span><span class="hs-keyword">let</span><span>
</span><span id="line-205"></span><span>                   </span><span id="local-6989586621679683904"><span class="annot"><span class="annottext">q :: (a, State s)
</span><a href="#local-6989586621679683904"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679683905"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683905"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679683906"><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683906"><span class="hs-identifier hs-var">_s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; State s -&gt; (a, State s)
forall s a. ST s a -&gt; State s -&gt; (a, State s)
</span><a href="Control.Monad.ST.Lazy.Imp.html#unST"><span class="hs-identifier hs-var">unST</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; ST s a
</span><a href="#local-6989586621679683902"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683905"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">State s
</span><a href="#local-6989586621679683903"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-206"></span><span>                </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(a, State s)
</span><a href="#local-6989586621679683904"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-207"></span><span class="hs-comment">-- Why don't we need unsafePerformIO in fixST? We create a thunk, q,</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- to perform a lazy state computation, and we pass a reference to that</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- thunk, r, to m. Uh oh? No, I think it should be fine, because that thunk</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- itself is demanded directly in the `let` body. See also</span><span>
</span><span id="line-211"></span><span class="hs-comment">-- Note [Lazy ST: not producing lazy pairs].</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="annot"><span class="hs-comment">-- | @since 2.01</span></span><span>
</span><span id="line-214"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679683770"><span class="annot"><a href="Control.Monad.Fix.html#MonadFix"><span class="hs-identifier hs-type">MonadFix</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683770"><span class="hs-identifier hs-type">s</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-215"></span><span>        </span><span id="local-6989586621679683912"><span class="annot"><span class="annottext">mfix :: forall a. (a -&gt; ST s a) -&gt; ST s a
</span><a href="Control.Monad.Fix.html#mfix"><span class="hs-identifier hs-var hs-var hs-var hs-var">mfix</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; ST s a) -&gt; ST s a
forall a s. (a -&gt; ST s a) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#fixST"><span class="hs-identifier hs-var">fixST</span></a></span><span>
</span><span id="line-216"></span><span>
</span><span id="line-217"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- Strict &lt;--&gt; Lazy</span><span>
</span><span id="line-219"></span><span>
</span><span id="line-220"></span><span class="annot"><span class="hs-comment">{-|
Convert a strict 'ST' computation into a lazy one.  The strict state
thread passed to 'strictToLazyST' is not performed until the result of
the lazy state thread it returns is demanded.
-}</span></span><span>
</span><span id="line-225"></span><span id="local-6989586621679683772"><span id="local-6989586621679683773"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-type">strictToLazyST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.ST.html#ST"><span class="hs-identifier hs-type">ST.ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683772"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683773"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683772"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683773"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-226"></span><span id="strictToLazyST"><span class="annot"><span class="annottext">strictToLazyST :: forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var hs-var">strictToLazyST</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.ST.html#ST"><span class="hs-identifier hs-type">GHC.ST.ST</span></a></span><span> </span><span id="local-6989586621679683914"><span class="annot"><span class="annottext">STRep s a
</span><a href="#local-6989586621679683914"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(State s -&gt; (a, State s)) -&gt; ST s a
forall s a. (State s -&gt; (a, State s)) -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-var">ST</span></a></span><span> </span><span class="annot"><span class="annottext">((State s -&gt; (a, State s)) -&gt; ST s a)
-&gt; (State s -&gt; (a, State s)) -&gt; ST s a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-type">S#</span></a></span><span> </span><span id="local-6989586621679683915"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683915"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">STRep s a
</span><a href="#local-6989586621679683914"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683915"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-228"></span><span>    </span><span class="hs-special">(#</span><span> </span><span id="local-6989586621679683916"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683916"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679683917"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683917"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-special">#)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683917"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">State# s -&gt; State s
forall s. State# s -&gt; State s
</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683916"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- See Note [Lazy ST: not producing lazy pairs]</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="annot"><span class="hs-comment">{-|
Convert a lazy 'ST' computation into a strict one.
-}</span></span><span>
</span><span id="line-234"></span><span id="local-6989586621679683778"><span id="local-6989586621679683779"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-type">lazyToStrictST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683778"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683779"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.ST.html#ST"><span class="hs-identifier hs-type">ST.ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683778"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683779"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-235"></span><span id="lazyToStrictST"><span class="annot"><span class="annottext">lazyToStrictST :: forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var hs-var">lazyToStrictST</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span id="local-6989586621679683918"><span class="annot"><span class="annottext">State s -&gt; (a, State s)
</span><a href="#local-6989586621679683918"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">STRep s a -&gt; ST s a
forall s a. STRep s a -&gt; ST s a
</span><a href="GHC.ST.html#ST"><span class="hs-identifier hs-var">GHC.ST.ST</span></a></span><span> </span><span class="annot"><span class="annottext">(STRep s a -&gt; ST s a) -&gt; STRep s a -&gt; ST s a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679683919"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683919"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-236"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State s -&gt; (a, State s)
</span><a href="#local-6989586621679683918"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">State# s -&gt; State s
forall s. State# s -&gt; State s
</span><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-var">S#</span></a></span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683919"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679683920"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683920"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#S%23"><span class="hs-identifier hs-type">S#</span></a></span><span> </span><span id="local-6989586621679683921"><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683921"><span class="hs-identifier hs-var">s'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(#</span><span> </span><span class="annot"><span class="annottext">State# s
</span><a href="#local-6989586621679683921"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679683920"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-special">#)</span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="hs-comment">-- | A monad transformer embedding lazy 'ST' in the 'IO'</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- monad.  The 'RealWorld' parameter indicates that the internal state</span><span>
</span><span id="line-240"></span><span class="hs-comment">-- used by the 'ST' computation is a special one supplied by the 'IO'</span><span>
</span><span id="line-241"></span><span class="hs-comment">-- monad, and thus distinct from those used by invocations of 'runST'.</span><span>
</span><span id="line-242"></span><span id="local-6989586621679683784"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#stToIO"><span class="hs-identifier hs-type">stToIO</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Prim.html#RealWorld/GHC.Prim.html#RealWorld"><span class="hs-identifier hs-type">RealWorld</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683784"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Types.html#IO/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683784"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-243"></span><span id="stToIO"><span class="annot"><span class="annottext">stToIO :: forall a. ST RealWorld a -&gt; IO a
</span><a href="Control.Monad.ST.Lazy.Imp.html#stToIO"><span class="hs-identifier hs-var hs-var">stToIO</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST RealWorld a -&gt; IO a
forall a. ST RealWorld a -&gt; IO a
</span><a href="GHC.IO.html#stToIO"><span class="hs-identifier hs-var">ST.stToIO</span></a></span><span> </span><span class="annot"><span class="annottext">(ST RealWorld a -&gt; IO a)
-&gt; (ST RealWorld a -&gt; ST RealWorld a) -&gt; ST RealWorld a -&gt; IO a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">ST RealWorld a -&gt; ST RealWorld a
forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var">lazyToStrictST</span></a></span><span>
</span><span id="line-244"></span><span>
</span><span id="line-245"></span><span class="hs-comment">-- ---------------------------------------------------------------------------</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- Strict &lt;--&gt; Lazy</span><span>
</span><span id="line-247"></span><span>
</span><span id="line-248"></span><span id="local-6989586621679683790"><span id="local-6989586621679683791"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeInterleaveST"><span class="hs-identifier hs-type">unsafeInterleaveST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683790"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683791"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683790"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683791"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-249"></span><span id="unsafeInterleaveST"><span class="annot"><span class="annottext">unsafeInterleaveST :: forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#unsafeInterleaveST"><span class="hs-identifier hs-var hs-var">unsafeInterleaveST</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; ST s a
forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var">strictToLazyST</span></a></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; ST s a) -&gt; (ST s a -&gt; ST s a) -&gt; ST s a -&gt; ST s a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; ST s a
forall s a. ST s a -&gt; ST s a
</span><a href="GHC.ST.html#unsafeInterleaveST"><span class="hs-identifier hs-var">ST.unsafeInterleaveST</span></a></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; ST s a) -&gt; (ST s a -&gt; ST s a) -&gt; ST s a -&gt; ST s a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; ST s a
forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#lazyToStrictST"><span class="hs-identifier hs-var">lazyToStrictST</span></a></span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span id="local-6989586621679683796"><span id="local-6989586621679683797"><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#unsafeIOToST"><span class="hs-identifier hs-type">unsafeIOToST</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../ghc-prim-0.10.0/src/GHC.Types.html#IO/GHC.Types.html#IO"><span class="hs-identifier hs-type">IO</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683796"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Control.Monad.ST.Lazy.Imp.html#ST"><span class="hs-identifier hs-type">ST</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683797"><span class="hs-identifier hs-type">s</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679683796"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-252"></span><span id="unsafeIOToST"><span class="annot"><span class="annottext">unsafeIOToST :: forall a s. IO a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#unsafeIOToST"><span class="hs-identifier hs-var hs-var">unsafeIOToST</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ST s a -&gt; ST s a
forall s a. ST s a -&gt; ST s a
</span><a href="Control.Monad.ST.Lazy.Imp.html#strictToLazyST"><span class="hs-identifier hs-var">strictToLazyST</span></a></span><span> </span><span class="annot"><span class="annottext">(ST s a -&gt; ST s a) -&gt; (IO a -&gt; ST s a) -&gt; IO a -&gt; ST s a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">IO a -&gt; ST s a
forall a s. IO a -&gt; ST s a
</span><a href="GHC.IO.html#unsafeIOToST"><span class="hs-identifier hs-var">ST.unsafeIOToST</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span></pre></body></html>