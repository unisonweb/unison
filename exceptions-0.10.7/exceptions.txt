-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible optionally-pure exceptions
--   
--   Extensible optionally-pure exceptions.
@package exceptions
@version 0.10.7


-- | This module supports monads that can throw extensible exceptions. The
--   exceptions are the very same from <a>Control.Exception</a>, and the
--   operations offered very similar, but here they are not limited to
--   <a>IO</a>.
--   
--   This code is in the style of both transformers and mtl, and is
--   compatible with them, though doesn't mimic the module structure or
--   offer the complete range of features in those packages.
--   
--   This is very similar to <tt>ErrorT</tt> and <tt>MonadError</tt>, but
--   based on features of <a>Control.Exception</a>. In particular, it
--   handles the complex case of asynchronous exceptions by including
--   <a>mask</a> in the typeclass. Note that the extensible exceptions
--   feature relies on the RankNTypes language extension.
module Control.Monad.Catch

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow m

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, HasCallStack) => Exception e => e -> m a

-- | A class for monads which allow exceptions to be caught, in particular
--   exceptions which were thrown by <a>throwM</a>.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   catch (throwM e) f = f e
--   </pre>
--   
--   Note that the ability to catch an exception does <i>not</i> guarantee
--   that we can deal with all possible exit points from a computation.
--   Some monads, such as continuation-based stacks, allow for more than
--   just a success/failure strategy, and therefore <tt>catch</tt>
--   <i>cannot</i> be used by those monads to properly implement a function
--   such as <tt>finally</tt>. For more information, see <a>MonadMask</a>.
class MonadThrow m => MonadCatch m

-- | Provide a handler for exceptions thrown during execution of the first
--   action. Note that type of the type of the argument to the handler will
--   constrain which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>catch</a>.
catch :: (MonadCatch m, HasCallStack) => Exception e => m a -> (e -> m a) -> m a

-- | A class for monads which provide for the ability to account for all
--   possible exit points from a computation, and to mask asynchronous
--   exceptions. Continuation-based monads are invalid instances of this
--   class.
--   
--   Instances should ensure that, in the following code:
--   
--   <pre>
--   fg = f `finally` g
--   </pre>
--   
--   The action <tt>g</tt> is called regardless of what occurs within
--   <tt>f</tt>, including async exceptions. Some monads allow <tt>f</tt>
--   to abort the computation via other effects than throwing an exception.
--   For simplicity, we will consider aborting and throwing an exception to
--   be two forms of "throwing an error".
--   
--   If <tt>f</tt> and <tt>g</tt> both throw an error, the error thrown by
--   <tt>fg</tt> depends on which errors we're talking about. In a monad
--   transformer stack, the deeper layers override the effects of the inner
--   layers; for example, <tt>ExceptT e1 (Except e2) a</tt> represents a
--   value of type <tt>Either e2 (Either e1 a)</tt>, so throwing both an
--   <tt>e1</tt> and an <tt>e2</tt> will result in <tt>Left e2</tt>. If
--   <tt>f</tt> and <tt>g</tt> both throw an error from the same layer,
--   instances should ensure that the error from <tt>g</tt> wins.
--   
--   Effects other than throwing an error are also overridden by the deeper
--   layers. For example, <tt>StateT s Maybe a</tt> represents a value of
--   type <tt>s -&gt; Maybe (a, s)</tt>, so if an error thrown from
--   <tt>f</tt> causes this function to return <tt>Nothing</tt>, any
--   changes to the state which <tt>f</tt> also performed will be erased.
--   As a result, <tt>g</tt> will see the state as it was before
--   <tt>f</tt>. Once <tt>g</tt> completes, <tt>f</tt>'s error will be
--   rethrown, so <tt>g</tt>' state changes will be erased as well. This is
--   the normal interaction between effects in a monad transformer stack.
--   
--   By contrast, <a>lifted-base</a>'s version of <a>finally</a> always
--   discards all of <tt>g</tt>'s non-IO effects, and <tt>g</tt> never sees
--   any of <tt>f</tt>'s non-IO effects, regardless of the layer ordering
--   and regardless of whether <tt>f</tt> throws an error. This is not the
--   result of interacting effects, but a consequence of
--   <tt>MonadBaseControl</tt>'s approach.
class MonadCatch m => MonadMask m

-- | Runs an action with asynchronous exceptions disabled. The action is
--   provided a method for restoring the async. environment to what it was
--   at the <a>mask</a> call. See <a>Control.Exception</a>'s <a>mask</a>.
mask :: (MonadMask m, HasCallStack) => ((forall a. m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception</a>'s <a>uninterruptibleMask</a>. WARNING: Only
--   use if you need to mask exceptions around an interruptible operation
--   AND you can guarantee the interruptible operation will only block for
--   a short period of time. Otherwise you render the program/thread
--   unresponsive and/or unkillable.
uninterruptibleMask :: (MonadMask m, HasCallStack) => ((forall a. m a -> m a) -> m b) -> m b

-- | A generalized version of <a>bracket</a> which uses <a>ExitCase</a> to
--   distinguish the different exit cases, and returns the values of both
--   the <tt>use</tt> and <tt>release</tt> actions. In practice, this extra
--   information is rarely needed, so it is often more convenient to use
--   one of the simpler functions which are defined in terms of this one,
--   such as <a>bracket</a>, <a>finally</a>, <a>onError</a>, and
--   <a>bracketOnError</a>.
--   
--   This function exists because in order to thread their effects through
--   the execution of <a>bracket</a>, monad transformers need values to be
--   threaded from <tt>use</tt> to <tt>release</tt> and from
--   <tt>release</tt> to the output value.
--   
--   <i>NOTE</i> This method was added in version 0.9.0 of this library.
--   Previously, implementation of functions like <a>bracket</a> and
--   <a>finally</a> in this module were based on the <a>mask</a> and
--   <a>uninterruptibleMask</a> functions only, disallowing some classes of
--   tranformers from having <tt>MonadMask</tt> instances (notably
--   multi-exit-point transformers like <a>ExceptT</a>). If you are a
--   library author, you'll now need to provide an implementation for this
--   method. The <tt>StateT</tt> implementation demonstrates most of the
--   subtleties:
--   
--   <pre>
--   generalBracket acquire release use = StateT $ s0 -&gt; do
--     ((b, _s2), (c, s3)) &lt;- generalBracket
--       (runStateT acquire s0)
--       ((resource, s1) exitCase -&gt; case exitCase of
--         ExitCaseSuccess (b, s2) -&gt; runStateT (release resource (ExitCaseSuccess b)) s2
--   
--         -- In the two other cases, the base monad overrides <tt>use</tt>'s state
--         -- changes and the state reverts to <tt>s1</tt>.
--         ExitCaseException e     -&gt; runStateT (release resource (ExitCaseException e)) s1
--         ExitCaseAbort           -&gt; runStateT (release resource ExitCaseAbort) s1
--       )
--       ((resource, s1) -&gt; runStateT (use resource) s1)
--     return ((b, c), s3)
--   </pre>
--   
--   The <tt>StateT s m</tt> implementation of <tt>generalBracket</tt>
--   delegates to the <tt>m</tt> implementation of <tt>generalBracket</tt>.
--   The <tt>acquire</tt>, <tt>use</tt>, and <tt>release</tt> arguments
--   given to <tt>StateT</tt>'s implementation produce actions of type
--   <tt>StateT s m a</tt>, <tt>StateT s m b</tt>, and <tt>StateT s m
--   c</tt>. In order to run those actions in the base monad, we need to
--   call <tt>runStateT</tt>, from which we obtain actions of type <tt>m
--   (a, s)</tt>, <tt>m (b, s)</tt>, and <tt>m (c, s)</tt>. Since each
--   action produces the next state, it is important to feed the state
--   produced by the previous action to the next action.
--   
--   In the <a>ExitCaseSuccess</a> case, the state starts at <tt>s0</tt>,
--   flows through <tt>acquire</tt> to become <tt>s1</tt>, flows through
--   <tt>use</tt> to become <tt>s2</tt>, and finally flows through
--   <tt>release</tt> to become <tt>s3</tt>. In the other two cases,
--   <tt>release</tt> does not receive the value <tt>s2</tt>, so its action
--   cannot see the state changes performed by <tt>use</tt>. This is fine,
--   because in those two cases, an error was thrown in the base monad, so
--   as per the usual interaction between effects in a monad transformer
--   stack, those state changes get reverted. So we start from <tt>s1</tt>
--   instead.
--   
--   Finally, the <tt>m</tt> implementation of <tt>generalBracket</tt>
--   returns the pairs <tt>(b, s)</tt> and <tt>(c, s)</tt>. For monad
--   transformers other than <tt>StateT</tt>, this will be some other type
--   representing the effects and values performed and returned by the
--   <tt>use</tt> and <tt>release</tt> actions. The effect part of the
--   <tt>use</tt> result, in this case <tt>_s2</tt>, usually needs to be
--   discarded, since those effects have already been incorporated in the
--   <tt>release</tt> action.
--   
--   The only effect which is intentionally not incorporated in the
--   <tt>release</tt> action is the effect of throwing an error. In that
--   case, the error must be re-thrown. One subtlety which is easy to miss
--   is that in the case in which <tt>use</tt> and <tt>release</tt> both
--   throw an error, the error from <tt>release</tt> should take priority.
--   Here is an implementation for <tt>ExceptT</tt> which demonstrates how
--   to do this.
--   
--   <pre>
--   generalBracket acquire release use = ExceptT $ do
--     (eb, ec) &lt;- generalBracket
--       (runExceptT acquire)
--       (eresource exitCase -&gt; case eresource of
--         Left e -&gt; return (Left e) -- nothing to release, acquire didn't succeed
--         Right resource -&gt; case exitCase of
--           ExitCaseSuccess (Right b) -&gt; runExceptT (release resource (ExitCaseSuccess b))
--           ExitCaseException e       -&gt; runExceptT (release resource (ExitCaseException e))
--           _                         -&gt; runExceptT (release resource ExitCaseAbort))
--       (either (return . Left) (runExceptT . use))
--     return $ do
--       -- The order in which we perform those two <a>Either</a> effects determines
--       -- which error will win if they are both <a>Left</a>s. We want the error from
--       -- <tt>release</tt> to win.
--       c &lt;- ec
--       b &lt;- eb
--       return (b, c)
--   </pre>
generalBracket :: (MonadMask m, HasCallStack) => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | A <a>MonadMask</a> computation may either succeed with a value, abort
--   with an exception, or abort for some other reason. For example, in
--   <tt>ExceptT e IO</tt> you can use <a>throwM</a> to abort with an
--   exception (<a>ExitCaseException</a>) or <a>throwE</a> to abort with a
--   value of type <tt>e</tt> (<a>ExitCaseAbort</a>).
data ExitCase a
ExitCaseSuccess :: a -> ExitCase a
ExitCaseException :: SomeException -> ExitCase a
ExitCaseAbort :: ExitCase a

-- | Like <a>mask</a>, but does not pass a <tt>restore</tt> action to the
--   argument.
mask_ :: HasCallStack => MonadMask m => m a -> m a

-- | Like <a>uninterruptibleMask</a>, but does not pass a <tt>restore</tt>
--   action to the argument.
uninterruptibleMask_ :: HasCallStack => MonadMask m => m a -> m a

-- | Catches all exceptions, and somewhat defeats the purpose of the
--   extensible exception system. Use sparingly.
--   
--   <i>NOTE</i> This catches all <i>exceptions</i>, but if the monad
--   supports other ways of aborting the computation, those other kinds of
--   errors will not be caught.
catchAll :: HasCallStack => MonadCatch m => m a -> (SomeException -> m a) -> m a

-- | Catch all <a>IOError</a> (eqv. <tt>IOException</tt>) exceptions. Still
--   somewhat too general, but better than using <a>catchAll</a>. See
--   <a>catchIf</a> for an easy way of catching specific <a>IOError</a>s
--   based on the predicates in <a>System.IO.Error</a>.
catchIOError :: HasCallStack => MonadCatch m => m a -> (IOError -> m a) -> m a

-- | A more generalized way of determining which exceptions to catch at run
--   time.
catchJust :: HasCallStack => (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Catch exceptions only if they pass some predicate. Often useful with
--   the predicates for testing <a>IOError</a> values in
--   <a>System.IO.Error</a>.
catchIf :: HasCallStack => (MonadCatch m, Exception e) => (e -> Bool) -> m a -> (e -> m a) -> m a

-- | Generalized version of <a>Handler</a>
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Catches different sorts of exceptions. See <a>Control.Exception</a>'s
--   <a>catches</a>
catches :: HasCallStack => (Foldable f, MonadCatch m) => m a -> f (Handler m a) -> m a

-- | Flipped <a>catch</a>. See <a>Control.Exception</a>'s <a>handle</a>.
handle :: HasCallStack => (MonadCatch m, Exception e) => (e -> m a) -> m a -> m a

-- | Flipped <a>catchAll</a>
handleAll :: HasCallStack => MonadCatch m => (SomeException -> m a) -> m a -> m a

-- | Flipped <a>catchIOError</a>
handleIOError :: HasCallStack => MonadCatch m => (IOError -> m a) -> m a -> m a

-- | Flipped <a>catchJust</a>. See <a>Control.Exception</a>'s
--   <a>handleJust</a>.
handleJust :: HasCallStack => (MonadCatch m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Flipped <a>catchIf</a>
handleIf :: HasCallStack => (MonadCatch m, Exception e) => (e -> Bool) -> (e -> m a) -> m a -> m a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result. See
--   <a>Control.Exception</a>'s <a>try</a>.
try :: HasCallStack => (MonadCatch m, Exception e) => m a -> m (Either e a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>tryJust</a>
tryJust :: HasCallStack => (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Run an action only if an exception is thrown in the main action. The
--   exception is not caught, simply rethrown.
--   
--   <i>NOTE</i> The action is only run if an <i>exception</i> is thrown.
--   If the monad supports other ways of aborting the computation, the
--   action won't run if those other kinds of errors are thrown. See
--   <a>onError</a>.
onException :: HasCallStack => MonadCatch m => m a -> m b -> m a

-- | Run an action only if an error is thrown in the main action. Unlike
--   <a>onException</a>, this works with every kind of error, not just
--   exceptions. For example, if <tt>f</tt> is an <a>ExceptT</a>
--   computation which aborts with a <a>Left</a>, the computation
--   <tt>onError f g</tt> will execute <tt>g</tt>, while <tt>onException f
--   g</tt> will not.
--   
--   This distinction is only meaningful for monads which have multiple
--   exit points, such as <tt>Except</tt> and <a>MaybeT</a>. For monads
--   that only have a single exit point, there is no difference between
--   <a>onException</a> and <a>onError</a>, except that <a>onError</a> has
--   a more constrained type.
onError :: HasCallStack => MonadMask m => m a -> m b -> m a

-- | Generalized abstracted pattern of safe resource acquisition and
--   release in the face of errors. The first action "acquires" some value,
--   which is "released" by the second action at the end. The third action
--   "uses" the value and its result is the result of the <a>bracket</a>.
--   
--   If an error is thrown during the use, the release still happens before
--   the error is rethrown.
--   
--   Note that this is essentially a type-specialized version of
--   <a>generalBracket</a>. This function has a more common signature
--   (matching the signature from <a>Control.Exception</a>), and is often
--   more convenient to use. By contrast, <a>generalBracket</a> is more
--   expressive, allowing us to implement other functions like
--   <a>bracketOnError</a>.
bracket :: HasCallStack => MonadMask m => m a -> (a -> m c) -> (a -> m b) -> m b

-- | Version of <a>bracket</a> without any value being passed to the second
--   and third actions.
bracket_ :: HasCallStack => MonadMask m => m a -> m c -> m b -> m b

-- | Perform an action with a finalizer action that is run, even if an
--   error occurs.
finally :: HasCallStack => MonadMask m => m a -> m b -> m a

-- | Like <a>bracket</a>, but only performs the final action if an error is
--   thrown by the in-between computation.
bracketOnError :: HasCallStack => MonadMask m => m a -> (a -> m c) -> (a -> m b) -> m b

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException
SomeException :: e -> SomeException
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Catch.ExitCase a)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Catch.Handler m)
instance Control.Monad.Catch.MonadMask GHC.Types.IO
instance (e GHC.Types.~ GHC.Exception.Type.SomeException) => Control.Monad.Catch.MonadMask (Data.Either.Either e)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Reader.ReaderT r m)
instance (Control.Monad.Catch.MonadMask m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Catch.MonadMask m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Catch.MonadMask m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadMask (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Catch.MonadMask m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadMask (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Catch.MonadCatch GHC.Types.IO
instance Control.Monad.Catch.MonadCatch GHC.Conc.Sync.STM
instance (e GHC.Types.~ GHC.Exception.Type.SomeException) => Control.Monad.Catch.MonadCatch (Data.Either.Either e)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Reader.ReaderT r m)
instance (Control.Monad.Catch.MonadCatch m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Catch.MonadCatch m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Catch.MonadCatch m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Catch.MonadCatch m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Catch.MonadThrow []
instance Control.Monad.Catch.MonadThrow GHC.Maybe.Maybe
instance Control.Monad.Catch.MonadThrow Language.Haskell.TH.Syntax.Q
instance Control.Monad.Catch.MonadThrow GHC.Types.IO
instance Control.Monad.Catch.MonadThrow (GHC.ST.ST s)
instance Control.Monad.Catch.MonadThrow GHC.Conc.Sync.STM
instance (e GHC.Types.~ GHC.Exception.Type.SomeException) => Control.Monad.Catch.MonadThrow (Data.Either.Either e)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Reader.ReaderT r m)
instance (Control.Monad.Catch.MonadThrow m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Control.Monad.Catch.MonadThrow m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Control.Monad.Catch.MonadThrow m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Control.Monad.Catch.MonadThrow m, GHC.Base.Monoid w) => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Cont.ContT r m)


-- | This module supplies a 'pure' monad transformer that can be used for
--   mock-testing code that throws exceptions, so long as those exceptions
--   are always thrown with <a>throwM</a>.
--   
--   Do not mix <a>CatchT</a> with <a>IO</a>. Choose one or the other for
--   the bottom of your transformer stack!
module Control.Monad.Catch.Pure

-- | Add <a>Exception</a> handling abilities to a <a>Monad</a>.
--   
--   This should <i>never</i> be used in combination with <a>IO</a>. Think
--   of <a>CatchT</a> as an alternative base monad for use with mocking
--   code that solely throws exceptions via <a>throwM</a>.
--   
--   Note: that <a>IO</a> monad has these abilities already, so stacking
--   <a>CatchT</a> on top of it does not add any value and can possibly be
--   confusing:
--   
--   <pre>
--   &gt;&gt;&gt; (error "Hello!" :: IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   Hello!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runCatchT $ (error "Hello!" :: CatchT IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   *** Exception: Hello!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runCatchT $ (throwM (ErrorCall "Hello!") :: CatchT IO ()) `catch` (\(e :: ErrorCall) -&gt; liftIO $ print e)
--   Hello!
--   </pre>
newtype CatchT m a
CatchT :: m (Either SomeException a) -> CatchT m a
[runCatchT] :: CatchT m a -> m (Either SomeException a)
type Catch = CatchT Identity
runCatch :: Catch a -> Either SomeException a

-- | Map the unwrapped computation using the given function.
--   
--   <pre>
--   <a>runCatchT</a> (<a>mapCatchT</a> f m) = f (<a>runCatchT</a> m)
--   </pre>
mapCatchT :: (m (Either SomeException a) -> n (Either SomeException b)) -> CatchT m a -> CatchT n b
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Catch.Pure.CatchT m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Control.Monad.Catch.Pure.CatchT m)
instance (GHC.Base.Monad m, Data.Traversable.Traversable m) => Data.Traversable.Traversable (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Catch.Pure.CatchT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => Control.Monad.Catch.MonadThrow (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => Control.Monad.Catch.MonadCatch (Control.Monad.Catch.Pure.CatchT m)
instance GHC.Base.Monad m => Control.Monad.Catch.MonadMask (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.Reader.Class.MonadReader e m => Control.Monad.Reader.Class.MonadReader e (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Catch.Pure.CatchT m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Catch.Pure.CatchT m)
