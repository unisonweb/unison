<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.ByteString.Lazy.Search</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">stringsearch-0.3.6.6: Fast searching, splitting and replacing of ByteStrings</span><ul class="links" id="page-menu"><li><a href="src/Data.ByteString.Lazy.Search.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Fischer<br />Chris Kuklewicz</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>non-portable (BangPatterns)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Lazy.Search</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Overview</a><ul><li><a href="#g:2">Performance</a></li><li><a href="#g:3">Caution</a></li><li><a href="#g:4">Complexity</a></li><li><a href="#g:5">Partial application</a></li><li><a href="#g:6">Integer overflow</a></li></ul></li><li><a href="#g:7">Finding substrings</a></li><li><a href="#g:8">Breaking on substrings</a></li><li><a href="#g:9">Replacing</a></li><li><a href="#g:10">Splitting</a></li><li><a href="#g:11">Convenience</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast overlapping Boyer-Moore search of lazy
 <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code> values. Breaking, splitting and replacing
 using the Boyer-Moore algorithm.</p><p>Descriptions of the algorithm can be found at
 <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140">http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140</a>
 and
 <a href="http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm">http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm</a></p><p>Original authors: Daniel Fischer (daniel.is.fischer at googlemail.com) and
 Chris Kuklewicz (haskell at list.mightyreason.com).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:indices">indices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:nonOverlappingIndices">nonOverlappingIndices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:breakOn">breakOn</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</li><li class="src short"><a href="#v:breakFindAfter">breakFindAfter</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; ((<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>), <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</li><li class="src short"><a href="#v:replace">replace</a> :: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep =&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; rep -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></li><li class="src short"><a href="#v:split">split</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepEnd">splitKeepEnd</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepFront">splitKeepFront</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li><li class="src short"><a href="#v:strictify">strictify</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Overview</h1></a><div class="doc"><p>This module provides functions related to searching a substring within
 a string, using the Boyer-Moore algorithm with minor modifications
 to improve the overall performance and ameliorate the worst case
 performance degradation of the original Boyer-Moore algorithm for
 periodic patterns.</p><p>Efficiency demands that the pattern be a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>,
 to work with a lazy pattern, convert it to a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>
 first via <code><a href="Data-ByteString-Lazy-Search.html#v:strictify" title="Data.ByteString.Lazy.Search">strictify</a></code> (provided it is not too long).
 If support for long lazy patterns is needed, mail a feature-request.</p><p>When searching a pattern in a UTF-8-encoded <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, be aware that
 these functions work on bytes, not characters, so the indices are
 byte-offsets, not character offsets.</p></div><a href="#g:2" id="g:2"><h2>Performance</h2></a><div class="doc"><p>In general, the Boyer-Moore algorithm is the most efficient method to
 search for a pattern inside a string. The advantage over other algorithms
 (e.g. Na&#239;ve, Knuth-Morris-Pratt, Horspool, Sunday) can be made
 arbitrarily large for specially selected patterns and targets, but
 usually, it's a factor of 2&#8211;3 versus Knuth-Morris-Pratt and of
 6&#8211;10 versus the na&#239;ve algorithm. The Horspool and Sunday
 algorithms, which are simplified variants of the Boyer-Moore algorithm,
 typically have performance between Boyer-Moore and Knuth-Morris-Pratt,
 mostly closer to Boyer-Moore. The advantage of the Boyer-moore variants
 over other algorithms generally becomes larger for longer patterns. For
 very short patterns (or patterns with a very short period), other
 algorithms, e.g. <a href="Data-ByteString-Lazy-Search-DFA.html">Data.ByteString.Lazy.Search.DFA</a> can be faster (my
 tests suggest that &quot;very short&quot; means two, maybe three bytes).</p><p>In general, searching in a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code> is slightly faster
 than searching in a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>, but for long targets the
 smaller memory footprint of lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s can make searching
 those (sometimes much) faster. On the other hand, there are cases
 where searching in a strict target is much faster, even for long targets.</p><p>On 32-bit systems, <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>-arithmetic is much faster than <code><a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a></code>-arithmetic,
 so when there are many matches, that can make a significant difference.</p><p>Also, the modification to ameliorate the case of periodic patterns
 is defeated by chunk-boundaries, so long patterns with a short period
 and many matches exhibit poor behaviour (consider using <code>indices</code> from
 <a href="Data-ByteString-Lazy-Search-DFA.html">Data.ByteString.Lazy.Search.DFA</a> or <a href="Data-ByteString-Lazy-Search-KMP.html">Data.ByteString.Lazy.Search.KMP</a>
 in those cases, the former for medium-length patterns, the latter for
 long patterns; none of the functions except <code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code> suffer from
 this problem, though).</p></div><a href="#g:3" id="g:3"><h2>Caution</h2></a><div class="doc"><p>When working with a lazy target string, the relation between the pattern
 length and the chunk size can play a big r&#244;le.
 Crossing chunk boundaries is relatively expensive, so when that becomes
 a frequent occurrence, as may happen when the pattern length is close
 to or larger than the chunk size, performance is likely to degrade.
 If it is needed, steps can be taken to ameliorate that effect, but unless
 entirely separate functions are introduced, that would hurt the
 performance for the more common case of patterns much shorter than
 the default chunk size.</p></div><a href="#g:4" id="g:4"><h2>Complexity</h2></a><div class="doc"><p>Preprocessing the pattern is <em>O</em>(<code>patternLength</code> + &#963;) in time and
 space (&#963; is the alphabet size, 256 here) for all functions.
 The time complexity of the searching phase for <code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code>
 is <em>O</em>(<code>targetLength</code> / <code>patternLength</code>) in the best case.
 For non-periodic patterns, the worst case complexity is
 <em>O</em>(<code>targetLength</code>), but for periodic patterns, the worst case complexity
 is <em>O</em>(<code>targetLength</code> * <code>patternLength</code>) for the original Boyer-Moore
 algorithm.</p><p>The searching functions in this module contain a modification which
 drastically improves the performance for periodic patterns, although
 less for lazy targets than for strict ones.
 If I'm not mistaken, the worst case complexity for periodic patterns
 is <em>O</em>(<code>targetLength</code> * (1 + <code>patternLength</code> / <code>chunkSize</code>)).</p><p>The other functions don't have to deal with possible overlapping
 patterns, hence the worst case complexity for the processing phase
 is <em>O</em>(<code>targetLength</code>) (respectively <em>O</em>(<code>firstIndex + patternLength</code>)
 for the breaking functions if the pattern occurs).</p></div><a href="#g:5" id="g:5"><h2>Partial application</h2></a><div class="doc"><p>All functions can usefully be partially applied. Given only a pattern,
 the pattern is preprocessed only once, allowing efficient re-use.</p></div><a href="#g:6" id="g:6"><h2>Integer overflow</h2></a><div class="doc"><p>The current code uses <code>Int</code> to keep track of the locations in the
 target string.  If the length of the pattern plus the length of any
 strict chunk of the target string is greater or equal to
 <code><code><a href="../base-4.18.2.1/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code> :: <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code></code> then this will overflow causing an error.  We try
 to detect this and call <code><a href="../base-4.18.2.1/Prelude.html#v:error" title="Prelude">error</a></code> before a segfault occurs.</p></div><a href="#g:7" id="g:7"><h1>Finding substrings</h1></a><div class="top"><p class="src"><a id="v:indices" class="def">indices</a> <a href="src/Data.ByteString.Lazy.Search.html#indices" class="link">Source</a> <a href="#v:indices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a id="v:nonOverlappingIndices" class="def">nonOverlappingIndices</a> <a href="src/Data.ByteString.Lazy.Search.html#nonOverlappingIndices" class="link">Source</a> <a href="#v:nonOverlappingIndices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:nonOverlappingIndices" title="Data.ByteString.Lazy.Search">nonOverlappingIndices</a></code></code> finds the starting indices of all
   non-overlapping occurrences of the pattern in the target string.
   It is more efficient than removing indices from the list produced
   by <code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code>.</p></div></div><a href="#g:8" id="g:8"><h1>Breaking on substrings</h1></a><div class="top"><p class="src"><a id="v:breakOn" class="def">breakOn</a> <a href="src/Data.ByteString.Lazy.Search.html#breakOn" class="link">Source</a> <a href="#v:breakOn" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken at substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:breakOn" title="Data.ByteString.Lazy.Search">breakOn</a></code> pattern target</code> splits <code>target</code> at the first occurrence
   of <code>pattern</code>. If the pattern does not occur in the target, the
   second component of the result is empty, otherwise it starts with
   <code>pattern</code>. If the pattern is empty, the first component is empty.
   For a non-empty pattern, the first component is generated lazily,
   thus the first parts of it can be available before the pattern has
   been found or determined to be absent.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:append" title="Data.ByteString.Lazy">append</a></code> . <code><a href="Data-ByteString-Lazy-Search.html#v:breakOn" title="Data.ByteString.Lazy.Search">breakOn</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:breakAfter" class="def">breakAfter</a> <a href="src/Data.ByteString.Lazy.Search.html#breakAfter" class="link">Source</a> <a href="#v:breakAfter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken after substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:breakAfter" title="Data.ByteString.Lazy.Search">breakAfter</a></code> pattern target</code> splits <code>target</code> behind the first occurrence
   of <code>pattern</code>. An empty second component means that either the pattern
   does not occur in the target or the first occurrence of pattern is at
   the very end of target. If you need to discriminate between those cases,
   use breakFindAfter.
   If the pattern is empty, the first component is empty.
   For a non-empty pattern, the first component is generated lazily,
   thus the first parts of it can be available before the pattern has
   been found or determined to be absent.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:append" title="Data.ByteString.Lazy">append</a></code> . <code><a href="Data-ByteString-Lazy-Search.html#v:breakAfter" title="Data.ByteString.Lazy.Search">breakAfter</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:breakFindAfter" class="def">breakFindAfter</a> <a href="src/Data.ByteString.Lazy.Search.html#breakFindAfter" class="link">Source</a> <a href="#v:breakFindAfter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; ((<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>), <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>Head and tail of string broken after substring
   and presence of pattern</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:breakFindAfter" title="Data.ByteString.Lazy.Search">breakFindAfter</a></code></code> does the same as <code><a href="Data-ByteString-Lazy-Search.html#v:breakAfter" title="Data.ByteString.Lazy.Search">breakAfter</a></code> but additionally indicates
   whether the pattern is present in the target.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:fst" title="Data.Tuple">fst</a></code> . <code><a href="Data-ByteString-Lazy-Search.html#v:breakFindAfter" title="Data.ByteString.Lazy.Search">breakFindAfter</a></code> pat = <code><a href="Data-ByteString-Lazy-Search.html#v:breakAfter" title="Data.ByteString.Lazy.Search">breakAfter</a></code> pat
</pre></div></div><a href="#g:9" id="g:9"><h1>Replacing</h1></a><div class="top"><p class="src"><a id="v:replace" class="def">replace</a> <a href="src/Data.ByteString.Lazy.Search.html#replace" class="link">Source</a> <a href="#v:replace" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to replace</p></td></tr><tr><td class="src">-&gt; rep</td><td class="doc"><p>Replacement string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to modify</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy result</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> pat sub text</code> replaces all (non-overlapping) occurrences of
   <code>pat</code> in <code>text</code> with <code>sub</code>. If occurrences of <code>pat</code> overlap, the first
   occurrence that does not overlap with a replaced previous occurrence
   is substituted. Occurrences of <code>pat</code> arising from a substitution
   will not be substituted. For example:</p><pre>  <code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> &quot;ana&quot; &quot;olog&quot; &quot;banana&quot; = &quot;bologna&quot;
  <code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> &quot;ana&quot; &quot;o&quot; &quot;bananana&quot; = &quot;bono&quot;
  <code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> &quot;aab&quot; &quot;abaa&quot; &quot;aaabb&quot; = &quot;aabaab&quot;
</pre><p>The result is a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>,
   which is lazily produced, without copying.
   Equality of pattern and substitution is not checked, but</p><pre>  <code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> pat pat text == text
</pre><p>holds (the internal structure is generally different).
   If the pattern is empty but not the substitution, the result
   is equivalent to (were they <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code>s) <code>cycle sub</code>.</p><p>For non-empty <code>pat</code> and <code>sub</code> a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>,</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> sub . <code><a href="Data-ByteString-Lazy-Search.html#v:split" title="Data.ByteString.Lazy.Search">split</a></code> pat = <code><a href="Data-ByteString-Lazy-Search.html#v:replace" title="Data.ByteString.Lazy.Search">replace</a></code> pat sub
</pre><p>and analogous relations hold for other types of <code>sub</code>.</p></div></div><a href="#g:10" id="g:10"><h1>Splitting</h1></a><div class="top"><p class="src"><a id="v:split" class="def">split</a> <a href="src/Data.ByteString.Lazy.Search.html#split" class="link">Source</a> <a href="#v:split" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:split" title="Data.ByteString.Lazy.Search">split</a></code> pattern target</code> splits <code>target</code> at each (non-overlapping)
   occurrence of <code>pattern</code>, removing <code>pattern</code>. If <code>pattern</code> is empty,
   the result is an infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s, if <code>target</code>
   is empty but not <code>pattern</code>, the result is an empty list, otherwise
   the following relations hold (where <code>patL</code> is the lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>
   corresponding to <code>pat</code>):</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> patL . <code><a href="Data-ByteString-Lazy-Search.html#v:split" title="Data.ByteString.Lazy.Search">split</a></code> pat = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>,
  <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Lazy-Search.html#v:split" title="Data.ByteString.Lazy.Search">split</a></code> pattern target) ==
              <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Lazy-Search.html#v:nonOverlappingIndices" title="Data.ByteString.Lazy.Search">nonOverlappingIndices</a></code> pattern target) + 1,
</pre><p>no fragment in the result contains an occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepEnd" class="def">splitKeepEnd</a> <a href="src/Data.ByteString.Lazy.Search.html#splitKeepEnd" class="link">Source</a> <a href="#v:splitKeepEnd" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search">splitKeepEnd</a></code> pattern target</code> splits <code>target</code> after each (non-overlapping)
   occurrence of <code>pattern</code>. If <code>pattern</code> is empty, the result is an
   infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s, otherwise the following
   relations hold:</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="Data-ByteString-Lazy-Search.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search">splitKeepEnd</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>,
</pre><p>all fragments in the result except possibly the last end with
   <code>pattern</code>, no fragment contains more than one occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepFront" class="def">splitKeepFront</a> <a href="src/Data.ByteString.Lazy.Search.html#splitKeepFront" class="link">Source</a> <a href="#v:splitKeepFront" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:splitKeepFront" title="Data.ByteString.Lazy.Search">splitKeepFront</a></code></code> is like <code><a href="Data-ByteString-Lazy-Search.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search">splitKeepEnd</a></code>, except that <code>target</code> is split
   before each occurrence of <code>pattern</code> and hence all fragments
   with the possible exception of the first begin with <code>pattern</code>.
   No fragment contains more than one non-overlapping occurrence
   of <code>pattern</code>.</p></div></div><a href="#g:11" id="g:11"><h1>Convenience</h1></a><div class="top"><p class="src"><a id="v:strictify" class="def">strictify</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="src/Data.ByteString.Lazy.Search.html#strictify" class="link">Source</a> <a href="#v:strictify" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search.html#v:strictify" title="Data.ByteString.Lazy.Search">strictify</a></code></code> converts a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code> to a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>
   to make it a suitable pattern.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>