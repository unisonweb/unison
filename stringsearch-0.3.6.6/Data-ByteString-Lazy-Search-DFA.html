<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.ByteString.Lazy.Search.DFA</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">stringsearch-0.3.6.6: Fast searching, splitting and replacing of ByteStrings</span><ul class="links" id="page-menu"><li><a href="src/Data.ByteString.Lazy.Search.DFA.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Fischer</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>non-portable (BangPatterns)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Lazy.Search.DFA</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Overview</a><ul><li><a href="#g:2">Complexity and performance</a></li><li><a href="#g:3">Partial application</a></li></ul></li><li><a href="#g:4">Finding substrings</a></li><li><a href="#g:5">Breaking on substrings</a></li><li><a href="#g:6">Replacing</a></li><li><a href="#g:7">Splitting</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast search of lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code> values. Breaking,
 splitting and replacing using a deterministic finite automaton.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:indices">indices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:nonOverlappingIndices">nonOverlappingIndices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:breakOn">breakOn</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</li><li class="src short"><a href="#v:breakFindAfter">breakFindAfter</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; ((<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>), <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</li><li class="src short"><a href="#v:replace">replace</a> :: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep =&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; rep -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></li><li class="src short"><a href="#v:split">split</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepEnd">splitKeepEnd</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepFront">splitKeepFront</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Overview</h1></a><div class="doc"><p>This module provides functions related to searching a substring within
 a string. The searching algorithm uses a deterministic finite automaton
 based on the Knuth-Morris-Pratt algorithm.
 The automaton is implemented as an array of <code>(patternLength + 1) * &#963;</code>
 state transitions, where &#963; is the alphabet size (256), so it is only
 suitable for short enough patterns, therefore the patterns in this module
 are required to be strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s.</p><p>When searching a pattern in a UTF-8-encoded <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>, be aware that
 these functions work on bytes, not characters, so the indices are
 byte-offsets, not character offsets.</p></div><a href="#g:2" id="g:2"><h2>Complexity and performance</h2></a><div class="doc"><p>The time and space complexity of the preprocessing phase is
 <em>O</em>(<code>patternLength * &#963;</code>).
 The searching phase is <em>O</em>(<code>targetLength</code>), each target character is
 inspected only once.</p><p>In general the functions in this module have about the same performance as
 the corresponding functions using the Knuth-Morris-Pratt algorithm but
 are considerably slower than the Boyer-Moore functions. For very short
 patterns or, in the case of <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:indices" title="Data.ByteString.Lazy.Search.DFA">indices</a></code>, patterns with a short period
 which occur often, however, times are close to or even below the
 Boyer-Moore times.</p></div><a href="#g:3" id="g:3"><h2>Partial application</h2></a><div class="doc"><p>All functions can usefully be partially applied. Given only a pattern,
 the automaton is constructed only once, allowing efficient re-use.</p></div><a href="#g:4" id="g:4"><h1>Finding substrings</h1></a><div class="top"><p class="src"><a id="v:indices" class="def">indices</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#indices" class="link">Source</a> <a href="#v:indices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:indices" title="Data.ByteString.Lazy.Search.DFA">indices</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a id="v:nonOverlappingIndices" class="def">nonOverlappingIndices</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#nonOverlappingIndices" class="link">Source</a> <a href="#v:nonOverlappingIndices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:nonOverlappingIndices" title="Data.ByteString.Lazy.Search.DFA">nonOverlappingIndices</a></code></code> finds the starting indices of all
   non-overlapping occurrences of the pattern in the target string.
   It is more efficient than removing indices from the list produced
   by <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:indices" title="Data.ByteString.Lazy.Search.DFA">indices</a></code>.</p></div></div><a href="#g:5" id="g:5"><h1>Breaking on substrings</h1></a><div class="top"><p class="src"><a id="v:breakOn" class="def">breakOn</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#breakOn" class="link">Source</a> <a href="#v:breakOn" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken at substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakOn" title="Data.ByteString.Lazy.Search.DFA">breakOn</a></code> pattern target</code> splits <code>target</code> at the first occurrence
   of <code>pattern</code>. If the pattern does not occur in the target, the
   second component of the result is empty, otherwise it starts with
   <code>pattern</code>. If the pattern is empty, the first component is empty.
   For a non-empty pattern, the first component is generated lazily,
   thus the first parts of it can be available before the pattern has
   been found or determined to be absent.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:append" title="Data.ByteString.Lazy">append</a></code> . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakOn" title="Data.ByteString.Lazy.Search.DFA">breakOn</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:breakAfter" class="def">breakAfter</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#breakAfter" class="link">Source</a> <a href="#v:breakAfter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken after substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakAfter" title="Data.ByteString.Lazy.Search.DFA">breakAfter</a></code> pattern target</code> splits <code>target</code> behind the first occurrence
   of <code>pattern</code>. An empty second component means that either the pattern
   does not occur in the target or the first occurrence of pattern is at
   the very end of target. If you need to discriminate between those cases,
   use breakFindAfter.
   If the pattern is empty, the first component is empty.
   For a non-empty pattern, the first component is generated lazily,
   thus the first parts of it can be available before the pattern has
   been found or determined to be absent.
 <code>
   <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:append" title="Data.ByteString.Lazy">append</a></code> . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakAfter" title="Data.ByteString.Lazy.Search.DFA">breakAfter</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
 </code></p></div></div><div class="top"><p class="src"><a id="v:breakFindAfter" class="def">breakFindAfter</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#breakFindAfter" class="link">Source</a> <a href="#v:breakFindAfter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to search in</p></td></tr><tr><td class="src">-&gt; ((<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>), <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>Head and tail of string broken after substring
   and presence of pattern</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakFindAfter" title="Data.ByteString.Lazy.Search.DFA">breakFindAfter</a></code></code> does the same as <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakAfter" title="Data.ByteString.Lazy.Search.DFA">breakAfter</a></code> but additionally indicates
   whether the pattern is present in the target.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:fst" title="Data.Tuple">fst</a></code> . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakFindAfter" title="Data.ByteString.Lazy.Search.DFA">breakFindAfter</a></code> pat = <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:breakAfter" title="Data.ByteString.Lazy.Search.DFA">breakAfter</a></code> pat
</pre></div></div><a href="#g:6" id="g:6"><h1>Replacing</h1></a><div class="top"><p class="src"><a id="v:replace" class="def">replace</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#replace" class="link">Source</a> <a href="#v:replace" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to replace</p></td></tr><tr><td class="src">-&gt; rep</td><td class="doc"><p>Replacement string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to modify</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy result</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> pat sub text</code> replaces all (non-overlapping) occurrences of
   <code>pat</code> in <code>text</code> with <code>sub</code>. If occurrences of <code>pat</code> overlap, the first
   occurrence that does not overlap with a replaced previous occurrence
   is substituted. Occurrences of <code>pat</code> arising from a substitution
   will not be substituted. For example:</p><pre>  <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> &quot;ana&quot; &quot;olog&quot; &quot;banana&quot; = &quot;bologna&quot;
  <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> &quot;ana&quot; &quot;o&quot; &quot;bananana&quot; = &quot;bono&quot;
  <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> &quot;aab&quot; &quot;abaa&quot; &quot;aaabb&quot; = &quot;aabaab&quot;
</pre><p>The result is a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>,
   which is lazily produced, without copying.
   Equality of pattern and substitution is not checked, but</p><pre>  <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> pat pat text == text
</pre><p>holds (the internal structure is generally different).
   If the pattern is empty but not the substitution, the result
   is equivalent to (were they <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code>s) <code>cycle sub</code>.</p><p>For non-empty <code>pat</code> and <code>sub</code> a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>,</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> sub . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:split" title="Data.ByteString.Lazy.Search.DFA">split</a></code> pat = <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:replace" title="Data.ByteString.Lazy.Search.DFA">replace</a></code> pat sub
</pre><p>and analogous relations hold for other types of <code>sub</code>.</p></div></div><a href="#g:7" id="g:7"><h1>Splitting</h1></a><div class="top"><p class="src"><a id="v:split" class="def">split</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#split" class="link">Source</a> <a href="#v:split" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:split" title="Data.ByteString.Lazy.Search.DFA">split</a></code> pattern target</code> splits <code>target</code> at each (non-overlapping)
   occurrence of <code>pattern</code>, removing <code>pattern</code>. If <code>pattern</code> is empty,
   the result is an infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s, if <code>target</code>
   is empty but not <code>pattern</code>, the result is an empty list, otherwise
   the following relations hold (where <code>patL</code> is the lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>
   corresponding to <code>pat</code>):</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> patL . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:split" title="Data.ByteString.Lazy.Search.DFA">split</a></code> pat = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>,
  <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Lazy-Search-DFA.html#v:split" title="Data.ByteString.Lazy.Search.DFA">split</a></code> pattern target) ==
              <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Lazy-Search-DFA.html#v:nonOverlappingIndices" title="Data.ByteString.Lazy.Search.DFA">nonOverlappingIndices</a></code> pattern target) + 1,
</pre><p>no fragment in the result contains an occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepEnd" class="def">splitKeepEnd</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#splitKeepEnd" class="link">Source</a> <a href="#v:splitKeepEnd" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search.DFA">splitKeepEnd</a></code> pattern target</code> splits <code>target</code> after each (non-overlapping)
   occurrence of <code>pattern</code>. If <code>pattern</code> is empty, the result is an
   infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s, otherwise the following
   relations hold:</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:concat" title="Data.ByteString.Lazy">concat</a></code> . <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search.DFA">splitKeepEnd</a></code> pattern = 'id,'
</pre><p>all fragments in the result except possibly the last end with
   <code>pattern</code>, no fragment contains more than one occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepFront" class="def">splitKeepFront</a> <a href="src/Data.ByteString.Lazy.Search.DFA.html#splitKeepFront" class="link">Source</a> <a href="#v:splitKeepFront" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy string to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Lazy-Search-DFA.html#v:splitKeepFront" title="Data.ByteString.Lazy.Search.DFA">splitKeepFront</a></code></code> is like <code><a href="Data-ByteString-Lazy-Search-DFA.html#v:splitKeepEnd" title="Data.ByteString.Lazy.Search.DFA">splitKeepEnd</a></code>, except that <code>target</code> is split
   before each occurrence of <code>pattern</code> and hence all fragments
   with the possible exception of the first begin with <code>pattern</code>.
   No fragment contains more than one non-overlapping occurrence
   of <code>pattern</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>