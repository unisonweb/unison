<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.ByteString.Search</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">stringsearch-0.3.6.6: Fast searching, splitting and replacing of ByteStrings</span><ul class="links" id="page-menu"><li><a href="src/Data.ByteString.Search.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Fischer (2007-2011)<br />Chris Kuklewicz</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>non-portable (BangPatterns)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Search</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Overview</a><ul><li><a href="#g:2">Performance</a></li><li><a href="#g:3">Complexity</a></li><li><a href="#g:4">Partial application</a></li></ul></li><li><a href="#g:5">Finding substrings</a></li><li><a href="#g:6">Breaking on substrings</a></li><li><a href="#g:7">Replacing</a></li><li><a href="#g:8">Splitting</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast overlapping Boyer-Moore search of strict
 <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code> values. Breaking, splitting and replacing
 using the Boyer-Moore algorithm.</p><p>Descriptions of the algorithm can be found at
 <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140">http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140</a>
 and
 <a href="http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm">http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm</a></p><p>Original authors: Daniel Fischer (daniel.is.fischer at googlemail.com) and
 Chris Kuklewicz (haskell at list.mightyreason.com).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:indices">indices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:nonOverlappingIndices">nonOverlappingIndices</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:breakOn">breakOn</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)</li><li class="src short"><a href="#v:replace">replace</a> :: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep =&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; rep -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></li><li class="src short"><a href="#v:split">split</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepEnd">splitKeepEnd</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</li><li class="src short"><a href="#v:splitKeepFront">splitKeepFront</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Overview</h1></a><div class="doc"><p>This module provides functions related to searching a substring within
 a string, using the Boyer-Moore algorithm with minor modifications
 to improve the overall performance and avoid the worst case
 performance degradation of the original Boyer-Moore algorithm for
 periodic patterns.</p><p>When searching a pattern in a UTF-8-encoded <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>, be aware that
 these functions work on bytes, not characters, so the indices are
 byte-offsets, not character offsets.</p></div><a href="#g:2" id="g:2"><h2>Performance</h2></a><div class="doc"><p>In general, the Boyer-Moore algorithm is the most efficient method to
 search for a pattern inside a string. The advantage over other algorithms
 (e.g. Na&#239;ve, Knuth-Morris-Pratt, Horspool, Sunday) can be made
 arbitrarily large for specially selected patterns and targets, but
 usually, it's a factor of 2&#8211;3 versus Knuth-Morris-Pratt and of
 6&#8211;10 versus the na&#239;ve algorithm. The Horspool and Sunday
 algorithms, which are simplified variants of the Boyer-Moore algorithm,
 typically have performance between Boyer-Moore and Knuth-Morris-Pratt,
 mostly closer to Boyer-Moore. The advantage of the Boyer-moore variants
 over other algorithms generally becomes larger for longer patterns. For
 very short patterns (or patterns with a very short period), other
 algorithms, e.g. <a href="Data-ByteString-Search-DFA.html">Data.ByteString.Search.DFA</a> can be faster (my
 tests suggest that &quot;very short&quot; means two, maybe three bytes).</p><p>In general, searching in a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code> is slightly faster
 than searching in a lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>, but for long targets, the
 smaller memory footprint of lazy <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>s can make searching
 those (sometimes much) faster. On the other hand, there are cases
 where searching in a strict target is much faster, even for long targets.</p></div><a href="#g:3" id="g:3"><h2>Complexity</h2></a><div class="doc"><p>Preprocessing the pattern is <em>O</em>(<code>patternLength</code> + &#963;) in time and
 space (&#963; is the alphabet size, 256 here) for all functions.
 The time complexity of the searching phase for <code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code>
 is <em>O</em>(<code>targetLength</code> / <code>patternLength</code>) in the best case.
 For non-periodic patterns, the worst case complexity is
 <em>O</em>(<code>targetLength</code>), but for periodic patterns, the worst case complexity
 is <em>O</em>(<code>targetLength</code> * <code>patternLength</code>) for the original Boyer-Moore
 algorithm.</p><p>The searching functions in this module contain a modification which
 drastically improves the performance for periodic patterns.
 I believe that for strict target strings, the worst case is now
 <em>O</em>(<code>targetLength</code>) also for periodic patterns.
 I may be wrong, though.</p><p>The other functions don't have to deal with possible overlapping
 patterns, hence the worst case complexity for the processing phase
 is <em>O</em>(<code>targetLength</code>) (respectively <em>O</em>(<code>firstIndex + patternLength</code>)
 for the breaking functions if the pattern occurs).</p></div><a href="#g:4" id="g:4"><h2>Partial application</h2></a><div class="doc"><p>All functions can usefully be partially applied. Given only a pattern,
 the pattern is preprocessed only once, allowing efficient re-use.</p></div><a href="#g:5" id="g:5"><h1>Finding substrings</h1></a><div class="top"><p class="src"><a id="v:indices" class="def">indices</a> <a href="src/Data.ByteString.Search.html#indices" class="link">Source</a> <a href="#v:indices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p><p>In general, <code><code><a href="../base-4.18.2.1/Data-Bool.html#v:not" title="Data.Bool">not</a></code> . <code><a href="../base-4.18.2.1/Data-Foldable.html#v:null" title="Data.Foldable">null</a></code> $ <code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code> pat target</code> is a much more
   efficient version of <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:isInfixOf" title="Data.ByteString">isInfixOf</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:nonOverlappingIndices" class="def">nonOverlappingIndices</a> <a href="src/Data.ByteString.Search.html#nonOverlappingIndices" class="link">Source</a> <a href="#v:nonOverlappingIndices" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Pattern to find</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:nonOverlappingIndices" title="Data.ByteString.Search">nonOverlappingIndices</a></code></code> finds the starting indices of all
   non-overlapping occurrences of the pattern in the target string.
   It is more efficient than removing indices from the list produced
   by <code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code>.</p></div></div><a href="#g:6" id="g:6"><h1>Breaking on substrings</h1></a><div class="top"><p class="src"><a id="v:breakOn" class="def">breakOn</a> <a href="src/Data.ByteString.Search.html#breakOn" class="link">Source</a> <a href="#v:breakOn" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken at substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:breakOn" title="Data.ByteString.Search">breakOn</a></code> pattern target</code> splits <code>target</code> at the first occurrence
   of <code>pattern</code>. If the pattern does not occur in the target, the
   second component of the result is empty, otherwise it starts with
   <code>pattern</code>. If the pattern is empty, the first component is empty.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:append" title="Data.ByteString">append</a></code> . <code><a href="Data-ByteString-Search.html#v:breakOn" title="Data.ByteString.Search">breakOn</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:breakAfter" class="def">breakAfter</a> <a href="src/Data.ByteString.Search.html#breakAfter" class="link">Source</a> <a href="#v:breakAfter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search for</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to search in</p></td></tr><tr><td class="src">-&gt; (<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>, <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>)</td><td class="doc"><p>Head and tail of string broken after substring</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:breakAfter" title="Data.ByteString.Search">breakAfter</a></code> pattern target</code> splits <code>target</code> behind the first occurrence
   of <code>pattern</code>. An empty second component means that either the pattern
   does not occur in the target or the first occurrence of pattern is at
   the very end of target. To discriminate between those cases, use e.g.
   <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:isSuffixOf" title="Data.ByteString">isSuffixOf</a></code>.</p><pre>  <code><a href="../base-4.18.2.1/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:append" title="Data.ByteString">append</a></code> . <code><a href="Data-ByteString-Search.html#v:breakAfter" title="Data.ByteString.Search">breakAfter</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre></div></div><a href="#g:7" id="g:7"><h1>Replacing</h1></a><div class="top"><p class="src"><a id="v:replace" class="def">replace</a> <a href="src/Data.ByteString.Search.html#replace" class="link">Source</a> <a href="#v:replace" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-ByteString-Search-Substitution.html#t:Substitution" title="Data.ByteString.Search.Substitution">Substitution</a> rep</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Substring to replace</p></td></tr><tr><td class="src">-&gt; rep</td><td class="doc"><p>Replacement string</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to modify</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy result</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> pat sub text</code> replaces all (non-overlapping) occurrences of
   <code>pat</code> in <code>text</code> with <code>sub</code>. If occurrences of <code>pat</code> overlap, the first
   occurrence that does not overlap with a replaced previous occurrence
   is substituted. Occurrences of <code>pat</code> arising from a substitution
   will not be substituted. For example:</p><pre>  <code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> &quot;ana&quot; &quot;olog&quot; &quot;banana&quot; = &quot;bologna&quot;
  <code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> &quot;ana&quot; &quot;o&quot; &quot;bananana&quot; = &quot;bono&quot;
  <code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> &quot;aab&quot; &quot;abaa&quot; &quot;aaabb&quot; = &quot;aabaab&quot;
</pre><p>The result is a <em>lazy</em> <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></code>,
   which is lazily produced, without copying.
   Equality of pattern and substitution is not checked, but</p><pre>  (<code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:concat" title="Data.ByteString">concat</a></code> . <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:toChunks" title="Data.ByteString.Lazy">toChunks</a></code> $ <code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> pat pat text) == text
</pre><p>holds. If the pattern is empty but not the substitution, the result
   is equivalent to (were they <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code>s) <code><code><a href="../base-4.18.2.1/GHC-List.html#v:cycle" title="GHC.List">cycle</a></code> sub</code>.</p><p>For non-empty <code>pat</code> and <code>sub</code> a strict <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>,</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#v:fromChunks" title="Data.ByteString.Lazy">fromChunks</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> sub . <code><a href="Data-ByteString-Search.html#v:split" title="Data.ByteString.Search">split</a></code> pat = <code><a href="Data-ByteString-Search.html#v:replace" title="Data.ByteString.Search">replace</a></code> pat sub
</pre><p>and analogous relations hold for other types of <code>sub</code>.</p></div></div><a href="#g:8" id="g:8"><h1>Splitting</h1></a><div class="top"><p class="src"><a id="v:split" class="def">split</a> <a href="src/Data.ByteString.Search.html#split" class="link">Source</a> <a href="#v:split" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:split" title="Data.ByteString.Search">split</a></code> pattern target</code> splits <code>target</code> at each (non-overlapping)
   occurrence of <code>pattern</code>, removing <code>pattern</code>. If <code>pattern</code> is empty,
   the result is an infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s, if <code>target</code>
   is empty but not <code>pattern</code>, the result is an empty list, otherwise
   the following relations hold:</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:concat" title="Data.ByteString">concat</a></code> . <code><a href="../base-4.18.2.1/Data-List.html#v:intersperse" title="Data.List">intersperse</a></code> pat . <code><a href="Data-ByteString-Search.html#v:split" title="Data.ByteString.Search">split</a></code> pat = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>,
  <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Search.html#v:split" title="Data.ByteString.Search">split</a></code> pattern target) ==
              <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> (<code><a href="Data-ByteString-Search.html#v:nonOverlappingIndices" title="Data.ByteString.Search">nonOverlappingIndices</a></code> pattern target) + 1,
</pre><p>no fragment in the result contains an occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepEnd" class="def">splitKeepEnd</a> <a href="src/Data.ByteString.Search.html#splitKeepEnd" class="link">Source</a> <a href="#v:splitKeepEnd" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:splitKeepEnd" title="Data.ByteString.Search">splitKeepEnd</a></code> pattern target</code> splits <code>target</code> after each (non-overlapping)
   occurrence of <code>pattern</code>. If <code>pattern</code> is empty, the result is an
   infinite list of empty <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></code>s, otherwise the following
   relations hold:</p><pre>  <code><a href="../bytestring-0.11.5.3/Data-ByteString.html#v:concat" title="Data.ByteString">concat</a></code> . <code><a href="Data-ByteString-Search.html#v:splitKeepEnd" title="Data.ByteString.Search">splitKeepEnd</a></code> pattern = <code><a href="../base-4.18.2.1/Data-Function.html#v:id" title="Data.Function">id</a></code>,
</pre><p>all fragments in the result except possibly the last end with
   <code>pattern</code>, no fragment contains more than one occurrence of <code>pattern</code>.</p></div></div><div class="top"><p class="src"><a id="v:splitKeepFront" class="def">splitKeepFront</a> <a href="src/Data.ByteString.Search.html#splitKeepFront" class="link">Source</a> <a href="#v:splitKeepFront" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Pattern to split on</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>String to split</p></td></tr><tr><td class="src">-&gt; [<a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a>]</td><td class="doc"><p>Fragments of string</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search.html#v:splitKeepFront" title="Data.ByteString.Search">splitKeepFront</a></code></code> is like <code><a href="Data-ByteString-Search.html#v:splitKeepEnd" title="Data.ByteString.Search">splitKeepEnd</a></code>, except that <code>target</code> is split
   before each occurrence of <code>pattern</code> and hence all fragments
   with the possible exception of the first begin with <code>pattern</code>.
   No fragment contains more than one non-overlapping occurrence
   of <code>pattern</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>