<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.ByteString.Search.BoyerMoore</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">stringsearch-0.3.6.6: Fast searching, splitting and replacing of ByteStrings</span><ul class="links" id="page-menu"><li><a href="src/Data.ByteString.Search.BoyerMoore.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Fischer<br />Chris Kuklewicz</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>non-portable (BangPatterns)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Search.BoyerMoore</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Overview</a><ul><li><a href="#g:2">Changes</a></li><li><a href="#g:3">Deprecation</a></li><li><a href="#g:4">Parameter and return types</a></li><li><a href="#g:5">Lazy ByteStrings</a></li><li><a href="#g:6">Performance</a></li><li><a href="#g:7">Complexity</a></li><li><a href="#g:8">Partial application</a></li><li><a href="#g:9">Integer overflow</a></li></ul></li><li><a href="#g:10">Functions</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><div class="warning"><p>Deprecated: Use the new interface instead</p></div><p>Fast overlapping Boyer-Moore search of both strict and lazy
 <code>ByteString</code> values.</p><p>Descriptions of the algorithm can be found at
 <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140">http://www-igm.univ-mlv.fr/~lecroq/string/node14.html#SECTION00140</a>
 and
 <a href="http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm">http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm</a></p><p>Original authors: Daniel Fischer (daniel.is.fischer at googlemail.com) and
 Chris Kuklewicz (haskell at list.mightyreason.com).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:matchLL">matchLL</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:matchLS">matchLS</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:matchSL">matchSL</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</li><li class="src short"><a href="#v:matchSS">matchSS</a> :: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Overview</h1></a><div class="doc"><p>This module exists only for backwards compatibility. Nevertheless
 there have been small changes in the behaviour of the functions.
 The module exports four search functions: <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code>, <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLS" title="Data.ByteString.Search.BoyerMoore">matchLS</a></code>,
 <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSL" title="Data.ByteString.Search.BoyerMoore">matchSL</a></code>, and <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSS" title="Data.ByteString.Search.BoyerMoore">matchSS</a></code>. All of them return the list of all
 starting positions of possibly overlapping occurrences of a pattern
 in a string.</p></div><a href="#g:2" id="g:2"><h2>Changes</h2></a><div class="doc"><p>Formerly, all four functions returned an empty list when passed
 an empty pattern. Now, in accordance with the functions from the other
 modules, <code>matchXY &quot;&quot; target = [0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div><a href="#g:3" id="g:3"><h2>Deprecation</h2></a><div class="doc"><p>This module is <em>deprecated</em>. You should use the new interface provided
 in <a href="Data-ByteString-Search.html">Data.ByteString.Search</a> resp. <a href="Data-ByteString-Lazy-Search.html">Data.ByteString.Lazy.Search</a>.</p></div><a href="#g:4" id="g:4"><h2>Parameter and return types</h2></a><div class="doc"><p>The first parameter is always the pattern string.  The second
 parameter is always the target string to be searched.  The returned
 list contains the offsets of all <em>overlapping</em> patterns.</p><p>A returned <code>Int</code> or <code>Int64</code> is an index into the target string
 which is aligned to the head of the pattern string.  Strict targets
 return <code>Int</code> indices and lazy targets return <code>Int64</code> indices.  All
 returned lists are computed and returned in a lazy fashion.</p></div><a href="#g:5" id="g:5"><h2>Lazy ByteStrings</h2></a><div class="doc"><p><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code> and <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLS" title="Data.ByteString.Search.BoyerMoore">matchLS</a></code> take lazy bytestrings as patterns.  For
 performance, if the pattern is not a single strict chunk then all
 the the pattern chunks will copied into a concatenated strict
 bytestring.  This limits the patterns to a length of (maxBound ::
 Int).</p><p><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code> and <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSL" title="Data.ByteString.Search.BoyerMoore">matchSL</a></code> take lazy bytestrings as targets.
 These are written so that while they work they will not retain a
 reference to all the earlier parts of the the lazy bytestring.
 This means the garbage collector would be able to keep only a small
 amount of the target string and free the rest.</p></div><a href="#g:6" id="g:6"><h2>Performance</h2></a><div class="doc"><p>In general, the Boyer-Moore algorithm is the most efficient method to
 search for a pattern inside a string. The advantage over other algorithms
 (e.g. Na&#239;ve, Knuth-Morris-Pratt, Horspool, Sunday) can be made
 arbitrarily large for specially selected patterns and targets, but
 usually, it's a factor of 2&#8211;3 versus Knuth-Morris-Pratt and of
 6&#8211;10 versus the na&#239;ve algorithm. The Horspool and Sunday
 algorithms, which are simplified variants of the Boyer-Moore algorithm,
 typically have performance between Boyer-Moore and Knuth-Morris-Pratt,
 mostly closer to Boyer-Moore. The advantage of the Boyer-moore variants
 over other algorithms generally becomes larger for longer patterns. For
 very short patterns (or patterns with a very short period), other
 algorithms, e.g. <a href="Data-ByteString-Search-DFA.html">Data.ByteString.Search.DFA</a> can be faster (my
 tests suggest that &quot;very short&quot; means two, maybe three bytes).</p><p>In general, searching in a strict <code><a href="S.html#v:ByteString" title="S">ByteString</a></code> is slightly faster
 than searching in a lazy <code><a href="L.html#v:ByteString" title="L">ByteString</a></code>, but for long targets the
 smaller memory footprint of lazy <code><a href="L.html#v:ByteStrings" title="L">ByteStrings</a></code> can make searching
 those (sometimes much) faster. On the other hand, there are cases
 where searching in a strict target is much faster, even for long targets.</p><p>On 32-bit systems, <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>-arithmetic is much faster than <code>Int64</code>-arithmetic,
 so when there are many matches, that can make a significant difference.</p><p>Also, the modification to ameliorate the case of periodic patterns
 is defeated by chunk-boundaries, so long patterns with a short period
 and many matches exhibit poor behaviour (consider using <code>indices</code> from
 <a href="Data-ByteString-Lazy-Search-DFA.html">Data.ByteString.Lazy.Search.DFA</a> or <a href="Data-ByteString-Lazy-Search-KMP.html">Data.ByteString.Lazy.Search.KMP</a>
 in those cases, the former for medium-length patterns, the latter for
 long patterns; only <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code> and <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSL" title="Data.ByteString.Search.BoyerMoore">matchSL</a></code> suffer from
 this problem, though).</p></div><a href="#g:7" id="g:7"><h2>Complexity</h2></a><div class="doc"><p>Preprocessing the pattern string is O(<code>patternLength</code>).  The search
 performance is O(<code>targetLength</code>/<code>patternLength</code>) in the best case,
 allowing it to go faster than a Knuth-Morris-Pratt algorithm.  With
 a non-periodic pattern the worst case uses O(3*<code>targetLength</code>)
 comparisons.  The periodic pattern worst case is quadratic
 O(<code>targetLength</code>*<code>patternLength</code>) complexity for the original
 Boyer-Moore algorithm.</p><p>The searching functions in this module contain a modification which
 drastically improves the performance for periodic patterns.
 I believe that for strict target strings, the worst case is now
 <em>O</em>(<code>targetLength</code>) also for periodic patterns and for lazy target
 strings, my semi-educated guess is
 <em>O</em>(<code>targetLength</code> * (1 + <code>patternLength</code> / <code>chunkSize</code>)).</p></div><a href="#g:8" id="g:8"><h2>Partial application</h2></a><div class="doc"><p>These functions can all be usefully partially applied.
 Given only a pattern the partially applied version will compute
 the supporting lookup tables only once, allowing for efficient re-use.
 Similarly, the partially applied <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code> and <code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLS" title="Data.ByteString.Search.BoyerMoore">matchLS</a></code> will compute
 the concatenated pattern only once.</p></div><a href="#g:9" id="g:9"><h2>Integer overflow</h2></a><div class="doc"><p>The current code uses <code>Int</code> to keep track of the locations in the
 target string.  If the length of the pattern plus the length of any
 strict chunk of the target string is greater or equal to
 <code><code><a href="../base-4.18.2.1/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code>::Int</code> then this will overflow causing an error.  We try
 to detect this and call <code><a href="../base-4.18.2.1/Prelude.html#v:error" title="Prelude">error</a></code> before a segfault occurs.</p></div><a href="#g:10" id="g:10"><h1>Functions</h1></a><div class="top"><p class="src"><a id="v:matchLL" class="def">matchLL</a> <a href="src/Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#matchLL" class="link">Source</a> <a href="#v:matchLL" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy pattern</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy target string</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLL" title="Data.ByteString.Search.BoyerMoore">matchLL</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   It is a simple wrapper for <code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code>.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a id="v:matchLS" class="def">matchLS</a> <a href="src/Data.ByteString.Search.Internal.BoyerMoore.html#matchLS" class="link">Source</a> <a href="#v:matchLS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy pattern</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict target string</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchLS" title="Data.ByteString.Search.BoyerMoore">matchLS</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   It is a simple wrapper for <code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code>.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a id="v:matchSL" class="def">matchSL</a> <a href="src/Data.ByteString.Lazy.Search.Internal.BoyerMoore.html#matchSL" class="link">Source</a> <a href="#v:matchSL" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString-Lazy.html#t:ByteString" title="Data.ByteString.Lazy">ByteString</a></td><td class="doc"><p>Lazy target string</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int64" title="Data.Int">Int64</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSL" title="Data.ByteString.Search.BoyerMoore">matchSL</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   It is an alias for <code><a href="Data-ByteString-Lazy-Search.html#v:indices" title="Data.ByteString.Lazy.Search">indices</a></code>.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div><div class="top"><p class="src"><a id="v:matchSS" class="def">matchSS</a> <a href="src/Data.ByteString.Search.Internal.BoyerMoore.html#matchSS" class="link">Source</a> <a href="#v:matchSS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict pattern</p></td></tr><tr><td class="src">-&gt; <a href="../bytestring-0.11.5.3/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></td><td class="doc"><p>Strict target string</p></td></tr><tr><td class="src">-&gt; [<a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a>]</td><td class="doc"><p>Offsets of matches</p></td></tr></table></div><div class="doc"><p><code><code><a href="Data-ByteString-Search-BoyerMoore.html#v:matchSS" title="Data.ByteString.Search.BoyerMoore">matchSS</a></code></code> finds the starting indices of all possibly overlapping
   occurrences of the pattern in the target string.
   It is an alias for <code><a href="Data-ByteString-Search.html#v:indices" title="Data.ByteString.Search">indices</a></code>.
   If the pattern is empty, the result is <code>[0 .. <code><a href="../base-4.18.2.1/Data-Foldable.html#v:length" title="Data.Foldable">length</a></code> target]</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>