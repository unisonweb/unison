<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-3"></span><span>
</span><span id="line-4"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Module      :  Control.Applicative.Combinators</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Copyright   :  &#169; 2017&#8211;present Mark Karpov</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- License     :  BSD 3 clause</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Maintainer  :  Mark Karpov &lt;markkarpov92@gmail.com&gt;</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Stability   :  experimental</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- The module provides parser combinators defined for instances of</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- 'Applicative' and 'Alternative'. It also re-exports functions that are</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- commonly used in parsing from &quot;Control.Applicative&quot; with additional</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- parsing-related comments added.</span><span>
</span><span id="line-17"></span><span class="hs-comment">--</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- Due to the nature of the 'Applicative' and 'Alternative' abstractions,</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- they are prone to memory leaks and not as efficient as their monadic</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- counterparts. Although all the combinators we provide in this module are</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- perfectly expressible in terms of 'Applicative' and 'Alternative', please</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- prefer &quot;Control.Monad.Combinators&quot; instead when possible.</span><span>
</span><span id="line-23"></span><span class="hs-comment">--</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- If you wish that the combinators that cannot return empty lists return</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- values of the 'Data.List.NonEmpty.NonEmpty' data type, use the</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- &quot;Control.Applicative.Combinators.NonEmpty&quot; module.</span><span>
</span><span id="line-27"></span><span class="hs-comment">--</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- === A note on backtracking</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- Certain parsing libraries, such as Megaparsec, do not backtrack every</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- branch of parsing automatically for the sake of performance and better</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- error messages. They typically backtrack only &#8220;atomic&#8221; parsers, e.g.</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- those that match a token or several tokens in a row. To backtrack an</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- arbitrary complex parser\/branch, a special combinator should be used,</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- typically called @try@. Combinators in this module are defined in terms</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- 'Applicative' and 'Alternative' operations. Being quite abstract, they</span><span>
</span><span id="line-37"></span><span class="hs-comment">-- cannot know anything about inner workings of any concrete parsing</span><span>
</span><span id="line-38"></span><span class="hs-comment">-- library, and so they cannot use @try@.</span><span>
</span><span id="line-39"></span><span class="hs-comment">--</span><span>
</span><span id="line-40"></span><span class="hs-comment">-- The essential feature of the 'Alternative' type class is the @('&lt;|&gt;')@</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- operator that allows to express choice. In libraries that do not</span><span>
</span><span id="line-42"></span><span class="hs-comment">-- backtrack everything automatically, the choice operator and everything</span><span>
</span><span id="line-43"></span><span class="hs-comment">-- that is build on top of it require the parser on the left hand side to</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- backtrack in order for the alternative branch of parsing to be tried.</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- Thus it is the responsibility of the programmer to wrap more complex,</span><span>
</span><span id="line-46"></span><span class="hs-comment">-- composite parsers in @try@ to achieve correct behavior.</span><span>
</span><span id="line-47"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Control.Applicative.Combinators</span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Re-exports from &quot;Control.Applicative&quot;</span></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span>
</span><span id="line-50"></span><span>    </span><span class="annot"><span class="hs-comment">-- $assocbo</span></span><span>
</span><span id="line-51"></span><span>    </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><span class="hs-comment">-- $many</span></span><span>
</span><span id="line-53"></span><span>    </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">,</span><span>
</span><span id="line-54"></span><span>    </span><span class="annot"><span class="hs-comment">-- $some</span></span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="hs-identifier">optional</span></span><span class="hs-special">,</span><span>
</span><span id="line-56"></span><span>    </span><span class="annot"><span class="hs-comment">-- $optional</span></span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span>
</span><span id="line-58"></span><span>    </span><span class="annot"><span class="hs-comment">-- $empty</span></span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Original combinators</span></span><span>
</span><span id="line-61"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#between"><span class="hs-identifier">between</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#choice"><span class="hs-identifier">choice</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#count"><span class="hs-identifier">count</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#count%27"><span class="hs-identifier">count'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#eitherP"><span class="hs-identifier">eitherP</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-66"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#endBy"><span class="hs-identifier">endBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#endBy1"><span class="hs-identifier">endBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill"><span class="hs-identifier">manyTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill_"><span class="hs-identifier">manyTill_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#someTill"><span class="hs-identifier">someTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-71"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#someTill_"><span class="hs-identifier">someTill_</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-72"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#option"><span class="hs-identifier">option</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy"><span class="hs-identifier">sepBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy1"><span class="hs-identifier">sepBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy"><span class="hs-identifier">sepEndBy</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-76"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy1"><span class="hs-identifier">sepEndBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-77"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipMany"><span class="hs-identifier">skipMany</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-78"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipSome"><span class="hs-identifier">skipSome</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-79"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipCount"><span class="hs-identifier">skipCount</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-80"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipManyTill"><span class="hs-identifier">skipManyTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-81"></span><span>    </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipSomeTill"><span class="hs-identifier">skipSomeTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span class="hs-keyword">where</span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span>
</span><span id="line-86"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">replicateM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">replicateM_</span></span><span class="hs-special">)</span><span>
</span><span id="line-87"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- Re-exports from &quot;Control.Applicative&quot;</span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span class="hs-comment">-- $assocbo</span><span>
</span><span id="line-93"></span><span class="hs-comment">--</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- This combinator implements choice. The parser @p '&lt;|&gt;' q@ first applies</span><span>
</span><span id="line-95"></span><span class="hs-comment">-- @p@. If it succeeds, the value of @p@ is returned. If @p@ fails, parser</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- @q@ is tried.</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- $many</span><span>
</span><span id="line-99"></span><span class="hs-comment">--</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- @'many' p@ applies the parser @p@ /zero/ or more times and returns a list</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- of the values returned by @p@.</span><span>
</span><span id="line-102"></span><span class="hs-comment">--</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- &gt; identifier = (:) &lt;$&gt; letter &lt;*&gt; many (alphaNumChar &lt;|&gt; char '_')</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="hs-comment">-- $some</span><span>
</span><span id="line-106"></span><span class="hs-comment">--</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- @'some' p@ applies the parser @p@ /one/ or more times and returns a list</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- of the values returned by @p@.</span><span>
</span><span id="line-109"></span><span class="hs-comment">--</span><span>
</span><span id="line-110"></span><span class="hs-comment">-- &gt; word = some letter</span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span class="hs-comment">-- $optional</span><span>
</span><span id="line-113"></span><span class="hs-comment">--</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- @'optional' p@ tries to apply the parser @p@. It will parse @p@ or</span><span>
</span><span id="line-115"></span><span class="hs-comment">-- 'Nothing'. It only fails if @p@ fails after consuming input. On success</span><span>
</span><span id="line-116"></span><span class="hs-comment">-- result of @p@ is returned inside of 'Just', on failure 'Nothing' is</span><span>
</span><span id="line-117"></span><span class="hs-comment">-- returned.</span><span>
</span><span id="line-118"></span><span class="hs-comment">--</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- See also: 'option'.</span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-comment">-- $empty</span><span>
</span><span id="line-122"></span><span class="hs-comment">--</span><span>
</span><span id="line-123"></span><span class="hs-comment">-- This parser fails unconditionally without providing any information about</span><span>
</span><span id="line-124"></span><span class="hs-comment">-- the cause of the failure.</span><span>
</span><span id="line-125"></span><span class="hs-comment">--</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- @since 0.4.0</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-comment">----------------------------------------------------------------------------</span><span>
</span><span id="line-129"></span><span class="hs-comment">-- Original combinators</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-comment">-- | @'between' open close p@ parses @open@, followed by @p@ and @close@.</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- Returns the value returned by @p@.</span><span>
</span><span id="line-133"></span><span class="hs-comment">--</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- &gt; braces = between (symbol &quot;{&quot;) (symbol &quot;}&quot;)</span><span>
</span><span id="line-135"></span><span id="local-6989586621679034128"><span id="local-6989586621679034129"><span id="local-6989586621679034130"><span id="local-6989586621679034131"><span class="annot"><a href="Control.Applicative.Combinators.html#between"><span class="hs-identifier hs-type">between</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034128"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034128"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034129"><span class="hs-identifier hs-type">open</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034128"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034130"><span class="hs-identifier hs-type">close</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034128"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034131"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034128"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034131"><span class="hs-identifier hs-type">a</span></a></span></span></span></span></span><span>
</span><span id="line-136"></span><span id="between"><span class="annot"><span class="annottext">between :: forall (m :: * -&gt; *) open close a.
Applicative m =&gt;
m open -&gt; m close -&gt; m a -&gt; m a
</span><a href="Control.Applicative.Combinators.html#between"><span class="hs-identifier hs-var hs-var">between</span></a></span></span><span> </span><span id="local-6989586621679034272"><span class="annot"><span class="annottext">m open
</span><a href="#local-6989586621679034272"><span class="hs-identifier hs-var">open</span></a></span></span><span> </span><span id="local-6989586621679034273"><span class="annot"><span class="annottext">m close
</span><a href="#local-6989586621679034273"><span class="hs-identifier hs-var">close</span></a></span></span><span> </span><span id="local-6989586621679034274"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034274"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m open
</span><a href="#local-6989586621679034272"><span class="hs-identifier hs-var">open</span></a></span><span> </span><span class="annot"><span class="annottext">m open -&gt; m a -&gt; m a
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034274"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m close -&gt; m a
forall a b. m a -&gt; m b -&gt; m a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">m close
</span><a href="#local-6989586621679034273"><span class="hs-identifier hs-var">close</span></a></span><span>
</span><span id="line-137"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#between"><span class="hs-pragma hs-type">between</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-comment">-- | @'choice' ps@ tries to apply the parsers in the list @ps@ in order,</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- until one of them succeeds. Returns the value of the succeeding parser.</span><span>
</span><span id="line-141"></span><span class="hs-comment">--</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- &gt; choice = asum</span><span>
</span><span id="line-143"></span><span id="local-6989586621679034141"><span id="local-6989586621679034142"><span id="local-6989586621679034144"><span class="annot"><a href="Control.Applicative.Combinators.html#choice"><span class="hs-identifier hs-type">choice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679034141"><span class="hs-identifier hs-type">f</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034142"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034141"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679034142"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034144"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034142"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034144"><span class="hs-identifier hs-type">a</span></a></span></span></span></span><span>
</span><span id="line-144"></span><span id="choice"><span class="annot"><span class="annottext">choice :: forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable f, Alternative m) =&gt;
f (m a) -&gt; m a
</span><a href="Control.Applicative.Combinators.html#choice"><span class="hs-identifier hs-var hs-var">choice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">f (m a) -&gt; m a
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable f, Alternative m) =&gt;
f (m a) -&gt; m a
</span><span class="hs-identifier hs-var">asum</span></span><span>
</span><span id="line-145"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#choice"><span class="hs-pragma hs-type">choice</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="hs-comment">-- | @'count' n p@ parses @n@ occurrences of @p@. If @n@ is smaller or equal</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- to zero, the parser equals to @'pure' []@. Returns a list of @n@ parsed</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- values.</span><span>
</span><span id="line-150"></span><span class="hs-comment">--</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- &gt; count = replicateM</span><span>
</span><span id="line-152"></span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- See also: 'skipCount', 'count''.</span><span>
</span><span id="line-154"></span><span id="local-6989586621679034148"><span id="local-6989586621679034149"><span class="annot"><a href="Control.Applicative.Combinators.html#count"><span class="hs-identifier hs-type">count</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034148"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034148"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034149"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034148"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034149"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-155"></span><span id="count"><span class="annot"><span class="annottext">count :: forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#count"><span class="hs-identifier hs-var hs-var">count</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; m a -&gt; m [a]
forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m [a]
</span><span class="hs-identifier hs-var">replicateM</span></span><span>
</span><span id="line-156"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#count"><span class="hs-pragma hs-type">count</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-157"></span><span>
</span><span id="line-158"></span><span class="hs-comment">-- | @'count'' m n p@ parses from @m@ to @n@ occurrences of @p@. If @n@ is</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- not positive or @m &gt; n@, the parser equals to @'pure' []@. Returns a list</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- of parsed values.</span><span>
</span><span id="line-161"></span><span class="hs-comment">--</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- Please note that @m@ /may/ be negative, in this case effect is the same</span><span>
</span><span id="line-163"></span><span class="hs-comment">-- as if it were equal to zero.</span><span>
</span><span id="line-164"></span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- See also: 'skipCount', 'count'.</span><span>
</span><span id="line-166"></span><span id="local-6989586621679034152"><span id="local-6989586621679034153"><span class="annot"><a href="Control.Applicative.Combinators.html#count%27"><span class="hs-identifier hs-type">count'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034152"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034152"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034153"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034152"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034153"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-167"></span><span id="count%27"><span class="annot"><span class="annottext">count' :: forall (m :: * -&gt; *) a. Alternative m =&gt; Int -&gt; Int -&gt; m a -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#count%27"><span class="hs-identifier hs-var hs-var">count'</span></a></span></span><span> </span><span id="local-6989586621679034292"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679034292"><span class="hs-identifier hs-var">m'</span></a></span></span><span> </span><span id="local-6989586621679034293"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679034293"><span class="hs-identifier hs-var">n'</span></a></span></span><span> </span><span id="local-6989586621679034294"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034294"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; m [a]
forall {t}. (Ord t, Num t) =&gt; t -&gt; t -&gt; m [a]
</span><a href="#local-6989586621679034295"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679034292"><span class="hs-identifier hs-var">m'</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679034293"><span class="hs-identifier hs-var">n'</span></a></span><span>
</span><span id="line-168"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-169"></span><span>    </span><span id="local-6989586621679034295"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; m [a]
</span><a href="#local-6989586621679034295"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">!</span><span id="local-6989586621679034321"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034321"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">!</span><span id="local-6989586621679034322"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034322"><span class="hs-identifier hs-var">n</span></a></span></span><span>
</span><span id="line-170"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034322"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034321"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034322"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-171"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034321"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034294"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; m [a]
</span><a href="#local-6989586621679034295"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034321"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034322"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-172"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034294"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; m [a]
</span><a href="#local-6989586621679034295"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679034322"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m [a] -&gt; m [a] -&gt; m [a]
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-173"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#count%27"><span class="hs-pragma hs-type">count'</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span class="hs-comment">-- | Combine two alternatives.</span><span>
</span><span id="line-176"></span><span class="hs-comment">--</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- &gt; eitherP a b = (Left &lt;$&gt; a) &lt;|&gt; (Right &lt;$&gt; b)</span><span>
</span><span id="line-178"></span><span id="local-6989586621679034166"><span id="local-6989586621679034167"><span id="local-6989586621679034168"><span class="annot"><a href="Control.Applicative.Combinators.html#eitherP"><span class="hs-identifier hs-type">eitherP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034166"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034166"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034167"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034166"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034168"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034166"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="annot"><a href="#local-6989586621679034167"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034168"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-179"></span><span id="eitherP"><span class="annot"><span class="annottext">eitherP :: forall (m :: * -&gt; *) a b.
Alternative m =&gt;
m a -&gt; m b -&gt; m (Either a b)
</span><a href="Control.Applicative.Combinators.html#eitherP"><span class="hs-identifier hs-var hs-var">eitherP</span></a></span></span><span> </span><span id="local-6989586621679034333"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034333"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679034334"><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679034334"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; Either a b
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Either a b) -&gt; m a -&gt; m (Either a b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034333"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m (Either a b) -&gt; m (Either a b) -&gt; m (Either a b)
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; Either a b
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">(b -&gt; Either a b) -&gt; m b -&gt; m (Either a b)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m b
</span><a href="#local-6989586621679034334"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-180"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#eitherP"><span class="hs-pragma hs-type">eitherP</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span class="hs-comment">-- | @'endBy' p sep@ parses /zero/ or more occurrences of @p@, separated and</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- ended by @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-184"></span><span class="hs-comment">--</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- &gt; cStatements = cStatement `endBy` semicolon</span><span>
</span><span id="line-186"></span><span id="local-6989586621679034177"><span id="local-6989586621679034178"><span id="local-6989586621679034179"><span class="annot"><a href="Control.Applicative.Combinators.html#endBy"><span class="hs-identifier hs-type">endBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034177"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034177"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034178"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034177"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034179"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034177"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034178"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-187"></span><span id="endBy"><span class="annot"><span class="annottext">endBy :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#endBy"><span class="hs-identifier hs-var hs-var">endBy</span></a></span></span><span> </span><span id="local-6989586621679034340"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034340"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034341"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034341"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; m [a]
forall a. m a -&gt; m [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034340"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m sep -&gt; m a
forall a b. m a -&gt; m b -&gt; m a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034341"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-188"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#endBy"><span class="hs-pragma hs-type">endBy</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-189"></span><span>
</span><span id="line-190"></span><span class="hs-comment">-- | @'endBy1' p sep@ parses /one/ or more occurrences of @p@, separated and</span><span>
</span><span id="line-191"></span><span class="hs-comment">-- ended by @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-192"></span><span id="local-6989586621679034342"><span id="local-6989586621679034343"><span id="local-6989586621679034344"><span class="annot"><a href="Control.Applicative.Combinators.html#endBy1"><span class="hs-identifier hs-type">endBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034343"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034344"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034342"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034343"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-193"></span><span id="endBy1"><span class="annot"><span class="annottext">endBy1 :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#endBy1"><span class="hs-identifier hs-var hs-var">endBy1</span></a></span></span><span> </span><span id="local-6989586621679034349"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034349"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034350"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034350"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; m [a]
forall a. m a -&gt; m [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034349"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m sep -&gt; m a
forall a b. m a -&gt; m b -&gt; m a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034350"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#endBy1"><span class="hs-pragma hs-type">endBy1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-comment">-- | @'manyTill' p end@ applies parser @p@ /zero/ or more times until parser</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- @end@ succeeds. Returns the list of values returned by @p@. @end@ result</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- is consumed and lost. Use 'manyTill_' if you wish to keep it.</span><span>
</span><span id="line-199"></span><span class="hs-comment">--</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- See also: 'skipMany', 'skipManyTill'.</span><span>
</span><span id="line-201"></span><span id="local-6989586621679034351"><span id="local-6989586621679034352"><span id="local-6989586621679034353"><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill"><span class="hs-identifier hs-type">manyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034352"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034353"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034351"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034352"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-202"></span><span id="manyTill"><span class="annot"><span class="annottext">manyTill :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#manyTill"><span class="hs-identifier hs-var hs-var">manyTill</span></a></span></span><span> </span><span id="local-6989586621679034357"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034357"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034358"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034358"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m [a]
</span><a href="#local-6989586621679034359"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-204"></span><span>    </span><span id="local-6989586621679034359"><span class="annot"><span class="annottext">go :: m [a]
</span><a href="#local-6989586621679034359"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m end -&gt; m [a]
forall a b. a -&gt; m b -&gt; m a
forall (f :: * -&gt; *) a b. Functor f =&gt; a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;$</span></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034358"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m [a] -&gt; m [a] -&gt; m [a]
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034357"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m [a]
</span><a href="#local-6989586621679034359"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-205"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill"><span class="hs-pragma hs-type">manyTill</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="hs-comment">-- | @'manyTill_' p end@ applies parser @p@ /zero/ or more times until</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- parser @end@ succeeds. Returns the list of values returned by @p@ and the</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- @end@ result. Use 'manyTill' if you have no need in the result of the</span><span>
</span><span id="line-210"></span><span class="hs-comment">-- @end@.</span><span>
</span><span id="line-211"></span><span class="hs-comment">--</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- See also: 'skipMany', 'skipManyTill'.</span><span>
</span><span id="line-213"></span><span class="hs-comment">--</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- @since 1.2.0</span><span>
</span><span id="line-215"></span><span id="local-6989586621679034194"><span id="local-6989586621679034195"><span id="local-6989586621679034196"><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill_"><span class="hs-identifier hs-type">manyTill_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034195"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034196"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034194"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034195"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679034196"><span class="hs-identifier hs-type">end</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-216"></span><span id="manyTill_"><span class="annot"><span class="annottext">manyTill_ :: forall (m :: * -&gt; *) a end.
Alternative m =&gt;
m a -&gt; m end -&gt; m ([a], end)
</span><a href="Control.Applicative.Combinators.html#manyTill_"><span class="hs-identifier hs-var hs-var">manyTill_</span></a></span></span><span> </span><span id="local-6989586621679034370"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034370"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034371"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034371"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m ([a], end)
</span><a href="#local-6989586621679034372"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-218"></span><span>    </span><span id="local-6989586621679034372"><span class="annot"><span class="annottext">go :: m ([a], end)
</span><a href="#local-6989586621679034372"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(end -&gt; ([a], end)) -&gt; m end -&gt; m ([a], end)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034371"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m ([a], end) -&gt; m ([a], end) -&gt; m ([a], end)
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; ([a], end) -&gt; ([a], end))
-&gt; m a -&gt; m ([a], end) -&gt; m ([a], end)
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679034379"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034379"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679034380"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679034380"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679034381"><span class="annot"><span class="annottext">end
</span><a href="#local-6989586621679034381"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034379"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; [a] -&gt; [a]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679034380"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">end
</span><a href="#local-6989586621679034381"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034370"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m ([a], end)
</span><a href="#local-6989586621679034372"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-219"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#manyTill_"><span class="hs-pragma hs-type">manyTill_</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="hs-comment">-- | @'someTill' p end@ works similarly to @'manyTill' p end@, but @p@</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- should succeed at least once. @end@ result is consumed and lost. Use</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- 'someTill_' if you wish to keep it.</span><span>
</span><span id="line-224"></span><span class="hs-comment">--</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- &gt; someTill p end = liftA2 (:) p (manyTill p end)</span><span>
</span><span id="line-226"></span><span class="hs-comment">--</span><span>
</span><span id="line-227"></span><span class="hs-comment">-- See also: 'skipSome', 'skipSomeTill'.</span><span>
</span><span id="line-228"></span><span id="local-6989586621679034382"><span id="local-6989586621679034383"><span id="local-6989586621679034384"><span class="annot"><a href="Control.Applicative.Combinators.html#someTill"><span class="hs-identifier hs-type">someTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034382"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034382"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034383"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034382"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034384"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034382"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034383"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-229"></span><span id="someTill"><span class="annot"><span class="annottext">someTill :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#someTill"><span class="hs-identifier hs-var hs-var">someTill</span></a></span></span><span> </span><span id="local-6989586621679034389"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034389"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034390"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034390"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034389"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a -&gt; m end -&gt; m [a]
forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034389"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034390"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#someTill"><span class="hs-pragma hs-type">someTill</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-231"></span><span>
</span><span id="line-232"></span><span class="hs-comment">-- | @'someTill_' p end@ works similarly to @'manyTill_' p end@, but @p@</span><span>
</span><span id="line-233"></span><span class="hs-comment">-- should succeed at least once. Use 'someTill' if you have no need in the</span><span>
</span><span id="line-234"></span><span class="hs-comment">-- result of the @end@.</span><span>
</span><span id="line-235"></span><span class="hs-comment">--</span><span>
</span><span id="line-236"></span><span class="hs-comment">-- See also: 'skipSome', 'skipSomeTill'.</span><span>
</span><span id="line-237"></span><span class="hs-comment">--</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- @since 1.2.0</span><span>
</span><span id="line-239"></span><span id="local-6989586621679034391"><span id="local-6989586621679034392"><span id="local-6989586621679034393"><span class="annot"><a href="Control.Applicative.Combinators.html#someTill_"><span class="hs-identifier hs-type">someTill_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034392"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034393"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034392"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679034393"><span class="hs-identifier hs-type">end</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-240"></span><span id="someTill_"><span class="annot"><span class="annottext">someTill_ :: forall (m :: * -&gt; *) a end.
Alternative m =&gt;
m a -&gt; m end -&gt; m ([a], end)
</span><a href="Control.Applicative.Combinators.html#someTill_"><span class="hs-identifier hs-var hs-var">someTill_</span></a></span></span><span> </span><span id="local-6989586621679034398"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034398"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034399"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034399"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-241"></span><span>  </span><span class="annot"><span class="annottext">(a -&gt; ([a], end) -&gt; ([a], end))
-&gt; m a -&gt; m ([a], end) -&gt; m ([a], end)
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679034400"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034400"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679034401"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679034401"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679034402"><span class="annot"><span class="annottext">end
</span><a href="#local-6989586621679034402"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034400"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; [a] -&gt; [a]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679034401"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">end
</span><a href="#local-6989586621679034402"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034398"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a -&gt; m end -&gt; m ([a], end)
forall (m :: * -&gt; *) a end.
Alternative m =&gt;
m a -&gt; m end -&gt; m ([a], end)
</span><a href="Control.Applicative.Combinators.html#manyTill_"><span class="hs-identifier hs-var">manyTill_</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034398"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034399"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#someTill_"><span class="hs-pragma hs-type">someTill_</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-243"></span><span>
</span><span id="line-244"></span><span class="hs-comment">-- | @'option' x p@ tries to apply the parser @p@. If @p@ fails without</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- consuming input, it returns the value @x@, otherwise the value returned</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- by @p@.</span><span>
</span><span id="line-247"></span><span class="hs-comment">--</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- &gt; option x p = p &lt;|&gt; pure x</span><span>
</span><span id="line-249"></span><span class="hs-comment">--</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- See also: 'optional'.</span><span>
</span><span id="line-251"></span><span id="local-6989586621679034206"><span id="local-6989586621679034207"><span class="annot"><a href="Control.Applicative.Combinators.html#option"><span class="hs-identifier hs-type">option</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034206"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034207"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034206"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034207"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034206"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034207"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-252"></span><span id="option"><span class="annot"><span class="annottext">option :: forall (m :: * -&gt; *) a. Alternative m =&gt; a -&gt; m a -&gt; m a
</span><a href="Control.Applicative.Combinators.html#option"><span class="hs-identifier hs-var hs-var">option</span></a></span></span><span> </span><span id="local-6989586621679034407"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034407"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679034408"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034408"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034408"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m a -&gt; m a
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679034407"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-253"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#option"><span class="hs-pragma hs-type">option</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-254"></span><span>
</span><span id="line-255"></span><span class="hs-comment">-- | @'sepBy' p sep@ parses /zero/ or more occurrences of @p@, separated by</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-257"></span><span class="hs-comment">--</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- &gt; commaSep p = p `sepBy` comma</span><span>
</span><span id="line-259"></span><span id="local-6989586621679034409"><span id="local-6989586621679034410"><span id="local-6989586621679034411"><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy"><span class="hs-identifier hs-type">sepBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034410"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034411"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034409"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034410"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-260"></span><span id="sepBy"><span class="annot"><span class="annottext">sepBy :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepBy"><span class="hs-identifier hs-var hs-var">sepBy</span></a></span></span><span> </span><span id="local-6989586621679034417"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034417"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034418"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034418"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; m sep -&gt; m [a]
forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepBy1"><span class="hs-identifier hs-var">sepBy1</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034417"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034418"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">m [a] -&gt; m [a] -&gt; m [a]
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-261"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy"><span class="hs-pragma hs-type">sepBy</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span class="hs-comment">-- | @'sepBy1' p sep@ parses /one/ or more occurrences of @p@, separated by</span><span>
</span><span id="line-264"></span><span class="hs-comment">-- @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-265"></span><span id="local-6989586621679034419"><span id="local-6989586621679034420"><span id="local-6989586621679034421"><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy1"><span class="hs-identifier hs-type">sepBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034420"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034421"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034420"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-266"></span><span id="sepBy1"><span class="annot"><span class="annottext">sepBy1 :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepBy1"><span class="hs-identifier hs-var hs-var">sepBy1</span></a></span></span><span> </span><span id="local-6989586621679034427"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034427"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034428"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034428"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034427"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a -&gt; m [a]
forall a. m a -&gt; m [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034428"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">m sep -&gt; m a -&gt; m a
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034427"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-267"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepBy1"><span class="hs-pragma hs-type">sepBy1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="hs-comment">-- | @'sepEndBy' p sep@ parses /zero/ or more occurrences of @p@, separated</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- and optionally ended by @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-271"></span><span id="local-6989586621679034429"><span id="local-6989586621679034430"><span id="local-6989586621679034431"><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy"><span class="hs-identifier hs-type">sepEndBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034429"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034429"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034430"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034429"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034431"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034429"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034430"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-272"></span><span id="sepEndBy"><span class="annot"><span class="annottext">sepEndBy :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepEndBy"><span class="hs-identifier hs-var hs-var">sepEndBy</span></a></span></span><span> </span><span id="local-6989586621679034437"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034437"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034438"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034438"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; m sep -&gt; m [a]
forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepEndBy1"><span class="hs-identifier hs-var">sepEndBy1</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034437"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034438"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">m [a] -&gt; m [a] -&gt; m [a]
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-273"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy"><span class="hs-pragma hs-type">sepEndBy</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span class="hs-comment">-- | @'sepEndBy1' p sep@ parses /one/ or more occurrences of @p@, separated</span><span>
</span><span id="line-276"></span><span class="hs-comment">-- and optionally ended by @sep@. Returns a list of values returned by @p@.</span><span>
</span><span id="line-277"></span><span id="local-6989586621679034439"><span id="local-6989586621679034440"><span id="local-6989586621679034441"><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy1"><span class="hs-identifier hs-type">sepEndBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034439"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034439"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034440"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034439"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034441"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034439"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679034440"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-278"></span><span id="sepEndBy1"><span class="annot"><span class="annottext">sepEndBy1 :: forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepEndBy1"><span class="hs-identifier hs-var hs-var">sepEndBy1</span></a></span></span><span> </span><span id="local-6989586621679034449"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034449"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034450"><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034450"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; [a] -&gt; [a]) -&gt; m a -&gt; m [a] -&gt; m [a]
forall a b c. (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034449"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034450"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">m sep -&gt; m [a] -&gt; m [a]
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m sep -&gt; m [a]
forall (m :: * -&gt; *) a sep. Alternative m =&gt; m a -&gt; m sep -&gt; m [a]
</span><a href="Control.Applicative.Combinators.html#sepEndBy"><span class="hs-identifier hs-var">sepEndBy</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034449"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m sep
</span><a href="#local-6989586621679034450"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m [a] -&gt; m [a] -&gt; m [a]
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; m [a]
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-279"></span><span class="hs-pragma">{-# INLINEABLE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#sepEndBy1"><span class="hs-pragma hs-type">sepEndBy1</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">-- | @'skipMany' p@ applies the parser @p@ /zero/ or more times, skipping</span><span>
</span><span id="line-282"></span><span class="hs-comment">-- its result.</span><span>
</span><span id="line-283"></span><span class="hs-comment">--</span><span>
</span><span id="line-284"></span><span class="hs-comment">-- See also: 'manyTill', 'skipManyTill'.</span><span>
</span><span id="line-285"></span><span id="local-6989586621679034222"><span id="local-6989586621679034223"><span class="annot"><a href="Control.Applicative.Combinators.html#skipMany"><span class="hs-identifier hs-type">skipMany</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034223"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034222"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-286"></span><span id="skipMany"><span class="annot"><span class="annottext">skipMany :: forall (m :: * -&gt; *) a. Alternative m =&gt; m a -&gt; m ()
</span><a href="Control.Applicative.Combinators.html#skipMany"><span class="hs-identifier hs-var hs-var">skipMany</span></a></span></span><span> </span><span id="local-6989586621679034454"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034454"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679034455"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-287"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-288"></span><span>    </span><span id="local-6989586621679034455"><span class="annot"><span class="annottext">go :: m ()
</span><a href="#local-6989586621679034455"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034454"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m () -&gt; m ()
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679034455"><span class="hs-identifier hs-var">go</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m () -&gt; m () -&gt; m ()
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">() -&gt; m ()
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipMany"><span class="hs-pragma hs-type">skipMany</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span class="hs-comment">-- | @'skipSome' p@ applies the parser @p@ /one/ or more times, skipping its</span><span>
</span><span id="line-292"></span><span class="hs-comment">-- result.</span><span>
</span><span id="line-293"></span><span class="hs-comment">--</span><span>
</span><span id="line-294"></span><span class="hs-comment">-- See also: 'someTill', 'skipSomeTill'.</span><span>
</span><span id="line-295"></span><span id="local-6989586621679034462"><span id="local-6989586621679034463"><span class="annot"><a href="Control.Applicative.Combinators.html#skipSome"><span class="hs-identifier hs-type">skipSome</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034462"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034462"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034463"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034462"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-296"></span><span id="skipSome"><span class="annot"><span class="annottext">skipSome :: forall (m :: * -&gt; *) a. Alternative m =&gt; m a -&gt; m ()
</span><a href="Control.Applicative.Combinators.html#skipSome"><span class="hs-identifier hs-var hs-var">skipSome</span></a></span></span><span> </span><span id="local-6989586621679034468"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034468"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034468"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m () -&gt; m ()
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m ()
forall (m :: * -&gt; *) a. Alternative m =&gt; m a -&gt; m ()
</span><a href="Control.Applicative.Combinators.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034468"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-297"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipSome"><span class="hs-pragma hs-type">skipSome</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-298"></span><span>
</span><span id="line-299"></span><span class="hs-comment">-- | @'skipCount' n p@ parses @n@ occurrences of @p@, skipping its result.</span><span>
</span><span id="line-300"></span><span class="hs-comment">-- If @n@ is not positive, the parser equals to @'pure' ()@.</span><span>
</span><span id="line-301"></span><span class="hs-comment">--</span><span>
</span><span id="line-302"></span><span class="hs-comment">-- &gt; skipCount = replicateM_</span><span>
</span><span id="line-303"></span><span class="hs-comment">--</span><span>
</span><span id="line-304"></span><span class="hs-comment">-- See also: 'count', 'count''.</span><span>
</span><span id="line-305"></span><span class="hs-comment">--</span><span>
</span><span id="line-306"></span><span class="hs-comment">-- @since 0.3.0</span><span>
</span><span id="line-307"></span><span id="local-6989586621679034228"><span id="local-6989586621679034229"><span class="annot"><a href="Control.Applicative.Combinators.html#skipCount"><span class="hs-identifier hs-type">skipCount</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034228"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034228"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034229"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034228"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-308"></span><span id="skipCount"><span class="annot"><span class="annottext">skipCount :: forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m ()
</span><a href="Control.Applicative.Combinators.html#skipCount"><span class="hs-identifier hs-var hs-var">skipCount</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; m a -&gt; m ()
forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m ()
</span><span class="hs-identifier hs-var">replicateM_</span></span><span>
</span><span id="line-309"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipCount"><span class="hs-pragma hs-type">skipCount</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span class="hs-comment">-- | @'skipManyTill' p end@ applies the parser @p@ /zero/ or more times</span><span>
</span><span id="line-312"></span><span class="hs-comment">-- skipping results until parser @end@ succeeds. Result parsed by @end@ is</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- then returned.</span><span>
</span><span id="line-314"></span><span class="hs-comment">--</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- See also: 'manyTill', 'skipMany'.</span><span>
</span><span id="line-316"></span><span id="local-6989586621679034232"><span id="local-6989586621679034233"><span id="local-6989586621679034234"><span class="annot"><a href="Control.Applicative.Combinators.html#skipManyTill"><span class="hs-identifier hs-type">skipManyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034232"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034232"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034233"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034232"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034234"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034232"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034234"><span class="hs-identifier hs-type">end</span></a></span></span></span></span><span>
</span><span id="line-317"></span><span id="skipManyTill"><span class="annot"><span class="annottext">skipManyTill :: forall (m :: * -&gt; *) a end. Alternative m =&gt; m a -&gt; m end -&gt; m end
</span><a href="Control.Applicative.Combinators.html#skipManyTill"><span class="hs-identifier hs-var hs-var">skipManyTill</span></a></span></span><span> </span><span id="local-6989586621679034474"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034474"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034475"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034475"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034476"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-318"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-319"></span><span>    </span><span id="local-6989586621679034476"><span class="annot"><span class="annottext">go :: m end
</span><a href="#local-6989586621679034476"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034475"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">m end -&gt; m end -&gt; m end
forall a. m a -&gt; m a -&gt; m a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034474"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m end -&gt; m end
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034476"><span class="hs-identifier hs-var">go</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-320"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipManyTill"><span class="hs-pragma hs-type">skipManyTill</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span class="hs-comment">-- | @'skipSomeTill' p end@ applies the parser @p@ /one/ or more times</span><span>
</span><span id="line-323"></span><span class="hs-comment">-- skipping results until parser @end@ succeeds. Result parsed by @end@ is</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- then returned.</span><span>
</span><span id="line-325"></span><span class="hs-comment">--</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- See also: 'someTill', 'skipSome'.</span><span>
</span><span id="line-327"></span><span id="local-6989586621679034482"><span id="local-6989586621679034483"><span id="local-6989586621679034484"><span class="annot"><a href="Control.Applicative.Combinators.html#skipSomeTill"><span class="hs-identifier hs-type">skipSomeTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Alternative</span></span><span> </span><span class="annot"><a href="#local-6989586621679034482"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034482"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034483"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034482"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034484"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679034482"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679034484"><span class="hs-identifier hs-type">end</span></a></span></span></span></span><span>
</span><span id="line-328"></span><span id="skipSomeTill"><span class="annot"><span class="annottext">skipSomeTill :: forall (m :: * -&gt; *) a end. Alternative m =&gt; m a -&gt; m end -&gt; m end
</span><a href="Control.Applicative.Combinators.html#skipSomeTill"><span class="hs-identifier hs-var hs-var">skipSomeTill</span></a></span></span><span> </span><span id="local-6989586621679034489"><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034489"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679034490"><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034490"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034489"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m end -&gt; m end
forall a b. m a -&gt; m b -&gt; m b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">m a -&gt; m end -&gt; m end
forall (m :: * -&gt; *) a end. Alternative m =&gt; m a -&gt; m end -&gt; m end
</span><a href="Control.Applicative.Combinators.html#skipManyTill"><span class="hs-identifier hs-var">skipManyTill</span></a></span><span> </span><span class="annot"><span class="annottext">m a
</span><a href="#local-6989586621679034489"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">m end
</span><a href="#local-6989586621679034490"><span class="hs-identifier hs-var">end</span></a></span><span>
</span><span id="line-329"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Control.Applicative.Combinators.html#skipSomeTill"><span class="hs-pragma hs-type">skipSomeTill</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-330"></span></pre></body></html>