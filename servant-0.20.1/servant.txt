-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A family of combinators for defining webservices APIs
--   
--   A family of combinators for defining webservices APIs and serving them
--   
--   You can learn about the basics in the <a>tutorial</a>.
--   
--   <a>CHANGELOG</a>
@package servant
@version 0.20.1

module Servant.API.Alternative

-- | Union of two APIs, first takes precedence in case of overlap.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--          :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] () -- POST /books
--   :}
--   </pre>
data a :<|> b
(:<|>) :: a -> b -> (:<|>) a b
infixr 3 :<|>
infixr 3 :<|>
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (a Servant.API.Alternative.:<|> b)
instance Data.Foldable.Foldable ((Servant.API.Alternative.:<|>) a)
instance Data.Traversable.Traversable ((Servant.API.Alternative.:<|>) a)
instance GHC.Base.Functor ((Servant.API.Alternative.:<|>) a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a Servant.API.Alternative.:<|> b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a Servant.API.Alternative.:<|> b)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (a Servant.API.Alternative.:<|> b)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (a Servant.API.Alternative.:<|> b)
instance Data.Bifoldable.Bifoldable (Servant.API.Alternative.:<|>)
instance Data.Bifunctor.Bifunctor (Servant.API.Alternative.:<|>)
instance Data.Biapplicative.Biapplicative (Servant.API.Alternative.:<|>)
instance Data.Bitraversable.Bitraversable (Servant.API.Alternative.:<|>)

module Servant.API.BasicAuth

-- | Combinator for <a>Basic Access Authentication</a>.
--   
--   <ul>
--   <li>IMPORTANT*: Only use Basic Auth over HTTPS! Credentials are not
--   hashed or encrypted. Note also that because the same credentials are
--   sent on every request, Basic Auth is not as secure as some
--   alternatives. Further, the implementation in servant-server does not
--   protect against some types of timing attacks.</li>
--   </ul>
--   
--   In Basic Auth, username and password are base64-encoded and
--   transmitted via the <tt>Authorization</tt> header. Handshakes are not
--   required, making it relatively efficient.
data BasicAuth (realm :: Symbol) (userData :: *)

-- | A simple datatype to hold data required to decorate a request
data BasicAuthData
BasicAuthData :: !ByteString -> !ByteString -> BasicAuthData
[basicAuthUsername] :: BasicAuthData -> !ByteString
[basicAuthPassword] :: BasicAuthData -> !ByteString

module Servant.API.Capture

-- | Capture a value from the request path under a certain type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /books/:isbn
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
type Capture = Capture' '[]

-- | <a>Capture</a> which can be modified. For example with
--   <tt>Description</tt>.
data Capture' (mods :: [*]) (sym :: Symbol) (a :: *)

-- | Capture all remaining values from the request path under a certain
--   type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /src/*
--   
--   &gt;&gt;&gt; type MyAPI = "src" :&gt; CaptureAll "segments" Text :&gt; Get '[JSON] SourceFile
--   </pre>
data CaptureAll (sym :: Symbol) (a :: *)


-- | A collection of basic Content-Types (also known as Internet Media
--   Types, or MIME types). Additionally, this module provides classes that
--   encapsulate how to serialize or deserialize values to or from a
--   particular Content-Type.
--   
--   Content-Types are used in <tt>ReqBody</tt> and the method combinators:
--   
--   <pre>
--   &gt;&gt;&gt; type MyEndpoint = ReqBody '[JSON, PlainText] Book :&gt; Put '[JSON, PlainText] Book
--   </pre>
--   
--   Meaning the endpoint accepts requests of Content-Type
--   <tt>application/json</tt> or <tt>text/plain;charset-utf8</tt>, and
--   returns data in either one of those formats (depending on the
--   <tt>Accept</tt> header).
--   
--   If you would like to support Content-Types beyond those provided here,
--   then:
--   
--   <ol>
--   <li>Declare a new data type with no constructors (e.g. <tt>data
--   HTML</tt>).</li>
--   <li>Make an instance of it for <a>Accept</a>.</li>
--   <li>If you want to be able to serialize data *into* that Content-Type,
--   make an instance of it for <a>MimeRender</a>.</li>
--   <li>If you want to be able to deserialize data *from* that
--   Content-Type, make an instance of it for <a>MimeUnrender</a>.</li>
--   </ol>
--   
--   Note that roles are reversed in <tt>servant-server</tt> and
--   <tt>servant-client</tt>: to be able to serve (or even typecheck) a
--   <tt>Get '[JSON, XML] MyData</tt>, you'll need to have the appropriate
--   <a>MimeRender</a> instances in scope, whereas to query that endpoint
--   with <tt>servant-client</tt>, you'll need a <a>MimeUnrender</a>
--   instance in scope.
module Servant.API.ContentTypes
data JSON
data PlainText
data FormUrlEncoded
data OctetStream

-- | Instances of <a>Accept</a> represent mimetypes. They are used for
--   matching against the <tt>Accept</tt> HTTP header of the request, and
--   for setting the <tt>Content-Type</tt> header of the response
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media ((//), (/:))
--   
--   &gt;&gt;&gt; data HTML
--   
--   &gt;&gt;&gt; :{
--   instance Accept HTML where
--      contentType _ = "text" // "html" /: ("charset", "utf-8")
--   :}
--   </pre>
class Accept ctype
contentType :: Accept ctype => Proxy ctype -> MediaType
contentTypes :: Accept ctype => Proxy ctype -> NonEmpty MediaType

-- | Instantiate this class to register a way of serializing a type based
--   on the <tt>Accept</tt> header.
--   
--   Example:
--   
--   <pre>
--   data MyContentType
--   
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   
--   instance Show a =&gt; MimeRender MyContentType a where
--      mimeRender _ val = pack ("This is MINE! " ++ show val)
--   
--   type MyAPI = "path" :&gt; Get '[MyContentType] Int
--   </pre>
class Accept ctype => MimeRender ctype a
mimeRender :: MimeRender ctype a => Proxy ctype -> a -> ByteString

-- | Instantiate this class to register a way of deserializing a type based
--   on the request's <tt>Content-Type</tt> header.
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media hiding (Accept)
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BSC
--   
--   &gt;&gt;&gt; data MyContentType = MyContentType String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Read a =&gt; MimeUnrender MyContentType a where
--      mimeUnrender _ bs = case BSC.take 12 bs of
--        "MyContentType" -&gt; return . read . BSC.unpack $ BSC.drop 12 bs
--        _ -&gt; Left "didn't start with the magic incantation"
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type MyAPI = "path" :&gt; ReqBody '[MyContentType] Int :&gt; Get '[JSON] Int
--   </pre>
class Accept ctype => MimeUnrender ctype a
mimeUnrender :: MimeUnrender ctype a => Proxy ctype -> ByteString -> Either String a

-- | Variant which is given the actual <a>MediaType</a> provided by the
--   other party.
--   
--   In the most cases you don't want to branch based on the
--   <a>MediaType</a>. See <a>pr552</a> for a motivating example.
mimeUnrenderWithType :: MimeUnrender ctype a => Proxy ctype -> MediaType -> ByteString -> Either String a

-- | A type for responses without content-body.
data NoContent
NoContent :: NoContent
newtype AcceptHeader
AcceptHeader :: ByteString -> AcceptHeader
class (AllMime list) => AllCTRender (list :: [*]) a
handleAcceptH :: AllCTRender list a => Proxy list -> AcceptHeader -> a -> Maybe (ByteString, ByteString)
class AllCTUnrender (list :: [*]) a
canHandleCTypeH :: AllCTUnrender list a => Proxy list -> ByteString -> Maybe (ByteString -> Either String a)
handleCTypeH :: AllCTUnrender list a => Proxy list -> ByteString -> ByteString -> Maybe (Either String a)
class AllMime (list :: [*])
allMime :: AllMime list => Proxy list -> [MediaType]
class (AllMime list) => AllMimeRender (list :: [*]) a
allMimeRender :: AllMimeRender list a => Proxy list -> a -> [(MediaType, ByteString)]
class (AllMime list) => AllMimeUnrender (list :: [*]) a
allMimeUnrender :: AllMimeUnrender list a => Proxy list -> [(MediaType, ByteString -> Either String a)]

-- | Deprecated: since aeson version 0.9 <a>eitherDecode</a> has lenient
--   behavior.

-- | <i>Deprecated: use eitherDecode instead</i>
eitherDecodeLenient :: FromJSON a => ByteString -> Either String a
canHandleAcceptH :: AllMime list => Proxy list -> AcceptHeader -> Bool
instance GHC.Generics.Generic Servant.API.ContentTypes.AcceptHeader
instance GHC.Read.Read Servant.API.ContentTypes.AcceptHeader
instance GHC.Show.Show Servant.API.ContentTypes.AcceptHeader
instance GHC.Classes.Eq Servant.API.ContentTypes.AcceptHeader
instance GHC.Generics.Generic Servant.API.ContentTypes.NoContent
instance GHC.Read.Read Servant.API.ContentTypes.NoContent
instance GHC.Classes.Eq Servant.API.ContentTypes.NoContent
instance GHC.Show.Show Servant.API.ContentTypes.NoContent
instance Servant.API.ContentTypes.Accept ctyp => Servant.API.ContentTypes.AllMimeRender '[ctyp] Servant.API.ContentTypes.NoContent
instance Servant.API.ContentTypes.AllMime (ctyp : ctyp' : ctyps) => Servant.API.ContentTypes.AllMimeRender (ctyp : ctyp' : ctyps) Servant.API.ContentTypes.NoContent
instance Control.DeepSeq.NFData Servant.API.ContentTypes.NoContent
instance Servant.API.ContentTypes.AllMimeUnrender ctyps a => Servant.API.ContentTypes.AllCTUnrender ctyps a
instance Servant.API.ContentTypes.AllMimeUnrender '[] a
instance (Servant.API.ContentTypes.MimeUnrender ctyp a, Servant.API.ContentTypes.AllMimeUnrender ctyps a) => Servant.API.ContentTypes.AllMimeUnrender (ctyp : ctyps) a
instance (Servant.API.ContentTypes.Accept ct, Servant.API.ContentTypes.AllMime cts, Servant.API.ContentTypes.AllMimeRender (ct : cts) a) => Servant.API.ContentTypes.AllCTRender (ct : cts) a
instance Servant.API.ContentTypes.MimeRender ctyp a => Servant.API.ContentTypes.AllMimeRender '[ctyp] a
instance (Servant.API.ContentTypes.MimeRender ctyp a, Servant.API.ContentTypes.AllMimeRender (ctyp' : ctyps) a) => Servant.API.ContentTypes.AllMimeRender (ctyp : ctyp' : ctyps) a
instance (TypeError ...) => Servant.API.ContentTypes.AllCTRender '[] ()
instance Servant.API.ContentTypes.AllMime '[]
instance (Servant.API.ContentTypes.Accept ctyp, Servant.API.ContentTypes.AllMime ctyps) => Servant.API.ContentTypes.AllMime (ctyp : ctyps)
instance Data.Aeson.Types.FromJSON.FromJSON a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.JSON a
instance Web.Internal.FormUrlEncoded.FromForm a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.FormUrlEncoded a
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Data.Text.Internal.Lazy.Text
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText Data.Text.Internal.Text
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText GHC.Base.String
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream Data.ByteString.Lazy.Internal.ByteString
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream Data.ByteString.Internal.Type.ByteString
instance Data.Aeson.Types.ToJSON.ToJSON a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.JSON a
instance Web.Internal.FormUrlEncoded.ToForm a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.FormUrlEncoded a
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Data.Text.Internal.Lazy.Text
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText Data.Text.Internal.Text
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText GHC.Base.String
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Data.ByteString.Lazy.Internal.ByteString
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Data.ByteString.Internal.Type.ByteString
instance Servant.API.ContentTypes.Accept Servant.API.ContentTypes.JSON
instance Servant.API.ContentTypes.Accept Servant.API.ContentTypes.FormUrlEncoded
instance Servant.API.ContentTypes.Accept Servant.API.ContentTypes.PlainText
instance Servant.API.ContentTypes.Accept Servant.API.ContentTypes.OctetStream

module Servant.API.Description

-- | Add more verbose description for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = Description
--    "This comment is visible in multiple Servant interpretations \
--    \and can be really long if necessary. \
--    \Haskell multiline String support is not perfect \
--    \but it's still very readable."
--   :&gt; Get '[JSON] Book
--   :}
--   </pre>
data Description (sym :: Symbol)

-- | Add a short summary for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; type MyApi = Summary "Get book by ISBN." :&gt; "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
data Summary (sym :: Symbol)

-- | Fold list of modifiers to extract description as a type-level String.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldDescription '[]
--   FoldDescription '[] :: Symbol
--   = ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldDescription '[Required, Description "foobar", Lenient]
--   FoldDescription '[Required, Description "foobar", Lenient] :: Symbol
--   = "foobar"
--   </pre>
type FoldDescription mods = FoldDescription' "" mods

-- | Implementation of <a>FoldDescription</a>.
type family FoldDescription' (acc :: Symbol) (mods :: [*]) :: Symbol

-- | Reflect description to the term level.
--   
--   <pre>
--   &gt;&gt;&gt; reflectDescription (Proxy :: Proxy '[Required, Description "foobar", Lenient])
--   "foobar"
--   </pre>
reflectDescription :: forall mods. KnownSymbol (FoldDescription mods) => Proxy mods -> String

module Servant.API.Empty

-- | An empty API: one which serves nothing. Morally speaking, this should
--   be the unit of <tt>:&lt;|&gt;</tt>. Implementors of interpretations of
--   API types should treat <a>EmptyAPI</a> as close to the unit as
--   possible.
data EmptyAPI
EmptyAPI :: EmptyAPI
instance GHC.Enum.Enum Servant.API.Empty.EmptyAPI
instance GHC.Enum.Bounded Servant.API.Empty.EmptyAPI
instance GHC.Show.Show Servant.API.Empty.EmptyAPI
instance GHC.Classes.Eq Servant.API.Empty.EmptyAPI

module Servant.API.Experimental.Auth

-- | A generalized Authentication combinator. Use this if you have a
--   non-standard authentication technique.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE.
data AuthProtect (tag :: k)

module Servant.API.Fragment

-- | Document the URI fragment in API. Useful in combination with
--   <tt>Link</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /post#TRACKING
--   
--   &gt;&gt;&gt; type MyApi = "post" :&gt; Fragment Text :&gt; Get '[JSON] Tracking
--   </pre>
data Fragment (a :: *)


-- | Define servant servers from record types. Generics for the win.
--   
--   The usage is simple, if you only need a collection of routes. First
--   you define a record with field types prefixed by a parameter
--   <tt>route</tt>:
--   
--   <pre>
--   data Routes route = Routes
--       { _get :: route :- Capture "id" Int :&gt; Get '[JSON] String
--       , _put :: route :- ReqBody '[JSON] Int :&gt; Put '[JSON] Bool
--       }
--     deriving (<a>Generic</a>)
--   </pre>
--   
--   You can get a <a>Proxy</a> of the server using
--   
--   <pre>
--   api :: Proxy (ToServantApi Routes)
--   api = genericApi (Proxy :: Proxy Routes)
--   </pre>
--   
--   Using <a>genericApi</a> is better as it checks that instances exists,
--   i.e. you get better error messages than simply using <a>Proxy</a>
--   value.
--   
--   <b>Note:</b> in 0.14 series this module isn't re-exported from
--   <a>API</a>.
--   
--   <a>Servant.API.Generic</a> is based on <tt>servant-generic</tt>
--   package by <a>Patrick Chilton</a>
module Servant.API.Generic

-- | A class with a type family that applies an appropriate type family to
--   the <tt>api</tt> parameter. For example, <a>AsApi</a> will leave
--   <tt>api</tt> untouched, while <tt><tt>AsServerT</tt> m</tt> will
--   produce <tt><tt>ServerT</tt> api m</tt>.
class GenericMode mode where {
    type mode :- api :: *;
}
infixl 0 :-

-- | A constraint alias, for work with <tt>mode</tt> and <tt>routes</tt>.
type GenericServant routes mode = (GenericMode mode, Generic (routes mode), GServantProduct (Rep (routes mode)))

-- | Turns a generic product type into a tree of <a>:&lt;|&gt;</a>
--   combinators.
type ToServant routes mode = GToServant (Rep (routes mode))

-- | See <a>ToServant</a>, but at value-level.
toServant :: GenericServant routes mode => routes mode -> ToServant routes mode

-- | Inverse of <a>toServant</a>.
--   
--   This can be used to turn <tt>generated</tt> values such as client
--   functions into records.
--   
--   You may need to provide a type signature for the <i>output</i> type
--   (your record type).
fromServant :: GenericServant routes mode => ToServant routes mode -> routes mode

-- | A type that specifies that an API record contains an API definition.
--   Only useful at type-level.
data AsApi
type ToServantApi routes = ToServant routes AsApi

-- | Get a <a>Proxy</a> of an API type.
genericApi :: GenericServant routes AsApi => Proxy routes -> Proxy (ToServantApi routes)
class GServantProduct f

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class () => Generic a where {
    
    -- | Generic representation type
    type family Rep a :: Type -> Type;
}
instance Servant.API.Generic.GServantProduct f => Servant.API.Generic.GServantProduct (GHC.Generics.M1 i c f)
instance (Servant.API.Generic.GServantProduct l, Servant.API.Generic.GServantProduct r) => Servant.API.Generic.GServantProduct (l GHC.Generics.:*: r)
instance Servant.API.Generic.GServantProduct (GHC.Generics.K1 i c)
instance Servant.API.Generic.GenericMode Servant.API.Generic.AsApi

module Servant.API.HttpVersion

-- | HTTP Version.
--   
--   Note that the <a>Show</a> instance is intended merely for debugging.
data () => HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

module Servant.API.IsSecure

-- | Was this request made over an SSL connection?
--   
--   Note that this value will not tell you if the client originally made
--   this request over SSL, but rather whether the current connection is
--   SSL. The distinction lies with reverse proxies. In many cases, the
--   client will connect to a load balancer over SSL, but connect to the
--   WAI handler without SSL. In such a case, the handlers would get
--   <a>NotSecure</a>, but from a user perspective, there is a secure
--   connection.
data IsSecure

-- | the connection to the server is secure (HTTPS)
Secure :: IsSecure

-- | the connection to the server is not secure (HTTP)
NotSecure :: IsSecure
instance GHC.Classes.Ord Servant.API.IsSecure.IsSecure
instance GHC.Generics.Generic Servant.API.IsSecure.IsSecure
instance GHC.Read.Read Servant.API.IsSecure.IsSecure
instance GHC.Show.Show Servant.API.IsSecure.IsSecure
instance GHC.Classes.Eq Servant.API.IsSecure.IsSecure

module Servant.API.Modifiers

-- | Required argument. Not wrapped.
data Required

-- | Optional argument. Wrapped in <a>Maybe</a>.
data Optional

-- | Fold modifier list to decide whether argument is required.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldRequired '[Required, Description "something"]
--   FoldRequired '[Required, Description "something"] :: Bool
--   = 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldRequired '[Required, Optional]
--   FoldRequired '[Required, Optional] :: Bool
--   = 'False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldRequired '[]
--   FoldRequired '[] :: Bool
--   = 'False
--   </pre>
type FoldRequired mods = FoldRequired' 'False mods

-- | Implementation of <a>FoldRequired</a>.
type family FoldRequired' (acc :: Bool) (mods :: [*]) :: Bool

-- | Leniently parsed argument, i.e. parsing never fail. Wrapped in
--   <tt><a>Either</a> <a>Text</a></tt>.
data Lenient

-- | Strictly parsed argument. Not wrapped.
data Strict

-- | Fold modifier list to decide whether argument should be parsed
--   strictly or leniently.
--   
--   <pre>
--   &gt;&gt;&gt; :kind! FoldLenient '[]
--   FoldLenient '[] :: Bool
--   = 'False
--   </pre>
type FoldLenient mods = FoldLenient' 'False mods

-- | Implementation of <a>FoldLenient</a>.
type family FoldLenient' (acc :: Bool) (mods :: [*]) :: Bool

-- | Helper type alias.
--   
--   <ul>
--   <li><a>Required</a> ↦ <tt>a</tt></li>
--   <li><a>Optional</a> ↦ <tt><a>Maybe</a> a</tt></li>
--   </ul>
type RequiredArgument mods a = If (FoldRequired mods) a (Maybe a)

-- | Fold a <tt>RequiredAgument</tt> into a value
foldRequiredArgument :: forall mods a r. SBoolI (FoldRequired mods) => Proxy mods -> (a -> r) -> (Maybe a -> r) -> RequiredArgument mods a -> r

-- | Unfold a value into a <a>RequiredArgument</a>.
unfoldRequiredArgument :: forall mods m a. (Monad m, SBoolI (FoldRequired mods), SBoolI (FoldLenient mods)) => Proxy mods -> m (RequiredArgument mods a) -> (Text -> m (RequiredArgument mods a)) -> Maybe (Either Text a) -> m (RequiredArgument mods a)

-- | Helper type alias.
--   
--   By default argument is <a>Optional</a> and <a>Strict</a>.
--   
--   <ul>
--   <li><a>Required</a>, <a>Strict</a> ↦ <tt>a</tt></li>
--   <li><a>Required</a>, <a>Lenient</a> ↦ <tt><a>Either</a> <a>Text</a>
--   a</tt></li>
--   <li><a>Optional</a>, <a>Strict</a> ↦ <tt><a>Maybe</a> a</tt></li>
--   <li><a>Optional</a>, <a>Lenient</a> ↦ <tt><a>Maybe</a> (<a>Either</a>
--   <a>Text</a> a)</tt></li>
--   </ul>
type RequestArgument mods a = If (FoldRequired mods) (If (FoldLenient mods) (Either Text a) a) (Maybe (If (FoldLenient mods) (Either Text a) a))

-- | Unfold a value into a <a>RequestArgument</a>.
unfoldRequestArgument :: forall mods m a. (Monad m, SBoolI (FoldRequired mods), SBoolI (FoldLenient mods)) => Proxy mods -> m (RequestArgument mods a) -> (Text -> m (RequestArgument mods a)) -> Maybe (Either Text a) -> m (RequestArgument mods a)

module Servant.API.Header

-- | Extract the given header's value as a value of type <tt>a</tt>. I.e.
--   header sent by client, parsed by server.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; newtype Referer = Referer Text deriving (Eq, Show)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; -- GET /view-my-referer
--   
--   &gt;&gt;&gt; type MyApi = "view-my-referer" :&gt; Header "from" Referer :&gt; Get '[JSON] Referer
--   </pre>
type Header = Header' '[Optional, Strict]
data Header' (mods :: [*]) (sym :: Symbol) (a :: *)

module Servant.API.NamedRoutes

-- | Combinator for embedding a record of named routes into a Servant API
--   type.
data NamedRoutes (api :: * -> *)

module Servant.API.QueryParam

-- | Lookup a potentially value-less query string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?published
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get '[JSON] [Book]
--   </pre>
data QueryFlag (sym :: Symbol)

-- | Lookup the value associated to the <tt>sym</tt> query string parameter
--   and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?author=&lt;author name&gt;
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get '[JSON] [Book]
--   </pre>
type QueryParam = QueryParam' '[Optional, Strict]

-- | <a>QueryParam</a> which can be <a>Required</a>, <a>Lenient</a>, or
--   modified otherwise.
data QueryParam' (mods :: [*]) (sym :: Symbol) (a :: *)

-- | Lookup the values associated to the <tt>sym</tt> query string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support query string parameters of the form
--   <tt>param[]=val1&amp;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1&amp;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?authors[]=&lt;author1&gt;&amp;authors[]=&lt;author2&gt;&amp;...
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get '[JSON] [Book]
--   </pre>
data QueryParams (sym :: Symbol) (a :: *)

module Servant.API.Raw

-- | Endpoint for plugging in your own Wai <tt>Application</tt>s.
--   
--   The given <tt>Application</tt> will get the request as received by the
--   server, potentially with a modified (stripped) <tt>pathInfo</tt> if
--   the <tt>Application</tt> is being routed with <a>:&gt;</a>.
--   
--   In addition to just letting you plug in your existing WAI
--   <tt>Application</tt>s, this can also be used with functions from
--   <a>Servant.Server.StaticFiles</a> to serve static files stored in a
--   particular directory on your filesystem
data Raw

-- | Variant of <a>Raw</a> that lets you access the underlying monadic
--   context to process the request.
data RawM

module Servant.API.RemoteHost

-- | Provides access to the host or IP address from which the HTTP request
--   was sent.
data RemoteHost

module Servant.API.ReqBody

-- | Extract the request body as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- POST /books
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   </pre>
type ReqBody = ReqBody' '[Required, Strict]

-- | <i>Note:</i> <a>ReqBody'</a> is always <a>Required</a>.
data ReqBody' (mods :: [*]) (contentTypes :: [*]) (a :: *)

module Servant.API.Status

-- | Retrieve a known or unknown Status from a KnownNat
statusFromNat :: forall a proxy. KnownNat a => proxy a -> Status

-- | Witness that a type-level natural number corresponds to a HTTP status
--   code
class KnownNat n => KnownStatus n
statusVal :: KnownStatus n => proxy n -> Status
instance Servant.API.Status.KnownStatus 100
instance Servant.API.Status.KnownStatus 101
instance Servant.API.Status.KnownStatus 200
instance Servant.API.Status.KnownStatus 201
instance Servant.API.Status.KnownStatus 202
instance Servant.API.Status.KnownStatus 203
instance Servant.API.Status.KnownStatus 204
instance Servant.API.Status.KnownStatus 205
instance Servant.API.Status.KnownStatus 206
instance Servant.API.Status.KnownStatus 300
instance Servant.API.Status.KnownStatus 301
instance Servant.API.Status.KnownStatus 302
instance Servant.API.Status.KnownStatus 303
instance Servant.API.Status.KnownStatus 304
instance Servant.API.Status.KnownStatus 305
instance Servant.API.Status.KnownStatus 307
instance Servant.API.Status.KnownStatus 308
instance Servant.API.Status.KnownStatus 400
instance Servant.API.Status.KnownStatus 401
instance Servant.API.Status.KnownStatus 402
instance Servant.API.Status.KnownStatus 403
instance Servant.API.Status.KnownStatus 404
instance Servant.API.Status.KnownStatus 405
instance Servant.API.Status.KnownStatus 406
instance Servant.API.Status.KnownStatus 407
instance Servant.API.Status.KnownStatus 408
instance Servant.API.Status.KnownStatus 409
instance Servant.API.Status.KnownStatus 410
instance Servant.API.Status.KnownStatus 411
instance Servant.API.Status.KnownStatus 412
instance Servant.API.Status.KnownStatus 413
instance Servant.API.Status.KnownStatus 414
instance Servant.API.Status.KnownStatus 415
instance Servant.API.Status.KnownStatus 416
instance Servant.API.Status.KnownStatus 417
instance Servant.API.Status.KnownStatus 418
instance Servant.API.Status.KnownStatus 422
instance Servant.API.Status.KnownStatus 426
instance Servant.API.Status.KnownStatus 428
instance Servant.API.Status.KnownStatus 429
instance Servant.API.Status.KnownStatus 431
instance Servant.API.Status.KnownStatus 500
instance Servant.API.Status.KnownStatus 501
instance Servant.API.Status.KnownStatus 502
instance Servant.API.Status.KnownStatus 503
instance Servant.API.Status.KnownStatus 504
instance Servant.API.Status.KnownStatus 505
instance Servant.API.Status.KnownStatus 511

module Servant.API.Sub

-- | The contained API (second argument) can be found under <tt>("/" ++
--   path)</tt> (path being the first argument).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /hello/world
--   
--   &gt;&gt;&gt; -- returning a JSON encoded World value
--   
--   &gt;&gt;&gt; type MyApi = "hello" :&gt; "world" :&gt; Get '[JSON] World
--   </pre>
data (path :: k) :> (a :: *)
infixr 4 :>


-- | This module defines the error messages used in type-level errors.
--   Type-level errors can signal non-existing instances, for instance when
--   a combinator is not applied to the correct number of arguments.
module Servant.API.TypeErrors

-- | No instance exists for <tt>tycls (expr :&gt; ...)</tt> because
--   <tt>expr</tt> is not fully saturated.
type PartialApplication (tycls :: k) (expr :: k') = NoInstanceForSub tycls expr :$$: ShowType expr :<>: Text " expects " :<>: ShowType (Arity expr) :<>: Text " more arguments"

-- | No instance exists for <tt>expr</tt>.
type NoInstanceFor (expr :: k) = Text "There is no instance for " :<>: ShowType expr

-- | No instance exists for <tt>tycls (expr :&gt; ...)</tt> because
--   <tt>expr</tt> is not recognised.
type NoInstanceForSub (tycls :: k) (expr :: k') = Text "There is no instance for " :<>: ShowType tycls :<>: Text " (" :<>: ShowType expr :<>: Text " :> ...)"
type ErrorIfNoGeneric routes = Break (NoGeneric routes :: Type) (Rep (routes ()))


-- | Type-level code for implementing and using <tt>UVerb</tt>. Heavily
--   inspired by <a>world-peace</a>.
module Servant.API.UVerb.Union
type IsMember (a :: u) (as :: [u]) = (Unique as, CheckElemIsMember a as, UElem a as)

-- | Check whether all values in a type-level list are distinct. This will
--   throw a nice error if there are any duplicate elements in the list.
type family Unique xs :: Constraint
type Union = NS I
inject :: UElem x xs => f x -> NS f xs
eject :: UElem x xs => NS f xs -> Maybe (f x)

-- | Convenience function to apply a function to an unknown union element
--   using a type class. All elements of the union must have instances in
--   the type class, and the function is applied unconditionally.
--   
--   See also: <a>matchUnion</a>.
foldMapUnion :: forall (c :: * -> Constraint) (a :: *) (as :: [*]). All c as => Proxy c -> (forall x. c x => x -> a) -> Union as -> a

-- | Convenience function to extract a union element using <tt>cast</tt>,
--   ie. return the value if the selected type happens to be the actual
--   type of the union in this value, or <a>Nothing</a> otherwise.
--   
--   See also: <a>foldMapUnion</a>.
matchUnion :: forall (a :: *) (as :: [*]). IsMember a as => Union as -> Maybe a
instance forall a (x :: a) (xs :: [a]). Servant.API.UVerb.Union.UElem x (x : xs)
instance forall a (x :: a) (xs :: [a]) (x' :: a). Servant.API.UVerb.Union.UElem x xs => Servant.API.UVerb.Union.UElem x (x' : xs)


-- | This module provides facilities for adding headers to a response.
--   
--   <pre>
--   &gt;&gt;&gt; let headerVal = addHeader "some-url" 5 :: Headers '[Header "Location" String] Int
--   </pre>
--   
--   The value is added to the header specified by the type
--   (<tt>Location</tt> in the example above).
module Servant.API.ResponseHeaders

-- | Response Header objects. You should never need to construct one
--   directly. Instead, use <a>addOptionalHeader</a>.
data Headers ls a
Headers :: a -> HList ls -> Headers ls a

-- | The underlying value of a <a>Headers</a>
[getResponse] :: Headers ls a -> a

-- | HList of headers.
[getHeadersHList] :: Headers ls a -> HList ls
data ResponseHeader (sym :: Symbol) a
Header :: a -> ResponseHeader (sym :: Symbol) a
MissingHeader :: ResponseHeader (sym :: Symbol) a
UndecodableHeader :: ByteString -> ResponseHeader (sym :: Symbol) a
class AddHeader h v orig new | h v orig -> new, new -> h, new -> v, new -> orig

-- | <tt>addHeader</tt> adds a header to a response. Note that it changes
--   the type of the value in the following ways:
--   
--   <ol>
--   <li>A simple value is wrapped in "Headers '[hdr]":</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example0 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; getHeaders example0
--   [("someheader","5")]
--   </pre>
--   
--   <ol>
--   <li>A value that already has a header has its new header *prepended*
--   to the existing list:</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example2
--   [("1st","true"),("someheader","5")]
--   </pre>
--   
--   Note that while in your handlers type annotations are not required,
--   since the type can be inferred from the API type, in other cases you
--   may find yourself needing to add annotations.
addHeader :: AddHeader h v orig new => v -> orig -> new

-- | Deliberately do not add a header to a value.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = noHeader "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example1
--   []
--   </pre>
noHeader :: AddHeader h v orig new => orig -> new
class HasResponseHeader h a headers

-- | Look up a specific ResponseHeader, without having to know what
--   position it is in the HList.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "someheader" Int
--   Header 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "1st" Bool
--   Header True
--   </pre>
--   
--   Usage of this function relies on an explicit type annotation of the
--   header to be looked up. This can be done with type annotations on the
--   result, or with an explicit type application. In this example, the
--   type of header value is determined by the type-inference, we only
--   specify the name of the header:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; case lookupResponseHeader @"1st" example2 of { Header b -&gt; b ; _ -&gt; False }
--   True
--   </pre>
lookupResponseHeader :: HasResponseHeader h a headers => Headers headers r -> ResponseHeader h a
class BuildHeadersTo hs
buildHeadersTo :: BuildHeadersTo hs => [Header] -> HList hs
class GetHeaders ls
getHeaders :: GetHeaders ls => ls -> [Header]

-- | Auxiliary class for <tt><a>GetHeaders</a> (<a>Headers</a> hs a)</tt>
--   instance
class GetHeaders' hs
type family HeaderValMap (f :: * -> *) (xs :: [*])
data HList a
[HNil] :: HList '[]
[HCons] :: ResponseHeader h x -> HList xs -> HList (Header h x ': xs)
instance GHC.Base.Functor (Servant.API.ResponseHeaders.ResponseHeader sym)
instance GHC.Show.Show a => GHC.Show.Show (Servant.API.ResponseHeaders.ResponseHeader sym a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Servant.API.ResponseHeaders.ResponseHeader sym a)
instance GHC.Base.Functor (Servant.API.ResponseHeaders.Headers ls)
instance Servant.API.ResponseHeaders.HasResponseHeader h a (Servant.API.Header.Header h a : rest)
instance Servant.API.ResponseHeaders.HasResponseHeader h a rest => Servant.API.ResponseHeaders.HasResponseHeader h a (first : rest)
instance (GHC.TypeLits.KnownSymbol h, Web.Internal.HttpApiData.ToHttpApiData v) => Servant.API.ResponseHeaders.AddHeader h v (Servant.API.ResponseHeaders.Headers (fst : rest) a) (Servant.API.ResponseHeaders.Headers (Servant.API.Header.Header h v : fst : rest) a)
instance (GHC.TypeLits.KnownSymbol h, Web.Internal.HttpApiData.ToHttpApiData v, new GHC.Types.~ Servant.API.ResponseHeaders.Headers '[Servant.API.Header.Header h v] a) => Servant.API.ResponseHeaders.AddHeader h v a new
instance Servant.API.ResponseHeaders.AddHeader h v old new => Servant.API.ResponseHeaders.AddHeader h v (Servant.API.UVerb.Union.Union '[old]) (Servant.API.UVerb.Union.Union '[new])
instance (Servant.API.ResponseHeaders.AddHeader h v old new, Servant.API.ResponseHeaders.AddHeader h v (Servant.API.UVerb.Union.Union oldrest) (Servant.API.UVerb.Union.Union newrest), oldrest GHC.Types.~ (a : as), newrest GHC.Types.~ (b : bs)) => Servant.API.ResponseHeaders.AddHeader h v (Servant.API.UVerb.Union.Union (old : a : as)) (Servant.API.UVerb.Union.Union (new : b : bs))
instance Servant.API.ResponseHeaders.GetHeaders' hs => Servant.API.ResponseHeaders.GetHeaders (Servant.API.ResponseHeaders.Headers hs a)
instance Servant.API.ResponseHeaders.GetHeaders' '[]
instance (GHC.TypeLits.KnownSymbol h, Servant.API.ResponseHeaders.GetHeadersFromHList rest, Web.Internal.HttpApiData.ToHttpApiData v) => Servant.API.ResponseHeaders.GetHeaders' (Servant.API.Header.Header h v : rest)
instance Servant.API.ResponseHeaders.GetHeadersFromHList hs => Servant.API.ResponseHeaders.GetHeaders (Servant.API.ResponseHeaders.HList hs)
instance Servant.API.ResponseHeaders.GetHeadersFromHList '[]
instance (GHC.TypeLits.KnownSymbol h, Web.Internal.HttpApiData.ToHttpApiData x, Servant.API.ResponseHeaders.GetHeadersFromHList xs) => Servant.API.ResponseHeaders.GetHeadersFromHList (Servant.API.Header.Header h x : xs)
instance Servant.API.ResponseHeaders.BuildHeadersTo '[]
instance (Web.Internal.HttpApiData.FromHttpApiData v, Servant.API.ResponseHeaders.BuildHeadersTo xs, GHC.TypeLits.KnownSymbol h) => Servant.API.ResponseHeaders.BuildHeadersTo (Servant.API.Header.Header h v : xs)
instance (Servant.API.ResponseHeaders.NFDataHList ls, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Servant.API.ResponseHeaders.Headers ls a)
instance Servant.API.ResponseHeaders.NFDataHList '[]
instance (y GHC.Types.~ Servant.API.Header.Header h x, Control.DeepSeq.NFData x, Servant.API.ResponseHeaders.NFDataHList xs) => Servant.API.ResponseHeaders.NFDataHList (y : xs)
instance Servant.API.ResponseHeaders.NFDataHList xs => Control.DeepSeq.NFData (Servant.API.ResponseHeaders.HList xs)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Servant.API.ResponseHeaders.ResponseHeader sym a)


-- | An alternative to <tt>Verb</tt> for end-points that respond with a
--   resource value of any of an open union of types, and specific status
--   codes for each type in this union. (<a>UVerb</a> is short for
--   <tt>UnionVerb</tt>)
--   
--   This can be used for returning (rather than throwing) exceptions in a
--   server as in, say <tt>'[Report, WaiError]</tt>; or responding with
--   either a 303 forward with a location header, or 201 created with a
--   different body type, depending on the circumstances. (All of this can
--   be done with vanilla servant-server by throwing exceptions, but it
--   can't be represented in the API types without something like
--   <a>UVerb</a>.)
--   
--   See
--   <a>https://docs.servant.dev/en/stable/cookbook/uverb/UVerb.html</a>
--   for a working example.
module Servant.API.UVerb

-- | A variant of <tt>Verb</tt> that can have any of a number of response
--   values and status codes.
--   
--   FUTUREWORK: it would be nice to make <tt>Verb</tt> a special case of
--   <a>UVerb</a>, and only write instances for <tt>HasServer</tt> etc. for
--   the latter, getting them for the former for free. Something like:
--   
--   <pre>
--   type Verb method statusCode contentTypes a = UVerb method contentTypes [WithStatus statusCode a]
--   </pre>
--   
--   Backwards compatibility is tricky, though: this type alias would mean
--   people would have to use <tt>respond</tt> instead of <a>pure</a> or
--   <a>return</a>, so all old handlers would have to be rewritten.
data UVerb (method :: StdMethod) (contentTypes :: [*]) (as :: [*])
class KnownStatus (StatusOf a) => HasStatus (a :: *) where {
    type StatusOf (a :: *) :: Nat;
}
statusOf :: forall a proxy. HasStatus a => proxy a -> Status
class HasStatuses (as :: [*]) where {
    type Statuses (as :: [*]) :: [Nat];
}
statuses :: HasStatuses as => Proxy as -> [Status]

-- | A simple newtype wrapper that pairs a type with its status code. It
--   implements all the content types that Servant ships with by default.
newtype WithStatus (k :: Nat) a
WithStatus :: a -> WithStatus (k :: Nat) a
instance GHC.Show.Show a => GHC.Show.Show (Servant.API.UVerb.WithStatus k a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Servant.API.UVerb.WithStatus k a)
instance Servant.API.Status.KnownStatus n => Servant.API.UVerb.HasStatus (Servant.API.UVerb.WithStatus n a)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.JSON a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.JSON (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.PlainText (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.FormUrlEncoded a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.FormUrlEncoded (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream a => Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.JSON a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.JSON (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.PlainText (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.FormUrlEncoded a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.FormUrlEncoded (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream a => Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream (Servant.API.UVerb.WithStatus _status a)
instance Servant.API.UVerb.HasStatuses '[]
instance (Servant.API.UVerb.HasStatus a, Servant.API.UVerb.HasStatuses as) => Servant.API.UVerb.HasStatuses (a : as)
instance Servant.API.UVerb.HasStatus Servant.API.ContentTypes.NoContent
instance Servant.API.UVerb.HasStatus a => Servant.API.UVerb.HasStatus (Servant.API.ResponseHeaders.Headers ls a)

module Servant.API.Vault

-- | A persistent store for values of arbitrary types.
--   
--   This variant is the simplest and creates keys in the <a>IO</a> monad.
--   See the module <a>Data.Vault.ST</a> if you want to use it with the
--   <a>ST</a> monad instead.
type Vault = Vault RealWorld

module Servant.API.Verbs

-- | <a>GET</a> with 200 status code.
type Get = Verb 'GET 200

-- | <a>PUT</a> with 200 status code.
type Put = Verb 'PUT 200

-- | <a>DELETE</a> with 200 status code.
type Delete = Verb 'DELETE 200

-- | <a>DELETE</a> with 202 status code.
type DeleteAccepted = Verb 'DELETE 202

-- | <a>DELETE</a> with 204 status code.
type DeleteNoContent = NoContentVerb 'DELETE

-- | <a>DELETE</a> with 203 status code.
type DeleteNonAuthoritative = Verb 'DELETE 203

-- | <a>GET</a> with 202 status code.
type GetAccepted = Verb 'GET 202

-- | <a>GET</a> with 204 status code.
type GetNoContent = NoContentVerb 'GET

-- | <a>GET</a> with 203 status code.
type GetNonAuthoritative = Verb 'GET 203

-- | <a>GET</a> with 206 status code.
type GetPartialContent = Verb 'GET 206

-- | <a>GET</a> with 205 status code.
type GetResetContent = Verb 'GET 205

-- | <tt>NoContentVerb</tt> is a specific type to represent
--   <tt>NoContent</tt> responses. It does not require either a list of
--   content types (because there's no content) or a status code (because
--   it should always be 204).
data NoContentVerb (method :: k1)

-- | <a>PATCH</a> with 200 status code.
type Patch = Verb 'PATCH 200

-- | <a>PATCH</a> with 202 status code.
type PatchAccepted = Verb 'PATCH 202

-- | <a>PATCH</a> with 204 status code.
type PatchNoContent = NoContentVerb 'PATCH

-- | <a>PATCH</a> with 203 status code.
type PatchNonAuthoritative = Verb 'PATCH 203

-- | <a>POST</a> with 200 status code.
type Post = Verb 'POST 200

-- | <a>POST</a> with 202 status code.
type PostAccepted = Verb 'POST 202

-- | <a>POST</a> with 201 status code.
type PostCreated = Verb 'POST 201

-- | <a>POST</a> with 204 status code.
type PostNoContent = NoContentVerb 'POST

-- | <a>POST</a> with 203 status code.
type PostNonAuthoritative = Verb 'POST 203

-- | <a>POST</a> with 205 status code.
type PostResetContent = Verb 'POST 205

-- | <a>PUT</a> with 202 status code.
type PutAccepted = Verb 'PUT 202

-- | <a>PUT</a> with 201 status code.
type PutCreated = Verb 'PUT 201

-- | <a>PUT</a> with 204 status code.
type PutNoContent = NoContentVerb 'PUT

-- | <a>PUT</a> with 203 status code.
type PutNonAuthoritative = Verb 'PUT 203
class ReflectMethod a
reflectMethod :: ReflectMethod a => Proxy a -> Method

-- | <tt>Verb</tt> is a general type for representing HTTP verbs (a.k.a.
--   methods). For convenience, type synonyms for each verb with a 200
--   response code are provided, but you are free to define your own:
--   
--   <pre>
--   &gt;&gt;&gt; type Post204 contentTypes a = Verb 'POST 204 contentTypes a
--   </pre>
data Verb (method :: k1) (statusCode :: Nat) (contentTypes :: [*]) (a :: *)

-- | <a>HEAD</a> with 204 status code.
type HeadNoContent = NoContentVerb 'HEAD

-- | <a>DELETE</a> with 205 status code.
type DeleteResetContent = Verb 'DELETE 205

-- | <a>PATCH</a> with 205 status code.
type PatchResetContent = Verb 'PATCH 205

-- | <a>PUT</a> with 205 status code.
type PutResetContent = Verb 'PUT 205

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data () => StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod

PATCH :: StdMethod
instance forall k1 (method :: k1) (statusCode :: GHC.TypeNats.Nat) (contentTypes :: [*]) a. GHC.Generics.Generic (Servant.API.Verbs.Verb method statusCode contentTypes a)
instance forall k1 (method :: k1). GHC.Generics.Generic (Servant.API.Verbs.NoContentVerb method)
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.GET
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.POST
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.PUT
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.DELETE
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.PATCH
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.HEAD
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.OPTIONS
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.TRACE
instance Servant.API.Verbs.ReflectMethod 'Network.HTTP.Types.Method.CONNECT


-- | This module collects utilities for manipulating <tt>servant</tt> API
--   types. The functionality in this module is for advanced usage.
--   
--   The code samples in this module use the following type synonym:
--   
--   <pre>
--   type SampleAPI = "hello" :&gt; Get '[JSON] Int
--               :&lt;|&gt; "bye" :&gt; Capture "name" String :&gt; Post '[JSON, PlainText] Bool
--   </pre>
module Servant.API.TypeLevel

-- | Flatten API into a list of endpoints.
--   
--   <pre>
--   &gt;&gt;&gt; Refl :: Endpoints SampleAPI :~: '["hello" :&gt; Verb 'GET 200 '[JSON] Int, "bye" :&gt; (Capture "name" String :&gt; Verb 'POST 200 '[JSON, PlainText] Bool)]
--   Refl
--   </pre>
type family Endpoints api

-- | You may use this type family to tell the type checker that your custom
--   type may be skipped as part of a link. This is useful for things like
--   <tt><a>QueryParam</a></tt> that are optional in a URI and do not
--   affect them if they are omitted.
--   
--   <pre>
--   &gt;&gt;&gt; data CustomThing
--   
--   &gt;&gt;&gt; type instance IsElem' e (CustomThing :&gt; s) = IsElem e s
--   </pre>
--   
--   Note that <tt><a>IsElem</a></tt> is called, which will mutually
--   recurse back to <tt><a>IsElem'</a></tt> if it exhausts all other
--   options again.
--   
--   Once you have written a <tt>HasLink</tt> instance for
--   <tt>CustomThing</tt> you are ready to go.
type family IsElem' a s :: Constraint

-- | Closed type family, check if <tt>endpoint</tt> is within <tt>api</tt>.
--   Uses <tt><a>IsElem'</a></tt> if it exhausts all other options.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("hello" :&gt; Get '[JSON] Int) SampleAPI))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("bye" :&gt; Get '[JSON] Int) SampleAPI))
--   ...
--   ... Could not ...
--   ...
--   </pre>
--   
--   An endpoint is considered within an api even if it is missing
--   combinators that don't affect the URL:
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (Header "h" Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (ReqBody '[JSON] Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <ul>
--   <li>N.B.:* <tt>IsElem a b</tt> can be seen as capturing the notion of
--   whether the URL represented by <tt>a</tt> would match the URL
--   represented by <tt>b</tt>, *not* whether a request represented by
--   <tt>a</tt> matches the endpoints serving <tt>b</tt> (for the latter,
--   use <a>IsIn</a>).</li>
--   </ul>
type family IsElem endpoint api :: Constraint

-- | Check whether <tt>sub</tt> is a sub-API of <tt>api</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsSubAPI SampleAPI (SampleAPI :&lt;|&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsSubAPI (SampleAPI :&lt;|&gt; Get '[JSON] Int) SampleAPI))
--   ...
--   ... Could not ...
--   ...
--   </pre>
--   
--   This uses <tt>IsElem</tt> for checking; thus the note there applies
--   here.
type family IsSubAPI sub api :: Constraint

-- | Check that every element of <tt>xs</tt> is an endpoint of <tt>api</tt>
--   (using <tt><a>IsElem</a></tt>).
type family AllIsElem xs api :: Constraint

-- | Closed type family, check if <tt>endpoint</tt> is exactly within
--   <tt>api</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsIn ("hello" :&gt; Get '[JSON] Int) SampleAPI))
--   OK
--   </pre>
--   
--   Unlike <a>IsElem</a>, this requires an *exact* match.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsIn (Get '[JSON] Int) (Header "h" Bool :&gt; Get '[JSON] Int)))
--   ...
--   ... Could not ...
--   ...
--   </pre>
type family IsIn (endpoint :: *) (api :: *) :: Constraint

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.
--   
--   Like <a>IsSubAPI</a>, but uses <a>IsIn</a> rather than <a>IsElem</a>.
type family IsStrictSubAPI sub api :: Constraint

-- | Check that every element of <tt>xs</tt> is an endpoint of <tt>api</tt>
--   (using <tt><a>IsIn</a></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (AllIsIn (Endpoints SampleAPI) SampleAPI))
--   OK
--   </pre>
type family AllIsIn xs api :: Constraint

-- | Apply <tt>(e :&gt;)</tt> to every API in <tt>xs</tt>.
type family MapSub e xs

-- | Append two type-level lists.
type family AppendList xs ys
type family IsSubList a b :: Constraint

-- | Check that a value is an element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (Elem Bool '[Int, Bool]))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (Elem String '[Int, Bool]))
--   ...
--   ... [Char]...'[Int, Bool...
--   ...
--   </pre>
type Elem e es = ElemGo e es es
type family ElemGo e es orig :: Constraint

-- | If either a or b produce an empty constraint, produce an empty
--   constraint.
type family Or (a :: Constraint) (b :: Constraint) :: Constraint

-- | If both a or b produce an empty constraint, produce an empty
--   constraint.
type family And (a :: Constraint) (b :: Constraint) :: Constraint
type family FragmentUnique api :: Constraint
class FragmentUnique api => AtLeastOneFragment api
instance forall k1 (m :: k1) (s :: GHC.TypeNats.Nat) (ct :: [*]) typ. Servant.API.TypeLevel.AtLeastOneFragment (Servant.API.Verbs.Verb m s ct typ)
instance Servant.API.TypeLevel.AtLeastOneFragment (Servant.API.UVerb.UVerb m cts as)
instance Servant.API.TypeLevel.AtLeastOneFragment (Servant.API.Fragment.Fragment a)

module Servant.API.WithNamedContext

-- | <a>WithNamedContext</a> names a specific tagged context to use for the
--   combinators in the API. (See also in <tt>servant-server</tt>,
--   <tt>Servant.Server.Context</tt>.) For example:
--   
--   <pre>
--   type UseNamedContextAPI = WithNamedContext "myContext" '[String] (
--       ReqBody '[JSON] Int :&gt; Get '[JSON] Int)
--   </pre>
--   
--   Both the <tt>ReqBody</tt> and <tt>Get</tt> combinators will use the
--   <a>WithNamedContext</a> with type tag "myContext" as their context.
--   
--   <tt>Context</tt>s are only relevant for <tt>servant-server</tt>.
--   
--   For more information, see the tutorial.
data WithNamedContext (name :: Symbol) (subContext :: [*]) subApi

module Servant.API.WithResource
data WithResource res

module Servant.Types.SourceT

-- | This is CPSised ListT.
newtype SourceT m a
SourceT :: (forall b. (StepT m a -> m b) -> m b) -> SourceT m a
[unSourceT] :: SourceT m a -> forall b. (StepT m a -> m b) -> m b
mapStepT :: (StepT m a -> StepT m b) -> SourceT m a -> SourceT m b

-- | <tt>ListT</tt> with additional constructors.
data StepT m a
Stop :: StepT m a
Error :: String -> StepT m a
Skip :: StepT m a -> StepT m a
Yield :: a -> StepT m a -> StepT m a
Effect :: m (StepT m a) -> StepT m a

-- | Create <a>SourceT</a> from <tt>Step</tt>.
--   
--   <i>Note:</i> often enough you want to use <a>SourceT</a> directly.
fromStepT :: StepT m a -> SourceT m a

-- | Create pure <a>SourceT</a>.
--   
--   <pre>
--   &gt;&gt;&gt; source "foo" :: SourceT Identity Char
--   fromStepT (Effect (Identity (Yield 'f' (Yield 'o' (Yield 'o' Stop)))))
--   </pre>
source :: Foldable f => f a -> SourceT m a

-- | Get the answers.
--   
--   <pre>
--   &gt;&gt;&gt; runSourceT (source "foo" :: SourceT Identity Char)
--   ExceptT (Identity (Right "foo"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runSourceT (source "foo" :: SourceT [] Char)
--   ExceptT [Right "foo"]
--   </pre>
runSourceT :: Monad m => SourceT m a -> ExceptT String m [a]
runStepT :: Monad m => StepT m a -> ExceptT String m [a]

-- | Filter values.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ mapMaybe (\x -&gt; if odd x then Just x else Nothing) (source [0..10]) :: [Int]
--   [1,3,5,7,9]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\x -&gt; if odd x then Just x else Nothing) (source [0..2]) :: SourceT Identity Int
--   fromStepT (Effect (Identity (Skip (Yield 1 (Skip Stop)))))
--   </pre>
--   
--   Illustrates why we need <a>Skip</a>.
mapMaybe :: Functor m => (a -> Maybe b) -> SourceT m a -> SourceT m b
mapMaybeStep :: Functor m => (a -> Maybe b) -> StepT m a -> StepT m b

-- | Run action for each value in the <a>SourceT</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foreach fail print $ source ("abc" :: String)
--   'a'
--   'b'
--   'c'
--   </pre>
foreach :: Monad m => (String -> m ()) -> (a -> m ()) -> SourceT m a -> m ()

-- | See <a>foreach</a>.
foreachStep :: Monad m => (String -> m ()) -> (a -> m ()) -> StepT m a -> m ()
fromAction :: Functor m => (a -> Bool) -> m a -> SourceT m a
fromActionStep :: Functor m => (a -> Bool) -> m a -> StepT m a

-- | Read file.
--   
--   <pre>
--   &gt;&gt;&gt; foreach fail BS.putStr (readFile "servant.cabal")
--   cabal-version:       2.2
--   name:                servant
--   ...
--   </pre>
readFile :: FilePath -> SourceT IO ByteString

-- | Transform using <tt>attoparsec</tt> parser.
--   
--   Note: <tt>parser</tt> should not accept empty input!
--   
--   <pre>
--   &gt;&gt;&gt; let parser = A.skipWhile A8.isSpace_w8 &gt;&gt; A.takeWhile1 A8.isDigit_w8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ runSourceT $ transformWithAtto parser (source $ [fromString "1 2 3"])
--   Right ["1","2","3"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ runSourceT $ transformWithAtto parser (source $ map fromString ["1", "2", "3"])
--   Right ["123"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ runSourceT $ transformWithAtto parser (source $ map fromString ["1", "2 3", "4"])
--   Right ["12","34"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ runSourceT $ transformWithAtto parser (source [fromString "foobar"])
--   Left "Failed reading: takeWhile1"
--   </pre>
transformWithAtto :: Monad m => Parser a -> SourceT m ByteString -> SourceT m a
transformStepWithAtto :: forall a m. Monad m => Parser a -> StepT m ByteString -> StepT m a
instance GHC.Base.Functor m => GHC.Base.Functor (Servant.Types.SourceT.StepT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Servant.Types.SourceT.SourceT m)
instance (Data.Functor.Identity.Identity GHC.Types.~ m) => Data.Foldable.Foldable (Servant.Types.SourceT.SourceT m)
instance (GHC.Base.Applicative m, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Servant.Types.SourceT.SourceT m)
instance (GHC.Base.Applicative m, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Servant.Types.SourceT.SourceT m a)
instance Control.Monad.Morph.MFunctor Servant.Types.SourceT.SourceT
instance GHC.Base.Functor m => GHC.Base.Semigroup (Servant.Types.SourceT.SourceT m a)
instance GHC.Base.Functor m => GHC.Base.Monoid (Servant.Types.SourceT.SourceT m a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Base.Monad m) => Test.QuickCheck.Arbitrary.Arbitrary (Servant.Types.SourceT.SourceT m a)
instance (Data.Functor.Identity.Identity GHC.Types.~ m) => Data.Foldable.Foldable (Servant.Types.SourceT.StepT m)
instance (GHC.Base.Applicative m, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Servant.Types.SourceT.StepT m)
instance (GHC.Base.Applicative m, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Servant.Types.SourceT.StepT m a)
instance Control.Monad.Morph.MFunctor Servant.Types.SourceT.StepT
instance GHC.Base.Functor m => GHC.Base.Semigroup (Servant.Types.SourceT.StepT m a)
instance GHC.Base.Functor m => GHC.Base.Monoid (Servant.Types.SourceT.StepT m a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Base.Monad m) => Test.QuickCheck.Arbitrary.Arbitrary (Servant.Types.SourceT.StepT m a)

module Servant.API.Stream

-- | A Stream endpoint for a given method emits a stream of encoded values
--   at a given <tt>Content-Type</tt>, delimited by a <tt>framing</tt>
--   strategy. Type synonyms are provided for standard methods.
data Stream (method :: k1) (status :: Nat) (framing :: *) (contentType :: *) (a :: *)
type StreamGet = Stream 'GET 200
type StreamPost = Stream 'POST 200

-- | A stream request body.
type StreamBody = StreamBody' '[]
data StreamBody' (mods :: [*]) (framing :: *) (contentType :: *) (a :: *)

-- | Stream endpoints may be implemented as producing a <tt><a>SourceIO</a>
--   chunk</tt>.
--   
--   Clients reading from streaming endpoints can be implemented as
--   consuming a <tt><a>SourceIO</a> chunk</tt>.
type SourceIO = SourceT IO

-- | <a>ToSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly as endpoints.
class ToSourceIO chunk a | a -> chunk
toSourceIO :: ToSourceIO chunk a => a -> SourceIO chunk

-- | <a>FromSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly on the client side for talking to
--   streaming endpoints.
class FromSourceIO chunk a | a -> chunk
fromSourceIO :: FromSourceIO chunk a => SourceIO chunk -> IO a

-- | Auxiliary class for <tt><a>ToSourceIO</a> x (<a>SourceT</a> m x)</tt>
--   instance.
class SourceToSourceIO m
sourceToSourceIO :: SourceToSourceIO m => SourceT m a -> SourceT IO a

-- | The <a>FramingRender</a> class provides the logic for emitting a
--   framing strategy. The strategy transforms a <tt><a>SourceT</a> m
--   a</tt> into <tt><a>SourceT</a> m <a>ByteString</a></tt>, therefore it
--   can prepend, append and intercalate <i>framing</i> structure around
--   chunks.
--   
--   <i>Note:</i> as the <tt><a>Monad</a> m</tt> is generic, this is pure
--   transformation.
class FramingRender strategy
framingRender :: (FramingRender strategy, Monad m) => Proxy strategy -> (a -> ByteString) -> SourceT m a -> SourceT m ByteString

-- | The <a>FramingUnrender</a> class provides the logic for parsing a
--   framing strategy.
class FramingUnrender strategy
framingUnrender :: (FramingUnrender strategy, Monad m) => Proxy strategy -> (ByteString -> Either String a) -> SourceT m ByteString -> SourceT m a

-- | A framing strategy that does not do any framing at all, it just passes
--   the input data This will be used most of the time with binary data,
--   such as files
data NoFraming

-- | A simple framing strategy that has no header, and inserts a newline
--   character after each frame. This assumes that it is used with a
--   Content-Type that encodes without newlines (e.g. JSON).
data NewlineFraming

-- | The netstring framing strategy as defined by djb:
--   <a>http://cr.yp.to/proto/netstrings.txt</a>
--   
--   Any string of 8-bit bytes may be encoded as
--   <tt>[len]":"[string]","</tt>. Here <tt>[string]</tt> is the string and
--   <tt>[len]</tt> is a nonempty sequence of ASCII digits giving the
--   length of <tt>[string]</tt> in decimal. The ASCII digits are
--   <tt><a>30</a></tt> for 0, <tt><a>31</a></tt> for 1, and so on up
--   through <tt><a>39</a></tt> for 9. Extra zeros at the front of
--   <tt>[len]</tt> are prohibited: <tt>[len]</tt> begins with
--   <tt><a>30</a></tt> exactly when <tt>[string]</tt> is empty.
--   
--   For example, the string <tt>"hello world!"</tt> is encoded as
--   <tt><a>32 3a 68 65 6c 6c 6f 20 77 6f 72 6c 64 21 2c</a></tt>, i.e.,
--   <tt>"12:hello world!,"</tt>. The empty string is encoded as
--   <tt>"0:,"</tt>.
data NetstringFraming
instance forall k1 (method :: k1) (status :: GHC.TypeNats.Nat) framing contentType a. GHC.Generics.Generic (Servant.API.Stream.Stream method status framing contentType a)
instance GHC.Generics.Generic (Servant.API.Stream.StreamBody' mods framing contentType a)
instance Servant.API.Stream.FramingRender Servant.API.Stream.NetstringFraming
instance Servant.API.Stream.FramingUnrender Servant.API.Stream.NetstringFraming
instance Servant.API.Stream.FramingRender Servant.API.Stream.NewlineFraming
instance Servant.API.Stream.FramingUnrender Servant.API.Stream.NewlineFraming
instance Servant.API.Stream.FramingRender Servant.API.Stream.NoFraming
instance Servant.API.Stream.FramingUnrender Servant.API.Stream.NoFraming
instance Control.Monad.IO.Class.MonadIO m => Servant.API.Stream.FromSourceIO a (Servant.Types.SourceT.SourceT m a)
instance Servant.API.Stream.SourceToSourceIO GHC.Types.IO
instance Servant.API.Stream.SourceToSourceIO m => Servant.API.Stream.ToSourceIO chunk (Servant.Types.SourceT.SourceT m chunk)
instance Servant.API.Stream.ToSourceIO a (GHC.Base.NonEmpty a)
instance Servant.API.Stream.ToSourceIO a [a]


-- | Type safe generation of internal links.
--   
--   Given an API with a few endpoints:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds -XTypeFamilies -XTypeOperators
--   
--   &gt;&gt;&gt; import Servant.API
--   
--   &gt;&gt;&gt; import Servant.Links
--   
--   &gt;&gt;&gt; import Web.HttpApiData (toUrlPiece)
--   
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; type Hello = "hello" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; type Bye   = "bye"   :&gt; QueryParam "name" String :&gt; Delete '[JSON] NoContent
--   
--   &gt;&gt;&gt; type API   = Hello :&lt;|&gt; Bye
--   
--   &gt;&gt;&gt; let api = Proxy :: Proxy API
--   </pre>
--   
--   It is possible to generate links that are guaranteed to be within
--   <tt>API</tt> with <a>safeLink</a>. The first argument to
--   <a>safeLink</a> is a type representing the API you would like to
--   restrict links to. The second argument is the destination endpoint you
--   would like the link to point to, this will need to end with a verb
--   like GET or POST. Further arguments may be required depending on the
--   type of the endpoint. If everything lines up you will get a
--   <a>Link</a> out the other end.
--   
--   You may omit <tt>QueryParam</tt>s and the like should you not want to
--   provide them, but types which form part of the URL path like
--   <tt>Capture</tt> must be included. The reason you may want to omit
--   <tt>QueryParam</tt>s is that safeLink is a bit magical: if parameters
--   are included that could take input it will return a function that
--   accepts that input and generates a link. This is best shown with an
--   example. Here, a link is generated with no parameters:
--   
--   <pre>
--   &gt;&gt;&gt; let hello = Proxy :: Proxy ("hello" :&gt; Get '[JSON] Int)
--   
--   &gt;&gt;&gt; toUrlPiece (safeLink api hello :: Link)
--   "hello"
--   </pre>
--   
--   If the API has an endpoint with parameters then we can generate links
--   with or without those:
--   
--   <pre>
--   &gt;&gt;&gt; let with = Proxy :: Proxy ("bye" :&gt; QueryParam "name" String :&gt; Delete '[JSON] NoContent)
--   
--   &gt;&gt;&gt; toUrlPiece $ safeLink api with (Just "Hubert")
--   "bye?name=Hubert"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let without = Proxy :: Proxy ("bye" :&gt; Delete '[JSON] NoContent)
--   
--   &gt;&gt;&gt; toUrlPiece $ safeLink api without
--   "bye"
--   </pre>
--   
--   If you would like to create a helper for generating links only within
--   that API, you can partially apply safeLink if you specify a correct
--   type signature like so:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XConstraintKinds
--   
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let apiLink :: (IsElem endpoint API, HasLink endpoint)
--   
--   &gt;&gt;&gt; =&gt; Proxy endpoint -&gt; MkLink endpoint Link
--   
--   &gt;&gt;&gt; apiLink = safeLink api
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <a>safeLink'</a> allows you to specialise the output:
--   
--   <pre>
--   &gt;&gt;&gt; safeLink' toUrlPiece api without
--   "bye"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let apiTextLink :: (IsElem endpoint API, HasLink endpoint)
--   
--   &gt;&gt;&gt; =&gt; Proxy endpoint -&gt; MkLink endpoint Text
--   
--   &gt;&gt;&gt; apiTextLink = safeLink' toUrlPiece api
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; apiTextLink without
--   "bye"
--   </pre>
--   
--   Attempting to construct a link to an endpoint that does not exist in
--   api will result in a type error like this:
--   
--   <pre>
--   &gt;&gt;&gt; let bad_link = Proxy :: Proxy ("hello" :&gt; Delete '[JSON] NoContent)
--   
--   &gt;&gt;&gt; safeLink api bad_link
--   ...
--   ...Could not ...
--   ...
--   </pre>
--   
--   This error is essentially saying that the type family couldn't find
--   bad_link under api after trying the open (but empty) type family
--   <a>IsElem'</a> as a last resort.
module Servant.Links

-- | Create a valid (by construction) relative URI with query params.
--   
--   This function will only typecheck if <tt>endpoint</tt> is part of the
--   API <tt>api</tt>
safeLink :: forall endpoint api. (IsElem endpoint api, HasLink endpoint) => Proxy api -> Proxy endpoint -> MkLink endpoint Link

-- | More general <a>safeLink</a>.
safeLink' :: forall endpoint api a. (IsElem endpoint api, HasLink endpoint) => (Link -> a) -> Proxy api -> Proxy endpoint -> MkLink endpoint a

-- | Create all links in an API.
--   
--   Note that the <tt>api</tt> type must be restricted to the endpoints
--   that have valid links to them.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "foo" :&gt; Capture "name" Text :&gt; Get '[JSON] Text :&lt;|&gt; "bar" :&gt; Capture "name" Int :&gt; Get '[JSON] Double
--   
--   &gt;&gt;&gt; let fooLink :&lt;|&gt; barLink = allLinks (Proxy :: Proxy API)
--   
--   &gt;&gt;&gt; :t fooLink
--   fooLink :: Text -&gt; Link
--   
--   &gt;&gt;&gt; :t barLink
--   barLink :: Int -&gt; Link
--   </pre>
--   
--   Note: nested APIs don't work well with this approach
--   
--   <pre>
--   &gt;&gt;&gt; :kind! MkLink (Capture "nest" Char :&gt; (Capture "x" Int :&gt; Get '[JSON] Int :&lt;|&gt; Capture "y" Double :&gt; Get '[JSON] Double)) Link
--   MkLink (Capture "nest" Char :&gt; (Capture "x" Int :&gt; Get '[JSON] Int :&lt;|&gt; Capture "y" Double :&gt; Get '[JSON] Double)) Link :: *
--   = Char -&gt; (Int -&gt; Link) :&lt;|&gt; (Double -&gt; Link)
--   </pre>
allLinks :: forall api. HasLink api => Proxy api -> MkLink api Link

-- | More general <a>allLinks</a>. See <a>safeLink'</a>.
allLinks' :: forall api a. HasLink api => (Link -> a) -> Proxy api -> MkLink api a

-- | Represents a general universal resource identifier using its component
--   parts.
--   
--   For example, for the URI
--   
--   <pre>
--   foo://anonymous@www.haskell.org:42/ghc?query#frag
--   </pre>
--   
--   the components are:
data () => URI
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI

-- | <pre>
--   foo:
--   </pre>
[uriScheme] :: URI -> String

-- | <pre>
--   //anonymous@www.haskell.org:42
--   </pre>
[uriAuthority] :: URI -> Maybe URIAuth

-- | <pre>
--   /ghc
--   </pre>
[uriPath] :: URI -> String

-- | <pre>
--   ?query
--   </pre>
[uriQuery] :: URI -> String

-- | <pre>
--   #frag
--   </pre>
[uriFragment] :: URI -> String

-- | A type that specifies that an API record contains a set of links.
data AsLink (a :: *)

-- | Given an API record field, create a link for that route. Only the
--   field's type is used.
--   
--   <pre>
--   data Record route = Record
--       { _get :: route :- Capture "id" Int :&gt; Get '[JSON] String
--       , _put :: route :- ReqBody '[JSON] Int :&gt; Put '[JSON] Bool
--       }
--     deriving (<a>Generic</a>)
--   
--   getLink :: Int -&gt; Link
--   getLink = <a>fieldLink</a> _get
--   </pre>
fieldLink :: (IsElem endpoint (ToServantApi routes), HasLink endpoint, GenericServant routes AsApi) => (routes AsApi -> endpoint) -> MkLink endpoint Link

-- | More general version of <a>fieldLink</a>
fieldLink' :: forall routes endpoint a. (IsElem endpoint (ToServantApi routes), HasLink endpoint, GenericServant routes AsApi) => (Link -> a) -> (routes AsApi -> endpoint) -> MkLink endpoint a

-- | Get all links as a record.
allFieldLinks :: (HasLink (ToServantApi routes), GenericServant routes (AsLink Link), ToServant routes (AsLink Link) ~ MkLink (ToServantApi routes) Link) => routes (AsLink Link)

-- | More general version of <a>allFieldLinks</a>.
allFieldLinks' :: forall routes a. (HasLink (ToServantApi routes), GenericServant routes (AsLink a), ToServant routes (AsLink a) ~ MkLink (ToServantApi routes) a) => (Link -> a) -> routes (AsLink a)

-- | Construct a toLink for an endpoint.
class HasLink endpoint where {
    type MkLink endpoint (a :: *);
}
toLink :: HasLink endpoint => (Link -> a) -> Proxy endpoint -> Link -> MkLink endpoint a

-- | A safe link datatype. The only way of constructing a <a>Link</a> is
--   using <a>safeLink</a>, which means any <a>Link</a> is guaranteed to be
--   part of the mentioned API.
data Link

-- | Transform <a>Link</a> into <a>URI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "something" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API)
--   something
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type API = "sum" :&gt; QueryParams "x" Int :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x[]=1&amp;x[]=2&amp;x[]=3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type API = "foo/bar" :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API)
--   foo%2Fbar
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type SomeRoute = "abc" :&gt; Capture "email" String :&gt; Put '[JSON] ()
--   
--   &gt;&gt;&gt; let someRoute = Proxy :: Proxy SomeRoute
--   
--   &gt;&gt;&gt; safeLink someRoute someRoute "test@example.com"
--   Link {_segments = ["abc","test%40example.com"], _queryParams = [], _fragment = Nothing}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linkURI $ safeLink someRoute someRoute "test@example.com"
--   abc/test%40example.com
--   </pre>
linkURI :: Link -> URI

-- | Configurable <a>linkURI</a>.
--   
--   <pre>
--   &gt;&gt;&gt; type API = "sum" :&gt; QueryParams "x" Int :&gt; Get '[JSON] Int
--   
--   &gt;&gt;&gt; linkURI' LinkArrayElementBracket $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x[]=1&amp;x[]=2&amp;x[]=3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linkURI' LinkArrayElementPlain $ safeLink (Proxy :: Proxy API) (Proxy :: Proxy API) [1, 2, 3]
--   sum?x=1&amp;x=2&amp;x=3
--   </pre>
linkURI' :: LinkArrayElementStyle -> Link -> URI

-- | How to encode array query elements.
data LinkArrayElementStyle

-- | <pre>
--   foo[]=1&amp;foo[]=2
--   </pre>
LinkArrayElementBracket :: LinkArrayElementStyle

-- | <pre>
--   foo=1&amp;foo=2
--   </pre>
LinkArrayElementPlain :: LinkArrayElementStyle

-- | Query parameter.
data Param
SingleParam :: String -> Text -> Param
ArrayElemParam :: String -> Text -> Param
FlagParam :: String -> Param
linkSegments :: Link -> [String]
linkQueryParams :: Link -> [Param]
linkFragment :: Link -> Fragment'
instance GHC.Show.Show Servant.Links.Param
instance GHC.Show.Show Servant.Links.Link
instance GHC.Enum.Bounded Servant.Links.LinkArrayElementStyle
instance GHC.Enum.Enum Servant.Links.LinkArrayElementStyle
instance GHC.Show.Show Servant.Links.LinkArrayElementStyle
instance GHC.Classes.Ord Servant.Links.LinkArrayElementStyle
instance GHC.Classes.Eq Servant.Links.LinkArrayElementStyle
instance Servant.Links.GLinkConstraints routes a => Servant.Links.GLink routes a
instance (Servant.Links.HasLink (Servant.API.Generic.ToServantApi routes), forall a. Servant.Links.GLink routes a, Servant.API.TypeErrors.ErrorIfNoGeneric routes) => Servant.Links.HasLink (Servant.API.NamedRoutes.NamedRoutes routes)
instance Servant.API.Generic.GenericMode (Servant.Links.AsLink a)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Links.HasLink sub) => Servant.Links.HasLink (sym Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData v, Servant.Links.HasLink sub, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods)) => Servant.Links.HasLink (Servant.API.QueryParam.QueryParam' mods sym v Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData v, Servant.Links.HasLink sub) => Servant.Links.HasLink (Servant.API.QueryParam.QueryParams sym v Servant.API.Sub.:> sub)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Links.HasLink sub) => Servant.Links.HasLink (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> sub)
instance (Servant.Links.HasLink a, Servant.Links.HasLink b) => Servant.Links.HasLink (a Servant.API.Alternative.:<|> b)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.ReqBody.ReqBody' mods ct a Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.Stream.StreamBody' mods framing ct a Servant.API.Sub.:> sub)
instance (Web.Internal.HttpApiData.ToHttpApiData v, Servant.Links.HasLink sub) => Servant.Links.HasLink (Servant.API.Capture.Capture' mods sym v Servant.API.Sub.:> sub)
instance (Web.Internal.HttpApiData.ToHttpApiData v, Servant.Links.HasLink sub) => Servant.Links.HasLink (Servant.API.Capture.CaptureAll sym v Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Data.Vault.Lazy.Vault Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.Description.Description s Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.Description.Summary s Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.WithNamedContext.WithNamedContext name context sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.WithResource.WithResource res Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> sub)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.BasicAuth.BasicAuth realm a Servant.API.Sub.:> sub)
instance Servant.Links.HasLink Servant.API.Empty.EmptyAPI
instance forall k1 (m :: k1) (s :: GHC.TypeNats.Nat) (ct :: [*]) a. Servant.Links.HasLink (Servant.API.Verbs.Verb m s ct a)
instance forall k1 (m :: k1). Servant.Links.HasLink (Servant.API.Verbs.NoContentVerb m)
instance Servant.Links.HasLink Servant.API.Raw.Raw
instance Servant.Links.HasLink Servant.API.Raw.RawM
instance forall k1 (m :: k1) (status :: GHC.TypeNats.Nat) fr ct a. Servant.Links.HasLink (Servant.API.Stream.Stream m status fr ct a)
instance Servant.Links.HasLink (Servant.API.UVerb.UVerb m ct a)
instance forall k sub (tag :: k). Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> sub)
instance (Servant.Links.HasLink sub, Web.Internal.HttpApiData.ToHttpApiData v) => Servant.Links.HasLink (Servant.API.Fragment.Fragment v Servant.API.Sub.:> sub)
instance forall a b (arr :: a -> b) sub. (TypeError ...) => Servant.Links.HasLink (arr Servant.API.Sub.:> sub)
instance forall k (ty :: k) sub. (TypeError ...) => Servant.Links.HasLink (ty Servant.API.Sub.:> sub)
instance forall k (api :: k). (TypeError ...) => Servant.Links.HasLink api
instance Web.Internal.HttpApiData.ToHttpApiData Servant.Links.Link
instance GHC.Show.Show Servant.Links.Escaped

module Servant.API

-- | The contained API (second argument) can be found under <tt>("/" ++
--   path)</tt> (path being the first argument).
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /hello/world
--   
--   &gt;&gt;&gt; -- returning a JSON encoded World value
--   
--   &gt;&gt;&gt; type MyApi = "hello" :&gt; "world" :&gt; Get '[JSON] World
--   </pre>
data (path :: k) :> (a :: *)
infixr 4 :>

-- | Union of two APIs, first takes precedence in case of overlap.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--          :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] () -- POST /books
--   :}
--   </pre>
data a :<|> b
(:<|>) :: a -> b -> (:<|>) a b
infixr 3 :<|>
infixr 3 :<|>

-- | An empty API: one which serves nothing. Morally speaking, this should
--   be the unit of <tt>:&lt;|&gt;</tt>. Implementors of interpretations of
--   API types should treat <a>EmptyAPI</a> as close to the unit as
--   possible.
data EmptyAPI
EmptyAPI :: EmptyAPI

-- | Strictly parsed argument. Not wrapped.
data Strict

-- | Leniently parsed argument, i.e. parsing never fail. Wrapped in
--   <tt><a>Either</a> <a>Text</a></tt>.
data Lenient

-- | Optional argument. Wrapped in <a>Maybe</a>.
data Optional

-- | Required argument. Not wrapped.
data Required

-- | Capture a value from the request path under a certain type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /books/:isbn
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
type Capture = Capture' '[]

-- | <a>Capture</a> which can be modified. For example with
--   <tt>Description</tt>.
data Capture' (mods :: [*]) (sym :: Symbol) (a :: *)

-- | Capture all remaining values from the request path under a certain
--   type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- GET /src/*
--   
--   &gt;&gt;&gt; type MyAPI = "src" :&gt; CaptureAll "segments" Text :&gt; Get '[JSON] SourceFile
--   </pre>
data CaptureAll (sym :: Symbol) (a :: *)

-- | Extract the given header's value as a value of type <tt>a</tt>. I.e.
--   header sent by client, parsed by server.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; newtype Referer = Referer Text deriving (Eq, Show)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; -- GET /view-my-referer
--   
--   &gt;&gt;&gt; type MyApi = "view-my-referer" :&gt; Header "from" Referer :&gt; Get '[JSON] Referer
--   </pre>
type Header = Header' '[Optional, Strict]
data Header' (mods :: [*]) (sym :: Symbol) (a :: *)

-- | HTTP Version.
--   
--   Note that the <a>Show</a> instance is intended merely for debugging.
data () => HttpVersion
HttpVersion :: !Int -> !Int -> HttpVersion
[httpMajor] :: HttpVersion -> !Int
[httpMinor] :: HttpVersion -> !Int

-- | Lookup the value associated to the <tt>sym</tt> query string parameter
--   and try to extract it as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?author=&lt;author name&gt;
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get '[JSON] [Book]
--   </pre>
type QueryParam = QueryParam' '[Optional, Strict]

-- | Lookup a potentially value-less query string parameter with boolean
--   semantics. If the param <tt>sym</tt> is there without any value, or if
--   it's there with value "true" or "1", it's interpreted as <a>True</a>.
--   Otherwise, it's interpreted as <a>False</a>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?published
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get '[JSON] [Book]
--   </pre>
data QueryFlag (sym :: Symbol)

-- | <a>QueryParam</a> which can be <a>Required</a>, <a>Lenient</a>, or
--   modified otherwise.
data QueryParam' (mods :: [*]) (sym :: Symbol) (a :: *)

-- | Lookup the values associated to the <tt>sym</tt> query string
--   parameter and try to extract it as a value of type <tt>[a]</tt>. This
--   is typically meant to support query string parameters of the form
--   <tt>param[]=val1&amp;param[]=val2</tt> and so on. Note that servant
--   doesn't actually require the <tt>[]</tt>s and will fetch the values
--   just fine with <tt>param=val1&amp;param=val2</tt>, too.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /books?authors[]=&lt;author1&gt;&amp;authors[]=&lt;author2&gt;&amp;...
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get '[JSON] [Book]
--   </pre>
data QueryParams (sym :: Symbol) (a :: *)

-- | Document the URI fragment in API. Useful in combination with
--   <tt>Link</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- /post#TRACKING
--   
--   &gt;&gt;&gt; type MyApi = "post" :&gt; Fragment Text :&gt; Get '[JSON] Tracking
--   </pre>
data Fragment (a :: *)

-- | Extract the request body as a value of type <tt>a</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; -- POST /books
--   
--   &gt;&gt;&gt; type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   </pre>
type ReqBody = ReqBody' '[Required, Strict]

-- | <i>Note:</i> <a>ReqBody'</a> is always <a>Required</a>.
data ReqBody' (mods :: [*]) (contentTypes :: [*]) (a :: *)

-- | Provides access to the host or IP address from which the HTTP request
--   was sent.
data RemoteHost

-- | Was this request made over an SSL connection?
--   
--   Note that this value will not tell you if the client originally made
--   this request over SSL, but rather whether the current connection is
--   SSL. The distinction lies with reverse proxies. In many cases, the
--   client will connect to a load balancer over SSL, but connect to the
--   WAI handler without SSL. In such a case, the handlers would get
--   <a>NotSecure</a>, but from a user perspective, there is a secure
--   connection.
data IsSecure

-- | the connection to the server is secure (HTTPS)
Secure :: IsSecure

-- | the connection to the server is not secure (HTTP)
NotSecure :: IsSecure

-- | A persistent store for values of arbitrary types.
--   
--   This variant is the simplest and creates keys in the <a>IO</a> monad.
--   See the module <a>Data.Vault.ST</a> if you want to use it with the
--   <a>ST</a> monad instead.
type Vault = Vault RealWorld

-- | <a>WithNamedContext</a> names a specific tagged context to use for the
--   combinators in the API. (See also in <tt>servant-server</tt>,
--   <tt>Servant.Server.Context</tt>.) For example:
--   
--   <pre>
--   type UseNamedContextAPI = WithNamedContext "myContext" '[String] (
--       ReqBody '[JSON] Int :&gt; Get '[JSON] Int)
--   </pre>
--   
--   Both the <tt>ReqBody</tt> and <tt>Get</tt> combinators will use the
--   <a>WithNamedContext</a> with type tag "myContext" as their context.
--   
--   <tt>Context</tt>s are only relevant for <tt>servant-server</tt>.
--   
--   For more information, see the tutorial.
data WithNamedContext (name :: Symbol) (subContext :: [*]) subApi
data WithResource res

-- | <a>GET</a> with 200 status code.
type Get = Verb 'GET 200

-- | <a>PUT</a> with 200 status code.
type Put = Verb 'PUT 200

-- | HTTP standard method (as defined by RFC 2616, and PATCH which is
--   defined by RFC 5789).
data () => StdMethod
GET :: StdMethod
POST :: StdMethod
HEAD :: StdMethod
PUT :: StdMethod
DELETE :: StdMethod
TRACE :: StdMethod
CONNECT :: StdMethod
OPTIONS :: StdMethod

PATCH :: StdMethod

-- | <a>DELETE</a> with 200 status code.
type Delete = Verb 'DELETE 200

-- | <a>DELETE</a> with 202 status code.
type DeleteAccepted = Verb 'DELETE 202

-- | <a>DELETE</a> with 204 status code.
type DeleteNoContent = NoContentVerb 'DELETE

-- | <a>DELETE</a> with 203 status code.
type DeleteNonAuthoritative = Verb 'DELETE 203

-- | <a>GET</a> with 202 status code.
type GetAccepted = Verb 'GET 202

-- | <a>GET</a> with 204 status code.
type GetNoContent = NoContentVerb 'GET

-- | <a>GET</a> with 203 status code.
type GetNonAuthoritative = Verb 'GET 203

-- | <a>GET</a> with 206 status code.
type GetPartialContent = Verb 'GET 206

-- | <a>GET</a> with 205 status code.
type GetResetContent = Verb 'GET 205

-- | <tt>NoContentVerb</tt> is a specific type to represent
--   <tt>NoContent</tt> responses. It does not require either a list of
--   content types (because there's no content) or a status code (because
--   it should always be 204).
data NoContentVerb (method :: k1)

-- | <a>PATCH</a> with 200 status code.
type Patch = Verb 'PATCH 200

-- | <a>PATCH</a> with 202 status code.
type PatchAccepted = Verb 'PATCH 202

-- | <a>PATCH</a> with 204 status code.
type PatchNoContent = NoContentVerb 'PATCH

-- | <a>PATCH</a> with 203 status code.
type PatchNonAuthoritative = Verb 'PATCH 203

-- | <a>POST</a> with 200 status code.
type Post = Verb 'POST 200

-- | <a>POST</a> with 202 status code.
type PostAccepted = Verb 'POST 202

-- | <a>POST</a> with 201 status code.
type PostCreated = Verb 'POST 201

-- | <a>POST</a> with 204 status code.
type PostNoContent = NoContentVerb 'POST

-- | <a>POST</a> with 203 status code.
type PostNonAuthoritative = Verb 'POST 203

-- | <a>POST</a> with 205 status code.
type PostResetContent = Verb 'POST 205

-- | <a>PUT</a> with 202 status code.
type PutAccepted = Verb 'PUT 202

-- | <a>PUT</a> with 201 status code.
type PutCreated = Verb 'PUT 201

-- | <a>PUT</a> with 204 status code.
type PutNoContent = NoContentVerb 'PUT

-- | <a>PUT</a> with 203 status code.
type PutNonAuthoritative = Verb 'PUT 203
class ReflectMethod a
reflectMethod :: ReflectMethod a => Proxy a -> Method

-- | <tt>Verb</tt> is a general type for representing HTTP verbs (a.k.a.
--   methods). For convenience, type synonyms for each verb with a 200
--   response code are provided, but you are free to define your own:
--   
--   <pre>
--   &gt;&gt;&gt; type Post204 contentTypes a = Verb 'POST 204 contentTypes a
--   </pre>
data Verb (method :: k1) (statusCode :: Nat) (contentTypes :: [*]) (a :: *)

-- | Check whether all values in a type-level list are distinct. This will
--   throw a nice error if there are any duplicate elements in the list.
type family Unique xs :: Constraint
type Union = NS I

-- | A variant of <tt>Verb</tt> that can have any of a number of response
--   values and status codes.
--   
--   FUTUREWORK: it would be nice to make <tt>Verb</tt> a special case of
--   <a>UVerb</a>, and only write instances for <tt>HasServer</tt> etc. for
--   the latter, getting them for the former for free. Something like:
--   
--   <pre>
--   type Verb method statusCode contentTypes a = UVerb method contentTypes [WithStatus statusCode a]
--   </pre>
--   
--   Backwards compatibility is tricky, though: this type alias would mean
--   people would have to use <tt>respond</tt> instead of <a>pure</a> or
--   <a>return</a>, so all old handlers would have to be rewritten.
data UVerb (method :: StdMethod) (contentTypes :: [*]) (as :: [*])
class KnownStatus (StatusOf a) => HasStatus (a :: *) where {
    type StatusOf (a :: *) :: Nat;
}
type IsMember (a :: u) (as :: [u]) = (Unique as, CheckElemIsMember a as, UElem a as)
type Statuses (as :: [*]) :: [Nat]
type Statuses (as :: [*]) :: [Nat]

-- | A simple newtype wrapper that pairs a type with its status code. It
--   implements all the content types that Servant ships with by default.
newtype WithStatus (k :: Nat) a
WithStatus :: a -> WithStatus (k :: Nat) a
inject :: UElem x xs => f x -> NS f xs
statusOf :: forall a proxy. HasStatus a => proxy a -> Status

-- | Combinator for embedding a record of named routes into a Servant API
--   type.
data NamedRoutes (api :: * -> *)

-- | A class with a type family that applies an appropriate type family to
--   the <tt>api</tt> parameter. For example, <a>AsApi</a> will leave
--   <tt>api</tt> untouched, while <tt><tt>AsServerT</tt> m</tt> will
--   produce <tt><tt>ServerT</tt> api m</tt>.
class GenericMode mode where {
    type mode :- api :: *;
}
infixl 0 :-

-- | A type that specifies that an API record contains an API definition.
--   Only useful at type-level.
data AsApi
class GServantProduct f

-- | A constraint alias, for work with <tt>mode</tt> and <tt>routes</tt>.
type GenericServant routes mode = (GenericMode mode, Generic (routes mode), GServantProduct (Rep (routes mode)))

-- | Turns a generic product type into a tree of <a>:&lt;|&gt;</a>
--   combinators.
type ToServant routes mode = GToServant (Rep (routes mode))
type ToServantApi routes = ToServant routes AsApi

-- | Inverse of <a>toServant</a>.
--   
--   This can be used to turn <tt>generated</tt> values such as client
--   functions into records.
--   
--   You may need to provide a type signature for the <i>output</i> type
--   (your record type).
fromServant :: GenericServant routes mode => ToServant routes mode -> routes mode

-- | Get a <a>Proxy</a> of an API type.
genericApi :: GenericServant routes AsApi => Proxy routes -> Proxy (ToServantApi routes)

-- | See <a>ToServant</a>, but at value-level.
toServant :: GenericServant routes mode => routes mode -> ToServant routes mode

-- | A Stream endpoint for a given method emits a stream of encoded values
--   at a given <tt>Content-Type</tt>, delimited by a <tt>framing</tt>
--   strategy. Type synonyms are provided for standard methods.
data Stream (method :: k1) (status :: Nat) (framing :: *) (contentType :: *) (a :: *)

-- | The <a>FramingRender</a> class provides the logic for emitting a
--   framing strategy. The strategy transforms a <tt><a>SourceT</a> m
--   a</tt> into <tt><a>SourceT</a> m <a>ByteString</a></tt>, therefore it
--   can prepend, append and intercalate <i>framing</i> structure around
--   chunks.
--   
--   <i>Note:</i> as the <tt><a>Monad</a> m</tt> is generic, this is pure
--   transformation.
class FramingRender strategy
framingRender :: (FramingRender strategy, Monad m) => Proxy strategy -> (a -> ByteString) -> SourceT m a -> SourceT m ByteString

-- | The <a>FramingUnrender</a> class provides the logic for parsing a
--   framing strategy.
class FramingUnrender strategy
framingUnrender :: (FramingUnrender strategy, Monad m) => Proxy strategy -> (ByteString -> Either String a) -> SourceT m ByteString -> SourceT m a

-- | <a>FromSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly on the client side for talking to
--   streaming endpoints.
class FromSourceIO chunk a | a -> chunk
fromSourceIO :: FromSourceIO chunk a => SourceIO chunk -> IO a

-- | The netstring framing strategy as defined by djb:
--   <a>http://cr.yp.to/proto/netstrings.txt</a>
--   
--   Any string of 8-bit bytes may be encoded as
--   <tt>[len]":"[string]","</tt>. Here <tt>[string]</tt> is the string and
--   <tt>[len]</tt> is a nonempty sequence of ASCII digits giving the
--   length of <tt>[string]</tt> in decimal. The ASCII digits are
--   <tt><a>30</a></tt> for 0, <tt><a>31</a></tt> for 1, and so on up
--   through <tt><a>39</a></tt> for 9. Extra zeros at the front of
--   <tt>[len]</tt> are prohibited: <tt>[len]</tt> begins with
--   <tt><a>30</a></tt> exactly when <tt>[string]</tt> is empty.
--   
--   For example, the string <tt>"hello world!"</tt> is encoded as
--   <tt><a>32 3a 68 65 6c 6c 6f 20 77 6f 72 6c 64 21 2c</a></tt>, i.e.,
--   <tt>"12:hello world!,"</tt>. The empty string is encoded as
--   <tt>"0:,"</tt>.
data NetstringFraming

-- | A simple framing strategy that has no header, and inserts a newline
--   character after each frame. This assumes that it is used with a
--   Content-Type that encodes without newlines (e.g. JSON).
data NewlineFraming

-- | A framing strategy that does not do any framing at all, it just passes
--   the input data This will be used most of the time with binary data,
--   such as files
data NoFraming

-- | Stream endpoints may be implemented as producing a <tt><a>SourceIO</a>
--   chunk</tt>.
--   
--   Clients reading from streaming endpoints can be implemented as
--   consuming a <tt><a>SourceIO</a> chunk</tt>.
type SourceIO = SourceT IO

-- | A stream request body.
type StreamBody = StreamBody' '[]
data StreamBody' (mods :: [*]) (framing :: *) (contentType :: *) (a :: *)
type StreamGet = Stream 'GET 200
type StreamPost = Stream 'POST 200

-- | <a>ToSourceIO</a> is intended to be implemented for types such as
--   Conduit, Pipe, etc. By implementing this class, all such streaming
--   abstractions can be used directly as endpoints.
class ToSourceIO chunk a | a -> chunk
toSourceIO :: ToSourceIO chunk a => a -> SourceIO chunk

-- | Combinator for <a>Basic Access Authentication</a>.
--   
--   <ul>
--   <li>IMPORTANT*: Only use Basic Auth over HTTPS! Credentials are not
--   hashed or encrypted. Note also that because the same credentials are
--   sent on every request, Basic Auth is not as secure as some
--   alternatives. Further, the implementation in servant-server does not
--   protect against some types of timing attacks.</li>
--   </ul>
--   
--   In Basic Auth, username and password are base64-encoded and
--   transmitted via the <tt>Authorization</tt> header. Handshakes are not
--   required, making it relatively efficient.
data BasicAuth (realm :: Symbol) (userData :: *)

-- | A simple datatype to hold data required to decorate a request
data BasicAuthData
BasicAuthData :: !ByteString -> !ByteString -> BasicAuthData
[basicAuthUsername] :: BasicAuthData -> !ByteString
[basicAuthPassword] :: BasicAuthData -> !ByteString

-- | Add more verbose description for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   type MyApi = Description
--    "This comment is visible in multiple Servant interpretations \
--    \and can be really long if necessary. \
--    \Haskell multiline String support is not perfect \
--    \but it's still very readable."
--   :&gt; Get '[JSON] Book
--   :}
--   </pre>
data Description (sym :: Symbol)

-- | Add a short summary for (part of) API.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; type MyApi = Summary "Get book by ISBN." :&gt; "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   </pre>
data Summary (sym :: Symbol)

-- | Instances of <a>Accept</a> represent mimetypes. They are used for
--   matching against the <tt>Accept</tt> HTTP header of the request, and
--   for setting the <tt>Content-Type</tt> header of the response
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media ((//), (/:))
--   
--   &gt;&gt;&gt; data HTML
--   
--   &gt;&gt;&gt; :{
--   instance Accept HTML where
--      contentType _ = "text" // "html" /: ("charset", "utf-8")
--   :}
--   </pre>
class Accept ctype
contentType :: Accept ctype => Proxy ctype -> MediaType
contentTypes :: Accept ctype => Proxy ctype -> NonEmpty MediaType
data FormUrlEncoded
data JSON

-- | Instantiate this class to register a way of serializing a type based
--   on the <tt>Accept</tt> header.
--   
--   Example:
--   
--   <pre>
--   data MyContentType
--   
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   
--   instance Show a =&gt; MimeRender MyContentType a where
--      mimeRender _ val = pack ("This is MINE! " ++ show val)
--   
--   type MyAPI = "path" :&gt; Get '[MyContentType] Int
--   </pre>
class Accept ctype => MimeRender ctype a
mimeRender :: MimeRender ctype a => Proxy ctype -> a -> ByteString

-- | Instantiate this class to register a way of deserializing a type based
--   on the request's <tt>Content-Type</tt> header.
--   
--   <pre>
--   &gt;&gt;&gt; import Network.HTTP.Media hiding (Accept)
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BSC
--   
--   &gt;&gt;&gt; data MyContentType = MyContentType String
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Accept MyContentType where
--      contentType _ = "example" // "prs.me.mine" /: ("charset", "utf-8")
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance Read a =&gt; MimeUnrender MyContentType a where
--      mimeUnrender _ bs = case BSC.take 12 bs of
--        "MyContentType" -&gt; return . read . BSC.unpack $ BSC.drop 12 bs
--        _ -&gt; Left "didn't start with the magic incantation"
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; type MyAPI = "path" :&gt; ReqBody '[MyContentType] Int :&gt; Get '[JSON] Int
--   </pre>
class Accept ctype => MimeUnrender ctype a
mimeUnrender :: MimeUnrender ctype a => Proxy ctype -> ByteString -> Either String a

-- | Variant which is given the actual <a>MediaType</a> provided by the
--   other party.
--   
--   In the most cases you don't want to branch based on the
--   <a>MediaType</a>. See <a>pr552</a> for a motivating example.
mimeUnrenderWithType :: MimeUnrender ctype a => Proxy ctype -> MediaType -> ByteString -> Either String a

-- | A type for responses without content-body.
data NoContent
NoContent :: NoContent
data OctetStream
data PlainText
class AddHeader h v orig new | h v orig -> new, new -> h, new -> v, new -> orig
class BuildHeadersTo hs
buildHeadersTo :: BuildHeadersTo hs => [Header] -> HList hs
class GetHeaders ls
getHeaders :: GetHeaders ls => ls -> [Header]
data HList a
[HNil] :: HList '[]
[HCons] :: ResponseHeader h x -> HList xs -> HList (Header h x ': xs)
class HasResponseHeader h a headers

-- | Response Header objects. You should never need to construct one
--   directly. Instead, use <a>addOptionalHeader</a>.
data Headers ls a
Headers :: a -> HList ls -> Headers ls a

-- | The underlying value of a <a>Headers</a>
[getResponse] :: Headers ls a -> a

-- | HList of headers.
[getHeadersHList] :: Headers ls a -> HList ls
data ResponseHeader (sym :: Symbol) a
Header :: a -> ResponseHeader (sym :: Symbol) a
MissingHeader :: ResponseHeader (sym :: Symbol) a
UndecodableHeader :: ByteString -> ResponseHeader (sym :: Symbol) a

-- | <tt>addHeader</tt> adds a header to a response. Note that it changes
--   the type of the value in the following ways:
--   
--   <ol>
--   <li>A simple value is wrapped in "Headers '[hdr]":</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example0 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; getHeaders example0
--   [("someheader","5")]
--   </pre>
--   
--   <ol>
--   <li>A value that already has a header has its new header *prepended*
--   to the existing list:</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String;
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example2
--   [("1st","true"),("someheader","5")]
--   </pre>
--   
--   Note that while in your handlers type annotations are not required,
--   since the type can be inferred from the API type, in other cases you
--   may find yourself needing to add annotations.
addHeader :: AddHeader h v orig new => v -> orig -> new

-- | Look up a specific ResponseHeader, without having to know what
--   position it is in the HList.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = addHeader 5 "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; let example2 = addHeader True example1 :: Headers '[Header "1st" Bool, Header "someheader" Int] String
--   
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "someheader" Int
--   Header 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupResponseHeader example2 :: ResponseHeader "1st" Bool
--   Header True
--   </pre>
--   
--   Usage of this function relies on an explicit type annotation of the
--   header to be looked up. This can be done with type annotations on the
--   result, or with an explicit type application. In this example, the
--   type of header value is determined by the type-inference, we only
--   specify the name of the header:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; case lookupResponseHeader @"1st" example2 of { Header b -&gt; b ; _ -&gt; False }
--   True
--   </pre>
lookupResponseHeader :: HasResponseHeader h a headers => Headers headers r -> ResponseHeader h a

-- | Deliberately do not add a header to a value.
--   
--   <pre>
--   &gt;&gt;&gt; let example1 = noHeader "hi" :: Headers '[Header "someheader" Int] String
--   
--   &gt;&gt;&gt; getHeaders example1
--   []
--   </pre>
noHeader :: AddHeader h v orig new => orig -> new

-- | Endpoint for plugging in your own Wai <tt>Application</tt>s.
--   
--   The given <tt>Application</tt> will get the request as received by the
--   server, potentially with a modified (stripped) <tt>pathInfo</tt> if
--   the <tt>Application</tt> is being routed with <a>:&gt;</a>.
--   
--   In addition to just letting you plug in your existing WAI
--   <tt>Application</tt>s, this can also be used with functions from
--   <a>Servant.Server.StaticFiles</a> to serve static files stored in a
--   particular directory on your filesystem
data Raw

-- | Variant of <a>Raw</a> that lets you access the underlying monadic
--   context to process the request.
data RawM

-- | Parse value from HTTP API data.
--   
--   <b>WARNING</b>: Do not derive this using <tt>DeriveAnyClass</tt> as
--   the generated instance will loop indefinitely.
class () => FromHttpApiData a

-- | Parse URL path piece.
parseUrlPiece :: FromHttpApiData a => Text -> Either Text a

-- | Parse HTTP header value.
parseHeader :: FromHttpApiData a => ByteString -> Either Text a

-- | Parse query param value.
parseQueryParam :: FromHttpApiData a => Text -> Either Text a

-- | Convert value to HTTP API data.
--   
--   <b>WARNING</b>: Do not derive this using <tt>DeriveAnyClass</tt> as
--   the generated instance will loop indefinitely.
class () => ToHttpApiData a

-- | Convert to URL path piece.
toUrlPiece :: ToHttpApiData a => a -> Text

-- | Convert to a URL path piece, making sure to encode any special chars.
--   The default definition uses <tt><a>urlEncodeBuilder</a>
--   <a>False</a></tt> but this may be overriden with a more efficient
--   version.
toEncodedUrlPiece :: ToHttpApiData a => a -> Builder

-- | Convert to HTTP header value.
toHeader :: ToHttpApiData a => a -> ByteString

-- | Convert to query param value.
toQueryParam :: ToHttpApiData a => a -> Text

-- | Convert to URL query param, The default definition uses
--   <tt><a>urlEncodeBuilder</a> <a>True</a></tt> but this may be overriden
--   with a more efficient version.
toEncodedQueryParam :: ToHttpApiData a => a -> Builder

-- | A generalized Authentication combinator. Use this if you have a
--   non-standard authentication technique.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE.
data AuthProtect (tag :: k)

-- | Represents a general universal resource identifier using its component
--   parts.
--   
--   For example, for the URI
--   
--   <pre>
--   foo://anonymous@www.haskell.org:42/ghc?query#frag
--   </pre>
--   
--   the components are:
data () => URI
URI :: String -> Maybe URIAuth -> String -> String -> String -> URI

-- | <pre>
--   foo:
--   </pre>
[uriScheme] :: URI -> String

-- | <pre>
--   //anonymous@www.haskell.org:42
--   </pre>
[uriAuthority] :: URI -> Maybe URIAuth

-- | <pre>
--   /ghc
--   </pre>
[uriPath] :: URI -> String

-- | <pre>
--   ?query
--   </pre>
[uriQuery] :: URI -> String

-- | <pre>
--   #frag
--   </pre>
[uriFragment] :: URI -> String

-- | Construct a toLink for an endpoint.
class HasLink endpoint where {
    type MkLink endpoint (a :: *);
}
toLink :: HasLink endpoint => (Link -> a) -> Proxy endpoint -> Link -> MkLink endpoint a

-- | Closed type family, check if <tt>endpoint</tt> is within <tt>api</tt>.
--   Uses <tt><a>IsElem'</a></tt> if it exhausts all other options.
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("hello" :&gt; Get '[JSON] Int) SampleAPI))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem ("bye" :&gt; Get '[JSON] Int) SampleAPI))
--   ...
--   ... Could not ...
--   ...
--   </pre>
--   
--   An endpoint is considered within an api even if it is missing
--   combinators that don't affect the URL:
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (Header "h" Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ok (Proxy :: Proxy (IsElem (Get '[JSON] Int) (ReqBody '[JSON] Bool :&gt; Get '[JSON] Int)))
--   OK
--   </pre>
--   
--   <ul>
--   <li>N.B.:* <tt>IsElem a b</tt> can be seen as capturing the notion of
--   whether the URL represented by <tt>a</tt> would match the URL
--   represented by <tt>b</tt>, *not* whether a request represented by
--   <tt>a</tt> matches the endpoints serving <tt>b</tt> (for the latter,
--   use <a>IsIn</a>).</li>
--   </ul>
type family IsElem endpoint api :: Constraint

-- | You may use this type family to tell the type checker that your custom
--   type may be skipped as part of a link. This is useful for things like
--   <tt><a>QueryParam</a></tt> that are optional in a URI and do not
--   affect them if they are omitted.
--   
--   <pre>
--   &gt;&gt;&gt; data CustomThing
--   
--   &gt;&gt;&gt; type instance IsElem' e (CustomThing :&gt; s) = IsElem e s
--   </pre>
--   
--   Note that <tt><a>IsElem</a></tt> is called, which will mutually
--   recurse back to <tt><a>IsElem'</a></tt> if it exhausts all other
--   options again.
--   
--   Once you have written a <tt>HasLink</tt> instance for
--   <tt>CustomThing</tt> you are ready to go.
type family IsElem' a s :: Constraint

-- | A safe link datatype. The only way of constructing a <a>Link</a> is
--   using <a>safeLink</a>, which means any <a>Link</a> is guaranteed to be
--   part of the mentioned API.
data Link

-- | Create a valid (by construction) relative URI with query params.
--   
--   This function will only typecheck if <tt>endpoint</tt> is part of the
--   API <tt>api</tt>
safeLink :: forall endpoint api. (IsElem endpoint api, HasLink endpoint) => Proxy api -> Proxy endpoint -> MkLink endpoint Link

-- | Type-level <a>If</a>. <tt>If True a b</tt> ==&gt; <tt>a</tt>; <tt>If
--   False a b</tt> ==&gt; <tt>b</tt>
type family If (cond :: Bool) (tru :: k) (fls :: k) :: k
data () => SBool (b :: Bool)
[STrue] :: SBool 'True
[SFalse] :: SBool 'False
class () => SBoolI (b :: Bool)
sbool :: SBoolI b => SBool b


-- | This is a module containing an API with all <a>API</a> combinators. It
--   is used for testing only (in particular, checking that instances exist
--   for the core servant classes for each combinator).
module Servant.Test.ComprehensiveAPI
type GET = Get '[JSON] NoContent
type ComprehensiveAPI = ComprehensiveAPIWithoutStreamingOrRaw' (EmptyEndpoint :<|> StreamingEndpoint :<|> RawEndpoint)
type RawEndpoint = "raw" :> Raw
type StreamingEndpoint = "streaming" :> StreamBody' '[Description "netstring"] NetstringFraming JSON (SourceT IO Int) :> Stream 'GET 200 NetstringFraming JSON (SourceT IO Int)
type EmptyEndpoint = "empty-api" :> EmptyAPI
comprehensiveAPI :: Proxy ComprehensiveAPI
type ComprehensiveAPIWithoutRaw = ComprehensiveAPIWithoutStreamingOrRaw' (EmptyEndpoint :<|> StreamingEndpoint)
comprehensiveAPIWithoutRaw :: Proxy ComprehensiveAPIWithoutRaw
type ComprehensiveAPIWithoutStreaming = ComprehensiveAPIWithoutStreamingOrRaw' (EmptyEndpoint :<|> RawEndpoint)
comprehensiveAPIWithoutStreaming :: Proxy ComprehensiveAPIWithoutStreaming

-- | <tt>:: API -&gt; API</tt>, so we have linear structure of the API.
type ComprehensiveAPIWithoutStreamingOrRaw' endpoint = GET :<|> "get-int" :> Get '[JSON] Int :<|> "capture" :> Capture' '[Description "example description"] "bar" Int :> GET :<|> "capture-lenient" :> Capture' '[Lenient] "foo" Int :> GET :<|> "header" :> Header "foo" Int :> GET :<|> "header-lenient" :> Header' '[Required, Lenient] "bar" Int :> GET :<|> "http-version" :> HttpVersion :> GET :<|> "is-secure" :> IsSecure :> GET :<|> "param" :> QueryParam "foo" Int :> GET :<|> "param-lenient" :> QueryParam' '[Required, Lenient] "bar" Int :> GET :<|> "params" :> QueryParams "foo" Int :> GET :<|> "flag" :> QueryFlag "foo" :> GET :<|> "remote-host" :> RemoteHost :> GET :<|> "req-body" :> ReqBody '[JSON] Int :> GET :<|> "req-body-lenient" :> ReqBody' '[Lenient] '[JSON] Int :> GET :<|> "res-headers" :> Get '[JSON] (Headers '[Header "foo" Int] NoContent) :<|> "foo" :> GET :<|> "vault" :> Vault :> GET :<|> "post-no-content" :> PostNoContent :<|> "post-int" :> Verb 'POST 204 '[JSON] Int :<|> "named-context" :> WithNamedContext "foo" '[] GET :<|> "capture-all" :> CaptureAll "foo" Int :> GET :<|> "summary" :> Summary "foo" :> GET :<|> "description" :> Description "foo" :> GET :<|> "alternative" :> ("left" :> GET :<|> "right" :> GET) :<|> "fragment" :> Fragment Int :> GET :<|> "resource" :> WithResource Int :> GET :<|> endpoint
type ComprehensiveAPIWithoutStreamingOrRaw = ComprehensiveAPIWithoutStreamingOrRaw' EmptyEndpoint
comprehensiveAPIWithoutStreamingOrRaw :: Proxy ComprehensiveAPIWithoutStreamingOrRaw
