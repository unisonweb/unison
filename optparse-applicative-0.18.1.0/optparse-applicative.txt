-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities and combinators for parsing command line options
--   
--   optparse-applicative is a haskell library for parsing options on the
--   command line, and providing a powerful applicative interface for
--   composing them.
--   
--   optparse-applicative takes care of reading and validating the
--   arguments passed to the command line, handling and reporting errors,
--   generating a usage line, a comprehensive help screen, and enabling
--   context-sensitive bash, zsh, and fish completions.
--   
--   See the included README for detailed instructions and examples, which
--   is also available on github
--   <a>https://github.com/pcapriotti/optparse-applicative</a>.
@package optparse-applicative
@version 0.18.1.0

module Options.Applicative.Help.Levenshtein

-- | Calculate the Damerau-Levenshtein edit distance between two lists
--   (strings).
--   
--   This is modified from <a>https://wiki.haskell.org/Edit_distance</a>
--   and is originally from Lloyd Allison's paper "Lazy Dynamic-Programming
--   can be Eager"
--   
--   It's been changed though from Levenshtein to Damerau-Levenshtein,
--   which treats transposition of adjacent characters as one change
--   instead of two.
--   
--   Complexity O(|a|*(1 + editDistance a b))
editDistance :: Eq a => [a] -> [a] -> Int

module Options.Applicative.Help.Pretty

-- | Overloaded conversion to <a>Doc</a>.
--   
--   Laws:
--   
--   <ol>
--   <li>output should be pretty. :-)</li>
--   </ol>
class () => Pretty a

-- | <pre>
--   &gt;&gt;&gt; pretty 1 &lt;+&gt; pretty "hello" &lt;+&gt; pretty 1.234
--   1 hello 1.234
--   </pre>
pretty :: Pretty a => a -> Doc ann

-- | <tt><a>prettyList</a></tt> is only used to define the <tt>instance
--   <a>Pretty</a> a =&gt; <a>Pretty</a> [a]</tt>. In normal circumstances
--   only the <tt><a>pretty</a></tt> function is used.
--   
--   <pre>
--   &gt;&gt;&gt; prettyList [1, 23, 456]
--   [1, 23, 456]
--   </pre>
prettyList :: Pretty a => [a] -> Doc ann

-- | The data type <tt>SimpleDocStream</tt> represents laid out documents
--   and is used by the display functions.
--   
--   A simplified view is that <tt><a>Doc</a> =
--   [<a>SimpleDocStream</a>]</tt>, and the layout functions pick one of
--   the <a>SimpleDocStream</a>s based on which one fits the layout
--   constraints best. This means that <a>SimpleDocStream</a> has all
--   complexity contained in <a>Doc</a> resolved, making it very easy to
--   convert it to other formats, such as plain text or terminal output.
--   
--   To write your own <tt><a>Doc</a></tt> to X converter, it is therefore
--   sufficient to convert from <tt><a>SimpleDocStream</a></tt>. The
--   »Render« submodules provide some built-in converters to do so, and
--   helpers to create own ones.
data () => SimpleDocStream ann
SFail :: SimpleDocStream ann
SEmpty :: SimpleDocStream ann
SChar :: !Char -> SimpleDocStream ann -> SimpleDocStream ann

-- | <a>length</a> is <i>O(n)</i>, so we cache it in the <a>Int</a> field.
SText :: !Int -> !Text -> SimpleDocStream ann -> SimpleDocStream ann

-- | <tt>Int</tt> = indentation level for the (next) line
SLine :: !Int -> SimpleDocStream ann -> SimpleDocStream ann

-- | Add an annotation to the remaining document.
SAnnPush :: ann -> SimpleDocStream ann -> SimpleDocStream ann

-- | Remove a previously pushed annotation.
SAnnPop :: SimpleDocStream ann -> SimpleDocStream ann

-- | Options to influence the layout algorithms.
newtype () => LayoutOptions
LayoutOptions :: PageWidth -> LayoutOptions
[layoutPageWidth] :: LayoutOptions -> PageWidth

-- | Maximum number of characters that fit in one line. The layout
--   algorithms will try not to exceed the set limit by inserting line
--   breaks when applicable (e.g. via <a>softline'</a>).
data () => PageWidth

-- | Layouters should not exceed the specified space per line.
--   
--   <ul>
--   <li>The <a>Int</a> is the number of characters, including whitespace,
--   that fit in a line. A typical value is 80.</li>
--   <li>The <a>Double</a> is the ribbon with, i.e. the fraction of the
--   total page width that can be printed on. This allows limiting the
--   length of printable text per line. Values must be between 0 and 1, and
--   0.4 to 1 is typical.</li>
--   </ul>
AvailablePerLine :: !Int -> !Double -> PageWidth

-- | Layouters should not introduce line breaks on their own.
Unbounded :: PageWidth

-- | Fusion depth parameter, used by <a>fuse</a>.
data () => FusionDepth

-- | Do not dive deep into nested documents, fusing mostly concatenations
--   of text nodes together.
Shallow :: FusionDepth

-- | Recurse into all parts of the <a>Doc</a>, including different layout
--   alternatives, and location-sensitive values such as created by
--   <a>nesting</a> which cannot be fused before, but only during, the
--   layout process. As a result, the performance cost of using deep fusion
--   is often hard to predict, and depends on the interplay between page
--   layout and document to prettyprint.
--   
--   This value should only be used if profiling shows it is significantly
--   faster than using <a>Shallow</a>.
Deep :: FusionDepth

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | <tt>(<a>group</a> x)</tt> tries laying out <tt>x</tt> into a single
--   line by removing the contained line breaks; if this does not fit the
--   page, or when a <a>hardline</a> within <tt>x</tt> prevents it from
--   being flattened, <tt>x</tt> is laid out without any changes.
--   
--   The <a>group</a> function is key to layouts that adapt to available
--   space nicely.
--   
--   See <a>vcat</a>, <a>line</a>, or <a>flatAlt</a> for examples that are
--   related, or make good use of it.
group :: Doc ann -> Doc ann

-- | <tt>(<a>fill</a> i x)</tt> lays out the document <tt>x</tt>. It then
--   appends <tt>space</tt>s until the width is equal to <tt>i</tt>. If the
--   width of <tt>x</tt> is already larger, nothing is appended.
--   
--   This function is quite useful in practice to output a list of
--   bindings:
--   
--   <pre>
--   &gt;&gt;&gt; let types = [("empty","Doc"), ("nest","Int -&gt; Doc -&gt; Doc"), ("fillSep","[Doc] -&gt; Doc")]
--   
--   &gt;&gt;&gt; let ptype (name, tp) = fill 5 (pretty name) &lt;+&gt; "::" &lt;+&gt; pretty tp
--   
--   &gt;&gt;&gt; "let" &lt;+&gt; align (vcat (map ptype types))
--   let empty :: Doc
--       nest  :: Int -&gt; Doc -&gt; Doc
--       fillSep :: [Doc] -&gt; Doc
--   </pre>
fill :: Int -> Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; parens "·"
--   (·)
--   </pre>
parens :: Doc ann -> Doc ann

-- | Haskell-inspired variant of <a>encloseSep</a> with braces and comma as
--   separator.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = list (map pretty [1,20,300,4000])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 80 doc
--   [1, 20, 300, 4000]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 doc
--   [ 1
--   , 20
--   , 300
--   , 4000 ]
--   </pre>
list :: [Doc ann] -> Doc ann

-- | <tt>(x <a>&lt;+&gt;</a> y)</tt> concatenates document <tt>x</tt> and
--   <tt>y</tt> with a <tt><tt>space</tt></tt> in between.
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &lt;+&gt; "world"
--   hello world
--   </pre>
--   
--   <pre>
--   x <a>&lt;+&gt;</a> y = x <a>&lt;&gt;</a> <tt>space</tt> <a>&lt;&gt;</a> y
--   </pre>
(<+>) :: Doc ann -> Doc ann -> Doc ann
infixr 6 <+>

-- | Add an annotation to a <tt><a>Doc</a></tt>. This annotation can then
--   be used by the renderer to e.g. add color to certain parts of the
--   output. For a full tutorial example on how to use it, see the
--   <a>Prettyprinter.Render.Tutorials.StackMachineTutorial</a> or
--   <a>Prettyprinter.Render.Tutorials.TreeRenderingTutorial</a> modules.
--   
--   This function is only relevant for custom formats with their own
--   annotations, and not relevant for basic prettyprinting. The predefined
--   renderers, e.g. <a>Prettyprinter.Render.Text</a>, should be enough for
--   the most common needs.
annotate :: ann -> Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; semi
--   ;
--   </pre>
semi :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; comma
--   ,
--   </pre>
comma :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; colon
--   :
--   </pre>
colon :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; "a" &lt;&gt; space &lt;&gt; "b"
--   a b
--   </pre>
--   
--   This is mostly used via <tt><a>&lt;+&gt;</a></tt>,
--   
--   <pre>
--   &gt;&gt;&gt; "a" &lt;+&gt; "b"
--   a b
--   </pre>
space :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; equals
--   =
--   </pre>
equals :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; lparen
--   (
--   </pre>
lparen :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; rparen
--   )
--   </pre>
rparen :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; lbrace
--   {
--   </pre>
lbrace :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; rbrace
--   }
--   </pre>
rbrace :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; brackets "·"
--   [·]
--   </pre>
brackets :: Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; braces "·"
--   {·}
--   </pre>
braces :: Doc ann -> Doc ann

-- | <tt>(<a>hcat</a> xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt><a>&lt;&gt;</a></tt> (i.e. without any spacing).
--   
--   It is provided only for consistency, since it is identical to
--   <a>mconcat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = Util.words "lorem ipsum dolor"
--   
--   &gt;&gt;&gt; hcat docs
--   loremipsumdolor
--   </pre>
hcat :: [Doc ann] -> Doc ann

-- | <tt>(<a>hsep</a> xs)</tt> concatenates all documents <tt>xs</tt>
--   horizontally with <tt><a>&lt;+&gt;</a></tt>, i.e. it puts a space
--   between all entries.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = Util.words "lorem ipsum dolor sit amet"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hsep docs
--   lorem ipsum dolor sit amet
--   </pre>
--   
--   <tt><a>hsep</a></tt> does not introduce line breaks on its own, even
--   when the page is too narrow:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 5 (hsep docs)
--   lorem ipsum dolor sit amet
--   </pre>
--   
--   For automatic line breaks, consider using <a>fillSep</a> instead.
hsep :: [Doc ann] -> Doc ann

-- | <tt>(<a>vcat</a> xs)</tt> vertically concatenates the documents
--   <tt>xs</tt>. If it is <a>group</a>ed, the line breaks are removed.
--   
--   In other words <tt><a>vcat</a></tt> is like <tt><a>vsep</a></tt>, with
--   newlines removed instead of replaced by <tt>space</tt>s.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = Util.words "lorem ipsum dolor"
--   
--   &gt;&gt;&gt; vcat docs
--   lorem
--   ipsum
--   dolor
--   
--   &gt;&gt;&gt; group (vcat docs)
--   loremipsumdolor
--   </pre>
--   
--   Since <a>group</a>ing a <a>vcat</a> is rather common, <a>cat</a> is a
--   built-in shortcut for it.
vcat :: [Doc ann] -> Doc ann

-- | <tt>(<a>nest</a> i x)</tt> lays out the document <tt>x</tt> with the
--   current nesting level (indentation of the following lines) increased
--   by <tt>i</tt>. Negative values are allowed, and decrease the nesting
--   level accordingly.
--   
--   <pre>
--   &gt;&gt;&gt; vsep [nest 4 (vsep ["lorem", "ipsum", "dolor"]), "sit", "amet"]
--   lorem
--       ipsum
--       dolor
--   sit
--   amet
--   </pre>
--   
--   See also
--   
--   <ul>
--   <li><a>hang</a> (<a>nest</a> relative to current cursor position
--   instead of current nesting level)</li>
--   <li><a>align</a> (set nesting level to current cursor position)</li>
--   <li><a>indent</a> (increase indentation on the spot, padding with
--   spaces).</li>
--   </ul>
nest :: Int -> Doc ann -> Doc ann

-- | <tt>(<a>hang</a> i x)</tt> lays out the document <tt>x</tt> with a
--   nesting level set to the <i>current column</i> plus <tt>i</tt>.
--   Negative values are allowed, and decrease the nesting level
--   accordingly.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = reflow "Indenting these words with hang"
--   
--   &gt;&gt;&gt; putDocW 24 ("prefix" &lt;+&gt; hang 4 doc)
--   prefix Indenting these
--              words with
--              hang
--   </pre>
--   
--   This differs from <a>nest</a>, which is based on the <i>current
--   nesting level</i> plus <tt>i</tt>. When you're not sure, try the more
--   efficient <a>nest</a> first. In our example, this would yield
--   
--   <pre>
--   &gt;&gt;&gt; let doc = reflow "Indenting these words with nest"
--   
--   &gt;&gt;&gt; putDocW 24 ("prefix" &lt;+&gt; nest 4 doc)
--   prefix Indenting these
--       words with nest
--   </pre>
--   
--   <pre>
--   <a>hang</a> i doc = <a>align</a> (<a>nest</a> i doc)
--   </pre>
hang :: Int -> Doc ann -> Doc ann

-- | <tt>(<a>punctuate</a> p xs)</tt> appends <tt>p</tt> to all but the
--   last document in <tt>xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = punctuate comma (Util.words "lorem ipsum dolor sit amet")
--   
--   &gt;&gt;&gt; putDocW 80 (hsep docs)
--   lorem, ipsum, dolor, sit, amet
--   </pre>
--   
--   The separators are put at the end of the entries, which we can see if
--   we position the result vertically:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 20 (vsep docs)
--   lorem,
--   ipsum,
--   dolor,
--   sit,
--   amet
--   </pre>
--   
--   If you want put the commas in front of their elements instead of at
--   the end, you should use <a>tupled</a> or, in general,
--   <a>encloseSep</a>.
punctuate :: Doc ann -> [Doc ann] -> [Doc ann]

-- | <tt>(<a>sep</a> xs)</tt> tries laying out the documents <tt>xs</tt>
--   separated with <tt>space</tt>s, and if this does not fit the page,
--   separates them with newlines. This is what differentiates it from
--   <a>vsep</a>, which always lays out its contents beneath each other.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "prefix" &lt;+&gt; sep ["text", "to", "lay", "out"]
--   
--   &gt;&gt;&gt; putDocW 80 doc
--   prefix text to lay out
--   </pre>
--   
--   With a narrower layout, the entries are separated by newlines:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 20 doc
--   prefix text
--   to
--   lay
--   out
--   </pre>
--   
--   <pre>
--   <a>sep</a> = <a>group</a> . <a>vsep</a>
--   </pre>
sep :: [Doc ann] -> Doc ann

-- | <tt>(<a>cat</a> xs)</tt> tries laying out the documents <tt>xs</tt>
--   separated with nothing, and if this does not fit the page, separates
--   them with newlines. This is what differentiates it from <a>vcat</a>,
--   which always lays out its contents beneath each other.
--   
--   <pre>
--   &gt;&gt;&gt; let docs = Util.words "lorem ipsum dolor"
--   
--   &gt;&gt;&gt; putDocW 80 ("Docs:" &lt;+&gt; cat docs)
--   Docs: loremipsumdolor
--   </pre>
--   
--   When there is enough space, the documents are put above one another:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 ("Docs:" &lt;+&gt; cat docs)
--   Docs: lorem
--   ipsum
--   dolor
--   </pre>
--   
--   <pre>
--   <a>cat</a> = <a>group</a> . <a>vcat</a>
--   </pre>
cat :: [Doc ann] -> Doc ann

-- | <tt>(<a>indent</a> i x)</tt> indents document <tt>x</tt> by <tt>i</tt>
--   columns, starting from the current cursor position.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = reflow "The indent function indents these words!"
--   
--   &gt;&gt;&gt; putDocW 24 ("prefix" &lt;&gt; indent 4 doc)
--   prefix    The indent
--             function
--             indents these
--             words!
--   </pre>
--   
--   <pre>
--   <a>indent</a> i d = <a>hang</a> i ({i spaces} &lt;&gt; d)
--   </pre>
indent :: Int -> Doc ann -> Doc ann

-- | Convenience function to convert a <a>Show</a>able value to a
--   <a>Doc</a>. If the <a>String</a> does not contain newlines, consider
--   using the more performant <a>unsafeViaShow</a>.
viaShow :: Show a => a -> Doc ann

-- | Convenience function to convert a <a>Show</a>able value /that must not
--   contain newlines/ to a <a>Doc</a>. If there may be newlines, use
--   <a>viaShow</a> instead.
unsafeViaShow :: Show a => a -> Doc ann

-- | The empty document behaves like <tt>(<a>pretty</a> "")</tt>, so it has
--   a height of 1. This may lead to surprising behaviour if we expect it
--   to bear no weight inside e.g. <a>vcat</a>, where we get an empty line
--   of output from it (<tt>parens</tt> for visibility only):
--   
--   <pre>
--   &gt;&gt;&gt; vsep ["hello", parens emptyDoc, "world"]
--   hello
--   ()
--   world
--   </pre>
--   
--   Together with <a>&lt;&gt;</a>, <a>emptyDoc</a> forms the <a>Monoid</a>
--   <a>Doc</a>.
emptyDoc :: Doc ann

-- | The <tt><a>line</a></tt> document advances to the next line and
--   indents to the current nesting level.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "lorem ipsum" &lt;&gt; line &lt;&gt; "dolor sit amet"
--   
--   &gt;&gt;&gt; doc
--   lorem ipsum
--   dolor sit amet
--   </pre>
--   
--   <tt><a>line</a></tt> behaves like <tt><tt>space</tt></tt> if the line
--   break is undone by <a>group</a>:
--   
--   <pre>
--   &gt;&gt;&gt; group doc
--   lorem ipsum dolor sit amet
--   </pre>
line :: Doc ann

-- | <tt><a>line'</a></tt> is like <tt><a>line</a></tt>, but behaves like
--   <tt><a>mempty</a></tt> if the line break is undone by <a>group</a>
--   (instead of <tt><tt>space</tt></tt>).
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "lorem ipsum" &lt;&gt; line' &lt;&gt; "dolor sit amet"
--   
--   &gt;&gt;&gt; doc
--   lorem ipsum
--   dolor sit amet
--   
--   &gt;&gt;&gt; group doc
--   lorem ipsumdolor sit amet
--   </pre>
line' :: Doc ann

-- | <tt>softline</tt> behaves like <tt><tt>space</tt></tt> if the
--   resulting output fits the page, otherwise like <tt><a>line</a></tt>.
--   
--   Here, we have enough space to put everything in one line:
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "lorem ipsum" &lt;&gt; softline &lt;&gt; "dolor sit amet"
--   
--   &gt;&gt;&gt; putDocW 80 doc
--   lorem ipsum dolor sit amet
--   </pre>
--   
--   If we narrow the page to width 10, the layouter produces a line break:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 doc
--   lorem ipsum
--   dolor sit amet
--   </pre>
--   
--   <pre>
--   <a>softline</a> = <a>group</a> <a>line</a>
--   </pre>
softline :: Doc ann

-- | <tt><a>softline'</a></tt> is like <tt><a>softline</a></tt>, but
--   behaves like <tt><a>mempty</a></tt> if the resulting output does not
--   fit on the page (instead of <tt><tt>space</tt></tt>). In other words,
--   <tt><a>line</a></tt> is to <tt><a>line'</a></tt> how
--   <tt><a>softline</a></tt> is to <tt><a>softline'</a></tt>.
--   
--   With enough space, we get direct concatenation:
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "ThisWord" &lt;&gt; softline' &lt;&gt; "IsWayTooLong"
--   
--   &gt;&gt;&gt; putDocW 80 doc
--   ThisWordIsWayTooLong
--   </pre>
--   
--   If we narrow the page to width 10, the layouter produces a line break:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 doc
--   ThisWord
--   IsWayTooLong
--   </pre>
--   
--   <pre>
--   <a>softline'</a> = <a>group</a> <a>line'</a>
--   </pre>
softline' :: Doc ann

-- | A <tt><a>hardline</a></tt> is <i>always</i> laid out as a line break,
--   even when <a>group</a>ed or when there is plenty of space. Note that
--   it might still be simply discarded if it is part of a <a>flatAlt</a>
--   inside a <a>group</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "lorem ipsum" &lt;&gt; hardline &lt;&gt; "dolor sit amet"
--   
--   &gt;&gt;&gt; putDocW 1000 doc
--   lorem ipsum
--   dolor sit amet
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; group doc
--   lorem ipsum
--   dolor sit amet
--   </pre>
hardline :: Doc ann

-- | By default, <tt>(<a>flatAlt</a> x y)</tt> renders as <tt>x</tt>.
--   However when <a>group</a>ed, <tt>y</tt> will be preferred, with
--   <tt>x</tt> as the fallback for the case when <tt>y</tt> doesn't fit.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = flatAlt "a" "b"
--   
--   &gt;&gt;&gt; putDoc doc
--   a
--   
--   &gt;&gt;&gt; putDoc (group doc)
--   b
--   
--   &gt;&gt;&gt; putDocW 0 (group doc)
--   a
--   </pre>
--   
--   <a>flatAlt</a> is particularly useful for defining conditional
--   separators such as
--   
--   <pre>
--   softline = <a>group</a> (<a>flatAlt</a> <a>hardline</a> " ")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let hello = "Hello" &lt;&gt; softline &lt;&gt; "world!"
--   
--   &gt;&gt;&gt; putDocW 12 hello
--   Hello world!
--   
--   &gt;&gt;&gt; putDocW 11 hello
--   Hello
--   world!
--   </pre>
--   
--   <h3><b>Example: Haskell's do-notation</b></h3>
--   
--   We can use this to render Haskell's do-notation nicely:
--   
--   <pre>
--   &gt;&gt;&gt; let open        = flatAlt "" "{ "
--   
--   &gt;&gt;&gt; let close       = flatAlt "" " }"
--   
--   &gt;&gt;&gt; let separator   = flatAlt "" "; "
--   
--   &gt;&gt;&gt; let prettyDo xs = group ("do" &lt;+&gt; align (encloseSep open close separator xs))
--   
--   &gt;&gt;&gt; let statements  = ["name:_ &lt;- getArgs", "let greet = \"Hello, \" &lt;&gt; name", "putStrLn greet"]
--   </pre>
--   
--   This is put into a single line with <tt>{;}</tt> style if it fits:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 80 (prettyDo statements)
--   do { name:_ &lt;- getArgs; let greet = "Hello, " &lt;&gt; name; putStrLn greet }
--   </pre>
--   
--   When there is not enough space the statements are broken up into lines
--   nicely:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 (prettyDo statements)
--   do name:_ &lt;- getArgs
--      let greet = "Hello, " &lt;&gt; name
--      putStrLn greet
--   </pre>
--   
--   <h3>Notes</h3>
--   
--   Users should be careful to choose <tt>x</tt> to be less wide than
--   <tt>y</tt>. Otherwise, if <tt>y</tt> turns out not to fit the page, we
--   fall back on an even wider layout:
--   
--   <pre>
--   &gt;&gt;&gt; let ugly = group (flatAlt "even wider" "too wide")
--   
--   &gt;&gt;&gt; putDocW 7 ugly
--   even wider
--   </pre>
--   
--   Also note that <a>group</a> will flatten <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; putDoc (group (flatAlt "x" ("y" &lt;&gt; line &lt;&gt; "y")))
--   y y
--   </pre>
--   
--   This also means that an "unflattenable" <tt>y</tt> which contains a
--   hard linebreak will <i>never</i> be rendered:
--   
--   <pre>
--   &gt;&gt;&gt; putDoc (group (flatAlt "x" ("y" &lt;&gt; hardline &lt;&gt; "y")))
--   x
--   </pre>
flatAlt :: Doc ann -> Doc ann -> Doc ann

-- | <tt>(<a>align</a> x)</tt> lays out the document <tt>x</tt> with the
--   nesting level set to the current column. It is used for example to
--   implement <a>hang</a>.
--   
--   As an example, we will put a document right above another one,
--   regardless of the current nesting level. Without <a>align</a>ment, the
--   second line is put simply below everything we've had so far:
--   
--   <pre>
--   &gt;&gt;&gt; "lorem" &lt;+&gt; vsep ["ipsum", "dolor"]
--   lorem ipsum
--   dolor
--   </pre>
--   
--   If we add an <a>align</a> to the mix, the <tt><a>vsep</a></tt>'s
--   contents all start in the same column:
--   
--   <pre>
--   &gt;&gt;&gt; "lorem" &lt;+&gt; align (vsep ["ipsum", "dolor"])
--   lorem ipsum
--         dolor
--   </pre>
align :: Doc ann -> Doc ann

-- | <tt>(<a>encloseSep</a> l r sep xs)</tt> concatenates the documents
--   <tt>xs</tt> separated by <tt>sep</tt>, and encloses the resulting
--   document by <tt>l</tt> and <tt>r</tt>.
--   
--   The documents are laid out horizontally if that fits the page:
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "list" &lt;+&gt; align (encloseSep lbracket rbracket comma (map pretty [1,20,300,4000]))
--   
--   &gt;&gt;&gt; putDocW 80 doc
--   list [1,20,300,4000]
--   </pre>
--   
--   If there is not enough space, then the input is split into lines
--   entry-wise therwise they are laid out vertically, with separators put
--   in the front:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 doc
--   list [1
--        ,20
--        ,300
--        ,4000]
--   </pre>
--   
--   Note that <tt>doc</tt> contains an explicit call to <a>align</a> so
--   that the list items are aligned vertically.
--   
--   For putting separators at the end of entries instead, have a look at
--   <a>punctuate</a>.
encloseSep :: Doc ann -> Doc ann -> Doc ann -> [Doc ann] -> Doc ann

-- | Haskell-inspired variant of <a>encloseSep</a> with parentheses and
--   comma as separator.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = tupled (map pretty [1,20,300,4000])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 80 doc
--   (1, 20, 300, 4000)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 10 doc
--   ( 1
--   , 20
--   , 300
--   , 4000 )
--   </pre>
tupled :: [Doc ann] -> Doc ann

-- | Concatenate all documents element-wise with a binary function.
--   
--   <pre>
--   <a>concatWith</a> _ [] = <a>mempty</a>
--   <a>concatWith</a> (**) [x,y,z] = x ** y ** z
--   </pre>
--   
--   Multiple convenience definitions based on <a>concatWith</a> are
--   already predefined, for example:
--   
--   <pre>
--   <a>hsep</a>    = <a>concatWith</a> (<a>&lt;+&gt;</a>)
--   <a>fillSep</a> = <a>concatWith</a> (\x y -&gt; x <a>&lt;&gt;</a> <a>softline</a> <a>&lt;&gt;</a> y)
--   </pre>
--   
--   This is also useful to define customized joiners:
--   
--   <pre>
--   &gt;&gt;&gt; concatWith (surround dot) ["Prettyprinter", "Render", "Text"]
--   Prettyprinter.Render.Text
--   </pre>
concatWith :: Foldable t => (Doc ann -> Doc ann -> Doc ann) -> t (Doc ann) -> Doc ann

-- | <tt>(<a>vsep</a> xs)</tt> concatenates all documents <tt>xs</tt> above
--   each other. If a <a>group</a> undoes the line breaks inserted by
--   <tt>vsep</tt>, the documents are separated with a <tt>space</tt>
--   instead.
--   
--   Using <a>vsep</a> alone yields
--   
--   <pre>
--   &gt;&gt;&gt; "prefix" &lt;+&gt; vsep ["text", "to", "lay", "out"]
--   prefix text
--   to
--   lay
--   out
--   </pre>
--   
--   <a>group</a>ing a <a>vsep</a> separates the documents with a
--   <tt>space</tt> if it fits the page (and does nothing otherwise). See
--   the <tt><a>sep</a></tt> convenience function for this use case.
--   
--   The <a>align</a> function can be used to align the documents under
--   their first element:
--   
--   <pre>
--   &gt;&gt;&gt; "prefix" &lt;+&gt; align (vsep ["text", "to", "lay", "out"])
--   prefix text
--          to
--          lay
--          out
--   </pre>
--   
--   Since <a>group</a>ing a <a>vsep</a> is rather common, <a>sep</a> is a
--   built-in for doing that.
vsep :: [Doc ann] -> Doc ann

-- | <tt>(<a>fillSep</a> xs)</tt> concatenates the documents <tt>xs</tt>
--   horizontally with <tt><a>&lt;+&gt;</a></tt> as long as it fits the
--   page, then inserts a <tt><a>line</a></tt> and continues doing that for
--   all documents in <tt>xs</tt>. (<tt><a>line</a></tt> means that if
--   <a>group</a>ed, the documents are separated with a <tt>space</tt>
--   instead of newlines. Use <a>fillCat</a> if you do not want a
--   <tt>space</tt>.)
--   
--   Let's print some words to fill the line:
--   
--   <pre>
--   &gt;&gt;&gt; let docs = take 20 (cycle ["lorem", "ipsum", "dolor", "sit", "amet"])
--   
--   &gt;&gt;&gt; putDocW 80 ("Docs:" &lt;+&gt; fillSep docs)
--   Docs: lorem ipsum dolor sit amet lorem ipsum dolor sit amet lorem ipsum dolor
--   sit amet lorem ipsum dolor sit amet
--   </pre>
--   
--   The same document, printed at a width of only 40, yields
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 40 ("Docs:" &lt;+&gt; fillSep docs)
--   Docs: lorem ipsum dolor sit amet lorem
--   ipsum dolor sit amet lorem ipsum dolor
--   sit amet lorem ipsum dolor sit amet
--   </pre>
fillSep :: [Doc ann] -> Doc ann

-- | <tt>(<a>fillCat</a> xs)</tt> concatenates documents <tt>xs</tt>
--   horizontally with <tt><a>&lt;&gt;</a></tt> as long as it fits the
--   page, then inserts a <tt><a>line'</a></tt> and continues doing that
--   for all documents in <tt>xs</tt>. This is similar to how an ordinary
--   word processor lays out the text if you just keep typing after you hit
--   the maximum line length.
--   
--   (<tt><a>line'</a></tt> means that if <a>group</a>ed, the documents are
--   separated with nothing instead of newlines. See <a>fillSep</a> if you
--   want a <tt>space</tt> instead.)
--   
--   Observe the difference between <a>fillSep</a> and <a>fillCat</a>.
--   <a>fillSep</a> concatenates the entries <tt>space</tt>d when
--   <a>group</a>ed:
--   
--   <pre>
--   &gt;&gt;&gt; let docs = take 20 (cycle (["lorem", "ipsum", "dolor", "sit", "amet"]))
--   
--   &gt;&gt;&gt; putDocW 40 ("Grouped:" &lt;+&gt; group (fillSep docs))
--   Grouped: lorem ipsum dolor sit amet
--   lorem ipsum dolor sit amet lorem ipsum
--   dolor sit amet lorem ipsum dolor sit
--   amet
--   </pre>
--   
--   On the other hand, <a>fillCat</a> concatenates the entries directly
--   when <a>group</a>ed:
--   
--   <pre>
--   &gt;&gt;&gt; putDocW 40 ("Grouped:" &lt;+&gt; group (fillCat docs))
--   Grouped: loremipsumdolorsitametlorem
--   ipsumdolorsitametloremipsumdolorsitamet
--   loremipsumdolorsitamet
--   </pre>
fillCat :: [Doc ann] -> Doc ann

-- | Layout a document depending on which column it starts at. <a>align</a>
--   is implemented in terms of <a>column</a>.
--   
--   <pre>
--   &gt;&gt;&gt; column (\l -&gt; "Columns are" &lt;+&gt; pretty l &lt;&gt; "-based.")
--   Columns are 0-based.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "prefix" &lt;+&gt; column (\l -&gt; "| &lt;- column" &lt;+&gt; pretty l)
--   
--   &gt;&gt;&gt; vsep [indent n doc | n &lt;- [0,4,8]]
--   prefix | &lt;- column 7
--       prefix | &lt;- column 11
--           prefix | &lt;- column 15
--   </pre>
column :: (Int -> Doc ann) -> Doc ann

-- | Layout a document depending on the current <a>nest</a>ing level.
--   <a>align</a> is implemented in terms of <a>nesting</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = "prefix" &lt;+&gt; nesting (\l -&gt; brackets ("Nested:" &lt;+&gt; pretty l))
--   
--   &gt;&gt;&gt; vsep [indent n doc | n &lt;- [0,4,8]]
--   prefix [Nested: 0]
--       prefix [Nested: 4]
--           prefix [Nested: 8]
--   </pre>
nesting :: (Int -> Doc ann) -> Doc ann

-- | <tt>(<a>width</a> doc f)</tt> lays out the document <tt>doc</tt>, and
--   makes the column width of it available to a function.
--   
--   <pre>
--   &gt;&gt;&gt; let annotate doc = width (brackets doc) (\w -&gt; " &lt;- width:" &lt;+&gt; pretty w)
--   
--   &gt;&gt;&gt; align (vsep (map annotate ["---", "------", indent 3 "---", vsep ["---", indent 4 "---"]]))
--   [---] &lt;- width: 5
--   [------] &lt;- width: 8
--   [   ---] &lt;- width: 8
--   [---
--       ---] &lt;- width: 8
--   </pre>
width :: Doc ann -> (Int -> Doc ann) -> Doc ann

-- | Layout a document depending on the page width, if one has been
--   specified.
--   
--   <pre>
--   &gt;&gt;&gt; let prettyPageWidth (AvailablePerLine l r) = "Width:" &lt;+&gt; pretty l &lt;&gt; ", ribbon fraction:" &lt;+&gt; pretty r
--   
--   &gt;&gt;&gt; let doc = "prefix" &lt;+&gt; pageWidth (brackets . prettyPageWidth)
--   
--   &gt;&gt;&gt; putDocW 32 (vsep [indent n doc | n &lt;- [0,4,8]])
--   prefix [Width: 32, ribbon fraction: 1.0]
--       prefix [Width: 32, ribbon fraction: 1.0]
--           prefix [Width: 32, ribbon fraction: 1.0]
--   </pre>
pageWidth :: (PageWidth -> Doc ann) -> Doc ann

-- | <tt>(<a>fillBreak</a> i x)</tt> first lays out the document
--   <tt>x</tt>. It then appends <tt>space</tt>s until the width is equal
--   to <tt>i</tt>. If the width of <tt>x</tt> is already larger than
--   <tt>i</tt>, the nesting level is increased by <tt>i</tt> and a
--   <tt>line</tt> is appended. When we redefine <tt>ptype</tt> in the
--   example given in <a>fill</a> to use <tt><a>fillBreak</a></tt>, we get
--   a useful variation of the output:
--   
--   <pre>
--   &gt;&gt;&gt; let types = [("empty","Doc"), ("nest","Int -&gt; Doc -&gt; Doc"), ("fillSep","[Doc] -&gt; Doc")]
--   
--   &gt;&gt;&gt; let ptype (name, tp) = fillBreak 5 (pretty name) &lt;+&gt; "::" &lt;+&gt; pretty tp
--   
--   &gt;&gt;&gt; "let" &lt;+&gt; align (vcat (map ptype types))
--   let empty :: Doc
--       nest  :: Int -&gt; Doc -&gt; Doc
--       fillSep
--             :: [Doc] -&gt; Doc
--   </pre>
fillBreak :: Int -> Doc ann -> Doc ann

-- | <tt>(<a>plural</a> n one many)</tt> is <tt>one</tt> if <tt>n</tt> is
--   <tt>1</tt>, and <tt>many</tt> otherwise. A typical use case is adding
--   a plural "s".
--   
--   <pre>
--   &gt;&gt;&gt; let things = [True]
--   
--   &gt;&gt;&gt; let amount = length things
--   
--   &gt;&gt;&gt; pretty things &lt;+&gt; "has" &lt;+&gt; pretty amount &lt;+&gt; plural "entry" "entries" amount
--   [True] has 1 entry
--   </pre>
plural :: (Num amount, Eq amount) => doc -> doc -> amount -> doc

-- | <tt>(<a>enclose</a> l r x)</tt> encloses document <tt>x</tt> between
--   documents <tt>l</tt> and <tt>r</tt> using <tt><a>&lt;&gt;</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; enclose "A" "Z" "·"
--   A·Z
--   </pre>
--   
--   <pre>
--   <a>enclose</a> l r x = l <a>&lt;&gt;</a> x <a>&lt;&gt;</a> r
--   </pre>
enclose :: Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | <tt>(<a>surround</a> x l r)</tt> surrounds document <tt>x</tt> with
--   <tt>l</tt> and <tt>r</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; surround "·" "A" "Z"
--   A·Z
--   </pre>
--   
--   This is merely an argument reordering of <tt><a>enclose</a></tt>, but
--   allows for definitions like
--   
--   <pre>
--   &gt;&gt;&gt; concatWith (surround dot) ["Prettyprinter", "Render", "Text"]
--   Prettyprinter.Render.Text
--   </pre>
surround :: Doc ann -> Doc ann -> Doc ann -> Doc ann

-- | Remove all annotations.
--   
--   Although <a>unAnnotate</a> is idempotent with respect to rendering,
--   
--   <pre>
--   <a>unAnnotate</a> . <a>unAnnotate</a> = <a>unAnnotate</a>
--   </pre>
--   
--   it should not be used without caution, for each invocation traverses
--   the entire contained document. If possible, it is preferrable to
--   unannotate after producing the layout by using <a>unAnnotateS</a>.
unAnnotate :: Doc ann -> Doc xxx

-- | Change the annotation of a <a>Doc</a>ument.
--   
--   Useful in particular to embed documents with one form of annotation in
--   a more generally annotated document.
--   
--   Since this traverses the entire <tt><a>Doc</a></tt> tree, including
--   parts that are not rendered due to other layouts fitting better, it is
--   preferrable to reannotate after producing the layout by using
--   <tt><a>reAnnotateS</a></tt>.
--   
--   Since <tt><a>reAnnotate</a></tt> has the right type and satisfies
--   <tt>'reAnnotate id = id'</tt>, it is used to define the
--   <tt><a>Functor</a></tt> instance of <tt><a>Doc</a></tt>.
reAnnotate :: (ann -> ann') -> Doc ann -> Doc ann'

-- | Change the annotations of a <a>Doc</a>ument. Individual annotations
--   can be removed, changed, or replaced by multiple ones.
--   
--   This is a general function that combines <a>unAnnotate</a> and
--   <a>reAnnotate</a>, and it is useful for mapping semantic annotations
--   (such as »this is a keyword«) to display annotations (such as »this is
--   red and underlined«), because some backends may not care about certain
--   annotations, while others may.
--   
--   Annotations earlier in the new list will be applied earlier, i.e.
--   returning <tt>[Bold, Green]</tt> will result in a bold document that
--   contains green text, and not vice-versa.
--   
--   Since this traverses the entire <tt><a>Doc</a></tt> tree, including
--   parts that are not rendered due to other layouts fitting better, it is
--   preferrable to reannotate after producing the layout by using
--   <tt><a>alterAnnotationsS</a></tt>.
alterAnnotations :: (ann -> [ann']) -> Doc ann -> Doc ann'

-- | Remove all annotations. <a>unAnnotate</a> for <a>SimpleDocStream</a>.
unAnnotateS :: SimpleDocStream ann -> SimpleDocStream xxx

-- | Change the annotation of a document. <a>reAnnotate</a> for
--   <a>SimpleDocStream</a>.
reAnnotateS :: (ann -> ann') -> SimpleDocStream ann -> SimpleDocStream ann'

-- | Change the annotation of a document to a different annotation, or none
--   at all. <a>alterAnnotations</a> for <a>SimpleDocStream</a>.
--   
--   Note that the <a>Doc</a> version is more flexible, since it allows
--   changing a single annotation to multiple ones. (<a>SimpleDocTree</a>
--   restores this flexibility again.)
alterAnnotationsS :: (ann -> Maybe ann') -> SimpleDocStream ann -> SimpleDocStream ann'

-- | <tt>(<a>fuse</a> depth doc)</tt> combines text nodes so they can be
--   rendered more efficiently. A fused document is always laid out
--   identical to its unfused version.
--   
--   When laying a <a>Doc</a>ument out to a <a>SimpleDocStream</a>, every
--   component of the input is translated directly to the simpler output
--   format. This sometimes yields undesirable chunking when many pieces
--   have been concatenated together.
--   
--   For example
--   
--   <pre>
--   &gt;&gt;&gt; "a" &lt;&gt; "b" &lt;&gt; pretty 'c' &lt;&gt; "d"
--   abcd
--   </pre>
--   
--   results in a chain of four entries in a <a>SimpleDocStream</a>,
--   although this is fully equivalent to the tightly packed
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" :: Doc ann
--   abcd
--   </pre>
--   
--   which is only a single <a>SimpleDocStream</a> entry, and can be
--   processed faster.
--   
--   It is therefore a good idea to run <a>fuse</a> on concatenations of
--   lots of small strings that are used many times:
--   
--   <pre>
--   &gt;&gt;&gt; let oftenUsed = fuse Shallow ("a" &lt;&gt; "b" &lt;&gt; pretty 'c' &lt;&gt; "d")
--   
--   &gt;&gt;&gt; hsep (replicate 5 oftenUsed)
--   abcd abcd abcd abcd abcd
--   </pre>
fuse :: FusionDepth -> Doc ann -> Doc ann

-- | Remove all trailing space characters.
--   
--   This has some performance impact, because it does an entire additional
--   pass over the <a>SimpleDocStream</a>.
--   
--   No trimming will be done inside annotations, which are considered to
--   contain no (trimmable) whitespace, since the annotation might actually
--   be <i>about</i> the whitespace, for example a renderer that colors the
--   background of trailing whitespace, as e.g. <tt>git diff</tt> can be
--   configured to do.
--   
--   <i>Historical note:</i> Since v1.7.0, <a>layoutPretty</a> and
--   <a>layoutSmart</a> avoid producing the trailing whitespace that was
--   the original motivation for creating <a>removeTrailingWhitespace</a>.
--   See <a>https://github.com/quchen/prettyprinter/pull/139</a> for some
--   background info.
removeTrailingWhitespace :: SimpleDocStream ann -> SimpleDocStream ann

-- | The default layout options, suitable when you just want some output,
--   and don’t particularly care about the details. Used by the <a>Show</a>
--   instance, for example.
--   
--   <pre>
--   &gt;&gt;&gt; defaultLayoutOptions
--   LayoutOptions {layoutPageWidth = AvailablePerLine 80 1.0}
--   </pre>
defaultLayoutOptions :: LayoutOptions

-- | This is the default layout algorithm, and it is used by <a>show</a>,
--   <tt>putDoc</tt> and <tt>hPutDoc</tt>.
--   
--   <tt><a>layoutPretty</a></tt> commits to rendering something in a
--   certain way if the next element fits the layout constraints; in other
--   words, it has one <a>SimpleDocStream</a> element lookahead when
--   rendering. Consider using the smarter, but a bit less performant,
--   <tt><a>layoutSmart</a></tt> algorithm if the results seem to run off
--   to the right before having lots of line breaks.
layoutPretty :: LayoutOptions -> Doc ann -> SimpleDocStream ann

-- | A layout algorithm with more lookahead than <a>layoutPretty</a>, that
--   introduces line breaks earlier if the content does not (or will not,
--   rather) fit into one line.
--   
--   Consider the following python-ish document,
--   
--   <pre>
--   &gt;&gt;&gt; let fun x = hang 2 ("fun(" &lt;&gt; softline' &lt;&gt; x) &lt;&gt; ")"
--   
--   &gt;&gt;&gt; let doc = (fun . fun . fun . fun . fun) (align (list ["abcdef", "ghijklm"]))
--   </pre>
--   
--   which we’ll be rendering using the following pipeline (where the
--   layout algorithm has been left open):
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Text.IO as T
--   
--   &gt;&gt;&gt; import Prettyprinter.Render.Text
--   
--   &gt;&gt;&gt; let hr = pipe &lt;&gt; pretty (replicate (26-2) '-') &lt;&gt; pipe
--   
--   &gt;&gt;&gt; let go layouter x = (T.putStrLn . renderStrict . layouter (LayoutOptions (AvailablePerLine 26 1))) (vsep [hr, x, hr])
--   </pre>
--   
--   If we render this using <a>layoutPretty</a> with a page width of 26
--   characters per line, all the <tt>fun</tt> calls fit into the first
--   line so they will be put there:
--   
--   <pre>
--   &gt;&gt;&gt; go layoutPretty doc
--   |------------------------|
--   fun(fun(fun(fun(fun(
--                     [ abcdef
--                     , ghijklm ])))))
--   |------------------------|
--   </pre>
--   
--   Note that this exceeds the desired 26 character page width. The same
--   document, rendered with <tt><a>layoutSmart</a></tt>, fits the layout
--   contstraints:
--   
--   <pre>
--   &gt;&gt;&gt; go layoutSmart doc
--   |------------------------|
--   fun(
--     fun(
--       fun(
--         fun(
--           fun(
--             [ abcdef
--             , ghijklm ])))))
--   |------------------------|
--   </pre>
--   
--   The key difference between <a>layoutPretty</a> and <a>layoutSmart</a>
--   is that the latter will check the potential document until it
--   encounters a line with the same indentation or less than the start of
--   the document. Any line encountered earlier is assumed to belong to the
--   same syntactic structure. <a>layoutPretty</a> checks only the first
--   line.
--   
--   Consider for example the question of whether the <tt>A</tt>s fit into
--   the document below:
--   
--   <pre>
--   1 A
--   2   A
--   3  A
--   4 B
--   5   B
--   </pre>
--   
--   <a>layoutPretty</a> will check only line 1, ignoring whether e.g. line
--   2 might already be too wide. By contrast, <a>layoutSmart</a> stops
--   only once it reaches line 4, where the <tt>B</tt> has the same
--   indentation as the first <tt>A</tt>.
layoutSmart :: LayoutOptions -> Doc ann -> SimpleDocStream ann

-- | <tt>(layoutCompact x)</tt> lays out the document <tt>x</tt> without
--   adding any indentation and without preserving annotations. Since no
--   'pretty' printing is involved, this layouter is very fast. The
--   resulting output contains fewer characters than a prettyprinted
--   version and can be used for output that is read by other programs.
--   
--   <pre>
--   &gt;&gt;&gt; let doc = hang 4 (vsep ["lorem", "ipsum", hang 4 (vsep ["dolor", "sit"])])
--   
--   &gt;&gt;&gt; doc
--   lorem
--       ipsum
--       dolor
--           sit
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let putDocCompact = renderIO System.IO.stdout . layoutCompact
--   
--   &gt;&gt;&gt; putDocCompact doc
--   lorem
--   ipsum
--   dolor
--   sit
--   </pre>
layoutCompact :: Doc ann1 -> SimpleDocStream ann2

-- | <pre>
--   &gt;&gt;&gt; squotes "·"
--   '·'
--   </pre>
squotes :: Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; dquotes "·"
--   "·"
--   </pre>
dquotes :: Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; angles "·"
--   &lt;·&gt;
--   </pre>
angles :: Doc ann -> Doc ann

-- | <pre>
--   &gt;&gt;&gt; squote
--   '
--   </pre>
squote :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; dquote
--   "
--   </pre>
dquote :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; langle
--   &lt;
--   </pre>
langle :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; rangle
--   &gt;
--   </pre>
rangle :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; lbracket
--   [
--   </pre>
lbracket :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; rbracket
--   ]
--   </pre>
rbracket :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; dot
--   .
--   </pre>
dot :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; slash
--   /
--   </pre>
slash :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; backslash
--   \
--   </pre>
backslash :: Doc ann

-- | <pre>
--   &gt;&gt;&gt; pipe
--   |
--   </pre>
pipe :: Doc ann
type Doc = Doc AnsiStyle
type SimpleDoc = SimpleDocStream AnsiStyle
(.$.) :: Doc -> Doc -> Doc
(</>) :: Doc -> Doc -> Doc

-- | Render flattened text on this line, or start a new line before
--   rendering any text.
--   
--   This will also nest subsequent lines in the group.
groupOrNestLine :: Doc -> Doc

-- | Separate items in an alternative with a pipe.
--   
--   If the first document and the pipe don't fit on the line, then
--   mandatorily flow the next entry onto the following line.
--   
--   The (<a>//</a>) softbreak ensures that if the document does fit on the
--   line, there is at least a space, but it's possible for y to still
--   appear on the next line.
altSep :: Doc -> Doc -> Doc

-- | Printer hacks to get nice indentation for long commands and
--   subcommands.
--   
--   If we're starting this section over the desired width (usually 1/3 of
--   the ribbon), then we will make a line break, indent all of the usage,
--   and go.
--   
--   The ifAtRoot is an interesting clause. If this whole operation is put
--   under a <a>group</a> then the linebreak will disappear; then item d
--   will therefore not be at the starting column, and it won't be indented
--   more.
hangAtIfOver :: Int -> Int -> Doc -> Doc
prettyString :: Double -> Int -> Doc -> String

module Options.Applicative.Help.Chunk

-- | The free monoid on a semigroup <tt>a</tt>.
newtype Chunk a
Chunk :: Maybe a -> Chunk a
[unChunk] :: Chunk a -> Maybe a

-- | Given a semigroup structure on <tt>a</tt>, return a monoid structure
--   on 'Chunk a'.
--   
--   Note that this is <i>not</i> the same as <a>liftA2</a>.
chunked :: (a -> a -> a) -> Chunk a -> Chunk a -> Chunk a

-- | Concatenate a list into a Chunk. <a>listToChunk</a> satisfies:
--   
--   <pre>
--   isEmpty . listToChunk = null
--   listToChunk = mconcat . fmap pure
--   </pre>
listToChunk :: Semigroup a => [a] -> Chunk a

-- | Concatenate two <a>Chunk</a>s with a space in between. If one is
--   empty, this just returns the other one.
--   
--   Unlike <a>&lt;+&gt;</a> for <a>Doc</a>, this operation has a unit
--   element, namely the empty <a>Chunk</a>.
(<<+>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate two <a>Chunk</a>s with a softline in between. This is
--   exactly like <a>&lt;&lt;+&gt;&gt;</a>, but uses a softline instead of
--   a space.
(<</>>) :: Chunk Doc -> Chunk Doc -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically.
vcatChunks :: [Chunk Doc] -> Chunk Doc

-- | Concatenate <a>Chunk</a>s vertically separated by empty lines.
vsepChunks :: [Chunk Doc] -> Chunk Doc

-- | Whether a <a>Chunk</a> is empty. Note that something like 'pure
--   mempty' is not considered an empty chunk, even though the underlying
--   <a>Doc</a> is empty.
isEmpty :: Chunk a -> Bool

-- | Convert a <a>String</a> into a <a>Chunk</a>. This satisfies:
--   
--   <pre>
--   isEmpty . stringChunk = null
--   extractChunk . stringChunk = string
--   </pre>
stringChunk :: String -> Chunk Doc

-- | Convert a paragraph into a <a>Chunk</a>. The resulting chunk is
--   composed by the words of the original paragraph separated by
--   softlines, so it will be automatically word-wrapped when rendering the
--   underlying document.
--   
--   This satisfies:
--   
--   <pre>
--   isEmpty . paragraph = null . words
--   </pre>
paragraph :: String -> Chunk Doc

-- | Part of a constrained comonad instance.
--   
--   This is the counit of the adjunction between <a>Chunk</a> and the
--   forgetful functor from monoids to semigroups. It satisfies:
--   
--   <pre>
--   extractChunk . pure = id
--   extractChunk . fmap pure = id
--   </pre>
extractChunk :: Monoid a => Chunk a -> a

-- | Display pairs of strings in a table.
tabulate :: Int -> [(Doc, Doc)] -> Chunk Doc
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Functor Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Applicative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Alternative Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Monad Options.Applicative.Help.Chunk.Chunk
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.Semigroup a => GHC.Base.Monoid (Options.Applicative.Help.Chunk.Chunk a)
instance GHC.Base.MonadPlus Options.Applicative.Help.Chunk.Chunk

module Options.Applicative.Help.Types
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc

-- | Convert a help text to <a>String</a>.
renderHelp :: Int -> ParserHelp -> String
instance GHC.Show.Show Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Monoid Options.Applicative.Help.Types.ParserHelp
instance GHC.Base.Semigroup Options.Applicative.Help.Types.ParserHelp

module Options.Applicative.Types
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int

-- | A single option of a parser.
data Option a
Option :: OptReader a -> OptProperties -> Option a

-- | reader for this option
[optMain] :: Option a -> OptReader a

-- | properties of this option
[optProps] :: Option a -> OptProperties
data OptName
OptShort :: !Char -> OptName
OptLong :: !String -> OptName
isShortName :: OptName -> Bool
isLongName :: OptName -> Bool

-- | An <a>OptReader</a> defines whether an option matches an command line
--   argument.
data OptReader a

-- | option reader
OptReader :: [OptName] -> CReader a -> (String -> ParseError) -> OptReader a

-- | flag reader
FlagReader :: [OptName] -> !a -> OptReader a

-- | argument reader
ArgReader :: CReader a -> OptReader a

-- | command reader
CmdReader :: Maybe String -> [(String, ParserInfo a)] -> OptReader a

-- | Specification for an individual parser option.
data OptProperties
OptProperties :: OptVisibility -> Chunk Doc -> String -> Maybe String -> Bool -> Maybe (Doc -> Doc) -> OptProperties

-- | whether this flag is shown in the brief description
[propVisibility] :: OptProperties -> OptVisibility

-- | help text for this option
[propHelp] :: OptProperties -> Chunk Doc

-- | metavariable for this option
[propMetaVar] :: OptProperties -> String

-- | what to show in the help text as the default
[propShowDefault] :: OptProperties -> Maybe String

-- | whether the option is presented in global options text
[propShowGlobal] :: OptProperties -> Bool

-- | a function to run over the brief description
[propDescMod] :: OptProperties -> Maybe (Doc -> Doc)

-- | Visibility of an option in the help text.
data OptVisibility

-- | does not appear in the help text at all
Internal :: OptVisibility

-- | only visible in the full description
Hidden :: OptVisibility

-- | visible both in the full and brief descriptions
Visible :: OptVisibility
data Backtracking
Backtrack :: Backtracking
NoBacktrack :: Backtracking
SubparserInline :: Backtracking

-- | A newtype over 'ReaderT String Except', used by option readers.
newtype ReadM a
ReadM :: ReaderT String (Except ParseError) a -> ReadM a
[unReadM] :: ReadM a -> ReaderT String (Except ParseError) a

-- | Return the value being read.
readerAsk :: ReadM String

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a
data CReader a
CReader :: Completer -> ReadM a -> CReader a
[crCompleter] :: CReader a -> Completer
[crReader] :: CReader a -> ReadM a

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a
NilP :: Maybe a -> Parser a
OptP :: Option a -> Parser a
MultP :: Parser (x -> a) -> Parser x -> Parser a
AltP :: Parser a -> Parser a -> Parser a
BindP :: Parser x -> (x -> Parser a) -> Parser a
newtype ParserM r
ParserM :: (forall x. (r -> Parser x) -> Parser x) -> ParserM r
[runParserM] :: ParserM r -> forall x. (r -> Parser x) -> Parser x

-- | A shell complete function.
newtype Completer
Completer :: (String -> IO [String]) -> Completer
[runCompleter] :: Completer -> String -> IO [String]

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a
type Args = [String]

-- | Policy for how to handle options within the parse
data ArgPolicy

-- | The default policy, options and arguments can be interspersed. A `--`
--   option can be passed to ensure all following commands are treated as
--   arguments.
Intersperse :: ArgPolicy

-- | Options must all come before arguments, once a single positional
--   argument or subcommand is parsed, all remaining arguments are treated
--   as positionals. A `--` option can be passed if the first positional
--   one needs starts with <a>-</a>.
NoIntersperse :: ArgPolicy

-- | No options are parsed at all, all arguments are treated as
--   positionals. Is the policy used after `--` is encountered.
AllPositionals :: ArgPolicy

-- | Options and arguments can be interspersed, but if a given option is
--   not found, it is treated as a positional argument. This is sometimes
--   useful if one is passing through most options to another tool, but are
--   supplying just a few of their own options.
ForwardOptions :: ArgPolicy
newtype ArgumentReachability
ArgumentReachability :: Bool -> ArgumentReachability

-- | If the result is a positional, if it can't be accessed in the current
--   parser position ( first arg )
[argumentIsUnreachable] :: ArgumentReachability -> Bool

-- | This type encapsulates whether an <a>AltNode</a> of an <a>OptTree</a>
--   should be displayed with brackets around it.
data AltNodeType
MarkDefault :: AltNodeType
NoDefault :: AltNodeType
data OptTree a
Leaf :: a -> OptTree a
MultNode :: [OptTree a] -> OptTree a
AltNode :: AltNodeType -> [OptTree a] -> OptTree a
BindNode :: OptTree a -> OptTree a
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
data SomeParser
SomeParser :: Parser a -> SomeParser

-- | Subparser context, containing the <tt>name</tt> of the subparser and
--   its parser info. Used by parserFailure to display relevant usage
--   information when parsing inside a subparser fails.
data Context
Context :: String -> ParserInfo a -> Context
data IsCmdStart
CmdStart :: IsCmdStart
CmdCont :: IsCmdStart
fromM :: ParserM a -> Parser a
oneM :: Parser a -> ParserM a
manyM :: Parser a -> ParserM [a]
someM :: Parser a -> ParserM [a]
filterOptional :: OptTree a -> OptTree a
optVisibility :: Option a -> OptVisibility
optMetaVar :: Option a -> String
optHelp :: Option a -> Chunk Doc
optShowDefault :: Option a -> Maybe String
optDescMod :: Option a -> Maybe (Doc -> Doc)
instance GHC.Show.Show Options.Applicative.Types.IsCmdStart
instance GHC.Show.Show Options.Applicative.Types.Backtracking
instance GHC.Classes.Eq Options.Applicative.Types.Backtracking
instance GHC.Show.Show Options.Applicative.Types.ParserPrefs
instance GHC.Classes.Eq Options.Applicative.Types.ParserPrefs
instance GHC.Show.Show Options.Applicative.Types.OptName
instance GHC.Classes.Ord Options.Applicative.Types.OptName
instance GHC.Classes.Eq Options.Applicative.Types.OptName
instance GHC.Show.Show Options.Applicative.Types.OptVisibility
instance GHC.Classes.Ord Options.Applicative.Types.OptVisibility
instance GHC.Classes.Eq Options.Applicative.Types.OptVisibility
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.ParserResult a)
instance GHC.Show.Show Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Ord Options.Applicative.Types.ArgPolicy
instance GHC.Classes.Eq Options.Applicative.Types.ArgPolicy
instance GHC.Show.Show Options.Applicative.Types.ArgumentReachability
instance GHC.Classes.Eq Options.Applicative.Types.ArgumentReachability
instance GHC.Classes.Eq Options.Applicative.Types.AltNodeType
instance GHC.Show.Show Options.Applicative.Types.AltNodeType
instance GHC.Show.Show a => GHC.Show.Show (Options.Applicative.Types.OptTree a)
instance GHC.Base.Monad Options.Applicative.Types.ParserM
instance GHC.Base.Functor Options.Applicative.Types.ParserM
instance GHC.Base.Applicative Options.Applicative.Types.ParserM
instance GHC.Base.Monoid Options.Applicative.Types.ParseError
instance GHC.Base.Semigroup Options.Applicative.Types.ParseError
instance GHC.Base.Functor Options.Applicative.Types.ParserInfo
instance GHC.Show.Show (Options.Applicative.Types.Option a)
instance GHC.Base.Functor Options.Applicative.Types.Option
instance GHC.Base.Functor Options.Applicative.Types.ReadM
instance GHC.Base.Applicative Options.Applicative.Types.ReadM
instance GHC.Base.Alternative Options.Applicative.Types.ReadM
instance GHC.Base.Monad Options.Applicative.Types.ReadM
instance Control.Monad.Fail.MonadFail Options.Applicative.Types.ReadM
instance GHC.Base.MonadPlus Options.Applicative.Types.ReadM
instance GHC.Base.Functor Options.Applicative.Types.CReader
instance GHC.Base.Functor Options.Applicative.Types.OptReader
instance GHC.Base.Functor Options.Applicative.Types.Parser
instance GHC.Base.Applicative Options.Applicative.Types.Parser
instance GHC.Base.Alternative Options.Applicative.Types.Parser
instance GHC.Base.Functor Options.Applicative.Types.ParserResult
instance GHC.Base.Applicative Options.Applicative.Types.ParserResult
instance GHC.Base.Monad Options.Applicative.Types.ParserResult
instance GHC.Show.Show h => GHC.Show.Show (Options.Applicative.Types.ParserFailure h)
instance GHC.Base.Functor Options.Applicative.Types.ParserFailure
instance GHC.Show.Show Options.Applicative.Types.CompletionResult
instance GHC.Base.Semigroup Options.Applicative.Types.Completer
instance GHC.Base.Monoid Options.Applicative.Types.Completer
instance GHC.Show.Show Options.Applicative.Types.OptProperties

module Options.Applicative.NonEmpty

-- | Sequences an action one or more times.
--   
--   Functionally identical to <a>some1</a>, but is preferred as it gives a
--   nicer help text.
some1 :: Parser a -> Parser (NonEmpty a)

module Options.Applicative.Internal
data P a
class (Alternative m, MonadPlus m) => MonadP m
enterContext :: MonadP m => String -> ParserInfo a -> m ()
exitContext :: MonadP m => m ()
getPrefs :: MonadP m => m ParserPrefs
missingArgP :: MonadP m => ParseError -> Completer -> m a
errorP :: MonadP m => ParseError -> m a
exitP :: MonadP m => IsCmdStart -> ArgPolicy -> Parser b -> Maybe a -> m a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
uncons :: [a] -> Maybe (a, [a])
hoistMaybe :: MonadPlus m => Maybe a -> m a
hoistEither :: MonadP m => Either ParseError a -> m a
runReadM :: MonadP m => ReadM a -> String -> m a
withReadM :: (String -> String) -> ReadM a -> ReadM a
runP :: P a -> ParserPrefs -> (Either ParseError a, [Context])
data Completion a
runCompletion :: Completion r -> ParserPrefs -> Maybe (Either (SomeParser, ArgPolicy) Completer)
contextNames :: [Context] -> [String]
data ListT m a
takeListT :: Monad m => Int -> ListT m a -> ListT m a
runListT :: Monad m => ListT m a -> m [a]
hoistList :: Alternative m => [a] -> m a
data NondetT m a
cut :: Monad m => NondetT m ()
(<!>) :: Monad m => NondetT m a -> NondetT m a -> NondetT m a
disamb :: Monad m => Bool -> NondetT m a -> m (Maybe a)
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.NondetT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.NondetT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.NondetT
instance GHC.Base.Monad m => GHC.Base.Functor (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Options.Applicative.Internal.ListT m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Options.Applicative.Internal.ListT m)
instance Control.Monad.Trans.Class.MonadTrans Options.Applicative.Internal.ListT
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Options.Applicative.Internal.ListT m)
instance GHC.Base.Functor Options.Applicative.Internal.Completion
instance GHC.Base.Applicative Options.Applicative.Internal.Completion
instance GHC.Base.Alternative Options.Applicative.Internal.Completion
instance GHC.Base.Monad Options.Applicative.Internal.Completion
instance GHC.Base.MonadPlus Options.Applicative.Internal.Completion
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.Completion
instance GHC.Base.Functor Options.Applicative.Internal.ComplResult
instance GHC.Base.Applicative Options.Applicative.Internal.ComplResult
instance GHC.Base.Monad Options.Applicative.Internal.ComplResult
instance GHC.Base.Functor Options.Applicative.Internal.P
instance GHC.Base.Applicative Options.Applicative.Internal.P
instance GHC.Base.Alternative Options.Applicative.Internal.P
instance GHC.Base.Monad Options.Applicative.Internal.P
instance GHC.Base.MonadPlus Options.Applicative.Internal.P
instance Options.Applicative.Internal.MonadP Options.Applicative.Internal.P

module Options.Applicative.Common

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Create a parser composed of a single option.
liftOpt :: Option a -> Parser a
showOption :: OptName -> String

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int
runParserInfo :: MonadP m => ParserInfo a -> Args -> m a
runParserFully :: MonadP m => ArgPolicy -> Parser a -> Args -> m a
runParserStep :: MonadP m => ArgPolicy -> Parser a -> String -> Args -> m (Maybe (Parser a), Args)

-- | Apply a <a>Parser</a> to a command line, and return a result and
--   leftover arguments. This function returns an error if any parsing
--   error occurs, or if any options are missing and don't have a default
--   value.
runParser :: MonadP m => ArgPolicy -> IsCmdStart -> Parser a -> Args -> m (a, Args)

-- | The default value of a <a>Parser</a>. This function returns an error
--   if any of the options don't have a default value.
evalParser :: Parser a -> Maybe a

-- | Map a polymorphic function over all the options of a parser, and
--   collect the results in a list.
mapParser :: (forall x. ArgumentReachability -> Option x -> b) -> Parser a -> [b]

-- | Like <a>mapParser</a>, but collect the results in a tree structure.
treeMapParser :: (forall x. ArgumentReachability -> Option x -> b) -> Parser a -> OptTree b
optionNames :: OptReader a -> [OptName]

module Options.Applicative.Help.Core

-- | Generate descriptions for commands.
cmdDesc :: ParserPrefs -> Parser a -> [(Maybe String, Chunk Doc)]

-- | Generate a brief help text for a parser.
briefDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a brief help text for a parser, only including mandatory
--   options and arguments.
missingDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a full help text for a parser
fullDesc :: ParserPrefs -> Parser a -> Chunk Doc

-- | Generate a help text for the parser, showing only what is relevant in
--   the "Global options: section"
globalDesc :: ParserPrefs -> Parser a -> Chunk Doc
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
errorHelp :: Chunk Doc -> ParserHelp
headerHelp :: Chunk Doc -> ParserHelp
suggestionsHelp :: Chunk Doc -> ParserHelp
usageHelp :: Chunk Doc -> ParserHelp
descriptionHelp :: Chunk Doc -> ParserHelp
bodyHelp :: Chunk Doc -> ParserHelp
footerHelp :: Chunk Doc -> ParserHelp
globalsHelp :: Chunk Doc -> ParserHelp

-- | Generate the help text for a program.
parserHelp :: ParserPrefs -> Parser a -> ParserHelp

-- | Generate option summary.
parserUsage :: ParserPrefs -> Parser a -> String -> Doc
parserGlobals :: ParserPrefs -> Parser a -> ParserHelp
instance GHC.Show.Show Options.Applicative.Help.Core.Parenthetic
instance GHC.Classes.Ord Options.Applicative.Help.Core.Parenthetic
instance GHC.Classes.Eq Options.Applicative.Help.Core.Parenthetic

module Options.Applicative.Help

module Options.Applicative.Builder.Internal

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a
Mod :: (f a -> f a) -> DefaultProp a -> (OptProperties -> OptProperties) -> Mod f a
class HasName f
name :: HasName f => OptName -> f a -> f a
class HasCompleter f
modCompleter :: HasCompleter f => (Completer -> Completer) -> f a -> f a
class HasValue f
hasValueDummy :: HasValue f => f a -> ()
class HasMetavar f
hasMetavarDummy :: HasMetavar f => f a -> ()
data OptionFields a
OptionFields :: [OptName] -> Completer -> (String -> ParseError) -> OptionFields a
[optNames] :: OptionFields a -> [OptName]
[optCompleter] :: OptionFields a -> Completer
[optNoArgError] :: OptionFields a -> String -> ParseError
data FlagFields a
FlagFields :: [OptName] -> a -> FlagFields a
[flagNames] :: FlagFields a -> [OptName]
[flagActive] :: FlagFields a -> a
data CommandFields a
CommandFields :: [(String, ParserInfo a)] -> Maybe String -> CommandFields a
[cmdCommands] :: CommandFields a -> [(String, ParserInfo a)]
[cmdGroup] :: CommandFields a -> Maybe String
data ArgumentFields a
ArgumentFields :: Completer -> ArgumentFields a
[argCompleter] :: ArgumentFields a -> Completer
data DefaultProp a
DefaultProp :: Maybe a -> Maybe (a -> String) -> DefaultProp a
optionMod :: (OptProperties -> OptProperties) -> Mod f a
fieldMod :: (f a -> f a) -> Mod f a

-- | Base default properties.
baseProps :: OptProperties
mkCommand :: Mod CommandFields a -> (Maybe String, [(String, ParserInfo a)])
mkParser :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Parser a
mkOption :: DefaultProp a -> (OptProperties -> OptProperties) -> OptReader a -> Option a
mkProps :: DefaultProp a -> (OptProperties -> OptProperties) -> OptProperties

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Suppress this option from appearing in global options
noGlobal :: Mod f a
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.Mod f a)
instance GHC.Base.Monoid (Options.Applicative.Builder.Internal.DefaultProp a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.Internal.DefaultProp a)
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasMetavar Options.Applicative.Builder.Internal.CommandFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasValue Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasCompleter Options.Applicative.Builder.Internal.ArgumentFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.OptionFields
instance Options.Applicative.Builder.Internal.HasName Options.Applicative.Builder.Internal.FlagFields

module Options.Applicative.Builder.Completer

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer

-- | Strongly quote the string we pass to compgen.
--   
--   We need to do this so bash doesn't expand out any ~ or other chars we
--   want to complete on, or emit an end of line error when seeking the
--   close to the quote.
requote :: String -> String

module Options.Applicative.Builder

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
--   
--   By default, sub-parsers allow backtracking to their parent's options
--   when they are completed. To allow full mixing of parent and sub-parser
--   options, turn on <a>subparserInline</a>; otherwise, to disable
--   backtracking completely, use <a>noBacktrack</a>.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a 'Prettyprinter.Doc AnsiStyle'
--   value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError

-- | Hide this option from the brief description.
--   
--   Use <a>internal</a> to hide the option from the help text too.
hidden :: Mod f a

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style (annotate bold))
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to use
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser (default).
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a 'Prettyprinter.Doc AnsiStyle'
--   value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Disable parsing of regular options completely. All options and
--   arguments will be treated as a positional arguments. Obviously not
--   recommended in general as options will be unreachable. This is the
--   same behaviour one sees after the "--" pseudo-argument.
allPositional :: InfoMod a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Allow full mixing of subcommand and parent arguments by inlining
--   selected subparsers into the parent parser.
--   
--   <i>NOTE:</i> When this option is used, preferences for the subparser
--   which effect the parser behaviour (such as noIntersperse) are ignored.
subparserInline :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Show equals sign, rather than space, in usage and help text for
--   options with long names.
helpLongEquals :: PrefsMod

-- | Show global help information in subparser usage.
helpShowGlobals :: PrefsMod

-- | Set fill width in help text presentation.
helpIndent :: Int -> PrefsMod

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f
instance GHC.Base.Monoid Options.Applicative.Builder.PrefsMod
instance GHC.Base.Semigroup Options.Applicative.Builder.PrefsMod
instance GHC.Base.Monoid (Options.Applicative.Builder.InfoMod a)
instance GHC.Base.Semigroup (Options.Applicative.Builder.InfoMod a)


-- | You don't need to import this module to enable bash completion.
--   
--   See <a>the wiki</a> for more information on bash completion.
module Options.Applicative.BashCompletion
bashCompletionParser :: ParserInfo a -> ParserPrefs -> Parser CompletionResult

-- | Generated bash shell completion script
bashCompletionScript :: String -> String -> String

-- | Generated fish shell completion script
fishCompletionScript :: String -> String -> String

-- | Generated zsh shell completion script
zshCompletionScript :: String -> String -> String
instance GHC.Show.Show Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Ord Options.Applicative.BashCompletion.Richness
instance GHC.Classes.Eq Options.Applicative.BashCompletion.Richness

module Options.Applicative.Extra

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | Like helper, but with a minimal set of modifiers that can be extended
--   as desired.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helperWith (mconcat [
--            long "help",
--            short 'h',
--            help "Show this help text",
--            hidden
--          ])) mempty
--   </pre>
helperWith :: Mod OptionFields (a -> a) -> Parser (a -> a)

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | A hidden "--version" option that displays the version.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; simpleVersioner "v1.2.3") mempty
--   </pre>
simpleVersioner :: String -> Parser (a -> a)

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo (ShowHelpText Nothing) mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String

module Options.Applicative

-- | A <tt>Parser a</tt> is an option parser returning a value of type
--   <tt>a</tt>.
data Parser a

-- | Builder for a flag parser.
--   
--   A flag that switches from a "default value" to an "active value" when
--   encountered. For a simple boolean value, use <a>switch</a> instead.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
flag :: a -> a -> Mod FlagFields a -> Parser a

-- | Builder for a flag parser without a default value.
--   
--   Same as <a>flag</a>, but with no default value. In particular, this
--   flag will never parse successfully by itself.
--   
--   It still makes sense to use it as part of a composite parser. For
--   example
--   
--   <pre>
--   length &lt;$&gt; many (flag' () (short 't'))
--   </pre>
--   
--   is a parser that counts the number of "-t" arguments on the command
--   line, alternatively
--   
--   <pre>
--   flag' True (long "on") &lt;|&gt; flag' False (long "off")
--   </pre>
--   
--   will require the user to enter '--on' or '--off' on the command line.
flag' :: a -> Mod FlagFields a -> Parser a

-- | Builder for a boolean flag.
--   
--   <i>Note</i>: Because this parser will never fail, it can not be used
--   with combinators such as <a>some</a> or <a>many</a>, as these
--   combinators continue until a failure occurs. See <tt>flag'</tt>.
--   
--   <pre>
--   switch = flag False True
--   </pre>
switch :: Mod FlagFields Bool -> Parser Bool

-- | Builder for an option taking a <a>String</a> argument.
strOption :: IsString s => Mod OptionFields s -> Parser s

-- | Builder for an option using the given reader.
--   
--   This is a regular option, and should always have either a
--   <tt>long</tt> or <tt>short</tt> name specified in the modifiers (or
--   both).
--   
--   <pre>
--   nameParser = option str ( long "name" &lt;&gt; short 'n' )
--   </pre>
option :: ReadM a -> Mod OptionFields a -> Parser a

-- | Builder for a <a>String</a> argument.
strArgument :: IsString s => Mod ArgumentFields s -> Parser s

-- | Builder for an argument parser.
argument :: ReadM a -> Mod ArgumentFields a -> Parser a

-- | Builder for a command parser. The <a>command</a> modifier can be used
--   to specify individual commands.
--   
--   By default, sub-parsers allow backtracking to their parent's options
--   when they are completed. To allow full mixing of parent and sub-parser
--   options, turn on <a>subparserInline</a>; otherwise, to disable
--   backtracking completely, use <a>noBacktrack</a>.
subparser :: Mod CommandFields a -> Parser a

-- | Builder for a command parser with a "helper" option attached. Used in
--   the same way as <a>subparser</a>, but includes a "--help|-h" inside
--   the subcommand.
hsubparser :: Mod CommandFields a -> Parser a

-- | An option that always fails.
--   
--   When this option is encountered, the option parser immediately aborts
--   with the given parse error. If you simply want to output a message,
--   use <a>infoOption</a> instead.
abortOption :: ParseError -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | An option that always fails and displays a message.
infoOption :: String -> Mod OptionFields (a -> a) -> Parser (a -> a)

-- | A hidden "helper" option which always fails.
--   
--   A common usage pattern is to apply this applicatively when creating a
--   <a>ParserInfo</a>
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; helper) mempty
--   </pre>
helper :: Parser (a -> a)

-- | A hidden "--version" option that displays the version.
--   
--   <pre>
--   opts :: ParserInfo Sample
--   opts = info (sample &lt;**&gt; simpleVersioner "v1.2.3") mempty
--   </pre>
simpleVersioner :: String -> Parser (a -> a)

-- | An option modifier.
--   
--   Option modifiers are values that represent a modification of the
--   properties of an option.
--   
--   The type parameter <tt>a</tt> is the return type of the option, while
--   <tt>f</tt> is a record containing its properties (e.g.
--   <a>OptionFields</a> for regular options, <a>FlagFields</a> for flags,
--   etc...).
--   
--   An option modifier consists of 3 elements:
--   
--   <ul>
--   <li>A field modifier, of the form <tt>f a -&gt; f a</tt>. These are
--   essentially (compositions of) setters for some of the properties
--   supported by <tt>f</tt>.</li>
--   <li>An optional default value and function to display it.</li>
--   <li>A property modifier, of the form <tt>OptProperties -&gt;
--   OptProperties</tt>. This is just like the field modifier, but for
--   properties applicable to any option.</li>
--   </ul>
--   
--   Modifiers are instances of <a>Monoid</a>, and can be composed as such.
--   
--   One rarely needs to deal with modifiers directly, as most of the times
--   it is sufficient to pass them to builders (such as <tt>strOption</tt>
--   or <tt>flag</tt>) to create options (see <a>Builder</a>).
data Mod f a

-- | Specify a short name for an option.
short :: HasName f => Char -> Mod f a

-- | Specify a long name for an option.
long :: HasName f => String -> Mod f a

-- | Specify the help text for an option.
help :: String -> Mod f a

-- | Specify the help text for an option as a 'Prettyprinter.Doc AnsiStyle'
--   value.
helpDoc :: Maybe Doc -> Mod f a

-- | Specify a default value for an option.
--   
--   <i>Note</i>: Because this modifier means the parser will never fail,
--   do not use it with combinators such as <a>some</a> or <a>many</a>, as
--   these combinators continue until a failure occurs. Careless use will
--   thus result in a hang.
--   
--   To display the default value, combine with showDefault or
--   showDefaultWith.
value :: HasValue f => a -> Mod f a

-- | Specify a function to show the default value for an option.
showDefaultWith :: (a -> String) -> Mod f a

-- | Show the default value for this option using its <a>Show</a> instance.
showDefault :: Show a => Mod f a

-- | Specify a metavariable for the argument.
--   
--   Metavariables have no effect on the actual parser, and only serve to
--   specify the symbolic name for an argument to be displayed in the help
--   text.
metavar :: HasMetavar f => String -> Mod f a

-- | Specify the error to display when no argument is provided to this
--   option.
noArgError :: ParseError -> Mod OptionFields a

-- | Hide this option from the brief description.
--   
--   Use <a>internal</a> to hide the option from the help text too.
hidden :: Mod f a

-- | Hide this option completely from the help text
--   
--   Use <tt>hidden</tt> if the option should remain visible in the full
--   description.
internal :: Mod f a

-- | Apply a function to the option description in the usage text.
--   
--   <pre>
--   import Options.Applicative.Help
--   flag' () (short 't' &lt;&gt; style (annotate bold))
--   </pre>
--   
--   <i>NOTE</i>: This builder is more flexible than its name and example
--   allude. One of the motivating examples for its addition was to use
--   <a>const</a> to completely replace the usage text of an option.
style :: (Doc -> Doc) -> Mod f a

-- | Add a command to a subparser option.
--   
--   Suggested usage for multiple commands is to add them to a single
--   subparser. e.g.
--   
--   <pre>
--   sample :: Parser Sample
--   sample = subparser
--          ( command "hello"
--            (info hello (progDesc "Print greeting"))
--         &lt;&gt; command "goodbye"
--            (info goodbye (progDesc "Say goodbye"))
--          )
--   </pre>
command :: String -> ParserInfo a -> Mod CommandFields a

-- | Add a description to a group of commands.
--   
--   Advanced feature for separating logical groups of commands on the
--   parse line.
--   
--   If using the same <a>metavar</a> for each group of commands, it may
--   yield a more attractive usage text combined with <a>hidden</a> for
--   some groups.
commandGroup :: String -> Mod CommandFields a

-- | Add a list of possible completion values.
completeWith :: HasCompleter f => [String] -> Mod f a

-- | Add a bash completion action. Common actions include <tt>file</tt> and
--   <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
action :: HasCompleter f => String -> Mod f a

-- | Add a completer to an argument.
--   
--   A completer is a function String -&gt; IO String which, given a
--   partial argument, returns all possible completions for that argument.
completer :: HasCompleter f => Completer -> Mod f a

-- | Trivial option modifier.
idm :: Monoid m => m

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a
data OptionFields a
data FlagFields a
data ArgumentFields a
data CommandFields a
class HasName f
class HasCompleter f
class HasValue f
class HasMetavar f

-- | A newtype over 'ReaderT String Except', used by option readers.
data ReadM a

-- | <a>Option</a> reader based on the <a>Read</a> type class.
auto :: Read a => ReadM a

-- | String <a>Option</a> reader.
--   
--   Polymorphic over the <a>IsString</a> type class since 0.14.
str :: IsString s => ReadM s

-- | Convert a function producing a <a>Maybe</a> into a reader.
maybeReader :: (String -> Maybe a) -> ReadM a

-- | Convert a function producing an <a>Either</a> into a reader.
--   
--   As an example, one can create a ReadM from an attoparsec Parser easily
--   with
--   
--   <pre>
--   import qualified Data.Attoparsec.Text as A
--   import qualified Data.Text as T
--   attoparsecReader :: A.Parser a -&gt; ReadM a
--   attoparsecReader p = eitherReader (A.parseOnly p . T.pack)
--   </pre>
eitherReader :: (String -> Either String a) -> ReadM a

-- | Null <a>Option</a> reader. All arguments will fail validation.
disabled :: ReadM a

-- | Abort option reader by exiting with a <a>ParseError</a>.
readerAbort :: ParseError -> ReadM a

-- | Abort option reader by exiting with an error message.
readerError :: String -> ReadM a

-- | Create a <a>ParserInfo</a> given a <a>Parser</a> and a modifier.
info :: Parser a -> InfoMod a -> ParserInfo a

-- | A full description for a runnable <a>Parser</a> for a program.
data ParserInfo a
ParserInfo :: Parser a -> Bool -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Int -> ArgPolicy -> ParserInfo a

-- | the option parser for the program
[infoParser] :: ParserInfo a -> Parser a

-- | whether the help text should contain full documentation
[infoFullDesc] :: ParserInfo a -> Bool

-- | brief parser description
[infoProgDesc] :: ParserInfo a -> Chunk Doc

-- | header of the full parser description
[infoHeader] :: ParserInfo a -> Chunk Doc

-- | footer of the full parser description
[infoFooter] :: ParserInfo a -> Chunk Doc

-- | exit code for a parser failure
[infoFailureCode] :: ParserInfo a -> Int

-- | allow regular options and flags to occur after arguments (default:
--   InterspersePolicy)
[infoPolicy] :: ParserInfo a -> ArgPolicy

-- | Modifier for <a>ParserInfo</a>.
data InfoMod a

-- | Show a full description in the help text of this parser (default).
fullDesc :: InfoMod a

-- | Only show a brief description in the help text of this parser.
briefDesc :: InfoMod a

-- | Specify a header for this parser.
header :: String -> InfoMod a

-- | Specify a header for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
headerDoc :: Maybe Doc -> InfoMod a

-- | Specify a footer for this parser.
footer :: String -> InfoMod a

-- | Specify a footer for this parser as a 'Prettyprinter.Doc AnsiStyle'
--   value.
footerDoc :: Maybe Doc -> InfoMod a

-- | Specify a short program description.
progDesc :: String -> InfoMod a

-- | Specify a short program description as a 'Prettyprinter.Doc AnsiStyle'
--   value.
progDescDoc :: Maybe Doc -> InfoMod a

-- | Specify an exit code if a parse error occurs.
failureCode :: Int -> InfoMod a

-- | Disable parsing of regular options after arguments. After a positional
--   argument is parsed, all remaining options and arguments will be
--   treated as a positional arguments. Not recommended in general as users
--   often expect to be able to freely intersperse regular options and
--   flags within command line options.
noIntersperse :: InfoMod a

-- | Intersperse matched options and arguments normally, but allow
--   unmatched options to be treated as positional arguments. This is
--   sometimes useful if one is wrapping a third party cli tool and needs
--   to pass options through, while also providing a handful of their own
--   options. Not recommended in general as typos by the user may not yield
--   a parse error and cause confusion.
forwardOptions :: InfoMod a

-- | Run a program description.
--   
--   Parse command line arguments. Display help text and exit if any parse
--   error occurs.
execParser :: ParserInfo a -> IO a

-- | Run a program description with custom preferences.
customExecParser :: ParserPrefs -> ParserInfo a -> IO a

-- | The most general way to run a program description in pure code.
execParserPure :: ParserPrefs -> ParserInfo a -> [String] -> ParserResult a

-- | Extract the actual result from a <a>ParserResult</a> value.
--   
--   This function returns <a>Nothing</a> in case of errors. Possible error
--   messages or completion actions are simply discarded.
--   
--   If you want to display error messages and invoke completion actions
--   appropriately, use <a>handleParseResult</a> instead.
getParseResult :: ParserResult a -> Maybe a

-- | Handle <a>ParserResult</a>.
handleParseResult :: ParserResult a -> IO a

-- | Generate a <a>ParserFailure</a> from a <a>ParseError</a> in a given
--   <a>Context</a>.
--   
--   This function can be used, for example, to show the help text for a
--   parser:
--   
--   <pre>
--   handleParseResult . Failure $ parserFailure pprefs pinfo (ShowHelpText Nothing) mempty
--   </pre>
parserFailure :: ParserPrefs -> ParserInfo a -> ParseError -> [Context] -> ParserFailure ParserHelp
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
overFailure :: (ParserHelp -> ParserHelp) -> ParserResult a -> ParserResult a

-- | Create a <a>ParserPrefs</a> given a modifier
prefs :: PrefsMod -> ParserPrefs

-- | Global preferences for a top-level <a>Parser</a>.
data ParserPrefs
ParserPrefs :: String -> Bool -> Bool -> Bool -> Backtracking -> Int -> Bool -> Bool -> Int -> ParserPrefs

-- | metavar suffix for multiple options
[prefMultiSuffix] :: ParserPrefs -> String

-- | automatically disambiguate abbreviations (default: False)
[prefDisambiguate] :: ParserPrefs -> Bool

-- | always show help text on parse errors (default: False)
[prefShowHelpOnError] :: ParserPrefs -> Bool

-- | show the help text for a command or subcommand if it fails with no
--   input (default: False)
[prefShowHelpOnEmpty] :: ParserPrefs -> Bool

-- | backtrack to parent parser when a subcommand fails (default:
--   Backtrack)
[prefBacktrack] :: ParserPrefs -> Backtracking

-- | number of columns in the terminal, used to format the help page
--   (default: 80)
[prefColumns] :: ParserPrefs -> Int

-- | when displaying long names in usage and help, use an '=' sign for long
--   names, rather than a single space (default: False)
[prefHelpLongEquals] :: ParserPrefs -> Bool

-- | when displaying subparsers' usage help, show parent options under a
--   "global options" section (default: False)
[prefHelpShowGlobal] :: ParserPrefs -> Bool

-- | Indentation width for tables
[prefTabulateFill] :: ParserPrefs -> Int
data PrefsMod

-- | Include a suffix to attach to the metavar when multiple values can be
--   entered.
multiSuffix :: String -> PrefsMod

-- | Turn on disambiguation.
--   
--   See
--   <a>https://github.com/pcapriotti/optparse-applicative#disambiguation</a>
disambiguate :: PrefsMod

-- | Show full help text on any error.
showHelpOnError :: PrefsMod

-- | Show the help text if the user enters only the program name or
--   subcommand.
--   
--   This will suppress a "Missing:" error and show the full usage instead
--   if a user just types the name of the program.
showHelpOnEmpty :: PrefsMod

-- | Turn off backtracking after subcommand is parsed.
noBacktrack :: PrefsMod

-- | Allow full mixing of subcommand and parent arguments by inlining
--   selected subparsers into the parent parser.
--   
--   <i>NOTE:</i> When this option is used, preferences for the subparser
--   which effect the parser behaviour (such as noIntersperse) are ignored.
subparserInline :: PrefsMod

-- | Set the maximum width of the generated help text.
columns :: Int -> PrefsMod

-- | Show equals sign, rather than space, in usage and help text for
--   options with long names.
helpLongEquals :: PrefsMod

-- | Show global help information in subparser usage.
helpShowGlobals :: PrefsMod

-- | Set fill width in help text presentation.
helpIndent :: Int -> PrefsMod

-- | Default preferences.
defaultPrefs :: ParserPrefs

-- | A shell complete function.
data Completer

-- | Smart constructor for a <a>Completer</a>
mkCompleter :: (String -> IO [String]) -> Completer

-- | Create a <a>Completer</a> from an IO action
listIOCompleter :: IO [String] -> Completer

-- | Create a <a>Completer</a> from a constant list of strings.
listCompleter :: [String] -> Completer

-- | Run a compgen completion action.
--   
--   Common actions include <tt>file</tt> and <tt>directory</tt>. See
--   <a>http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins</a>
--   for a complete list.
bashCompleter :: String -> Completer
data ParseError
ErrorMsg :: String -> ParseError
InfoMsg :: String -> ParseError
ShowHelpText :: Maybe String -> ParseError
UnknownError :: ParseError
MissingError :: IsCmdStart -> SomeParser -> ParseError
ExpectsArgError :: String -> ParseError
UnexpectedError :: String -> SomeParser -> ParseError
data ParserHelp
ParserHelp :: Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> Chunk Doc -> ParserHelp
[helpError] :: ParserHelp -> Chunk Doc
[helpSuggestions] :: ParserHelp -> Chunk Doc
[helpHeader] :: ParserHelp -> Chunk Doc
[helpUsage] :: ParserHelp -> Chunk Doc
[helpDescription] :: ParserHelp -> Chunk Doc
[helpBody] :: ParserHelp -> Chunk Doc
[helpGlobals] :: ParserHelp -> Chunk Doc
[helpFooter] :: ParserHelp -> Chunk Doc
newtype ParserFailure h
ParserFailure :: (String -> (h, ExitCode, Int)) -> ParserFailure h
[execFailure] :: ParserFailure h -> String -> (h, ExitCode, Int)

-- | Result of <tt>execParserPure</tt>.
data ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
newtype CompletionResult
CompletionResult :: (String -> IO String) -> CompletionResult
[execCompletion] :: CompletionResult -> String -> IO String


-- | This module contains an arrow interface for option parsers, which
--   allows to define and combine parsers using the arrow notation and
--   arrow combinators.
--   
--   The arrow syntax is particularly useful to create parsers of nested
--   structures, or records where the order of fields is different from the
--   order in which the parsers should be applied.
--   
--   For example, an <a>arguments</a> parser often needs to be applied
--   last, and that makes it inconvenient to use it for a field which is
--   not the last one in a record.
--   
--   Using the arrow syntax and the functions in this module, one can
--   write, e.g.:
--   
--   <pre>
--   data Options = Options
--     { optArgs :: [String]
--     , optVerbose :: Bool }
--   
--   opts :: Parser Options
--   opts = runA $ proc () -&gt; do
--     verbose &lt;- asA (switch (short 'v')) -&lt; ()
--     args &lt;- asA (arguments str idm) -&lt; ()
--     returnA -&lt; Options args verbose
--   </pre>
--   
--   Parser arrows, created out of regular <a>Parser</a> values using the
--   <a>asA</a> function, are arrows taking <tt>()</tt> as argument and
--   returning the parsed value.
module Options.Applicative.Arrows

-- | For any <a>Applicative</a> functor <tt>f</tt>, <tt>A f</tt> is the
--   <a>Arrow</a> instance associated to <tt>f</tt>.
--   
--   The <a>A</a> constructor can be used to convert a value of type <tt>f
--   (a -&gt; b)</tt> into an arrow.
newtype A f a b
A :: f (a -> b) -> A f a b
[unA] :: A f a b -> f (a -> b)

-- | Convert a value of type <tt>f a</tt> into an arrow taking <tt>()</tt>
--   as argument.
--   
--   Applied to a value of type <a>Parser</a>, it turns it into an arrow
--   that can be used inside an arrow command, or passed to arrow
--   combinators.
asA :: Applicative f => f a -> A f () a

-- | Convert an arrow back to an applicative value.
--   
--   This function can be used to return a result of type <a>Parser</a>
--   from an arrow command.
runA :: Applicative f => A f () a -> f a

-- | The type of arrows associated to the applicative <a>Parser</a>
--   functor.
type ParserA = A Parser
instance GHC.Base.Applicative f => Control.Category.Category (Options.Applicative.Arrows.A f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Options.Applicative.Arrows.A f)
