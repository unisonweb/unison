-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple applicative parser
--   
--   A simple applicative parser in Parsec style
@package appar
@version 0.1.8


-- | Simple <a>Applicative</a> parser whose input is lazy
--   <a>ByteString</a>. The usage is the same as parsec.
--   
--   Parsec 3 provides features which Parsec 2 does not provide:
--   
--   <ul>
--   <li><a>Applicative</a> style</li>
--   <li><a>ByteString</a> as input</li>
--   </ul>
--   
--   But Haskell Platform includes Parsec 2, not Parsec 3. Installing
--   Parsec 3 to Haskell Platform environment makes it mess. So, this
--   library was implemented.
module Text.Appar.LazyByteString

-- | Parser synonym for strict <a>ByteString</a>.
type Parser = MkParser ByteString

-- | Run a parser.
parse :: Input inp => MkParser inp a -> inp -> Maybe a

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character.
char :: Input inp => Char -> MkParser inp Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Input inp => MkParser inp Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character.
oneOf :: Input inp => String -> MkParser inp Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
noneOf :: Input inp => String -> MkParser inp Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: Input inp => MkParser inp Char

-- | Parses a digit. Returns the parsed character.
digit :: Input inp => MkParser inp Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Input inp => MkParser inp Char

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Input inp => MkParser inp Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string
string :: Input inp => String -> MkParser inp String

-- | The parser try p behaves like parser p, except that it pretends that
--   it hasn't consumed any input when an error occurs.
try :: MkParser inp a -> MkParser inp a

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: [MkParser inp a] -> MkParser inp a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
option :: a -> MkParser inp a -> MkParser inp a

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
skipMany :: MkParser inp a -> MkParser inp ()

-- | <tt>skipSome p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipSome :: MkParser inp a -> MkParser inp ()

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>.
manyTill :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a
infixl 3 <|>

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | Lift a value.
pure :: Applicative f => a -> f a
data MkParser inp a
P :: (inp -> (Maybe a, inp)) -> MkParser inp a

-- | Getting the internal parser.
[runParser] :: MkParser inp a -> inp -> (Maybe a, inp)

-- | The class for parser input.
class Eq inp => Input inp

-- | The head function for input
car :: Input inp => inp -> Char

-- | The tail function for input
cdr :: Input inp => inp -> inp

-- | The end of input
nil :: Input inp => inp

-- | The function to check the end of input
isNil :: Input inp => inp -> Bool

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Input inp => (Char -> Bool) -> MkParser inp Char


-- | Simple <a>Applicative</a> parser whose input is strict
--   <a>ByteString</a>. The usage is the same as parsec.
--   
--   Parsec 3 provides features which Parsec 2 does not provide:
--   
--   <ul>
--   <li><a>Applicative</a> style</li>
--   <li><a>ByteString</a> as input</li>
--   </ul>
--   
--   But Haskell Platform includes Parsec 2, not Parsec 3. Installing
--   Parsec 3 to Haskell Platform environment makes it mess. So, this
--   library was implemented.
module Text.Appar.ByteString

-- | Parser synonym for strict <a>ByteString</a>.
type Parser = MkParser ByteString

-- | Run a parser.
parse :: Input inp => MkParser inp a -> inp -> Maybe a

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character.
char :: Input inp => Char -> MkParser inp Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Input inp => MkParser inp Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character.
oneOf :: Input inp => String -> MkParser inp Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
noneOf :: Input inp => String -> MkParser inp Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: Input inp => MkParser inp Char

-- | Parses a digit. Returns the parsed character.
digit :: Input inp => MkParser inp Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Input inp => MkParser inp Char

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Input inp => MkParser inp Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string
string :: Input inp => String -> MkParser inp String

-- | The parser try p behaves like parser p, except that it pretends that
--   it hasn't consumed any input when an error occurs.
try :: MkParser inp a -> MkParser inp a

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: [MkParser inp a] -> MkParser inp a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
option :: a -> MkParser inp a -> MkParser inp a

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
skipMany :: MkParser inp a -> MkParser inp ()

-- | <tt>skipSome p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipSome :: MkParser inp a -> MkParser inp ()

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>.
manyTill :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a
infixl 3 <|>

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | Lift a value.
pure :: Applicative f => a -> f a
data MkParser inp a
P :: (inp -> (Maybe a, inp)) -> MkParser inp a

-- | Getting the internal parser.
[runParser] :: MkParser inp a -> inp -> (Maybe a, inp)

-- | The class for parser input.
class Eq inp => Input inp

-- | The head function for input
car :: Input inp => inp -> Char

-- | The tail function for input
cdr :: Input inp => inp -> inp

-- | The end of input
nil :: Input inp => inp

-- | The function to check the end of input
isNil :: Input inp => inp -> Bool

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Input inp => (Char -> Bool) -> MkParser inp Char


-- | Simple <a>Applicative</a> parser whose input is <a>String</a>. The
--   usage is the same as parsec.
--   
--   Parsec 3 provides features which Parsec 2 does not provide:
--   
--   <ul>
--   <li><a>Applicative</a> style</li>
--   <li><tt>ByteString</tt> as input</li>
--   </ul>
--   
--   But Haskell Platform includes Parsec 2, not Parsec 3. Installing
--   Parsec 3 to Haskell Platform environment makes it mess. So, this
--   library was implemented.
module Text.Appar.String

-- | Parser synonym for <a>String</a>.
type Parser = MkParser String

-- | Run a parser.
parse :: Input inp => MkParser inp a -> inp -> Maybe a

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character.
char :: Input inp => Char -> MkParser inp Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Input inp => MkParser inp Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character.
oneOf :: Input inp => String -> MkParser inp Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
noneOf :: Input inp => String -> MkParser inp Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: Input inp => MkParser inp Char

-- | Parses a digit. Returns the parsed character.
digit :: Input inp => MkParser inp Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Input inp => MkParser inp Char

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Input inp => MkParser inp Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string
string :: Input inp => String -> MkParser inp String

-- | The parser try p behaves like parser p, except that it pretends that
--   it hasn't consumed any input when an error occurs.
try :: MkParser inp a -> MkParser inp a

-- | <tt>choice ps</tt> tries to apply the parsers in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding parser.
choice :: [MkParser inp a] -> MkParser inp a

-- | <tt>option x p</tt> tries to apply parser <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
option :: a -> MkParser inp a -> MkParser inp a

-- | <tt>skipMany p</tt> applies the parser <tt>p</tt> <i>zero</i> or more
--   times, skipping its result.
skipMany :: MkParser inp a -> MkParser inp ()

-- | <tt>skipSome p</tt> applies the parser <tt>p</tt> <i>one</i> or more
--   times, skipping its result.
skipSome :: MkParser inp a -> MkParser inp ()

-- | <tt>sepBy1 p sep</tt> parses <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of values
--   returned by <tt>p</tt>.
sepBy1 :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | <tt>manyTill p end</tt> applies parser <tt>p</tt> <i>zero</i> or more
--   times until parser <tt>end</tt> succeeds. Returns the list of values
--   returned by <tt>p</tt>.
manyTill :: MkParser inp a -> MkParser inp b -> MkParser inp [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a
infixl 3 <|>

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | Lift a value.
pure :: Applicative f => a -> f a
data MkParser inp a
P :: (inp -> (Maybe a, inp)) -> MkParser inp a

-- | Getting the internal parser.
[runParser] :: MkParser inp a -> inp -> (Maybe a, inp)

-- | The class for parser input.
class Eq inp => Input inp

-- | The head function for input
car :: Input inp => inp -> Char

-- | The tail function for input
cdr :: Input inp => inp -> inp

-- | The end of input
nil :: Input inp => inp

-- | The function to check the end of input
isNil :: Input inp => inp -> Bool

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Input inp => (Char -> Bool) -> MkParser inp Char
