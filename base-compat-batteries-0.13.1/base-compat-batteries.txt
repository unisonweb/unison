-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | base-compat with extra batteries
--   
--   Provides functions available in later versions of <tt>base</tt> to a
--   wider range of compilers, without requiring you to use CPP pragmas in
--   your code.
--   
--   This package provides the same API as the <tt><a>base-compat</a></tt>
--   library, but depends on compatibility packages (such as
--   <tt>semigroups</tt>) to offer a wider support window than
--   <tt>base-compat</tt>, which has no dependencies. Most of the modules
--   in this library have the same names as in <tt>base-compat</tt> to make
--   it easier to switch between the two. There also exist versions of each
--   module with the suffix <tt>.Repl.Batteries</tt>, which are distinct
--   from anything in <tt>base-compat</tt>, to allow for easier use in
--   GHCi.
--   
--   See <tt><a>here</a></tt> for a more comprehensive list of differences
--   between <tt>base-compat</tt> and <tt>base-compat-batteries</tt>.
@package base-compat-batteries
@version 0.13.1

module Control.Concurrent.Compat


-- | Reexports <a>Control.Concurrent.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.Compat.Repl.Batteries

module Control.Concurrent.MVar.Compat


-- | Reexports <a>Control.Concurrent.MVar.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.MVar.Compat.Repl.Batteries

module Control.Exception.Compat


-- | Reexports <a>Control.Exception.Compat</a> from a globally unique
--   namespace.
module Control.Exception.Compat.Repl.Batteries

module Control.Monad.Compat

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results:
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
fail :: MonadFail m => String -> m a


-- | Reexports <a>Control.Monad.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Compat.Repl.Batteries

module Control.Monad.Fail.Compat


-- | Reexports <a>Control.Monad.Fail.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Fail.Compat.Repl.Batteries

module Control.Monad.IO.Class.Compat


-- | Reexports <a>Control.Monad.IO.Class.Compat</a> from a globally unique
--   namespace.
module Control.Monad.IO.Class.Compat.Repl.Batteries

module Control.Monad.ST.Lazy.Unsafe.Compat


-- | Reexports <a>Control.Monad.ST.Lazy.Unsafe.Compat</a> from a globally
--   unique namespace.
module Control.Monad.ST.Lazy.Unsafe.Compat.Repl.Batteries

module Control.Monad.ST.Unsafe.Compat


-- | Reexports <a>Control.Monad.ST.Unsafe.Compat</a> from a globally unique
--   namespace.
module Control.Monad.ST.Unsafe.Compat.Repl.Batteries

module Data.Bifoldable.Compat


-- | Reexports <a>Data.Bifoldable.Compat</a> from a globally unique
--   namespace.
module Data.Bifoldable.Compat.Repl.Batteries

module Data.Bifoldable1.Compat


-- | Reexports <a>Data.Bifoldable1.Compat</a> from a globally unique
--   namespace.
module Data.Bifoldable1.Compat.Repl.Batteries

module Data.Bifunctor.Compat


-- | Reexports <a>Data.Bifunctor.Compat</a> from a globally unique
--   namespace.
module Data.Bifunctor.Compat.Repl.Batteries

module Data.Bitraversable.Compat


-- | Reexports <a>Data.Bitraversable.Compat</a> from a globally unique
--   namespace.
module Data.Bitraversable.Compat.Repl.Batteries

module Data.Bits.Compat


-- | Reexports <a>Data.Bits.Compat</a> from a globally unique namespace.
module Data.Bits.Compat.Repl.Batteries

module Data.Bool.Compat


-- | Reexports <a>Data.Bool.Compat</a> from a globally unique namespace.
module Data.Bool.Compat.Repl.Batteries

module Data.Complex.Compat


-- | Reexports <a>Data.Complex.Compat</a> from a globally unique namespace.
module Data.Complex.Compat.Repl.Batteries

module Data.Either.Compat


-- | Reexports <a>Data.Either.Compat</a> from a globally unique namespace.
module Data.Either.Compat.Repl.Batteries

module Data.Foldable.Compat


-- | Reexports <a>Data.Foldable.Compat</a> from a globally unique
--   namespace.
module Data.Foldable.Compat.Repl.Batteries

module Data.Foldable1.Compat


-- | Reexports <a>Data.Foldable1.Compat</a> from a globally unique
--   namespace.
module Data.Foldable1.Compat.Repl.Batteries

module Data.Function.Compat


-- | Reexports <a>Data.Function.Compat</a> from a globally unique
--   namespace.
module Data.Function.Compat.Repl.Batteries

module Data.Functor.Compat


-- | Reexports <a>Data.Functor.Compat</a> from a globally unique namespace.
module Data.Functor.Compat.Repl.Batteries

module Data.Functor.Compose.Compat


-- | Reexports <a>Data.Functor.Compose.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Compose.Compat.Repl.Batteries

module Data.Functor.Const.Compat


-- | Reexports <a>Data.Functor.Const.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Const.Compat.Repl.Batteries

module Data.Functor.Contravariant.Compat


-- | Reexports <a>Data.Functor.Contravariant.Compat</a> from a globally
--   unique namespace.
module Data.Functor.Contravariant.Compat.Repl.Batteries

module Data.Functor.Identity.Compat


-- | Reexports <a>Data.Functor.Identity.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Identity.Compat.Repl.Batteries

module Data.Functor.Product.Compat


-- | Reexports <a>Data.Functor.Product.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Product.Compat.Repl.Batteries

module Data.Functor.Sum.Compat


-- | Reexports <a>Data.Functor.Sum.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Sum.Compat.Repl.Batteries

module Data.IORef.Compat


-- | Reexports <a>Data.IORef.Compat</a> from a globally unique namespace.
module Data.IORef.Compat.Repl.Batteries

module Data.List.Compat


-- | Reexports <a>Data.List.Compat</a> from a globally unique namespace.
module Data.List.Compat.Repl.Batteries

module Data.List.NonEmpty.Compat

-- | Non-empty (and non-strict) list type.
data () => NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Construct a <a>NonEmpty</a> list from a single element.
singleton :: a -> NonEmpty a

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>, starting with the shortest. The
--   result is <a>NonEmpty</a> because the result always contains the empty
--   list as the first element.
--   
--   <pre>
--   inits [1,2,3] == [] :| [[1], [1,2], [1,2,3]]
--   inits [1] == [] :| [[1]]
--   inits [] == [] :| []
--   </pre>
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>inits1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the <a>NonEmpty</a> finite prefixes of <tt>xs</tt>,
--   starting with the shortest.
--   
--   <pre>
--   inits1 (1 :| [2,3]) == (1 :| []) :| [1 :| [2], 1 :| [2,3]]
--   inits1 (1 :| []) == (1 :| []) :| []
--   </pre>
inits1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>, starting with the longest. The result is
--   <a>NonEmpty</a> because the result always contains the empty list as
--   the last element.
--   
--   <pre>
--   tails [1,2,3] == [1,2,3] :| [[2,3], [3], []]
--   tails [1] == [1] :| [[]]
--   tails [] == [] :| []
--   </pre>
tails :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the non-empty suffixes of <tt>xs</tt>, starting with
--   the longest.
--   
--   <pre>
--   tails1 (1 :| [2,3]) == (1 :| [2,3]) :| [2 :| [3], 3 :| []]
--   tails1 (1 :| []) == (1 :| []) :| []
--   </pre>
tails1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>isPrefixOf</a> function returns <a>True</a> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: HasCallStack => NonEmpty a -> Int -> a
infixl 9 !!

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: HasCallStack => [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | Reexports <a>Data.List.NonEmpty.Compat</a> from a globally unique
--   namespace.
module Data.List.NonEmpty.Compat.Repl.Batteries

module Data.Monoid.Compat

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype () => Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype () => Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype () => Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the rightmost non-<a>Nothing</a> value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <tt>Data.Semigroup.</tt><a>Last</a>. The former returns the last
--   non-<a>Nothing</a>, so <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>. The latter simply returns the last value, thus <tt>x &lt;&gt;
--   Data.Semigroup.Last Nothing = Data.Semigroup.Last Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world")
--   Last {getLast = Just "world"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Last Nothing &lt;&gt; mempty
--   Last {getLast = Nothing}
--   </pre>
newtype () => Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Maybe monoid returning the leftmost non-<a>Nothing</a> value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   Beware that <tt>Data.Monoid.</tt><a>First</a> is different from
--   <tt>Data.Semigroup.</tt><a>First</a>. The former returns the first
--   non-<a>Nothing</a>, so <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>. The latter simply returns the first value, thus
--   <tt>Data.Semigroup.First Nothing &lt;&gt; x = Data.Semigroup.First
--   Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world")
--   First {getFirst = Just "hello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; First Nothing &lt;&gt; mempty
--   First {getFirst = Nothing}
--   </pre>
newtype () => First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   Alt l &lt;&gt; Alt r == Alt (l &lt;|&gt; r)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Alt (Just 12) &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Alt Nothing &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 24}
--   </pre>
newtype () => Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype () => All
All :: Bool -> All
[getAll] :: All -> Bool

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype () => Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype () => Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Ap (Just [1, 2, 3]) &lt;&gt; Ap Nothing
--   Ap {getAp = Nothing}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ap [Sum 10, Sum 20] &lt;&gt; Ap [Sum 1, Sum 2]
--   Ap {getAp = [Sum {getSum = 11},Sum {getSum = 12},Sum {getSum = 21},Sum {getSum = 22}]}
--   </pre>
newtype () => Ap (f :: k -> Type) (a :: k)
Ap :: f a -> Ap (f :: k -> Type) (a :: k)
[getAp] :: Ap (f :: k -> Type) (a :: k) -> f a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>


-- | Reexports <a>Data.Monoid.Compat</a> from a globally unique namespace.
module Data.Monoid.Compat.Repl.Batteries

module Data.Proxy.Compat


-- | Reexports <a>Data.Proxy.Compat</a> from a globally unique namespace.
module Data.Proxy.Compat.Repl.Batteries

module Data.Ratio.Compat


-- | Reexports <a>Data.Ratio.Compat</a> from a globally unique namespace.
module Data.Ratio.Compat.Repl.Batteries

module Data.STRef.Compat


-- | Reexports <a>Data.STRef.Compat</a> from a globally unique namespace.
module Data.STRef.Compat.Repl.Batteries

module Data.Semigroup.Compat

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   In many cases, <tt><a>stimes</a> 0 a</tt> for a <a>Monoid</a> will
--   produce <a>mempty</a>. However, there are situations when it cannot do
--   so. In particular, the following situation is fairly common:
--   
--   <pre>
--   data T a = ...
--   
--   class Constraint1 a
--   class Constraint1 a =&gt; Constraint2 a
--   </pre>
--   
--   <pre>
--   instance Constraint1 a =&gt; <a>Semigroup</a> (T a)
--   instance Constraint2 a =&gt; <a>Monoid</a> (T a)
--   </pre>
--   
--   Since <tt>Constraint1</tt> is insufficient to implement <a>mempty</a>,
--   <a>stimes</a> for <tt>T a</tt> cannot do so.
--   
--   When working with such a type, or when working polymorphically with
--   <a>Semigroup</a> instances, <tt>mtimesDefault</tt> should be used when
--   the multiplier might be zero. It is implemented using <a>stimes</a>
--   when the multiplier is nonzero and <a>mempty</a> when it is zero.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 0 "bark"
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 3 "meow"
--   "meowmeowmeow"
--   </pre>
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | The <a>Min</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   smaller element as by the <a>Ord</a> instance and <a>min</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min 42 &lt;&gt; Min 3
--   Min 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Min 1 :| [ Min n | n &lt;- [2 .. 100]]
--   Min {getMin = 1}
--   </pre>
newtype () => Min a
Min :: a -> Min a
[getMin] :: Min a -> a

-- | The <a>Max</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   bigger element as by the <a>Ord</a> instance and <a>max</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max 42 &lt;&gt; Max 3
--   Max 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Max 1 :| [ Max n | n &lt;- [2 .. 100]]
--   Max {getMax = 100}
--   </pre>
newtype () => Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>First</a> is different from
--   <tt>Data.Monoid.</tt><a>First</a>. The former simply returns the first
--   value, so <tt>Data.Semigroup.First Nothing &lt;&gt; x =
--   Data.Semigroup.First Nothing</tt>. The latter returns the first
--   non-<a>Nothing</a>, thus <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First 0 &lt;&gt; First 10
--   First 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ First 1 :| [ First n | n &lt;- [2 ..] ]
--   First 1
--   </pre>
newtype () => First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>Last</a> is different from
--   <tt>Data.Monoid.</tt><a>Last</a>. The former simply returns the last
--   value, so <tt>x &lt;&gt; Data.Semigroup.Last Nothing =
--   Data.Semigroup.Last Nothing</tt>. The latter returns the last
--   non-<a>Nothing</a>, thus <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last 0 &lt;&gt; Last 10
--   Last {getLast = 10}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Last 1 :| [ Last n | n &lt;- [2..]]
--   Last {getLast = * hangs forever *
--   </pre>
newtype () => Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype () => WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype () => Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype () => Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype () => All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype () => Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype () => Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype () => Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   let hello = diff "Hello, "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo hello "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; mempty) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (mempty &lt;&gt; hello) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   let world = diff "World"
--   let excl = diff "!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; (world &lt;&gt; excl)) mempty
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo ((hello &lt;&gt; world) &lt;&gt; excl) mempty
--   "Hello, World!"
--   </pre>
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ cycle1 [1, 2, 3]
--   [1,2,3,1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Right 1)
--   Right 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Left 1)
--   * hangs forever *
--   </pre>
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (x * x) x | x &lt;- [-10 .. 10] ]
--   Arg 0 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg 3.8 4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg (-34.0) (-10.0)
--   </pre>
data () => Arg a b
Arg :: a -> b -> Arg a b

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min (Arg 0 ()) &lt;&gt; Min (Arg 1 ())
--   Min {getMin = Arg 0 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 3 "lea"
--   </pre>
type ArgMin a b = Min Arg a b

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max (Arg 0 ()) &lt;&gt; Max (Arg 1 ())
--   Max {getMax = Arg 1 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 9 "violencia"
--   </pre>
type ArgMax a b = Max Arg a b


-- | Reexports <a>Data.Semigroup.Compat</a> from a globally unique
--   namespace.
module Data.Semigroup.Compat.Repl.Batteries

module Data.String.Compat


-- | Reexports <a>Data.String.Compat</a> from a globally unique namespace.
module Data.String.Compat.Repl.Batteries

module Data.Traversable.Compat


-- | Reexports <a>Data.Traversable.Compat</a> from a globally unique
--   namespace.
module Data.Traversable.Compat.Repl.Batteries


-- | This uses the <tt>OneTuple</tt> compatibility library to backport
--   <a>Solo</a> to old versions of GHC. Note that <tt>OneTuple</tt> makes
--   use of pattern synonyms, which cannot be defined on pre-7.8 versions
--   of GHC. As such, it is not feasible to backport the <tt>Solo</tt> data
--   constructor on pre-7.8 versions of GHC, as <tt>OneTuple</tt> defines
--   this as a pattern synonym.
module Data.Tuple.Compat

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data () => Solo a
MkSolo :: a -> Solo a
pattern Solo :: a -> Solo a
getSolo :: Solo a -> a

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)


-- | Reexports <a>Data.Tuple.Compat</a> from a globally unique namespace.
module Data.Tuple.Compat.Repl.Batteries

module Data.Type.Coercion.Compat


-- | Reexports <a>Data.Type.Coercion.Compat</a> from a globally unique
--   namespace.
module Data.Type.Coercion.Compat.Repl.Batteries

module Data.Type.Equality.Compat

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~# b => (a :: k0) ~~ (b :: k1)
infix 4 ~~

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data () => (a :: k1) :~~: (b :: k2)
[HRefl] :: forall {k1} (a :: k1). a :~~: a
infix 4 :~~:

-- | Symmetry of equality
sym :: forall {k} (a :: k) (b :: k). (a :~: b) -> b :~: a

-- | Transitivity of equality
trans :: forall {k} (a :: k) (b :: k) (c :: k). (a :~: b) -> (b :~: c) -> a :~: c

-- | Type-safe cast, using propositional equality
castWith :: (a :~: b) -> a -> b

-- | Generalized form of type-safe cast using propositional equality
gcastWith :: forall {k} (a :: k) (b :: k) r. (a :~: b) -> (a ~ b => r) -> r

-- | Apply one equality to another, respectively
apply :: forall {k1} {k2} (f :: k1 -> k2) (g :: k1 -> k2) (a :: k1) (b :: k1). (f :~: g) -> (a :~: b) -> f a :~: g b

-- | Extract equality of the arguments from an equality of applied types
inner :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> a :~: b

-- | Extract equality of type constructors from an equality of applied
--   types
outer :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> f :~: g

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>.
--   
--   The result should be <tt>Just Refl</tt> if and only if the types
--   applied to <tt>f</tt> are equal:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b
--   </pre>
--   
--   Typically, only singleton types should inhabit this class. In that
--   case type argument equality coincides with term equality:
--   
--   <pre>
--   testEquality (x :: f a) (y :: f b) = Just Refl ⟺ a = b ⟺ x = y
--   </pre>
--   
--   <pre>
--   isJust (testEquality x y) = x == y
--   </pre>
--   
--   Singleton types are not required, however, and so the latter two
--   would-be laws are not in fact valid in general.
class () => TestEquality (f :: k -> Type)

-- | Conditionally prove the equality of <tt>a</tt> and <tt>b</tt>.
testEquality :: forall (a :: k) (b :: k). TestEquality f => f a -> f b -> Maybe (a :~: b)

-- | A type family to compute Boolean equality.
type family (a :: k) == (b :: k) :: Bool
infix 4 ==


-- | Reexports <a>Data.Type.Equality.Compat</a> from a globally unique
--   namespace.
module Data.Type.Equality.Compat.Repl.Batteries

module Data.Typeable.Compat


-- | Reexports <a>Data.Typeable.Compat</a> from a globally unique
--   namespace.
module Data.Typeable.Compat.Repl.Batteries

module Data.Version.Compat


-- | Reexports <a>Data.Version.Compat</a> from a globally unique namespace.
module Data.Version.Compat.Repl.Batteries

module Data.Void.Compat

-- | Uninhabited data type
data () => Void

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values. It is implemented in
--   terms of <tt>fmap absurd</tt>.
vacuous :: Functor f => f Void -> f a


-- | Reexports <a>Data.Void.Compat</a> from a globally unique namespace.
module Data.Void.Compat.Repl.Batteries

module Data.Word.Compat


-- | Reexports <a>Data.Word.Compat</a> from a globally unique namespace.
module Data.Word.Compat.Repl.Batteries

module Debug.Trace.Compat


-- | Reexports <a>Debug.Trace.Compat</a> from a globally unique namespace.
module Debug.Trace.Compat.Repl.Batteries

module Foreign.Compat


-- | Reexports <a>Foreign.Compat</a> from a globally unique namespace.
module Foreign.Compat.Repl.Batteries

module Foreign.ForeignPtr.Compat


-- | Reexports <a>Foreign.ForeignPtr.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Compat.Repl.Batteries

module Foreign.ForeignPtr.Safe.Compat


-- | Reexports <a>Foreign.ForeignPtr.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Safe.Compat.Repl.Batteries

module Foreign.ForeignPtr.Unsafe.Compat


-- | Reexports <a>Foreign.ForeignPtr.Unsafe.Compat</a> from a globally
--   unique namespace.
module Foreign.ForeignPtr.Unsafe.Compat.Repl.Batteries

module Foreign.Marshal.Alloc.Compat


-- | Reexports <a>Foreign.Marshal.Alloc.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Alloc.Compat.Repl.Batteries

module Foreign.Marshal.Array.Compat


-- | Reexports <a>Foreign.Marshal.Array.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Array.Compat.Repl.Batteries

module Foreign.Marshal.Compat


-- | Reexports <a>Foreign.Marshal.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Compat.Repl.Batteries

module Foreign.Marshal.Safe.Compat


-- | Reexports <a>Foreign.Marshal.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Safe.Compat.Repl.Batteries

module Foreign.Marshal.Unsafe.Compat


-- | Reexports <a>Foreign.Marshal.Unsafe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Unsafe.Compat.Repl.Batteries

module Foreign.Marshal.Utils.Compat


-- | Reexports <a>Foreign.Marshal.Utils.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Utils.Compat.Repl.Batteries

module Numeric.Compat


-- | Reexports <a>Numeric.Compat</a> from a globally unique namespace.
module Numeric.Compat.Repl.Batteries

module Numeric.Natural.Compat

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural


-- | Reexports <a>Numeric.Natural.Compat</a> from a globally unique
--   namespace.
module Numeric.Natural.Compat.Repl.Batteries

module Prelude.Compat


-- | Reexports <a>Prelude.Compat</a> from a globally unique namespace.
module Prelude.Compat.Repl.Batteries

module System.Environment.Compat


-- | Reexports <a>System.Environment.Compat</a> from a globally unique
--   namespace.
module System.Environment.Compat.Repl.Batteries

module System.Exit.Compat


-- | Reexports <a>System.Exit.Compat</a> from a globally unique namespace.
module System.Exit.Compat.Repl.Batteries

module System.IO.Compat


-- | Reexports <a>System.IO.Compat</a> from a globally unique namespace.
module System.IO.Compat.Repl.Batteries

module System.IO.Error.Compat


-- | Reexports <a>System.IO.Error.Compat</a> from a globally unique
--   namespace.
module System.IO.Error.Compat.Repl.Batteries

module System.IO.Unsafe.Compat


-- | Reexports <a>System.IO.Unsafe.Compat</a> from a globally unique
--   namespace.
module System.IO.Unsafe.Compat.Repl.Batteries

module Text.Read.Compat


-- | Reexports <a>Text.Read.Compat</a> from a globally unique namespace.
module Text.Read.Compat.Repl.Batteries

module Text.Read.Lex.Compat


-- | Reexports <a>Text.Read.Lex.Compat</a> from a globally unique
--   namespace.
module Text.Read.Lex.Compat.Repl.Batteries

module Type.Reflection.Compat


-- | Reexports <a>Type.Reflection.Compat</a> from a globally unique
--   namespace.
module Type.Reflection.Compat.Repl.Batteries
