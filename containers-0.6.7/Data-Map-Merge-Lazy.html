<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.Map.Merge.Lazy</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">containers-0.6.7: Assorted concrete container types</span><ul class="links" id="page-menu"><li><a href="src/Data.Map.Merge.Lazy.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) David Feuer 2016</td></tr><tr><th>License</th><td>BSD-style</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Map.Merge.Lazy</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Simple merge tactic types</a></li><li><a href="#g:2">General combining function</a><ul><li><a href="#g:3"><code>WhenMatched</code> tactics</a></li><li><a href="#g:4"><code>WhenMissing</code> tactics</a></li></ul></li><li><a href="#g:5">Applicative merge tactic types</a></li><li><a href="#g:6">Applicative general combining function</a><ul><li><a href="#g:7"><code>WhenMatched</code> tactics</a></li><li><a href="#g:8"><code>WhenMissing</code> tactics</a></li><li><a href="#g:9">Covariant maps for tactics</a></li><li><a href="#g:10">Contravariant maps for tactics</a></li><li><a href="#g:11">Miscellaneous tactic functions</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines an API for writing functions that merge two
 maps. The key functions are <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> and <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code>.
 Each of these can be used with several different &quot;merge tactics&quot;.</p><p>The <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> and <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> functions are shared by
 the lazy and strict modules. Only the choice of merge tactics
 determines strictness. If you use <code><a href="Data-Map-Merge-Strict.html#v:mapMissing" title="Data.Map.Merge.Strict">mapMissing</a></code>
 from <a href="Data-Map-Merge-Strict.html">Data.Map.Merge.Strict</a> then the results will be forced before
 they are inserted. If you use <code><a href="Data-Map-Merge-Lazy.html#v:mapMissing" title="Data.Map.Merge.Lazy">mapMissing</a></code> from
 this module then they will not.</p><h2>Efficiency note</h2><p>The <code><a href="../base-4.18.2.1/Control-Category.html#v:Category" title="Control.Category">Category</a></code>, <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>, and <code><a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instances for
 <code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> tactics are included because they are valid. However, they are
 inefficient in many cases and should usually be avoided. The instances
 for <code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code> tactics should not pose any major efficiency problems.</p><p><em>Since: containers-0.5.9</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleWhenMissing">SimpleWhenMissing</a> = <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> <a href="Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleWhenMatched">SimpleWhenMatched</a> = <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> <a href="Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a></li><li class="src short"><a href="#v:merge">merge</a> :: <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMissing" title="Data.Map.Merge.Lazy">SimpleWhenMissing</a> k a c -&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMissing" title="Data.Map.Merge.Lazy">SimpleWhenMissing</a> k b c -&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMatched" title="Data.Map.Merge.Lazy">SimpleWhenMatched</a> k a b c -&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k a -&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b -&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k c</li><li class="src short"><a href="#v:zipWithMaybeMatched">zipWithMaybeMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z</li><li class="src short"><a href="#v:zipWithMatched">zipWithMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z</li><li class="src short"><a href="#v:mapMaybeMissing">mapMaybeMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y</li><li class="src short"><a href="#v:dropMissing">dropMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y</li><li class="src short"><a href="#v:preserveMissing">preserveMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x</li><li class="src short"><a href="#v:mapMissing">mapMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y</li><li class="src short"><a href="#v:filterMissing">filterMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x</li><li class="src short"><span class="keyword">data</span> <a href="#t:WhenMissing">WhenMissing</a> f k x y</li><li class="src short"><span class="keyword">data</span> <a href="#t:WhenMatched">WhenMatched</a> f k x y z</li><li class="src short"><a href="#v:mergeA">mergeA</a> :: (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a c -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k b c -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k a b c -&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k a -&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b -&gt; f (<a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k c)</li><li class="src short"><a href="#v:zipWithMaybeAMatched">zipWithMaybeAMatched</a> :: (k -&gt; x -&gt; y -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z)) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z</li><li class="src short"><a href="#v:zipWithAMatched">zipWithAMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z</li><li class="src short"><a href="#v:traverseMaybeMissing">traverseMaybeMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y)) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y</li><li class="src short"><a href="#v:traverseMissing">traverseMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y</li><li class="src short"><a href="#v:filterAMissing">filterAMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x</li><li class="src short"><a href="#v:mapWhenMissing">mapWhenMissing</a> :: (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b</li><li class="src short"><a href="#v:mapWhenMatched">mapWhenMatched</a> :: <a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b</li><li class="src short"><a href="#v:lmapWhenMissing">lmapWhenMissing</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a x -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k b x</li><li class="src short"><a href="#v:contramapFirstWhenMatched">contramapFirstWhenMatched</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k a y z -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k b y z</li><li class="src short"><a href="#v:contramapSecondWhenMatched">contramapSecondWhenMatched</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x a z -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x b z</li><li class="src short"><a href="#v:runWhenMatched">runWhenMatched</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z -&gt; k -&gt; x -&gt; y -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z)</li><li class="src short"><a href="#v:runWhenMissing">runWhenMissing</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y -&gt; k -&gt; x -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h2>Simple merge tactic types</h2></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleWhenMissing" class="def">SimpleWhenMissing</a> = <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> <a href="Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="src/Data.Map.Internal.html#SimpleWhenMissing" class="link">Source</a> <a href="#t:SimpleWhenMissing" class="selflink">#</a></p><div class="doc"><p>A tactic for dealing with keys present in one map but not the other in
 <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code>.</p><p>A tactic of type <code> SimpleWhenMissing k x z </code> is an abstract representation
 of a function of type <code> k -&gt; x -&gt; Maybe z </code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleWhenMatched" class="def">SimpleWhenMatched</a> = <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> <a href="Data-Map-Internal.html#t:Identity" title="Data.Map.Internal">Identity</a> <a href="src/Data.Map.Internal.html#SimpleWhenMatched" class="link">Source</a> <a href="#t:SimpleWhenMatched" class="selflink">#</a></p><div class="doc"><p>A tactic for dealing with keys present in both maps in <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code>.</p><p>A tactic of type <code> SimpleWhenMatched k x y z </code> is an abstract representation
 of a function of type <code> k -&gt; x -&gt; y -&gt; Maybe z </code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:2" id="g:2"><h2>General combining function</h2></a><div class="top"><p class="src"><a id="v:merge" class="def">merge</a> <a href="src/Data.Map.Internal.html#merge" class="link">Source</a> <a href="#v:merge" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMissing" title="Data.Map.Merge.Lazy">SimpleWhenMissing</a> k a c</td><td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMissing" title="Data.Map.Merge.Lazy">SimpleWhenMissing</a> k b c</td><td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMatched" title="Data.Map.Merge.Lazy">SimpleWhenMatched</a> k a b c</td><td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k a</td><td class="doc"><p>Map <code>m1</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b</td><td class="doc"><p>Map <code>m2</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k c</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Merge two maps.</p><p><code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> takes two <code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> tactics, a <code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code>
 tactic and two maps. It uses the tactics to merge the maps.
 Its behavior is best understood via its fundamental tactics,
 <code><a href="Data-Map-Merge-Lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> and <code><a href="Data-Map-Merge-Lazy.html#v:zipWithMaybeMatched" title="Data.Map.Merge.Lazy">zipWithMaybeMatched</a></code>.</p><p>Consider</p><pre>merge (mapMaybeMissing g1)
             (mapMaybeMissing g2)
             (zipWithMaybeMatched f)
             m1 m2
</pre><p>Take, for example,</p><pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, &quot;one&quot;), (2, &quot;two&quot;), (4, &quot;three&quot;)]
</pre><p><code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> will first &quot;align&quot; these maps by key:</p><pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, &quot;one&quot;), (2, &quot;two&quot;),           (4, &quot;three&quot;)]
</pre><p>It will then pass the individual entries and pairs of entries
 to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p><pre>maybes = [g1 0 'a', f 1 'b' &quot;one&quot;, g2 2 &quot;two&quot;, g1 3 'c', f 4 'd' &quot;three&quot;]
</pre><p>This produces a <code><a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> for each key:</p><pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre><p>Finally, the <code>Just</code> results are collected into a map:</p><pre>return value = [(1, True), (2, False), (4, True)]
</pre><p>The other tactics below are optimizations or simplifications of
 <code><a href="Data-Map-Merge-Lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> for special cases. Most importantly,</p><ul><li><code><a href="Data-Map-Merge-Lazy.html#v:dropMissing" title="Data.Map.Merge.Lazy">dropMissing</a></code> drops all the keys.</li><li><code><a href="Data-Map-Merge-Lazy.html#v:preserveMissing" title="Data.Map.Merge.Lazy">preserveMissing</a></code> leaves all the entries alone.</li></ul><p>When <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> is given three arguments, it is inlined at the call
 site. To prevent excessive inlining, you should typically use <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code>
 to define your custom combining functions.</p><p>Examples:</p><pre>unionWithKey f = merge preserveMissing preserveMissing (zipWithMatched f)</pre><pre>intersectionWithKey f = merge dropMissing dropMissing (zipWithMatched f)</pre><pre>differenceWith f = merge preserveMissing dropMissing (zipWithMatched f)</pre><pre>symmetricDifference = merge preserveMissing preserveMissing (zipWithMaybeMatched $ \ _ _ _ -&gt; Nothing)</pre><pre>mapEachPiece f g h = merge (mapMissing f) (mapMissing g) (zipWithMatched h)</pre><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:3" id="g:3"><h3><code>WhenMatched</code> tactics</h3></a><div class="top"><p class="src"><a id="v:zipWithMaybeMatched" class="def">zipWithMaybeMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z <a href="src/Data.Map.Internal.html#zipWithMaybeMatched" class="link">Source</a> <a href="#v:zipWithMaybeMatched" class="selflink">#</a></p><div class="doc"><p>When a key is found in both maps, apply a function to the
 key and values and maybe use the result in the merged map.</p><pre>zipWithMaybeMatched :: (k -&gt; x -&gt; y -&gt; Maybe z)
                    -&gt; SimpleWhenMatched k x y z
</pre><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithMatched" class="def">zipWithMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z <a href="src/Data.Map.Internal.html#zipWithMatched" class="link">Source</a> <a href="#v:zipWithMatched" class="selflink">#</a></p><div class="doc"><p>When a key is found in both maps, apply a function to the
 key and values and use the result in the merged map.</p><pre>zipWithMatched :: (k -&gt; x -&gt; y -&gt; z)
               -&gt; SimpleWhenMatched k x y z
</pre><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:4" id="g:4"><h3><code>WhenMissing</code> tactics</h3></a><div class="top"><p class="src"><a id="v:mapMaybeMissing" class="def">mapMaybeMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#mapMaybeMissing" class="link">Source</a> <a href="#v:mapMaybeMissing" class="selflink">#</a></p><div class="doc"><p>Map over the entries whose keys are missing from the other map,
 optionally removing some. This is the most powerful <code><a href="Data-Map-Merge-Lazy.html#t:SimpleWhenMissing" title="Data.Map.Merge.Lazy">SimpleWhenMissing</a></code>
 tactic, but others are usually more efficient.</p><pre>mapMaybeMissing :: (k -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing k x y
</pre><pre>mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</pre><p>but <code>mapMaybeMissing</code> uses fewer unnecessary <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> operations.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:dropMissing" class="def">dropMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#dropMissing" class="link">Source</a> <a href="#v:dropMissing" class="selflink">#</a></p><div class="doc"><p>Drop all the entries whose keys are missing from the other
 map.</p><pre>dropMissing :: SimpleWhenMissing k x y
</pre><pre>dropMissing = mapMaybeMissing (\_ _ -&gt; Nothing)</pre><p>but <code>dropMissing</code> is much faster.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:preserveMissing" class="def">preserveMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x <a href="src/Data.Map.Internal.html#preserveMissing" class="link">Source</a> <a href="#v:preserveMissing" class="selflink">#</a></p><div class="doc"><p>Preserve, unchanged, the entries whose keys are missing from
 the other map.</p><pre>preserveMissing :: SimpleWhenMissing k x x
</pre><pre>preserveMissing = Merge.Lazy.mapMaybeMissing (\_ x -&gt; Just x)</pre><p>but <code>preserveMissing</code> is much faster.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:mapMissing" class="def">mapMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#mapMissing" class="link">Source</a> <a href="#v:mapMissing" class="selflink">#</a></p><div class="doc"><p>Map over the entries whose keys are missing from the other map.</p><pre>mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing k x y
</pre><pre>mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</pre><p>but <code>mapMissing</code> is somewhat faster.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:filterMissing" class="def">filterMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x <a href="src/Data.Map.Internal.html#filterMissing" class="link">Source</a> <a href="#v:filterMissing" class="selflink">#</a></p><div class="doc"><p>Filter the entries whose keys are missing from the other map.</p><pre>filterMissing :: (k -&gt; x -&gt; Bool) -&gt; SimpleWhenMissing k x x
</pre><pre>filterMissing f = Merge.Lazy.mapMaybeMissing $ \k x -&gt; guard (f k x) *&gt; Just x</pre><p>but this should be a little faster.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:5" id="g:5"><h2>Applicative merge tactic types</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:WhenMissing" class="def">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#WhenMissing" class="link">Source</a> <a href="#t:WhenMissing" class="selflink">#</a></p><div class="doc"><p>A tactic for dealing with keys present in one map but not the other in
 <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> or <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code>.</p><p>A tactic of type <code> WhenMissing f k x z </code> is an abstract representation
 of a function of type <code> k -&gt; x -&gt; f (Maybe z) </code>.</p><p><em>Since: containers-0.5.9</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMissing">Instances</h4><details id="i:WhenMissing" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMissing:Category:1"></span> (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.18.2.1/Control-Category.html#t:Category" title="Control.Category">Category</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</span> <a href="src/Data.Map.Internal.html#line-2118" class="link">Source</a> <a href="#t:WhenMissing" class="selflink">#</a></td><td class="doc"><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMissing:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:id">id</a> :: <span class="keyword">forall</span> (a :: k0). <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a a <a href="../base-4.18.2.1/src/Control.Category.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:.">(.)</a> :: <span class="keyword">forall</span> (b :: k0) (c :: k0) (a :: k0). <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k b c -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a c <a href="../base-4.18.2.1/src/Control.Category.html#." class="link">Source</a> <a href="#v:." class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMissing:Applicative:2"></span> (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x)</span> <a href="src/Data.Map.Internal.html#line-2132" class="link">Source</a> <a href="#t:WhenMissing" class="selflink">#</a></td><td class="doc"><p>Equivalent to <code> ReaderT k (ReaderT x (MaybeT f)) </code>.</p><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMissing:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a <a href="../base-4.18.2.1/src/GHC.Base.html#pure" class="link">Source</a> <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%2A%3E" class="link">Source</a> <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x c <a href="../base-4.18.2.1/src/GHC.Base.html#liftA2" class="link">Source</a> <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="../base-4.18.2.1/src/GHC.Base.html#%2A%3E" class="link">Source</a> <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%2A" class="link">Source</a> <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMissing:Functor:3"></span> (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x)</span> <a href="src/Data.Map.Internal.html#line-2113" class="link">Source</a> <a href="#t:WhenMissing" class="selflink">#</a></td><td class="doc"><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMissing:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="../base-4.18.2.1/src/GHC.Base.html#fmap" class="link">Source</a> <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%24" class="link">Source</a> <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMissing:Monad:4"></span> (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x)</span> <a href="src/Data.Map.Internal.html#line-2145" class="link">Source</a> <a href="#t:WhenMissing" class="selflink">#</a></td><td class="doc"><p>Equivalent to <code> ReaderT k (ReaderT x (MaybeT f)) </code>.</p><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMissing:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; (a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="../base-4.18.2.1/src/GHC.Base.html#%3E%3E%3D" class="link">Source</a> <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="../base-4.18.2.1/src/GHC.Base.html#%3E%3E" class="link">Source</a> <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a <a href="../base-4.18.2.1/src/GHC.Base.html#return" class="link">Source</a> <a href="#v:return" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:WhenMatched" class="def">WhenMatched</a> f k x y z <a href="src/Data.Map.Internal.html#WhenMatched" class="link">Source</a> <a href="#t:WhenMatched" class="selflink">#</a></p><div class="doc"><p>A tactic for dealing with keys present in both
 maps in <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> or <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code>.</p><p>A tactic of type <code> WhenMatched f k x y z </code> is an abstract representation
 of a function of type <code> k -&gt; x -&gt; y -&gt; f (Maybe z) </code>.</p><p><em>Since: containers-0.5.9</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:WhenMatched">Instances</h4><details id="i:WhenMatched" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMatched:Category:1"></span> (<a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.18.2.1/Control-Category.html#t:Category" title="Control.Category">Category</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</span> <a href="src/Data.Map.Internal.html#line-2253" class="link">Source</a> <a href="#t:WhenMatched" class="selflink">#</a></td><td class="doc"><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMatched:Category:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:id">id</a> :: <span class="keyword">forall</span> (a :: k0). <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x a a <a href="../base-4.18.2.1/src/Control.Category.html#id" class="link">Source</a> <a href="#v:id" class="selflink">#</a></p><p class="src"><a href="#v:.">(.)</a> :: <span class="keyword">forall</span> (b :: k0) (c :: k0) (a :: k0). <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x b c -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x a b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x a c <a href="../base-4.18.2.1/src/Control.Category.html#." class="link">Source</a> <a href="#v:." class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMatched:Applicative:2"></span> (<a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y)</span> <a href="src/Data.Map.Internal.html#line-2267" class="link">Source</a> <a href="#t:WhenMatched" class="selflink">#</a></td><td class="doc"><p>Equivalent to <code> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMatched:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a <a href="../base-4.18.2.1/src/GHC.Base.html#pure" class="link">Source</a> <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%2A%3E" class="link">Source</a> <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y c <a href="../base-4.18.2.1/src/GHC.Base.html#liftA2" class="link">Source</a> <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="../base-4.18.2.1/src/GHC.Base.html#%2A%3E" class="link">Source</a> <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%2A" class="link">Source</a> <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMatched:Functor:3"></span> <a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; <a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y)</span> <a href="src/Data.Map.Internal.html#line-2248" class="link">Source</a> <a href="#t:WhenMatched" class="selflink">#</a></td><td class="doc"><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMatched:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="../base-4.18.2.1/src/GHC.Base.html#fmap" class="link">Source</a> <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a <a href="../base-4.18.2.1/src/GHC.Base.html#%3C%24" class="link">Source</a> <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WhenMatched:Monad:4"></span> (<a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f, <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y)</span> <a href="src/Data.Map.Internal.html#line-2280" class="link">Source</a> <a href="#t:WhenMatched" class="selflink">#</a></td><td class="doc"><p>Equivalent to <code> ReaderT k (ReaderT x (ReaderT y (MaybeT f))) </code></p><p><em>Since: containers-0.5.9</em></p></td></tr><tr><td colspan="2"><details id="i:id:WhenMatched:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Map-Internal.html">Data.Map.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; (a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="../base-4.18.2.1/src/GHC.Base.html#%3E%3E%3D" class="link">Source</a> <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="../base-4.18.2.1/src/GHC.Base.html#%3E%3E" class="link">Source</a> <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a <a href="../base-4.18.2.1/src/GHC.Base.html#return" class="link">Source</a> <a href="#v:return" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:6" id="g:6"><h2>Applicative general combining function</h2></a><div class="top"><p class="src"><a id="v:mergeA" class="def">mergeA</a> <a href="src/Data.Map.Internal.html#mergeA" class="link">Source</a> <a href="#v:mergeA" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a c</td><td class="doc"><p>What to do with keys in <code>m1</code> but not <code>m2</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k b c</td><td class="doc"><p>What to do with keys in <code>m2</code> but not <code>m1</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k a b c</td><td class="doc"><p>What to do with keys in both <code>m1</code> and <code>m2</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k a</td><td class="doc"><p>Map <code>m1</code></p></td></tr><tr><td class="src">-&gt; <a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k b</td><td class="doc"><p>Map <code>m2</code></p></td></tr><tr><td class="src">-&gt; f (<a href="Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> k c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>An applicative version of <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code>.</p><p><code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> takes two <code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> tactics, a <code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code>
 tactic and two maps. It uses the tactics to merge the maps.
 Its behavior is best understood via its fundamental tactics,
 <code><a href="Data-Map-Merge-Lazy.html#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> and <code><a href="Data-Map-Merge-Lazy.html#v:zipWithMaybeAMatched" title="Data.Map.Merge.Lazy">zipWithMaybeAMatched</a></code>.</p><p>Consider</p><pre>mergeA (traverseMaybeMissing g1)
              (traverseMaybeMissing g2)
              (zipWithMaybeAMatched f)
              m1 m2
</pre><p>Take, for example,</p><pre>m1 = [(0, 'a'), (1, 'b'), (3, 'c'), (4, 'd')]
m2 = [(1, &quot;one&quot;), (2, &quot;two&quot;), (4, &quot;three&quot;)]
</pre><p><code>mergeA</code> will first &quot;align&quot; these maps by key:</p><pre>m1 = [(0, 'a'), (1, 'b'),               (3, 'c'), (4, 'd')]
m2 =           [(1, &quot;one&quot;), (2, &quot;two&quot;),           (4, &quot;three&quot;)]
</pre><p>It will then pass the individual entries and pairs of entries
 to <code>g1</code>, <code>g2</code>, or <code>f</code> as appropriate:</p><pre>actions = [g1 0 'a', f 1 'b' &quot;one&quot;, g2 2 &quot;two&quot;, g1 3 'c', f 4 'd' &quot;three&quot;]
</pre><p>Next, it will perform the actions in the <code>actions</code> list in order from
 left to right.</p><pre>keys =     0        1          2           3        4
results = [Nothing, Just True, Just False, Nothing, Just True]
</pre><p>Finally, the <code>Just</code> results are collected into a map:</p><pre>return value = [(1, True), (2, False), (4, True)]
</pre><p>The other tactics below are optimizations or simplifications of
 <code><a href="Data-Map-Merge-Lazy.html#v:traverseMaybeMissing" title="Data.Map.Merge.Lazy">traverseMaybeMissing</a></code> for special cases. Most importantly,</p><ul><li><code><a href="Data-Map-Merge-Lazy.html#v:dropMissing" title="Data.Map.Merge.Lazy">dropMissing</a></code> drops all the keys.</li><li><code><a href="Data-Map-Merge-Lazy.html#v:preserveMissing" title="Data.Map.Merge.Lazy">preserveMissing</a></code> leaves all the entries alone.</li><li><code><a href="Data-Map-Merge-Lazy.html#v:mapMaybeMissing" title="Data.Map.Merge.Lazy">mapMaybeMissing</a></code> does not use the <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> context.</li></ul><p>When <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> is given three arguments, it is inlined at the call
 site. To prevent excessive inlining, you should generally only use
 <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> to define custom combining functions.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:7" id="g:7"><h3><code>WhenMatched</code> tactics</h3></a><div class="doc"><p>The tactics described for <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> work for
 <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> as well. Furthermore, the following
 are available.</p></div><div class="top"><p class="src"><a id="v:zipWithMaybeAMatched" class="def">zipWithMaybeAMatched</a> :: (k -&gt; x -&gt; y -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z)) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z <a href="src/Data.Map.Internal.html#zipWithMaybeAMatched" class="link">Source</a> <a href="#v:zipWithMaybeAMatched" class="selflink">#</a></p><div class="doc"><p>When a key is found in both maps, apply a function to the
 key and values, perform the resulting action, and maybe use
 the result in the merged map.</p><p>This is the fundamental <code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code> tactic.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithAMatched" class="def">zipWithAMatched</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; y -&gt; f z) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z <a href="src/Data.Map.Internal.html#zipWithAMatched" class="link">Source</a> <a href="#v:zipWithAMatched" class="selflink">#</a></p><div class="doc"><p>When a key is found in both maps, apply a function to the
 key and values to produce an action and use its result in the merged map.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:8" id="g:8"><h3><code>WhenMissing</code> tactics</h3></a><div class="doc"><p>The tactics described for <code><a href="Data-Map-Merge-Lazy.html#v:merge" title="Data.Map.Merge.Lazy">merge</a></code> work for
 <code><a href="Data-Map-Merge-Lazy.html#v:mergeA" title="Data.Map.Merge.Lazy">mergeA</a></code> as well. Furthermore, the following
 are available.</p></div><div class="top"><p class="src"><a id="v:traverseMaybeMissing" class="def">traverseMaybeMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y)) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#traverseMaybeMissing" class="link">Source</a> <a href="#v:traverseMaybeMissing" class="selflink">#</a></p><div class="doc"><p>Traverse over the entries whose keys are missing from the other map,
 optionally producing values to put in the result.
 This is the most powerful <code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> tactic, but others are usually
 more efficient.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:traverseMissing" class="def">traverseMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f y) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y <a href="src/Data.Map.Internal.html#traverseMissing" class="link">Source</a> <a href="#v:traverseMissing" class="selflink">#</a></p><div class="doc"><p>Traverse over the entries whose keys are missing from the other map.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:filterAMissing" class="def">filterAMissing</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (k -&gt; x -&gt; f <a href="../base-4.18.2.1/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x x <a href="src/Data.Map.Internal.html#filterAMissing" class="link">Source</a> <a href="#v:filterAMissing" class="selflink">#</a></p><div class="doc"><p>Filter the entries whose keys are missing from the other map
 using some <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> action.</p><pre>filterAMissing f = Merge.Lazy.traverseMaybeMissing $
  \k x -&gt; (\b -&gt; guard b *&gt; Just x) &lt;$&gt; f k x</pre><p>but this should be a little faster.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:9" id="g:9"><h3>Covariant maps for tactics</h3></a><div class="top"><p class="src"><a id="v:mapWhenMissing" class="def">mapWhenMissing</a> :: (<a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> f) =&gt; (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x b <a href="src/Data.Map.Internal.html#mapWhenMissing" class="link">Source</a> <a href="#v:mapWhenMissing" class="selflink">#</a></p><div class="doc"><p>Map covariantly over a <code><code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> f k x</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:mapWhenMatched" class="def">mapWhenMatched</a> :: <a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y a -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y b <a href="src/Data.Map.Internal.html#mapWhenMatched" class="link">Source</a> <a href="#v:mapWhenMatched" class="selflink">#</a></p><div class="doc"><p>Map covariantly over a <code><code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code> f k x y</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:10" id="g:10"><h3>Contravariant maps for tactics</h3></a><div class="top"><p class="src"><a id="v:lmapWhenMissing" class="def">lmapWhenMissing</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k a x -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k b x <a href="src/Data.Map.Internal.html#lmapWhenMissing" class="link">Source</a> <a href="#v:lmapWhenMissing" class="selflink">#</a></p><div class="doc"><p>Map contravariantly over a <code><code><a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a></code> f k _ x</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:contramapFirstWhenMatched" class="def">contramapFirstWhenMatched</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k a y z -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k b y z <a href="src/Data.Map.Internal.html#contramapFirstWhenMatched" class="link">Source</a> <a href="#v:contramapFirstWhenMatched" class="selflink">#</a></p><div class="doc"><p>Map contravariantly over a <code><code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code> f k _ y z</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:contramapSecondWhenMatched" class="def">contramapSecondWhenMatched</a> :: (b -&gt; a) -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x a z -&gt; <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x b z <a href="src/Data.Map.Internal.html#contramapSecondWhenMatched" class="link">Source</a> <a href="#v:contramapSecondWhenMatched" class="selflink">#</a></p><div class="doc"><p>Map contravariantly over a <code><code><a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a></code> f k x _ z</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><a href="#g:11" id="g:11"><h3>Miscellaneous tactic functions</h3></a><div class="top"><p class="src"><a id="v:runWhenMatched" class="def">runWhenMatched</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMatched" title="Data.Map.Merge.Lazy">WhenMatched</a> f k x y z -&gt; k -&gt; x -&gt; y -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> z) <a href="src/Data.Map.Internal.html#runWhenMatched" class="link">Source</a> <a href="#v:runWhenMatched" class="selflink">#</a></p><div class="doc"><p>Along with zipWithMaybeAMatched, witnesses the isomorphism between
 <code>WhenMatched f k x y z</code> and <code>k -&gt; x -&gt; y -&gt; f (Maybe z)</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div><div class="top"><p class="src"><a id="v:runWhenMissing" class="def">runWhenMissing</a> :: <a href="Data-Map-Merge-Lazy.html#t:WhenMissing" title="Data.Map.Merge.Lazy">WhenMissing</a> f k x y -&gt; k -&gt; x -&gt; f (<a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> y) <a href="src/Data.Map.Internal.html#runWhenMissing" class="link">Source</a> <a href="#v:runWhenMissing" class="selflink">#</a></p><div class="doc"><p>Along with traverseMaybeMissing, witnesses the isomorphism between
 <code>WhenMissing f k x y</code> and <code>k -&gt; x -&gt; f (Maybe y)</code>.</p><p><em>Since: containers-0.5.9</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>