<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE BangPatterns #-}</span><span class="hs-cpp">
#if !defined(TESTING) &amp;&amp; defined(__GLASGOW_HASKELL__)
</span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#include &quot;containers.h&quot;
</span><span>
</span><span id="line-9"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Module      :  Data.IntMap.Merge.Strict</span><span>
</span><span id="line-12"></span><span class="hs-comment">-- Copyright   :  (c) wren romano 2016</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- License     :  BSD-style</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- Maintainer  :  libraries@haskell.org</span><span>
</span><span id="line-15"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-16"></span><span class="hs-comment">--</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- This module defines an API for writing functions that merge two</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- maps. The key functions are 'merge' and 'mergeA'.</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- Each of these can be used with several different \&quot;merge tactics\&quot;.</span><span>
</span><span id="line-20"></span><span class="hs-comment">--</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- The 'merge' and 'mergeA' functions are shared by</span><span>
</span><span id="line-22"></span><span class="hs-comment">-- the lazy and strict modules. Only the choice of merge tactics</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- determines strictness. If you use 'Data.Map.Merge.Strict.mapMissing'</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- from this module then the results will be forced before they are</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- inserted. If you use 'Data.Map.Merge.Lazy.mapMissing' from</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- &quot;Data.Map.Merge.Lazy&quot; then they will not.</span><span>
</span><span id="line-27"></span><span class="hs-comment">--</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- == Efficiency note</span><span>
</span><span id="line-29"></span><span class="hs-comment">--</span><span>
</span><span id="line-30"></span><span class="hs-comment">-- The 'Control.Category.Category', 'Applicative', and 'Monad' instances for</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- 'WhenMissing' tactics are included because they are valid. However, they are</span><span>
</span><span id="line-32"></span><span class="hs-comment">-- inefficient in many cases and should usually be avoided. The instances</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- for 'WhenMatched' tactics should not pose any major efficiency problems.</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- @since 0.5.9</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data.IntMap.Merge.Strict</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Simple merge tactic types</span></span><span>
</span><span id="line-39"></span><span>      </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMissing"><span class="hs-identifier">SimpleWhenMissing</span></a></span><span>
</span><span id="line-40"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMatched"><span class="hs-identifier">SimpleWhenMatched</span></a></span><span>
</span><span id="line-41"></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** General combining function</span></span><span>
</span><span id="line-43"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#merge"><span class="hs-identifier">merge</span></a></span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMatched@ tactics</span></span><span>
</span><span id="line-46"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier">zipWithMaybeMatched</span></a></span><span>
</span><span id="line-47"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier">zipWithMatched</span></a></span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMissing@ tactics</span></span><span>
</span><span id="line-50"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier">mapMaybeMissing</span></a></span><span>
</span><span id="line-51"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#dropMissing"><span class="hs-identifier">dropMissing</span></a></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#preserveMissing"><span class="hs-identifier">preserveMissing</span></a></span><span>
</span><span id="line-53"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier">mapMissing</span></a></span><span>
</span><span id="line-54"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterMissing"><span class="hs-identifier">filterMissing</span></a></span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Applicative merge tactic types</span></span><span>
</span><span id="line-57"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier">WhenMissing</span></a></span><span>
</span><span id="line-58"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier">WhenMatched</span></a></span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Applicative general combining function</span></span><span>
</span><span id="line-61"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#mergeA"><span class="hs-identifier">mergeA</span></a></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMatched@ tactics</span></span><span>
</span><span id="line-64"></span><span>    </span><span class="hs-comment">-- | The tactics described for 'merge' work for</span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-comment">-- 'mergeA' as well. Furthermore, the following</span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-comment">-- are available.</span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier">zipWithMaybeAMatched</span></a></span><span>
</span><span id="line-68"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier">zipWithAMatched</span></a></span><span>
</span><span id="line-69"></span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="hs-comment">-- *** @WhenMissing@ tactics</span></span><span>
</span><span id="line-71"></span><span>    </span><span class="hs-comment">-- | The tactics described for 'merge' work for</span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-comment">-- 'mergeA' as well. Furthermore, the following</span><span>
</span><span id="line-73"></span><span>    </span><span class="hs-comment">-- are available.</span><span>
</span><span id="line-74"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier">traverseMaybeMissing</span></a></span><span>
</span><span id="line-75"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier">traverseMissing</span></a></span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterAMissing"><span class="hs-identifier">filterAMissing</span></a></span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Covariant maps for tactics</span></span><span>
</span><span id="line-79"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier">mapWhenMissing</span></a></span><span>
</span><span id="line-80"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier">mapWhenMatched</span></a></span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Miscellaneous functions on tactics</span></span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier">runWhenMatched</span></a></span><span>
</span><span id="line-85"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMissing"><span class="hs-identifier">runWhenMissing</span></a></span><span>
</span><span id="line-86"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html"><span class="hs-identifier">Data.IntMap.Internal</span></a></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMissing"><span class="hs-identifier">SimpleWhenMissing</span></a></span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#SimpleWhenMatched"><span class="hs-identifier">SimpleWhenMatched</span></a></span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#merge"><span class="hs-identifier">merge</span></a></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#dropMissing"><span class="hs-identifier">dropMissing</span></a></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#preserveMissing"><span class="hs-identifier">preserveMissing</span></a></span><span>
</span><span id="line-94"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterMissing"><span class="hs-identifier">filterMissing</span></a></span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier">WhenMissing</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier">WhenMatched</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#mergeA"><span class="hs-identifier">mergeA</span></a></span><span>
</span><span id="line-98"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#filterAMissing"><span class="hs-identifier">filterAMissing</span></a></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier">runWhenMatched</span></a></span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#runWhenMissing"><span class="hs-identifier">runWhenMissing</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.IntMap.Strict.Internal.html"><span class="hs-identifier">Data.IntMap.Strict.Internal</span></a></span><span>
</span><span id="line-103"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Prelude.html#/Prelude.html"><span class="hs-identifier">Prelude</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.List.html#filter/GHC.List.html#filter"><span class="hs-identifier">filter</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#map/GHC.Base.html#map"><span class="hs-identifier">map</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Foldable.html#foldl/Data.Foldable.html#foldl"><span class="hs-identifier">foldl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/Data.Foldable.html#foldr/Data.Foldable.html#foldr"><span class="hs-identifier">foldr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="annot"><span class="hs-comment">-- | Map covariantly over a @'WhenMissing' f k x@.</span></span><span>
</span><span id="line-106"></span><span id="local-6989586621679206265"><span id="local-6989586621679206266"><span id="local-6989586621679206267"><span id="local-6989586621679206268"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier hs-type">mapWhenMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Functor/GHC.Base.html#Functor"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679206266"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206267"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206268"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206266"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206265"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206268"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206267"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span><span>
</span><span id="line-107"></span><span id="mapWhenMissing"><span class="annot"><span class="annottext">mapWhenMissing :: forall (f :: * -&gt; *) a b x.
Functor f =&gt;
(a -&gt; b) -&gt; WhenMissing f x a -&gt; WhenMissing f x b
</span><a href="Data.IntMap.Merge.Strict.html#mapWhenMissing"><span class="hs-identifier hs-var hs-var">mapWhenMissing</span></a></span></span><span> </span><span id="local-6989586621679206415"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679206415"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679206416"><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679206416"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-108"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap b)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(IntMap a -&gt; IntMap b) -&gt; f (IntMap a) -&gt; f (IntMap b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; IntMap a -&gt; IntMap b
forall a b. (a -&gt; b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679206415"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f (IntMap a) -&gt; f (IntMap b))
-&gt; (IntMap x -&gt; f (IntMap a)) -&gt; IntMap x -&gt; f (IntMap b)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a -&gt; IntMap x -&gt; f (IntMap a)
forall (f :: * -&gt; *) x y.
WhenMissing f x y -&gt; IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679206416"><span class="hs-identifier hs-var">q</span></a></span><span>
</span><span id="line-109"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe b)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206421"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206421"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206422"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206422"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; Maybe b) -&gt; f (Maybe a) -&gt; f (Maybe b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe b -&gt; Maybe b
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; Maybe b) -&gt; (Maybe a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679206415"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f (Maybe a) -&gt; f (Maybe b)) -&gt; f (Maybe a) -&gt; f (Maybe b)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a -&gt; Key -&gt; x -&gt; f (Maybe a)
forall (f :: * -&gt; *) x y.
WhenMissing f x y -&gt; Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMissing f x a
</span><a href="#local-6989586621679206416"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206421"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206422"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="annot"><span class="hs-comment">-- | Map covariantly over a @'WhenMatched' f k x y@.</span></span><span>
</span><span id="line-112"></span><span id="local-6989586621679206294"><span id="local-6989586621679206295"><span id="local-6989586621679206296"><span id="local-6989586621679206297"><span id="local-6989586621679206298"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier hs-type">mapWhenMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Functor/GHC.Base.html#Functor"><span class="hs-identifier hs-type">Functor</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206294"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679206295"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206296"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206294"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206297"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206298"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206295"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206294"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206297"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206298"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206296"><span class="hs-identifier hs-type">b</span></a></span></span></span></span></span></span><span>
</span><span id="line-113"></span><span id="mapWhenMatched"><span class="annot"><span class="annottext">mapWhenMatched :: forall (f :: * -&gt; *) a b x y.
Functor f =&gt;
(a -&gt; b) -&gt; WhenMatched f x y a -&gt; WhenMatched f x y b
</span><a href="Data.IntMap.Merge.Strict.html#mapWhenMatched"><span class="hs-identifier hs-var hs-var">mapWhenMatched</span></a></span></span><span> </span><span id="local-6989586621679206427"><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679206427"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679206428"><span class="annot"><span class="annottext">WhenMatched f x y a
</span><a href="#local-6989586621679206428"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">matchedKey :: Key -&gt; x -&gt; y -&gt; f (Maybe b)
</span><a href="Data.IntMap.Internal.html#matchedKey"><span class="hs-identifier hs-var">matchedKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206430"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206430"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206431"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206431"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679206432"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206432"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; Maybe b) -&gt; f (Maybe a) -&gt; f (Maybe b)
forall a b. (a -&gt; b) -&gt; f a -&gt; f b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe b -&gt; Maybe b
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe b -&gt; Maybe b) -&gt; (Maybe a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#./GHC.Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">(a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall a b. (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#fmap/GHC.Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; b
</span><a href="#local-6989586621679206427"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(f (Maybe a) -&gt; f (Maybe b)) -&gt; f (Maybe a) -&gt; f (Maybe b)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMatched f x y a -&gt; Key -&gt; x -&gt; y -&gt; f (Maybe a)
forall (f :: * -&gt; *) x y z.
WhenMatched f x y z -&gt; Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="Data.IntMap.Internal.html#runWhenMatched"><span class="hs-identifier hs-var">runWhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">WhenMatched f x y a
</span><a href="#local-6989586621679206428"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206430"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206431"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206432"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-117"></span><span class="hs-comment">-- key and values and maybe use the result in the merged map.</span><span>
</span><span id="line-118"></span><span class="hs-comment">--</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- zipWithMaybeMatched :: (k -&gt; x -&gt; y -&gt; Maybe z)</span><span>
</span><span id="line-121"></span><span class="hs-comment">--                     -&gt; SimpleWhenMatched k x y z</span><span>
</span><span id="line-122"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-123"></span><span id="local-6989586621679206309"><span id="local-6989586621679206310"><span id="local-6989586621679206311"><span id="local-6989586621679206312"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier hs-type">zipWithMaybeMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206309"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-124"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206310"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206311"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206312"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206309"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206310"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206311"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206312"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-126"></span><span id="zipWithMaybeMatched"><span class="annot"><span class="annottext">zipWithMaybeMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; Maybe z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-identifier hs-var hs-var">zipWithMaybeMatched</span></a></span></span><span> </span><span id="local-6989586621679206435"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; Maybe z
</span><a href="#local-6989586621679206435"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">((Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z)
-&gt; (Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-127"></span><span>  </span><span class="hs-glyph">\</span><span id="local-6989586621679206436"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206436"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206437"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206437"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679206438"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206438"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe z -&gt; f (Maybe z)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe z -&gt; f (Maybe z)) -&gt; Maybe z -&gt; f (Maybe z)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe z -&gt; Maybe z
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe z -&gt; Maybe z) -&gt; Maybe z -&gt; Maybe z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; Maybe z
</span><a href="#local-6989586621679206435"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206436"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206437"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206438"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-128"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeMatched"><span class="hs-pragma hs-type">zipWithMaybeMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- key and values, perform the resulting action, and maybe use</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- the result in the merged map.</span><span>
</span><span id="line-133"></span><span class="hs-comment">--</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- This is the fundamental 'WhenMatched' tactic.</span><span>
</span><span id="line-135"></span><span id="local-6989586621679206323"><span id="local-6989586621679206324"><span id="local-6989586621679206325"><span id="local-6989586621679206326"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier hs-type">zipWithMaybeAMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206323"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-136"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206324"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206325"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206323"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206326"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-137"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206323"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206324"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206325"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206326"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-138"></span><span id="zipWithMaybeAMatched"><span class="annot"><span class="annottext">zipWithMaybeAMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-identifier hs-var hs-var">zipWithMaybeAMatched</span></a></span></span><span> </span><span id="local-6989586621679206444"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="#local-6989586621679206444"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">((Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z)
-&gt; (Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-139"></span><span>  </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679206445"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206445"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206446"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206446"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679206447"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206447"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe z -&gt; Maybe z
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe z -&gt; Maybe z) -&gt; f (Maybe z) -&gt; f (Maybe z)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/Data.Functor.html#%3C%24%3E/Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f (Maybe z)
</span><a href="#local-6989586621679206444"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206445"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206446"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206447"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-140"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMaybeAMatched"><span class="hs-pragma hs-type">zipWithMaybeAMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-143"></span><span class="hs-comment">-- key and values to produce an action and use its result in the merged map.</span><span>
</span><span id="line-144"></span><span id="local-6989586621679206334"><span id="local-6989586621679206335"><span id="local-6989586621679206336"><span id="local-6989586621679206337"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier hs-type">zipWithAMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206334"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-145"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206335"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206336"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206334"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206337"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-146"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206334"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206335"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206336"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206337"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-147"></span><span id="zipWithAMatched"><span class="annot"><span class="annottext">zipWithAMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; f z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-identifier hs-var hs-var">zipWithAMatched</span></a></span></span><span> </span><span id="local-6989586621679206452"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f z
</span><a href="#local-6989586621679206452"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">((Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z)
-&gt; (Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621679206453"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206453"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206454"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206454"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679206455"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206455"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">z -&gt; Maybe z
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">(z -&gt; Maybe z) -&gt; z -&gt; Maybe z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(z -&gt; Maybe z) -&gt; f z -&gt; f (Maybe z)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/Data.Functor.html#%3C%24%3E/Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; f z
</span><a href="#local-6989586621679206452"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206453"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206454"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206455"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-149"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithAMatched"><span class="hs-pragma hs-type">zipWithAMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-150"></span><span>
</span><span id="line-151"></span><span class="hs-comment">-- | When a key is found in both maps, apply a function to the</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- key and values and use the result in the merged map.</span><span>
</span><span id="line-153"></span><span class="hs-comment">--</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- zipWithMatched :: (k -&gt; x -&gt; y -&gt; z)</span><span>
</span><span id="line-156"></span><span class="hs-comment">--                -&gt; SimpleWhenMatched k x y z</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-158"></span><span id="local-6989586621679206343"><span id="local-6989586621679206344"><span id="local-6989586621679206345"><span id="local-6989586621679206346"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier hs-type">zipWithMatched</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206343"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-159"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206344"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206345"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206346"><span class="hs-identifier hs-type">z</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-type">WhenMatched</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206343"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206344"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206345"><span class="hs-identifier hs-type">y</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206346"><span class="hs-identifier hs-type">z</span></a></span></span></span></span></span><span>
</span><span id="line-160"></span><span id="zipWithMatched"><span class="annot"><span class="annottext">zipWithMatched :: forall (f :: * -&gt; *) x y z.
Applicative f =&gt;
(Key -&gt; x -&gt; y -&gt; z) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-identifier hs-var hs-var">zipWithMatched</span></a></span></span><span> </span><span id="local-6989586621679206458"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; z
</span><a href="#local-6989586621679206458"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall (f :: * -&gt; *) x y z.
(Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
</span><a href="Data.IntMap.Internal.html#WhenMatched"><span class="hs-identifier hs-var">WhenMatched</span></a></span><span> </span><span class="annot"><span class="annottext">((Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z)
-&gt; (Key -&gt; x -&gt; y -&gt; f (Maybe z)) -&gt; WhenMatched f x y z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24/GHC.Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-161"></span><span>  </span><span class="hs-glyph">\</span><span id="local-6989586621679206459"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206459"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206460"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206460"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679206461"><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206461"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe z -&gt; f (Maybe z)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe z -&gt; f (Maybe z)) -&gt; Maybe z -&gt; f (Maybe z)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">z -&gt; Maybe z
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">(z -&gt; Maybe z) -&gt; z -&gt; Maybe z
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y -&gt; z
</span><a href="#local-6989586621679206458"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206459"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206460"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">y
</span><a href="#local-6989586621679206461"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-162"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#zipWithMatched"><span class="hs-pragma hs-type">zipWithMatched</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span class="hs-comment">-- | Map over the entries whose keys are missing from the other map,</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- optionally removing some. This is the most powerful 'SimpleWhenMissing'</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- tactic, but others are usually more efficient.</span><span>
</span><span id="line-167"></span><span class="hs-comment">--</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- mapMaybeMissing :: (k -&gt; x -&gt; Maybe y) -&gt; SimpleWhenMissing k x y</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-171"></span><span class="hs-comment">--</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- prop&gt; mapMaybeMissing f = traverseMaybeMissing (\k x -&gt; pure (f k x))</span><span>
</span><span id="line-173"></span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- but @mapMaybeMissing@ uses fewer unnecessary 'Applicative' operations.</span><span>
</span><span id="line-175"></span><span id="local-6989586621679206351"><span id="local-6989586621679206352"><span id="local-6989586621679206353"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier hs-type">mapMaybeMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206351"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206352"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206353"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206351"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206352"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206353"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-176"></span><span id="mapMaybeMissing"><span class="annot"><span class="annottext">mapMaybeMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; Maybe y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-identifier hs-var hs-var">mapMaybeMissing</span></a></span></span><span> </span><span id="local-6989586621679206465"><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679206465"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-177"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206466"><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679206466"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IntMap y -&gt; f (IntMap y)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(IntMap y -&gt; f (IntMap y)) -&gt; IntMap y -&gt; f (IntMap y)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; Maybe y) -&gt; IntMap x -&gt; IntMap y
forall a b. (Key -&gt; a -&gt; Maybe b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#mapMaybeWithKey"><span class="hs-identifier hs-var">mapMaybeWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679206465"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679206466"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-178"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206468"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206468"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206469"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206469"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe y -&gt; f (Maybe y)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe y -&gt; f (Maybe y)) -&gt; Maybe y -&gt; f (Maybe y)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe y -&gt; Maybe y
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe y -&gt; Maybe y) -&gt; Maybe y -&gt; Maybe y
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; Maybe y
</span><a href="#local-6989586621679206465"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206468"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206469"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-179"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMaybeMissing"><span class="hs-pragma hs-type">mapMaybeMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- | Map over the entries whose keys are missing from the other map.</span><span>
</span><span id="line-182"></span><span class="hs-comment">--</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- mapMissing :: (k -&gt; x -&gt; y) -&gt; SimpleWhenMissing k x y</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-186"></span><span class="hs-comment">--</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- prop&gt; mapMissing f = mapMaybeMissing (\k x -&gt; Just $ f k x)</span><span>
</span><span id="line-188"></span><span class="hs-comment">--</span><span>
</span><span id="line-189"></span><span class="hs-comment">-- but @mapMissing@ is somewhat faster.</span><span>
</span><span id="line-190"></span><span id="local-6989586621679206359"><span id="local-6989586621679206360"><span id="local-6989586621679206361"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier hs-type">mapMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206359"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206360"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206361"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206359"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206360"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206361"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-191"></span><span id="mapMissing"><span class="annot"><span class="annottext">mapMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-identifier hs-var hs-var">mapMissing</span></a></span></span><span> </span><span id="local-6989586621679206473"><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679206473"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206474"><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679206474"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">IntMap y -&gt; f (IntMap y)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(IntMap y -&gt; f (IntMap y)) -&gt; IntMap y -&gt; f (IntMap y)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; y) -&gt; IntMap x -&gt; IntMap y
forall a b. (Key -&gt; a -&gt; b) -&gt; IntMap a -&gt; IntMap b
</span><a href="Data.IntMap.Strict.Internal.html#mapWithKey"><span class="hs-identifier hs-var">mapWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679206473"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap x
</span><a href="#local-6989586621679206474"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206476"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206476"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206477"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206477"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe y -&gt; f (Maybe y)
forall a. a -&gt; f a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#pure/GHC.Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe y -&gt; f (Maybe y)) -&gt; Maybe y -&gt; f (Maybe y)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">y -&gt; Maybe y
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">(y -&gt; Maybe y) -&gt; y -&gt; Maybe y
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; y
</span><a href="#local-6989586621679206473"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206476"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206477"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-194"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#mapMissing"><span class="hs-pragma hs-type">mapMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span class="hs-comment">-- | Traverse over the entries whose keys are missing from the other map,</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- optionally producing values to put in the result.</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- This is the most powerful 'WhenMissing' tactic, but others are usually</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- more efficient.</span><span>
</span><span id="line-200"></span><span id="local-6989586621679206367"><span id="local-6989586621679206368"><span id="local-6989586621679206369"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier hs-type">traverseMaybeMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206367"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-201"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206368"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206367"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206369"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206367"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206368"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206369"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-202"></span><span id="traverseMaybeMissing"><span class="annot"><span class="annottext">traverseMaybeMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; f (Maybe y)) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-identifier hs-var hs-var">traverseMaybeMissing</span></a></span></span><span> </span><span id="local-6989586621679206482"><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679206482"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; f (Maybe y)) -&gt; IntMap x -&gt; f (IntMap y)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(Key -&gt; a -&gt; f (Maybe b)) -&gt; IntMap a -&gt; f (IntMap b)
</span><a href="Data.IntMap.Strict.Internal.html#traverseMaybeWithKey"><span class="hs-identifier hs-var">traverseMaybeWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679206482"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206484"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206484"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206485"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206485"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe y -&gt; Maybe y
forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe y -&gt; Maybe y) -&gt; f (Maybe y) -&gt; f (Maybe y)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/Data.Functor.html#%3C%24%3E/Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f (Maybe y)
</span><a href="#local-6989586621679206482"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206484"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206485"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-205"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMaybeMissing"><span class="hs-pragma hs-type">traverseMaybeMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="annot"><span class="hs-comment">-- | Traverse over the entries whose keys are missing from the other map.</span></span><span>
</span><span id="line-208"></span><span id="local-6989586621679206376"><span id="local-6989586621679206377"><span id="local-6989586621679206378"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier hs-type">traverseMissing</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Base.html#Applicative/GHC.Base.html#Applicative"><span class="hs-identifier hs-type">Applicative</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206376"><span class="hs-identifier hs-type">f</span></a></span><span>
</span><span id="line-209"></span><span>                     </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Data.IntSet.Internal.html#Key"><span class="hs-identifier hs-type">Key</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206377"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679206376"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206378"><span class="hs-identifier hs-type">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206376"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206377"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206378"><span class="hs-identifier hs-type">y</span></a></span></span></span></span><span>
</span><span id="line-210"></span><span id="traverseMissing"><span class="annot"><span class="annottext">traverseMissing :: forall (f :: * -&gt; *) x y.
Applicative f =&gt;
(Key -&gt; x -&gt; f y) -&gt; WhenMissing f x y
</span><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-identifier hs-var hs-var">traverseMissing</span></a></span></span><span> </span><span id="local-6989586621679206490"><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679206490"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Data.IntMap.Internal.html#WhenMissing"><span class="hs-identifier hs-type">WhenMissing</span></a></span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">missingSubtree :: IntMap x -&gt; f (IntMap y)
</span><a href="Data.IntMap.Internal.html#missingSubtree"><span class="hs-identifier hs-var">missingSubtree</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Key -&gt; x -&gt; f y) -&gt; IntMap x -&gt; f (IntMap y)
forall (t :: * -&gt; *) a b.
Applicative t =&gt;
(Key -&gt; a -&gt; t b) -&gt; IntMap a -&gt; t (IntMap b)
</span><a href="Data.IntMap.Strict.Internal.html#traverseWithKey"><span class="hs-identifier hs-var">traverseWithKey</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679206490"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">missingKey :: Key -&gt; x -&gt; f (Maybe y)
</span><a href="Data.IntMap.Internal.html#missingKey"><span class="hs-identifier hs-var">missingKey</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679206492"><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206492"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679206493"><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206493"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">y -&gt; Maybe y
forall a. a -&gt; Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">(y -&gt; Maybe y) -&gt; y -&gt; Maybe y
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.18.2.1/src/GHC.Base.html#%24%21/GHC.Base.html#%24%21"><span class="hs-operator hs-var">$!</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(y -&gt; Maybe y) -&gt; f y -&gt; f (Maybe y)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.18.2.1/src/Data.Functor.html#%3C%24%3E/Data.Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Key -&gt; x -&gt; f y
</span><a href="#local-6989586621679206490"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Key
</span><a href="#local-6989586621679206492"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">x
</span><a href="#local-6989586621679206493"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-213"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#traverseMissing"><span class="hs-pragma hs-type">traverseMissing</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span id="local-6989586621679206287"><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-type">forceMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206287"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Maybe/GHC.Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679206287"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-216"></span><span id="forceMaybe"><span class="annot"><span class="annottext">forceMaybe :: forall a. Maybe a -&gt; Maybe a
</span><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var hs-var">forceMaybe</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Nothing/GHC.Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-217"></span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-identifier hs-var">forceMaybe</span></a></span><span> </span><span id="local-6989586621679206494"><span class="annot"><span class="annottext">m :: Maybe a
</span><a href="#local-6989586621679206494"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.18.2.1/src/GHC.Maybe.html#Just/GHC.Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe a
</span><a href="#local-6989586621679206494"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-218"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Data.IntMap.Merge.Strict.html#forceMaybe"><span class="hs-pragma hs-type">forceMaybe</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-219"></span></pre></body></html>