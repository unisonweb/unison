-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concrete functor and monad transformers
--   
--   A portable library of functor and monad transformers, inspired by the
--   paper
--   
--   <ul>
--   <li>"Functional Programming with Overloading and Higher-Order
--   Polymorphism", by Mark P Jones, in <i>Advanced School of Functional
--   Programming</i>, 1995
--   (<a>http://web.cecs.pdx.edu/~mpj/pubs/springschool.html</a>).</li>
--   </ul>
--   
--   This package contains:
--   
--   <ul>
--   <li>the monad transformer class (in
--   <a>Control.Monad.Trans.Class</a>)</li>
--   <li>concrete functor and monad transformers, each with associated
--   operations and functions to lift operations associated with other
--   transformers.</li>
--   </ul>
--   
--   The package can be used on its own in portable Haskell code, in which
--   case operations need to be manually lifted through transformer stacks
--   (see <a>Control.Monad.Trans.Class</a> for some examples).
--   Alternatively, it can be used with the non-portable monad classes in
--   the <tt>mtl</tt> or <tt>monads-tf</tt> packages, which automatically
--   lift operations introduced by monad transformers through other
--   transformers.
@package transformers
@version 0.6.1.0


-- | Making functors with an <a>Applicative</a> instance that performs
--   actions in the reverse order.
module Control.Applicative.Backwards

-- | The same functor, but with an <a>Applicative</a> instance that
--   performs actions in the reverse order.
newtype Backwards f a
Backwards :: f a -> Backwards f a
[forwards] :: Backwards f a -> f a
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Control.Applicative.Backwards.Backwards f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Control.Applicative.Backwards.Backwards f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Applicative.Backwards.Backwards f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Applicative.Backwards.Backwards f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Backwards.Backwards f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Backwards.Backwards f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Applicative.Backwards.Backwards f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Backwards.Backwards f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Backwards.Backwards f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Applicative.Backwards.Backwards f)


-- | Signatures for monad operations that require specialized lifting. Each
--   signature has a uniformity property that the lifting should satisfy.
module Control.Monad.Signatures

-- | Signature of the <tt>callCC</tt> operation, introduced in
--   <a>Control.Monad.Trans.Cont</a>. Any lifting function
--   <tt>liftCallCC</tt> should satisfy
--   
--   <ul>
--   <li><pre><a>lift</a> (f k) = f' (<a>lift</a> . k) =&gt; <a>lift</a>
--   (cf f) = liftCallCC cf f'</pre></li>
--   </ul>
type CallCC m a b = ((a -> m b) -> m a) -> m a

-- | Signature of the <tt>catchE</tt> operation, introduced in
--   <a>Control.Monad.Trans.Except</a>. Any lifting function
--   <tt>liftCatch</tt> should satisfy
--   
--   <ul>
--   <li><pre><a>lift</a> (cf m f) = liftCatch (<a>lift</a> . cf)
--   (<a>lift</a> f)</pre></li>
--   </ul>
type Catch e m a = m a -> (e -> m a) -> m a

-- | Signature of the <tt>listen</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>. Any lifting function
--   <tt>liftListen</tt> should satisfy
--   
--   <ul>
--   <li><pre><a>lift</a> . liftListen = liftListen .
--   <a>lift</a></pre></li>
--   </ul>
type Listen w m a = m a -> m (a, w)

-- | Signature of the <tt>pass</tt> operation, introduced in
--   <a>Control.Monad.Trans.Writer</a>. Any lifting function
--   <tt>liftPass</tt> should satisfy
--   
--   <ul>
--   <li><pre><a>lift</a> . liftPass = liftPass . <a>lift</a></pre></li>
--   </ul>
type Pass w m a = m (a, w -> w) -> m a


-- | The class of monad transformers.
--   
--   A monad transformer makes a new monad out of an existing monad, such
--   that computations of the old monad may be embedded in the new one. To
--   construct a monad with a desired set of features, one typically starts
--   with a base monad, such as <a>Identity</a>, <tt>[]</tt> or <a>IO</a>,
--   and applies a sequence of monad transformers.
module Control.Monad.Trans.Class

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class (forall m. Monad m => Monad (t m)) => MonadTrans t

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a


-- | Continuation monads.
--   
--   Delimited continuation operators are taken from Kenichi Asai and Oleg
--   Kiselyov's tutorial at CW 2011, "Introduction to programming with
--   shift and reset"
--   (<a>http://okmij.org/ftp/continuations/#tutorial</a>).
module Control.Monad.Trans.Cont

-- | Continuation monad. <tt>Cont r a</tt> is a CPS ("continuation-passing
--   style") computation that produces an intermediate result of type
--   <tt>a</tt> within a CPS computation whose final result type is
--   <tt>r</tt>.
--   
--   The <tt>return</tt> function simply creates a continuation which
--   passes the value on.
--   
--   The <tt>&gt;&gt;=</tt> operator adds the bound function into the
--   continuation chain.
type Cont r = ContT r Identity

-- | Construct a continuation-passing computation from a function. (The
--   inverse of <a>runCont</a>)
cont :: ((a -> r) -> r) -> Cont r a

-- | The result of running a CPS computation with a given final
--   continuation. (The inverse of <a>cont</a>)
runCont :: Cont r a -> (a -> r) -> r

-- | The result of running a CPS computation with the identity as the final
--   continuation.
--   
--   <ul>
--   <li><pre><a>evalCont</a> (<a>return</a> x) = x</pre></li>
--   </ul>
evalCont :: Cont r r -> r

-- | Apply a function to transform the result of a continuation-passing
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>mapCont</a> f m) = f . <a>runCont</a>
--   m</pre></li>
--   </ul>
mapCont :: (r -> r) -> Cont r a -> Cont r a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runCont</a> (<a>withCont</a> f m) = <a>runCont</a> m .
--   f</pre></li>
--   </ul>
withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b

-- | <tt><a>reset</a> m</tt> delimits the continuation of any <a>shift</a>
--   inside <tt>m</tt>.
--   
--   <ul>
--   <li><pre><a>reset</a> (<a>return</a> m) = <a>return</a> m</pre></li>
--   </ul>
reset :: Cont r r -> Cont r' r

-- | <tt><a>shift</a> f</tt> captures the continuation up to the nearest
--   enclosing <a>reset</a> and passes it to <tt>f</tt>:
--   
--   <ul>
--   <li><pre><a>reset</a> (<a>shift</a> f &gt;&gt;= k) = <a>reset</a> (f
--   (<a>evalCont</a> . k))</pre></li>
--   </ul>
shift :: ((a -> r) -> Cont r r) -> Cont r a

-- | The continuation monad transformer. Can be used to add continuation
--   handling to any type constructor: the <a>Monad</a> instance and most
--   of the operations do not require <tt>m</tt> to be a monad.
--   
--   <a>ContT</a> is not a functor on the category of monads, and many
--   operations cannot be lifted through it.
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
[runContT] :: ContT r m a -> (a -> m r) -> m r

-- | The result of running a CPS computation with <a>return</a> as the
--   final continuation.
--   
--   <ul>
--   <li><pre><a>evalContT</a> (<a>lift</a> m) = m</pre></li>
--   </ul>
evalContT :: Monad m => ContT r m r -> m r

-- | Apply a function to transform the result of a continuation-passing
--   computation. This has a more restricted type than the <tt>map</tt>
--   operations for other monad transformers, because <a>ContT</a> does not
--   define a functor in the category of monads.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>mapContT</a> f m) = f . <a>runContT</a>
--   m</pre></li>
--   </ul>
mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a

-- | Apply a function to transform the continuation passed to a CPS
--   computation.
--   
--   <ul>
--   <li><pre><a>runContT</a> (<a>withContT</a> f m) = <a>runContT</a> m .
--   f</pre></li>
--   </ul>
withContT :: ((b -> m r) -> a -> m r) -> ContT r m a -> ContT r m b

-- | <tt>callCC</tt> (call-with-current-continuation) calls its argument
--   function, passing it the current continuation. It provides an escape
--   continuation mechanism for use with continuation monads. Escape
--   continuations one allow to abort the current computation and return a
--   value immediately. They achieve a similar effect to <a>throwE</a> and
--   <a>catchE</a> within an <a>ExceptT</a> monad. The advantage of this
--   function over calling <a>return</a> is that it makes the continuation
--   explicit, allowing more flexibility and better control.
--   
--   The standard idiom used with <tt>callCC</tt> is to provide a
--   lambda-expression to name the continuation. Then calling the named
--   continuation anywhere within its scope will escape from the
--   computation, even if it is many layers deep within nested
--   computations.
callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a

-- | <tt><a>resetT</a> m</tt> delimits the continuation of any
--   <a>shiftT</a> inside <tt>m</tt>.
--   
--   <ul>
--   <li><pre><a>resetT</a> (<a>lift</a> m) = <a>lift</a> m</pre></li>
--   </ul>
resetT :: Monad m => ContT r m r -> ContT r' m r

-- | <tt><a>shiftT</a> f</tt> captures the continuation up to the nearest
--   enclosing <a>resetT</a> and passes it to <tt>f</tt>:
--   
--   <ul>
--   <li><pre><a>resetT</a> (<a>shiftT</a> f &gt;&gt;= k) = <a>resetT</a>
--   (f (<a>evalContT</a> . k))</pre></li>
--   </ul>
shiftT :: Monad m => ((a -> m r) -> ContT r m r) -> ContT r m a

-- | <tt><a>liftLocal</a> ask local</tt> yields a <tt>local</tt> function
--   for <tt><a>ContT</a> r m</tt>.
liftLocal :: Monad m => m r' -> ((r' -> r') -> m r -> m r) -> (r' -> r') -> ContT r m a -> ContT r m a
instance forall k (r :: k) (m :: k -> *) a. GHC.Generics.Generic (Control.Monad.Trans.Cont.ContT r m a)
instance forall k (r :: k) (m :: k -> *). GHC.Base.Functor (Control.Monad.Trans.Cont.ContT r m)
instance forall k (r :: k) (m :: k -> *). GHC.Base.Applicative (Control.Monad.Trans.Cont.ContT r m)
instance forall k (r :: k) (m :: k -> *). GHC.Base.Monad (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Cont.ContT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Cont.ContT r m)


-- | This monad transformer extends a monad with the ability to throw
--   exceptions.
--   
--   A sequence of actions terminates normally, producing a value, only if
--   none of the actions in the sequence throws an exception. If one throws
--   an exception, the rest of the sequence is skipped and the composite
--   action exits with that exception.
--   
--   If the value of the exception is not required, the variant in
--   <a>Control.Monad.Trans.Maybe</a> may be used instead.
module Control.Monad.Trans.Except

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: Monad m => Either e a -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e m a
ExceptT :: m (Either e a) -> ExceptT e m a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: Monad m => e -> ExceptT e m a

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
instance GHC.Base.Functor m => GHC.Generics.Generic1 (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Generics.Generic (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Except.ExceptT e m a)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Except.ExceptT e m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Except.ExceptT e f)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Functor m, GHC.Base.Monad m, GHC.Base.Monoid e) => GHC.Base.Alternative (Control.Monad.Trans.Except.ExceptT e m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monad m, GHC.Base.Monoid e) => GHC.Base.MonadPlus (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Except.ExceptT e m)


-- | The identity monad transformer.
--   
--   This is useful for functions parameterized by a monad transformer.
module Control.Monad.Trans.Identity

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
newtype IdentityT f a
IdentityT :: f a -> IdentityT f a
[runIdentityT] :: IdentityT f a -> f a

-- | Lift a unary operation to the new monad.
mapIdentityT :: (m a -> n b) -> IdentityT m a -> IdentityT n b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m a -> Catch e (IdentityT m) a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m a b -> CallCC (IdentityT m) a b
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Control.Monad.Trans.Identity.IdentityT f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Monad.Trans.Identity.IdentityT f)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Identity.IdentityT f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Identity.IdentityT f a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Foldable1.Foldable1 m => Data.Foldable1.Foldable1 (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Identity.IdentityT f)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Identity.IdentityT f)


-- | The <a>MaybeT</a> monad transformer extends a monad with the ability
--   to exit the computation without returning a value.
--   
--   A sequence of actions produces a value only if all the actions in the
--   sequence do. If one exits, the rest of the sequence is skipped and the
--   composite action exits.
--   
--   For a variant allowing a range of exception values, see
--   <a>Control.Monad.Trans.Except</a>.
module Control.Monad.Trans.Maybe

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT m a
MaybeT :: m (Maybe a) -> MaybeT m a
[runMaybeT] :: MaybeT m a -> m (Maybe a)

-- | Transform the computation inside a <tt>MaybeT</tt>.
--   
--   <ul>
--   <li><pre><a>runMaybeT</a> (<a>mapMaybeT</a> f m) = f (<a>runMaybeT</a>
--   m)</pre></li>
--   </ul>
mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b

-- | Convert a <a>Maybe</a> computation to <a>MaybeT</a>.
hoistMaybe :: Applicative m => Maybe b -> MaybeT m b

-- | Convert a <a>MaybeT</a> computation to <a>ExceptT</a>, with a default
--   exception value.
maybeToExceptT :: Functor m => e -> MaybeT m a -> ExceptT e m a

-- | Convert a <a>ExceptT</a> computation to <a>MaybeT</a>, discarding the
--   value of any exception.
exceptToMaybeT :: Functor m => ExceptT e m a -> MaybeT m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Maybe a) (Maybe b) -> CallCC (MaybeT m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (Maybe a) -> Catch e (MaybeT m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Maybe a) -> Listen w (MaybeT m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Maybe a) -> Pass w (MaybeT m) a
instance GHC.Base.Functor m => GHC.Generics.Generic1 (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Generics.Generic (Control.Monad.Trans.Maybe.MaybeT m a)
instance Data.Functor.Classes.Eq1 m => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Ord1 m => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Read1 m => Data.Functor.Classes.Read1 (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Show1 m => Data.Functor.Classes.Show1 (Control.Monad.Trans.Maybe.MaybeT m)
instance (Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Maybe.MaybeT m a)
instance (Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Maybe.MaybeT m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Maybe.MaybeT f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Maybe.MaybeT f)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Alternative (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Maybe.MaybeT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Maybe.MaybeT m)


-- | A monad transformer that combines <a>ReaderT</a>, <a>WriterT</a> and
--   <a>StateT</a>. This version uses continuation-passing-style for the
--   writer part to achieve constant space usage. For a lazy version with
--   the same interface, see <a>Control.Monad.Trans.RWS.Lazy</a>.
module Control.Monad.Trans.RWS.CPS

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: Monoid w => (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: Monoid w => RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: Monoid w => RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: Monoid w => RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: (Monoid w, Monoid w') => ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
data RWST r w s m a

-- | Construct an RWST computation from a function. (The inverse of
--   <a>runRWST</a>.)
rwsT :: (Functor m, Monoid w) => (r -> s -> m (a, s, w)) -> RWST r w s m a

-- | Unwrap an RWST computation as a function. (The inverse of
--   <a>rwsT</a>.)
runRWST :: Monoid w => RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: (Monad m, Monoid w) => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: (Monad m, Monoid w) => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><tt><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</tt> mapRWST :: (m (a, s, w) -&gt; n (b, s, w')) -&gt; RWST r w s
--   m a -&gt; RWST r w' s n b</li>
--   </ul>
mapRWST :: (Monad n, Monoid w, Monoid w') => (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: Monad m => (r -> a) -> RWST r w s m a

-- | Fetch the value of the environment.
ask :: Monad m => RWST r w s m r

-- | Execute a computation in a modified environment
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>local</a> f m) r s = <a>runRWST</a> m (f
--   r) s</pre></li>
--   </ul>
local :: (r -> r) -> RWST r w s m a -> RWST r w s m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: Monad m => (r -> a) -> RWST r w s m a

-- | Construct a writer computation from a (result, output) pair.
writer :: (Monoid w, Monad m) => (a, w) -> RWST r w s m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> RWST r w s m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>listen</a> m) r s = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => RWST r w s m a -> RWST r w s m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>listens</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> RWST r w s m a -> RWST r w s m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>pass</a> m) r s = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
pass :: (Monoid w, Monoid w', Monad m) => RWST r w s m (a, w -> w') -> RWST r w' s m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>censor</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> RWST r w s m a -> RWST r w s m a

-- | Construct a state monad computation from a state transformer function.
state :: Monad m => (s -> (a, s)) -> RWST r w s m a

-- | Fetch the current value of the state within the monad.
get :: Monad m => RWST r w s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: Monad m => s -> RWST r w s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: Monad m => (s -> s) -> RWST r w s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: Monad m => (s -> a) -> RWST r w s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation.
liftCallCC' :: CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s, w) -> Catch e (RWST r w s m) a
instance GHC.Generics.Generic (Control.Monad.Trans.RWS.CPS.RWST r w s m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.RWS.CPS.RWST r w s)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.CPS.RWST r w s m)


-- | A monad transformer that combines <a>ReaderT</a>, <a>WriterT</a> and
--   <a>StateT</a>. This version is lazy; for a constant-space version with
--   almost the same interface, see <a>Control.Monad.Trans.RWS.CPS</a>.
module Control.Monad.Trans.RWS.Lazy

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
[runRWST] :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Fetch the value of the environment.
ask :: (Monoid w, Monad m) => RWST r w s m r

-- | Execute a computation in a modified environment
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>local</a> f m) r s = <a>runRWST</a> m (f
--   r) s</pre></li>
--   </ul>
local :: (r -> r) -> RWST r w s m a -> RWST r w s m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Construct a writer computation from a (result, output) pair.
writer :: Monad m => (a, w) -> RWST r w s m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: Monad m => w -> RWST r w s m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>listen</a> m) r s = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listen :: Monad m => RWST r w s m a -> RWST r w s m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>listens</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listens :: Monad m => (w -> b) -> RWST r w s m a -> RWST r w s m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>pass</a> m) r s = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
pass :: Monad m => RWST r w s m (a, w -> w) -> RWST r w s m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>censor</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
censor :: Monad m => (w -> w) -> RWST r w s m a -> RWST r w s m a

-- | Construct a state monad computation from a state transformer function.
state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a

-- | Fetch the current value of the state within the monad.
get :: (Monoid w, Monad m) => RWST r w s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monoid w, Monad m) => s -> RWST r w s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: Monoid w => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation.
liftCallCC' :: Monoid w => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s, w) -> Catch e (RWST r w s m) a
instance GHC.Generics.Generic (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fail.MonadFail m) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Lazy.RWST r w s m)


-- | A monad transformer that combines <a>ReaderT</a>, <a>WriterT</a> and
--   <a>StateT</a>. This version is lazy; for a constant-space version with
--   almost the same interface, see <a>Control.Monad.Trans.RWS.CPS</a>.
module Control.Monad.Trans.RWS


-- | A monad transformer that combines <a>ReaderT</a>, <a>WriterT</a> and
--   <a>StateT</a>. This version is strict; for a lazy version with the
--   same interface, see <a>Control.Monad.Trans.RWS.Lazy</a>. Although the
--   output is built strictly, it is not possible to achieve constant space
--   behaviour with this transformer: for that, use
--   <a>Control.Monad.Trans.RWS.CPS</a> instead.
module Control.Monad.Trans.RWS.Strict

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | Construct an RWS computation from a function. (The inverse of
--   <a>runRWS</a>.)
rws :: (r -> s -> (a, s, w)) -> RWS r w s a

-- | Unwrap an RWS computation as a function. (The inverse of <a>rws</a>.)
runRWS :: RWS r w s a -> r -> s -> (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWS :: RWS r w s a -> r -> s -> (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWS :: RWS r w s a -> r -> s -> (s, w)

-- | Map the return value, final state and output of a computation using
--   the given function.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>mapRWS</a> f m) r s = f (<a>runRWS</a> m r
--   s)</pre></li>
--   </ul>
mapRWS :: ((a, s, w) -> (b, s, w')) -> RWS r w s a -> RWS r w' s b

-- | <tt><a>withRWS</a> f m</tt> executes action <tt>m</tt> with an initial
--   environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWS</a> (<a>withRWS</a> f m) r s = <a>uncurry</a>
--   (<a>runRWS</a> m) (f r s)</pre></li>
--   </ul>
withRWS :: (r' -> s -> (r, s)) -> RWS r w s a -> RWS r' w s a

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s m a
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
[runRWST] :: RWST r w s m a -> r -> s -> m (a, s, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final value and output, discarding the final state.
evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)

-- | Evaluate a computation with the given initial state and environment,
--   returning the final state and output, discarding the final value.
execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)

-- | Map the inner computation using the given function.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>mapRWST</a> f m) r s = f (<a>runRWST</a> m
--   r s)</pre></li>
--   </ul>
mapRWST :: (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b

-- | <tt><a>withRWST</a> f m</tt> executes action <tt>m</tt> with an
--   initial environment and state modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>withRWST</a> f m) r s = <a>uncurry</a>
--   (<a>runRWST</a> m) (f r s)</pre></li>
--   </ul>
withRWST :: (r' -> s -> (r, s)) -> RWST r w s m a -> RWST r' w s m a

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Fetch the value of the environment.
ask :: (Monoid w, Monad m) => RWST r w s m r

-- | Execute a computation in a modified environment
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>local</a> f m) r s = <a>runRWST</a> m (f
--   r) s</pre></li>
--   </ul>
local :: (r -> r) -> RWST r w s m a -> RWST r w s m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: (Monoid w, Monad m) => (r -> a) -> RWST r w s m a

-- | Construct a writer computation from a (result, output) pair.
writer :: Monad m => (a, w) -> RWST r w s m a

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: Monad m => w -> RWST r w s m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>listen</a> m) r s = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listen :: Monad m => RWST r w s m a -> RWST r w s m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>listens</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
listens :: Monad m => (w -> b) -> RWST r w s m a -> RWST r w s m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runRWST</a> (<a>pass</a> m) r s = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
pass :: Monad m => RWST r w s m (a, w -> w) -> RWST r w s m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runRWST</a> (<a>censor</a> f m) r s = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runRWST</a> m r s)</pre></li>
--   </ul>
censor :: Monad m => (w -> w) -> RWST r w s m a -> RWST r w s m a

-- | Construct a state monad computation from a state transformer function.
state :: (Monoid w, Monad m) => (s -> (a, s)) -> RWST r w s m a

-- | Fetch the current value of the state within the monad.
get :: (Monoid w, Monad m) => RWST r w s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: (Monoid w, Monad m) => s -> RWST r w s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: (Monoid w, Monad m) => (s -> s) -> RWST r w s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: (Monoid w, Monad m) => (s -> a) -> RWST r w s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: Monoid w => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation.
liftCallCC' :: Monoid w => CallCC m (a, s, w) (b, s, w) -> CallCC (RWST r w s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s, w) -> Catch e (RWST r w s m) a
instance GHC.Generics.Generic (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fail.MonadFail m) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.RWS.Strict.RWST r w s m)


-- | Declaration of the <a>ReaderT</a> monad transformer, which adds a
--   static environment to a given monad.
--   
--   If the computation is to modify the stored information, use
--   <a>Control.Monad.Trans.State</a> instead.
module Control.Monad.Trans.Reader

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Constructor for computations in the reader monad (equivalent to
--   <a>asks</a>).
reader :: Monad m => (r -> a) -> ReaderT r m a

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Transform the value returned by a <tt>Reader</tt>.
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>mapReader</a> f m) = f .
--   <a>runReader</a> m</pre></li>
--   </ul>
mapReader :: (a -> b) -> Reader r a -> Reader r b

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>withReader</a> f m) = <a>runReader</a> m
--   . f</pre></li>
--   </ul>
withReader :: (r' -> r) -> Reader r a -> Reader r' a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
[runReaderT] :: ReaderT r m a -> r -> m a

-- | Transform the computation inside a <tt>ReaderT</tt>.
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>mapReaderT</a> f m) = f .
--   <a>runReaderT</a> m</pre></li>
--   </ul>
mapReaderT :: (m a -> n b) -> ReaderT r m a -> ReaderT r n b

-- | Execute a computation in a modified environment (a more general
--   version of <a>local</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>withReaderT</a> f m) =
--   <a>runReaderT</a> m . f</pre></li>
--   </ul>
withReaderT :: (r' -> r) -> ReaderT r m a -> ReaderT r' m a

-- | Fetch the value of the environment.
ask :: Monad m => ReaderT r m r

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>local</a> f m) = <a>runReaderT</a> m .
--   f</pre></li>
--   </ul>
local :: (r -> r) -> ReaderT r m a -> ReaderT r m a

-- | Retrieve a function of the current environment.
--   
--   <ul>
--   <li><pre><a>asks</a> f = <a>liftM</a> f <a>ask</a></pre></li>
--   </ul>
asks :: Monad m => (r -> a) -> ReaderT r m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m a b -> CallCC (ReaderT r m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m a -> Catch e (ReaderT r m) a
instance GHC.Generics.Generic1 (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Generics.Generic (Control.Monad.Trans.Reader.ReaderT r m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Reader.ReaderT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Zip.MonadZip m => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Reader.ReaderT r m)


-- | Selection monad transformer, modelling search algorithms.
--   
--   <ul>
--   <li>Martin Escardo and Paulo Oliva. "Selection functions, bar
--   recursion and backward induction", <i>Mathematical Structures in
--   Computer Science</i> 20:2 (2010), pp. 127-168.
--   <a>https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf</a></li>
--   <li>Jules Hedges. "Monad transformers for backtracking search". In
--   <i>Proceedings of MSFP 2014</i>.
--   <a>https://arxiv.org/abs/1406.2058</a></li>
--   </ul>
module Control.Monad.Trans.Select

-- | Selection monad.
type Select r = SelectT r Identity

-- | Constructor for computations in the selection monad.
select :: ((a -> r) -> a) -> Select r a

-- | Runs a <tt>Select</tt> computation with a function for evaluating
--   answers to select a particular answer. (The inverse of <a>select</a>.)
runSelect :: Select r a -> (a -> r) -> a

-- | Apply a function to transform the result of a selection computation.
--   
--   <ul>
--   <li><pre><a>runSelect</a> (<a>mapSelect</a> f m) = f .
--   <a>runSelect</a> m</pre></li>
--   </ul>
mapSelect :: (a -> a) -> Select r a -> Select r a

-- | Selection monad transformer.
--   
--   <a>SelectT</a> is not a functor on the category of monads, and many
--   operations cannot be lifted through it.
newtype SelectT r m a
SelectT :: ((a -> m r) -> m a) -> SelectT r m a

-- | Runs a <tt>SelectT</tt> computation with a function for evaluating
--   answers to select a particular answer. (The inverse of <a>select</a>.)
runSelectT :: SelectT r m a -> (a -> m r) -> m a

-- | Apply a function to transform the result of a selection computation.
--   This has a more restricted type than the <tt>map</tt> operations for
--   other monad transformers, because <a>SelectT</a> does not define a
--   functor in the category of monads.
--   
--   <ul>
--   <li><pre><a>runSelectT</a> (<a>mapSelectT</a> f m) = f .
--   <a>runSelectT</a> m</pre></li>
--   </ul>
mapSelectT :: (m a -> m a) -> SelectT r m a -> SelectT r m a

-- | Convert a selection computation to a continuation-passing computation.
selectToContT :: Monad m => SelectT r m a -> ContT r m a
instance GHC.Generics.Generic (Control.Monad.Trans.Select.SelectT r m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Select.SelectT r m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Select.SelectT r m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.Select.SelectT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Select.SelectT r m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Select.SelectT r m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Select.SelectT r m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Select.SelectT r)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Select.SelectT r m)


-- | Lazy state monads, passing an updatable state through a computation.
--   See below for examples.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   In this version, sequencing of computations is lazy, so that for
--   example the following produces a usable result:
--   
--   <pre>
--   evalState (sequence $ repeat $ do { n &lt;- get; put (n*2); return n }) 1
--   </pre>
--   
--   For a strict version with the same interface, see
--   <a>Control.Monad.Trans.State.Strict</a>.
module Control.Monad.Trans.State.Lazy

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Construct a state monad computation from a function. (The inverse of
--   <a>runState</a>.)
state :: Monad m => (s -> (a, s)) -> StateT s m a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
[runStateT] :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

-- | Fetch the current value of the state within the monad.
get :: Monad m => StateT s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: Monad m => s -> StateT s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: Monad m => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
--   
--   <ul>
--   <li><pre><a>modify'</a> f = <a>get</a> &gt;&gt;= ((<a>$!</a>)
--   <a>put</a> . f)</pre></li>
--   </ul>
modify' :: Monad m => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the new state is generated by a
--   monadic action.
modifyM :: Monad m => (s -> m s) -> StateT s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: Monad m => (s -> a) -> StateT s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the uniformity property (see
--   <a>Control.Monad.Signatures</a>).
liftCallCC' :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s) -> Catch e (StateT s m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (a, s) -> Listen w (StateT s m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (a, s) -> Pass w (StateT s m) a
instance GHC.Generics.Generic (Control.Monad.Trans.State.Lazy.StateT s m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.State.Lazy.StateT s m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.State.Lazy.StateT s)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Lazy.StateT s m)


-- | State monads, passing an updatable state through a computation.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   This version is lazy; for a strict version, see
--   <a>Control.Monad.Trans.State.Strict</a>, which has the same interface.
module Control.Monad.Trans.State


-- | Strict state monads, passing an updatable state through a computation.
--   See below for examples.
--   
--   Some computations may not require the full power of state
--   transformers:
--   
--   <ul>
--   <li>For a read-only state, see <a>Control.Monad.Trans.Reader</a>.</li>
--   <li>To accumulate a value without using it on the way, see
--   <a>Control.Monad.Trans.Writer</a>.</li>
--   </ul>
--   
--   In this version, sequencing of computations is strict (but
--   computations are not strict in the state unless you force it with
--   <a>seq</a> or the like). For a lazy version with the same interface,
--   see <a>Control.Monad.Trans.State.Lazy</a>.
module Control.Monad.Trans.State.Strict

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Construct a state monad computation from a function. (The inverse of
--   <a>runState</a>.)
state :: Monad m => (s -> (a, s)) -> StateT s m a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
[runStateT] :: StateT s m a -> s -> m (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: (s -> s) -> StateT s m a -> StateT s m a

-- | Fetch the current value of the state within the monad.
get :: Monad m => StateT s m s

-- | <tt><a>put</a> s</tt> sets the state within the monad to <tt>s</tt>.
put :: Monad m => s -> StateT s m ()

-- | <tt><a>modify</a> f</tt> is an action that updates the state to the
--   result of applying <tt>f</tt> to the current state.
--   
--   <ul>
--   <li><pre><a>modify</a> f = <a>get</a> &gt;&gt;= (<a>put</a> .
--   f)</pre></li>
--   </ul>
modify :: Monad m => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
--   
--   <ul>
--   <li><pre><a>modify'</a> f = <a>get</a> &gt;&gt;= ((<a>$!</a>)
--   <a>put</a> . f)</pre></li>
--   </ul>
--   
--   Note that this is only strict in the top level of the state. Lazy
--   components of the state will not be evaluated unless <tt>f</tt>
--   evaluates them.
modify' :: Monad m => (s -> s) -> StateT s m ()

-- | A variant of <a>modify</a> in which the new state is generated by a
--   monadic action.
modifyM :: Monad m => (s -> m s) -> StateT s m ()

-- | Get a specific component of the state, using a projection function
--   supplied.
--   
--   <ul>
--   <li><pre><a>gets</a> f = <a>liftM</a> f <a>get</a></pre></li>
--   </ul>
gets :: Monad m => (s -> a) -> StateT s m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the uniformity property (see
--   <a>Control.Monad.Signatures</a>).
liftCallCC' :: CallCC m (a, s) (b, s) -> CallCC (StateT s m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, s) -> Catch e (StateT s m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (a, s) -> Listen w (StateT s m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (a, s) -> Pass w (StateT s m) a
instance GHC.Generics.Generic (Control.Monad.Trans.State.Strict.StateT s m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.State.Strict.StateT s m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.State.Strict.StateT s m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.State.Strict.StateT s)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.State.Strict.StateT s m)


-- | The strict <a>WriterT</a> monad transformer, which adds collection of
--   outputs (such as a count or string output) to a given monad.
--   
--   This monad transformer provides only limited access to the output
--   during the computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
--   
--   This version builds its output strictly and uses
--   continuation-passing-style to achieve constant space usage. This
--   transformer can be used as a drop-in replacement for
--   <a>Control.Monad.Trans.Writer.Strict</a>.
module Control.Monad.Trans.Writer.CPS

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Construct a writer computation from a (result, output) pair. (The
--   inverse of <a>runWriter</a>.)
writer :: (Monoid w, Monad m) => (a, w) -> WriterT w m a

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Monoid w => Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Monoid w => Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: (Monoid w, Monoid w') => ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <a>&gt;&gt;=</a> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data WriterT w m a

-- | Construct a writer computation from a (result, output) computation.
--   (The inverse of <a>runWriterT</a>.)
writerT :: (Functor m, Monoid w) => m (a, w) -> WriterT w m a

-- | Unwrap a writer computation. (The inverse of <a>writerT</a>.)
runWriterT :: Monoid w => WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: (Monad m, Monoid w) => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (Monad n, Monoid w, Monoid w') => (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: (Monoid w, Monad m) => w -> WriterT w m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>listen</a> m) = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listen :: (Monoid w, Monad m) => WriterT w m a -> WriterT w m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>listens</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listens :: (Monoid w, Monad m) => (w -> b) -> WriterT w m a -> WriterT w m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>pass</a> m) = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
pass :: (Monoid w, Monoid w', Monad m) => WriterT w m (a, w -> w') -> WriterT w' m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>censor</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
censor :: (Monoid w, Monad m) => (w -> w) -> WriterT w m a -> WriterT w m a

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: CallCC m (a, w) (b, w) -> CallCC (WriterT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (WriterT w m) a
instance GHC.Generics.Generic (Control.Monad.Trans.Writer.CPS.WriterT w m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Writer.CPS.WriterT w)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.CPS.WriterT w m)


-- | The lazy <a>WriterT</a> monad transformer, which adds collection of
--   outputs (such as a count or string output) to a given monad.
--   
--   This monad transformer provides only limited access to the output
--   during the computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
--   
--   This version builds its output lazily; for a constant-space version
--   with almost the same interface, see
--   <a>Control.Monad.Trans.Writer.CPS</a>.
module Control.Monad.Trans.Writer.Lazy

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Construct a writer computation from a (result, output) pair. (The
--   inverse of <a>runWriter</a>.)
writer :: Monad m => (a, w) -> WriterT w m a

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
[runWriterT] :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: Monad m => w -> WriterT w m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>listen</a> m) = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listen :: Monad m => WriterT w m a -> WriterT w m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>listens</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listens :: Monad m => (w -> b) -> WriterT w m a -> WriterT w m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>pass</a> m) = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
pass :: Monad m => WriterT w m (a, w -> w) -> WriterT w m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>censor</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
censor :: Monad m => (w -> w) -> WriterT w m a -> WriterT w m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: Monoid w => CallCC m (a, w) (b, w) -> CallCC (WriterT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (WriterT w m) a
instance GHC.Generics.Generic (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Alternative m) => GHC.Base.Alternative (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fail.MonadFail m) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Zip.MonadZip m) => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Lazy.WriterT w m)


-- | The WriterT monad transformer. This version builds its output lazily;
--   for a constant-space version with almost the same interface, see
--   <a>Control.Monad.Trans.Writer.CPS</a>.
module Control.Monad.Trans.Writer


-- | The lazy <a>AccumT</a> monad transformer, which adds accumulation
--   capabilities (such as declarations or document patches) to a given
--   monad.
--   
--   This monad transformer provides append-only accumulation during the
--   computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
module Control.Monad.Trans.Accum

-- | An accumulation monad parameterized by the type <tt>w</tt> of output
--   to accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Accum w = AccumT w Identity

-- | Construct an accumulation computation from a (result, output) pair.
--   (The inverse of <a>runAccum</a>.)
accum :: Monad m => (w -> (a, w)) -> AccumT w m a

-- | Unwrap an accumulation computation as a (result, output) pair. (The
--   inverse of <a>accum</a>.)
runAccum :: Accum w a -> w -> (a, w)

-- | Extract the output from an accumulation computation.
--   
--   <ul>
--   <li><pre><a>execAccum</a> m w = <a>snd</a> (<a>runAccum</a> m
--   w)</pre></li>
--   </ul>
execAccum :: Accum w a -> w -> w

-- | Evaluate an accumulation computation with the given initial output
--   history and return the final value, discarding the final output.
--   
--   <ul>
--   <li><pre><a>evalAccum</a> m w = <a>fst</a> (<a>runAccum</a> m
--   w)</pre></li>
--   </ul>
evalAccum :: Monoid w => Accum w a -> w -> a

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runAccum</a> (<a>mapAccum</a> f m) = f . <a>runAccum</a>
--   m</pre></li>
--   </ul>
mapAccum :: ((a, w) -> (b, w)) -> Accum w a -> Accum w b

-- | An accumulation monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
--   
--   This monad transformer is similar to both state and writer monad
--   transformers. Thus it can be seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad transformer
--   or</li>
--   <li>a writer monad transformer with the extra ability to read all
--   previous output.</li>
--   </ul>
newtype AccumT w m a
AccumT :: (w -> m (a, w)) -> AccumT w m a

-- | Unwrap an accumulation computation.
runAccumT :: AccumT w m a -> w -> m (a, w)

-- | Extract the output from an accumulation computation.
--   
--   <ul>
--   <li><pre><a>execAccumT</a> m w = <a>liftM</a> <a>snd</a>
--   (<a>runAccumT</a> m w)</pre></li>
--   </ul>
execAccumT :: Monad m => AccumT w m a -> w -> m w

-- | Evaluate an accumulation computation with the given initial output
--   history and return the final value, discarding the final output.
--   
--   <ul>
--   <li><pre><a>evalAccumT</a> m w = <a>liftM</a> <a>fst</a>
--   (<a>runAccumT</a> m w)</pre></li>
--   </ul>
evalAccumT :: (Monad m, Monoid w) => AccumT w m a -> w -> m a

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runAccumT</a> (<a>mapAccumT</a> f m) = f .
--   <a>runAccumT</a> m</pre></li>
--   </ul>
mapAccumT :: (m (a, w) -> n (b, w)) -> AccumT w m a -> AccumT w n b

-- | <tt><a>look</a></tt> is an action that fetches all the previously
--   accumulated output.
look :: (Monoid w, Monad m) => AccumT w m w

-- | <tt><a>look</a></tt> is an action that retrieves a function of the
--   previously accumulated output.
looks :: (Monoid w, Monad m) => (w -> a) -> AccumT w m a

-- | <tt><a>add</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
add :: Monad m => w -> AccumT w m ()

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original output history on entering the
--   continuation.
liftCallCC :: CallCC m (a, w) (b, w) -> CallCC (AccumT w m) a b

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current output history on entering the continuation.
--   It does not satisfy the uniformity property (see
--   <a>Control.Monad.Signatures</a>).
liftCallCC' :: CallCC m (a, w) (b, w) -> CallCC (AccumT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (AccumT w m) a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (a, s) -> Listen w (AccumT s m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (a, s) -> Pass w (AccumT s m) a

-- | Convert a read-only computation into an accumulation computation.
readerToAccumT :: (Functor m, Monoid w) => ReaderT w m a -> AccumT w m a

-- | Convert a writer computation into an accumulation computation.
writerToAccumT :: WriterT w m a -> AccumT w m a

-- | Convert an accumulation (append-only) computation into a fully
--   stateful computation.
accumToStateT :: (Functor m, Monoid s) => AccumT s m a -> StateT s m a
instance GHC.Generics.Generic (Control.Monad.Trans.Accum.AccumT w m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.Alternative (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fail.MonadFail m) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Accum.AccumT w m)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Accum.AccumT w m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Accum.AccumT w)
instance (GHC.Base.Monoid w, GHC.Base.Functor m, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Accum.AccumT w m)


-- | The strict <a>WriterT</a> monad transformer, which adds collection of
--   outputs (such as a count or string output) to a given monad.
--   
--   This monad transformer provides only limited access to the output
--   during the computation. For more general access, use
--   <a>Control.Monad.Trans.State</a> instead.
--   
--   This version builds its output strictly; for a lazy version with the
--   same interface, see <a>Control.Monad.Trans.Writer.Lazy</a>. Although
--   the output is built strictly, it is not possible to achieve constant
--   space behaviour with this transformer: for that, use
--   <a>Control.Monad.Trans.Writer.CPS</a> instead.
module Control.Monad.Trans.Writer.Strict

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | Construct a writer computation from a (result, output) pair. (The
--   inverse of <a>runWriter</a>.)
writer :: Monad m => (a, w) -> WriterT w m a

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriter</a> m = <a>snd</a> (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
execWriter :: Writer w a -> w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriter</a> (<a>mapWriter</a> f m) = f (<a>runWriter</a>
--   m)</pre></li>
--   </ul>
mapWriter :: ((a, w) -> (b, w')) -> Writer w a -> Writer w' b

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w m a
WriterT :: m (a, w) -> WriterT w m a
[runWriterT] :: WriterT w m a -> m (a, w)

-- | Extract the output from a writer computation.
--   
--   <ul>
--   <li><pre><a>execWriterT</a> m = <a>liftM</a> <a>snd</a>
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
execWriterT :: Monad m => WriterT w m a -> m w

-- | Map both the return value and output of a computation using the given
--   function.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>mapWriterT</a> f m) = f
--   (<a>runWriterT</a> m)</pre></li>
--   </ul>
mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b

-- | <tt><a>tell</a> w</tt> is an action that produces the output
--   <tt>w</tt>.
tell :: Monad m => w -> WriterT w m ()

-- | <tt><a>listen</a> m</tt> is an action that executes the action
--   <tt>m</tt> and adds its output to the value of the computation.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>listen</a> m) = <a>liftM</a> (\ (a, w)
--   -&gt; ((a, w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listen :: Monad m => WriterT w m a -> WriterT w m (a, w)

-- | <tt><a>listens</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and adds the result of applying <tt>f</tt> to the output to
--   the value of the computation.
--   
--   <ul>
--   <li><pre><a>listens</a> f m = <a>liftM</a> (id *** f) (<a>listen</a>
--   m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>listens</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; ((a, f w), w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
listens :: Monad m => (w -> b) -> WriterT w m a -> WriterT w m (a, b)

-- | <tt><a>pass</a> m</tt> is an action that executes the action
--   <tt>m</tt>, which returns a value and a function, and returns the
--   value, applying the function to the output.
--   
--   <ul>
--   <li><pre><a>runWriterT</a> (<a>pass</a> m) = <a>liftM</a> (\ ((a, f),
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
pass :: Monad m => WriterT w m (a, w -> w) -> WriterT w m a

-- | <tt><a>censor</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   <ul>
--   <li><pre><a>censor</a> f m = <a>pass</a> (<a>liftM</a> (\ x -&gt;
--   (x,f)) m)</pre></li>
--   <li><pre><a>runWriterT</a> (<a>censor</a> f m) = <a>liftM</a> (\ (a,
--   w) -&gt; (a, f w)) (<a>runWriterT</a> m)</pre></li>
--   </ul>
censor :: Monad m => (w -> w) -> WriterT w m a -> WriterT w m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: Monoid w => CallCC m (a, w) (b, w) -> CallCC (WriterT w m) a b

-- | Lift a <tt>catchE</tt> operation to the new monad.
liftCatch :: Catch e m (a, w) -> Catch e (WriterT w m) a
instance GHC.Generics.Generic (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m, GHC.Read.Read a) => GHC.Read.Read (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m, GHC.Show.Show a) => GHC.Show.Show (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => GHC.Base.Applicative (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Alternative m) => GHC.Base.Alternative (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Monad (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fail.MonadFail m) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, GHC.Base.MonadPlus m) => GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance GHC.Base.Monoid w => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Writer.Strict.WriterT w)
instance (GHC.Base.Monoid w, Control.Monad.IO.Class.MonadIO m) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Zip.MonadZip m) => Control.Monad.Zip.MonadZip (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | The constant functor.
module Data.Functor.Constant

-- | Constant functor.
newtype Constant a b
Constant :: a -> Constant a b
[getConstant] :: Constant a b -> a
instance GHC.Generics.Generic1 (Data.Functor.Constant.Constant a)
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Constant.Constant a b)
instance forall a k (b :: k). (Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable k, Data.Data.Data a) => Data.Data.Data (Data.Functor.Constant.Constant a b)
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Constant.Constant a b)
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Constant.Constant a b)
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Constant.Constant a b)
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Constant.Constant a b)
instance Data.Functor.Classes.Eq2 Data.Functor.Constant.Constant
instance Data.Functor.Classes.Ord2 Data.Functor.Constant.Constant
instance Data.Functor.Classes.Read2 Data.Functor.Constant.Constant
instance Data.Functor.Classes.Show2 Data.Functor.Constant.Constant
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Functor.Constant.Constant a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Functor.Constant.Constant a)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Functor.Constant.Constant a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Functor.Constant.Constant a)
instance GHC.Base.Functor (Data.Functor.Constant.Constant a)
instance Data.Foldable.Foldable (Data.Functor.Constant.Constant a)
instance Data.Traversable.Traversable (Data.Functor.Constant.Constant a)
instance forall k a (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Constant.Constant a b)
instance GHC.Base.Monoid a => GHC.Base.Applicative (Data.Functor.Constant.Constant a)
instance forall k a (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Constant.Constant a b)
instance Data.Bifunctor.Bifunctor Data.Functor.Constant.Constant
instance Data.Bifoldable.Bifoldable Data.Functor.Constant.Constant
instance Data.Bitraversable.Bitraversable Data.Functor.Constant.Constant
instance Data.Functor.Contravariant.Contravariant (Data.Functor.Constant.Constant a)


-- | Adding a new kind of pure computation to an applicative functor.
module Control.Applicative.Lift

-- | Applicative functor formed by adding pure computations to a given
--   applicative functor.
data Lift f a
Pure :: a -> Lift f a
Other :: f a -> Lift f a

-- | Projection to the other functor.
unLift :: Applicative f => Lift f a -> f a

-- | Apply a transformation to the other computation.
mapLift :: (f a -> g a) -> Lift f a -> Lift g a

-- | Eliminator for <a>Lift</a>.
--   
--   <ul>
--   <li><pre><a>elimLift</a> f g . <a>pure</a> = f</pre></li>
--   <li><pre><a>elimLift</a> f g . <a>Other</a> = g</pre></li>
--   </ul>
elimLift :: (a -> r) -> (f a -> r) -> Lift f a -> r

-- | An applicative functor that collects a monoid (e.g. lists) of errors.
--   A sequence of computations fails if any of its components do, but
--   unlike monads made with <a>ExceptT</a> from
--   <a>Control.Monad.Trans.Except</a>, these computations continue after
--   an error, collecting all the errors.
--   
--   <ul>
--   <li><pre><a>pure</a> f <a>&lt;*&gt;</a> <a>pure</a> x = <a>pure</a> (f
--   x)</pre></li>
--   <li><pre><a>pure</a> f <a>&lt;*&gt;</a> <a>failure</a> e =
--   <a>failure</a> e</pre></li>
--   <li><pre><a>failure</a> e <a>&lt;*&gt;</a> <a>pure</a> x =
--   <a>failure</a> e</pre></li>
--   <li><pre><a>failure</a> e1 <a>&lt;*&gt;</a> <a>failure</a> e2 =
--   <a>failure</a> (e1 <a>&lt;&gt;</a> e2)</pre></li>
--   </ul>
type Errors e = Lift (Constant e)

-- | Extractor for computations with accumulating errors.
--   
--   <ul>
--   <li><pre><a>runErrors</a> (<a>pure</a> x) = <a>Right</a> x</pre></li>
--   <li><pre><a>runErrors</a> (<a>failure</a> e) = <a>Left</a>
--   e</pre></li>
--   </ul>
runErrors :: Errors e a -> Either e a

-- | Report an error.
failure :: e -> Errors e a

-- | Convert from <a>Either</a> to <a>Errors</a> (inverse of
--   <a>runErrors</a>).
eitherToErrors :: Either e a -> Errors e a
instance GHC.Generics.Generic1 (Control.Applicative.Lift.Lift f)
instance GHC.Generics.Generic (Control.Applicative.Lift.Lift f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Control.Applicative.Lift.Lift f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Control.Applicative.Lift.Lift f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Applicative.Lift.Lift f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Applicative.Lift.Lift f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Applicative.Lift.Lift f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Applicative.Lift.Lift f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Applicative.Lift.Lift f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Lift.Lift f)


-- | Making functors whose elements are notionally in the reverse order
--   from the original functor.
module Data.Functor.Reverse

-- | The same functor, but with <a>Foldable</a> and <a>Traversable</a>
--   instances that process the elements in the reverse order.
newtype Reverse f a
Reverse :: f a -> Reverse f a
[getReverse] :: Reverse f a -> f a
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Functor.Reverse.Reverse f)
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Reverse.Reverse f a)
instance Data.Functor.Classes.Eq1 f => Data.Functor.Classes.Eq1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Ord1 f => Data.Functor.Classes.Ord1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Read1 f => Data.Functor.Classes.Read1 (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Show1 f => Data.Functor.Classes.Show1 (Data.Functor.Reverse.Reverse f)
instance (Data.Functor.Classes.Eq1 f, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Ord1 f, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Read1 f, GHC.Read.Read a) => GHC.Read.Read (Data.Functor.Reverse.Reverse f a)
instance (Data.Functor.Classes.Show1 f, GHC.Show.Show a) => GHC.Show.Show (Data.Functor.Reverse.Reverse f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Functor.Reverse.Reverse m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Data.Functor.Reverse.Reverse m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Functor.Reverse.Reverse m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Functor.Reverse.Reverse f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Functor.Reverse.Reverse f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Functor.Reverse.Reverse f)
