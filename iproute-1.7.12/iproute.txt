-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | IP Routing Table
--   
--   IP Routing Table is a tree of IP ranges to search one of them on the
--   longest match base. It is a kind of TRIE with one way branching
--   removed. Both IPv4 and IPv6 are supported.
@package iproute
@version 1.7.12

module Data.IP.Builder

-- | <a>BoundedPrim</a> bytestring <a>Builder</a> for general <a>IP</a>
--   addresses.
ipBuilder :: IP -> Builder

-- | <a>BoundedPrim</a> bytestring <a>Builder</a> for <a>IP</a> addresses.
ipv4Builder :: IPv4 -> Builder

-- | <a>BoundedPrim</a> bytestring <a>Builder</a> for <a>IP</a> addresses.
ipv6Builder :: IPv6 -> Builder

module Data.IP.Internal

-- | The abstract data type to express an IPv4 address. To create this, use
--   <a>toIPv4</a>. Or use <a>read</a> <tt>"192.0.2.1"</tt> :: <a>IP</a>,
--   for example. Also, <tt>"192.0.2.1"</tt> can be used as literal with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1" :: IPv4
--   192.0.2.1
--   </pre>
newtype IPv4
IP4 :: IPv4Addr -> IPv4

-- | The abstract data type to express an IPv6 address. To create this, use
--   <a>toIPv6</a>. Or use <a>read</a> <tt>"2001:DB8::1"</tt> :: <a>IP</a>,
--   for example. Also, <tt>"2001:DB8::1"</tt> can be used as literal with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01" :: IPv6
--   2001:db8::1
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00::101" :: IPv6
--   2001:db8:11e:c00::101
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00:aa:bb:192.0.2.1" :: IPv6
--   2001:db8:11e:c00:aa:bb:c000:201
--   
--   &gt;&gt;&gt; read "2001:db8::192.0.2.1" :: IPv6
--   2001:db8::c000:201
--   
--   &gt;&gt;&gt; read "0::ffff:192.0.2.1" :: IPv6
--   ::ffff:192.0.2.1
--   
--   &gt;&gt;&gt; read "0::0:c000:201" :: IPv6
--   ::192.0.2.1
--   
--   &gt;&gt;&gt; read "::0.0.0.1" :: IPv6
--   ::1
--   </pre>
newtype IPv6
IP6 :: IPv6Addr -> IPv6

-- | The Addr range consists of an address, a contiguous mask, and mask
--   length. The contiguous mask and the mask length are essentially same
--   information but contained for pre calculation.
--   
--   To create this, use <tt>makeAddrRange</tt> or <a>read</a>
--   <tt>"192.0.2.0/24"</tt> :: <a>AddrRange</a> <a>IP</a>. Also,
--   <tt>"192.0.2.0/24"</tt> can be used as literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1/24" :: AddrRange IPv4
--   192.0.2.0/24
--   
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01/48" :: AddrRange IPv6
--   2001:db8::/48
--   </pre>
data AddrRange a
AddrRange :: !a -> !a -> {-# UNPACK #-} !Int -> AddrRange a

-- | The <a>addr</a> function returns an address from <a>AddrRange</a>.
[addr] :: AddrRange a -> !a

-- | The <a>mask</a> function returns a contiguous <a>IP</a> mask from
--   <a>AddrRange</a>.
[mask] :: AddrRange a -> !a

-- | The <a>mlen</a> function returns a mask length from <a>AddrRange</a>.
[mlen] :: AddrRange a -> {-# UNPACK #-} !Int
type IPv4Addr = Word32
type IPv6Addr = (Word32, Word32, Word32, Word32)


-- | Data structures to express IPv4, IPv6 and IP range.
module Data.IP

-- | A unified IP data for <a>IP</a> and <a>IP</a>. To create this, use the
--   data constructors. Or use <a>read</a> <tt>"192.0.2.1"</tt> ::
--   <a>IP</a>, for example. Also, <tt>"192.0.2.1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1" :: IP) == IPv4 (read "192.0.2.1" :: IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01" :: IP) == IPv6 (read "2001:db8:00:00:00:00:00:01" :: IPv6)
--   True
--   </pre>
data IP
IPv4 :: IPv4 -> IP
[ipv4] :: IP -> IPv4
IPv6 :: IPv6 -> IP
[ipv6] :: IP -> IPv6

-- | The abstract data type to express an IPv4 address. To create this, use
--   <a>toIPv4</a>. Or use <a>read</a> <tt>"192.0.2.1"</tt> :: <a>IP</a>,
--   for example. Also, <tt>"192.0.2.1"</tt> can be used as literal with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1" :: IPv4
--   192.0.2.1
--   </pre>
data IPv4

-- | The <a>toIPv4</a> function returns the <a>IP</a> address corresponding
--   to the given list of <a>Int</a> octets. The function is strict in the
--   four elements of the list. An error is returned if the list has a
--   differnet length. The input elements are silently truncated to their 8
--   least-significant bits before they are combined to form the IPv4
--   address.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv4 [192,0,2,1]
--   192.0.2.1
--   </pre>
toIPv4 :: [Int] -> IPv4

-- | The <a>toIPv4w</a> function constructs the <a>IP</a> address
--   corresponding to the given <a>Word32</a> value. Unlike the
--   <a>fromHostAddress</a> function, it is strict in the input value,
--   which here is in host byte order.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv4w 0xc0000201
--   192.0.2.1
--   </pre>
toIPv4w :: Word32 -> IPv4

-- | The <a>fromIPv4</a> function returns the list of four <a>Int</a>
--   octets corresponding to the given <a>IP</a> address.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv4 (toIPv4 [192,0,2,1])
--   [192,0,2,1]
--   </pre>
fromIPv4 :: IPv4 -> [Int]

-- | The <a>fromIPv4w</a> function returns a single <a>Word32</a> value
--   corresponding to the given the <a>IP</a> address. Unlike the
--   <a>toHostAddress</a> function, the returned value is strictly
--   evaluated, and is not converted to network byte order.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv4w (toIPv4 [0xc0,0,2,1]) == 0xc0000201
--   True
--   </pre>
fromIPv4w :: IPv4 -> Word32

-- | The <a>fromHostAddress</a> function converts <a>HostAddress</a> to
--   <a>IP</a>.
fromHostAddress :: HostAddress -> IPv4

-- | The <a>toHostAddress</a> function converts <a>IP</a> to
--   <a>HostAddress</a>.
toHostAddress :: IPv4 -> HostAddress

-- | The abstract data type to express an IPv6 address. To create this, use
--   <a>toIPv6</a>. Or use <a>read</a> <tt>"2001:DB8::1"</tt> :: <a>IP</a>,
--   for example. Also, <tt>"2001:DB8::1"</tt> can be used as literal with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01" :: IPv6
--   2001:db8::1
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00::101" :: IPv6
--   2001:db8:11e:c00::101
--   
--   &gt;&gt;&gt; read "2001:db8:11e:c00:aa:bb:192.0.2.1" :: IPv6
--   2001:db8:11e:c00:aa:bb:c000:201
--   
--   &gt;&gt;&gt; read "2001:db8::192.0.2.1" :: IPv6
--   2001:db8::c000:201
--   
--   &gt;&gt;&gt; read "0::ffff:192.0.2.1" :: IPv6
--   ::ffff:192.0.2.1
--   
--   &gt;&gt;&gt; read "0::0:c000:201" :: IPv6
--   ::192.0.2.1
--   
--   &gt;&gt;&gt; read "::0.0.0.1" :: IPv6
--   ::1
--   </pre>
data IPv6

-- | The <a>toIPv6</a> function returns the <a>IP</a> address corresponding
--   to the given list of eight 16-bit <a>Int</a>s. The function is strict
--   in the eight elements of the list. An error is returned if the list
--   has a differnet length. The input elements are in host byte order and
--   are silently truncated to their 16 least-signicant bits before they
--   are combined to form the IPv6 address.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv6 [0x2001,0xDB8,0,0,0,0,0,1]
--   2001:db8::1
--   </pre>
toIPv6 :: [Int] -> IPv6

-- | The <a>toIPv6b</a> function returns the IPv6 address corresponding to
--   the given list of sixteen <a>Int</a> octets. The function is strict in
--   the sixteen elements of the list. An error is returned if the list has
--   a differnet length. The input elements are silently truncated to their
--   8 least-signicant bits before they are combined to form the IPv6
--   address.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv6b [0x20,0x01,0xD,0xB8,0,0,0,0,0,0,0,0,0,0,0,1]
--   2001:db8::1
--   </pre>
toIPv6b :: [Int] -> IPv6

-- | The <a>toIPv6w</a> function constructs the <a>IP</a> address
--   corresponding to the given four-tuple of host byte order <a>Word32</a>
--   values. This function differs from the <a>fromHostAddress6</a>
--   function only in the fact that it is strict in the elements of the
--   tuple.
--   
--   <pre>
--   &gt;&gt;&gt; toIPv6w (0x20010DB8,0x0,0x0,0x1)
--   2001:db8::1
--   </pre>
toIPv6w :: (Word32, Word32, Word32, Word32) -> IPv6

-- | The <a>fromIPv6</a> function returns a list eight <a>Int</a>s in host
--   byte order corresponding to the eight 16-bit fragments of the given
--   IPv6 address.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv6 (toIPv6 [0x2001,0xDB8,0,0,0,0,0,1])
--   [8193,3512,0,0,0,0,0,1]
--   </pre>
fromIPv6 :: IPv6 -> [Int]

-- | The <a>fromIPv6b</a> function returns the 16 <a>Int</a> octets
--   corresponding to the 16 bytes of the given IPv6 address.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv6b (toIPv6b [0x20,0x01,0xD,0xB8,0,0,0,0,0,0,0,0,0,0,0,1])
--   [32,1,13,184,0,0,0,0,0,0,0,0,0,0,0,1]
--   </pre>
fromIPv6b :: IPv6 -> [Int]

-- | The <a>fromIPv6w</a> function returns a four-tuple of <a>Word32</a>
--   values in host byte order corresponding to the given <a>IP</a>
--   address. This is identical to the <a>toHostAddress6</a> function,
--   except that the elements of four-tuple are first strictly evaluated.
--   
--   <pre>
--   &gt;&gt;&gt; fromIPv6w (toIPv6 [0x2001,0xDB8,0,0,0,0,0,1]) == (0x20010DB8, 0, 0, 1)
--   True
--   </pre>
fromIPv6w :: IPv6 -> (Word32, Word32, Word32, Word32)

-- | The <a>fromHostAddress6</a> function converts <a>HostAddress6</a> to
--   <a>IP</a>.
fromHostAddress6 :: HostAddress6 -> IPv6

-- | The <a>toHostAddress6</a> function converts <a>IP</a> to
--   <a>HostAddress6</a>.
toHostAddress6 :: IPv6 -> HostAddress6

-- | Convert IPv4 address to IPv4-embedded-in-IPv6
ipv4ToIPv6 :: IPv4 -> IPv6

-- | Convert <a>SockAddr</a> to <a>IP</a>.
--   
--   Since: 1.7.4.
fromSockAddr :: SockAddr -> Maybe (IP, PortNumber)

-- | Convert <a>IP</a> to <a>SockAddr</a>.
--   
--   Since: 1.7.8.
toSockAddr :: (IP, PortNumber) -> SockAddr

-- | A unified data for <a>AddrRange</a> <a>IP</a> and <a>AddrRange</a>
--   <a>IP</a>. To create this, use <a>read</a> <tt>"192.0.2.0/24"</tt> ::
--   <a>IPRange</a>. Also, <tt>"192.0.2.0/24"</tt> can be used as literal
--   with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1/24" :: IPRange) == IPv4Range (read "192.0.2.0/24" :: AddrRange IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01/48" :: IPRange) == IPv6Range (read "2001:db8:00:00:00:00:00:01/48" :: AddrRange IPv6)
--   True
--   </pre>
data IPRange
IPv4Range :: AddrRange IPv4 -> IPRange
[ipv4range] :: IPRange -> AddrRange IPv4
IPv6Range :: AddrRange IPv6 -> IPRange
[ipv6range] :: IPRange -> AddrRange IPv6

-- | The Addr range consists of an address, a contiguous mask, and mask
--   length. The contiguous mask and the mask length are essentially same
--   information but contained for pre calculation.
--   
--   To create this, use <tt>makeAddrRange</tt> or <a>read</a>
--   <tt>"192.0.2.0/24"</tt> :: <a>AddrRange</a> <a>IP</a>. Also,
--   <tt>"192.0.2.0/24"</tt> can be used as literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; read "192.0.2.1/24" :: AddrRange IPv4
--   192.0.2.0/24
--   
--   &gt;&gt;&gt; read "2001:db8:00:00:00:00:00:01/48" :: AddrRange IPv6
--   2001:db8::/48
--   </pre>
data AddrRange a

-- | <pre>
--   &gt;&gt;&gt; toIPv4 [127,0,2,1] `masked` intToMask 7
--   126.0.0.0
--   </pre>
class Eq a => Addr a

-- | The <a>masked</a> function takes an <a>Addr</a> and a contiguous mask
--   and returned a masked <a>Addr</a>.
masked :: Addr a => a -> a -> a

-- | The <a>intToMask</a> function takes an <a>Int</a> representing the
--   number of bits to be set in the returned contiguous mask. When this
--   integer is positive the bits will be starting from the MSB and from
--   the LSB otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; intToMask 16 :: IPv4
--   255.255.0.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intToMask (-16) :: IPv4
--   0.0.255.255
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intToMask 16 :: IPv6
--   ffff::
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intToMask (-16) :: IPv6
--   ::ffff
--   </pre>
intToMask :: Addr a => Int -> a

-- | The <a>makeAddrRange</a> functions takes an <a>Addr</a> address and a
--   mask length. It creates a bit mask from the mask length and masks the
--   <a>Addr</a> address, then returns <a>AddrRange</a> made of them.
--   
--   <pre>
--   &gt;&gt;&gt; makeAddrRange (toIPv4 [127,0,2,1]) 8
--   127.0.0.0/8
--   
--   &gt;&gt;&gt; makeAddrRange (toIPv6 [0x2001,0xDB8,0,0,0,0,0,1]) 8
--   2000::/8
--   </pre>
makeAddrRange :: Addr a => a -> Int -> AddrRange a

-- | The &gt;:&gt; operator takes two <a>AddrRange</a>. It returns
--   <a>True</a> if the first <a>AddrRange</a> contains the second
--   <a>AddrRange</a>. Otherwise, it returns <a>False</a>.
--   
--   <pre>
--   &gt;&gt;&gt; makeAddrRange ("127.0.2.1" :: IPv4) 8 &gt;:&gt; makeAddrRange "127.0.2.1" 24
--   True
--   
--   &gt;&gt;&gt; makeAddrRange ("127.0.2.1" :: IPv4) 24 &gt;:&gt; makeAddrRange "127.0.2.1" 8
--   False
--   
--   &gt;&gt;&gt; makeAddrRange ("2001:DB8::1" :: IPv6) 16 &gt;:&gt; makeAddrRange "2001:DB8::1" 32
--   True
--   
--   &gt;&gt;&gt; makeAddrRange ("2001:DB8::1" :: IPv6) 32 &gt;:&gt; makeAddrRange "2001:DB8::1" 16
--   False
--   </pre>
(>:>) :: Addr a => AddrRange a -> AddrRange a -> Bool

-- | The <a>isMatchedTo</a> function take an <a>Addr</a> address and an
--   <a>AddrRange</a>, and returns <a>True</a> if the range contains the
--   address.
--   
--   <pre>
--   &gt;&gt;&gt; ("127.0.2.0" :: IPv4) `isMatchedTo` makeAddrRange "127.0.2.1" 24
--   True
--   
--   &gt;&gt;&gt; ("127.0.2.0" :: IPv4) `isMatchedTo` makeAddrRange "127.0.2.1" 32
--   False
--   
--   &gt;&gt;&gt; ("2001:DB8::1" :: IPv6) `isMatchedTo` makeAddrRange "2001:DB8::1" 32
--   True
--   
--   &gt;&gt;&gt; ("2001:DB8::" :: IPv6) `isMatchedTo` makeAddrRange "2001:DB8::1" 128
--   False
--   </pre>
isMatchedTo :: Addr a => a -> AddrRange a -> Bool

-- | The <tt>unmakeAddrRange</tt> functions take a <a>AddrRange</a> and
--   returns the network address and a mask length.
--   
--   <pre>
--   &gt;&gt;&gt; addrRangePair ("127.0.0.0/8" :: AddrRange IPv4)
--   (127.0.0.0,8)
--   
--   &gt;&gt;&gt; addrRangePair ("2000::/8" :: AddrRange IPv6)
--   (2000::,8)
--   </pre>
addrRangePair :: Addr a => AddrRange a -> (a, Int)

-- | Convert IPv4 range to IPV4-embedded-in-IPV6 range
ipv4RangeToIPv6 :: AddrRange IPv4 -> AddrRange IPv6


-- | IP routing table is a tree of <a>AddrRange</a> to search one of them
--   on the longest match base. It is a kind of TRIE with one way branching
--   removed. Both IPv4 and IPv6 are supported.
module Data.IP.RouteTable.Internal

-- | A class to contain IPv4 and IPv6.
class Addr a => Routable a

-- | The <a>intToTBit</a> function takes <a>Int</a> and returns an
--   <a>Routable</a> address whose only n-th bit is set.
intToTBit :: Routable a => Int -> a

-- | The <a>isZero</a> function takes an <a>Routable</a> address and an
--   test bit <a>Routable</a> address and returns <a>True</a> is the bit is
--   unset, otherwise returns <a>False</a>.
isZero :: Routable a => a -> a -> Bool
intToTBitIPv4 :: Int -> IPv4
intToTBitIPv6 :: Int -> IPv6
intToTBitsWord32 :: [Word32]
intToTBitsIPv4 :: IntMap IPv4Addr
intToTBitsIPv6 :: IntMap IPv6Addr

-- | The Tree structure for IP routing table based on TRIE with one way
--   branching removed. This is an abstract data type, so you cannot touch
--   its inside. Please use <a>insert</a> or <a>lookup</a>, instead.
data IPRTable k a
Nil :: IPRTable k a
Node :: !AddrRange k -> !k -> !Maybe a -> !IPRTable k a -> !IPRTable k a -> IPRTable k a

-- | The <a>empty</a> function returns an empty IP routing table.
--   
--   <pre>
--   &gt;&gt;&gt; (empty :: IPRTable IPv4 ()) == fromList []
--   True
--   </pre>
empty :: Routable k => IPRTable k a

-- | The <a>insert</a> function inserts a value with a key of
--   <a>AddrRange</a> to <a>IPRTable</a> and returns a new <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (insert ("127.0.0.1" :: AddrRange IPv4) () empty) == fromList [("127.0.0.1",())]
--   True
--   </pre>
insert :: Routable k => AddrRange k -> a -> IPRTable k a -> IPRTable k a
link :: Routable k => IPRTable k a -> IPRTable k a -> IPRTable k a
glue :: Routable k => Int -> AddrRange k -> AddrRange k -> AddrRange k
keyToTestBit :: Routable k => AddrRange k -> k
isLeft :: Routable k => AddrRange k -> k -> Bool

-- | The <a>delete</a> function deletes a value by a key of
--   <a>AddrRange</a> from <a>IPRTable</a> and returns a new
--   <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; delete "127.0.0.1" (insert "127.0.0.1" () empty) == (empty :: IPRTable IPv4 ())
--   True
--   </pre>
delete :: Routable k => AddrRange k -> IPRTable k a -> IPRTable k a
node :: Routable k => AddrRange k -> k -> Maybe a -> IPRTable k a -> IPRTable k a -> IPRTable k a

-- | The <a>lookup</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If a routing information in <a>IPRTable</a> matches
--   the key, its value is returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 v4
--   
--   &gt;&gt;&gt; lookup "127.0.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.3.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.4.0.0" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.4.0.1" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.5.16.0" rt
--   Just 133.5.16.0/24
--   
--   &gt;&gt;&gt; lookup "133.5.16.1" rt
--   Just 133.5.16.0/24
--   </pre>
lookup :: Routable k => AddrRange k -> IPRTable k a -> Maybe a

-- | The <a>lookupKeyValue</a> function looks up <a>IPRTable</a> with a key
--   of <a>AddrRange</a>. If a routing information in <a>IPRTable</a>
--   matches the key, both key and value are returned.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let rt = fromList ([("192.168.0.0/24", 1), ("10.10.0.0/16", 2)] :: [(AddrRange IPv4, Int)])
--   
--   &gt;&gt;&gt; lookupKeyValue "127.0.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookupKeyValue "192.168.0.1" rt
--   Just (192.168.0.0/24,1)
--   
--   &gt;&gt;&gt; lookupKeyValue "10.10.0.1" rt
--   Just (10.10.0.0/16,2)
--   </pre>
lookupKeyValue :: Routable k => AddrRange k -> IPRTable k a -> Maybe (AddrRange k, a)
search :: Routable k => AddrRange k -> IPRTable k a -> Maybe (AddrRange k, a) -> Maybe (AddrRange k, a)

-- | <a>lookupAll</a> is a version of <a>lookup</a> that returns all
--   entries matching the given key, not just the longest match.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let rt = fromList ([("192.168.0.0/24", 1), ("10.10.0.0/16", 2), ("10.0.0.0/8", 3)] :: [(AddrRange IPv4, Int)])
--   
--   &gt;&gt;&gt; lookupAll "127.0.0.1" rt
--   []
--   
--   &gt;&gt;&gt; lookupAll "192.168.0.1" rt
--   [(192.168.0.0/24,1)]
--   
--   &gt;&gt;&gt; lookupAll "10.10.0.1" rt
--   [(10.10.0.0/16,2),(10.0.0.0/8,3)]
--   </pre>
lookupAll :: Routable k => AddrRange k -> IPRTable k a -> [(AddrRange k, a)]

-- | The <a>findMatch</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If the key matches routing informations in
--   <a>IPRTable</a>, they are returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 $ repeat ()
--   
--   &gt;&gt;&gt; findMatch "133.4.0.0/15" rt :: [(AddrRange IPv4,())]
--   [(133.4.0.0/16,()),(133.5.0.0/16,()),(133.5.16.0/24,()),(133.5.23.0/24,())]
--   </pre>
findMatch :: Alternative m => Routable k => AddrRange k -> IPRTable k a -> m (AddrRange k, a)

-- | The <a>fromList</a> function creates a new IP routing table from a
--   list of a pair of <tt>IPrange</tt> and value.
fromList :: Routable k => [(AddrRange k, a)] -> IPRTable k a

-- | The <a>toList</a> function creates a list of a pair of
--   <a>AddrRange</a> and value from an IP routing table.
toList :: Routable k => IPRTable k a -> [(AddrRange k, a)]
foldt :: (IPRTable k a -> b -> b) -> b -> IPRTable k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the IPRTable using the given
--   left-associative binary operator. This function is equivalent to
--   Data.Map.foldlWithKey with necessary to IPRTable changes. Since: 1.7.5
foldlWithKey :: (b -> AddrRange k -> a -> b) -> b -> IPRTable k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the IPRTable using the given
--   right-associative binary operator. This function is equivalent to
--   Data.Map.foldrWithKey with necessary to IPRTable changes. Since: 1.7.5
foldrWithKey :: (AddrRange k -> a -> b -> b) -> b -> IPRTable k a -> b
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Data.IP.RouteTable.Internal.IPRTable k a)
instance GHC.Generics.Generic1 (Data.IP.RouteTable.Internal.IPRTable k)
instance GHC.Generics.Generic (Data.IP.RouteTable.Internal.IPRTable k a)
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.IP.RouteTable.Internal.IPRTable k a)
instance GHC.Base.Functor (Data.IP.RouteTable.Internal.IPRTable k)
instance Data.Foldable.Foldable (Data.IP.RouteTable.Internal.IPRTable k)
instance Data.Traversable.Traversable (Data.IP.RouteTable.Internal.IPRTable k)
instance Data.IP.RouteTable.Internal.Routable k => GHC.Base.Semigroup (Data.IP.RouteTable.Internal.IPRTable k a)
instance Data.IP.RouteTable.Internal.Routable k => GHC.Base.Monoid (Data.IP.RouteTable.Internal.IPRTable k a)
instance Data.IP.RouteTable.Internal.Routable Data.IP.Addr.IPv4
instance Data.IP.RouteTable.Internal.Routable Data.IP.Addr.IPv6


-- | IP routing table is a tree of <tt>IPRange</tt> to search one of them
--   on the longest match base. It is a kind of TRIE with one way branching
--   removed. Both IPv4 and IPv6 are supported.
--   
--   For more information, see:
--   <a>http://www.mew.org/~kazu/proj/iproute/</a>
module Data.IP.RouteTable

-- | A class to contain IPv4 and IPv6.
class Addr a => Routable a

-- | The <a>intToTBit</a> function takes <a>Int</a> and returns an
--   <a>Routable</a> address whose only n-th bit is set.
intToTBit :: Routable a => Int -> a

-- | The <a>isZero</a> function takes an <a>Routable</a> address and an
--   test bit <a>Routable</a> address and returns <a>True</a> is the bit is
--   unset, otherwise returns <a>False</a>.
isZero :: Routable a => a -> a -> Bool

-- | The Tree structure for IP routing table based on TRIE with one way
--   branching removed. This is an abstract data type, so you cannot touch
--   its inside. Please use <a>insert</a> or <a>lookup</a>, instead.
data IPRTable k a

-- | The <a>empty</a> function returns an empty IP routing table.
--   
--   <pre>
--   &gt;&gt;&gt; (empty :: IPRTable IPv4 ()) == fromList []
--   True
--   </pre>
empty :: Routable k => IPRTable k a

-- | The <a>insert</a> function inserts a value with a key of
--   <a>AddrRange</a> to <a>IPRTable</a> and returns a new <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (insert ("127.0.0.1" :: AddrRange IPv4) () empty) == fromList [("127.0.0.1",())]
--   True
--   </pre>
insert :: Routable k => AddrRange k -> a -> IPRTable k a -> IPRTable k a

-- | The <a>delete</a> function deletes a value by a key of
--   <a>AddrRange</a> from <a>IPRTable</a> and returns a new
--   <a>IPRTable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; delete "127.0.0.1" (insert "127.0.0.1" () empty) == (empty :: IPRTable IPv4 ())
--   True
--   </pre>
delete :: Routable k => AddrRange k -> IPRTable k a -> IPRTable k a

-- | The <a>lookup</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If a routing information in <a>IPRTable</a> matches
--   the key, its value is returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 v4
--   
--   &gt;&gt;&gt; lookup "127.0.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.3.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookup "133.4.0.0" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.4.0.1" rt
--   Just 133.4.0.0/16
--   
--   &gt;&gt;&gt; lookup "133.5.16.0" rt
--   Just 133.5.16.0/24
--   
--   &gt;&gt;&gt; lookup "133.5.16.1" rt
--   Just 133.5.16.0/24
--   </pre>
lookup :: Routable k => AddrRange k -> IPRTable k a -> Maybe a

-- | The <a>lookupKeyValue</a> function looks up <a>IPRTable</a> with a key
--   of <a>AddrRange</a>. If a routing information in <a>IPRTable</a>
--   matches the key, both key and value are returned.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let rt = fromList ([("192.168.0.0/24", 1), ("10.10.0.0/16", 2)] :: [(AddrRange IPv4, Int)])
--   
--   &gt;&gt;&gt; lookupKeyValue "127.0.0.1" rt
--   Nothing
--   
--   &gt;&gt;&gt; lookupKeyValue "192.168.0.1" rt
--   Just (192.168.0.0/24,1)
--   
--   &gt;&gt;&gt; lookupKeyValue "10.10.0.1" rt
--   Just (10.10.0.0/16,2)
--   </pre>
lookupKeyValue :: Routable k => AddrRange k -> IPRTable k a -> Maybe (AddrRange k, a)

-- | <a>lookupAll</a> is a version of <a>lookup</a> that returns all
--   entries matching the given key, not just the longest match.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; let rt = fromList ([("192.168.0.0/24", 1), ("10.10.0.0/16", 2), ("10.0.0.0/8", 3)] :: [(AddrRange IPv4, Int)])
--   
--   &gt;&gt;&gt; lookupAll "127.0.0.1" rt
--   []
--   
--   &gt;&gt;&gt; lookupAll "192.168.0.1" rt
--   [(192.168.0.0/24,1)]
--   
--   &gt;&gt;&gt; lookupAll "10.10.0.1" rt
--   [(10.10.0.0/16,2),(10.0.0.0/8,3)]
--   </pre>
lookupAll :: Routable k => AddrRange k -> IPRTable k a -> [(AddrRange k, a)]

-- | The <a>findMatch</a> function looks up <a>IPRTable</a> with a key of
--   <a>AddrRange</a>. If the key matches routing informations in
--   <a>IPRTable</a>, they are returned.
--   
--   <pre>
--   &gt;&gt;&gt; let v4 = ["133.4.0.0/16","133.5.0.0/16","133.5.16.0/24","133.5.23.0/24"] :: [AddrRange IPv4]
--   
--   &gt;&gt;&gt; let rt = fromList $ zip v4 $ repeat ()
--   
--   &gt;&gt;&gt; findMatch "133.4.0.0/15" rt :: [(AddrRange IPv4,())]
--   [(133.4.0.0/16,()),(133.5.0.0/16,()),(133.5.16.0/24,()),(133.5.23.0/24,())]
--   </pre>
findMatch :: Alternative m => Routable k => AddrRange k -> IPRTable k a -> m (AddrRange k, a)

-- | The <a>fromList</a> function creates a new IP routing table from a
--   list of a pair of <tt>IPrange</tt> and value.
fromList :: Routable k => [(AddrRange k, a)] -> IPRTable k a

-- | The <a>toList</a> function creates a list of a pair of
--   <a>AddrRange</a> and value from an IP routing table.
toList :: Routable k => IPRTable k a -> [(AddrRange k, a)]

-- | <i>O(n)</i>. Fold the keys and values in the IPRTable using the given
--   left-associative binary operator. This function is equivalent to
--   Data.Map.foldlWithKey with necessary to IPRTable changes. Since: 1.7.5
foldlWithKey :: (b -> AddrRange k -> a -> b) -> b -> IPRTable k a -> b

-- | <i>O(n)</i>. Fold the keys and values in the IPRTable using the given
--   right-associative binary operator. This function is equivalent to
--   Data.Map.foldrWithKey with necessary to IPRTable changes. Since: 1.7.5
foldrWithKey :: (AddrRange k -> a -> b -> b) -> b -> IPRTable k a -> b
