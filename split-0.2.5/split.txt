-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinator library for splitting lists.
--   
--   A collection of various methods for splitting lists into parts, akin
--   to the "split" function found in several mainstream languages. Here is
--   its tale:
--   
--   Once upon a time the standard <a>Data.List</a> module held no function
--   for splitting a list into parts according to a delimiter. Many a brave
--   lambda-knight strove to add such a function, but their striving was in
--   vain, for Lo, the Supreme Council fell to bickering amongst themselves
--   what was to be the essential nature of the One True Function which
--   could cleave a list in twain (or thrain, or any required number of
--   parts).
--   
--   And thus came to pass the split package, comprising divers functions
--   for splitting a list asunder, each according to its nature. And the
--   Supreme Council had no longer any grounds for argument, for the
--   favored method of each was contained therein.
--   
--   To get started, see the <a>Data.List.Split</a> module.
@package split
@version 0.2.5


-- | Implementation module for <a>Data.List.Split</a>, a combinator library
--   for splitting lists. See the <a>Data.List.Split</a> documentation for
--   more description and examples.
module Data.List.Split.Internals

-- | A splitting strategy.
data Splitter a
Splitter :: Delimiter a -> DelimPolicy -> CondensePolicy -> EndPolicy -> EndPolicy -> Splitter a

-- | What delimiter to split on
[delimiter] :: Splitter a -> Delimiter a

-- | What to do with delimiters (drop from output, keep as separate
--   elements in output, or merge with previous or following chunks)
[delimPolicy] :: Splitter a -> DelimPolicy

-- | What to do with multiple consecutive delimiters
[condensePolicy] :: Splitter a -> CondensePolicy

-- | Drop an initial blank?
[initBlankPolicy] :: Splitter a -> EndPolicy

-- | Drop a final blank?
[finalBlankPolicy] :: Splitter a -> EndPolicy

-- | The default splitting strategy: keep delimiters in the output as
--   separate chunks, don't condense multiple consecutive delimiters into
--   one, keep initial and final blank chunks. Default delimiter is the
--   constantly false predicate.
--   
--   Note that <a>defaultSplitter</a> should normally not be used; use
--   <a>oneOf</a>, <a>onSublist</a>, or <a>whenElt</a> instead, which are
--   the same as the <a>defaultSplitter</a> with just the delimiter
--   overridden.
--   
--   The <a>defaultSplitter</a> strategy with any delimiter gives a
--   maximally information-preserving splitting strategy, in the sense that
--   (a) taking the <a>concat</a> of the output yields the original list,
--   and (b) given only the output list, we can reconstruct a
--   <a>Splitter</a> which would produce the same output list again given
--   the original input list. This default strategy can be overridden to
--   allow discarding various sorts of information.
defaultSplitter :: Splitter a

-- | A delimiter is a list of predicates on elements, matched by some
--   contiguous subsequence of a list.
newtype Delimiter a
Delimiter :: [a -> Bool] -> Delimiter a

-- | Try to match a delimiter at the start of a list, either failing or
--   decomposing the list into the portion which matched the delimiter and
--   the remainder.
matchDelim :: Delimiter a -> [a] -> Maybe ([a], [a])

-- | What to do with delimiters?
data DelimPolicy

-- | Drop delimiters from the output.
Drop :: DelimPolicy

-- | Keep delimiters as separate chunks of the output.
Keep :: DelimPolicy

-- | Keep delimiters in the output, prepending them to the following chunk.
KeepLeft :: DelimPolicy

-- | Keep delimiters in the output, appending them to the previous chunk.
KeepRight :: DelimPolicy

-- | What to do with multiple consecutive delimiters?
data CondensePolicy

-- | Condense into a single delimiter.
Condense :: CondensePolicy

-- | Keep consecutive delimiters separate, but don't insert blank chunks in
--   between them.
DropBlankFields :: CondensePolicy

-- | Insert blank chunks between consecutive delimiters.
KeepBlankFields :: CondensePolicy

-- | What to do with a blank chunk at either end of the list (<i>i.e.</i>
--   when the list begins or ends with a delimiter).
data EndPolicy
DropBlank :: EndPolicy
KeepBlank :: EndPolicy

-- | Tag chunks as delimiters or text.
data Chunk a
Delim :: [a] -> Chunk a
Text :: [a] -> Chunk a

-- | Internal representation of a split list that tracks which pieces are
--   delimiters and which aren't.
type SplitList a = [Chunk a]

-- | Untag a <a>Chunk</a>.
fromElem :: Chunk a -> [a]

-- | Test whether a <a>Chunk</a> is a delimiter.
isDelim :: Chunk a -> Bool

-- | Test whether a <a>Chunk</a> is text.
isText :: Chunk a -> Bool

-- | Given a delimiter to use, split a list into an internal representation
--   with chunks tagged as delimiters or text. This transformation is
--   lossless; in particular,
--   
--   <pre>
--   <a>concatMap</a> <a>fromElem</a> (<a>splitInternal</a> d l) == l.
--   </pre>
splitInternal :: Delimiter a -> [a] -> SplitList a

-- | Given a split list in the internal tagged representation, produce a
--   new internal tagged representation corresponding to the final output,
--   according to the strategy defined by the given <a>Splitter</a>.
postProcess :: Splitter a -> SplitList a -> SplitList a

-- | Drop delimiters if the <a>DelimPolicy</a> is <a>Drop</a>.
doDrop :: DelimPolicy -> SplitList a -> SplitList a

-- | Condense multiple consecutive delimiters into one if the
--   <a>CondensePolicy</a> is <a>Condense</a>.
doCondense :: CondensePolicy -> SplitList a -> SplitList a

-- | Insert blank chunks between any remaining consecutive delimiters
--   (unless the condense policy is <a>DropBlankFields</a>), and at the
--   beginning or end if the first or last element is a delimiter.
insertBlanks :: CondensePolicy -> SplitList a -> SplitList a

-- | Insert blank chunks between consecutive delimiters.
insertBlanks' :: CondensePolicy -> SplitList a -> SplitList a

-- | Merge delimiters into adjacent chunks according to the
--   <a>DelimPolicy</a>.
doMerge :: DelimPolicy -> SplitList a -> SplitList a

-- | Merge delimiters with adjacent chunks to the right (yes, that's not a
--   typo: the delimiters should end up on the left of the chunks, so they
--   are merged with chunks to their right).
mergeLeft :: SplitList a -> SplitList a

-- | Merge delimiters with adjacent chunks to the left.
mergeRight :: SplitList a -> SplitList a

-- | Drop an initial blank chunk according to the given <a>EndPolicy</a>.
dropInitial :: EndPolicy -> SplitList a -> SplitList a

-- | Drop a final blank chunk according to the given <a>EndPolicy</a>.
dropFinal :: EndPolicy -> SplitList a -> SplitList a

-- | Split a list according to the given splitting strategy. This is how to
--   "run" a <a>Splitter</a> that has been built using the other
--   combinators.
split :: Splitter a -> [a] -> [[a]]

-- | A splitting strategy that splits on any one of the given elements.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ",;") "hi;there,world"
--   ["hi",";","there",",","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf "xyz") "aazbxyzcxd"
--   ["aa","z","b","x","","y","","z","c","x","d"]
--   </pre>
oneOf :: Eq a => [a] -> Splitter a

-- | A splitting strategy that splits on the given list, when it is
--   encountered as an exact subsequence.
--   
--   <pre>
--   &gt;&gt;&gt; split (onSublist "xyz") "aazbxyzcxd"
--   ["aazb","xyz","cxd"]
--   </pre>
--   
--   Note that splitting on the empty list is a special case, which splits
--   just before every element of the list being split.
--   
--   <pre>
--   &gt;&gt;&gt; split (onSublist "") "abc"
--   ["","","a","","b","","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims . dropBlanks $ onSublist "") "abc"
--   ["a","b","c"]
--   </pre>
--   
--   However, if you want to break a list into singleton elements like
--   this, you are better off using <tt><a>chunksOf</a> 1</tt>, or better
--   yet, <tt><a>map</a> (:[])</tt>.
onSublist :: Eq a => [a] -> Splitter a

-- | A splitting strategy that splits on any elements that satisfy the
--   given predicate.
--   
--   <pre>
--   &gt;&gt;&gt; split (whenElt (&lt;0)) [2,4,-3,6,-9,1 :: Int]
--   [[2,4],[-3],[6],[-9],[1]]
--   </pre>
whenElt :: (a -> Bool) -> Splitter a

-- | Drop delimiters from the output (the default is to keep them).
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "a:b:c"
--   ["a",":","b",":","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims $ oneOf ":") "a:b:c"
--   ["a","b","c"]
--   </pre>
dropDelims :: Splitter a -> Splitter a

-- | Keep delimiters in the output by prepending them to adjacent chunks.
--   
--   <pre>
--   &gt;&gt;&gt; split (keepDelimsL $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","zb","x","y","zc","xd"]
--   </pre>
keepDelimsL :: Splitter a -> Splitter a

-- | Keep delimiters in the output by appending them to adjacent chunks.
--   
--   <pre>
--   &gt;&gt;&gt; split (keepDelimsR $ oneOf "xyz") "aazbxyzcxd"
--   ["aaz","bx","y","z","cx","d"]
--   </pre>
keepDelimsR :: Splitter a -> Splitter a

-- | Condense multiple consecutive delimiters into one.
--   
--   <pre>
--   &gt;&gt;&gt; split (condense $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","z","b","xyz","c","x","d"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","b","","","c","d"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (condense . dropDelims $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","b","c","d"]
--   </pre>
condense :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the beginning.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") ":a:b"
--   ["",":","a",":","b"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropInitBlank $ oneOf ":") ":a:b"
--   [":","a",":","b"]
--   </pre>
dropInitBlank :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the end.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "a:b:"
--   ["a",":","b",":",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropFinalBlank $ oneOf ":") "a:b:"
--   ["a",":","b",":"]
--   </pre>
dropFinalBlank :: Splitter a -> Splitter a

-- | Don't generate blank chunks between consecutive delimiters.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "::b:::a"
--   ["",":","",":","b",":","",":","",":","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropInnerBlanks $ oneOf ":") "::b:::a"
--   ["",":",":","b",":",":",":","a"]
--   </pre>
dropInnerBlanks :: Splitter a -> Splitter a

-- | Split over a different type of element by performing a preprocessing
--   step.
--   
--   <pre>
--   &gt;&gt;&gt; split (mapSplitter snd $ oneOf "-_") $ zip [0..] "a-bc_d"
--   [[(0,'a')],[(1,'-')],[(2,'b'),(3,'c')],[(4,'_')],[(5,'d')]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char (toLower)
--   
--   &gt;&gt;&gt; split (mapSplitter toLower $ dropDelims $ whenElt (== 'x')) "abXcxd"
--   ["ab","c","d"]
--   </pre>
mapSplitter :: (b -> a) -> Splitter a -> Splitter b

-- | Drop all blank chunks from the output, and condense consecutive
--   delimiters into one. Equivalent to <tt><a>dropInitBlank</a> .
--   <a>dropFinalBlank</a> . <a>condense</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "::b:::a"
--   ["",":","",":","b",":","",":","",":","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropBlanks $ oneOf ":") "::b:::a"
--   ["::","b",":::","a"]
--   </pre>
dropBlanks :: Splitter a -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with the
--   given subsequence (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (startsWith "app") "applyapplicativeapplaudapproachapple"
--   ["apply","applicative","applaud","approach","apple"]
--   </pre>
startsWith :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with one
--   of the given elements (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>oneOf</a></tt>.
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; split (startsWithOneOf ['A'..'Z']) "ACamelCaseIdentifier"
--   ["A","Camel","Case","Identifier"]
--   </pre>
startsWithOneOf :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all end with the
--   given subsequence, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> .
--   <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (endsWith "ly") "happilyslowlygnarlylily"
--   ["happily","slowly","gnarly","lily"]
--   </pre>
endsWith :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all end with one
--   of the given elements, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> . <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (condense $ endsWithOneOf ".,?! ") "Hi, there!  How are you?"
--   ["Hi, ","there!  ","How ","are ","you?"]
--   </pre>
endsWithOneOf :: Eq a => [a] -> Splitter a

-- | Split on any of the given elements. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitOneOf ";.," "foo,bar;baz.glurk"
--   ["foo","bar","baz","glurk"]
--   </pre>
splitOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split on the given sublist. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitOn ":" "12:35:07"
--   ["12","35","07"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "x" "axbxc"
--   ["a","b","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "x" "axbxcx"
--   ["a","b","c",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn ".." "a..b...c....d.."
--   ["a","b",".c","","d",""]
--   </pre>
--   
--   In some parsing combinator frameworks this is also known as
--   <tt>sepBy</tt>.
--   
--   Note that this is the right inverse of the <a>intercalate</a> function
--   from <a>Data.List</a>, that is,
--   
--   <pre>
--   intercalate x . splitOn x === id
--   </pre>
--   
--   <tt><a>splitOn</a> x . <a>intercalate</a> x</tt> is the identity on
--   certain lists, but it is tricky to state the precise conditions under
--   which this holds. (For example, it is not enough to say that
--   <tt>x</tt> does not occur in any elements of the input list. Working
--   out why is left as an exercise for the reader.)
splitOn :: Eq a => [a] -> [a] -> [[a]]

-- | Split on elements satisfying the given predicate. Equivalent to
--   <tt><a>split</a> . <a>dropDelims</a> . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitWhen (&lt;0) [1,3,-4,5,7,-9,0,2]
--   [[1,3],[5,7],[0,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitWhen (&lt;0) [1,-2,3,4,-5,-6,7,8,-9]
--   [[1],[3,4],[],[7,8],[]]
--   </pre>
splitWhen :: (a -> Bool) -> [a] -> [[a]]

-- | Split into chunks terminated by the given subsequence. Equivalent to
--   <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; endBy ".;" "foo.;bar.;baz.;"
--   ["foo","bar","baz"]
--   </pre>
--   
--   Note also that the <a>lines</a> function from <a>Data.List</a> is
--   equivalent to <tt><a>endBy</a> "\n"</tt>.
endBy :: Eq a => [a] -> [a] -> [[a]]

-- | Split into chunks terminated by one of the given elements. Equivalent
--   to <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; endByOneOf ";," "foo;bar,baz;"
--   ["foo","bar","baz"]
--   </pre>
endByOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split into "words", with word boundaries indicated by the given
--   predicate. Satisfies <tt><a>words</a> === wordsBy <a>isSpace</a></tt>;
--   equivalent to <tt><a>split</a> . <a>dropBlanks</a> . <a>dropDelims</a>
--   . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (`elem` ",;.?! ") "Hello there, world! How?"
--   ["Hello","there","world","How"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (=='x') "dogxxxcatxbirdxx"
--   ["dog","cat","bird"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Split into "lines", with line boundaries indicated by the given
--   predicate. Satisfies <tt><a>lines</a> === linesBy (=='n')</tt>;
--   equivalent to <tt><a>split</a> . <a>dropFinalBlank</a> .
--   <a>dropDelims</a> . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; linesBy (==';') "foo;bar;;baz;"
--   ["foo","bar","","baz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linesBy (=='x') "dogxxxcatxbirdxx"
--   ["dog","","","cat","bird",""]
--   </pre>
linesBy :: (a -> Bool) -> [a] -> [[a]]

-- | Standard build function, specialized to building lists.
--   
--   Usually build is given the rank-2 type
--   
--   <pre>
--   build :: (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
--   </pre>
--   
--   but since we only use it when <tt>(b ~ [a])</tt>, we give it the more
--   restricted type signature in order to avoid needing a non-Haskell2010
--   extension.
--   
--   Note that the 0.1.4.3 release of this package did away with a custom
--   <tt>build</tt> implementation in favor of importing one from
--   <a>GHC.Exts</a>, which was (reportedly) faster for some applications.
--   However, in the interest of simplicity and complete Haskell2010
--   compliance as <tt>split</tt> is being included in the Haskel Platform,
--   version 0.2.1.0 has gone back to defining <tt>build</tt> manually.
--   This is in line with <tt>split</tt>'s design philosophy of having
--   efficiency as a non-goal.
build :: ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]

-- | <tt><a>chunksOf</a> n</tt> splits a list into length-n pieces. The
--   last piece will be shorter if <tt>n</tt> does not evenly divide the
--   length of the list. If <tt>n &lt;= 0</tt>, <tt><a>chunksOf</a> n
--   l</tt> returns an infinite list of empty lists.
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 [1..12]
--   [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 "Hello there"
--   ["Hel","lo ","the","re"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 ([] :: [Int])
--   []
--   </pre>
--   
--   Note that <tt><a>chunksOf</a> n []</tt> is <tt>[]</tt>, not
--   <tt>[[]]</tt>. This is intentional, and satisfies the property that
--   
--   <pre>
--   chunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)
--   </pre>
--   
--   whenever <tt>n</tt> evenly divides the length of <tt>xs</tt>.
chunksOf :: Int -> [e] -> [[e]]

-- | Split a list into chunks of the given lengths.
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [2,3,4] [1..20]
--   [[1,2],[3,4,5],[6,7,8,9]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [4,9] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [4,9,3] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   If the input list is longer than the total of the given lengths, then
--   the remaining elements are dropped. If the list is shorter than the
--   total of the given lengths, then the result may contain fewer chunks
--   than requested, and the last chunk may be shorter than requested.
splitPlaces :: Integral a => [a] -> [e] -> [[e]]

-- | Split a list into chunks of the given lengths. Unlike
--   <a>splitPlaces</a>, the output list will always be the same length as
--   the first input argument. If the input list is longer than the total
--   of the given lengths, then the remaining elements are dropped. If the
--   list is shorter than the total of the given lengths, then the last
--   several chunks will be shorter than requested or empty.
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [2,3,4] [1..20]
--   [[1,2],[3,4,5],[6,7,8,9]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [4,9] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [4,9,3] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10],[]]
--   </pre>
--   
--   Notice the empty list in the output of the third example, which
--   differs from the behavior of <a>splitPlaces</a>.
splitPlacesBlanks :: Integral a => [a] -> [e] -> [[e]]

-- | A useful recursion pattern for processing a list to produce a new
--   list, often used for "chopping" up the input list. Typically chop is
--   called with some function that will consume an initial prefix of the
--   list and produce a value and the rest of the list.
--   
--   For example, many common Prelude functions can be implemented in terms
--   of <tt>chop</tt>:
--   
--   <pre>
--   group :: (Eq a) =&gt; [a] -&gt; [[a]]
--   group = chop (\ xs@(x:_) -&gt; span (==x) xs)
--   
--   words :: String -&gt; [String]
--   words = filter (not . null) . chop (break isSpace . dropWhile isSpace)
--   </pre>
chop :: ([a] -> (b, [a])) -> [a] -> [b]

-- | Divides up an input list into a set of sublists, according to
--   <tt>n</tt> and <tt>m</tt> input specifications you provide. Each
--   sublist will have <tt>n</tt> items, and the start of each sublist will
--   be offset by <tt>m</tt> items from the previous one.
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 5 [1..15]
--   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 2 [1..15]
--   [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9],[7,8,9,10,11],[9,10,11,12,13],[11,12,13,14,15]]
--   </pre>
--   
--   In the case where a source list's trailing elements do no fill an
--   entire sublist, those trailing elements will be dropped.
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 2 [1..10]
--   [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9]]
--   </pre>
--   
--   As an example, you can generate a moving average over a list of
--   prices:
--   
--   <pre>
--   type Prices = [Float]
--   type AveragePrices = [Float]
--   
--   average :: [Float] -&gt; Float
--   average xs = sum xs / (fromIntegral $ length xs)
--   
--   simpleMovingAverage :: Prices -&gt; AveragePrices
--   simpleMovingAverage = map average . divvy 20 1
--   </pre>
divvy :: Int -> Int -> [a] -> [[a]]
instance GHC.Show.Show Data.List.Split.Internals.DelimPolicy
instance GHC.Classes.Eq Data.List.Split.Internals.DelimPolicy
instance GHC.Show.Show Data.List.Split.Internals.CondensePolicy
instance GHC.Classes.Eq Data.List.Split.Internals.CondensePolicy
instance GHC.Show.Show Data.List.Split.Internals.EndPolicy
instance GHC.Classes.Eq Data.List.Split.Internals.EndPolicy
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.List.Split.Internals.Chunk a)
instance GHC.Show.Show a => GHC.Show.Show (Data.List.Split.Internals.Chunk a)


-- | The <a>Data.List.Split</a> module contains a wide range of strategies
--   for splitting lists with respect to some sort of delimiter, mostly
--   implemented through a unified combinator interface. The goal is to be
--   flexible yet simple. See below for usage, examples, and detailed
--   documentation of all exported functions. If you want to learn about
--   the implementation, see <a>Data.List.Split.Internals</a>.
--   
--   A git repository containing the source (including a module with over
--   40 QuickCheck properties) can be found at
--   <a>https://github.com/byorgey/split</a>.
module Data.List.Split

-- | Split on the given sublist. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitOn ":" "12:35:07"
--   ["12","35","07"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "x" "axbxc"
--   ["a","b","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn "x" "axbxcx"
--   ["a","b","c",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitOn ".." "a..b...c....d.."
--   ["a","b",".c","","d",""]
--   </pre>
--   
--   In some parsing combinator frameworks this is also known as
--   <tt>sepBy</tt>.
--   
--   Note that this is the right inverse of the <a>intercalate</a> function
--   from <a>Data.List</a>, that is,
--   
--   <pre>
--   intercalate x . splitOn x === id
--   </pre>
--   
--   <tt><a>splitOn</a> x . <a>intercalate</a> x</tt> is the identity on
--   certain lists, but it is tricky to state the precise conditions under
--   which this holds. (For example, it is not enough to say that
--   <tt>x</tt> does not occur in any elements of the input list. Working
--   out why is left as an exercise for the reader.)
splitOn :: Eq a => [a] -> [a] -> [[a]]

-- | Split on any of the given elements. Equivalent to <tt><a>split</a> .
--   <a>dropDelims</a> . <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitOneOf ";.," "foo,bar;baz.glurk"
--   ["foo","bar","baz","glurk"]
--   </pre>
splitOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split on elements satisfying the given predicate. Equivalent to
--   <tt><a>split</a> . <a>dropDelims</a> . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; splitWhen (&lt;0) [1,3,-4,5,7,-9,0,2]
--   [[1,3],[5,7],[0,2]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitWhen (&lt;0) [1,-2,3,4,-5,-6,7,8,-9]
--   [[1],[3,4],[],[7,8],[]]
--   </pre>
splitWhen :: (a -> Bool) -> [a] -> [[a]]

-- | Split into chunks terminated by the given subsequence. Equivalent to
--   <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; endBy ".;" "foo.;bar.;baz.;"
--   ["foo","bar","baz"]
--   </pre>
--   
--   Note also that the <a>lines</a> function from <a>Data.List</a> is
--   equivalent to <tt><a>endBy</a> "\n"</tt>.
endBy :: Eq a => [a] -> [a] -> [[a]]

-- | Split into chunks terminated by one of the given elements. Equivalent
--   to <tt><a>split</a> . <a>dropFinalBlank</a> . <a>dropDelims</a> .
--   <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; endByOneOf ";," "foo;bar,baz;"
--   ["foo","bar","baz"]
--   </pre>
endByOneOf :: Eq a => [a] -> [a] -> [[a]]

-- | Split into "words", with word boundaries indicated by the given
--   predicate. Satisfies <tt><a>words</a> === wordsBy <a>isSpace</a></tt>;
--   equivalent to <tt><a>split</a> . <a>dropBlanks</a> . <a>dropDelims</a>
--   . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (`elem` ",;.?! ") "Hello there, world! How?"
--   ["Hello","there","world","How"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (=='x') "dogxxxcatxbirdxx"
--   ["dog","cat","bird"]
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Split into "lines", with line boundaries indicated by the given
--   predicate. Satisfies <tt><a>lines</a> === linesBy (=='n')</tt>;
--   equivalent to <tt><a>split</a> . <a>dropFinalBlank</a> .
--   <a>dropDelims</a> . <a>whenElt</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; linesBy (==';') "foo;bar;;baz;"
--   ["foo","bar","","baz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; linesBy (=='x') "dogxxxcatxbirdxx"
--   ["dog","","","cat","bird",""]
--   </pre>
linesBy :: (a -> Bool) -> [a] -> [[a]]

-- | <tt><a>chunksOf</a> n</tt> splits a list into length-n pieces. The
--   last piece will be shorter if <tt>n</tt> does not evenly divide the
--   length of the list. If <tt>n &lt;= 0</tt>, <tt><a>chunksOf</a> n
--   l</tt> returns an infinite list of empty lists.
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 [1..12]
--   [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 "Hello there"
--   ["Hel","lo ","the","re"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; chunksOf 3 ([] :: [Int])
--   []
--   </pre>
--   
--   Note that <tt><a>chunksOf</a> n []</tt> is <tt>[]</tt>, not
--   <tt>[[]]</tt>. This is intentional, and satisfies the property that
--   
--   <pre>
--   chunksOf n xs ++ chunksOf n ys == chunksOf n (xs ++ ys)
--   </pre>
--   
--   whenever <tt>n</tt> evenly divides the length of <tt>xs</tt>.
chunksOf :: Int -> [e] -> [[e]]

-- | Split a list into chunks of the given lengths.
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [2,3,4] [1..20]
--   [[1,2],[3,4,5],[6,7,8,9]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [4,9] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlaces [4,9,3] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   If the input list is longer than the total of the given lengths, then
--   the remaining elements are dropped. If the list is shorter than the
--   total of the given lengths, then the result may contain fewer chunks
--   than requested, and the last chunk may be shorter than requested.
splitPlaces :: Integral a => [a] -> [e] -> [[e]]

-- | Split a list into chunks of the given lengths. Unlike
--   <a>splitPlaces</a>, the output list will always be the same length as
--   the first input argument. If the input list is longer than the total
--   of the given lengths, then the remaining elements are dropped. If the
--   list is shorter than the total of the given lengths, then the last
--   several chunks will be shorter than requested or empty.
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [2,3,4] [1..20]
--   [[1,2],[3,4,5],[6,7,8,9]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [4,9] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; splitPlacesBlanks [4,9,3] [1..10]
--   [[1,2,3,4],[5,6,7,8,9,10],[]]
--   </pre>
--   
--   Notice the empty list in the output of the third example, which
--   differs from the behavior of <a>splitPlaces</a>.
splitPlacesBlanks :: Integral a => [a] -> [e] -> [[e]]

-- | A useful recursion pattern for processing a list to produce a new
--   list, often used for "chopping" up the input list. Typically chop is
--   called with some function that will consume an initial prefix of the
--   list and produce a value and the rest of the list.
--   
--   For example, many common Prelude functions can be implemented in terms
--   of <tt>chop</tt>:
--   
--   <pre>
--   group :: (Eq a) =&gt; [a] -&gt; [[a]]
--   group = chop (\ xs@(x:_) -&gt; span (==x) xs)
--   
--   words :: String -&gt; [String]
--   words = filter (not . null) . chop (break isSpace . dropWhile isSpace)
--   </pre>
chop :: ([a] -> (b, [a])) -> [a] -> [b]

-- | Divides up an input list into a set of sublists, according to
--   <tt>n</tt> and <tt>m</tt> input specifications you provide. Each
--   sublist will have <tt>n</tt> items, and the start of each sublist will
--   be offset by <tt>m</tt> items from the previous one.
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 5 [1..15]
--   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 2 [1..15]
--   [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9],[7,8,9,10,11],[9,10,11,12,13],[11,12,13,14,15]]
--   </pre>
--   
--   In the case where a source list's trailing elements do no fill an
--   entire sublist, those trailing elements will be dropped.
--   
--   <pre>
--   &gt;&gt;&gt; divvy 5 2 [1..10]
--   [[1,2,3,4,5],[3,4,5,6,7],[5,6,7,8,9]]
--   </pre>
--   
--   As an example, you can generate a moving average over a list of
--   prices:
--   
--   <pre>
--   type Prices = [Float]
--   type AveragePrices = [Float]
--   
--   average :: [Float] -&gt; Float
--   average xs = sum xs / (fromIntegral $ length xs)
--   
--   simpleMovingAverage :: Prices -&gt; AveragePrices
--   simpleMovingAverage = map average . divvy 20 1
--   </pre>
divvy :: Int -> Int -> [a] -> [[a]]

-- | A splitting strategy.
data Splitter a

-- | The default splitting strategy: keep delimiters in the output as
--   separate chunks, don't condense multiple consecutive delimiters into
--   one, keep initial and final blank chunks. Default delimiter is the
--   constantly false predicate.
--   
--   Note that <a>defaultSplitter</a> should normally not be used; use
--   <a>oneOf</a>, <a>onSublist</a>, or <a>whenElt</a> instead, which are
--   the same as the <a>defaultSplitter</a> with just the delimiter
--   overridden.
--   
--   The <a>defaultSplitter</a> strategy with any delimiter gives a
--   maximally information-preserving splitting strategy, in the sense that
--   (a) taking the <a>concat</a> of the output yields the original list,
--   and (b) given only the output list, we can reconstruct a
--   <a>Splitter</a> which would produce the same output list again given
--   the original input list. This default strategy can be overridden to
--   allow discarding various sorts of information.
defaultSplitter :: Splitter a

-- | Split a list according to the given splitting strategy. This is how to
--   "run" a <a>Splitter</a> that has been built using the other
--   combinators.
split :: Splitter a -> [a] -> [[a]]

-- | A splitting strategy that splits on any one of the given elements.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ",;") "hi;there,world"
--   ["hi",";","there",",","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf "xyz") "aazbxyzcxd"
--   ["aa","z","b","x","","y","","z","c","x","d"]
--   </pre>
oneOf :: Eq a => [a] -> Splitter a

-- | A splitting strategy that splits on the given list, when it is
--   encountered as an exact subsequence.
--   
--   <pre>
--   &gt;&gt;&gt; split (onSublist "xyz") "aazbxyzcxd"
--   ["aazb","xyz","cxd"]
--   </pre>
--   
--   Note that splitting on the empty list is a special case, which splits
--   just before every element of the list being split.
--   
--   <pre>
--   &gt;&gt;&gt; split (onSublist "") "abc"
--   ["","","a","","b","","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims . dropBlanks $ onSublist "") "abc"
--   ["a","b","c"]
--   </pre>
--   
--   However, if you want to break a list into singleton elements like
--   this, you are better off using <tt><a>chunksOf</a> 1</tt>, or better
--   yet, <tt><a>map</a> (:[])</tt>.
onSublist :: Eq a => [a] -> Splitter a

-- | A splitting strategy that splits on any elements that satisfy the
--   given predicate.
--   
--   <pre>
--   &gt;&gt;&gt; split (whenElt (&lt;0)) [2,4,-3,6,-9,1 :: Int]
--   [[2,4],[-3],[6],[-9],[1]]
--   </pre>
whenElt :: (a -> Bool) -> Splitter a

-- | Drop delimiters from the output (the default is to keep them).
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "a:b:c"
--   ["a",":","b",":","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims $ oneOf ":") "a:b:c"
--   ["a","b","c"]
--   </pre>
dropDelims :: Splitter a -> Splitter a

-- | Keep delimiters in the output by prepending them to adjacent chunks.
--   
--   <pre>
--   &gt;&gt;&gt; split (keepDelimsL $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","zb","x","y","zc","xd"]
--   </pre>
keepDelimsL :: Splitter a -> Splitter a

-- | Keep delimiters in the output by appending them to adjacent chunks.
--   
--   <pre>
--   &gt;&gt;&gt; split (keepDelimsR $ oneOf "xyz") "aazbxyzcxd"
--   ["aaz","bx","y","z","cx","d"]
--   </pre>
keepDelimsR :: Splitter a -> Splitter a

-- | Condense multiple consecutive delimiters into one.
--   
--   <pre>
--   &gt;&gt;&gt; split (condense $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","z","b","xyz","c","x","d"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropDelims $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","b","","","c","d"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (condense . dropDelims $ oneOf "xyz") "aazbxyzcxd"
--   ["aa","b","c","d"]
--   </pre>
condense :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the beginning.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") ":a:b"
--   ["",":","a",":","b"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropInitBlank $ oneOf ":") ":a:b"
--   [":","a",":","b"]
--   </pre>
dropInitBlank :: Splitter a -> Splitter a

-- | Don't generate a blank chunk if there is a delimiter at the end.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "a:b:"
--   ["a",":","b",":",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropFinalBlank $ oneOf ":") "a:b:"
--   ["a",":","b",":"]
--   </pre>
dropFinalBlank :: Splitter a -> Splitter a

-- | Don't generate blank chunks between consecutive delimiters.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "::b:::a"
--   ["",":","",":","b",":","",":","",":","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropInnerBlanks $ oneOf ":") "::b:::a"
--   ["",":",":","b",":",":",":","a"]
--   </pre>
dropInnerBlanks :: Splitter a -> Splitter a

-- | Split over a different type of element by performing a preprocessing
--   step.
--   
--   <pre>
--   &gt;&gt;&gt; split (mapSplitter snd $ oneOf "-_") $ zip [0..] "a-bc_d"
--   [[(0,'a')],[(1,'-')],[(2,'b'),(3,'c')],[(4,'_')],[(5,'d')]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char (toLower)
--   
--   &gt;&gt;&gt; split (mapSplitter toLower $ dropDelims $ whenElt (== 'x')) "abXcxd"
--   ["ab","c","d"]
--   </pre>
mapSplitter :: (b -> a) -> Splitter a -> Splitter b

-- | Drop all blank chunks from the output, and condense consecutive
--   delimiters into one. Equivalent to <tt><a>dropInitBlank</a> .
--   <a>dropFinalBlank</a> . <a>condense</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (oneOf ":") "::b:::a"
--   ["",":","",":","b",":","",":","",":","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split (dropBlanks $ oneOf ":") "::b:::a"
--   ["::","b",":::","a"]
--   </pre>
dropBlanks :: Splitter a -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with the
--   given subsequence (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (startsWith "app") "applyapplicativeapplaudapproachapple"
--   ["apply","applicative","applaud","approach","apple"]
--   </pre>
startsWith :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all start with one
--   of the given elements (except possibly the first). Equivalent to
--   <tt><a>dropInitBlank</a> . <a>keepDelimsL</a> . <a>oneOf</a></tt>.
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; split (startsWithOneOf ['A'..'Z']) "ACamelCaseIdentifier"
--   ["A","Camel","Case","Identifier"]
--   </pre>
startsWithOneOf :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all end with the
--   given subsequence, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> .
--   <a>onSublist</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (endsWith "ly") "happilyslowlygnarlylily"
--   ["happily","slowly","gnarly","lily"]
--   </pre>
endsWith :: Eq a => [a] -> Splitter a

-- | Make a strategy that splits a list into chunks that all end with one
--   of the given elements, except possibly the last. Equivalent to
--   <tt><a>dropFinalBlank</a> . <a>keepDelimsR</a> . <a>oneOf</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; split (condense $ endsWithOneOf ".,?! ") "Hi, there!  How are you?"
--   ["Hi, ","there!  ","How ","are ","you?"]
--   </pre>
endsWithOneOf :: Eq a => [a] -> Splitter a
