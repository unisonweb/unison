-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Process libraries
--   
--   This package contains libraries for dealing with system processes.
--   
--   The typed-process package is a more recent take on a process API,
--   which uses this package internally. It features better binary support,
--   easier concurrency, and a more composable API. You can read more about
--   it at <a>https://github.com/fpco/typed-process/#readme</a>.
@package process
@version 1.6.19.0


-- | <b>Note:</b> This module exports internal implementation details that
--   may change anytime. If you want a more stable API, use
--   <a>System.Process</a> instead.
module System.Process.Internals

-- | A handle to a process, which can be used to wait for termination of
--   the process using <a>waitForProcess</a>.
--   
--   None of the process-creation functions in this library wait for
--   termination: they all return a <a>ProcessHandle</a> which may be used
--   to wait for the process later.
--   
--   On Windows a second wait method can be used to block for event
--   completion. This requires two handles. A process job handle and a
--   events handle to monitor.
data ProcessHandle
ProcessHandle :: !MVar ProcessHandle__ -> !Bool -> !MVar () -> ProcessHandle
[phandle] :: ProcessHandle -> !MVar ProcessHandle__
[mb_delegate_ctlc] :: ProcessHandle -> !Bool
[waitpidLock] :: ProcessHandle -> !MVar ()
data ProcessHandle__
OpenHandle :: PHANDLE -> ProcessHandle__

-- | the process
[phdlProcessHandle] :: ProcessHandle__ -> PHANDLE

-- | <a>OpenExtHandle</a> is only applicable for Windows platform. It
--   represents <a>Job Objects</a>.
OpenExtHandle :: PHANDLE -> PHANDLE -> ProcessHandle__

-- | the process
[phdlProcessHandle] :: ProcessHandle__ -> PHANDLE

-- | the job containing the process and its subprocesses
[phdlJobHandle] :: ProcessHandle__ -> PHANDLE
ClosedHandle :: ExitCode -> ProcessHandle__
type PHANDLE = CPid
closePHANDLE :: PHANDLE -> IO ()
mkProcessHandle :: PHANDLE -> Bool -> IO ProcessHandle
data () => CGid
type GroupID = CGid
type UserID = CUid
modifyProcessHandle :: ProcessHandle -> (ProcessHandle__ -> IO (ProcessHandle__, a)) -> IO a
withProcessHandle :: ProcessHandle -> (ProcessHandle__ -> IO a) -> IO a
data CreateProcess
CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe UserID -> Bool -> CreateProcess

-- | Executable &amp; arguments, or shell command. If <a>cwd</a> is
--   <a>Nothing</a>, relative paths are resolved with respect to the
--   current working directory. If <a>cwd</a> is provided, it is
--   implementation-dependent whether relative paths are resolved with
--   respect to <a>cwd</a> or the current working directory, so absolute
--   paths should be used to ensure portability.
[cmdspec] :: CreateProcess -> CmdSpec

-- | Optional path to the working directory for the new process
[cwd] :: CreateProcess -> Maybe FilePath

-- | Optional environment (otherwise inherit from the current process)
[env] :: CreateProcess -> Maybe [(String, String)]

-- | How to determine stdin
[std_in] :: CreateProcess -> StdStream

-- | How to determine stdout
[std_out] :: CreateProcess -> StdStream

-- | How to determine stderr
[std_err] :: CreateProcess -> StdStream

-- | Close all file descriptors except stdin, stdout and stderr in the new
--   process (on Windows, only works if std_in, std_out, and std_err are
--   all Inherit). This implementation will call close on every fd from 3
--   to the maximum of open files, which can be slow for high maximum of
--   open files. XXX verify what happens with fds in nodejs child processes
[close_fds] :: CreateProcess -> Bool

-- | Create a new process group. On JavaScript this also creates a new
--   session.
[create_group] :: CreateProcess -> Bool

-- | Delegate control-C handling. Use this for interactive console
--   processes to let them handle control-C themselves (see below for
--   details).
[delegate_ctlc] :: CreateProcess -> Bool

-- | Use the windows DETACHED_PROCESS flag when creating the process; does
--   nothing on other platforms.
[detach_console] :: CreateProcess -> Bool

-- | Use the windows CREATE_NEW_CONSOLE flag when creating the process;
--   does nothing on other platforms.
--   
--   Default: <tt>False</tt>
[create_new_console] :: CreateProcess -> Bool

-- | Use posix setsid to start the new process in a new session; starts
--   process in a new session on JavaScript; does nothing on other
--   platforms.
[new_session] :: CreateProcess -> Bool

-- | Use posix setgid to set child process's group id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_group] :: CreateProcess -> Maybe GroupID

-- | Use posix setuid to set child process's user id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_user] :: CreateProcess -> Maybe UserID

-- | On Windows systems this flag indicates that we should wait for the
--   entire process tree to finish before unblocking. On POSIX systems this
--   flag is ignored. See $exec-on-windows for details.
--   
--   Default: <tt>False</tt>
[use_process_jobs] :: CreateProcess -> Bool
data CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
--   
--   Windows does not have a mechanism for passing multiple arguments. When
--   using <tt>RawCommand</tt> on Windows, the command line is serialised
--   into a string, with arguments quoted separately. Command line parsing
--   is up individual programs, so the default behaviour may not work for
--   some programs. If you are not getting the desired results, construct
--   the command line yourself and use <a>ShellCommand</a>.
RawCommand :: FilePath -> [String] -> CmdSpec
data StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream

-- | contains the handles returned by a call to createProcess_Internal
data ProcRetHandles
ProcRetHandles :: Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> ProcRetHandles
[hStdInput] :: ProcRetHandles -> Maybe Handle
[hStdOutput] :: ProcRetHandles -> Maybe Handle
[hStdError] :: ProcRetHandles -> Maybe Handle
[procHandle] :: ProcRetHandles -> ProcessHandle

-- | This function is almost identical to <a>createProcess</a>. The only
--   differences are:
--   
--   <ul>
--   <li><a>Handle</a>s provided via <a>UseHandle</a> are not closed
--   automatically.</li>
--   <li>This function takes an extra <tt>String</tt> argument to be used
--   in creating error messages.</li>
--   </ul>
--   
--   This function has been available from the
--   <a>System.Process.Internals</a> module for some time, and is part of
--   the <a>System.Process</a> module since version 1.2.1.0.
createProcess_ :: String -> CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | <i>Deprecated: Please do not use this anymore, use the ordinary
--   <a>createProcess</a>. If you need the SIGINT handling, use
--   delegate_ctlc = True (runGenProcess_ is now just an imperfectly
--   emulated stub that probably duplicates or overrides your own signal
--   handling).</i>
runGenProcess_ :: String -> CreateProcess -> Maybe CLong -> Maybe CLong -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Turn an existing file descriptor into a Handle. This is used by
--   various external libraries to make Handles.
--   
--   Makes a binary Handle. This is for historical reasons; it should
--   probably be a text Handle with the default encoding and newline
--   translation instead.
fdToHandle :: FD -> IO Handle
startDelegateControlC :: IO ()
endDelegateControlC :: ExitCode -> IO ()
stopDelegateControlC :: IO ()
unwrapHandles :: ProcRetHandles -> (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
pPrPr_disableITimers :: IO ()
c_execvpe :: CString -> Ptr CString -> Ptr CString -> IO CInt

-- | <tt>runInteractiveProcess</tt> blocks signals around the fork(). Since
--   blocking/unblocking of signals is a global state operation, we need to
--   ensure mutual exclusion of calls to <tt>runInteractiveProcess</tt>.
--   This lock is exported so that other libraries which also need to
--   fork() (and also need to make the same global state changes) can
--   protect their changes with the same lock. See
--   <a>https://github.com/haskell/process/pull/154</a>.
runInteractiveProcess_lock :: MVar ()
ignoreSignal :: CLong
defaultSignal :: CLong
withFilePathException :: FilePath -> IO a -> IO a
withCEnvironment :: [(String, String)] -> (Ptr CString -> IO a) -> IO a
translate :: String -> String

-- | Create a pipe for interprocess communication and return a
--   <tt>(readEnd, writeEnd)</tt> <a>Handle</a> pair.
--   
--   <ul>
--   <li>WinIO Support</li>
--   </ul>
--   
--   When this function is used with WinIO enabled it's the caller's
--   responsibility to register the handles with the I/O manager. If this
--   is not done the operation will deadlock. Association can be done as
--   follows:
--   
--   <pre>
--   #if defined(<b>IO_MANAGER_WINIO</b>)
--   import GHC.IO.SubSystem ((<a>!</a>))
--   import GHC.IO.Handle.Windows (handleToHANDLE)
--   import GHC.Event.Windows (associateHandle')
--   #endif
--   
--   ...
--   
--   #if defined (<b>IO_MANAGER_WINIO</b>)
--   return () <a>!</a> (do
--     associateHandle' =<a>handleToHANDLE &lt;handle</a>)
--   #endif
--   </pre>
--   
--   Only associate handles that you are in charge of read/writing to. Do
--   not associate handles passed to another process. It's the process's
--   reponsibility to register the handle if it supports async access.
createPipe :: IO (Handle, Handle)

-- | Create a pipe for interprocess communication and return a
--   <tt>(readEnd, writeEnd)</tt> <a>FD</a> pair.
createPipeFd :: IO (FD, FD)

-- | Sends an interrupt signal to the process group of the given process.
--   
--   On Unix systems, it sends the group the SIGINT signal.
--   
--   On Windows systems, it generates a CTRL_BREAK_EVENT and will only work
--   for processes created using <tt>createProcess</tt> and setting the
--   <a>create_group</a> flag
interruptProcessGroupOf :: ProcessHandle -> IO ()


-- | Operations for creating and interacting with sub-processes.
module System.Process

-- | This is the most general way to spawn an external process. The process
--   can be a command line to be executed by a shell or a raw command with
--   a list of arguments. The stdin, stdout, and stderr streams of the new
--   process may individually be attached to new pipes, to existing
--   <a>Handle</a>s, or just inherited from the parent (the default.)
--   
--   The details of how to create the process are passed in the
--   <a>CreateProcess</a> record. To make it easier to construct a
--   <a>CreateProcess</a>, the functions <a>proc</a> and <a>shell</a> are
--   supplied that fill in the fields with default values which can be
--   overriden as needed.
--   
--   <a>createProcess</a> returns <tt>(<i>mb_stdin_hdl</i>,
--   <i>mb_stdout_hdl</i>, <i>mb_stderr_hdl</i>, <i>ph</i>)</tt>, where
--   
--   <ul>
--   <li>if <tt><a>std_in</a> == <a>CreatePipe</a></tt>, then
--   <tt><i>mb_stdin_hdl</i></tt> will be <tt>Just <i>h</i></tt>, where
--   <tt><i>h</i></tt> is the write end of the pipe connected to the child
--   process's <tt>stdin</tt>.</li>
--   <li>otherwise, <tt><i>mb_stdin_hdl</i> == Nothing</tt></li>
--   </ul>
--   
--   Similarly for <tt><i>mb_stdout_hdl</i></tt> and
--   <tt><i>mb_stderr_hdl</i></tt>.
--   
--   For example, to execute a simple <tt>ls</tt> command:
--   
--   <pre>
--   r &lt;- createProcess (proc "ls" [])
--   </pre>
--   
--   To create a pipe from which to read the output of <tt>ls</tt>:
--   
--   <pre>
--   (_, Just hout, _, _) &lt;-
--       createProcess (proc "ls" []){ std_out = CreatePipe }
--   </pre>
--   
--   To also set the directory in which to run <tt>ls</tt>:
--   
--   <pre>
--   (_, Just hout, _, _) &lt;-
--       createProcess (proc "ls" []){ cwd = Just "/home/bob",
--                                     std_out = CreatePipe }
--   </pre>
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt>,
--   <tt>std_out</tt>, or <tt>std_err</tt> via the <tt>UseHandle</tt>
--   constructor will be closed by calling this function. This is not
--   always the desired behavior. In cases where you would like to leave
--   the <tt>Handle</tt> open after spawning the child process, please use
--   <a>createProcess_</a> instead. All created <tt>Handle</tt>s are
--   initially in text mode; if you need them to be in binary mode then use
--   <a>hSetBinaryMode</a>.
--   
--   <tt><i>ph</i></tt> contains a handle to the running process. On
--   Windows <a>use_process_jobs</a> can be set in CreateProcess in order
--   to create a Win32 Job object to monitor a process tree's progress. If
--   it is set then that job is also returned inside <tt><i>ph</i></tt>.
--   <tt><i>ph</i></tt> can be used to kill all running sub-processes. This
--   feature has been available since 1.5.0.0.
createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | This function is almost identical to <a>createProcess</a>. The only
--   differences are:
--   
--   <ul>
--   <li><a>Handle</a>s provided via <a>UseHandle</a> are not closed
--   automatically.</li>
--   <li>This function takes an extra <tt>String</tt> argument to be used
--   in creating error messages.</li>
--   </ul>
--   
--   This function has been available from the
--   <a>System.Process.Internals</a> module for some time, and is part of
--   the <a>System.Process</a> module since version 1.2.1.0.
createProcess_ :: String -> CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a command to be passed to the
--   shell.
shell :: String -> CreateProcess

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a raw command with arguments.
--   
--   See <a>RawCommand</a> for precise semantics of the specified
--   <tt>FilePath</tt>.
proc :: FilePath -> [String] -> CreateProcess
data CreateProcess
CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe UserID -> Bool -> CreateProcess

-- | Executable &amp; arguments, or shell command. If <a>cwd</a> is
--   <a>Nothing</a>, relative paths are resolved with respect to the
--   current working directory. If <a>cwd</a> is provided, it is
--   implementation-dependent whether relative paths are resolved with
--   respect to <a>cwd</a> or the current working directory, so absolute
--   paths should be used to ensure portability.
[cmdspec] :: CreateProcess -> CmdSpec

-- | Optional path to the working directory for the new process
[cwd] :: CreateProcess -> Maybe FilePath

-- | Optional environment (otherwise inherit from the current process)
[env] :: CreateProcess -> Maybe [(String, String)]

-- | How to determine stdin
[std_in] :: CreateProcess -> StdStream

-- | How to determine stdout
[std_out] :: CreateProcess -> StdStream

-- | How to determine stderr
[std_err] :: CreateProcess -> StdStream

-- | Close all file descriptors except stdin, stdout and stderr in the new
--   process (on Windows, only works if std_in, std_out, and std_err are
--   all Inherit). This implementation will call close on every fd from 3
--   to the maximum of open files, which can be slow for high maximum of
--   open files. XXX verify what happens with fds in nodejs child processes
[close_fds] :: CreateProcess -> Bool

-- | Create a new process group. On JavaScript this also creates a new
--   session.
[create_group] :: CreateProcess -> Bool

-- | Delegate control-C handling. Use this for interactive console
--   processes to let them handle control-C themselves (see below for
--   details).
[delegate_ctlc] :: CreateProcess -> Bool

-- | Use the windows DETACHED_PROCESS flag when creating the process; does
--   nothing on other platforms.
[detach_console] :: CreateProcess -> Bool

-- | Use the windows CREATE_NEW_CONSOLE flag when creating the process;
--   does nothing on other platforms.
--   
--   Default: <tt>False</tt>
[create_new_console] :: CreateProcess -> Bool

-- | Use posix setsid to start the new process in a new session; starts
--   process in a new session on JavaScript; does nothing on other
--   platforms.
[new_session] :: CreateProcess -> Bool

-- | Use posix setgid to set child process's group id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_group] :: CreateProcess -> Maybe GroupID

-- | Use posix setuid to set child process's user id; works for JavaScript
--   when system running nodejs is posix. does nothing on other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_user] :: CreateProcess -> Maybe UserID

-- | On Windows systems this flag indicates that we should wait for the
--   entire process tree to finish before unblocking. On POSIX systems this
--   flag is ignored. See $exec-on-windows for details.
--   
--   Default: <tt>False</tt>
[use_process_jobs] :: CreateProcess -> Bool
data CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
--   
--   Windows does not have a mechanism for passing multiple arguments. When
--   using <tt>RawCommand</tt> on Windows, the command line is serialised
--   into a string, with arguments quoted separately. Command line parsing
--   is up individual programs, so the default behaviour may not work for
--   some programs. If you are not getting the desired results, construct
--   the command line yourself and use <a>ShellCommand</a>.
RawCommand :: FilePath -> [String] -> CmdSpec
data StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream

-- | A handle to a process, which can be used to wait for termination of
--   the process using <a>waitForProcess</a>.
--   
--   None of the process-creation functions in this library wait for
--   termination: they all return a <a>ProcessHandle</a> which may be used
--   to wait for the process later.
--   
--   On Windows a second wait method can be used to block for event
--   completion. This requires two handles. A process job handle and a
--   events handle to monitor.
data ProcessHandle

-- | Creates a new process to run the specified command with the given
--   arguments, and wait for it to finish. If the command returns a
--   non-zero exit code, an exception is raised.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>callProcess</tt>, the forked process will be terminated and
--   <tt>callProcess</tt> will wait (block) until the process has been
--   terminated.
callProcess :: FilePath -> [String] -> IO ()

-- | Creates a new process to run the specified shell command. If the
--   command returns a non-zero exit code, an exception is raised.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>callCommand</tt>, the forked process will be terminated and
--   <tt>callCommand</tt> will wait (block) until the process has been
--   terminated.
callCommand :: String -> IO ()

-- | Creates a new process to run the specified raw command with the given
--   arguments. It does not wait for the program to finish, but returns the
--   <a>ProcessHandle</a>.
spawnProcess :: FilePath -> [String] -> IO ProcessHandle

-- | Creates a new process to run the specified shell command. It does not
--   wait for the program to finish, but returns the <a>ProcessHandle</a>.
spawnCommand :: String -> IO ProcessHandle

-- | <tt>readCreateProcess</tt> works exactly like <a>readProcess</a>
--   except that it lets you pass <a>CreateProcess</a> giving better
--   flexibility.
--   
--   <pre>
--   &gt; readCreateProcess ((shell "pwd") { cwd = Just "/etc/" }) ""
--   "/etc\n"
--   </pre>
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt> or
--   <tt>std_out</tt> via the CreateProcess record will be ignored.
readCreateProcess :: CreateProcess -> String -> IO String

-- | <tt>readProcess</tt> forks an external process, reads its standard
--   output strictly, blocking until the process terminates, and returns
--   the output string. The external process inherits the standard error.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>readProcess</tt>, the forked process will be terminated and
--   <tt>readProcess</tt> will wait (block) until the process has been
--   terminated.
--   
--   Output is returned strictly, so this is not suitable for launching
--   processes that require interaction over the standard file streams.
--   
--   This function throws an <a>IOException</a> if the process
--   <a>ExitCode</a> is anything other than <a>ExitSuccess</a>. If instead
--   you want to get the <a>ExitCode</a> then use
--   <a>readProcessWithExitCode</a>.
--   
--   Users of this function should compile with <tt>-threaded</tt> if they
--   want other Haskell threads to keep running while waiting on the result
--   of readProcess.
--   
--   <pre>
--   &gt; readProcess "date" [] []
--   "Thu Feb  7 10:03:39 PST 2008\n"
--   </pre>
--   
--   The arguments are:
--   
--   <ul>
--   <li>The command to run, which must be in the $PATH, or an absolute or
--   relative path</li>
--   <li>A list of separate command line arguments to the program. See
--   <a>RawCommand</a> for further discussion of Windows semantics.</li>
--   <li>A string to pass on standard input to the forked process.</li>
--   </ul>
readProcess :: FilePath -> [String] -> String -> IO String

-- | <tt>readCreateProcessWithExitCode</tt> works exactly like
--   <a>readProcessWithExitCode</a> except that it lets you pass
--   <a>CreateProcess</a> giving better flexibility.
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt>,
--   <tt>std_out</tt>, or <tt>std_err</tt> via the CreateProcess record
--   will be ignored.
readCreateProcessWithExitCode :: CreateProcess -> String -> IO (ExitCode, String, String)

-- | <tt>readProcessWithExitCode</tt> is like <a>readProcess</a> but with
--   two differences:
--   
--   <ul>
--   <li>it returns the <a>ExitCode</a> of the process, and does not throw
--   any exception if the code is not <a>ExitSuccess</a>.</li>
--   <li>it reads and returns the output from process' standard error
--   handle, rather than the process inheriting the standard error
--   handle.</li>
--   </ul>
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal.
readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)

-- | A <a>bracket</a>-style resource handler for <a>createProcess</a>.
--   
--   Does automatic cleanup when the action finishes. If there is an
--   exception in the body then it ensures that the process gets terminated
--   and any <a>CreatePipe</a> <a>Handle</a>s are closed. In particular
--   this means that if the Haskell thread is killed (e.g.
--   <a>killThread</a>), that the external process is also terminated.
--   
--   e.g.
--   
--   <pre>
--   withCreateProcess (proc cmd args) { ... }  $ \stdin stdout stderr ph -&gt; do
--     ...
--   </pre>
withCreateProcess :: CreateProcess -> (Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> IO a) -> IO a

-- | Cleans up the process.
--   
--   This function is meant to be invoked from any application level
--   cleanup handler. It terminates the process, and closes any
--   <a>CreatePipe</a> <tt>handle</tt>s.
cleanupProcess :: (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> IO ()

-- | Given a program <tt><i>p</i></tt> and arguments <tt><i>args</i></tt>,
--   <tt>showCommandForUser <i>p</i> <i>args</i></tt> returns a string
--   suitable for pasting into <tt>/bin/sh</tt> (on Unix systems) or
--   <tt>CMD.EXE</tt> (on Windows).
showCommandForUser :: FilePath -> [String] -> String

-- | The platform specific type for a process identifier.
--   
--   This is always an integral type. Width and signedness are platform
--   specific.
type Pid = CPid

-- | Returns the PID (process ID) of a subprocess.
--   
--   <a>Nothing</a> is returned if the handle was already closed. Otherwise
--   a PID is returned that remains valid as long as the handle is open.
--   The operating system may reuse the PID as soon as the last handle to
--   the process is closed.
getPid :: ProcessHandle -> IO (Maybe Pid)

-- | Returns the PID (process ID) of the current process. On POSIX systems,
--   this calls <a>getProcessID</a> from <a>System.Posix.Process</a> in the
--   <tt>unix</tt> package. On Windows, this calls
--   <tt>getCurrentProcessId</tt> from <a>System.Win32.Process</a> in the
--   <tt>Win32</tt> package.
getCurrentPid :: IO Pid

-- | Waits for the specified process to terminate, and returns its exit
--   code. On Unix systems, may throw <tt>UserInterrupt</tt> when using
--   <a>delegate_ctlc</a>.
--   
--   GHC Note: in order to call <tt>waitForProcess</tt> without blocking
--   all the other threads in the system, you must compile the program with
--   <tt>-threaded</tt>.
--   
--   Note that it is safe to call <tt>waitForProcess</tt> for the same
--   process in multiple threads. When the process ends, threads blocking
--   on this call will wake in FIFO order. When using <a>delegate_ctlc</a>
--   and the process is interrupted, only the first waiting thread will
--   throw <tt>UserInterrupt</tt>.
--   
--   (<i>Since: 1.2.0.0</i>) On Unix systems, a negative value
--   <tt><a>ExitFailure</a> -<i>signum</i></tt> indicates that the child
--   was terminated by signal <tt><i>signum</i></tt>. The signal numbers
--   are platform-specific, so to test for a specific signal use the
--   constants provided by <a>System.Posix.Signals</a> in the <tt>unix</tt>
--   package. Note: core dumps are not reported, use
--   <a>System.Posix.Process</a> if you need this detail.
waitForProcess :: ProcessHandle -> IO ExitCode

-- | This is a non-blocking version of <a>waitForProcess</a>. If the
--   process is still running, <a>Nothing</a> is returned. If the process
--   has exited, then <tt><a>Just</a> e</tt> is returned where <tt>e</tt>
--   is the exit code of the process.
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal. May throw
--   <tt>UserInterrupt</tt> when using <a>delegate_ctlc</a>.
getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)

-- | Attempts to terminate the specified process. This function should not
--   be used under normal circumstances - no guarantees are given regarding
--   how cleanly the process is terminated. To check whether the process
--   has indeed terminated, use <a>getProcessExitCode</a>.
--   
--   On Unix systems, <a>terminateProcess</a> sends the process the SIGTERM
--   signal. On Windows systems, if <a>use_process_jobs</a> is <a>True</a>
--   then the Win32 <tt>TerminateJobObject</tt> function is called to kill
--   all processes associated with the job and passing the exit code of 1
--   to each of them. Otherwise if <a>use_process_jobs</a> is <a>False</a>
--   then the Win32 <tt>TerminateProcess</tt> function is called, passing
--   an exit code of 1.
--   
--   Note: on Windows, if the process was a shell command created by
--   <a>createProcess</a> with <a>shell</a>, or created by
--   <a>runCommand</a> or <a>runInteractiveCommand</a>, then
--   <a>terminateProcess</a> will only terminate the shell, not the command
--   itself. On Unix systems, both processes are in a process group and
--   will be terminated together.
terminateProcess :: ProcessHandle -> IO ()

-- | Sends an interrupt signal to the process group of the given process.
--   
--   On Unix systems, it sends the group the SIGINT signal.
--   
--   On Windows systems, it generates a CTRL_BREAK_EVENT and will only work
--   for processes created using <tt>createProcess</tt> and setting the
--   <a>create_group</a> flag
interruptProcessGroupOf :: ProcessHandle -> IO ()

-- | Create a pipe for interprocess communication and return a
--   <tt>(readEnd, writeEnd)</tt> <a>Handle</a> pair.
--   
--   <ul>
--   <li>WinIO Support</li>
--   </ul>
--   
--   When this function is used with WinIO enabled it's the caller's
--   responsibility to register the handles with the I/O manager. If this
--   is not done the operation will deadlock. Association can be done as
--   follows:
--   
--   <pre>
--   #if defined(<b>IO_MANAGER_WINIO</b>)
--   import GHC.IO.SubSystem ((<a>!</a>))
--   import GHC.IO.Handle.Windows (handleToHANDLE)
--   import GHC.Event.Windows (associateHandle')
--   #endif
--   
--   ...
--   
--   #if defined (<b>IO_MANAGER_WINIO</b>)
--   return () <a>!</a> (do
--     associateHandle' =<a>handleToHANDLE &lt;handle</a>)
--   #endif
--   </pre>
--   
--   Only associate handles that you are in charge of read/writing to. Do
--   not associate handles passed to another process. It's the process's
--   reponsibility to register the handle if it supports async access.
createPipe :: IO (Handle, Handle)

-- | Create a pipe for interprocess communication and return a
--   <tt>(readEnd, writeEnd)</tt> <a>FD</a> pair.
createPipeFd :: IO (FD, FD)

-- | Runs a raw command, optionally specifying <a>Handle</a>s from which to
--   take the <tt>stdin</tt>, <tt>stdout</tt> and <tt>stderr</tt> channels
--   for the new process (otherwise these handles are inherited from the
--   current process).
--   
--   Any <a>Handle</a>s passed to <a>runProcess</a> are placed immediately
--   in the closed state.
--   
--   Note: consider using the more general <a>createProcess</a> instead of
--   <a>runProcess</a>.
runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle

-- | Runs a command using the shell.
runCommand :: String -> IO ProcessHandle

-- | Runs a raw command, and returns <a>Handle</a>s that may be used to
--   communicate with the process via its <tt>stdin</tt>, <tt>stdout</tt>
--   and <tt>stderr</tt> respectively.
--   
--   For example, to start a process and feed a string to its stdin:
--   
--   <pre>
--   (inp,out,err,pid) &lt;- runInteractiveProcess "..."
--   forkIO (hPutStr inp str)
--   </pre>
runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)

-- | Runs a command using the shell, and returns <a>Handle</a>s that may be
--   used to communicate with the process via its <tt>stdin</tt>,
--   <tt>stdout</tt>, and <tt>stderr</tt> respectively.
runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)

-- | Computation <tt>system cmd</tt> returns the exit code produced when
--   the operating system runs the shell command <tt>cmd</tt>.
--   
--   This computation may fail with one of the following <a>IOErrorType</a>
--   exceptions:
--   
--   <ul>
--   <li><i><tt>PermissionDenied</tt></i> The process has insufficient
--   privileges to perform the operation.</li>
--   <li><i><tt>ResourceExhausted</tt></i> Insufficient resources are
--   available to perform the operation.</li>
--   <li><i><tt>UnsupportedOperation</tt></i> The implementation does not
--   support system calls.</li>
--   </ul>
--   
--   On Windows, <a>system</a> passes the command to the Windows command
--   interpreter (<tt>CMD.EXE</tt> or <tt>COMMAND.COM</tt>), hence Unixy
--   shell tricks will not work.
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal.
system :: String -> IO ExitCode

-- | The computation <tt><a>rawSystem</a> <i>cmd</i> <i>args</i></tt> runs
--   the operating system command <tt><i>cmd</i></tt> in such a way that it
--   receives as arguments the <tt><i>args</i></tt> strings exactly as
--   given, with no funny escaping or shell meta-syntax expansion. It will
--   therefore behave more portably between operating systems than
--   <a>system</a>.
--   
--   The return codes and possible failures are the same as for
--   <a>system</a>.
rawSystem :: String -> [String] -> IO ExitCode


-- | Executing an external command.
--   
--   This module provides a simple interface for executing external
--   commands. For a more complex, but more powerful, interface, see the
--   <a>System.Process</a> module.

-- | <i>Deprecated: Use <a>System.Process</a> instead</i>
module System.Cmd

-- | Computation <tt>system cmd</tt> returns the exit code produced when
--   the operating system runs the shell command <tt>cmd</tt>.
--   
--   This computation may fail with one of the following <a>IOErrorType</a>
--   exceptions:
--   
--   <ul>
--   <li><i><tt>PermissionDenied</tt></i> The process has insufficient
--   privileges to perform the operation.</li>
--   <li><i><tt>ResourceExhausted</tt></i> Insufficient resources are
--   available to perform the operation.</li>
--   <li><i><tt>UnsupportedOperation</tt></i> The implementation does not
--   support system calls.</li>
--   </ul>
--   
--   On Windows, <a>system</a> passes the command to the Windows command
--   interpreter (<tt>CMD.EXE</tt> or <tt>COMMAND.COM</tt>), hence Unixy
--   shell tricks will not work.
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal.
system :: String -> IO ExitCode

-- | The computation <tt><a>rawSystem</a> <i>cmd</i> <i>args</i></tt> runs
--   the operating system command <tt><i>cmd</i></tt> in such a way that it
--   receives as arguments the <tt><i>args</i></tt> strings exactly as
--   given, with no funny escaping or shell meta-syntax expansion. It will
--   therefore behave more portably between operating systems than
--   <a>system</a>.
--   
--   The return codes and possible failures are the same as for
--   <a>system</a>.
rawSystem :: String -> [String] -> IO ExitCode
