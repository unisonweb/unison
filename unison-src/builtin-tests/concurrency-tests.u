concurrency.tests = Tests.main do
  !simpleRefTest
  !simpleRefTestScope
  !ticketTest
  !casTest
  --  !threadTest
  --  !promiseSequentialTest
  --  !promiseConcurrentTest
  --  !fullTest

simpleRefTest = do
  r = IO.ref 0
  Ref.write r 1
  i = Ref.read r
  Ref.write r 2
  j = Ref.read r
  Ref.write r 5
  checkEqual "Ref read-write"  (i, j, Ref.read r) (1, 2, 5)

simpleRefTestScope = do
  Scope.run do
    r = Scope.ref 0
    Ref.write r 1
    i = Ref.read r
    Ref.write r 2
    j = Ref.read r
    Ref.write r 5
    checkEqual "Ref read-write"  (i, j, Ref.read r) (1, 2, 5)

ticketTest = do
 r = IO.ref 3
 t = Ref.readForCas r
 v = Ticket.read t
 checkEqual "Ticket contains the Ref value" v 3

casTest = do
   ref = IO.ref 0
   ticket = Ref.readForCas ref
   v1 = Ref.cas ref ticket 5
   check "CAS is successful is there were no conflicting writes" 'v1
   Ref.write ref 10
   v2 = Ref.cas ref ticket 15
   check "CAS fails when there was an intervening write" '(not v2)

-- TODO test both Left and Right on the catchAll
-- and try access the failure as well
threadTest = do
  ref = IO.ref None
  millis = 1000
  thread = do
    match catchAll do sleep (500 * millis) with
      Left _ -> Ref.write ref (Some "interrupted")
      Right _ -> Ref.write ref (Some "completed")
  t = fork thread
  sleep (200 * millis)
  kill t
  r = while (Optional.isNone) do Ref.read ref
  checkEqual "Thread has been interrupted" r (Some "interrupted")


promiseSequentialTest = do
  use Nat eq
  use Promise read write
  p = !Promise.new
  ignore (write p 0)
  v1 = read p
  checkEqual "Promise should read a value that's been written" v1 0
  ignore(write p 1)
  v2 = read p
  checkEqual "Promise can only be written to once" v2 0

promiseConcurrentTest = do
  use Nat eq
  use concurrent fork
  p = !Promise.new
  _ = fork '(Promise.write p 5)
  v = Promise.read p
  checkEqual "Reads awaits for completion of the Promise" v 5

atomicUpdate : Ref {IO} a -> (a -> a) ->{IO} ()
atomicUpdate ref f =
  ticket = Ref.readForCas ref
  value = f (Ticket.read ticket)
  if Ref.cas ref ticket value then () else atomicUpdate ref f

spawnN : Nat -> '{IO} a ->{IO} [a]
spawnN n fa =
  use Nat eq -
  use concurrent fork
  
  go i acc =
    if eq i 0
    then acc
    else
      value = !Promise.new
      _ = fork do Promise.write value !fa
      go (i - 1) (acc :+ value)

  map Promise.read (go n [])

fullTest = do
  use Nat * + eq -
  
  numThreads = 100
  iterations = 100
  expected = numThreads * iterations

  state = IO.ref 0
  thread n =
    if eq n 0
    then ()
    else 
      atomicUpdate state (v -> v + 1)
      thread (n - 1)
  ignore (spawnN numThreads '(thread iterations))
  result = Ref.read state
  checkEqual "The state of the counter is consistent " result expected

