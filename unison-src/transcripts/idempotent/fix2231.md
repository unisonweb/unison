This transcript contains some cases that were problematic with the new
type checker. They were likely not discovered earlier because they
involve combining types inferred with the older strategy with the new
inference algorithm. Some code can be given multiple possible types,
and while they are all valid and some may be equivalently general,
the choices may not work equally well with the type checking
strategies.

``` ucm :hide
scratch/main> builtins.merge
```

``` unison
(<<) : (b ->{e} c) -> (a ->{e} b) -> a ->{e} c
(<<) f g x = f (g x)

f = atan << tan

foldl : (b ->{e} a ->{e} b) -> b -> [a] ->{e} b
foldl f a = cases
  [] -> a
  x +: xs -> foldl f (f a x) xs

txt = foldl (Text.++) "" ["a", "b", "c"]
```

``` ucm :added-by-ucm

  Loading changes detected in scratch.u.

  I found and typechecked these definitions in scratch.u. If you
  do an `add` or `update`, here's how your codebase would
  change:

    ⍟ These new definitions are ok to `add`:
    
      <<    : (b ->{e} c) -> (a ->{e} b) -> a ->{e} c
      f     : Float -> Float
      foldl : (b ->{e} a ->{e} b) -> b -> [a] ->{e} b
      txt   : Text
```

``` ucm
scratch/main> add

  ⍟ I've added these definitions:

    <<    : (b ->{e} c) -> (a ->{e} b) -> a ->{e} c
    f     : Float -> Float
    foldl : (b ->{e} a ->{e} b) -> b -> [a] ->{e} b
    txt   : Text
```
