``` ucm :hide
scratch/main> builtins.merge
```

Tests cases that produced bad decompilation output previously. There
are three cases that need to be 'fixed up.'

1.  lambda expressions with free variables need to be beta reduced
2.  let defined functions need to have arguments removed and
    occurrences rewritten.
3.  let-rec defined functions need to have arguments removed, but
    it is a more complicated process.

``` unison
> Any (w x -> let
    f0 y = match y with
       0 -> x
       n -> 1 + f1 (drop y 1)
    f1 y = match y with
       0 -> w + x
       n -> 1 + f0 (drop y 1)
    f2 x = f2 x
    f3 y = 1 + y + f2 x
    g h = h 1 + x
    g (z -> x + f0 z))
```

``` ucm :added-by-ucm

  Loading changes detected in scratch.u.

  ✅

  scratch.u changed.

  Now evaluating any watch expressions (lines starting with
  `>`)... Ctrl+C cancels.

    1 | > Any (w x -> let
          ⧩
          Any
            (w x ->
              let
                use Nat + drop
                f1 y = match y with
                  0 -> w + x
                  n -> 1 + f0 (drop y 1)
                f0 y = match y with
                  0 -> x
                  n -> 1 + f1 (drop y 1)
                f2 x = f2 x
                f3 x y = 1 + y + f2 x
                g h = h 1 + x
                g (z -> x + f0 z))
```

Also check for some possible corner cases.

`f` should not have its `x` argument eliminated, because it doesn't
always occur with `x` as the first argument, but if we aren't careful,
we might do that, because we find the first occurrence of `f`, and
discard its arguments, where `f` also occurs.

``` unison
> Any (x -> let
    f x y = match y with
      0 -> 0
      _ -> f x (f y (drop y 1))

    f x 20)
```

``` ucm :added-by-ucm

  Loading changes detected in scratch.u.

  ✅

  scratch.u changed.

  Now evaluating any watch expressions (lines starting with
  `>`)... Ctrl+C cancels.

    1 | > Any (x -> let
          ⧩
          Any
            (x ->
              let
                f x y = match y with
                  0 -> 0
                  _ -> f x (f y (Nat.drop y 1))
                f x 20)
```
