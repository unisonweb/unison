-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Associative containers retaining insertion order for traversals.
--   
--   Associative containers retaining insertion order for traversals.
--   
--   The implementation is based on `unordered-containers`.
@package insert-ordered-containers
@version 0.2.5.3


-- | <a>InsOrdHashMap</a> is like <a>HashMap</a>, but it folds and
--   traverses in insertion order.
--   
--   This module interface mimics <a>Data.HashMap.Strict</a>, with some
--   additions.
module Data.HashMap.Strict.InsOrd

-- | <a>HashMap</a> which tries its best to remember insertion order of
--   elements.
data InsOrdHashMap k v
empty :: InsOrdHashMap k v
singleton :: Hashable k => k -> v -> InsOrdHashMap k v
null :: InsOrdHashMap k v -> Bool
size :: InsOrdHashMap k v -> Int
member :: (Eq k, Hashable k) => k -> InsOrdHashMap k a -> Bool
lookup :: (Eq k, Hashable k) => k -> InsOrdHashMap k v -> Maybe v
lookupDefault :: (Eq k, Hashable k) => v -> k -> InsOrdHashMap k v -> v
insert :: (Eq k, Hashable k) => k -> v -> InsOrdHashMap k v -> InsOrdHashMap k v
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> k -> v -> InsOrdHashMap k v -> InsOrdHashMap k v
delete :: (Eq k, Hashable k) => k -> InsOrdHashMap k v -> InsOrdHashMap k v
adjust :: (Eq k, Hashable k) => (v -> v) -> k -> InsOrdHashMap k v -> InsOrdHashMap k v
update :: (Eq k, Hashable k) => (a -> Maybe a) -> k -> InsOrdHashMap k a -> InsOrdHashMap k a
alter :: (Eq k, Hashable k) => (Maybe v -> Maybe v) -> k -> InsOrdHashMap k v -> InsOrdHashMap k v
union :: (Eq k, Hashable k) => InsOrdHashMap k v -> InsOrdHashMap k v -> InsOrdHashMap k v

-- | The union of two maps. If a key occurs in both maps, the provided
--   function (first argument) will be used to compute the result.
--   
--   Ordered traversal will go thru keys in the first map first.
unionWith :: (Eq k, Hashable k) => (v -> v -> v) -> InsOrdHashMap k v -> InsOrdHashMap k v -> InsOrdHashMap k v
unionWithKey :: (Eq k, Hashable k) => (k -> v -> v -> v) -> InsOrdHashMap k v -> InsOrdHashMap k v -> InsOrdHashMap k v
unions :: (Eq k, Hashable k, Foldable f) => f (InsOrdHashMap k v) -> InsOrdHashMap k v
map :: (v1 -> v2) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2

-- | Order preserving mapping of keys.
mapKeys :: (Eq k', Hashable k') => (k -> k') -> InsOrdHashMap k v -> InsOrdHashMap k' v
traverseKeys :: (Eq k', Hashable k', Applicative f) => (k -> f k') -> InsOrdHashMap k v -> f (InsOrdHashMap k' v)
mapWithKey :: (k -> v1 -> v2) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2
traverseWithKey :: Applicative f => (k -> a -> f b) -> InsOrdHashMap k a -> f (InsOrdHashMap k b)

-- | More efficient than <a>traverse</a>, when traversing in insertion
--   order is not important.
unorderedTraverse :: Applicative f => (a -> f b) -> InsOrdHashMap k a -> f (InsOrdHashMap k b)

-- | More efficient than <a>traverseWithKey</a>, when traversing in
--   insertion order is not important.
unorderedTraverseWithKey :: Applicative f => (k -> a -> f b) -> InsOrdHashMap k a -> f (InsOrdHashMap k b)
difference :: (Eq k, Hashable k) => InsOrdHashMap k v -> InsOrdHashMap k w -> InsOrdHashMap k v
intersection :: (Eq k, Hashable k) => InsOrdHashMap k v -> InsOrdHashMap k w -> InsOrdHashMap k v
intersectionWith :: (Eq k, Hashable k) => (v1 -> v2 -> v3) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2 -> InsOrdHashMap k v3
intersectionWithKey :: (Eq k, Hashable k) => (k -> v1 -> v2 -> v3) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2 -> InsOrdHashMap k v3
foldl' :: (a -> v -> a) -> a -> InsOrdHashMap k v -> a
foldlWithKey' :: (a -> k -> v -> a) -> a -> InsOrdHashMap k v -> a
foldr :: (v -> a -> a) -> a -> InsOrdHashMap k v -> a
foldrWithKey :: (k -> v -> a -> a) -> a -> InsOrdHashMap k v -> a
foldMapWithKey :: Monoid m => (k -> a -> m) -> InsOrdHashMap k a -> m

-- | More efficient than <a>foldMap</a>, when folding in insertion order is
--   not important.
unorderedFoldMap :: Monoid m => (a -> m) -> InsOrdHashMap k a -> m

-- | More efficient than <a>foldMapWithKey</a>, when folding in insertion
--   order is not important.
unorderedFoldMapWithKey :: Monoid m => (k -> a -> m) -> InsOrdHashMap k a -> m
filter :: (v -> Bool) -> InsOrdHashMap k v -> InsOrdHashMap k v
filterWithKey :: (k -> v -> Bool) -> InsOrdHashMap k v -> InsOrdHashMap k v
mapMaybe :: (v1 -> Maybe v2) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2
mapMaybeWithKey :: (k -> v1 -> Maybe v2) -> InsOrdHashMap k v1 -> InsOrdHashMap k v2
keys :: InsOrdHashMap k v -> [k]
elems :: InsOrdHashMap k v -> [v]
toList :: InsOrdHashMap k v -> [(k, v)]
toRevList :: InsOrdHashMap k v -> [(k, v)]
fromList :: forall k v. (Eq k, Hashable k) => [(k, v)] -> InsOrdHashMap k v
toHashMap :: InsOrdHashMap k v -> HashMap k v
fromHashMap :: HashMap k v -> InsOrdHashMap k v

-- | This is a slight lie, as roundtrip doesn't preserve ordering.
hashMap :: Iso (InsOrdHashMap k a) (InsOrdHashMap k b) (HashMap k a) (HashMap k b)
unorderedTraversal :: Traversal (InsOrdHashMap k a) (InsOrdHashMap k b) a b

-- | Test if the internal map structure is valid.
valid :: InsOrdHashMap k v -> Bool
instance Data.Data.Data a => Data.Data.Data (Data.HashMap.Strict.InsOrd.P a)
instance Data.Traversable.Traversable Data.HashMap.Strict.InsOrd.P
instance Data.Foldable.Foldable Data.HashMap.Strict.InsOrd.P
instance GHC.Base.Functor Data.HashMap.Strict.InsOrd.P
instance (Data.Data.Data k, Data.Data.Data v, Data.Hashable.Class.Hashable k) => Data.Data.Data (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance GHC.Base.Functor (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance Control.DeepSeq.NFData k => Control.DeepSeq.NFData1 (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance Control.DeepSeq.NFData2 Data.HashMap.Strict.InsOrd.InsOrdHashMap
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Read.Read k, GHC.Read.Read v) => GHC.Read.Read (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.Base.Semigroup (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.Base.Monoid (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance Data.Foldable.Foldable (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance Data.Traversable.Traversable (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Functor.Bind.Class.Apply (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Functor.Bind.Class.Bind (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.IsList.IsList (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance Data.Aeson.Types.ToJSON.ToJSONKey k => Data.Aeson.Types.ToJSON.ToJSON1 (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (Data.Aeson.Types.ToJSON.ToJSONKey k, Data.Aeson.Types.ToJSON.ToJSON v) => Data.Aeson.Types.ToJSON.ToJSON (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Data.Aeson.Types.FromJSON.FromJSONKey k) => Data.Aeson.Types.FromJSON.FromJSON1 (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Data.Aeson.Types.FromJSON.FromJSONKey k, Data.Aeson.Types.FromJSON.FromJSON v) => Data.Aeson.Types.FromJSON.FromJSON (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.FunctorWithIndex k (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.FoldableWithIndex k (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => WithIndex.TraversableWithIndex k (Data.HashMap.Strict.InsOrd.InsOrdHashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.Ixed (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.At (Data.HashMap.Strict.InsOrd.InsOrdHashMap k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.Ixed (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.At (Data.HashMap.Strict.InsOrd.InsOrdHashMap k a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.HashMap.Strict.InsOrd.P a)
instance Control.DeepSeq.NFData1 Data.HashMap.Strict.InsOrd.P
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.HashMap.Strict.InsOrd.P a)
instance GHC.Show.Show a => GHC.Show.Show (Data.HashMap.Strict.InsOrd.P a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.HashMap.Strict.InsOrd.P a)


-- | <a>InsOrdHashSet</a> is like <a>HashSet</a>, but it folds in insertion
--   order.
--   
--   This module interface mimics <a>Data.HashSet</a>, with some additions.
module Data.HashSet.InsOrd

-- | <a>HashSet</a> which tries its best to remember insertion order of
--   elements.
data InsOrdHashSet k
empty :: InsOrdHashSet k
singleton :: Hashable k => k -> InsOrdHashSet k
null :: InsOrdHashSet k -> Bool
size :: InsOrdHashSet k -> Int
member :: (Eq k, Hashable k) => k -> InsOrdHashSet k -> Bool
insert :: (Eq k, Hashable k) => k -> InsOrdHashSet k -> InsOrdHashSet k
delete :: (Eq k, Hashable k) => k -> InsOrdHashSet k -> InsOrdHashSet k
union :: (Eq k, Hashable k) => InsOrdHashSet k -> InsOrdHashSet k -> InsOrdHashSet k
map :: (Hashable b, Eq b) => (a -> b) -> InsOrdHashSet a -> InsOrdHashSet b
difference :: (Eq a, Hashable a) => InsOrdHashSet a -> InsOrdHashSet a -> InsOrdHashSet a
intersection :: (Eq a, Hashable a) => InsOrdHashSet a -> InsOrdHashSet a -> InsOrdHashSet a
filter :: (a -> Bool) -> InsOrdHashSet a -> InsOrdHashSet a
toList :: InsOrdHashSet k -> [k]
fromList :: (Eq k, Hashable k) => [k] -> InsOrdHashSet k
toHashSet :: InsOrdHashSet k -> HashSet k
fromHashSet :: HashSet k -> InsOrdHashSet k

-- | This is a slight lie, as roundtrip doesn't preserve ordering.
hashSet :: Iso' (InsOrdHashSet a) (HashSet a)

-- | Test if the internal map structure is valid.
valid :: InsOrdHashSet a -> Bool
instance (Data.Data.Data k, Data.Hashable.Class.Hashable k) => Data.Data.Data (Data.HashSet.InsOrd.InsOrdHashSet k)
instance Control.DeepSeq.NFData k => Control.DeepSeq.NFData (Data.HashSet.InsOrd.InsOrdHashSet k)
instance Control.DeepSeq.NFData1 Data.HashSet.InsOrd.InsOrdHashSet
instance GHC.Classes.Eq k => GHC.Classes.Eq (Data.HashSet.InsOrd.InsOrdHashSet k)
instance GHC.Show.Show k => GHC.Show.Show (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Read.Read k) => GHC.Read.Read (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.Base.Semigroup (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.Base.Monoid (Data.HashSet.InsOrd.InsOrdHashSet k)
instance Data.Foldable.Foldable Data.HashSet.InsOrd.InsOrdHashSet
instance Data.Hashable.Class.Hashable k => Data.Hashable.Class.Hashable (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.IsList.IsList (Data.HashSet.InsOrd.InsOrdHashSet k)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Data.HashSet.InsOrd.InsOrdHashSet a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.HashSet.InsOrd.InsOrdHashSet a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.Ixed (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.At (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Control.Lens.At.Contains (Data.HashSet.InsOrd.InsOrdHashSet a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.Ixed (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Optics.At.Core.At (Data.HashSet.InsOrd.InsOrdHashSet k)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Optics.At.Core.Contains (Data.HashSet.InsOrd.InsOrdHashSet a)
