-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids: Category sans id
--   
--   Provides a wide array of (semi)groupoids and operations for working
--   with them.
--   
--   A <a>Semigroupoid</a> is a <a>Category</a> without the requirement of
--   identity arrows for every object in the category.
--   
--   A <a>Category</a> is any <a>Semigroupoid</a> for which the Yoneda
--   lemma holds.
--   
--   When working with comonads you often have the <tt>&lt;*&gt;</tt>
--   portion of an <tt>Applicative</tt>, but not the <tt>pure</tt>. This
--   was captured in Uustalu and Vene's "Essence of Dataflow Programming"
--   in the form of the <tt>ComonadZip</tt> class in the days before
--   <tt>Applicative</tt>. Apply provides a weaker invariant, but for the
--   comonads used for data flow programming (found in the streams
--   package), this invariant is preserved. Applicative function
--   composition forms a semigroupoid.
--   
--   Similarly many structures are nearly a comonad, but not quite, for
--   instance lists provide a reasonable <a>extend</a> operation in the
--   form of <a>tails</a>, but do not always contain a value.
--   
--   We describe the relationships between the type classes defined in this
--   package and those from <a>base</a> (and some from
--   <a>contravariant</a>) in the diagram below. Thick-bordered nodes
--   correspond to type classes defined in this package; thin-bordered ones
--   correspond to type classes from elsewhere. Solid edges indicate a
--   subclass relationship that actually exists; dashed edges indicate a
--   subclass relationship that <i>should</i> exist, but currently doesn't.
--   
--   
--   Apply, Bind, and Extend (not shown) give rise the Static, Kleisli and
--   Cokleisli semigroupoids respectively.
--   
--   This lets us remove many of the restrictions from various monad
--   transformers as in many cases the binding operation or
--   <tt>&lt;*&gt;</tt> operation does not require them.
--   
--   Finally, to work with these weaker structures it is beneficial to have
--   containers that can provide stronger guarantees about their contents,
--   so versions of <a>Traversable</a> and <a>Foldable</a> that can be
--   folded with just a <a>Semigroup</a> are added.
@package semigroupoids
@version 6.0.1


module Data.Functor.Extend
class Functor w => Extend w

-- | <pre>
--   duplicated = extended id
--   fmap (fmap f) . duplicated = duplicated . fmap f
--   </pre>
duplicated :: Extend w => w a -> w (w a)

-- | <pre>
--   extended f  = fmap f . duplicated
--   </pre>
extended :: Extend w => (w a -> b) -> w a -> w b

-- | Generic <a>duplicated</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>w</tt> is a product type.</li>
--   <li>Will not compile if <tt>w</tt> contains fields where the type
--   variable appears underneath the composition of type constructors
--   (e.g., <tt>f (g a)</tt>).</li>
--   </ol>
gduplicated :: (Extend (Rep1 w), Generic1 w) => w a -> w (w a)

-- | Generic <a>extended</a>. Caveats are the same as for
--   <a>gduplicated</a>.
gextended :: (Extend (Rep1 w), Generic1 w) => (w a -> b) -> w a -> w b
instance Data.Functor.Extend.Extend []
instance Data.Functor.Extend.Extend (Data.Tagged.Tagged a)
instance Data.Functor.Extend.Extend Data.Proxy.Proxy
instance Data.Functor.Extend.Extend GHC.Maybe.Maybe
instance Data.Functor.Extend.Extend (Data.Either.Either a)
instance Data.Functor.Extend.Extend ((,) e)
instance GHC.Base.Semigroup m => Data.Functor.Extend.Extend ((->) m)
instance Data.Functor.Extend.Extend Data.Sequence.Internal.Seq
instance Data.Functor.Extend.Extend Data.Tree.Tree
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Env.EnvT e w)
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Comonad.Trans.Store.StoreT s w)
instance (Data.Functor.Extend.Extend w, GHC.Base.Semigroup m) => Data.Functor.Extend.Extend (Control.Comonad.Trans.Traced.TracedT m w)
instance Data.Functor.Extend.Extend Data.Functor.Identity.Identity
instance Data.Functor.Extend.Extend w => Data.Functor.Extend.Extend (Control.Monad.Trans.Identity.IdentityT w)
instance Data.Functor.Extend.Extend GHC.Base.NonEmpty
instance (Data.Functor.Extend.Extend f, Data.Functor.Extend.Extend g) => Data.Functor.Extend.Extend (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Extend.Extend f, Data.Functor.Extend.Extend g) => Data.Functor.Extend.Extend (f GHC.Generics.:+: g)
instance Data.Functor.Extend.Extend (GHC.Generics.K1 i c)
instance Data.Functor.Extend.Extend GHC.Generics.U1
instance Data.Functor.Extend.Extend GHC.Generics.V1
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (GHC.Generics.M1 i t f)
instance Data.Functor.Extend.Extend GHC.Generics.Par1
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (GHC.Generics.Rec1 f)
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Sum
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Product
instance Data.Functor.Extend.Extend Data.Semigroup.Internal.Dual
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Extend.Extend Data.Semigroup.First
instance Data.Functor.Extend.Extend Data.Semigroup.Last
instance Data.Functor.Extend.Extend Data.Semigroup.Min
instance Data.Functor.Extend.Extend Data.Semigroup.Max



-- | <i>Deprecated: This module re-exports a limited subset of the class
--   methods in the Foldable1 and Bifoldable1 classes, which are now
--   located in the Data.Foldable1 and Data.Bifoldable1 modules in
--   base-4.18. (On older versions of base, these can be found in the
--   foldable1-classes-compat library.) Import from these modules
--   instead.</i>
module Data.Semigroup.Foldable.Class

-- | Non-empty data structures that can be folded.
class Foldable t => Foldable1 (t :: Type -> Type)

-- | Combine the elements of a structure using a semigroup. @since 4.18.0.0
fold1 :: (Foldable1 t, Semigroup m) => t m -> m

-- | Map each element of the structure to a semigroup, and combine the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1 Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | List of elements of a structure, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (Identity 2)
--   2 :| []
--   </pre>
toNonEmpty :: Foldable1 t => t a -> NonEmpty a
class Bifoldable t => Bifoldable1 (t :: Type -> Type -> Type)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m


-- | Re-exports from the `base-orphans` and `transformers-compat` packages.
module Data.Traversable.Instances


-- | This module is used to resolve the cyclic we get from defining these
--   classes here rather than in a package upstream. Otherwise we'd get
--   orphaned heads for many instances on the types in
--   <tt>transformers</tt> and <tt>bifunctors</tt>.
module Data.Functor.Bind.Class

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 .>
infixl 4 <.

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform an Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | Apply a non-empty container of functions to a possibly-empty-with-unit
--   container of values.
(<.*>) :: Apply f => f (a -> b) -> MaybeApply f a -> f b
infixl 4 <.*>

-- | Apply a possibly-empty-with-unit container of functions to a non-empty
--   container of values.
(<*.>) :: Apply f => MaybeApply f (a -> b) -> f a -> f b
infixl 4 <*.>

-- | Traverse a <a>Traversable</a> using <a>Apply</a>, getting the results
--   back in a <a>MaybeApply</a>.
traverse1Maybe :: (Traversable t, Apply f) => (a -> f b) -> t a -> MaybeApply f (t b)

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
infixl 1 >>-
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
class Bifunctor p => Biapply p
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
infixl 4 <<.>>
infixl 4 .>>
infixl 4 <<.
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (GHC.Generics.M1 i t f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (GHC.Generics.Rec1 f)
instance Data.Functor.Bind.Class.Biapply (,)
instance Data.Functor.Bind.Class.Biapply Data.Semigroup.Arg
instance GHC.Base.Semigroup x => Data.Functor.Bind.Class.Biapply ((,,) x)
instance (GHC.Base.Semigroup x, GHC.Base.Semigroup y) => Data.Functor.Bind.Class.Biapply ((,,,) x y)
instance (GHC.Base.Semigroup x, GHC.Base.Semigroup y, GHC.Base.Semigroup z) => Data.Functor.Bind.Class.Biapply ((,,,,) x y z)
instance Data.Functor.Bind.Class.Biapply Data.Functor.Const.Const
instance Data.Functor.Bind.Class.Biapply Data.Tagged.Tagged
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Biff.Biff p f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Clown.Clown f)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Flip.Flip p)
instance Data.Functor.Bind.Class.Apply g => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Joker.Joker g)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Apply (Data.Bifunctor.Join.Join p)
instance (Data.Functor.Bind.Class.Biapply p, Data.Functor.Bind.Class.Biapply q) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Product.Product p q)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Biapply p) => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Functor.Bind.Class.Biapply p => Data.Functor.Bind.Class.Biapply (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Bind ((,) m)
instance Data.Functor.Bind.Class.Bind (Data.Tagged.Tagged a)
instance Data.Functor.Bind.Class.Bind Data.Proxy.Proxy
instance Data.Functor.Bind.Class.Bind (Data.Either.Either a)
instance (Data.Functor.Bind.Class.Bind f, Data.Functor.Bind.Class.Bind g) => Data.Functor.Bind.Class.Bind (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Bind ((->) m)
instance Data.Functor.Bind.Class.Bind []
instance Data.Functor.Bind.Class.Bind GHC.Base.NonEmpty
instance Data.Functor.Bind.Class.Bind GHC.Types.IO
instance Data.Functor.Bind.Class.Bind GHC.Maybe.Maybe
instance Data.Functor.Bind.Class.Bind Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Bind Language.Haskell.TH.Syntax.Q
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Identity.IdentityT m)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Bind (Control.Applicative.WrappedMonad m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.State.Strict.StateT s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance Data.Functor.Bind.Class.Bind (Control.Monad.Trans.Cont.ContT r m)
instance Data.Functor.Bind.Class.Bind Data.Complex.Complex
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Bind (Data.Map.Internal.Map k)
instance Data.Functor.Bind.Class.Bind Data.IntMap.Internal.IntMap
instance Data.Functor.Bind.Class.Bind Data.Sequence.Internal.Seq
instance Data.Functor.Bind.Class.Bind Data.Tree.Tree
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Bind (Data.HashMap.Internal.HashMap k)
instance Data.Functor.Bind.Class.Bind Data.Ord.Down
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Sum
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Product
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Internal.Dual
instance Data.Functor.Bind.Class.Bind Data.Monoid.First
instance Data.Functor.Bind.Class.Bind Data.Monoid.Last
instance Data.Functor.Bind.Class.Bind f => Data.Functor.Bind.Class.Bind (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Bind.Class.Bind Data.Semigroup.First
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Last
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Min
instance Data.Functor.Bind.Class.Bind Data.Semigroup.Max
instance Data.Functor.Bind.Class.Bind GHC.Generics.V1
instance Data.Functor.Bind.Class.Bind GHC.Generics.U1
instance Data.Functor.Bind.Class.Bind f => Data.Functor.Bind.Class.Bind (GHC.Generics.M1 i c f)
instance Data.Functor.Bind.Class.Bind m => Data.Functor.Bind.Class.Bind (GHC.Generics.Rec1 m)
instance Data.Functor.Bind.Class.Bind GHC.Generics.Par1
instance (Data.Functor.Bind.Class.Bind f, Data.Functor.Bind.Class.Bind g) => Data.Functor.Bind.Class.Bind (f GHC.Generics.:*: g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Applicative (Data.Functor.Bind.Class.MaybeApply f)
instance Data.Functor.Extend.Extend f => Data.Functor.Extend.Extend (Data.Functor.Bind.Class.MaybeApply f)
instance Control.Comonad.Comonad f => Control.Comonad.Comonad (Data.Functor.Bind.Class.MaybeApply f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => Data.Functor.Bind.Class.Apply (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Bind.Class.WrappedApplicative f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Bind.Class.Apply (Data.Tagged.Tagged a)
instance Data.Functor.Bind.Class.Apply Data.Proxy.Proxy
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Compose.Compose f g)
instance GHC.Base.Semigroup f => Data.Functor.Bind.Class.Apply (Data.Functor.Constant.Constant f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (Data.Functor.Product.Product f g)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Functor.Reverse.Reverse f)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Apply ((,) m)
instance Data.Functor.Bind.Class.Apply GHC.Base.NonEmpty
instance Data.Functor.Bind.Class.Apply (Data.Either.Either a)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Apply (Data.Functor.Const.Const m)
instance Data.Functor.Bind.Class.Apply ((->) m)
instance Data.Functor.Bind.Class.Apply Control.Applicative.ZipList
instance Data.Functor.Bind.Class.Apply []
instance Data.Functor.Bind.Class.Apply GHC.Types.IO
instance Data.Functor.Bind.Class.Apply GHC.Maybe.Maybe
instance Data.Functor.Bind.Class.Apply Data.Functor.Identity.Identity
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Identity.IdentityT w)
instance GHC.Base.Monad m => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedMonad m)
instance Control.Arrow.Arrow a => Data.Functor.Bind.Class.Apply (Control.Applicative.WrappedArrow a b)
instance Data.Functor.Bind.Class.Apply Data.Complex.Complex
instance Data.Functor.Bind.Class.Apply Language.Haskell.TH.Syntax.Q
instance GHC.Classes.Ord k => Data.Functor.Bind.Class.Apply (Data.Map.Internal.Map k)
instance Data.Functor.Bind.Class.Apply Data.IntMap.Internal.IntMap
instance Data.Functor.Bind.Class.Apply Data.Sequence.Internal.Seq
instance Data.Functor.Bind.Class.Apply Data.Tree.Tree
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Bind.Class.Apply (Data.HashMap.Internal.HashMap k)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Maybe.MaybeT m)
instance (GHC.Base.Functor m, GHC.Base.Monad m) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Bind.Class.Apply m => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Reader.ReaderT e m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Bind.Class.Apply (Control.Monad.Trans.Cont.ContT r m)
instance (GHC.Base.Semigroup e, Data.Functor.Bind.Class.Apply w) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Env.EnvT e w)
instance (Data.Functor.Bind.Class.Apply w, GHC.Base.Semigroup s) => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Store.StoreT s w)
instance Data.Functor.Bind.Class.Apply w => Data.Functor.Bind.Class.Apply (Control.Comonad.Trans.Traced.TracedT m w)
instance Data.Functor.Bind.Class.Apply (Control.Comonad.Cokleisli w a)
instance Data.Functor.Bind.Class.Apply Data.Ord.Down
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Sum
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Product
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Internal.Dual
instance Data.Functor.Bind.Class.Apply Data.Monoid.First
instance Data.Functor.Bind.Class.Apply Data.Monoid.Last
instance Data.Functor.Bind.Class.Apply Data.Semigroup.First
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Last
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Min
instance Data.Functor.Bind.Class.Apply Data.Semigroup.Max
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (f GHC.Generics.:*: g)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Bind.Class.Apply g) => Data.Functor.Bind.Class.Apply (f GHC.Generics.:.: g)
instance Data.Functor.Bind.Class.Apply GHC.Generics.U1
instance GHC.Base.Semigroup c => Data.Functor.Bind.Class.Apply (GHC.Generics.K1 i c)
instance Data.Functor.Bind.Class.Apply GHC.Generics.Par1
instance Data.Functor.Bind.Class.Apply GHC.Generics.V1


module Data.Functor.Apply

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 .>
infixl 4 <.

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b
infixl 4 <..>

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Generic <a>liftF2</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>w</tt> is a sum type.</li>
--   <li>Types in <tt>w</tt> that do not mention the type variable must be
--   instances of <a>Semigroup</a>.</li>
--   </ol>
gliftF2 :: (Generic1 w, Apply (Rep1 w)) => (a -> b -> c) -> w a -> w b -> w c

-- | Generic <a>liftF3</a>. Caveats are the same as for <a>gliftF2</a>.
gliftF3 :: (Generic1 w, Apply (Rep1 w)) => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform an Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | Apply a non-empty container of functions to a possibly-empty-with-unit
--   container of values.
(<.*>) :: Apply f => f (a -> b) -> MaybeApply f a -> f b
infixl 4 <.*>

-- | Apply a possibly-empty-with-unit container of functions to a non-empty
--   container of values.
(<*.>) :: Apply f => MaybeApply f (a -> b) -> f a -> f b
infixl 4 <*.>


-- | Re-exports a subset of the <a>Data.Bifoldable1</a> module along with
--   some additional combinators that require <a>Bifoldable1</a>
--   constraints.
module Data.Semigroup.Bifoldable
class Bifoldable t => Bifoldable1 (t :: Type -> Type -> Type)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
bitraverse1_ :: (Bifoldable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f ()
bifor1_ :: (Bifoldable1 t, Apply f) => t a c -> (a -> f b) -> (c -> f d) -> f ()
bisequenceA1_ :: (Bifoldable1 t, Apply f) => t (f a) (f b) -> f ()

-- | Usable default for foldMap, but only if you define bifoldMap1 yourself
bifoldMapDefault1 :: (Bifoldable1 t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Semigroup.Bifoldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Bifoldable.Act f)


-- | This module is only available if building with GHC 8.6 or later, or if
--   the <tt>+contravariant</tt> <tt>cabal</tt> build flag is available.
module Data.Functor.Contravariant.Divise

-- | The contravariant analogue of <a>Apply</a>; it is <a>Divisible</a>
--   without <a>conquer</a>.
--   
--   If one thinks of <tt>f a</tt> as a consumer of <tt>a</tt>s, then
--   <a>divise</a> allows one to handle the consumption of a value by
--   splitting it between two consumers that consume separate parts of
--   <tt>a</tt>.
--   
--   <a>divise</a> takes the "splitting" method and the two sub-consumers,
--   and returns the wrapped/combined consumer.
--   
--   All instances of <a>Divisible</a> should be instances of <a>Divise</a>
--   with <tt><a>divise</a> = <a>divide</a></tt>.
--   
--   If a function is polymorphic over <tt><a>Divise</a> f</tt> (as opposed
--   to <tt><a>Divisible</a> f</tt>), we can provide a stronger guarantee:
--   namely, that any input consumed will be passed to at least one
--   sub-consumer. With <tt><a>Divisible</a> f</tt>, said input could
--   potentially disappear into the void, as this is possible with
--   <a>conquer</a>.
--   
--   Mathematically, a functor being an instance of <a>Divise</a> means
--   that it is "semigroupoidal" with respect to the contravariant
--   (tupling) Day convolution. That is, it is possible to define a
--   function <tt>(f <tt>Day</tt> f) a -&gt; f a</tt> in a way that is
--   associative.
class Contravariant f => Divise f

-- | Takes a "splitting" method and the two sub-consumers, and returns the
--   wrapped/combined consumer.
divise :: Divise f => (a -> (b, c)) -> f b -> f c -> f a

-- | Generic <a>divise</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>f</tt> is a sum type.</li>
--   <li>Will not compile if <tt>f</tt> contains fields that do not mention
--   its type variable.</li>
--   <li><tt>-XDeriveGeneric</tt> is not smart enough to make instances
--   where the type variable appears in negative position.</li>
--   </ol>
gdivise :: (Divise (Rep1 f), Generic1 f) => (a -> (b, c)) -> f b -> f c -> f a

-- | Combine a consumer of <tt>a</tt> with a consumer of <tt>b</tt> to get
--   a consumer of <tt>(a, b)</tt>.
--   
--   <pre>
--   <a>divised</a> = <a>divise</a> <a>id</a>
--   </pre>
divised :: Divise f => f a -> f b -> f (a, b)

-- | Generic <a>divised</a>. Caveats are the same as for <a>gdivise</a>.
gdivised :: (Generic1 f, Divise (Rep1 f)) => f a -> f b -> f (a, b)

-- | Wrap a <a>Divisible</a> to be used as a member of <a>Divise</a>
newtype WrappedDivisible f a
WrapDivisible :: f a -> WrappedDivisible f a
[unwrapDivisible] :: WrappedDivisible f a -> f a
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Divise.WrappedDivisible f)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Contravariant.Divise.WrappedDivisible f)
instance GHC.Base.Semigroup r => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Contravariant.Op r)
instance GHC.Base.Semigroup m => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Const.Const m)
instance GHC.Base.Semigroup m => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Constant.Constant m)
instance Data.Functor.Contravariant.Divise.Divise Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Divise.Divise Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Divise.Divise Data.Functor.Contravariant.Predicate
instance Data.Functor.Contravariant.Divise.Divise Data.Proxy.Proxy
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Divise.Divise GHC.Generics.U1
instance Data.Functor.Contravariant.Divise.Divise GHC.Generics.V1
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Divise.Divise f, Data.Functor.Contravariant.Divise.Divise g) => Data.Functor.Contravariant.Divise.Divise (f GHC.Generics.:*: g)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Contravariant.Divise.Divise g) => Data.Functor.Contravariant.Divise.Divise (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Divise.Divise (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Contravariant.Divise.Divise g) => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Divise.Divise f, Data.Functor.Contravariant.Divise.Divise g) => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Divise.Divise f => Data.Functor.Contravariant.Divise.Divise (Data.Functor.Reverse.Reverse f)


-- | This module is only available if building with GHC 8.6 or later, or if
--   the <tt>+contravariant</tt> <tt>cabal</tt> build flag is available.
module Data.Functor.Contravariant.Decide

-- | The contravariant analogue of <a>Alt</a>.
--   
--   If one thinks of <tt>f a</tt> as a consumer of <tt>a</tt>s, then
--   <a>decide</a> allows one to handle the consumption of a value by
--   choosing to handle it via exactly one of two independent consumers. It
--   redirects the input completely into one of two consumers.
--   
--   <a>decide</a> takes the "decision" method and the two potential
--   consumers, and returns the wrapped/combined consumer.
--   
--   Mathematically, a functor being an instance of <a>Decide</a> means
--   that it is "semigroupoidal" with respect to the contravariant
--   "either-based" Day convolution (<tt>data EitherDay f g a = forall b c.
--   EitherDay (f b) (g c) (a -&gt; Either b c)</tt>). That is, it is
--   possible to define a function <tt>(f <tt>EitherDay</tt> f) a -&gt; f
--   a</tt> in a way that is associative.
class Contravariant f => Decide f

-- | Takes the "decision" method and the two potential consumers, and
--   returns the wrapped/combined consumer.
decide :: Decide f => (a -> Either b c) -> f b -> f c -> f a

-- | Generic <a>decide</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>f</tt> is a sum type.</li>
--   <li>Will not compile if <tt>f</tt> contains fields that do not mention
--   its type variable.</li>
--   <li><tt>-XDeriveGeneric</tt> is not smart enough to make instances
--   where the type variable appears in negative position.</li>
--   </ol>
gdecide :: (Generic1 f, Decide (Rep1 f)) => (a -> Either b c) -> f b -> f c -> f a

-- | For <tt><a>decided</a> x y</tt>, the resulting <tt>f (<a>Either</a> b
--   c)</tt> will direct <a>Left</a>s to be consumed by <tt>x</tt>, and
--   <a>Right</a>s to be consumed by y.
decided :: Decide f => f b -> f c -> f (Either b c)

-- | Generic <a>decided</a>. Caveats are the same as for <a>gdecide</a>.
gdecided :: (Generic1 f, Decide (Rep1 f)) => f b -> f c -> f (Either b c)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Decide.Decide (Data.Functor.Contravariant.Divise.WrappedDivisible f)
instance Data.Functor.Contravariant.Decide.Decide Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Decide.Decide Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Decide.Decide Data.Functor.Contravariant.Predicate
instance Data.Functor.Contravariant.Decide.Decide (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Decide.Decide GHC.Generics.U1
instance Data.Functor.Contravariant.Decide.Decide GHC.Generics.V1
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Decide.Decide f, Data.Functor.Contravariant.Decide.Decide g) => Data.Functor.Contravariant.Decide.Decide (f GHC.Generics.:*: g)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Contravariant.Decide.Decide g) => Data.Functor.Contravariant.Decide.Decide (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Contravariant.Divise.Divise m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Decide.Decide m => Data.Functor.Contravariant.Decide.Decide (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply f, Data.Functor.Contravariant.Decide.Decide g) => Data.Functor.Contravariant.Decide.Decide (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Decide.Decide f, Data.Functor.Contravariant.Decide.Decide g) => Data.Functor.Contravariant.Decide.Decide (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Decide.Decide f => Data.Functor.Contravariant.Decide.Decide (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Contravariant.Decide.Decide Data.Proxy.Proxy


-- | This module is only available if building with GHC 8.6 or later, or if
--   the <tt>+contravariant</tt> <tt>cabal</tt> build flag is available.
module Data.Functor.Contravariant.Conclude

-- | The contravariant analogue of <tt>Plus</tt>. Adds on to <a>Decide</a>
--   the ability to express a combinator that rejects all input, to act as
--   the dead-end. Essentially <a>Decidable</a> without a superclass
--   constraint on <a>Divisible</a>.
--   
--   If one thinks of <tt>f a</tt> as a consumer of <tt>a</tt>s, then
--   <a>conclude</a> defines a consumer that cannot ever receive <i>any</i>
--   input.
--   
--   Conclude acts as an identity with <a>decide</a>, because any decision
--   that involves <a>conclude</a> must necessarily <i>always</i> pick the
--   other option.
--   
--   That is, for, say,
--   
--   <pre>
--   <a>decide</a> f x <a>concluded</a>
--   </pre>
--   
--   <tt>f</tt> is the deciding function that picks which of the inputs of
--   <tt>decide</tt> to direct input to; in the situation above, <tt>f</tt>
--   must <i>always</i> direct all input to <tt>x</tt>, and never
--   <a>concluded</a>.
--   
--   Mathematically, a functor being an instance of <a>Decide</a> means
--   that it is "monoidal" with respect to the contravariant "either-based"
--   Day convolution described in the documentation of <a>Decide</a>. On
--   top of <a>Decide</a>, it adds a way to construct an "identity"
--   <tt>conclude</tt> where <tt>decide f x (conclude q) == x</tt>, and
--   <tt>decide g (conclude r) y == y</tt>.
class Decide f => Conclude f

-- | The consumer that cannot ever receive <i>any</i> input.
conclude :: Conclude f => (a -> Void) -> f a

-- | Generic <a>conclude</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>f</tt> is a sum type.</li>
--   <li>Will not compile if <tt>f</tt> contains fields that do not mention
--   its type variable.</li>
--   </ol>
gconclude :: (Generic1 f, Conclude (Rep1 f)) => (a -> Void) -> f a

-- | A potentially more meaningful form of <a>conclude</a>, the consumer
--   that cannot ever receive <i>any</i> input. That is because it expects
--   only input of type <a>Void</a>, but such a type has no values.
--   
--   <pre>
--   <a>concluded</a> = <a>conclude</a> <a>id</a>
--   </pre>
concluded :: Conclude f => f Void

-- | Generic <a>concluded</a>. Caveats are the same as for
--   <a>gconclude</a>.
gconcluded :: (Generic1 f, Conclude (Rep1 f)) => f Void
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Conclude.Conclude (Data.Functor.Contravariant.Divise.WrappedDivisible f)
instance Data.Functor.Contravariant.Conclude.Conclude Data.Functor.Contravariant.Comparison
instance Data.Functor.Contravariant.Conclude.Conclude Data.Functor.Contravariant.Equivalence
instance Data.Functor.Contravariant.Conclude.Conclude Data.Functor.Contravariant.Predicate
instance Data.Functor.Contravariant.Conclude.Conclude (Data.Functor.Contravariant.Op r)
instance Data.Functor.Contravariant.Conclude.Conclude Data.Proxy.Proxy
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Contravariant.Conclude.Conclude GHC.Generics.U1
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (GHC.Generics.Rec1 f)
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (GHC.Generics.M1 i c f)
instance (Data.Functor.Contravariant.Conclude.Conclude f, Data.Functor.Contravariant.Conclude.Conclude g) => Data.Functor.Contravariant.Conclude.Conclude (f GHC.Generics.:*: g)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Applicative f, Data.Functor.Contravariant.Conclude.Conclude g) => Data.Functor.Contravariant.Conclude.Conclude (f GHC.Generics.:.: g)
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (Data.Functor.Contravariant.Divisible.Divisible m, Data.Functor.Contravariant.Divise.Divise m) => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Contravariant.Conclude.Conclude m => Data.Functor.Contravariant.Conclude.Conclude (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Applicative f, Data.Functor.Contravariant.Conclude.Conclude g) => Data.Functor.Contravariant.Conclude.Conclude (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Contravariant.Conclude.Conclude f, Data.Functor.Contravariant.Conclude.Conclude g) => Data.Functor.Contravariant.Conclude.Conclude (Data.Functor.Product.Product f g)
instance Data.Functor.Contravariant.Conclude.Conclude f => Data.Functor.Contravariant.Conclude.Conclude (Data.Functor.Reverse.Reverse f)


module Data.Functor.Bind

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   (<a>.</a>) <a>&lt;$&gt;</a> u <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w = u <a>&lt;.&gt;</a> (v <a>&lt;.&gt;</a> w)
--   x <a>&lt;.&gt;</a> (f <a>&lt;$&gt;</a> y) = (<a>.</a> f) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   f <a>&lt;$&gt;</a> (x <a>&lt;.&gt;</a> y) = (f <a>.</a>) <a>&lt;$&gt;</a> x <a>&lt;.&gt;</a> y
--   </pre>
--   
--   The laws imply that <a>.&gt;</a> and <a>&lt;.</a> really ignore their
--   left and right results, respectively, and really return their right
--   and left results, respectively. Specifically,
--   
--   <pre>
--   (mf <a>&lt;$&gt;</a> m) <a>.&gt;</a> (nf <a>&lt;$&gt;</a> n) = nf <a>&lt;$&gt;</a> (m <a>.&gt;</a> n)
--   (mf <a>&lt;$&gt;</a> m) <a>&lt;.</a> (nf <a>&lt;$&gt;</a> n) = mf <a>&lt;$&gt;</a> (m <a>&lt;.</a> n)
--   </pre>
class Functor f => Apply f
(<.>) :: Apply f => f (a -> b) -> f a -> f b

-- | <pre>
--   a <a>.&gt;</a> b = <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>) :: Apply f => f a -> f b -> f b

-- | <pre>
--   a <a>&lt;.</a> b = <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<.) :: Apply f => f a -> f b -> f a

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
infixl 4 <.>
infixl 4 .>
infixl 4 <.

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b
infixl 4 <..>

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
[unwrapApplicative] :: WrappedApplicative f a -> f a

-- | Transform an Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
[runMaybeApply] :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
infixl 1 >>-

-- | Generic <a>(&gt;&gt;-)</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>m</tt> is a sum type.</li>
--   <li>Will not compile if <tt>m</tt> contains fields that do not mention
--   its type variable.</li>
--   <li>Will not compile if <tt>m</tt> contains fields where the type
--   variable appears underneath the composition of type constructors
--   (e.g., <tt>f (g a)</tt>).</li>
--   <li>May do redundant work, due to the nature of the <a>Bind</a>
--   instance for (<a>:*:</a>)</li>
--   </ol>
gbind :: (Generic1 m, Bind (Rep1 m)) => m a -> (a -> m b) -> m b
(-<<) :: Bind m => (a -> m b) -> m a -> m b
infixr 1 -<<
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 -<-
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 ->-
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
newtype WrappedCategory k a b
WrapCategory :: k a b -> WrappedCategory k a b
[unwrapCategory] :: WrappedCategory k a b -> k a b
newtype Semi m a b
Semi :: m -> Semi m a b
[getSemi] :: Semi m a b -> m
instance GHC.Base.Semigroup m => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Semi m)
instance GHC.Base.Monoid m => Control.Category.Category (Data.Semigroupoid.Semi m)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.WrappedCategory k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Semigroupoid.WrappedCategory k2)
instance Data.Semigroupoid.Semigroupoid (->)
instance Data.Semigroupoid.Semigroupoid (,)
instance Data.Functor.Bind.Class.Bind m => Data.Semigroupoid.Semigroupoid (Control.Arrow.Kleisli m)
instance Data.Functor.Extend.Extend w => Data.Semigroupoid.Semigroupoid (Control.Comonad.Cokleisli w)
instance Data.Semigroupoid.Semigroupoid Data.Functor.Contravariant.Op
instance Data.Semigroupoid.Semigroupoid Data.Functor.Const.Const
instance Data.Semigroupoid.Semigroupoid Data.Tagged.Tagged
instance Data.Semigroupoid.Semigroupoid Data.Type.Coercion.Coercion
instance Data.Semigroupoid.Semigroupoid (Data.Type.Equality.:~:)
instance Data.Semigroupoid.Semigroupoid (Data.Type.Equality.:~~:)


module Data.Semigroupoid.Ob
class Semigroupoid k => Ob k a
semiid :: Ob k a => k a a
instance (Data.Functor.Bind.Class.Bind m, GHC.Base.Monad m) => Data.Semigroupoid.Ob.Ob (Control.Arrow.Kleisli m) a
instance (Data.Functor.Extend.Extend w, Control.Comonad.Comonad w) => Data.Semigroupoid.Ob.Ob (Control.Comonad.Cokleisli w) a
instance Data.Semigroupoid.Ob.Ob (->) a


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid.Dual
newtype Dual k a b
Dual :: k b a -> Dual k a b
[getDual] :: Dual k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Dual.Dual k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Semigroupoid.Dual.Dual k2)


-- | Provides a way to attach an identity to any semigroupoid.
module Data.Semigroupoid.Categorical

-- | Attaches an identity.
data Categorical s a b
[Id] :: Categorical s a a
[Embed] :: s a b -> Categorical s a b

runCategorical :: (a ~ b => r) -> (s a b -> r) -> Categorical s a b -> r
instance Data.Semigroupoid.Semigroupoid s => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Categorical.Categorical s)
instance Data.Semigroupoid.Semigroupoid s => Control.Category.Category (Data.Semigroupoid.Categorical.Categorical s)


module Data.Groupoid

-- | semigroupoid with inverses. This technically should be a category with
--   inverses, except we need to use Ob to define the valid objects for the
--   category
class Semigroupoid k => Groupoid k
inv :: Groupoid k => k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Groupoid.Groupoid k2 => Data.Groupoid.Groupoid (Data.Semigroupoid.Dual.Dual k2)
instance Data.Groupoid.Groupoid Data.Type.Coercion.Coercion
instance Data.Groupoid.Groupoid (Data.Type.Equality.:~:)
instance Data.Groupoid.Groupoid (Data.Type.Equality.:~~:)


module Data.Isomorphism
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
[embed] :: Iso k a b -> k a b
[project] :: Iso k a b -> k b a
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Semigroupoid.Semigroupoid (Data.Isomorphism.Iso k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Data.Semigroupoid.Semigroupoid k2 => Data.Groupoid.Groupoid (Data.Isomorphism.Iso k2)
instance forall k1 (k2 :: k1 -> k1 -> *). Control.Category.Category k2 => Control.Category.Category (Data.Isomorphism.Iso k2)


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance Data.Functor.Bind.Trans.BindTrans Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Reader.ReaderT e)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Writer.CPS.WriterT w)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.State.Strict.StateT s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.RWS.CPS.RWST r w s)
instance Data.Functor.Bind.Trans.BindTrans (Control.Monad.Trans.Cont.ContT r)


module Data.Bifunctor.Apply

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class forall a. () => Functor p a => Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
class Bifunctor p => Biapply p
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d

-- | <pre>
--   a <a>.&gt;</a> b ≡ <a>const</a> <a>id</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(.>>) :: Biapply p => p a b -> p c d -> p c d

-- | <pre>
--   a <a>&lt;.</a> b ≡ <a>const</a> <a>&lt;$&gt;</a> a <a>&lt;.&gt;</a> b
--   </pre>
(<<.) :: Biapply p => p a b -> p c d -> p a b
infixl 4 <<.>>
infixl 4 .>>
infixl 4 <<.
(<<$>>) :: (a -> b) -> a -> b
infixl 4 <<$>>
(<<..>>) :: Biapply p => p a c -> p (a -> b) (c -> d) -> p b d
infixl 4 <<..>>

-- | Lift binary functions
bilift2 :: Biapply w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
bilift3 :: Biapply w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distribution" law of MonadPlus with respect to <a>&lt;.&gt;</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   <a>IO</a>, <tt><a>Either</a> a</tt>, <tt><a>ExceptT</a> e m</tt> and
--   <a>STM</a> instead satisfy the "left catch" law:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   <a>Maybe</a> and <a>Identity</a> satisfy both "left distribution" and
--   "left catch".
--   
--   These variations cannot be stated purely in terms of the dependencies
--   of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <tt>Bind</tt> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f

-- | <a>&lt;|&gt;</a> without a required <tt>empty</tt>
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
infixl 3 <!>

-- | One or none.
optional :: (Alt f, Applicative f) => f a -> f (Maybe a)

-- | Generic (<a>&lt;!&gt;</a>). Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>f</tt> is a sum type.</li>
--   <li>Any types where the <tt>a</tt> does not appear must have a
--   <a>Semigroup</a> instance.</li>
--   </ol>
galt :: (Generic1 f, Alt (Rep1 f)) => f a -> f a -> f a
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (GHC.Generics.M1 i c f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (GHC.Generics.Rec1 f)
instance (Data.Functor.Alt.Alt f, Data.Functor.Alt.Alt g) => Data.Functor.Alt.Alt (f GHC.Generics.:*: g)
instance (Data.Functor.Alt.Alt f, GHC.Base.Functor g) => Data.Functor.Alt.Alt (f GHC.Generics.:.: g)
instance GHC.Base.Semigroup c => Data.Functor.Alt.Alt (GHC.Generics.K1 i c)
instance Data.Functor.Alt.Alt GHC.Generics.U1
instance Data.Functor.Alt.Alt GHC.Generics.V1
instance Data.Functor.Alt.Alt Data.Proxy.Proxy
instance Data.Functor.Alt.Alt (Data.Either.Either a)
instance Data.Functor.Alt.Alt GHC.Types.IO
instance Data.Functor.Alt.Alt Data.Functor.Identity.Identity
instance Data.Functor.Alt.Alt []
instance Data.Functor.Alt.Alt GHC.Maybe.Maybe
instance GHC.Base.MonadPlus m => Data.Functor.Alt.Alt (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Alt.Alt (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Alt.Alt (Data.Map.Internal.Map k)
instance Data.Functor.Alt.Alt Data.IntMap.Internal.IntMap
instance Data.Functor.Alt.Alt Data.Sequence.Internal.Seq
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Alt.Alt (Data.HashMap.Internal.HashMap k)
instance Data.Functor.Alt.Alt GHC.Base.NonEmpty
instance GHC.Base.Alternative f => Data.Functor.Alt.Alt (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Reader.ReaderT e f)
instance (GHC.Base.Functor f, GHC.Base.Monad f) => Data.Functor.Alt.Alt (Control.Monad.Trans.Maybe.MaybeT f)
instance (GHC.Base.Functor f, GHC.Base.Monad f, GHC.Base.Semigroup e) => Data.Functor.Alt.Alt (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.Writer.CPS.WriterT w f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Monad.Trans.RWS.CPS.RWST r w s f)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Alt.Alt f, GHC.Base.Functor g) => Data.Functor.Alt.Alt (Data.Functor.Compose.Compose f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Alt.Alt f, Data.Functor.Alt.Alt g) => Data.Functor.Alt.Alt (Data.Functor.Product.Product f g)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Alt.Alt Data.Semigroup.First
instance Data.Functor.Alt.Alt Data.Semigroup.Last
instance Data.Functor.Alt.Alt Data.Monoid.First
instance Data.Functor.Alt.Alt Data.Monoid.Last


-- | Re-exports a subset of the <a>Data.Foldable1</a> module along with
--   some additional combinators that require <a>Foldable1</a> constraints.
module Data.Semigroup.Foldable

-- | Non-empty data structures that can be folded.
class Foldable t => Foldable1 (t :: Type -> Type)

-- | Combine the elements of a structure using a semigroup. @since 4.18.0.0
fold1 :: (Foldable1 t, Semigroup m) => t m -> m

-- | Map each element of the structure to a semigroup, and combine the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1 Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | List of elements of a structure, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (Identity 2)
--   2 :| []
--   </pre>
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | Insert an <tt>m</tt> between each pair of <tt>t m</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a

-- | Generic <a>fold1</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>t</tt> is an empty constructor.</li>
--   <li>Will not compile if <tt>t</tt> has some fields that don't mention
--   <tt>a</tt>, for exmaple <tt>data Bar a = MkBar a Int</tt></li>
--   </ol>
gfold1 :: (Foldable1 (Rep1 t), Generic1 t, Semigroup m) => t m -> m

-- | Generic <a>foldMap1</a>. Caveats are the same as for <a>gfold1</a>.
gfoldMap1 :: (Foldable1 (Rep1 t), Generic1 t, Semigroup m) => (a -> m) -> t a -> m

-- | Generic <a>toNonEmpty</a>. Caveats are the same as for <a>gfold1</a>.
gtoNonEmpty :: (Foldable1 (Rep1 t), Generic1 t) => t a -> NonEmpty a
instance Data.Functor.Alt.Alt f => GHC.Base.Semigroup (Data.Semigroup.Foldable.Alt_ f a)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Semigroup.Foldable.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroup.Foldable.Act f)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Semigroup.Foldable.JoinWith a)


module Data.Semigroup.Traversable.Class
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
class (Foldable1 t, Traversable t) => Traversable1 t
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
instance (Data.Semigroup.Traversable.Class.Bitraversable1 p, Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Clown.Clown f)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Join.Join p)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Joker.Joker g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 p) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (GHC.Generics.Rec1 f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (GHC.Generics.M1 i c f)
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Generics.Par1
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Generics.V1
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:*: g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:+: g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (f GHC.Generics.:.: g)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Functor.Identity.Identity
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Product.Product f g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Sum.Sum f g)
instance (Data.Semigroup.Traversable.Class.Traversable1 f, Data.Semigroup.Traversable.Class.Traversable1 g) => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Compose.Compose f g)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Backwards.Backwards f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Applicative.Lift.Lift f)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Data.Functor.Reverse.Reverse f)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Complex.Complex
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.Tagged.Tagged a)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Tree.Tree
instance Data.Semigroup.Traversable.Class.Traversable1 GHC.Base.NonEmpty
instance Data.Semigroup.Traversable.Class.Traversable1 ((,) a)
instance Data.Semigroup.Traversable.Class.Traversable1 g => Data.Semigroup.Traversable.Class.Traversable1 (Data.Bifunctor.Joker.Joker g a)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Sum
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Product
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Internal.Dual
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Data.Semigroup.Internal.Alt f)
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.First
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Last
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Min
instance Data.Semigroup.Traversable.Class.Traversable1 Data.Semigroup.Max
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Semigroup.Arg
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Either.Either
instance Data.Semigroup.Traversable.Class.Bitraversable1 (,)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,) x)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,) x y)
instance Data.Semigroup.Traversable.Class.Bitraversable1 ((,,,,) x y z)
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Functor.Const.Const
instance Data.Semigroup.Traversable.Class.Bitraversable1 Data.Tagged.Tagged
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Flip.Flip p)
instance (Data.Semigroup.Traversable.Class.Bitraversable1 f, Data.Semigroup.Traversable.Class.Bitraversable1 g) => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Product.Product f g)
instance Data.Semigroup.Traversable.Class.Bitraversable1 p => Data.Semigroup.Traversable.Class.Bitraversable1 (Data.Bifunctor.Wrapped.WrappedBifunctor p)


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)

-- | Traverse a <a>Traversable</a> using <a>Apply</a>, getting the results
--   back in a <a>MaybeApply</a>.
traverse1Maybe :: (Traversable t, Apply f) => (a -> f b) -> t a -> MaybeApply f (t b)

-- | Generic <a>traverse1</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>t</tt> is an empty constructor.</li>
--   <li>Will not compile if <tt>t</tt> has some fields that don't mention
--   <tt>a</tt>, for exmaple <tt>data Bar a = MkBar a Int</tt></li>
--   </ol>
gtraverse1 :: (Traversable1 (Rep1 t), Apply f, Generic1 t) => (a -> f b) -> t a -> f (t b)

-- | Generic <a>sequence1</a>. Caveats are the same for <a>gtraverse1</a>.
gsequence1 :: (Traversable1 (Rep1 t), Apply f, Generic1 t) => t (f b) -> f (t b)

-- | Default implementation of <tt>foldMap1</tt> given an implementation of
--   <a>Traversable1</a>.
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m


module Data.Semigroup.Bitraversable
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
bifoldMap1Default :: (Bitraversable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; psum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
psum :: (Foldable t, Plus f) => t (f a) -> f a

-- | Generic <a>zero</a>. Caveats:
--   
--   <ol>
--   <li>Will not compile if <tt>f</tt> is a sum type.</li>
--   <li>Any types where the <tt>a</tt> does not appear must have a
--   <a>Monoid</a> instance.</li>
--   </ol>
gzero :: (Plus (Rep1 f), Generic1 f) => f a
instance Data.Functor.Plus.Plus Data.Proxy.Proxy
instance Data.Functor.Plus.Plus GHC.Generics.U1
instance GHC.Base.Monoid c => Data.Functor.Plus.Plus (GHC.Generics.K1 i c)
instance (Data.Functor.Plus.Plus f, Data.Functor.Plus.Plus g) => Data.Functor.Plus.Plus (f GHC.Generics.:*: g)
instance (Data.Functor.Plus.Plus f, GHC.Base.Functor g) => Data.Functor.Plus.Plus (f GHC.Generics.:.: g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (GHC.Generics.M1 i c f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (GHC.Generics.Rec1 f)
instance Data.Functor.Plus.Plus GHC.Types.IO
instance Data.Functor.Plus.Plus []
instance Data.Functor.Plus.Plus GHC.Maybe.Maybe
instance GHC.Base.MonadPlus m => Data.Functor.Plus.Plus (Control.Applicative.WrappedMonad m)
instance Control.Arrow.ArrowPlus a => Data.Functor.Plus.Plus (Control.Applicative.WrappedArrow a b)
instance GHC.Classes.Ord k => Data.Functor.Plus.Plus (Data.Map.Internal.Map k)
instance Data.Functor.Plus.Plus Data.IntMap.Internal.IntMap
instance Data.Functor.Plus.Plus Data.Sequence.Internal.Seq
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Functor.Plus.Plus (Data.HashMap.Internal.HashMap k)
instance GHC.Base.Alternative f => Data.Functor.Plus.Plus (Data.Functor.Bind.Class.WrappedApplicative f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Identity.IdentityT f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Reader.ReaderT e f)
instance (GHC.Base.Functor f, GHC.Base.Monad f) => Data.Functor.Plus.Plus (Control.Monad.Trans.Maybe.MaybeT f)
instance (GHC.Base.Functor f, GHC.Base.Monad f, GHC.Base.Semigroup e, GHC.Base.Monoid e) => Data.Functor.Plus.Plus (Control.Monad.Trans.Except.ExceptT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Strict.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.State.Lazy.StateT e f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Strict.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.Lazy.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.Writer.CPS.WriterT w f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Strict.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.Lazy.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Monad.Trans.RWS.CPS.RWST r w s f)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Backwards.Backwards f)
instance (Data.Functor.Plus.Plus f, GHC.Base.Functor g) => Data.Functor.Plus.Plus (Data.Functor.Compose.Compose f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Control.Applicative.Lift.Lift f)
instance (Data.Functor.Plus.Plus f, Data.Functor.Plus.Plus g) => Data.Functor.Plus.Plus (Data.Functor.Product.Product f g)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Plus.Plus Data.Monoid.First
instance Data.Functor.Plus.Plus Data.Monoid.Last


-- | This module re-exports operators from <a>Data.Functor.Apply</a> and
--   <a>Data.Functor.Bind</a>, but under the same names as their
--   <tt>Applicative</tt> and <tt>Monad</tt> counterparts. This makes it
--   convenient to use do-notation on a type that is a <a>Bind</a> but not
--   a monad (or an <a>Apply</a> but not an <tt>Applicative</tt> with
--   <tt>ApplicativeDo</tt>), either using the <tt>QualifiedDo</tt>
--   extension or the more traditional <tt>RebindableSyntax</tt>.
--   
--   <pre>
--   {-# LANGUAGE ApplicativeDo #-}
--   {-# LANGUAGE QualifiedDo #-}
--   
--   foo :: Apply f =&gt; f a -&gt; f b -&gt; f (a, b)
--   foo as bs = Semi.do
--     a &lt;- as
--     b &lt;- bs
--     pure (a, b)
--   
--   
--   bar :: Bind m =&gt; (a -&gt; b -&gt; m c) -&gt; m a -&gt; m b -&gt; m c
--   bar f as bs = Semi.do
--     a &lt;- as
--     b &lt;- bs
--     f a b
--   </pre>
module Semigroupoids.Do

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

(<*) :: Apply f => f a -> f b -> f a

(*>) :: Apply f => f a -> f b -> f b

(<*>) :: Apply f => f (a -> b) -> f a -> f b

(>>) :: Bind m => m a -> m b -> m b

(>>=) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | <h1>Important note</h1>
--   
--   This <i>ignores</i> whatever <a>String</a> you give it. It is a bad
--   idea to use <a>fail</a> as a form of labelled error; instead, it
--   should only be defaulted to when a pattern match fails.
fail :: Plus m => String -> m a


module Data.Semigroupoid.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
[runStatic] :: Static f a b -> f (a -> b)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Alt.Alt f => Data.Functor.Alt.Alt (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Plus.Plus f => Data.Functor.Plus.Plus (Data.Semigroupoid.Static.Static f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Semigroupoid.Static.Static f a)
instance (Data.Functor.Extend.Extend f, GHC.Base.Semigroup a) => Data.Functor.Extend.Extend (Data.Semigroupoid.Static.Static f a)
instance (Control.Comonad.Comonad f, GHC.Base.Monoid a) => Control.Comonad.Comonad (Data.Semigroupoid.Static.Static f a)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroupoid.Semigroupoid (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Category.Category (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.Arrow (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowZero (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Alternative f => Control.Arrow.ArrowPlus (Data.Semigroupoid.Static.Static f)
instance GHC.Base.Applicative f => Control.Arrow.ArrowChoice (Data.Semigroupoid.Static.Static f)
