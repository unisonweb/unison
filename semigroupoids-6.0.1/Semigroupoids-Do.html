<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Semigroupoids.Do</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">semigroupoids-6.0.1: Semigroupoids: Category sans id</span><ul class="links" id="page-menu"><li><a href="src/Semigroupoids.Do.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Semigroupoids.Do</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module re-exports operators from <a href="Data-Functor-Apply.html">Data.Functor.Apply</a> and
<a href="Data-Functor-Bind.html">Data.Functor.Bind</a>, but under the same
names as their <code>Applicative</code> and <code>Monad</code> counterparts. This makes it convenient
to use do-notation on a type that is a <code><a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a></code> but not a monad (or an <code><a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a></code>
but not an <code>Applicative</code> with <code>ApplicativeDo</code>), either using the
<code>QualifiedDo</code> extension or the more traditional <code>RebindableSyntax</code>.</p><pre>{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE QualifiedDo #-}

foo :: Apply f =&gt; f a -&gt; f b -&gt; f (a, b)
foo as bs = Semi.do
  a &lt;- as
  b &lt;- bs
  pure (a, b)


bar :: Bind m =&gt; (a -&gt; b -&gt; m c) -&gt; m a -&gt; m b -&gt; m c
bar f as bs = Semi.do
  a &lt;- as
  b &lt;- bs
  f a b
</pre></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:fmap">fmap</a> :: <a href="Data-Functor-Apply.html#t:Functor" title="Data.Functor.Apply">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f a -&gt; f b -&gt; f a</li><li class="src short"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f a -&gt; f b -&gt; f b</li><li class="src short"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m a -&gt; m b -&gt; m b</li><li class="src short"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:join">join</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m (m a) -&gt; m a</li><li class="src short"><a href="#v:pure">pure</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a</li><li class="src short"><a href="#v:return">return</a> :: <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; a -&gt; m a</li><li class="src short"><a href="#v:fail">fail</a> :: <a href="Data-Functor-Plus.html#t:Plus" title="Data.Functor.Plus">Plus</a> m =&gt; <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m a</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:fmap" class="def">fmap</a> :: <a href="Data-Functor-Apply.html#t:Functor" title="Data.Functor.Apply">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b <a href="#v:fmap" class="selflink">#</a></p><div class="doc"><p><code><a href="Semigroupoids-Do.html#v:fmap" title="Semigroupoids.Do">fmap</a></code> is used to apply a function of type <code>(a -&gt; b)</code> to a value of type <code>f a</code>,
 where f is a functor, to produce a value of type <code>f b</code>.
 Note that for any type constructor with more than one parameter (e.g., <code>Either</code>),
 only the last type parameter can be modified with <code><a href="Semigroupoids-Do.html#v:fmap" title="Semigroupoids.Do">fmap</a></code> (e.g., <code>b</code> in `Either a b`).</p><p>Some type constructors with two parameters or more have a <code><code><a href="Data.html#v:Bifunctor" title="Data">Bifunctor</a></code></code> instance that allows
 both the last and the penultimate parameters to be mapped over.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:fmap0">Examples</h4><details id="ch:fmap0"><summary class="hide-when-js-enabled">Expand</summary><p>Convert from a <code><code><a href="../base-4.18.2.1/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code> Int</code> to a <code>Maybe String</code>
 using <code><a href="../base-4.18.2.1/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap show Nothing
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap show (Just 3)
</code></strong>Just &quot;3&quot;
</pre><p>Convert from an <code><code><a href="../base-4.18.2.1/Data-Either.html#v:Either" title="Data.Either">Either</a></code> Int Int</code> to an
 <code>Either Int String</code> using <code><a href="../base-4.18.2.1/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap show (Left 17)
</code></strong>Left 17
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap show (Right 17)
</code></strong>Right &quot;17&quot;
</pre><p>Double each element of a list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap (*2) [1,2,3]
</code></strong>[2,4,6]
</pre><p>Apply <code><a href="../base-4.18.2.1/Prelude.html#v:even" title="Prelude">even</a></code> to the second element of a pair:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap even (2,2)
</code></strong>(2,True)
</pre><p>It may seem surprising that the function is only applied to the last element of the tuple
 compared to the list example above which applies it to every element in the list.
 To understand, remember that tuples are type constructors with multiple type parameters:
 a tuple of 3 elements <code>(a,b,c)</code> can also be written <code>(,,) a b c</code> and its <code>Functor</code> instance
 is defined for <code>Functor ((,,) a b)</code> (i.e., only the third parameter is free to be mapped over
 with <code>fmap</code>).</p><p>It explains why <code>fmap</code> can be used with tuples containing values of different types as in the
 following example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fmap even (&quot;hello&quot;, 1.0, 4)
</code></strong>(&quot;hello&quot;,1.0,True)
</pre></details></div></div><div class="top"><p class="src"><a id="v:-60--42-" class="def">(&lt;*)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f a -&gt; f b -&gt; f a <a href="src/Semigroupoids.Do.html#%3C%2A" class="link">Source</a> <a href="#v:-60--42-" class="selflink">#</a></p><div class="doc"><p><em>Since: 5.3.6</em></p></div></div><div class="top"><p class="src"><a id="v:-42--62-" class="def">(*&gt;)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f a -&gt; f b -&gt; f b <a href="src/Semigroupoids.Do.html#%2A%3E" class="link">Source</a> <a href="#v:-42--62-" class="selflink">#</a></p><div class="doc"><p><em>Since: 5.3.6</em></p></div></div><div class="top"><p class="src"><a id="v:-60--42--62-" class="def">(&lt;*&gt;)</a> :: <a href="Data-Functor-Apply.html#t:Apply" title="Data.Functor.Apply">Apply</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <a href="src/Semigroupoids.Do.html#%3C%2A%3E" class="link">Source</a> <a href="#v:-60--42--62-" class="selflink">#</a></p><div class="doc"><p><em>Since: 5.3.6</em></p></div></div><div class="top"><p class="src"><a id="v:-62--62-" class="def">(&gt;&gt;)</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m a -&gt; m b -&gt; m b <a href="src/Semigroupoids.Do.html#%3E%3E" class="link">Source</a> <a href="#v:-62--62-" class="selflink">#</a></p><div class="doc"><p><em>Since: 5.3.6</em></p></div></div><div class="top"><p class="src"><a id="v:-62--62--61-" class="def">(&gt;&gt;=)</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b <a href="src/Semigroupoids.Do.html#%3E%3E%3D" class="link">Source</a> <a href="#v:-62--62--61-" class="selflink">#</a></p><div class="doc"><p><em>Since: 5.3.6</em></p></div></div><div class="top"><p class="src"><a id="v:join" class="def">join</a> :: <a href="Data-Functor-Bind.html#t:Bind" title="Data.Functor.Bind">Bind</a> m =&gt; m (m a) -&gt; m a <a href="src/Data.Functor.Bind.Class.html#join" class="link">Source</a> <a href="#v:join" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:pure" class="def">pure</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a <a href="#v:pure" class="selflink">#</a></p><div class="doc"><p>Lift a value.</p></div></div><div class="top"><p class="src"><a id="v:return" class="def">return</a> :: <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; a -&gt; m a <a href="#v:return" class="selflink">#</a></p><div class="doc"><p>Inject a value into the monadic type.</p></div></div><div class="top"><p class="src"><a id="v:fail" class="def">fail</a> :: <a href="Data-Functor-Plus.html#t:Plus" title="Data.Functor.Plus">Plus</a> m =&gt; <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m a <a href="src/Semigroupoids.Do.html#fail" class="link">Source</a> <a href="#v:fail" class="selflink">#</a></p><div class="doc"><h1>Important note</h1><p>This <em>ignores</em> whatever <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code> you give it. It is a bad idea to use <code><a href="Semigroupoids-Do.html#v:fail" title="Semigroupoids.Do">fail</a></code>
 as a form of labelled error; instead, it should only be defaulted to when a
 pattern match fails.</p><p><em>Since: 5.3.6</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>