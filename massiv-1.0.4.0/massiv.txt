-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Massiv (Массив) is an Array Library.
--   
--   Multi-dimensional Arrays with fusion, stencils and parallel
--   computation.
@package massiv
@version 1.0.4.0


module Data.Massiv.Core.Index

-- | Zero-dimension, i.e. a scalar. Can't really be used directly as there
--   is no instance of <a>Index</a> for it, and is included for
--   completeness.
data Ix0
Ix0 :: Ix0

-- | A type synonym for 1-dimensional index, i.e. <a>Int</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 :: Ix1
--   5
--   </pre>
type Ix1 = Int

-- | This is a very handy pattern synonym to indicate that any arbitrary
--   <a>Integral</a> literal is an <a>Int</a>, e.g. a 1-dimensional index:
--   <tt>(Ix1 5) == (5 :: Int)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 5
--   5
--   
--   &gt;&gt;&gt; :t Ix1 5
--   Ix1 5 :: Ix1
--   </pre>
pattern Ix1 :: Int -> Ix1

-- | 2-dimensional index. This is also a base index for higher dimensions.
data Ix2
(:.) :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Ix2

-- | 2-dimensional index constructor. Useful when infix notation is
--   inconvenient. <tt>(Ix2 i j) == (i :. j)</tt>
pattern Ix2 :: Int -> Int -> Ix2
infixr 5 :.

-- | n-dimensional index. Needs a base case, which is the <a>Ix2</a>.
data IxN (n :: Nat)
(:>) :: {-# UNPACK #-} !Int -> !Ix (n - 1) -> IxN (n :: Nat)

-- | 3-dimensional index constructor. <tt>(Ix3 i j k) == (i :&gt; j :.
--   k)</tt>
pattern Ix3 :: Int -> Int -> Int -> Ix3

-- | 4-dimensional index constructor. <tt>(Ix4 i j k l) == (i :&gt; j :&gt;
--   k :. l)</tt>
pattern Ix4 :: Int -> Int -> Int -> Int -> Ix4

-- | 5-dimensional index constructor. <tt>(Ix5 i j k l m) == (i :&gt; j
--   :&gt; k :&gt; l :. m)</tt>
pattern Ix5 :: Int -> Int -> Int -> Int -> Int -> Ix5
infixr 5 :>

-- | Constraint synonym that encapsulates all constraints needed for
--   dimension 4 and higher.
type HighIxN n = (4 <= n, KnownNat n, KnownNat (n - 1), Index (IxN (n - 1)), IxN (n - 1) ~ Ix (n - 1))

-- | 3-dimensional type synonym. Useful as a alternative to enabling
--   <tt>DataKinds</tt> and using type level Nats.
type Ix3 = IxN 3

-- | 4-dimensional type synonym.
type Ix4 = IxN 4

-- | 5-dimensional type synonym.
type Ix5 = IxN 5

-- | Defines n-dimensional index by relating a general <a>IxN</a> with few
--   base cases.
type family Ix (n :: Nat) = r | r -> n

-- | 1-dimensional type synonym for size.
type Sz1 = Sz Ix1

-- | 2-dimensional size type synonym.
type Sz2 = Sz Ix2

-- | 3-dimensional size type synonym.
type Sz3 = Sz Ix3

-- | 4-dimensional size type synonym.
type Sz4 = Sz Ix4

-- | 5-dimensional size type synonym.
type Sz5 = Sz Ix5

-- | <a>Sz</a> is the size of the array. It describes total number of
--   elements along each dimension in the array. It is a wrapper around an
--   index of the same dimension, however it provides type safety
--   preventing mixup with index. Moreover the <tt>Sz</tt> constructor and
--   others such as <a>Sz1</a>, <a>Sz2</a>, ... that are specialized to
--   specific dimensions, prevent creation of invalid sizes with negative
--   values by clamping them to zero.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3)
--   Sz (1 :&gt; 2 :. 3)
--   </pre>
--   
--   <a>Sz</a> has a <a>Num</a> instance, which is very convenient:
--   
--   <pre>
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3) + 5
--   Sz (6 :&gt; 7 :. 8)
--   </pre>
--   
--   However subtraction can sometimes lead to surprising behavior, because
--   size is not allowed to take negative values it will be clamped at 0.
--   
--   <pre>
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3) - 2
--   Sz (0 :&gt; 0 :. 1)
--   </pre>
--   
--   <b>Warning</b>: It is always wrong to <a>negate</a> a size, thus it
--   will result in an error. For that reason also watch out for partially
--   applied <tt>(<a>-</a> sz)</tt>, which is deugared into
--   <tt><a>negate</a> sz</tt>. See more info about it in <a>#114</a>.
data Sz ix

-- | A safe bidirectional pattern synonym for <a>Sz</a> construction that
--   will make sure that none of the size elements are negative.
pattern Sz :: Index ix => ix -> Sz ix

-- | 1-dimensional size constructor. Especially useful with literals:
--   <tt>(Sz1 5) == Sz (5 :: Int)</tt>.
pattern Sz1 :: Ix1 -> Sz Ix1

-- | 2-dimensional size constructor. <tt>(Sz2 i j) == Sz (i :. j)</tt>
pattern Sz2 :: Int -> Int -> Sz Ix2

-- | 3-dimensional size constructor. <tt>(Sz3 i j k) == Sz (i :&gt; j :.
--   k)</tt>
pattern Sz3 :: Int -> Int -> Int -> Sz Ix3

-- | 4-dimensional size constructor. <tt>(Sz4 i j k l) == Sz (i :&gt; j
--   :&gt; k :. l)</tt>
pattern Sz4 :: Int -> Int -> Int -> Int -> Sz Ix4

-- | 5-dimensional size constructor. <tt>(Sz5 i j k l m) == Sz (i :&gt; j
--   :&gt; k :&gt; l :. m)</tt>
pattern Sz5 :: Int -> Int -> Int -> Int -> Int -> Sz Ix5

-- | Function for unwrapping <a>Sz</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unSz $ Sz3 1 2 3
--   1 :&gt; 2 :. 3
--   </pre>
unSz :: Sz ix -> ix

-- | An empty size with all elements in size equal to <tt>0</tt>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; zeroSz :: Sz5
--   Sz (0 :&gt; 0 :&gt; 0 :&gt; 0 :. 0)
--   </pre>
zeroSz :: Index ix => Sz ix

-- | A singleton size with all elements in size equal to <tt>1</tt>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; oneSz :: Sz3
--   Sz (1 :&gt; 1 :. 1)
--   </pre>
oneSz :: Index ix => Sz ix

-- | Same as <a>liftIndex</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; liftSz succ (Sz2 2 3)
--   Sz (3 :. 4)
--   </pre>
liftSz :: Index ix => (Int -> Int) -> Sz ix -> Sz ix

-- | Same as <a>liftIndex2</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; liftSz2 (-) (Sz2 2 3) (Sz2 3 1)
--   Sz (0 :. 2)
--   </pre>
liftSz2 :: Index ix => (Int -> Int -> Int) -> Sz ix -> Sz ix -> Sz ix

-- | Same as <a>consDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; consSz (Sz1 1) (Sz2 2 3) :: Sz3
--   Sz (1 :&gt; 2 :. 3)
--   </pre>
consSz :: Index ix => Sz Ix1 -> Sz (Lower ix) -> Sz ix

-- | Same as <a>unconsDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unconsSz $ Sz3 1 2 3
--   (Sz1 1,Sz (2 :. 3))
--   </pre>
unconsSz :: Index ix => Sz ix -> (Sz Ix1, Sz (Lower ix))

-- | Same as <a>snocDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; snocSz (Sz2 2 3) (Sz1 1) :: Sz3
--   Sz (2 :&gt; 3 :. 1)
--   </pre>
snocSz :: Index ix => Sz (Lower ix) -> Sz Ix1 -> Sz ix

-- | Same as <a>unsnocDim</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; unsnocSz $ Sz3 1 2 3
--   (Sz (1 :. 2),Sz1 3)
--   </pre>
unsnocSz :: Index ix => Sz ix -> (Sz (Lower ix), Sz Ix1)

-- | Same as <a>setDimM</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; setSzM (Sz2 2 3) 2 (Sz1 1) :: IO Sz2
--   Sz (1 :. 3)
--   
--   &gt;&gt;&gt; setSzM (Sz2 2 3) 3 (Sz1 1) :: IO Sz2
--   *** Exception: IndexDimensionException: (Dim 3) for (2 :. 3)
--   </pre>
setSzM :: (MonadThrow m, Index ix) => Sz ix -> Dim -> Sz Int -> m (Sz ix)

-- | Same as <a>insertDimM</a>, but for <a>Sz</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; insertSzM (Sz2 2 3) 3 (Sz1 1) :: IO Sz3
--   Sz (1 :&gt; 2 :. 3)
--   
--   &gt;&gt;&gt; insertSzM (Sz2 2 3) 4 (Sz1 1) :: IO Sz3
--   *** Exception: IndexDimensionException: (Dim 4) for (2 :. 3)
--   </pre>
insertSzM :: (MonadThrow m, Index ix) => Sz (Lower ix) -> Dim -> Sz Int -> m (Sz ix)

-- | Same as <tt>pullOutDim</tt>, but for <a>Sz</a>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Core.Index
--   
--   &gt;&gt;&gt; pullOutSzM (Sz3 1 2 3) 3
--   (Sz1 1,Sz (2 :. 3))
--   
--   &gt;&gt;&gt; pullOutSzM (Sz3 1 2 3) 0
--   *** Exception: IndexDimensionException: (Dim 0) for (1 :&gt; 2 :. 3)
--   </pre>
pullOutSzM :: (MonadThrow m, Index ix) => Sz ix -> Dim -> m (Sz Ix1, Sz (Lower ix))

-- | Convert a size to a linear size.
toLinearSz :: Index ix => Sz ix -> Sz1

-- | Construct size from index while checking its correctness. Throws
--   <a>SizeNegativeException</a> and <a>SizeOverflowException</a>.
mkSzM :: (Index ix, MonadThrow m) => ix -> m (Sz ix)

-- | A way to select Array dimension at a value level.
newtype Dim
Dim :: Int -> Dim
[unDim] :: Dim -> Int

-- | A way to select Array dimension at a type level.
data Dimension (n :: Nat)
[DimN] :: (1 <= n, KnownNat n) => Dimension n

-- | Construct 1st dimension
pattern Dim1 :: Dimension 1

-- | Construct 2nd dimension
pattern Dim2 :: Dimension 2

-- | Construct 3rd dimension
pattern Dim3 :: Dimension 3

-- | Construct 4th dimension
pattern Dim4 :: Dimension 4

-- | Construct 5th dimension
pattern Dim5 :: Dimension 5

-- | A type level constraint that ensures index is indeed valid and that
--   supplied dimension can be safely used with it.
type IsIndexDimension ix n = (1 <= n, n <= Dimensions ix, Index ix, KnownNat n)
type family IsDimValid ix n :: Bool
type family ReportInvalidDim (dims :: Nat) (n :: Nat) isNotZero isLess :: Bool

-- | Stride provides a way to ignore elements of an array if an index is
--   divisible by a corresponding value in a stride. So, for a <tt>Stride
--   (i :. j)</tt> only elements with indices will be kept around:
--   
--   <pre>
--   ( 0 :. 0) ( 0 :. j) ( 0 :. 2j) ( 0 :. 3j) ...
--   ( i :. 0) ( i :. j) ( i :. 2j) ( i :. 3j) ...
--   (2i :. 0) (2i :. j) (2i :. 2j) (2i :. 3j) ...
--   ...
--   </pre>
--   
--   Only positive strides make sense, so <a>Stride</a> pattern synonym
--   constructor will prevent a user from creating a stride with negative
--   or zero values, thus promoting safety of the library.
--   
--   <h4><b>Examples:</b></h4>
--   
--   <ul>
--   <li>Default and minimal stride of <tt><a>Stride</a> (<a>pureIndex</a>
--   1)</tt> will have no affect and all elements will kept.</li>
--   </ul>
--   
--   <ul>
--   <li>If stride is <tt><a>Stride</a> 2</tt>, then every 2nd element
--   (i.e. with index 1, 3, 5, ..) will be skipped and only elemnts with
--   indices divisible by 2 will be kept around.</li>
--   <li>In case of two dimensions, if what you want is to keep all rows
--   divisible by 5, but keep every column intact then you'd use <tt>Stride
--   (5 :. 1)</tt>.</li>
--   </ul>
data Stride ix

-- | A safe bidirectional pattern synonym for <a>Stride</a> construction
--   that will make sure stride elements are always positive.
pattern Stride :: Index ix => ix -> Stride ix

-- | Just a helper function for unwrapping <a>Stride</a>.
unStride :: Stride ix -> ix

-- | Compute linear index with stride using the original size and index
toLinearIndexStride :: Index ix => Stride ix -> Sz ix -> ix -> Int

-- | Adjust starting index according to the stride
strideStart :: Index ix => Stride ix -> ix -> ix

-- | Adjust size according to the stride.
strideSize :: Index ix => Stride ix -> Sz ix -> Sz ix

-- | A default stride of <tt>1</tt>, where all elements are kept
oneStride :: Index ix => Stride ix

-- | Approach to be used near the borders during various transformations.
--   Whenever a function needs information not only about an element of
--   interest, but also about it's neighbors, it will go out of bounds near
--   the array edges, hence is this set of approaches that specify how to
--   handle such situation.
data Border e

-- | Fill in a constant element.
--   
--   <pre>
--              outside |  Array  | outside
--   (<a>Fill</a> 0) : 0 0 0 0 | 1 2 3 4 | 0 0 0 0
--   </pre>
Fill :: e -> Border e

-- | Wrap around from the opposite border of the array.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Wrap</a> :     1 2 3 4 | 1 2 3 4 | 1 2 3 4
--   </pre>
Wrap :: Border e

-- | Replicate the element at the edge.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Edge</a> :     1 1 1 1 | 1 2 3 4 | 4 4 4 4
--   </pre>
Edge :: Border e

-- | Mirror like reflection.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Reflect</a> :  4 3 2 1 | 1 2 3 4 | 4 3 2 1
--   </pre>
Reflect :: Border e

-- | Also mirror like reflection, but without repeating the edge element.
--   
--   <pre>
--              outside |  Array  | outside
--   <a>Continue</a> : 1 4 3 2 | 1 2 3 4 | 3 2 1 4
--   </pre>
Continue :: Border e

-- | Apply a border resolution technique to an index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; handleBorderIndex (Fill 100) (Sz (2 :. 3)) id (2 :. 3)
--   100 :. 100
--   
--   &gt;&gt;&gt; handleBorderIndex Wrap (Sz (2 :. 3)) id (2 :. 3)
--   0 :. 0
--   
--   &gt;&gt;&gt; handleBorderIndex Edge (Sz (2 :. 3)) id (2 :. 3)
--   1 :. 2
--   </pre>
handleBorderIndex :: Index ix => Border e -> Sz ix -> (ix -> e) -> ix -> e

-- | This type family will always point to a type for a dimension that is
--   one lower than the type argument.
type family Lower ix :: Type

-- | This is bread and butter of multi-dimensional array indexing. It is
--   unlikely that any of the functions in this class will be useful to a
--   regular user, unless general algorithms are being implemented that do
--   span multiple dimensions.
class (Eq ix, Ord ix, Show ix, NFData ix, Typeable ix, Eq (Lower ix), Ord (Lower ix), Show (Lower ix), NFData (Lower ix), KnownNat (Dimensions ix)) => Index ix where {
    
    -- | Type level information on how many dimensions this index has.
    type Dimensions ix :: Nat;
}

-- | What is the dimensionality of this index.
dimensions :: Index ix => proxy ix -> Dim

-- | Total number of elements in an array of this size.
totalElem :: Index ix => Sz ix -> Int

-- | Prepend a dimension to the index
consDim :: Index ix => Int -> Lower ix -> ix

-- | Take a dimension from the index from the outside
unconsDim :: Index ix => ix -> (Int, Lower ix)

-- | Apppend a dimension to the index
snocDim :: Index ix => Lower ix -> Int -> ix

-- | Take a dimension from the index from the inside
unsnocDim :: Index ix => ix -> (Lower ix, Int)

-- | Pull out value at specified dimension from the index, thus also
--   lowering it dimensionality.
pullOutDimM :: (Index ix, MonadThrow m) => ix -> Dim -> m (Int, Lower ix)

-- | Insert a dimension into the index
insertDimM :: (Index ix, MonadThrow m) => Lower ix -> Dim -> Int -> m ix

-- | Extract the value index has at specified dimension.
getDimM :: (Index ix, MonadThrow m) => ix -> Dim -> m Int

-- | Set the value for an index at specified dimension.
setDimM :: (Index ix, MonadThrow m) => ix -> Dim -> Int -> m ix

-- | Update the value for an index at specified dimension and return the
--   old value as well as the updated index.
modifyDimM :: (Index ix, MonadThrow m) => ix -> Dim -> (Int -> Int) -> m (Int, ix)

-- | Lift an <a>Int</a> to any index by replicating the value as many times
--   as there are dimensions.
pureIndex :: Index ix => Int -> ix

-- | Zip together two indices with a function
liftIndex2 :: Index ix => (Int -> Int -> Int) -> ix -> ix -> ix

-- | Map a function over an index
liftIndex :: Index ix => (Int -> Int) -> ix -> ix

-- | Perform a left fold over the index
foldlIndex :: Index ix => (a -> Int -> a) -> a -> ix -> a

-- | Perform a left fold over the index
foldlIndex :: (Index ix, Index (Lower ix)) => (a -> Int -> a) -> a -> ix -> a

-- | Check whether index is positive and is within the size.
isSafeIndex :: Index ix => Sz ix -> ix -> Bool

-- | Check whether index is positive and is within the size.
isSafeIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> Bool

-- | Convert linear index from size and index
toLinearIndex :: Index ix => Sz ix -> ix -> Ix1

-- | Convert linear index from size and index
toLinearIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> Ix1

-- | Convert linear index from size and index with an accumulator.
--   Currently is useless and will likely be removed in future versions.
toLinearIndexAcc :: Index ix => Ix1 -> ix -> ix -> Ix1

-- | Convert linear index from size and index with an accumulator.
--   Currently is useless and will likely be removed in future versions.
toLinearIndexAcc :: (Index ix, Index (Lower ix)) => Ix1 -> ix -> ix -> Ix1

-- | Compute an index from size and linear index
fromLinearIndex :: Index ix => Sz ix -> Ix1 -> ix

-- | Compute an index from size and linear index
fromLinearIndex :: (Index ix, Index (Lower ix)) => Sz ix -> Ix1 -> ix

-- | Compute an index from size and linear index using an accumulator, thus
--   trying to optimize for tail recursion while getting the index
--   computed.
fromLinearIndexAcc :: Index ix => ix -> Ix1 -> (Int, ix)

-- | Compute an index from size and linear index using an accumulator, thus
--   trying to optimize for tail recursion while getting the index
--   computed.
fromLinearIndexAcc :: (Index ix, Index (Lower ix)) => ix -> Ix1 -> (Ix1, ix)

-- | A way to make sure index is withing the bounds for the supplied size.
--   Takes two functions that will be invoked whenever index (2nd arg) is
--   outsize the supplied size (1st arg)
repairIndex :: Index ix => Sz ix -> ix -> (Sz Int -> Int -> Int) -> (Sz Int -> Int -> Int) -> ix

-- | A way to make sure index is withing the bounds for the supplied size.
--   Takes two functions that will be invoked whenever index (2nd arg) is
--   outsize the supplied size (1st arg)
repairIndex :: (Index ix, Index (Lower ix)) => Sz ix -> ix -> (Sz Int -> Int -> Int) -> (Sz Int -> Int -> Int) -> ix

-- | This function is what makes it possible to iterate over an array of
--   any dimension.
iterM :: (Index ix, Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> m a) -> m a

-- | This function is what makes it possible to iterate over an array of
--   any dimension.
iterM :: (Index ix, Index (Lower ix), Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> m a) -> m a
iterRowMajorST :: Index ix => Int -> Scheduler s a -> ix -> ix -> Sz ix -> a -> (a -> ST s (a, a)) -> (ix -> a -> ST s a) -> ST s a
iterRowMajorST :: (Index ix, Index (Lower ix)) => Int -> Scheduler s a -> ix -> ix -> Sz ix -> a -> (a -> ST s (a, a)) -> (ix -> a -> ST s a) -> ST s a

-- | Similar to <a>iterM</a>, but no restriction on a Monad.
iterF :: Index ix => ix -> ix -> ix -> (Int -> Int -> Bool) -> f a -> (ix -> f a -> f a) -> f a

-- | Similar to <a>iterM</a>, but no restriction on a Monad.
iterF :: (Index ix, Index (Lower ix)) => ix -> ix -> ix -> (Int -> Int -> Bool) -> f a -> (ix -> f a -> f a) -> f a

-- | A single step in iteration
stepNextMF :: Index ix => ix -> ix -> ix -> (Int -> Int -> Bool) -> (Maybe ix -> f a) -> f a

-- | A single step in iteration
stepNextMF :: (Index ix, Index (Lower ix)) => ix -> ix -> ix -> (Int -> Int -> Bool) -> (Maybe ix -> f a) -> f a
iterTargetRowMajorA_ :: (Index ix, Applicative f) => Int -> Int -> Sz ix -> ix -> ix -> (Ix1 -> ix -> f a) -> f ()
iterTargetRowMajorA_ :: (Index ix, Applicative f, Index (Lower ix)) => Int -> Int -> Sz ix -> ix -> ix -> (Ix1 -> ix -> f a) -> f ()
iterTargetRowMajorAccM :: (Index ix, Monad m) => Int -> Int -> Sz ix -> ix -> ix -> a -> (Ix1 -> ix -> a -> m a) -> m a
iterTargetRowMajorAccM :: (Index ix, Monad m, Index (Lower ix)) => Int -> Int -> Sz ix -> ix -> ix -> a -> (Ix1 -> ix -> a -> m a) -> m a
iterTargetRowMajorAccST :: Index ix => Int -> Int -> Scheduler s a -> Int -> Sz ix -> ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetRowMajorAccST :: (Index ix, Index (Lower ix)) => Int -> Int -> Scheduler s a -> Int -> Sz ix -> ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetRowMajorAccST_ :: Index ix => Int -> Int -> Scheduler s () -> Int -> Sz ix -> ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()
iterTargetRowMajorAccST_ :: (Index ix, Index (Lower ix)) => Int -> Int -> Scheduler s () -> Int -> Sz ix -> ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()

-- | Index with all zeros
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; zeroIndex :: Ix4
--   0 :&gt; 0 :&gt; 0 :. 0
--   </pre>
zeroIndex :: Index ix => ix

-- | Index with all ones
oneIndex :: Index ix => ix

-- | Checks whether size can hold at least one element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isZeroSz (Sz3 1 0 2)
--   True
--   </pre>
isZeroSz :: Index ix => Sz ix -> Bool

-- | Checks whether size can hold at least one element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isNotZeroSz (Sz3 1 0 2)
--   False
--   </pre>
isNotZeroSz :: Index ix => Sz ix -> Bool

-- | Get the outmost dimension of the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; headDim (2 :&gt; 3 :&gt; 4 :. 5)
--   2
--   </pre>
headDim :: Index ix => ix -> Int

-- | Drop the outmost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; tailDim (2 :&gt; 3 :&gt; 4 :. 5)
--   3 :&gt; 4 :. 5
--   </pre>
tailDim :: Index ix => ix -> Lower ix

-- | Get the innermost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lastDim (2 :&gt; 3 :&gt; 4 :. 5)
--   5
--   </pre>
lastDim :: Index ix => ix -> Int

-- | Drop the innermost dimension from the index
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; initDim (2 :&gt; 3 :&gt; 4 :. 5)
--   2 :&gt; 3 :. 4
--   </pre>
initDim :: Index ix => ix -> Lower ix

-- | Change the value from a specific dimension within the index. See
--   <a>getDimM</a> for a safer version and <a>getDimension</a> for a type
--   safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getDim' (2 :&gt; 3 :&gt; 4 :. 5) 3
--   3
--   </pre>
getDim' :: (HasCallStack, Index ix) => ix -> Dim -> Int

-- | Change the value of a specific dimension within the index. See
--   <a>setDimM</a> for a safer version and <a>setDimension</a> for a type
--   safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; setDim' (2 :&gt; 3 :&gt; 4 :. 5) 3 10
--   2 :&gt; 10 :&gt; 4 :. 5
--   </pre>
setDim' :: (HasCallStack, Index ix) => ix -> Dim -> Int -> ix

-- | Update the value of a specific dimension within the index. See
--   <a>modifyDimM</a> for a safer version and <a>modifyDimension</a> for a
--   type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; modifyDim' (2 :&gt; 3 :&gt; 4 :. 5) 2 (+ 10)
--   (4,2 :&gt; 3 :&gt; 14 :. 5)
--   </pre>
modifyDim' :: (HasCallStack, Index ix) => ix -> Dim -> (Int -> Int) -> (Int, ix)

-- | Remove a dimension from the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropDimM (2 :&gt; 3 :&gt; 4 :. 5) 3 :: Maybe Ix3
--   Just (2 :&gt; 4 :. 5)
--   
--   &gt;&gt;&gt; dropDimM (2 :&gt; 3 :&gt; 4 :. 5) 6 :: Maybe Ix3
--   Nothing
--   </pre>
dropDimM :: (MonadThrow m, Index ix) => ix -> Dim -> m (Lower ix)

-- | Remove a dimension from the index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropDim' (2 :&gt; 3 :&gt; 4 :. 5) 3
--   2 :&gt; 4 :. 5
--   </pre>
dropDim' :: (HasCallStack, Index ix) => ix -> Dim -> Lower ix

-- | Lower the dimension of the index by pulling the specified dimension.
--   See <a>pullOutDimM</a> for a safer version and <a>pullOutDimension</a>
--   for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pullOutDim' (2 :&gt; 3 :&gt; 4 :. 5) 3
--   (3,2 :&gt; 4 :. 5)
--   </pre>
pullOutDim' :: (HasCallStack, Index ix) => ix -> Dim -> (Int, Lower ix)

-- | Raise the dimension of the index by inserting one in the specified
--   dimension. See <a>insertDimM</a> for a safer version and
--   <a>insertDimension</a> for a type safe version.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertDim' (2 :&gt; 3 :&gt; 4 :. 5) 3 10 :: Ix5
--   2 :&gt; 3 :&gt; 10 :&gt; 4 :. 5
--   </pre>
insertDim' :: (HasCallStack, Index ix) => Lower ix -> Dim -> Int -> ix

-- | Get the value level <a>Dim</a> from the type level equivalent.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromDimension Dim4
--   (Dim 4)
--   
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; fromDimension (DimN :: Dimension 10)
--   (Dim 10)
--   </pre>
fromDimension :: KnownNat n => Dimension n -> Dim

-- | Type safe way to extract value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; getDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   4
--   </pre>
getDimension :: IsIndexDimension ix n => ix -> Dimension n -> Int

-- | Type safe way to set value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; setDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim4 10
--   10 :&gt; 3 :&gt; 4 :. 5
--   </pre>
setDimension :: IsIndexDimension ix n => ix -> Dimension n -> Int -> ix

-- | Type safe way to set value of index at a particular dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; modifyDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim3 (+ 2)
--   (3,2 :&gt; 5 :&gt; 4 :. 5)
--   </pre>
modifyDimension :: IsIndexDimension ix n => ix -> Dimension n -> (Int -> Int) -> (Int, ix)

-- | Type safe way of dropping a particular dimension, thus lowering index
--   dimensionality.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; dropDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   2 :&gt; 3 :. 5
--   </pre>
dropDimension :: IsIndexDimension ix n => ix -> Dimension n -> Lower ix

-- | Type safe way of pulling out a particular dimension, thus lowering
--   index dimensionality and returning the value at specified dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; pullOutDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2
--   (4,2 :&gt; 3 :. 5)
--   </pre>
pullOutDimension :: IsIndexDimension ix n => ix -> Dimension n -> (Int, Lower ix)

-- | Type safe way of inserting a particular dimension, thus raising index
--   dimensionality.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim5 10 :: Ix5
--   10 :&gt; 2 :&gt; 3 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim4 10 :: Ix5
--   2 :&gt; 10 :&gt; 3 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim3 10 :: Ix5
--   2 :&gt; 3 :&gt; 10 :&gt; 4 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim2 10 :: Ix5
--   2 :&gt; 3 :&gt; 4 :&gt; 10 :. 5
--   
--   &gt;&gt;&gt; insertDimension (2 :&gt; 3 :&gt; 4 :. 5) Dim1 10 :: Ix5
--   2 :&gt; 3 :&gt; 4 :&gt; 5 :. 10
--   </pre>
insertDimension :: IsIndexDimension ix n => Lower ix -> Dimension n -> Int -> ix

-- | Row-major iterator for the index. Same as <a>iterM</a>, but pure.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; iter (Ix1 0) 1000 1 (&lt;) 0 (+)
--   499500
--   
--   &gt;&gt;&gt; iter (0 :. 0) (2 :. 3) oneIndex (&lt;) 100 $ \ (i :. j) acc -&gt; (acc + i) * (j + 1)
--   3615
--   </pre>
iter :: Index ix => ix -> ix -> ix -> (Int -> Int -> Bool) -> a -> (ix -> a -> a) -> a

-- | Same as <a>iterM</a>, Iterate over a region with specific step, but
--   using <a>Applicative</a> instead of a <a>Monad</a> and don't bother
--   with accumulator or return value.
iterA_ :: forall ix f a. (Index ix, Applicative f) => ix -> ix -> ix -> (Int -> Int -> Bool) -> (ix -> f a) -> f ()

-- | Same as <a>iterM</a>, but don't bother with accumulator and return
--   value.

-- | <i>Deprecated: In favor of more lax <a>iterA_</a></i>
iterM_ :: (Index ix, Monad m) => ix -> ix -> ix -> (Int -> Int -> Bool) -> (ix -> m a) -> m ()

-- | Iterate over N-dimensional space linearly from start to end in
--   row-major fashion with an accumulator
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sz = Sz2 3 4
--   
--   &gt;&gt;&gt; iterLinearM sz 0 3 1 (&lt;) 100 $ \ k ix acc -&gt; (acc + k) &lt;$ print (fromLinearIndex sz k == ix)
--   True
--   True
--   True
--   103
--   </pre>
iterLinearM :: (Index ix, Monad m) => Sz ix -> Int -> Int -> Int -> (Int -> Int -> Bool) -> a -> (Int -> ix -> a -> m a) -> m a

-- | Same as <a>iterLinearM</a>, except without an accumulator.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sz = Sz2 3 4
--   
--   &gt;&gt;&gt; iterLinearM_ sz 0 3 1 (&lt;) $ \ k ix -&gt; print (toLinearIndex sz ix == k)
--   True
--   True
--   True
--   </pre>
iterLinearM_ :: (Index ix, Monad m) => Sz ix -> Int -> Int -> Int -> (Int -> Int -> Bool) -> (Int -> ix -> m ()) -> m ()

-- | Efficient loop with an accumulator
loop :: Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> a) -> a
loopF :: Int -> (Int -> Bool) -> (Int -> Int) -> f a -> (Int -> f a -> f a) -> f a
nextMaybeF :: Int -> (Int -> Bool) -> (Int -> Int) -> (Maybe Int -> f a) -> f a

-- | Applicative loop. Use monadic <a>loopM</a> when possible, since it
--   will be more efficient.
loopA :: Applicative f => Int -> (Int -> Bool) -> (Int -> Int) -> f b -> (Int -> f (b -> b)) -> f b

-- | Efficient Applicative loop. Result of each iteration is discarded.
--   
--   <pre>
--   loopA_ initial cond incr f === loopA initial cond incr (pure ()) (\i -&gt; id &lt;$ f i)
--   </pre>
loopA_ :: Applicative f => Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> f a) -> f ()

-- | Efficient monadic loop with an accumulator
--   
--   <pre>
--   &gt;&gt;&gt; loopM 1 (&lt; 20) (+ 2) [] (\i a -&gt; Just (i:a))
--   Just [19,17,15,13,11,9,7,5,3,1]
--   </pre>
loopM :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> m a) -> m a

-- | Efficient monadic loop. Result of each iteration is discarded.

-- | <i>Deprecated: In favor of <a>loopA_</a></i>
loopM_ :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> m a) -> m ()

-- | Efficient monadic loop with an accumulator and extra linear index
--   incremented by 1.
--   
--   <pre>
--   &gt;&gt;&gt; iloopM 100 1 (&lt; 20) (+ 2) [] (\i ix a -&gt; Just ((i, ix) : a))
--   Just [(109,19),(108,17),(107,15),(106,13),(105,11),(104,9),(103,7),(102,5),(101,3),(100,1)]
--   </pre>
iloopM :: Monad m => Int -> Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> Int -> a -> m a) -> m a

-- | Efficient monadic loop with extra linear index incremented by 1.
--   
--   <pre>
--   &gt;&gt;&gt; iloopA_ 100 1 (&lt; 10) (+ 2) (\i ix -&gt; print (i, ix))
--   (100,1)
--   (101,3)
--   (102,5)
--   (103,7)
--   (104,9)
--   </pre>
iloopA_ :: Applicative f => Int -> Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> Int -> f a) -> f ()

-- | Similar to <a>loopM_</a> except the action accepts not only the value
--   for current step, but also for the next one as well.
loopNextM :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> Int -> a -> m a) -> m a

-- | Similar to <a>loopM_</a> except the action accepts not only the value
--   for current step, but also for the next one as well.
loopNextA_ :: Applicative f => Int -> (Int -> Bool) -> (Int -> Int) -> (Int -> Int -> f a) -> f ()

-- | Similar to <a>loopM</a>, but way less efficient monadic loop with an
--   accumulator that reverses the direction of action application. eg:
--   
--   <pre>
--   &gt;&gt;&gt; loopDeepM 1 (&lt; 20) (+ 2) [] (\i a -&gt; Just (i:a))
--   Just [1,3,5,7,9,11,13,15,17,19]
--   </pre>
--   
--   Equivalent to:
--   
--   <pre>
--   &gt;&gt;&gt; loopM 19 (&gt;= 1) (subtract 2) [] (\i a -&gt; Just (i:a))
--   Just [1,3,5,7,9,11,13,15,17,19]
--   </pre>
loopDeepM :: Monad m => Int -> (Int -> Bool) -> (Int -> Int) -> a -> (Int -> a -> m a) -> m a

-- | Divide length in chunks and apply a function to the computed results
splitLinearly :: Int -> Int -> (Int -> Int -> a) -> a

-- | Iterator that expects an action that accepts starting linear index as
--   well as the ending
splitLinearlyM :: MonadPrimBase s m => Scheduler s a -> Int -> (Int -> Int -> m a) -> m ()

-- | Iterator that expects an action that accepts starting linear index as
--   well as the ending
splitLinearlyM_ :: MonadPrimBase s m => Scheduler s () -> Int -> (Int -> Int -> m ()) -> m ()

-- | Iterator that can be used to split computation amongst different
--   workers. For monadic generator see <a>splitLinearlyWithM_</a>.
splitLinearlyWith_ :: MonadPrimBase s m => Scheduler s () -> Int -> (Int -> b) -> (Int -> b -> m ()) -> m ()

-- | Iterator that can be used to split computation jobs
splitLinearlyWithM_ :: MonadPrimBase s m => Scheduler s () -> Int -> (Int -> m b) -> (Int -> b -> m c) -> m ()

-- | Iterator that can be used to split computation jobs
splitLinearlyWithStartAtM_ :: MonadPrimBase s m => Scheduler s () -> Int -> Int -> (Int -> m b) -> (Int -> b -> m c) -> m ()

-- | Iterator that can be used to split computation jobs, while using a
--   stateful scheduler.
splitLinearlyWithStatefulM_ :: MonadUnliftIO m => SchedulerWS ws () -> Int -> (Int -> ws -> m b) -> (Int -> b -> m c) -> m ()

-- | Linear iterator that supports multiplying factor
iterLinearST_ :: Int -> Scheduler s () -> Int -> Int -> Int -> (Int -> ST s a) -> ST s ()

-- | Linear iterator that supports multiplying factor and accumulator, but
--   the results are discarded.
iterLinearAccST_ :: Int -> Scheduler s () -> Int -> Int -> Int -> a -> (a -> ST s (a, a)) -> (Int -> a -> ST s a) -> ST s ()

-- | Linear iterator that supports multiplying factor and accumulator.
--   Results of actions are stored in the scheduler.
iterLinearAccST :: Int -> Scheduler s a -> Int -> Int -> Int -> a -> (a -> ST s (a, a)) -> (Int -> a -> ST s a) -> ST s a

-- | Helper for figuring out the chunk length and slack start
splitNumChunks :: Int -> Int -> Int -> (Int, Int)

-- | Helper for adjusting stride of a chunk
stepStartAdjust :: Int -> Int -> Int

-- | This is a major helper function for fair splitting and parallelization
--   of work with ability to use some arbitrary accumulator and splittable
--   seed
splitWorkWithFactorST :: Int -> Scheduler s a -> Int -> Int -> Int -> b -> (b -> ST s (b, b)) -> (Int -> Int -> Int -> Int -> b -> ST s a) -> ST s b

-- | Internal version of a <a>scheduleWork</a> that will be replaced by
--   <a>scheduleWork_</a> by the compiler whenever action produces
--   <tt>()</tt>
scheduleMassivWork :: PrimBase m => Scheduler (PrimState m) a -> m a -> m ()

-- | Selects an optimal scheduler for the supplied strategy, but it works
--   only in <a>IO</a>
withMassivScheduler_ :: Comp -> (Scheduler RealWorld () -> IO ()) -> IO ()
class Iterator it

-- | Iterate over a target region using linear index with access to the
--   source index, which adjusted according to the stride. Use
--   <a>iterTargetM</a> if you need an accumulator.
iterTargetA_ :: (Iterator it, Index ix, Applicative f) => it -> Int -> Sz ix -> ix -> Stride ix -> (Ix1 -> ix -> f a) -> f ()

-- | Iterate over a target region using linear index with access to the
--   source index, which adjusted according to the stride.
iterTargetM :: (Iterator it, Index ix, Monad m) => it -> Ix1 -> Sz ix -> ix -> Stride ix -> a -> (Ix1 -> ix -> a -> m a) -> m a
iterTargetWithStrideAccST :: (Iterator it, Index ix) => it -> Scheduler s a -> Ix1 -> Sz ix -> ix -> Stride ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetWithStrideAccST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> ix -> Stride ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()

-- | Iterate over a region with a monadic action and accumulator.
iterFullM :: (Iterator it, Index ix, Monad m) => it -> ix -> Sz ix -> a -> (ix -> a -> m a) -> m a

-- | Iterate over a region with an applicative action ignoring the result.
iterFullA_ :: (Iterator it, Index ix, Applicative f) => it -> ix -> Sz ix -> (ix -> f a) -> f ()

-- | Iterate over a region in a ST monad with access to <a>Scheduler</a>.
iterFullAccST :: (Iterator it, Index ix) => it -> Scheduler s a -> ix -> Sz ix -> a -> (a -> ST s (a, a)) -> (ix -> a -> ST s a) -> ST s a
iterTargetFullAccST :: (Iterator it, Index ix) => it -> Scheduler s a -> Ix1 -> Sz ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetFullAccST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()
iterTargetFullST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> (Ix1 -> ix -> ST s ()) -> ST s ()

-- | Iterate over a target array with a stride without an accumulator
iterTargetWithStrideST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> ix -> Stride ix -> (Ix1 -> ix -> ST s a) -> ST s ()
iterTargetAccST :: (Iterator it, Index ix) => it -> Scheduler s a -> Ix1 -> Sz ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetAccST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()
iterTargetFullWithStrideAccST :: (Iterator it, Index ix) => it -> Scheduler s a -> Ix1 -> Sz ix -> Stride ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s a
iterTargetFullWithStrideAccST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> Stride ix -> a -> (a -> ST s (a, a)) -> (Ix1 -> ix -> a -> ST s a) -> ST s ()
iterTargetST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> ix -> (Ix1 -> ix -> ST s ()) -> ST s ()
iterTargetFullWithStrideST_ :: (Iterator it, Index ix) => it -> Scheduler s () -> Ix1 -> Sz ix -> Stride ix -> (Ix1 -> ix -> ST s ()) -> ST s ()

-- | Default iterator that parallelizes work in linear chunks. Supplied
--   factor will be used to schedule that many jobs per capability.
data RowMajor
pattern RowMajor :: Int -> RowMajor

-- | Default row major iterator with multiplying factor set to <tt>8</tt>.
defRowMajor :: RowMajor
newtype RowMajorLinear
RowMajorLinear :: Int -> RowMajorLinear
defRowMajorLinear :: RowMajorLinear

-- | Parallelizing unbalanced computation (i.e. computing some elements of
--   the array is much more expensive then the others) it can be benefitial
--   to interleave iteration. Perfect example of this would be a ray tracer
--   or the Mandelbrot set.
--   
--   iteration without parallelization is equivalent to <a>RowMajor</a>
data RowMajorUnbalanced
pattern RowMajorUnbalanced :: Int -> RowMajorUnbalanced
defRowMajorUnbalanced :: RowMajorUnbalanced

-- | Another 1-dimensional index type synonym for <a>Int</a>, same as
--   <a>Ix1</a> and is here just for consistency.
type Ix1T = Int

-- | 2-dimensional index as tuple of <a>Int</a>s.
type Ix2T = (Int, Int)

-- | Convert an <a>Int</a> tuple to <a>Ix2</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx2 (2, 3)
--   2 :. 3
--   </pre>
toIx2 :: Ix2T -> Ix2

-- | Convert an <a>Ix2</a> to <a>Int</a> tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx2 (2 :. 3)
--   (2,3)
--   </pre>
fromIx2 :: Ix2 -> Ix2T

-- | 3-dimensional index as 3-tuple of <a>Int</a>s.
type Ix3T = (Int, Int, Int)

-- | Convert a <a>Int</a> 3-tuple to <a>Ix3</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx3 (1, 2, 3)
--   1 :&gt; 2 :. 3
--   </pre>
toIx3 :: Ix3T -> Ix3

-- | Convert an <a>Ix3</a> to <a>Int</a> 3-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx3 (1 :&gt;  2 :. 3)
--   (1,2,3)
--   </pre>
fromIx3 :: Ix3 -> Ix3T

-- | 4-dimensional index as 4-tuple of <a>Int</a>s.
type Ix4T = (Int, Int, Int, Int)

-- | Convert a <a>Int</a> 4-tuple to <a>Ix4</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx4 (1, 2, 3, 4)
--   1 :&gt; 2 :&gt; 3 :. 4
--   </pre>
toIx4 :: Ix4T -> Ix4

-- | Convert an <a>Ix4</a> to <a>Int</a> 4-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx4 (1 :&gt; 2 :&gt; 3 :. 4)
--   (1,2,3,4)
--   </pre>
fromIx4 :: Ix4 -> Ix4T

-- | 5-dimensional index as 5-tuple of <a>Int</a>s.
type Ix5T = (Int, Int, Int, Int, Int)

-- | Convert a <a>Int</a> 5-tuple to <a>Ix5</a>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; toIx5 (1, 2, 3, 4, 5)
--   1 :&gt; 2 :&gt; 3 :&gt; 4 :. 5
--   </pre>
toIx5 :: Ix5T -> Ix5

-- | Convert an <a>Ix5</a> to <a>Int</a> 5-tuple
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; fromIx5 (1 :&gt; 2 :&gt; 3 :&gt; 4 :. 5)
--   (1,2,3,4,5)
--   </pre>
fromIx5 :: Ix5 -> Ix5T

-- | Exceptions that get thrown when there is a problem with an index, size
--   or dimension.
data IndexException

-- | Index contains a zero value along one of the dimensions.
[IndexZeroException] :: Index ix => !ix -> IndexException

-- | Dimension is out of reach.
[IndexDimensionException] :: (NFData ix, Eq ix, Show ix, Typeable ix) => !ix -> !Dim -> IndexException

-- | Index is out of bounds.
[IndexOutOfBoundsException] :: Index ix => !Sz ix -> !ix -> IndexException

-- | Exception that indicates an issue with an array size.
data SizeException

-- | Two sizes are expected to be equal along some or all dimensions, but
--   they are not.
[SizeMismatchException] :: Index ix => !Sz ix -> !Sz ix -> SizeException

-- | Total number of elements does not match between the two sizes.
[SizeElementsMismatchException] :: (Index ix, Index ix') => !Sz ix -> !Sz ix' -> SizeException

-- | Described subregion is too big for the specified size.
[SizeSubregionException] :: Index ix => !Sz ix -> !ix -> !Sz ix -> SizeException

-- | An array with the size cannot contain any elements.
[SizeEmptyException] :: Index ix => !Sz ix -> SizeException

-- | Total number of elements is too large resulting in overflow.
[SizeOverflowException] :: Index ix => !Sz ix -> SizeException

-- | At least one dimensions contain a negative value.
[SizeNegativeException] :: Index ix => !Sz ix -> SizeException

-- | Exception that can happen upon conversion of a ragged type array into
--   the rectangular kind. Which means conversion from lists is susceptible
--   to this exception.
data ShapeException

-- | Across a specific dimension there was not enough elements for the
--   supplied size
DimTooShortException :: !Dim -> !Sz Ix1 -> !Sz Ix1 -> ShapeException

-- | Across a specific dimension there was too many elements for the
--   supplied size
DimTooLongException :: !Dim -> !Sz Ix1 -> !Sz Ix1 -> ShapeException

-- | Expected an empty size, but the shape was not empty.
ShapeNonEmpty :: ShapeException

-- | Throw <a>SizeElementsMismatchException</a> whenever number of elements
--   in both sizes do not match.
guardNumberOfElements :: (MonadThrow m, Index ix, Index ix') => Sz ix -> Sz ix' -> m ()

-- | This is used by the <tt>unsafe-checks</tt> cabal flag.
indexAssert :: String -> (a -> Sz ix) -> (a -> ix -> e) -> a -> ix -> e

-- | This is used by <tt>INDEX_CHECK</tt> macro and thus used whenever the
--   <tt>unsafe-checks</tt> cabal flag is on.

-- | <i>Deprecated: In favor of <a>indexAssert</a> that uses
--   HasCallStack</i>
indexWith :: Index ix => String -> Int -> String -> (arr -> Sz ix) -> (arr -> ix -> e) -> arr -> ix -> e
instance GHC.Show.Show e => GHC.Show.Show (Data.Massiv.Core.Index.Border e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Data.Massiv.Core.Index.Border e)
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Data.Massiv.Core.Index.Border e)


module Data.Massiv.Core.Operations
class (Size r, Num e) => FoldNumeric r e

-- | Compute sum of all elements in the array
sumArray :: (FoldNumeric r e, Index ix) => Array r ix e -> e

-- | Compute product of all elements in the array
productArray :: (FoldNumeric r e, Index ix) => Array r ix e -> e

-- | Raise each element in the array to some non-negative power and sum the
--   results
powerSumArray :: (FoldNumeric r e, Index ix) => Array r ix e -> Int -> e

-- | Compute dot product without any extraneous checks
unsafeDotProduct :: (FoldNumeric r e, Index ix) => Array r ix e -> Array r ix e -> e

-- | Fold over an array
foldArray :: (FoldNumeric r e, Index ix) => (e -> e -> e) -> e -> Array r ix e -> e
defaultPowerSumArray :: (Index ix, Source r e, Num e) => Array r ix e -> Int -> e
defaultUnsafeDotProduct :: (Num e, Index ix, Source r e) => Array r ix e -> Array r ix e -> e
defaultFoldArray :: (Index ix, Source r e) => (e -> e -> e) -> e -> Array r ix e -> e
class FoldNumeric r e => Numeric r e
plusScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
minusScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
scalarMinus :: (Numeric r e, Index ix) => e -> Array r ix e -> Array r ix e
multiplyScalar :: (Numeric r e, Index ix) => Array r ix e -> e -> Array r ix e
absPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e
additionPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
subtractionPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
multiplicationPointwise :: (Numeric r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e

-- | Raise each element of the array to the power
powerPointwise :: (Numeric r e, Index ix) => Array r ix e -> Int -> Array r ix e
unsafeLiftArray :: (Numeric r e, Index ix) => (e -> e) -> Array r ix e -> Array r ix e
unsafeLiftArray2 :: (Numeric r e, Index ix) => (e -> e -> e) -> Array r ix e -> Array r ix e -> Array r ix e
defaultUnsafeLiftArray :: (Load r ix e, Source r e) => (e -> e) -> Array r ix e -> Array r ix e
defaultUnsafeLiftArray2 :: (Load r ix e, Source r e) => (e -> e -> e) -> Array r ix e -> Array r ix e -> Array r ix e
class (Numeric r e, Floating e) => NumericFloat r e
divideScalar :: (NumericFloat r e, Index ix) => Array r ix e -> e -> Array r ix e
scalarDivide :: (NumericFloat r e, Index ix) => e -> Array r ix e -> Array r ix e
divisionPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e -> Array r ix e
recipPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e
sqrtPointwise :: (NumericFloat r e, Index ix) => Array r ix e -> Array r ix e


module Data.Massiv.Core.List
data L
L :: L

-- | The array family. Representations <tt>r</tt> describe how data is
--   arranged or computed. All arrays have a common property that each
--   index <tt>ix</tt> always maps to the same unique element <tt>e</tt>,
--   even if that element does not yet exist in memory and the array has to
--   be computed in order to get the value of that element. Data is always
--   arranged in a nested row-major fashion. Rank of an array is specified
--   by <tt><a>Dimensions</a> ix</tt>.
data family Array r ix e :: Type
newtype List ix e
List :: [Elt ix e] -> List ix e
[unList] :: List ix e -> [Elt ix e]

-- | Construct an array backed by linked lists from any source array
toListArray :: (Ragged L ix e, Shape r ix, Source r e) => Array r ix e -> Array L ix e

-- | Helper function for declaring <a>Show</a> instances for arrays
showsArrayPrec :: forall r r' ix e. (Ragged L ix e, Load r ix e, Load r' ix e, Source r' e, Show e) => (Array r ix e -> Array r' ix e) -> Int -> Array r ix e -> ShowS

-- | Helper function for declaring <a>Show</a> instances for arrays
showArrayList :: Show arr => [arr] -> String -> String
type family ListItem ix e :: Type
instance GHC.Types.Coercible (Data.Massiv.Core.List.Elt ix e) (Data.Massiv.Core.List.ListItem ix e) => GHC.IsList.IsList (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L ix e)
instance Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1
instance Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L Data.Massiv.Core.Index.Ix.Ix2
instance (Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Ix.Ix (n GHC.TypeNats.- 1)), Data.Massiv.Core.Index.Internal.Index (Data.Massiv.Core.Index.Ix.IxN n)) => Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Ix.IxN n)
instance Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance (Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L ix, Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e) => Data.Massiv.Core.Common.Load Data.Massiv.Core.List.L ix e
instance Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L Data.Massiv.Core.Index.Ix.Ix2 e
instance (Data.Massiv.Core.Common.Shape Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Ix.IxN n), Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Ix.Ix (n GHC.TypeNats.- 1)) e, GHC.Types.Coercible (Data.Massiv.Core.List.Elt (Data.Massiv.Core.Index.Ix.Ix (n GHC.TypeNats.- 1)) e) (Data.Massiv.Core.List.ListItem (Data.Massiv.Core.Index.Ix.Ix (n GHC.TypeNats.- 1)) e)) => Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L (Data.Massiv.Core.Index.Ix.IxN n) e
instance Data.Massiv.Core.Common.Strategy Data.Massiv.Core.List.L
instance (Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Core.Common.Array Data.Massiv.Core.List.L ix e)
instance (Data.Massiv.Core.Common.Ragged Data.Massiv.Core.List.L ix e, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Core.List.List ix e)
instance Data.Massiv.Core.Common.Stream Data.Massiv.Core.List.L Data.Massiv.Core.Index.Internal.Ix1 e
instance GHC.Types.Coercible (Data.Massiv.Core.List.Elt ix e) (Data.Massiv.Core.List.ListItem ix e) => GHC.IsList.IsList (Data.Massiv.Core.List.List ix e)


module Data.Massiv.Core

-- | The array family. Representations <tt>r</tt> describe how data is
--   arranged or computed. All arrays have a common property that each
--   index <tt>ix</tt> always maps to the same unique element <tt>e</tt>,
--   even if that element does not yet exist in memory and the array has to
--   be computed in order to get the value of that element. Data is always
--   arranged in a nested row-major fashion. Rank of an array is specified
--   by <tt><a>Dimensions</a> ix</tt>.
data family Array r ix e :: Type
newtype List ix e
List :: [Elt ix e] -> List ix e
[unList] :: List ix e -> [Elt ix e]

-- | Type synonym for a single dimension array, or simply a flat vector.
type Vector r e = Array r Ix1 e

-- | Type synonym for a single dimension mutable array, or simply a flat
--   mutable vector.
type MVector s r e = MArray s r Ix1 e

-- | Type synonym for a two-dimentsional array, or simply a matrix.
type Matrix r e = Array r Ix2 e

-- | Type synonym for a two-dimentsional mutable array, or simply a mutable
--   matrix.
type MMatrix s r e = MArray s r Ix2 e

-- | Any array that can be computed and loaded into memory
class (Strategy r, Shape r ix) => Load r ix e

-- | Iterate over an array with a ST action that is applied to each element
--   and its index.
iterArrayLinearST_ :: Load r ix e => Scheduler s () -> Array r ix e -> (Int -> e -> ST s ()) -> ST s ()

-- | Similar to <a>iterArrayLinearST_</a>. Except it also accepts a
--   function that is potentially optimized for setting many cells in a
--   region to the same value.
iterArrayLinearWithSetST_ :: Load r ix e => Scheduler s () -> Array r ix e -> (Ix1 -> e -> ST s ()) -> (Ix1 -> Sz1 -> e -> ST s ()) -> ST s ()
class Load r ix e => Stream r ix e
toStream :: Stream r ix e => Array r ix e -> Steps Id e
toStreamIx :: Stream r ix e => Array r ix e -> Steps Id (ix, e)

-- | Arrays that can be used as source to practically any manipulation
--   function.
class (Strategy r, Size r) => Source r e

-- | Prefered indexing function.
data PrefIndex ix e
PrefIndex :: (ix -> e) -> PrefIndex ix e
PrefIndexLinear :: (Int -> e) -> PrefIndex ix e

-- | Arrays that have information about their size availible in constant
--   time.
class Size r

-- | The shape of an array. It is different from <a>Size</a> in that it can
--   be applicable to non-square matrices and might not be available in
--   constant time.
class Index ix => Shape r ix

-- | <i>O(1)</i> - Check what do we know about the number of elements
--   without doing any work
linearSizeHint :: Shape r ix => Array r ix e -> LengthHint

-- | <i>O(n)</i> - possibly iterate over the whole array before producing
--   the answer
linearSize :: Shape r ix => Array r ix e -> Sz1

-- | <i>O(n)</i> - possibly iterate over the whole array before producing
--   the answer
linearSize :: (Shape r ix, Size r) => Array r ix e -> Sz1

-- | <i>O(n)</i> - Rectangular size of an array that is inferred from
--   looking at the first row in each dimensions. For rectangular arrays
--   this is the same as <a>size</a>
outerSize :: Shape r ix => Array r ix e -> Sz ix

-- | <i>O(n)</i> - Rectangular size of an array that is inferred from
--   looking at the first row in each dimensions. For rectangular arrays
--   this is the same as <a>size</a>
outerSize :: (Shape r ix, Size r) => Array r ix e -> Sz ix

-- | <i>O(1)</i> - Get the possible maximum linear size of an immutabe
--   array. If the lookup of size in constant time is not possible,
--   <a>Nothing</a> will be returned. This value will be used as the
--   initial size of the mutable array into which the loading will happen.
maxLinearSize :: Shape r ix => Array r ix e -> Maybe Sz1

-- | <i>O(1)</i> - Check whether an array is empty or not.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (11 :. 21)
--   False
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (10 :. 21)
--   True
--   
--   &gt;&gt;&gt; isNull (empty :: Array D Ix5 Int)
--   True
--   
--   &gt;&gt;&gt; isNull $ sfromList []
--   True
--   </pre>
isNull :: Shape r ix => Array r ix e -> Bool

-- | Size hint
data LengthHint

-- | Exact known size
LengthExact :: Sz1 -> LengthHint

-- | Upper bound on the size
LengthMax :: Sz1 -> LengthHint

-- | Unknown size
LengthUnknown :: LengthHint
class Load r ix e => StrideLoad r ix e

-- | Load an array into memory with stride. Default implementation requires
--   an instance of <a>Source</a>.
iterArrayLinearWithStrideST_ :: StrideLoad r ix e => Scheduler s () -> Stride ix -> Sz ix -> Array r ix e -> (Int -> e -> ST s ()) -> ST s ()

-- | Load an array into memory with stride. Default implementation requires
--   an instance of <a>Source</a>.
iterArrayLinearWithStrideST_ :: (StrideLoad r ix e, Source r e) => Scheduler s () -> Stride ix -> Sz ix -> Array r ix e -> (Int -> e -> ST s ()) -> ST s ()

-- | Manifest arrays are backed by actual memory and values are looked up
--   versus computed as it is with delayed arrays. Because manifest arrays
--   are located in memory their contents can be mutated once thawed into
--   <a>MArray</a>. The process of changed a mutable <a>MArray</a> back
--   into an immutable <a>Array</a> is called freezing.
class Source r e => Manifest r e

-- | Starting with massiv-1.0 <a>Mutable</a> and <a>Manifest</a> are
--   synonymous. Since massiv-1.1 it is deprecated and will be removed in
--   massiv-1.2

-- | <i>Deprecated: In favor of <a>Manifest</a></i>
type Mutable r e = Manifest r e
class (IsList (Array r ix e), Load r ix e) => Ragged r ix e
data L
L :: L
type family ListItem ix e :: Type

-- | Main type for scheduling work. See <a>withScheduler</a> or
--   <a>withScheduler_</a> for ways to construct and use this data type.
data () => Scheduler s a

-- | This is a wrapper around <a>Scheduler</a>, but it also keeps a
--   separate state for each individual worker. See <a>withSchedulerWS</a>
--   or <a>withSchedulerWS_</a> for ways to construct and use this data
--   type.
data () => SchedulerWS ws a
class Typeable r => Strategy r

-- | Computation strategy to use when scheduling work.
data () => Comp

-- | Sequential computation
Seq :: Comp

-- | Schedule workers to run on specific capabilities. Specifying an empty
--   list <tt><a>ParOn</a> []</tt> or using <a>Par</a> will result in
--   utilization of all available capabilities.
ParOn :: ![Int] -> Comp

-- | Specify the number of workers that will be handling all the jobs.
--   Difference from <a>ParOn</a> is that workers can jump between cores.
--   Using <tt><a>ParN</a> 0</tt> will result in using all available
--   capabilities.
ParN :: {-# UNPACK #-} !Word16 -> Comp

-- | Parallel computation using all available cores. Same as
--   <tt><a>ParOn</a> []</tt>
pattern Par :: Comp

-- | Parallel computation using all available cores. Same as
--   <tt><a>ParN</a> 0</tt>
pattern Par' :: Comp

-- | Get computation strategy of this array
getComp :: Strategy r => Array r ix e -> Comp

-- | Set computation strategy for this array
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = singleton @DL @Ix1 @Int 0
--   
--   &gt;&gt;&gt; a
--   Array DL Seq (Sz1 1)
--     [ 0 ]
--   
--   &gt;&gt;&gt; setComp (ParN 6) a -- use 6 capabilities
--   Array DL (ParN 6) (Sz1 1)
--     [ 0 ]
--   </pre>
setComp :: Strategy r => Comp -> Array r ix e -> Array r ix e

-- | Append computation strategy using <a>Comp</a>'s <a>Monoid</a>
--   instance.
appComp :: Strategy r => Comp -> Array r ix e -> Array r ix e

-- | Each worker is capable of keeping it's own state, that can be share
--   for different schedulers, but not at the same time. In other words
--   using the same <a>WorkerStates</a> on <a>withSchedulerS</a>
--   concurrently will result in an error. Can be initialized with
--   <a>initWorkerStates</a>
data () => WorkerStates ws

-- | Initialize a separate state for each worker.
initWorkerStates :: MonadIO m => Comp -> (WorkerId -> m ws) -> m (WorkerStates ws)

-- | Schedule an action to be picked up and computed by a worker from a
--   pool of jobs. Similar to <a>scheduleWorkId</a>, except the job doesn't
--   get the worker id.
scheduleWork :: MonadPrimBase s m => Scheduler s a -> m a -> m ()

-- | Same as <a>scheduleWork</a>, but only for a <a>Scheduler</a> that
--   doesn't keep the results.
scheduleWork_ :: MonadPrimBase s m => Scheduler s () -> m () -> m ()
class (Size r, Num e) => FoldNumeric r e
class FoldNumeric r e => Numeric r e
class (Numeric r e, Floating e) => NumericFloat r e

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, HasCallStack, Exception e) => e -> m a

-- | Exceptions that get thrown when there is a problem with an index, size
--   or dimension.
data IndexException

-- | Index contains a zero value along one of the dimensions.
[IndexZeroException] :: Index ix => !ix -> IndexException

-- | Dimension is out of reach.
[IndexDimensionException] :: (NFData ix, Eq ix, Show ix, Typeable ix) => !ix -> !Dim -> IndexException

-- | Index is out of bounds.
[IndexOutOfBoundsException] :: Index ix => !Sz ix -> !ix -> IndexException

-- | Exception that indicates an issue with an array size.
data SizeException

-- | Two sizes are expected to be equal along some or all dimensions, but
--   they are not.
[SizeMismatchException] :: Index ix => !Sz ix -> !Sz ix -> SizeException

-- | Total number of elements does not match between the two sizes.
[SizeElementsMismatchException] :: (Index ix, Index ix') => !Sz ix -> !Sz ix' -> SizeException

-- | Described subregion is too big for the specified size.
[SizeSubregionException] :: Index ix => !Sz ix -> !ix -> !Sz ix -> SizeException

-- | An array with the size cannot contain any elements.
[SizeEmptyException] :: Index ix => !Sz ix -> SizeException

-- | Total number of elements is too large resulting in overflow.
[SizeOverflowException] :: Index ix => !Sz ix -> SizeException

-- | At least one dimensions contain a negative value.
[SizeNegativeException] :: Index ix => !Sz ix -> SizeException

-- | Exception that can happen upon conversion of a ragged type array into
--   the rectangular kind. Which means conversion from lists is susceptible
--   to this exception.
data ShapeException

-- | Across a specific dimension there was not enough elements for the
--   supplied size
DimTooShortException :: !Dim -> !Sz Ix1 -> !Sz Ix1 -> ShapeException

-- | Across a specific dimension there was too many elements for the
--   supplied size
DimTooLongException :: !Dim -> !Sz Ix1 -> !Sz Ix1 -> ShapeException

-- | Expected an empty size, but the shape was not empty.
ShapeNonEmpty :: ShapeException

-- | Throw an impossible error.
throwImpossible :: HasCallStack => Exception e => e -> a

-- | Throw an error on <a>Left</a> or produce the result on <a>Right</a>.
--   Exception type is lost, so do not expect to be able to catch it as
--   such. Stick to <a>IO</a> if you need exception control flow.
throwEither :: HasCallStack => Either SomeException a -> a

-- | An error that gets thrown when an unitialized element of a boxed array
--   gets accessed. Can only happen when array was constructed with
--   <a>unsafeNew</a>.
data Uninitialized
Uninitialized :: Uninitialized

-- | Throw <a>SizeElementsMismatchException</a> whenever number of elements
--   in both sizes do not match.
guardNumberOfElements :: (MonadThrow m, Index ix, Index ix') => Sz ix -> Sz ix' -> m ()

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data () => SomeException

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Monads which allow their actions to be run in <a>IO</a>.
--   
--   While <a>MonadIO</a> allows an <a>IO</a> action to be lifted into
--   another monad, this class captures the opposite concept: allowing you
--   to capture the monadic context. Note that, in order to meet the laws
--   given below, the intuition is that a monad must have no monadic state,
--   but may have monadic context. This essentially limits
--   <a>MonadUnliftIO</a> to <a>ReaderT</a> and <a>IdentityT</a>
--   transformers on top of <a>IO</a>.
--   
--   Laws. For any function <tt>run</tt> provided by <a>withRunInIO</a>, it
--   must meet the monad transformer laws as reformulated for
--   <tt>MonadUnliftIO</tt>:
--   
--   <ul>
--   <li><pre>run . return = return</pre></li>
--   <li><pre>run (m &gt;&gt;= f) = run m &gt;&gt;= run . f</pre></li>
--   </ul>
--   
--   Instances of <tt>MonadUnliftIO</tt> must also satisfy the following
--   laws:
--   
--   <ul>
--   <li><i>Identity law</i> <tt>withRunInIO (\run -&gt; run m) =
--   m</tt></li>
--   <li><i>Inverse law</i> <tt>withRunInIO (\_ -&gt; m) = liftIO
--   m</tt></li>
--   </ul>
--   
--   As an example of an invalid instance, a naive implementation of
--   <tt>MonadUnliftIO (StateT s m)</tt> might be
--   
--   <pre>
--   withRunInIO inner =
--     StateT $ \s -&gt;
--       withRunInIO $ \run -&gt;
--         inner (run . flip evalStateT s)
--   </pre>
--   
--   This breaks the identity law because the inner <tt>run m</tt> would
--   throw away any state changes in <tt>m</tt>.
class MonadIO m => MonadUnliftIO (m :: Type -> Type)

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type.
    type family PrimState (m :: Type -> Type);
}


module Data.Massiv.Array.Mutable

-- | <i>O(1)</i> - Get the size of a mutable array.
sizeOfMArray :: (Manifest r e, Index ix) => MArray s r ix e -> Sz ix

-- | Get the size of a mutable array.

-- | <i>Deprecated: In favor of <a>sizeOfMArray</a></i>
msize :: (Manifest r e, Index ix) => MArray s r ix e -> Sz ix

-- | <i>O(1)</i> - Change the size of a mutable array. Throws
--   <a>SizeElementsMismatchException</a> if total number of elements does
--   not match the supplied array.
resizeMArrayM :: (Manifest r e, Index ix', Index ix, MonadThrow m) => Sz ix' -> MArray s r ix e -> m (MArray s r ix' e)

-- | <i>O(1)</i> - Change a mutable array to a mutable vector.
flattenMArray :: (Manifest r e, Index ix) => MArray s r ix e -> MVector s r e

-- | <i>O(1)</i> - Slice a mutable array from the outside, while reducing
--   its dimensionality by one. Same as <a>!?&gt;</a> operator, but for
--   mutable arrays.
outerSliceMArrayM :: forall r ix e m s. (MonadThrow m, Index (Lower ix), Index ix, Manifest r e) => MArray s r ix e -> Ix1 -> m (MArray s r (Lower ix) e)

-- | <i>O(1)</i> - Take all outer slices of a mutable array and construct a
--   delayed vector out of them. In other words it applies
--   <a>outerSliceMArrayM</a> to each outer index. Same as
--   <a>outerSlices</a> function, but for mutable arrays.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr &lt;- resizeM (Sz2 4 7) $ makeArrayR P Seq (Sz1 28) (+10)
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (4 :. 7))
--     [ [ 10, 11, 12, 13, 14, 15, 16 ]
--     , [ 17, 18, 19, 20, 21, 22, 23 ]
--     , [ 24, 25, 26, 27, 28, 29, 30 ]
--     , [ 31, 32, 33, 34, 35, 36, 37 ]
--     ]
--   </pre>
--   
--   Here we can see we can get individual rows from a mutable matrix
--   
--   <pre>
--   &gt;&gt;&gt; marr &lt;- thawS arr
--   
--   &gt;&gt;&gt; import Control.Monad ((&lt;=&lt;))
--   
--   &gt;&gt;&gt; mapIO_ (print &lt;=&lt; freezeS)  $ outerSlicesMArray Seq marr
--   Array P Seq (Sz1 7)
--     [ 10, 11, 12, 13, 14, 15, 16 ]
--   Array P Seq (Sz1 7)
--     [ 17, 18, 19, 20, 21, 22, 23 ]
--   Array P Seq (Sz1 7)
--     [ 24, 25, 26, 27, 28, 29, 30 ]
--   Array P Seq (Sz1 7)
--     [ 31, 32, 33, 34, 35, 36, 37 ]
--   </pre>
--   
--   For the sake of example what if our goal was to mutate array in such a
--   way that rows from the top half were swapped with the bottom half:
--   
--   <pre>
--   &gt;&gt;&gt; (top, bottom) &lt;- splitAtM 1 2 $ outerSlicesMArray Seq marr
--   
--   &gt;&gt;&gt; mapIO_ (print &lt;=&lt; freezeS) top
--   Array P Seq (Sz1 7)
--     [ 10, 11, 12, 13, 14, 15, 16 ]
--   Array P Seq (Sz1 7)
--     [ 17, 18, 19, 20, 21, 22, 23 ]
--   
--   &gt;&gt;&gt; mapIO_ (print &lt;=&lt; freezeS) bottom
--   Array P Seq (Sz1 7)
--     [ 24, 25, 26, 27, 28, 29, 30 ]
--   Array P Seq (Sz1 7)
--     [ 31, 32, 33, 34, 35, 36, 37 ]
--   
--   &gt;&gt;&gt; szipWithM_ (zipSwapM_ 0) top bottom
--   
--   &gt;&gt;&gt; freezeS marr
--   Array P Seq (Sz (4 :. 7))
--     [ [ 24, 25, 26, 27, 28, 29, 30 ]
--     , [ 31, 32, 33, 34, 35, 36, 37 ]
--     , [ 10, 11, 12, 13, 14, 15, 16 ]
--     , [ 17, 18, 19, 20, 21, 22, 23 ]
--     ]
--   </pre>
outerSlicesMArray :: forall r ix e s. (Index (Lower ix), Index ix, Manifest r e) => Comp -> MArray s r ix e -> Vector D (MArray s r (Lower ix) e)

-- | <i>O(1)</i> - Lookup an element in the mutable array. Returns
--   <a>Nothing</a> when index is out of bounds.
read :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> m (Maybe e)

-- | <i>O(1)</i> - Same as <a>read</a>, but throws
--   <a>IndexOutOfBoundsException</a> on an invalid index.
readM :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> m e

-- | <i>O(1)</i> - Write an element into the cell of a mutable array.
--   Returns <a>False</a> when index is out of bounds.
write :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m Bool

-- | <i>O(1)</i> - Write an element into the cell of a mutable array. Same
--   as <a>write</a> function in case of an out of bounds index it is noop,
--   but unlike <a>write</a>, there is no information is returned about was
--   the writing of element successful or not. In other words, just like
--   <a>writeM</a>, but doesn't throw an exception.
write_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | <i>O(1)</i> - Same as <a>write</a>, but throws
--   <a>IndexOutOfBoundsException</a> on an invalid index.
writeM :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | <i>O(1)</i> - Modify an element in the cell of a mutable array with a
--   supplied action. Returns the previous value, if index was not out of
--   bounds.
modify :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m (Maybe e)

-- | <i>O(1)</i> - Same as <a>modify</a>, except that neither the previous
--   value, nor any information on whether the modification was successful
--   are returned. In other words, just like <a>modifyM_</a>, but doesn't
--   throw an exception.
modify_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m ()

-- | <i>O(1)</i> - Modify an element in the cell of a mutable array with a
--   supplied action. Throws an <a>IndexOutOfBoundsException</a> exception
--   for invalid index and returns the previous value otherwise.
modifyM :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m e

-- | <i>O(1)</i> - Same as <a>modifyM</a>, but discard the returned element
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Control.Monad.ST
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; runST $ newMArray' @P @Ix1 @Int (Sz1 3) &gt;&gt;= (\ma -&gt; modifyM_ ma (pure . (+10)) 1 &gt;&gt; freezeS ma)
--   Array P Seq (Sz1 3)
--     [ 0, 10, 0 ]
--   </pre>
modifyM_ :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m ()

-- | <i>O(1)</i> - Same as <a>swapM</a>, but instead of throwing an
--   exception returns <a>Nothing</a> when either one of the indices is out
--   of bounds and <a>Just</a> elements under those indices otherwise.
swap :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m (Maybe (e, e))

-- | <i>O(1)</i> - Same as <a>swap</a>, but instead of returning
--   <a>Nothing</a> it does nothing. In other words, it is similar to
--   <a>swapM_</a>, but does not throw any exceptions.
swap_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m ()

-- | <i>O(1)</i> - Swap two elements in a mutable array under the supplied
--   indices. Throws an <a>IndexOutOfBoundsException</a> when either one of
--   the indices is out of bounds and elements under those indices
--   otherwise.
swapM :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> ix -> m (e, e)

-- | <i>O(1)</i> - Same as <a>swapM</a>, but discard the returned elements
swapM_ :: (Manifest r e, Index ix, PrimMonad m, MonadThrow m) => MArray (PrimState m) r ix e -> ix -> ix -> m ()

-- | Swap elements in the intersection of two mutable arrays starting at
--   the initial index.
zipSwapM_ :: forall r1 r2 ix e m s. (MonadPrim s m, Manifest r2 e, Manifest r1 e, Index ix) => ix -> MArray s r1 ix e -> MArray s r2 ix e -> m ()

-- | <i>O(n)</i> - Make a mutable copy of a pure array. Keep in mind that
--   both <a>freeze</a> and <a>thaw</a> trigger a copy of the full array.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr &lt;- fromListsM @U @Ix2 @Double Par [[12,21],[13,31]]
--   
--   &gt;&gt;&gt; marr &lt;- thaw arr
--   
--   &gt;&gt;&gt; modify marr (pure . (+ 10)) (1 :. 0)
--   Just 13.0
--   
--   &gt;&gt;&gt; freeze Par marr
--   Array U Par (Sz (2 :. 2))
--     [ [ 12.0, 21.0 ]
--     , [ 23.0, 31.0 ]
--     ]
--   </pre>
thaw :: forall r ix e m. (Manifest r e, Index ix, MonadIO m) => Array r ix e -> m (MArray RealWorld r ix e)

-- | Same as <a>thaw</a>, but restrict computation to sequential only.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; thawS @P @Ix1 @Double [1..10]
--   
--   &gt;&gt;&gt; marr &lt;- thawS @P @Ix1 @Double [1..10]
--   
--   &gt;&gt;&gt; writeM marr 5 100
--   
--   &gt;&gt;&gt; freezeS marr
--   Array P Seq (Sz1 10)
--     [ 1.0, 2.0, 3.0, 4.0, 5.0, 100.0, 7.0, 8.0, 9.0, 10.0 ]
--   </pre>
thawS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Array r ix e -> m (MArray (PrimState m) r ix e)

-- | <i>O(n)</i> - Yield an immutable copy of the mutable array. Note that
--   mutable representations have to be the same.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; marr &lt;- newMArray @P (Sz2 2 6) (0 :: Int)
--   
--   &gt;&gt;&gt; forM_ (range Seq 0 (Ix2 1 4)) $ \ix -&gt; write marr ix 9
--   
--   &gt;&gt;&gt; freeze Seq marr
--   Array P Seq (Sz (2 :. 6))
--     [ [ 9, 9, 9, 9, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
freeze :: forall r ix e m. (Manifest r e, Index ix, MonadIO m) => Comp -> MArray RealWorld r ix e -> m (Array r ix e)

-- | Same as <a>freeze</a>, but do the copy of supplied muable array
--   sequentially. Also, unlike <a>freeze</a> that has to be done in
--   <a>IO</a>, <a>freezeS</a> can be used with <a>ST</a>.
freezeS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> m (Array r ix e)

-- | Create new mutable array while initializing all elements to the
--   specified value.
newMArray :: (Manifest r e, Index ix, PrimMonad m) => Sz ix -> e -> m (MArray (PrimState m) r ix e)

-- | <i>O(n)</i> - Initialize a new mutable array. All elements will be set
--   to some default value. For boxed arrays it will be a thunk with
--   <a>Uninitialized</a> exception, while for others it will be simply
--   zeros.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; marr &lt;- newMArray' (Sz2 2 6) :: IO (MArray RealWorld P Ix2 Int)
--   
--   &gt;&gt;&gt; freeze Seq marr
--   Array P Seq (Sz (2 :. 6))
--     [ [ 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
--   
--   Or using <tt>TypeApplications</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; newMArray' @P @Ix2 @Int (Sz2 2 6) &gt;&gt;= freezeS
--   Array P Seq (Sz (2 :. 6))
--     [ [ 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; newMArray' @B @_ @Int (Sz2 2 6) &gt;&gt;= freezeS
--   *** Exception: Uninitialized
--   </pre>
newMArray' :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> m (MArray (PrimState m) r ix e)

-- | Just like <a>makeMArrayS</a>, but also accepts computation strategy
--   and runs in <a>IO</a>.
makeMArray :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (ix -> m e) -> m (MArray RealWorld r ix e)

-- | Just like <a>makeMArrayLinearS</a>, but also accepts computation
--   strategy and runs in <a>IO</a>.
makeMArrayLinear :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (Int -> m e) -> m (MArray RealWorld r ix e)

-- | Create a mutable array using an index aware generating action.
makeMArrayS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (ix -> m e) -> m (MArray (PrimState m) r ix e)

-- | Same as <a>makeMArrayS</a>, but index supplied to the action is
--   row-major linear index.
makeMArrayLinearS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (Int -> m e) -> m (MArray (PrimState m) r ix e)

-- | Create a new array by supplying an action that will fill the new blank
--   mutable array. Use <a>createArray</a> if you'd like to keep the result
--   of the filling function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; createArray_ @P @_ @Int Seq (Sz1 2) (\ s marr -&gt; scheduleWork s (writeM marr 0 10) &gt;&gt; scheduleWork s (writeM marr 1 11))
--   Array P Seq (Sz1 2)
--     [ 10, 11 ]
--   </pre>
createArray_ :: forall r ix e a m. (Manifest r e, Index ix, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler RealWorld () -> MArray RealWorld r ix e -> m a) -> m (Array r ix e)

-- | Just like <a>createArray_</a>, but together with <a>Array</a> it
--   returns results of scheduled filling actions.
createArray :: forall r ix e a m b. (Manifest r e, Index ix, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler RealWorld a -> MArray RealWorld r ix e -> m b) -> m ([a], Array r ix e)

-- | Create a new array by supplying an action that will fill the new blank
--   mutable array. Use <a>createArrayS</a> if you'd like to keep the
--   result of the filling function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; createArrayS_ @P @_ @Int (Sz1 2) (\ marr -&gt; write marr 0 10 &gt;&gt; write marr 1 12)
--   Array P Seq (Sz1 2)
--     [ 10, 12 ]
--   </pre>
createArrayS_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Just like <a>createArray_</a>, but together with <a>Array</a> it
--   returns the result of the filling action.
createArrayS :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Just like <a>createArrayS_</a>, but restricted to <a>ST</a>.
createArrayST_ :: forall r ix e a. (Manifest r e, Index ix) => Sz ix -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Just like <a>createArrayS</a>, but restricted to <a>ST</a>.
createArrayST :: forall r ix e a. (Manifest r e, Index ix) => Sz ix -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Just like <a>generateArrayS</a>, except this generator <b>will</b>
--   respect the supplied computation strategy, and for that reason it is
--   restricted to <a>IO</a>.
generateArray :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Just like <a>generateArray</a>, except generating action will receive
--   a row-major linear index.
generateArrayLinear :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (Ix1 -> m e) -> m (Array r ix e)

-- | Sequentially generate a pure array. Much like <a>makeArray</a> creates
--   a pure array this function will use <a>Manifest</a> interface to
--   generate a pure <a>Array</a> in the end, except that computation
--   strategy is set to <a>Seq</a>. Element producing function no longer
--   has to be pure but is a stateful action, becuase it is restricted to
--   <a>PrimMonad</a> thus allows for sharing the state between computation
--   of each element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef (0 :: Int)
--   
--   &gt;&gt;&gt; generateArrayS (Sz1 6) (\ i -&gt; modifyIORef' ref (+i) &gt;&gt; print i &gt;&gt; pure i) :: IO (Array U Ix1 Int)
--   0
--   1
--   2
--   3
--   4
--   5
--   Array U Seq (Sz1 6)
--     [ 0, 1, 2, 3, 4, 5 ]
--   
--   &gt;&gt;&gt; readIORef ref
--   15
--   </pre>
generateArrayS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Same as <a>generateArray</a> but with action that accepts row-major
--   linear index.
generateArrayLinearS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (Int -> m e) -> m (Array r ix e)

-- | Similar to <a>makeSplitSeedArray</a>, except it will produce a
--   Manifest array and will return back the last unused seed together with
--   all final seeds produced by each scheduled job. This function can be
--   thought of as an unfolding done in parallel while iterating in a
--   customizable manner.
generateSplitSeedArray :: forall r ix e g it. (Iterator it, Manifest r e, Index ix) => it -> g -> (forall s. g -> ST s (g, g)) -> Comp -> Sz ix -> (forall s. Ix1 -> ix -> g -> ST s (e, g)) -> (g, [g], Array r ix e)

-- | Use per worker thread state while generating elements of the array.
--   Very useful for things that are not thread safe.
generateArrayWS :: forall r ix e s m. (Manifest r e, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (ix -> s -> m e) -> m (Array r ix e)

-- | Same as <a>generateArrayWS</a>, but use linear indexing instead.
generateArrayLinearWS :: forall r ix e s m. (Manifest r e, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (Int -> s -> m e) -> m (Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers while performing an <a>IO</a>
--   action at each iteration.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldrPrimM_ (Sz1 10) (\(f0, f1) -&gt; (f0, (f1, f0 + f1)) &lt;$ print f1) (0, 1) :: IO (Array P Ix1 Int)
--   1
--   1
--   2
--   3
--   5
--   8
--   13
--   21
--   34
--   55
--   Array P Seq (Sz1 10)
--     [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]
--   </pre>
unfoldrPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldrPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldrPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldrPrimM</a>, but do the unfolding with index aware
--   function.
unfoldrPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldrPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldrPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers starting at the end while
--   performing and <a>IO</a> action on the accumulator for each element of
--   the array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldlPrimM_ (Sz1 10) (\a@(f0, f1) -&gt; let fn = f0 + f1 in print a &gt;&gt; return ((f1, fn), f0)) (0, 1) :: IO (Array P Ix1 Int)
--   (0,1)
--   (1,1)
--   (1,2)
--   (2,3)
--   (3,5)
--   (5,8)
--   (8,13)
--   (13,21)
--   (21,34)
--   (34,55)
--   Array P Seq (Sz1 10)
--     [ 34, 21, 13, 8, 5, 3, 2, 1, 1, 0 ]
--   </pre>
unfoldlPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldlPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldlPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldlPrimM</a>, but do the unfolding with index aware
--   function.
unfoldlPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldlPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldlPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Sequentially loop over a mutable array while modifying each element
--   with an action.
forPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an action to it. There is no mutation to the array, unless
--   the action itself modifies it.
forPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an index aware action to it. There is no mutation to the
--   array, unless the action itself modifies it.
iforPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforLinearPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying a linear index aware action to it. There is no mutation to
--   the array, unless the action itself modifies it.
iforLinearPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m ()) -> m ()

-- | Sequentially loop over the intersection of two mutable arrays while
--   reading elements from both and applying an action to it. There is no
--   mutation to the actual arrays, unless the action itself modifies
--   either one of them.
for2PrimM_ :: forall r1 r2 e1 e2 ix m. (PrimMonad m, Index ix, Manifest r1 e1, Manifest r2 e2) => MArray (PrimState m) r1 ix e1 -> MArray (PrimState m) r2 ix e2 -> (e1 -> e2 -> m ()) -> m ()

-- | Same as <a>for2PrimM_</a>, but with index aware action.
ifor2PrimM_ :: forall r1 r2 e1 e2 ix m. (PrimMonad m, Index ix, Manifest r1 e1, Manifest r2 e2) => MArray (PrimState m) r1 ix e1 -> MArray (PrimState m) r2 ix e2 -> (ix -> e1 -> e2 -> m ()) -> m ()

-- | Same as <a>withMArray_</a>, but allows to keep artifacts of scheduled
--   tasks.
withMArray :: (Manifest r e, Index ix, MonadUnliftIO m) => Array r ix e -> (Scheduler RealWorld a -> MArray RealWorld r ix e -> m b) -> m ([a], Array r ix e)

-- | Create a copy of a pure array, mutate it in place and return its
--   frozen version. The big difference between <a>withMArrayS</a> is that
--   it's not only gonna respect the computation strategy supplied to it
--   while making a copy, but it will also pass extra argumens to the
--   action that suppose to modify the mutable copy of the source array.
--   These two extra arguments are:
--   
--   <ul>
--   <li>Number of capabilities derived from the <a>Comp</a>utation
--   strategy of the array.</li>
--   <li>An action that can be used to schedule arbitrary number of jobs
--   that will be executed in parallel.</li>
--   <li>And, of course, the mutable array itself.</li>
--   </ul>
withMArray_ :: (Manifest r e, Index ix, MonadUnliftIO m) => Array r ix e -> (Scheduler RealWorld () -> MArray RealWorld r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArray_</a>, but the array supplied to this function
--   can be any loadable array. For that reason it will be faster if
--   supplied array is delayed.
withLoadMArray_ :: forall r ix e r' m b. (Load r' ix e, Manifest r e, MonadUnliftIO m) => Array r' ix e -> (Scheduler RealWorld () -> MArray RealWorld r ix e -> m b) -> m (Array r ix e)

-- | Create a copy of a pure array, mutate it in place and return its
--   frozen version. The important benefit over doing a manual <a>thawS</a>
--   followed by a <a>freezeS</a> is that an array will only be copied
--   once.
withMArrayS :: (Manifest r e, Index ix, PrimMonad m) => Array r ix e -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Same as <a>withMArrayS</a>, but will work with any loadable array.
withLoadMArrayS :: forall r ix e r' m a. (Load r' ix e, Manifest r e, PrimMonad m) => Array r' ix e -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Same as <a>withMArrayS</a>, except it discards the value produced by
--   the supplied action
withMArrayS_ :: (Manifest r e, Index ix, PrimMonad m) => Array r ix e -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArrayS_</a>, but will work with any loadable array.
withLoadMArrayS_ :: forall r ix e r' m a. (Load r' ix e, Manifest r e, PrimMonad m) => Array r' ix e -> (MArray (PrimState m) r ix e -> m a) -> m (Array r ix e)

-- | Same as <a>withMArrayS</a> but in <a>ST</a>. This is not only pure,
--   but also the safest way to do mutation to the array.
withMArrayST :: (Manifest r e, Index ix) => Array r ix e -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Same as <a>withMArrayST</a>, but works with any loadable array.
withLoadMArrayST :: forall r ix e r' a. (Load r' ix e, Manifest r e) => Array r' ix e -> (forall s. MArray s r ix e -> ST s a) -> (a, Array r ix e)

-- | Same as <a>withMArrayS</a> but in <a>ST</a>. This is not only pure,
--   but also the safest way to do mutation to the array.
withMArrayST_ :: (Manifest r e, Index ix) => Array r ix e -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Same as <a>withMArrayST_</a>, but works with any loadable array.
withLoadMArrayST_ :: forall r ix e r' a. (Load r' ix e, Manifest r e) => Array r' ix e -> (forall s. MArray s r ix e -> ST s a) -> Array r ix e

-- | Initialize mutable array to some default value.
initialize :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> m ()

-- | Create new mutable array while initializing all elements to some
--   default value.
initializeNew :: (Manifest r e, Index ix, PrimMonad m) => Maybe e -> Sz ix -> m (MArray (PrimState m) r ix e)

-- | Manifest arrays are backed by actual memory and values are looked up
--   versus computed as it is with delayed arrays. Because manifest arrays
--   are located in memory their contents can be mutated once thawed into
--   <a>MArray</a>. The process of changed a mutable <a>MArray</a> back
--   into an immutable <a>Array</a> is called freezing.
class Source r e => Manifest r e

-- | Mutable version of a <a>Manifest</a> <a>Array</a>. The extra type
--   argument <tt>s</tt> is for the state token used by <a>IO</a> and
--   <a>ST</a>.
data family MArray s r ix e :: Type

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | Compute an Array while loading the results into the supplied mutable
--   target array. Number of elements for arrays must agree, otherwise
--   <a>SizeElementsMismatchException</a> exception is thrown.
computeInto :: (Load r' ix' e, Manifest r e, Index ix, MonadIO m) => MArray RealWorld r ix e -> Array r' ix' e -> m ()

-- | Load a pure array into the newly created mutable array, while
--   respecting computation startegy.
loadArray :: forall r ix e r' m. (Load r' ix e, Manifest r e, MonadIO m) => Array r' ix e -> m (MArray RealWorld r ix e)

-- | Load sequentially a pure array into the newly created mutable array.
loadArrayS :: forall r ix e r' m. (Load r' ix e, Manifest r e, PrimMonad m) => Array r' ix e -> m (MArray (PrimState m) r ix e)


module Data.Massiv.Array.Numeric
class FoldNumeric r e => Numeric r e
class (Numeric r e, Floating e) => NumericFloat r e

-- | Similar to <a>liftArray2M</a>, except it can be applied only to
--   representations with <a>Numeric</a> instance and result representation
--   stays the same.
liftNumArray2M :: (Index ix, Numeric r e, MonadThrow m) => (e -> e -> e) -> Array r ix e -> Array r ix e -> m (Array r ix e)

-- | Add a scalar to each element of the array. Array is on the left.
(.+) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 6 .+

-- | Add a scalar to each element of the array. Array is on the right.
(+.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 6 +.

-- | Add two arrays together pointwise. Same as <a>!+!</a> but produces
--   monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.+.) :: (Index ix, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 6 .+.

-- | Add two arrays together pointwise. Prefer to use monadic version of
--   this function <a>.+.</a> whenever possible, because it is better to
--   avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !+! a2
--   Array D Seq (Sz1 11)
--     [ 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40 ]
--   </pre>
(!+!) :: (HasCallStack, Index ix, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 6 !+!

-- | Compute sum of arrays pointwise. All arrays must have the same size.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; sumArraysM [] :: IO (Array P Ix3 Int)
--   Array P Seq (Sz (0 :&gt; 0 :. 0))
--     [  ]
--   
--   &gt;&gt;&gt; arr = A.makeArrayR P Seq (Sz3 4 5 6) $ \(i :&gt; j :. k) -&gt; i + j * k
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (4 :&gt; 5 :. 6))
--     [ [ [ 0, 0, 0, 0, 0, 0 ]
--       , [ 0, 1, 2, 3, 4, 5 ]
--       , [ 0, 2, 4, 6, 8, 10 ]
--       , [ 0, 3, 6, 9, 12, 15 ]
--       , [ 0, 4, 8, 12, 16, 20 ]
--       ]
--     , [ [ 1, 1, 1, 1, 1, 1 ]
--       , [ 1, 2, 3, 4, 5, 6 ]
--       , [ 1, 3, 5, 7, 9, 11 ]
--       , [ 1, 4, 7, 10, 13, 16 ]
--       , [ 1, 5, 9, 13, 17, 21 ]
--       ]
--     , [ [ 2, 2, 2, 2, 2, 2 ]
--       , [ 2, 3, 4, 5, 6, 7 ]
--       , [ 2, 4, 6, 8, 10, 12 ]
--       , [ 2, 5, 8, 11, 14, 17 ]
--       , [ 2, 6, 10, 14, 18, 22 ]
--       ]
--     , [ [ 3, 3, 3, 3, 3, 3 ]
--       , [ 3, 4, 5, 6, 7, 8 ]
--       , [ 3, 5, 7, 9, 11, 13 ]
--       , [ 3, 6, 9, 12, 15, 18 ]
--       , [ 3, 7, 11, 15, 19, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; sumArraysM $ outerSlices arr
--   Array P Seq (Sz (5 :. 6))
--     [ [ 6, 6, 6, 6, 6, 6 ]
--     , [ 6, 10, 14, 18, 22, 26 ]
--     , [ 6, 14, 22, 30, 38, 46 ]
--     , [ 6, 18, 30, 42, 54, 66 ]
--     , [ 6, 22, 38, 54, 70, 86 ]
--     ]
--   
--   &gt;&gt;&gt; sumArraysM $ innerSlices arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 0, 15, 30, 45, 60 ]
--     , [ 6, 21, 36, 51, 66 ]
--     , [ 12, 27, 42, 57, 72 ]
--     , [ 18, 33, 48, 63, 78 ]
--     ]
--   </pre>
sumArraysM :: (Foldable t, Load r ix e, Numeric r e, MonadThrow m) => t (Array r ix e) -> m (Array r ix e)

-- | Same as <a>sumArraysM</a>, compute sum of arrays pointwise. All arrays
--   must have the same size, otherwise it will result in an error.
sumArrays' :: (HasCallStack, Foldable t, Load r ix e, Numeric r e) => t (Array r ix e) -> Array r ix e

-- | Subtract a scalar from each element of the array. Array is on the
--   left.
(.-) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 6 .-

-- | Subtract each element of the array from a scalar. Array is on the
--   right.
(-.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 6 -.

-- | Subtract two arrays pointwise. Same as <a>!-!</a> but produces monadic
--   computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.-.) :: (Index ix, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 6 .-.

-- | Subtract one array from another pointwise. Prefer to use monadic
--   version of this function <a>.-.</a> whenever possible, because it is
--   better to avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !-! a2
--   Array D Seq (Sz1 11)
--     [ -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20 ]
--   </pre>
(!-!) :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 6 !-!

-- | Multiply each element of the array by a scalar value. Scalar is on the
--   right.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; arr .* 10
--   Array D Seq (Sz1 5)
--     [ 200, 210, 220, 230, 240 ]
--   </pre>
(.*) :: (Index ix, Numeric r e) => Array r ix e -> e -> Array r ix e
infixl 7 .*

-- | Multiply each element of the array by a scalar value. Scalar is on the
--   left.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; 10 *. arr
--   Array D Seq (Sz1 5)
--     [ 200, 210, 220, 230, 240 ]
--   </pre>
(*.) :: (Index ix, Numeric r e) => e -> Array r ix e -> Array r ix e
infixl 7 *.

-- | Multiply two arrays together pointwise. Same as <a>!*!</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(.*.) :: (Index ix, Numeric r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 7 .*.

-- | Multiplication of two arrays pointwise, i.e. <a>Hadamard product</a>.
--   Prefer to use monadic version of this function <a>.*.</a> whenever
--   possible, because it is better to avoid partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let a1 = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; let a2 = Ix1 20 ... 30
--   
--   &gt;&gt;&gt; a1 !*! a2
--   Array D Seq (Sz1 11)
--     [ 0, 21, 44, 69, 96, 125, 156, 189, 224, 261, 300 ]
--   </pre>
(!*!) :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 7 !*!

-- | Raise each element of the array to a power.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = Ix1 20 ..: 25
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20, 21, 22, 23, 24 ]
--   
--   &gt;&gt;&gt; arr .^ 3
--   Array D Seq (Sz1 5)
--     [ 8000, 9261, 10648, 12167, 13824 ]
--   </pre>
(.^) :: (Index ix, Numeric r e) => Array r ix e -> Int -> Array r ix e
infixr 8 .^

-- | Compute product of arrays pointwise. All arrays must have the same
--   size.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; productArraysM [] :: IO (Array P Ix3 Int)
--   Array P Seq (Sz (0 :&gt; 0 :. 0))
--     [  ]
--   
--   &gt;&gt;&gt; arr = A.makeArrayR P Seq (Sz3 4 5 6) $ \(i :&gt; j :. k) -&gt; i + j * k
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (4 :&gt; 5 :. 6))
--     [ [ [ 0, 0, 0, 0, 0, 0 ]
--       , [ 0, 1, 2, 3, 4, 5 ]
--       , [ 0, 2, 4, 6, 8, 10 ]
--       , [ 0, 3, 6, 9, 12, 15 ]
--       , [ 0, 4, 8, 12, 16, 20 ]
--       ]
--     , [ [ 1, 1, 1, 1, 1, 1 ]
--       , [ 1, 2, 3, 4, 5, 6 ]
--       , [ 1, 3, 5, 7, 9, 11 ]
--       , [ 1, 4, 7, 10, 13, 16 ]
--       , [ 1, 5, 9, 13, 17, 21 ]
--       ]
--     , [ [ 2, 2, 2, 2, 2, 2 ]
--       , [ 2, 3, 4, 5, 6, 7 ]
--       , [ 2, 4, 6, 8, 10, 12 ]
--       , [ 2, 5, 8, 11, 14, 17 ]
--       , [ 2, 6, 10, 14, 18, 22 ]
--       ]
--     , [ [ 3, 3, 3, 3, 3, 3 ]
--       , [ 3, 4, 5, 6, 7, 8 ]
--       , [ 3, 5, 7, 9, 11, 13 ]
--       , [ 3, 6, 9, 12, 15, 18 ]
--       , [ 3, 7, 11, 15, 19, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; productArraysM $ outerSlices arr
--   Array P Seq (Sz (5 :. 6))
--     [ [ 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 24, 120, 360, 840, 1680 ]
--     , [ 0, 120, 840, 3024, 7920, 17160 ]
--     , [ 0, 360, 3024, 11880, 32760, 73440 ]
--     , [ 0, 840, 7920, 32760, 93024, 212520 ]
--     ]
--   
--   &gt;&gt;&gt; productArraysM $ innerSlices arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 0, 0, 0, 0, 0 ]
--     , [ 1, 720, 10395, 58240, 208845 ]
--     , [ 64, 5040, 46080, 209440, 665280 ]
--     , [ 729, 20160, 135135, 524880, 1514205 ]
--     ]
--   </pre>
productArraysM :: (Foldable t, Load r ix e, Numeric r e, MonadThrow m) => t (Array r ix e) -> m (Array r ix e)

-- | Same as <a>productArraysM</a>. Compute product of arrays pointwise.
--   All arrays must have the same size, otherwise it will result in an
--   error.
productArrays' :: (HasCallStack, Foldable t, Load r ix e, Numeric r e) => t (Array r ix e) -> Array r ix e

-- | Dot product of two vectors.
--   
--   <ul>
--   <li><i>Partial</i> Throws an impure exception when lengths of vectors
--   do not match</li>
--   </ul>
(!.!) :: (Numeric r e, Source r e) => Vector r e -> Vector r e -> e

-- | Dot product of two vectors.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   lengths of vectors do not match
dotM :: (FoldNumeric r e, Source r e, MonadThrow m) => Vector r e -> Vector r e -> m e

-- | Multiply a matrix by a column vector. Same as <a>!&gt;&lt;</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(.><) :: (MonadThrow m, FoldNumeric r e, Source r e) => Matrix r e -> Vector r e -> m (Vector D e)

-- | Multiply a matrix by a column vector
--   
--   <ul>
--   <li><i>Partial</i> Throws impure exception when inner dimensions do
--   not agree</li>
--   </ul>
(!><) :: (Numeric r e, Source r e) => Matrix r e -> Vector r e -> Vector D e

-- | Multiply matrix by a column vector. Same as <a>.&gt;&lt;</a> but
--   returns computed version of a vector
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
multiplyMatrixByVector :: (MonadThrow m, Numeric r e, Manifest r e) => Matrix r e -> Vector r e -> m (Vector r e)

-- | Multiply a row vector by a matrix. Same as <a>&gt;&lt;!</a> but
--   produces monadic computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(><.) :: (MonadThrow m, Numeric r e, Manifest r e) => Vector r e -> Matrix r e -> m (Vector r e)

-- | Multiply a row vector by a matrix.
--   
--   <ul>
--   <li><i>Partial</i> Throws impure exception when inner dimensions do
--   not agree</li>
--   </ul>
(><!) :: (Numeric r e, Manifest r e) => Vector r e -> Matrix r e -> Vector r e

-- | Multiply a row vector by a matrix. Same as <a>&gt;&lt;.</a> but
--   returns computed vector instead of a delayed one.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
multiplyVectorByMatrix :: (MonadThrow m, Numeric r e, Manifest r e) => Vector r e -> Matrix r e -> m (Vector r e)

-- | Matrix multiplication. Same as <a>!&gt;&lt;!</a> but produces monadic
--   computation that allows for handling failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   inner dimensions of arrays do not match.
(.><.) :: (Numeric r e, Manifest r e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix r e)

-- | Multiply two matrices together.
--   
--   <ul>
--   <li><i>Partial</i> Inner dimension must agree</li>
--   </ul>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a1 = makeArrayR P Seq (Sz2 5 6) $ \(i :. j) -&gt; i + j
--   
--   &gt;&gt;&gt; a2 = makeArrayR P Seq (Sz2 6 5) $ \(i :. j) -&gt; i - j
--   
--   &gt;&gt;&gt; a1 !&gt;&lt;! a2
--   Array P Seq (Sz (5 :. 5))
--     [ [ 55, 40, 25, 10, -5 ]
--     , [ 70, 49, 28, 7, -14 ]
--     , [ 85, 58, 31, 4, -23 ]
--     , [ 100, 67, 34, 1, -32 ]
--     , [ 115, 76, 37, -2, -41 ]
--     ]
--   </pre>
(!><!) :: (Numeric r e, Manifest r e) => Matrix r e -> Matrix r e -> Matrix r e

-- | Synonym for <a>.&gt;&lt;.</a>
multiplyMatrices :: (Numeric r e, Manifest r e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix r e)

-- | Computes the matrix-matrix multiplication where second matrix is
--   transposed (i.e. M x N')
--   
--   <pre>
--   m1 .&gt;&lt;. transpose m2 == multiplyMatricesTransposed m1 m2
--   </pre>
multiplyMatricesTransposed :: (Numeric r e, Manifest r e, MonadThrow m) => Matrix r e -> Matrix r e -> m (Matrix D e)

-- | Compute L2 norm of an array.
normL2 :: (FoldNumeric r e, Source r e, Index ix, Floating e) => Array r ix e -> e

-- | Create an indentity matrix.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; identityMatrix 5
--   Array DL Seq (Sz (5 :. 5))
--     [ [ 1, 0, 0, 0, 0 ]
--     , [ 0, 1, 0, 0, 0 ]
--     , [ 0, 0, 1, 0, 0 ]
--     , [ 0, 0, 0, 1, 0 ]
--     , [ 0, 0, 0, 0, 1 ]
--     ]
--   </pre>
identityMatrix :: Num e => Sz1 -> Matrix DL e

-- | Create a lower triangular (L in LU decomposition) matrix of size
--   <tt>NxN</tt>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; lowerTriangular Seq 5 (\(i :. j) -&gt; i + j)
--   Array DL Seq (Sz (5 :. 5))
--     [ [ 0, 0, 0, 0, 0 ]
--     , [ 1, 2, 0, 0, 0 ]
--     , [ 2, 3, 4, 0, 0 ]
--     , [ 3, 4, 5, 6, 0 ]
--     , [ 4, 5, 6, 7, 8 ]
--     ]
--   </pre>
lowerTriangular :: forall e. Num e => Comp -> Sz1 -> (Ix2 -> e) -> Matrix DL e

-- | Create an upper triangular (U in LU decomposition) matrix of size
--   <tt>NxN</tt>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; upperTriangular Par 5 (\(i :. j) -&gt; i + j)
--   Array DL Par (Sz (5 :. 5))
--     [ [ 0, 1, 2, 3, 4 ]
--     , [ 0, 2, 3, 4, 5 ]
--     , [ 0, 0, 4, 5, 6 ]
--     , [ 0, 0, 0, 6, 7 ]
--     , [ 0, 0, 0, 0, 8 ]
--     ]
--   </pre>
upperTriangular :: forall e. Num e => Comp -> Sz1 -> (Ix2 -> e) -> Matrix DL e

-- | Negate each element of the array
negateA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Apply <a>abs</a> to each element of the array
absA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Apply <a>signum</a> to each element of the array
signumA :: (Index ix, Numeric r e) => Array r ix e -> Array r ix e

-- | Perform a pointwise quotient where first array contains numerators and
--   the second one denominators
--   
--   <pre>
--   quotA arr1 arr2 == zipWith quot arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
quotA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `quotA`

-- | Perform a pointwise remainder computation
--   
--   <pre>
--   remA arr1 arr2 == zipWith rem arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
remA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `remA`

-- | Perform a pointwise integer division where first array contains
--   numerators and the second one denominators
--   
--   <pre>
--   divA arr1 arr2 == zipWith div arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
divA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `divA`

-- | Perform a pointwise modulo computation
--   
--   <pre>
--   modA arr1 arr2 == zipWith mod arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
modA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> Array D ix e
infixl 7 `modA`

-- | Perform a pointwise quotient with remainder where first array contains
--   numerators and the second one denominators
--   
--   <pre>
--   quotRemA arr1 arr2 == zipWith quotRem arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
quotRemA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> (Array D ix e, Array D ix e)

-- | Perform a pointwise integer division with modulo where first array
--   contains numerators and the second one denominators
--   
--   <pre>
--   divModA arr1 arr2 == zipWith divMod arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
divModA :: (HasCallStack, Index ix, Source r1 e, Source r2 e, Integral e) => Array r1 ix e -> Array r2 ix e -> (Array D ix e, Array D ix e)

-- | Divide each element of the array by a scalar value.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20.0, 21.0, 22.0, 23.0, 24.0 ]
--   
--   &gt;&gt;&gt; arr ./ 100
--   Array D Seq (Sz1 5)
--     [ 0.2, 0.21, 0.22, 0.23, 0.24 ]
--   </pre>
(./) :: (Index ix, NumericFloat r e) => Array r ix e -> e -> Array r ix e
infixl 7 ./

-- | Divide a scalar value by each element of the array.
--   
--   <pre>
--   e /. arr == e *. recipA arr
--   </pre>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz1 5)
--     [ 20.0, 21.0, 22.0, 23.0, 24.0 ]
--   
--   &gt;&gt;&gt; 100 /. arr
--   Array D Seq (Sz1 5)
--     [ 5.0, 4.7619047, 4.5454545, 4.347826, 4.1666665 ]
--   </pre>
(/.) :: (Index ix, NumericFloat r e) => e -> Array r ix e -> Array r ix e
infixl 7 /.

-- | Divide each element of one array by another pointwise. Same as
--   <a>!/!</a> but produces monadic computation that allows for handling
--   failure.
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
(./.) :: (Index ix, NumericFloat r e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)
infixl 7 ./.

-- | Divide two arrays pointwise. Prefer to use monadic version of this
--   function <a>./.</a> whenever possible, because it is better to avoid
--   partial functions.
--   
--   <ul>
--   <li><i>Partial</i> Mismatched array sizes will result in an impure
--   exception being thrown.</li>
--   </ul>
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let arr1 = fromIntegral &lt;$&gt; (Ix1 20 ..: 25) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; let arr2 = fromIntegral &lt;$&gt; (Ix1 100 ..: 105) :: Array D Ix1 Float
--   
--   &gt;&gt;&gt; arr1 !/! arr2
--   Array D Seq (Sz1 5)
--     [ 0.2, 0.20792079, 0.21568628, 0.22330096, 0.23076923 ]
--   </pre>
(!/!) :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e -> Array r ix e
infixl 7 !/!
(.^^) :: (Index ix, Numeric r e, Fractional e, Integral b) => Array r ix e -> b -> Array r ix e
infixr 8 .^^

-- | Apply reciprocal to each element of the array.
--   
--   <pre>
--   recipA arr == 1 /. arr
--   </pre>
recipA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply exponent to each element of the array.
--   
--   <pre>
--   expA arr == map exp arr
--   </pre>
expA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply logarithm to each element of the array.
--   
--   <pre>
--   logA arr == map log arr
--   </pre>
logA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply square root to each element of the array.
--   
--   <pre>
--   sqrtA arr == map sqrt arr
--   </pre>
sqrtA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply power to each element of the array where the power value is in
--   the same cell in the second array.
--   
--   <pre>
--   arr1 .** arr2 == zipWith (**) arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Throws an error when arrays do not have matching
--   sizes</li>
--   </ul>
(.**) :: (Index ix, Source r1 e, Source r2 e, Floating e) => Array r1 ix e -> Array r2 ix e -> Array D ix e

-- | Apply logarithm to each element of the array where the base is in the
--   same cell in the second array.
--   
--   <pre>
--   logBaseA arr1 arr2 == zipWith logBase arr1 arr2
--   </pre>
--   
--   <ul>
--   <li><i>Partial</i> Throws an error when arrays do not have matching
--   sizes</li>
--   </ul>
logBaseA :: (Index ix, Source r1 e, Source r2 e, Floating e) => Array r1 ix e -> Array r2 ix e -> Array D ix e

-- | Apply sine function to each element of the array.
--   
--   <pre>
--   sinA arr == map sin arr
--   </pre>
sinA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply cosine function to each element of the array.
--   
--   <pre>
--   cosA arr == map cos arr
--   </pre>
cosA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply tangent function to each element of the array.
--   
--   <pre>
--   tanA arr == map tan arr
--   </pre>
tanA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arcsine function to each element of the array.
--   
--   <pre>
--   asinA arr == map asin arr
--   </pre>
asinA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arccosine function to each element of the array.
--   
--   <pre>
--   acosA arr == map acos arr
--   </pre>
acosA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply arctangent function to each element of the array.
--   
--   <pre>
--   atanA arr == map atan arr
--   </pre>
atanA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic sine function to each element of the array.
--   
--   <pre>
--   sinhA arr == map sinh arr
--   </pre>
sinhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic cosine function to each element of the array.
--   
--   <pre>
--   coshA arr == map cosh arr
--   </pre>
coshA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply hyperbolic tangent function to each element of the array.
--   
--   <pre>
--   tanhA arr == map tanh arr
--   </pre>
tanhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic sine function to each element of the array.
--   
--   <pre>
--   asinhA arr == map asinh arr
--   </pre>
asinhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic cosine function to each element of the array.
--   
--   <pre>
--   acoshA arr == map acosh arr
--   </pre>
acoshA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Apply inverse hyperbolic tangent function to each element of the
--   array.
--   
--   <pre>
--   atanhA arr == map atanh arr
--   </pre>
atanhA :: (Index ix, NumericFloat r e) => Array r ix e -> Array r ix e

-- | Truncate each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
truncateA :: (Index ix, Source r a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Round each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
roundA :: (Index ix, Source r a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Ceiling of each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
ceilingA :: (Index ix, Source r a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Floor each element of the array.
--   
--   <pre>
--   truncateA arr == map truncate arr
--   </pre>
floorA :: (Index ix, Source r a, RealFrac a, Integral e) => Array r ix a -> Array D ix e

-- | Perform atan2 pointwise
--   
--   <pre>
--   atan2A arr1 arr2 == zipWith atan2 arr1 arr2
--   </pre>
--   
--   <i><b>Throws Exception</b></i>: <a>SizeMismatchException</a> when
--   array sizes do not match.
atan2A :: (Index ix, Numeric r e, RealFloat e, MonadThrow m) => Array r ix e -> Array r ix e -> m (Array r ix e)


module Data.Massiv.Array.Mutable.Atomic

-- | Atomically read an <a>Int</a> element from the array
atomicReadIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> m (Maybe Int)

-- | Atomically write an <a>Int</a> element int the array. Returns
--   <a>True</a> if supplied index was correct and write was successfull.
atomicWriteIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Bool

-- | Atomically modify an <a>Int</a> element of the array. Returns the old
--   value, unless the supplied index was out of bounds.
atomicModifyIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> (Int -> Int) -> m (Maybe Int)

-- | Atomically add to an <a>Int</a> element in the array. Returns the old
--   value.
atomicAddIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically subtract from an <a>Int</a> element in the array. Returns
--   the old value.
atomicSubIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically AND an <a>Int</a> element in the array. Returns the old
--   value.
atomicAndIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically NAND an <a>Int</a> element in the array. Returns the old
--   value.
atomicNandIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically OR an <a>Int</a> element in the array. Returns the old
--   value.
atomicOrIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically XOR an <a>Int</a> element in the array. Returns the old
--   value.
atomicXorIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m (Maybe Int)

-- | Atomically CAS (Compare-and-Swap) an <a>Int</a> in the array. Returns
--   the old value.
casIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> Int -> m (Maybe Int)


module Data.Massiv.Array.Manifest.Vector

-- | In case when resulting array representation matches the one of
--   vector's it will do a <i>O(1)</i> - conversion using
--   <a>castFromVector</a>, otherwise Vector elements will be copied into a
--   new array. Will throw an error if length of resulting array doesn't
--   match the source vector length.
fromVectorM :: (MonadThrow m, Typeable v, Vector v a, Manifest r a, Load (ARepr v) ix a, Load r ix a) => Comp -> Sz ix -> v a -> m (Array r ix a)

-- | Just like <a>fromVectorM</a>, but will throw an exception on a
--   mismatched size.
fromVector' :: (HasCallStack, Typeable v, Vector v a, Load (ARepr v) ix a, Load r ix a, Manifest r a) => Comp -> Sz ix -> v a -> Array r ix a

-- | <i>O(1)</i> - conversion from vector to an array with a corresponding
--   representation. Will return <a>Nothing</a> if there is a size mismatch
--   or if some non-standard vector type is supplied. Is suppplied is the
--   boxed <a>Vector</a> then it's all elements will be evaluated toWHNF,
--   therefore complexity will be <i>O(n)</i>
castFromVector :: forall v r ix e. (Vector v e, Typeable v, Index ix, ARepr v ~ r) => Comp -> Sz ix -> v e -> Maybe (Array r ix e)

-- | Convert an array into a vector. Will perform a cast if resulting
--   vector is of compatible representation, otherwise memory copy will
--   occur.
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example a <a>S</a>torable Array is created and then casted
--   into a Storable <a>Vector</a> in costant time:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Massiv.Array.Manifest.Vector (toVector)
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; toVector (makeArrayR S Par (Sz2 5 6) (\(i :. j) -&gt; i + j)) :: VS.Vector Int
--   [0,1,2,3,4,5,1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9]
--   </pre>
--   
--   While in this example <a>S</a>torable Array will first be converted
--   into <a>U</a>nboxed representation in <a>Par</a>allel and only after
--   that will be coverted into Unboxed <a>Vector</a> in constant time.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; toVector (makeArrayR S Par (Sz2 5 6) (\(i :. j) -&gt; i + j)) :: VU.Vector Int
--   [0,1,2,3,4,5,1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9]
--   </pre>
toVector :: forall r ix e v. (Manifest r e, Load r ix e, Manifest (ARepr v) e, Vector v e, VRepr (ARepr v) ~ v) => Array r ix e -> v e

-- | <i>O(1)</i> - conversion from <a>Mutable</a> array to a corresponding
--   vector. Will return <a>Nothing</a> only if source array representation
--   was not one of <a>B</a>, <a>N</a>, <a>P</a>, <a>S</a> or <a>U</a>.
castToVector :: forall v r ix e. (Manifest r e, Index ix, VRepr r ~ v) => Array r ix e -> Maybe (v e)

-- | Match vector type to array representation
type family ARepr (v :: Type -> Type) :: Type

-- | Match array representation to a vector type
type family VRepr r :: Type -> Type


module Data.Massiv.Array.Manifest

-- | Manifest arrays are backed by actual memory and values are looked up
--   versus computed as it is with delayed arrays. Because manifest arrays
--   are located in memory their contents can be mutated once thawed into
--   <a>MArray</a>. The process of changed a mutable <a>MArray</a> back
--   into an immutable <a>Array</a> is called freezing.
class Source r e => Manifest r e

-- | Just like <a>generateArrayS</a>, except this generator <b>will</b>
--   respect the supplied computation strategy, and for that reason it is
--   restricted to <a>IO</a>.
generateArray :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Just like <a>generateArray</a>, except generating action will receive
--   a row-major linear index.
generateArrayLinear :: forall r ix e m. (MonadUnliftIO m, Manifest r e, Index ix) => Comp -> Sz ix -> (Ix1 -> m e) -> m (Array r ix e)

-- | Sequentially generate a pure array. Much like <a>makeArray</a> creates
--   a pure array this function will use <a>Manifest</a> interface to
--   generate a pure <a>Array</a> in the end, except that computation
--   strategy is set to <a>Seq</a>. Element producing function no longer
--   has to be pure but is a stateful action, becuase it is restricted to
--   <a>PrimMonad</a> thus allows for sharing the state between computation
--   of each element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef (0 :: Int)
--   
--   &gt;&gt;&gt; generateArrayS (Sz1 6) (\ i -&gt; modifyIORef' ref (+i) &gt;&gt; print i &gt;&gt; pure i) :: IO (Array U Ix1 Int)
--   0
--   1
--   2
--   3
--   4
--   5
--   Array U Seq (Sz1 6)
--     [ 0, 1, 2, 3, 4, 5 ]
--   
--   &gt;&gt;&gt; readIORef ref
--   15
--   </pre>
generateArrayS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (ix -> m e) -> m (Array r ix e)

-- | Same as <a>generateArray</a> but with action that accepts row-major
--   linear index.
generateArrayLinearS :: forall r ix e m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (Int -> m e) -> m (Array r ix e)

-- | Similar to <a>makeSplitSeedArray</a>, except it will produce a
--   Manifest array and will return back the last unused seed together with
--   all final seeds produced by each scheduled job. This function can be
--   thought of as an unfolding done in parallel while iterating in a
--   customizable manner.
generateSplitSeedArray :: forall r ix e g it. (Iterator it, Manifest r e, Index ix) => it -> g -> (forall s. g -> ST s (g, g)) -> Comp -> Sz ix -> (forall s. Ix1 -> ix -> g -> ST s (e, g)) -> (g, [g], Array r ix e)

-- | Use per worker thread state while generating elements of the array.
--   Very useful for things that are not thread safe.
generateArrayWS :: forall r ix e s m. (Manifest r e, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (ix -> s -> m e) -> m (Array r ix e)

-- | Same as <a>generateArrayWS</a>, but use linear indexing instead.
generateArrayLinearWS :: forall r ix e s m. (Manifest r e, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Sz ix -> (Int -> s -> m e) -> m (Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers while performing an <a>IO</a>
--   action at each iteration.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldrPrimM_ (Sz1 10) (\(f0, f1) -&gt; (f0, (f1, f0 + f1)) &lt;$ print f1) (0, 1) :: IO (Array P Ix1 Int)
--   1
--   1
--   2
--   3
--   5
--   8
--   13
--   21
--   34
--   55
--   Array P Seq (Sz1 10)
--     [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ]
--   </pre>
unfoldrPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldrPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldrPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldrPrimM</a>, but do the unfolding with index aware
--   function.
unfoldrPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldrPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldrPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (e, a)) -> a -> m (a, Array r ix e)

-- | Sequentially unfold an array from the left.
--   
--   <h4><b>Examples</b></h4>
--   
--   Create an array with Fibonacci numbers starting at the end while
--   performing and <a>IO</a> action on the accumulator for each element of
--   the array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldlPrimM_ (Sz1 10) (\a@(f0, f1) -&gt; let fn = f0 + f1 in print a &gt;&gt; return ((f1, fn), f0)) (0, 1) :: IO (Array P Ix1 Int)
--   (0,1)
--   (1,1)
--   (1,2)
--   (2,3)
--   (3,5)
--   (5,8)
--   (8,13)
--   (13,21)
--   (21,34)
--   (34,55)
--   Array P Seq (Sz1 10)
--     [ 34, 21, 13, 8, 5, 3, 2, 1, 1, 0 ]
--   </pre>
unfoldlPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (Array r ix e)

-- | Same as <a>unfoldlPrimM_</a> but do the unfolding with index aware
--   function.
iunfoldlPrimM_ :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (Array r ix e)

-- | Just like <a>iunfoldlPrimM</a>, but do the unfolding with index aware
--   function.
unfoldlPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Just like <a>iunfoldlPrimM_</a>, but also returns the final value of
--   the accumulator.
iunfoldlPrimM :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (a -> ix -> m (a, e)) -> a -> m (a, Array r ix e)

-- | Sequentially loop over a mutable array while modifying each element
--   with an action.
forPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an action to it. There is no mutation to the array, unless
--   the action itself modifies it.
forPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying an index aware action to it. There is no mutation to the
--   array, unless the action itself modifies it.
iforPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (ix -> e -> m ()) -> m ()

-- | Sequentially loop over a mutable array while modifying each element
--   with an index aware action.
iforLinearPrimM :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m e) -> m ()

-- | Sequentially loop over a mutable array while reading each element and
--   applying a linear index aware action to it. There is no mutation to
--   the array, unless the action itself modifies it.
iforLinearPrimM_ :: (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (Int -> e -> m ()) -> m ()

-- | Sequentially loop over the intersection of two mutable arrays while
--   reading elements from both and applying an action to it. There is no
--   mutation to the actual arrays, unless the action itself modifies
--   either one of them.
for2PrimM_ :: forall r1 r2 e1 e2 ix m. (PrimMonad m, Index ix, Manifest r1 e1, Manifest r2 e2) => MArray (PrimState m) r1 ix e1 -> MArray (PrimState m) r2 ix e2 -> (e1 -> e2 -> m ()) -> m ()

-- | Same as <a>for2PrimM_</a>, but with index aware action.
ifor2PrimM_ :: forall r1 r2 e1 e2 ix m. (PrimMonad m, Index ix, Manifest r1 e1, Manifest r2 e2) => MArray (PrimState m) r1 ix e1 -> MArray (PrimState m) r2 ix e2 -> (ix -> e1 -> e2 -> m ()) -> m ()

-- | Array representation for Boxed elements. Its elements are strict to
--   Weak Head Normal Form (WHNF) only.
data B
B :: B

-- | Array representation for Boxed elements. This data structure is lazy
--   with respect to its elements.
--   
--   <h4><b>Example</b></h4>
--   
--   Memoized version of a factorial that relies on laziness. Note that
--   computing memoized factorial of a million would likely overflow
--   memory.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :{
--   mkMemoFactorial :: Int -&gt; (Int -&gt; Integer)
--   mkMemoFactorial n =
--     let arr = makeVectorR BL Seq (Sz1 n) fact
--         fact i | i == 0 = 1
--                | otherwise = (arr ! (i - 1)) * toInteger i
--     in (arr !)
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fact = mkMemoFactorial 1000001
--   
--   &gt;&gt;&gt; fact 50
--   30414093201713378043612608166064768844377641568960512000000000000
--   
--   &gt;&gt;&gt; length $ show $ fact 5000
--   16326
--   </pre>
data BL
BL :: BL
data BN
BN :: BN

-- | Type and pattern <a>N</a> have been added for backwards compatibility
--   and will be replaced in the future in favor of <a>BN</a>.
--   
--   <i>Deprecated</i> - since 1.0.0

-- | <i>Deprecated: In favor of more consistently named <a>BN</a></i>
type N = BN

-- | <i>Deprecated: In favor of more consistently named <a>BN</a></i>
pattern N :: N

-- | An error that gets thrown when an unitialized element of a boxed array
--   gets accessed. Can only happen when array was constructed with
--   <a>unsafeNew</a>.
data Uninitialized
Uninitialized :: Uninitialized

-- | <i>O(n)</i> - Perform a row-major search starting at <tt>0</tt> for an
--   element. Returns the index of the first occurance of an element or
--   <a>Nothing</a> if a predicate could not be satisifed after it was
--   applyied to all elements of the array.
findIndex :: (Index ix, Manifest r e) => (e -> Bool) -> Array r ix e -> Maybe ix

-- | <i>O(1)</i> - Cast a strict boxed array into a lazy boxed array.
toLazyArray :: Array B ix e -> Array BL ix e

-- | <i>O(n)</i> - Evaluate all elements of a boxed lazy array to weak head
--   normal form
evalLazyArray :: Index ix => Array BL ix e -> Array B ix e

-- | <i>O(n)</i> - Evaluate all elements of a boxed lazy array to normal
--   form
forceLazyArray :: (NFData e, Index ix) => Array BL ix e -> Array N ix e

-- | <i>O(1)</i> - Converts array from <a>N</a> to <a>B</a> representation.
unwrapNormalForm :: Array N ix e -> Array B ix e

-- | <i>O(n)</i> - Compute all elements of a boxed array to NF (normal
--   form)
evalNormalForm :: (Index ix, NFData e) => Array B ix e -> Array N ix e

-- | <i>O(1)</i> - Unwrap boxed array. This will discard any possible
--   slicing that has been applied to the array.
unwrapLazyArray :: Array BL ix e -> Array e

-- | <i>O(1)</i> - Wrap a boxed array.
wrapLazyArray :: Array e -> Vector BL e

-- | <i>O(1)</i> - Unwrap boxed array. This will discard any possible
--   slicing that has been applied to the array.
unwrapArray :: Array B ix e -> Array e

-- | <i>O(n)</i> - Wrap a boxed array and evaluate all elements to a WHNF.
evalArray :: Comp -> Array e -> Vector B e

-- | <i>O(1)</i> - Unwrap mutable boxed array. This will discard any
--   possible slicing that has been applied to the array.
unwrapMutableArray :: MArray s B ix e -> MutableArray s e

-- | <i>O(1)</i> - Unwrap mutable boxed lazy array. This will discard any
--   possible slicing that has been applied to the array.
unwrapMutableLazyArray :: MArray s BL ix e -> MutableArray s e

-- | <i>O(n)</i> - Wrap mutable boxed array and evaluate all elements to
--   WHNF.
evalMutableArray :: PrimMonad m => MutableArray (PrimState m) e -> m (MArray (PrimState m) B Ix1 e)

-- | <i>O(1)</i> - Unwrap a fully evaluated boxed array. This will discard
--   any possible slicing that has been applied to the array.
unwrapNormalFormArray :: Array N ix e -> Array e

-- | <i>O(n)</i> - Wrap a boxed array and evaluate all elements to a Normal
--   Form (NF).
evalNormalFormArray :: NFData e => Comp -> Array e -> Array N Ix1 e

-- | <i>O(1)</i> - Unwrap a fully evaluated mutable boxed array. This will
--   discard any possible slicing that has been applied to the array.
unwrapNormalFormMutableArray :: MArray s N ix e -> MutableArray s e

-- | <i>O(n)</i> - Wrap mutable boxed array and evaluate all elements to
--   NF.
evalNormalFormMutableArray :: (PrimMonad m, NFData e) => MutableArray (PrimState m) e -> m (MArray (PrimState m) N Ix1 e)

-- | <i>O(1)</i> - Converts a boxed <a>Array</a> into a <a>Vector</a>
--   without touching any elements.
toBoxedVector :: Index ix => Array BL ix a -> Vector a

-- | <i>O(1)</i> - Converts a boxed <a>MArray</a> into a <a>MVector</a>.
toBoxedMVector :: Index ix => MArray s BL ix a -> MVector s a

-- | <i>O(1)</i> - Cast a boxed vector without touching any elements.
fromBoxedVector :: Vector a -> Vector BL a

-- | <i>O(1)</i> - Convert mutable boxed vector to a lazy mutable boxed
--   array. Both keep pointing to the same memory
fromBoxedMVector :: MVector s a -> MArray s BL Ix1 a

-- | <i>O(n)</i> - Convert a boxed vector and evaluate all elements to
--   WHNF. Computation strategy will be respected during evaluation
evalBoxedVector :: Comp -> Vector a -> Array B Ix1 a

-- | <i>O(n)</i> - Convert mutable boxed vector and evaluate all elements
--   to WHNF sequentially. Both keep pointing to the same memory
evalBoxedMVector :: PrimMonad m => MVector (PrimState m) a -> m (MArray (PrimState m) B Ix1 a)

-- | Representation for <a>Prim</a>itive elements
data P
P :: P

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class () => Prim a

-- | <i>O(n)</i> - Ensure that the size matches the internal
--   <a>ByteArray</a>. If not make a copy of the slice and return it as
--   <a>ByteArray</a>
toByteArray :: (Index ix, Prim e) => Array P ix e -> ByteArray

-- | <i>O(1)</i> - Unwrap Ensure that the size matches the internal
--   <a>ByteArray</a>.
toByteArrayM :: (Prim e, Index ix, MonadThrow m) => Array P ix e -> m ByteArray

-- | <i>O(1)</i> - Extract the internal <a>ByteArray</a>. This will ignore
--   any possible slicing that has been applied to the array. Use
--   <a>toByteArray</a> in order to preserve slicing or
--   <a>unwrapByteArrayOffset</a> to get ahold of the offset
unwrapByteArray :: Array P ix e -> ByteArray

-- | <i>O(1)</i> - Extract potential linear offset into the underlying
--   <a>ByteArray</a>, which can also be extracted with
--   <a>unwrapByteArray</a>.
unwrapByteArrayOffset :: Array P ix e -> Int

-- | <i>O(1)</i> - Construct a flat Array from <a>ByteArray</a>
fromByteArray :: forall e. Prim e => Comp -> ByteArray -> Array P Ix1 e

-- | <i>O(1)</i> - Construct a primitive array from the <a>ByteArray</a>.
--   Will return <a>Nothing</a> if number of elements doesn't match.
fromByteArrayM :: (MonadThrow m, Index ix, Prim e) => Comp -> Sz ix -> ByteArray -> m (Array P ix e)

-- | <i>O(1)</i> - Construct a primitive array from the <a>ByteArray</a>.
--   Will return <a>Nothing</a> if number of elements doesn't match.
fromByteArrayOffsetM :: (MonadThrow m, Index ix, Prim e) => Comp -> Sz ix -> Int -> ByteArray -> m (Array P ix e)

-- | <i>O(n)</i> - Try to cast a mutable array to <a>MutableByteArray</a>,
--   if sizes do not match make a copy. Returns <a>True</a> if an array was
--   converted without a copy, in which case it means that the source at
--   the resulting array are still pointing to the same location in memory.
toMutableByteArray :: forall ix e m. (Prim e, Index ix, PrimMonad m) => MArray (PrimState m) P ix e -> m (Bool, MutableByteArray (PrimState m))

-- | <i>O(1)</i> - Extract the internal <a>MutableByteArray</a>. This will
--   discard any possible slicing that has been applied to the array.
unwrapMutableByteArray :: MArray s P ix e -> MutableByteArray s

-- | <i>O(1)</i> - Extract the linear offset into underlying
--   <a>MutableByteArray</a>, which can aslo be extracted with
--   <a>unwrapMutableByteArray</a>.
unwrapMutableByteArrayOffset :: MArray s P ix e -> Int

-- | <i>O(1)</i> - Construct a flat Array from <a>MutableByteArray</a>
fromMutableByteArray :: forall e s. Prim e => MutableByteArray s -> MArray s P Ix1 e

-- | <i>O(1)</i> - Construct a primitive mutable array from the
--   <a>MutableByteArray</a>. Will throw
--   <a>SizeElementsMismatchException</a> if number of elements doesn't
--   match.
fromMutableByteArrayM :: (MonadThrow m, Index ix, Prim e) => Sz ix -> MutableByteArray s -> m (MArray s P ix e)

-- | <i>O(1)</i> - Construct a primitive mutable array from the
--   <a>MutableByteArray</a>. Will throw
--   <a>SizeElementsMismatchException</a> if number of elements doesn't
--   match.
fromMutableByteArrayOffsetM :: (MonadThrow m, Index ix, Prim e) => Sz ix -> Ix1 -> MutableByteArray s -> m (MArray s P ix e)

-- | <i>O(1)</i> - Cast a primitive array to a primitive vector.
toPrimitiveVector :: Index ix => Array P ix e -> Vector e

-- | <i>O(1)</i> - Cast a mutable primitive array to a mutable primitive
--   vector.
toPrimitiveMVector :: Index ix => MArray s P ix e -> MVector s e

-- | <i>O(1)</i> - Cast a primitive vector to a primitive array.
fromPrimitiveVector :: Vector e -> Array P Ix1 e

-- | <i>O(1)</i> - Cast a mutable primitive vector to a mutable primitive
--   array.
fromPrimitiveMVector :: MVector s e -> MArray s P Ix1 e

-- | Representation for <a>Storable</a> elements
data S
S :: S

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a

-- | Very similar to <tt><a>computeAs</a> <a>S</a></tt> except load the
--   source array into memory allocated with <tt>malloc</tt> on C heap. It
--   can potentially be useful when iteroperating with some C programs.
mallocCompute :: forall r ix e. (Size r, Load r ix e, Storable e) => Array r ix e -> IO (Array S ix e)

-- | Allocate memory on C heap with <tt>malloc</tt> and copy the source
--   array over.
mallocCopy :: forall ix e. (Index ix, Storable e) => Array S ix e -> IO (Array S ix e)

-- | <i>O(1)</i> - Unwrap storable array and pull out the underlying
--   storable vector.
toStorableVector :: Index ix => Array S ix e -> Vector e

-- | <i>O(1)</i> - Unwrap storable mutable array and pull out the
--   underlying storable mutable vector.
toStorableMVector :: Index ix => MArray s S ix e -> MVector s e

-- | <i>O(1)</i> - Cast a storable vector to a storable array.
fromStorableVector :: Comp -> Vector e -> Vector S e

-- | <i>O(1)</i> - Cast a mutable storable vector to a mutable storable
--   array.
fromStorableMVector :: MVector s e -> MVector s S e

-- | A pointer to the beginning of the mutable array.
withPtr :: MonadUnliftIO m => MArray RealWorld S ix e -> (Ptr e -> m b) -> m b

-- | Representation for <a>Unbox</a>ed elements
data U
U :: U
class (Vector Vector a, MVector MVector a) => Unbox a

-- | <i>O(1)</i> - Unwrap unboxed array and pull out the underlying unboxed
--   vector.
toUnboxedVector :: Array U ix e -> Vector e

-- | <i>O(1)</i> - Unwrap unboxed mutable array and pull out the underlying
--   unboxed mutable vector.
toUnboxedMVector :: MArray s U ix e -> MVector s e

-- | <i>O(1)</i> - Wrap an unboxed vector and produce an unboxed flat
--   array.
fromUnboxedVector :: Unbox e => Comp -> Vector e -> Vector U e

-- | <i>O(1)</i> - Wrap an unboxed mutable vector and produce a mutable
--   unboxed flat array.
fromUnboxedMVector :: Unbox e => MVector s e -> MVector s U e

-- | <i>O(n)</i> - Convert a strict ByteString into a manifest array. Will
--   return <a>Nothing</a> if length doesn't match the total number of
--   elements of new array.
fromByteString :: Load r Ix1 Word8 => Comp -> ByteString -> Vector r Word8

-- | <i>O(1)</i> - Cast a strict <a>ByteString</a> into a <a>S</a>torable
--   array
castFromByteString :: Comp -> ByteString -> Vector S Word8

-- | <i>O(n)</i> - Convert any source array into a strict
--   <a>ByteString</a>. In case when the source array is actually storable,
--   no memory copy will occur.
toByteString :: Load r ix Word8 => Array r ix Word8 -> ByteString

-- | <i>O(1)</i> - Cast a <a>S</a>torable array into a strict
--   <a>ByteString</a>
castToByteString :: Index ix => Array S ix Word8 -> ByteString

-- | <i>O(n)</i> - Conversion of array monoidally into a ByteString
--   <a>Builder</a>.
toBuilder :: (Index ix, Source r e) => (e -> Builder) -> Array r ix e -> Builder

-- | <i>O(1)</i> - Cast a storable array of <a>Word8</a> to ByteString
--   <a>Builder</a>.
castToBuilder :: Index ix => Array S ix Word8 -> Builder


module Data.Massiv.Array.Stencil

-- | Stencil is abstract description of how to handle elements in the
--   neighborhood of every array cell in order to compute a value for the
--   cells in the new array. Use <a>makeStencil</a> and
--   <a>makeConvolutionStencil</a> in order to create a stencil.
data Stencil ix e a

-- | Construct a stencil from a function, which describes how to calculate
--   the value at a point while having access to neighboring elements with
--   a function that accepts idices relative to the center of stencil.
--   Trying to index outside the stencil box will result in a runtime error
--   upon stencil creation.
--   
--   <i>Note</i> - Once correctness of stencil is verified then switching
--   to <a>makeUnsafeStencil</a> is recommended in order to get the most
--   performance out of the <a>Stencil</a>
--   
--   <h4><b>Example</b></h4>
--   
--   Below is an example of creating a <a>Stencil</a>, which, when mapped
--   over a 2-dimensional array, will compute an average of all elements in
--   a 3x3 square for each element in that array.
--   
--   <i>Note</i> - Make sure to add an <tt>INLINE</tt> pragma, otherwise
--   performance will be terrible.
--   
--   <pre>
--   average3x3Stencil :: Fractional a =&gt; Stencil Ix2 a a
--   average3x3Stencil = makeStencil (Sz (3 :. 3)) (1 :. 1) $  get -&gt;
--     (  get (-1 :. -1) + get (-1 :. 0) + get (-1 :. 1) +
--        get ( 0 :. -1) + get ( 0 :. 0) + get ( 0 :. 1) +
--        get ( 1 :. -1) + get ( 1 :. 0) + get ( 1 :. 1)   ) / 9
--   {-# INLINE average3x3Stencil #-}
--   </pre>
makeStencil :: Index ix => Sz ix -> ix -> ((ix -> e) -> a) -> Stencil ix e a

-- | Get the size of the stencil
getStencilSize :: Stencil ix e a -> Sz ix

-- | Get the index of the stencil's center
getStencilCenter :: Stencil ix e a -> ix

-- | Padding of the source array before stencil application.
--   
--   <h4><b>Examples</b></h4>
--   
--   In order to see the affect of padding we can simply apply an identity
--   stencil to an array:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ resize' (Sz2 2 3) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; applyStencil noPadding idStencil a
--   Array DW Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 1 2) (Sz2 3 4) (Fill 0)) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 1, 2, 3, 0, 0, 0, 0 ]
--     , [ 0, 0, 4, 5, 6, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
--   
--   It is also a nice technique to see the border resolution strategy in
--   action:
--   
--   <pre>
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Wrap) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     , [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     , [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
--     , [ 4, 5, 6, 4, 5, 6, 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Edge) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 1, 1, 1, 1, 2, 3, 3, 3, 3 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     , [ 4, 4, 4, 4, 5, 6, 6, 6, 6 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Reflect) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     , [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 6, 5, 4, 4, 5, 6, 6, 5, 4 ]
--     , [ 3, 2, 1, 1, 2, 3, 3, 2, 1 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 2 3) (Sz2 2 3) Continue) idStencil a
--   Array DW Seq (Sz (6 :. 9))
--     [ [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     , [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     , [ 1, 3, 2, 1, 2, 3, 2, 1, 3 ]
--     , [ 4, 6, 5, 4, 5, 6, 5, 4, 6 ]
--     ]
--   </pre>
data Padding ix e
Padding :: !Sz ix -> !Sz ix -> !Border e -> Padding ix e
[paddingFromOrigin] :: Padding ix e -> !Sz ix
[paddingFromBottom] :: Padding ix e -> !Sz ix

-- | Element to do padding with
[paddingWithElement] :: Padding ix e -> !Border e

-- | Also known as "valid" padding. When stencil is applied to an array,
--   that array will shrink, unless the stencil is of size 1.
noPadding :: Index ix => Padding ix e

-- | Padding that matches the size of the stencil, which is known as "same"
--   padding, because when a stencil is applied to an array with such
--   matching padding, the resulting array will be of the same size as the
--   source array. This is exactly the behavior of <a>mapStencil</a>
samePadding :: Index ix => Stencil ix e a -> Border e -> Padding ix e

-- | Map a constructed stencil over an array. Resulting array must be
--   <a>compute</a>d in order to be useful.
mapStencil :: (Index ix, Manifest r e) => Border e -> Stencil ix e a -> Array r ix e -> Array DW ix a

-- | Apply a constructed stencil over an array. Resulting array must be
--   <a>compute</a>d in order to be useful. Unlike <a>mapStencil</a>, the
--   size of the resulting array will not necesserally be the same as the
--   source array, which will depend on the padding.
applyStencil :: (Index ix, Manifest r e) => Padding ix e -> Stencil ix e a -> Array r ix e -> Array DW ix a

-- | Identity stencil that does not change the elements of the source
--   array.
idStencil :: Index ix => Stencil ix e e

-- | Sum all elements in the stencil region
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 2 5) (* 2) (1 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (2 :. 5))
--     [ [ 2, 4, 8, 16, 32 ]
--     , [ 64, 128, 256, 512, 1024 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (sumStencil (Sz2 1 2)) a
--   Array DW Seq (Sz (2 :. 4))
--     [ [ 6, 12, 24, 48 ]
--     , [ 192, 384, 768, 1536 ]
--     ]
--   
--   &gt;&gt;&gt; [2 + 4, 4 + 8, 8 + 16, 16 + 32] :: [Int]
--   [6,12,24,48]
--   </pre>
sumStencil :: (Num e, Index ix) => Sz ix -> Stencil ix e e

-- | Multiply all elements in the stencil region
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 2 2) (+1) (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (2 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding 0 2 (Fill 0)) (productStencil 2) a
--   Array DW Seq (Sz (3 :. 3))
--     [ [ 24, 0, 0 ]
--     , [ 0, 0, 0 ]
--     , [ 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding 0 2 Reflect) (productStencil 2) a
--   Array DW Seq (Sz (3 :. 3))
--     [ [ 24, 64, 24 ]
--     , [ 144, 256, 144 ]
--     , [ 24, 64, 24 ]
--     ]
--   </pre>
productStencil :: (Num e, Index ix) => Sz ix -> Stencil ix e e

-- | Find the average value of all elements in the stencil region
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Double)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11.0, 12.0, 13.0, 14.0 ]
--     , [ 15.0, 16.0, 17.0, 18.0 ]
--     , [ 19.0, 20.0, 21.0, 22.0 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (avgStencil (Sz2 2 3)) a
--   Array DW Seq (Sz (2 :. 2))
--     [ [ 14.0, 15.0 ]
--     , [ 18.0, 19.0 ]
--     ]
--   
--   &gt;&gt;&gt; Prelude.sum [11.0, 12.0, 13.0, 15.0, 16.0, 17.0] / 6 :: Double
--   14.0
--   </pre>
avgStencil :: (Fractional e, Index ix) => Sz ix -> Stencil ix e e

-- | Create a stencil centered at 0 that will extract the maximum value in
--   the region of supplied size.
--   
--   <h4><b>Example</b></h4>
--   
--   Here is a sample implementation of max pooling.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a &lt;- computeAs P &lt;$&gt; resizeM (Sz2 9 9) (Ix1 10 ..: 91)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (9 :. 9))
--     [ [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22, 23, 24, 25, 26, 27 ]
--     , [ 28, 29, 30, 31, 32, 33, 34, 35, 36 ]
--     , [ 37, 38, 39, 40, 41, 42, 43, 44, 45 ]
--     , [ 46, 47, 48, 49, 50, 51, 52, 53, 54 ]
--     , [ 55, 56, 57, 58, 59, 60, 61, 62, 63 ]
--     , [ 64, 65, 66, 67, 68, 69, 70, 71, 72 ]
--     , [ 73, 74, 75, 76, 77, 78, 79, 80, 81 ]
--     , [ 82, 83, 84, 85, 86, 87, 88, 89, 90 ]
--     ]
--   
--   &gt;&gt;&gt; computeWithStrideAs P (Stride 3) $ mapStencil Edge (maxStencil (Sz 3)) a
--   Array P Seq (Sz (3 :. 3))
--     [ [ 30, 33, 36 ]
--     , [ 57, 60, 63 ]
--     , [ 84, 87, 90 ]
--     ]
--   </pre>
maxStencil :: (Bounded e, Ord e, Index ix) => Sz ix -> Stencil ix e e

-- | Create a stencil centered at 0 that will extract the maximum value in
--   the region of supplied size.
--   
--   <h4><b>Example</b></h4>
--   
--   Here is a sample implementation of min pooling.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a &lt;- computeAs P &lt;$&gt; resizeM (Sz2 9 9) (Ix1 10 ..: 91)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (9 :. 9))
--     [ [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22, 23, 24, 25, 26, 27 ]
--     , [ 28, 29, 30, 31, 32, 33, 34, 35, 36 ]
--     , [ 37, 38, 39, 40, 41, 42, 43, 44, 45 ]
--     , [ 46, 47, 48, 49, 50, 51, 52, 53, 54 ]
--     , [ 55, 56, 57, 58, 59, 60, 61, 62, 63 ]
--     , [ 64, 65, 66, 67, 68, 69, 70, 71, 72 ]
--     , [ 73, 74, 75, 76, 77, 78, 79, 80, 81 ]
--     , [ 82, 83, 84, 85, 86, 87, 88, 89, 90 ]
--     ]
--   
--   &gt;&gt;&gt; computeWithStrideAs P (Stride 3) $ mapStencil Edge (minStencil (Sz 3)) a
--   Array P Seq (Sz (3 :. 3))
--     [ [ 10, 13, 16 ]
--     , [ 37, 40, 43 ]
--     , [ 64, 67, 70 ]
--     ]
--   </pre>
minStencil :: (Bounded e, Ord e, Index ix) => Sz ix -> Stencil ix e e

-- | Stencil that does a left fold in a row-major order. Regardless of the
--   supplied size resulting stencil will be centered at zero, although by
--   using <a>Padding</a> it is possible to overcome this limitation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (foldlStencil (flip (:)) [] (Sz2 3 2)) a
--   Array DW Seq (Sz (1 :. 3))
--     [ [ [20,19,16,15,12,11], [21,20,17,16,13,12], [22,21,18,17,14,13] ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil (Padding (Sz2 1 0) 0 (Fill 10)) (foldlStencil (flip (:)) [] (Sz2 3 2)) a
--   Array DW Seq (Sz (2 :. 3))
--     [ [ [16,15,12,11,10,10], [17,16,13,12,10,10], [18,17,14,13,10,10] ]
--     , [ [20,19,16,15,12,11], [21,20,17,16,13,12], [22,21,18,17,14,13] ]
--     ]
--   </pre>
foldlStencil :: Index ix => (a -> e -> a) -> a -> Sz ix -> Stencil ix e a

-- | Stencil that does a right fold in a row-major order. Regardless of the
--   supplied size resulting stencil will be centered at zero, although by
--   using <a>Padding</a> it is possible to overcome this limitation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs P $ iterateN (Sz2 3 4) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array P Seq (Sz (3 :. 4))
--     [ [ 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18 ]
--     , [ 19, 20, 21, 22 ]
--     ]
--   
--   &gt;&gt;&gt; applyStencil noPadding (foldrStencil (:) [] (Sz2 2 3)) a
--   Array DW Seq (Sz (2 :. 2))
--     [ [ [11,12,13,15,16,17], [12,13,14,16,17,18] ]
--     , [ [15,16,17,19,20,21], [16,17,18,20,21,22] ]
--     ]
--   </pre>
foldrStencil :: Index ix => (e -> a -> a) -> a -> Sz ix -> Stencil ix e a

-- | Create a stencil that will fold all elements in the region monoidally.
foldStencil :: (Monoid e, Index ix) => Sz ix -> Stencil ix e e

-- | A Profunctor dimap. Same caviat applies as in <a>lmapStencil</a>
dimapStencil :: (c -> d) -> (a -> b) -> Stencil ix d a -> Stencil ix c b

-- | A contravariant map of a second type parameter. In other words map a
--   function over each element of the array, that the stencil will be
--   applied to.
--   
--   <b>Note</b>: This map can be very inefficient, since for stencils
--   larger than 1 element in size, the supllied function will be
--   repeatedly applied to the same element. It is better to simply map
--   that function over the source array instead.
lmapStencil :: (c -> d) -> Stencil ix d a -> Stencil ix c a

-- | A covariant map over the right most type argument. In other words the
--   usual <a>fmap</a> from <a>Functor</a>:
--   
--   <pre>
--   fmap == rmapStencil
--   </pre>
rmapStencil :: (a -> b) -> Stencil ix e a -> Stencil ix e b

-- | Create a convolution stencil by specifying border resolution technique
--   and an accumulator function.
--   
--   <i>Note</i> - Using <a>makeUnsafeConvolutionStencil</a> will be
--   slightly faster, therefore it is recommended to switch from this
--   function, after manual verification that the created stencil behaves
--   as expected.
--   
--   <h4><b>Examples</b></h4>
--   
--   Here is how to create a 2D horizontal Sobel Stencil:
--   
--   <pre>
--   sobelX :: Num e =&gt; Stencil Ix2 e e
--   sobelX = makeConvolutionStencil (Sz2 3 3) (1 :. 1)
--            $ f -&gt; f (-1 :. -1) (-1) . f (-1 :. 1) 1 .
--                    f ( 0 :. -1) (-2) . f ( 0 :. 1) 2 .
--                    f ( 1 :. -1) (-1) . f ( 1 :. 1) 1
--   {-# INLINE sobelX #-}
--   </pre>
makeConvolutionStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Make a stencil out of a Kernel Array. This <a>Stencil</a> will be
--   slower than if <a>makeConvolutionStencil</a> is used, but sometimes we
--   just really don't know the kernel at compile time.
makeConvolutionStencilFromKernel :: (Manifest r e, Index ix, Num e) => Array r ix e -> Stencil ix e e

-- | Make a <a>cross-correlation</a> stencil
--   
--   <i>Note</i> - Using <a>makeUnsafeCorrelationStencil</a> will be much
--   faster, therefore it is recommended to switch from this function,
--   after manual verification that the created stencil behaves as
--   expected.
makeCorrelationStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Make a <a>cross-correlation</a> stencil out of a Kernel Array. This
--   <a>Stencil</a> will be slower than if <a>makeCorrelationStencil</a> is
--   used, but sometimes we just really don't know the kernel at compile
--   time.
makeCorrelationStencilFromKernel :: (Manifest r e, Index ix, Num e) => Array r ix e -> Stencil ix e e
instance (Data.Massiv.Core.Index.Internal.Index ix, GHC.Show.Show e) => GHC.Show.Show (Data.Massiv.Array.Stencil.Padding ix e)
instance (GHC.Classes.Eq ix, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.Massiv.Array.Stencil.Padding ix e)


module Data.Massiv.Array.Delayed

-- | Delayed representation.
data D
D :: D

-- | <i>O(1)</i> Conversion from a source array to <a>D</a> representation.
delay :: (Index ix, Source r e) => Array r ix e -> Array D ix e

-- | Same as <a>liftArray2M</a>, but throws an imprecise exception on
--   mismatched sizes.
liftArray2' :: (HasCallStack, Index ix, Source r1 a, Source r2 b) => (a -> b -> e) -> Array r1 ix a -> Array r2 ix b -> Array D ix e

-- | Similar to <a>zipWith</a>, except dimensions of both arrays have to be
--   the same, otherwise it throws <a>SizeMismatchException</a>.
liftArray2M :: (Index ix, Source r1 a, Source r2 b, MonadThrow m) => (a -> b -> e) -> Array r1 ix a -> Array r2 ix b -> m (Array D ix e)

-- | Delayed load representation. Also known as Push array.
data DL
DL :: DL

-- | Convert any <a>Load</a>able array into <a>DL</a> representation.
toLoadArray :: forall r ix e. (Size r, Load r ix e) => Array r ix e -> Array DL ix e

-- | Describe how an array should be loaded into memory sequentially. For
--   parallelizable version see <a>makeLoadArray</a>.
makeLoadArrayS :: forall ix e. Index ix => Sz ix -> e -> (forall m. Monad m => (ix -> e -> m Bool) -> m ()) -> Array DL ix e

-- | Specify how an array should be loaded into memory. Unlike
--   <a>makeLoadArrayS</a>, loading function accepts a scheduler, thus can
--   be parallelized. If you need an unsafe version of this function see
--   <a>unsafeMakeLoadArray</a>.
makeLoadArray :: forall ix e. Index ix => Comp -> Sz ix -> e -> (forall s. Scheduler s () -> (ix -> e -> ST s Bool) -> ST s ()) -> Array DL ix e

-- | Convert an array that can be loaded with stride into <a>DL</a>
--   representation.
fromStrideLoad :: forall r ix e. StrideLoad r ix e => Stride ix -> Array r ix e -> Array DL ix e

-- | Delayed stream array that represents a sequence of values that can be
--   loaded sequentially. Important distinction from other arrays is that
--   its size might no be known until it is computed.
data DS
DS :: DS

-- | Flatten an array into a stream of values.
toStreamArray :: (Index ix, Source r e) => Array r ix e -> Vector DS e

-- | <i>O(1)</i> - Convert delayed stream array into <a>Steps</a>.
toSteps :: Vector DS e -> Steps Id e

-- | <i>O(1)</i> - Convert <a>Steps</a> into delayed stream array
fromSteps :: Steps Id e -> Vector DS e

-- | Delayed array that will be loaded in an interleaved fashion during
--   parallel computation.
--   
--   <i>Warning</i> - Will be deprecated in the next major version update.
data DI
DI :: DI

-- | Convert a source array into an array that, when computed, will have
--   its elemets evaluated out of order (interleaved amongst cores), hence
--   making unbalanced computation better parallelizable.
toInterleaved :: (Index ix, Source r e) => Array r ix e -> Array DI ix e

-- | <i>O(1)</i> - Unwrap the interleved array.
fromInterleaved :: Array DI ix e -> Array D ix e

-- | Delayed Windowed Array representation.
data DW
DW :: DW
data Window ix e
Window :: !ix -> !Sz ix -> (ix -> e) -> !Maybe Int -> Window ix e

-- | Index of where window will start at.
[windowStart] :: Window ix e -> !ix

-- | Size of the window
[windowSize] :: Window ix e -> !Sz ix

-- | Indexing function for the window
[windowIndex] :: Window ix e -> ix -> e

-- | Setting this value during stencil application improves cache
--   utilization by unrolling the loop for Ix2 and higher dimensions. Has
--   no affect on arrays with one dimension.
[windowUnrollIx2] :: Window ix e -> !Maybe Int

-- | Inserts a <a>Window</a> into a delayed array while scaling the window
--   down if it doesn't fit inside that array.
insertWindow :: Index ix => Array D ix e -> Window ix e -> Array DW ix e

-- | Get the <a>Window</a> from a windowed array.
getWindow :: Array DW ix e -> Maybe (Window ix e)

-- | Drop the <a>Window</a> from a windowed array.
dropWindow :: Array DW ix e -> Array D ix e

-- | Construct a delayed windowed array by supply a separate element
--   producing function for the interior of an array. This is very usful
--   for stencil mapping, where interior function does not perform boundary
--   checks, thus significantly speeding up computation process.
makeWindowedArray :: (Index ix, Source r e) => Array r ix e -> ix -> Sz ix -> (ix -> e) -> Array DW ix e


module Data.Massiv.Vector

-- | Type synonym for a single dimension array, or simply a flat vector.
type Vector r e = Array r Ix1 e

-- | Type synonym for a single dimension mutable array, or simply a flat
--   mutable vector.
type MVector s r e = MArray s r Ix1 e

-- | <i>O(1)</i> - Get the length of a <a>Stream</a> array, but only if it
--   is known exactly in constant time without looking at any of the
--   elements in the array.
--   
--   <i>Related</i>: <a>maxLinearSize</a>, <a>size</a>, <a>elemsCount</a>
--   and <a>totalElem</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slength $ sfromList []
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sreplicate 5 ()
--   Just (Sz1 5)
--   
--   &gt;&gt;&gt; slength $ makeArrayLinearR D Seq (Sz1 5) id
--   Just (Sz1 5)
--   
--   &gt;&gt;&gt; slength $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sunfoldrN 10 (\x -&gt; Just (x, x)) (0 :: Int)
--   Nothing
--   
--   &gt;&gt;&gt; slength $ sunfoldrExactN 10 (\x -&gt; (x, x)) (0 :: Int)
--   Just (Sz1 10)
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.Foldable.<a>length</a></tt></i> For some data
--   structures, like a list for example, it is an <i>O(n)</i> operation,
--   because there is a need to evaluate the full spine and possibly even
--   the elements in order to get the full length. With <a>Stream</a>
--   vectors that is not always the case.</li>
--   <li><i><tt>Data.Vector.Generic.<a>length</a></tt></i> In the vector
--   package this function will always break fusion, unless it is the only
--   operation that is applied to the vector.</li>
--   </ul>
slength :: forall r ix e. Stream r ix e => Array r ix e -> Maybe Sz1

-- | <i>O(1)</i> - Get the possible maximum linear size of an immutabe
--   array. If the lookup of size in constant time is not possible,
--   <a>Nothing</a> will be returned. This value will be used as the
--   initial size of the mutable array into which the loading will happen.
maxLinearSize :: Shape r ix => Array r ix e -> Maybe Sz1

-- | <i>O(1)</i> - Get the exact size of an immutabe array. Most of the
--   time will produce the size in constant time, except for <a>DS</a>
--   representation, which could result in evaluation of the whole stream.
--   See <a>maxLinearSize</a> and <a>slength</a> for more info.
size :: Size r => Array r ix e -> Sz ix

-- | <i>O(1)</i> - Check whether an array is empty or not.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (11 :. 21)
--   False
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (10 :. 21)
--   True
--   
--   &gt;&gt;&gt; isNull (empty :: Array D Ix5 Int)
--   True
--   
--   &gt;&gt;&gt; isNull $ sfromList []
--   True
--   </pre>
isNull :: Shape r ix => Array r ix e -> Bool

-- | <i>O(1)</i> - Check if array has elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNotNull (singleton 1 :: Array D Ix2 Int)
--   True
--   
--   &gt;&gt;&gt; isNotNull (empty :: Array D Ix2 Int)
--   False
--   </pre>
isNotNull :: Shape r ix => Array r ix e -> Bool

-- | <i>O(1)</i> - Infix version of <a>indexM</a>.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; a &lt;- fromListsM @U @Ix2 @Int Seq [[1,2,3],[4,5,6]]
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a !? 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a !? 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   
--   &gt;&gt;&gt; a !? 0 :. 3 :: Maybe Int
--   Nothing
--   </pre>
(!?) :: forall r ix e m. (Index ix, Manifest r e, MonadThrow m) => Array r ix e -> ix -> m e
infixl 4 !?

-- | <i>O(1)</i> - Infix version of <a>index'</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs U $ iterateN (Sz (2 :. 3)) succ (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a ! 0 :. 2
--   3
--   </pre>
(!) :: forall r ix e. (HasCallStack, Manifest r e, Index ix) => Array r ix e -> ix -> e
infixl 4 !

-- | <i>O(1)</i> - Lookup an element in the array. Returns <a>Nothing</a>,
--   when index is out of bounds and returns the element at the supplied
--   index otherwise. Use <a>indexM</a> instead, since it is more general
--   and it can just as well be used with <a>Maybe</a>.
index :: (Index ix, Manifest r e) => Array r ix e -> ix -> Maybe e

-- | <i>O(1)</i> - Lookup an element in the array. This is a partial
--   function and it will throw an error when index is out of bounds. It is
--   safer to use <a>indexM</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; index' xs 50
--   50
--   </pre>
index' :: (HasCallStack, Index ix, Manifest r e) => Array r ix e -> ix -> e

-- | <i>O(1)</i> - Get the first element of a <a>Source</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <a>shead'</a>, <a>headM</a>, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; head' (Ix1 10 ..: 10000000000000)
--   10
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>head</a></tt></i> Also constant time and
--   partial. Fusion is broken if there other consumers of the list.</li>
--   <li><i><tt>Data.Vector.Generic.<a>head</a></tt></i> Also constant time
--   and partial. Will cause materialization of the full vector if any
--   other function is applied to the vector.</li>
--   </ul>
head' :: forall r e. (HasCallStack, Source r e) => Vector r e -> e

-- | <i>O(1)</i> - Get the first element of a <a>Stream</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <a>head'</a>, <a>headM</a>, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; shead' $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   0
--   
--   &gt;&gt;&gt; shead' (Ix1 3 ... 5)
--   3
--   </pre>
shead' :: forall r e. (HasCallStack, Stream r Ix1 e) => Vector r e -> e

-- | <i>O(1)</i> - Get the last element of a <a>Source</a> vector. Throws
--   an error on empty.
--   
--   <i>Related</i>: <a>lastM</a>, <a>unsnocM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; last' (Ix1 10 ... 10000000000000)
--   10000000000000
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>last</a></tt></i> Also partial, but it has
--   <i>O(n)</i> complexity. Fusion is broken if there other consumers of
--   the list.</li>
--   <li><i><tt>Data.Vector.Generic.<a>last</a></tt></i> Also constant time
--   and partial. Will cause materialization of the full vector if any
--   other function is applied to the vector.</li>
--   </ul>
last' :: forall r e. (HasCallStack, Source r e) => Vector r e -> e

-- | <i>O(1)</i> - Lookup an element in the array.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
indexM :: (Index ix, Manifest r e, MonadThrow m) => Array r ix e -> ix -> m e

-- | <i>O(1)</i> - Get the first element of a <a>Source</a> vector.
--   
--   <i>Related</i>: <a>head'</a>, <a>shead'</a>, <a>sheadM</a>,
--   <a>unconsM</a>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; headM (Ix1 10 ..: 10000000000000)
--   10
--   
--   &gt;&gt;&gt; headM (Ix1 10 ..: 10000000000000) :: Maybe Int
--   Just 10
--   
--   &gt;&gt;&gt; headM (empty :: Array D Ix1 Int) :: Maybe Int
--   Nothing
--   
--   &gt;&gt;&gt; either show (const "") $ headM (Ix1 10 ..: 10)
--   "SizeEmptyException: (Sz1 0) corresponds to an empty array"
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.Maybe.<a>listToMaybe</a></tt></i> It also a safe way
--   to get the head of the list, except it is restricted to
--   <a>Maybe</a></li>
--   </ul>
headM :: forall r e m. (Source r e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Get the first element of a <a>Stream</a> vector.
--   
--   <i>Related</i>: <a>head'</a>, <a>shead'</a>, <a>headM</a>,
--   <a>unconsM</a>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; maybe 101 id $ sheadM (empty :: Vector D Int)
--   101
--   
--   &gt;&gt;&gt; maybe 101 id $ sheadM (singleton 202 :: Vector D Int)
--   202
--   
--   &gt;&gt;&gt; sheadM $ sunfoldr (\x -&gt; Just (x, x)) (0 :: Int)
--   0
--   
--   &gt;&gt;&gt; x &lt;- sheadM $ sunfoldr (\_ -&gt; Nothing) (0 :: Int)
--   *** Exception: SizeEmptyException: (Sz1 0) corresponds to an empty array
--   </pre>
sheadM :: forall r e m. (Stream r Ix1 e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Get the last element of a <a>Source</a> vector.
--   
--   <i>Related</i>: <a>last'</a>, <a>unsnocM</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; lastM (Ix1 10 ... 10000000000000)
--   10000000000000
--   
--   &gt;&gt;&gt; lastM (Ix1 10 ... 10000000000000) :: Maybe Int
--   Just 10000000000000
--   
--   &gt;&gt;&gt; either show (const "") $ lastM (fromList Seq [] :: Array P Ix1 Int)
--   "SizeEmptyException: (Sz1 0) corresponds to an empty array"
--   </pre>
lastM :: forall r e m. (Source r e, MonadThrow m) => Vector r e -> m e

-- | <i>O(1)</i> - Take one element off of the <a>Source</a> vector from
--   the left side, as well as the remaining part of the vector in delayed
--   <a>D</a> representation.
--   
--   <i>Related</i>: <a>head'</a>, <a>shead'</a>, <a>headM</a>,
--   <a>sheadM</a>, <a>cons</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unconsM (fromList Seq [1,2,3] :: Array P Ix1 Int)
--   (1,Array P Seq (Sz1 2)
--     [ 2, 3 ])
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Data.List.<a>uncons</a></tt></i> Same concept, except it is
--   restricted to <a>Maybe</a> instead of the more general
--   <a>MonadThrow</a></li>
--   </ul>
unconsM :: forall r e m. (MonadThrow m, Source r e) => Vector r e -> m (e, Vector r e)

-- | <i>O(1)</i> - Take one element off of the vector from the right side,
--   as well as the remaining part of the vector.
--   
--   <i>Related</i>: <a>last'</a>, <a>lastM</a>, <a>snoc</a>
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; unsnocM (fromList Seq [1,2,3] :: Array P Ix1 Int)
--   (Array P Seq (Sz1 2)
--     [ 1, 2 ],3)
--   </pre>
unsnocM :: forall r e m. (MonadThrow m, Source r e) => Vector r e -> m (Vector r e, e)

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Never fails,
--   instead adjusts the indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slice 10 5 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; slice (-10) 5 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; slice 9999999999998 50 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 3)
--     [ 9999999999998, 9999999999999, 10000000000000 ]
--   </pre>
slice :: forall r e. Source r e => Ix1 -> Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Throws an error
--   on incorrect indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; slice' 10 5 (Ix1 0 ... 100)
--   Array D Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; slice' 9999999999998 3 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 3)
--     [ 9999999999998, 9999999999999, 10000000000000 ]
--   </pre>
slice' :: forall r e. (HasCallStack, Source r e) => Ix1 -> Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Take a slice of a <a>Source</a> vector. Throws an error
--   on incorrect indices.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeSubregionException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sliceM 10 5 (Ix1 0 ... 100)
--   Array D Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; sliceM (-10) 5 (Ix1 0 ... 100)
--   *** Exception: SizeSubregionException: (Sz1 101) is to small for -10 (Sz1 5)
--   
--   &gt;&gt;&gt; sliceM 98 50 (Ix1 0 ... 100)
--   *** Exception: SizeSubregionException: (Sz1 101) is to small for 98 (Sz1 50)
--   
--   &gt;&gt;&gt; sliceM 9999999999998 3 (Ix1 0 ... 10000000000000)
--   Array D Seq (Sz1 3)
--     [ 9999999999998, 9999999999999, 10000000000000 ]
--   </pre>
sliceM :: forall r e m. (Source r e, MonadThrow m) => Ix1 -> Sz1 -> Vector r e -> m (Vector r e)

-- | Take a slice of a <a>Stream</a> vector. Never fails, instead adjusts
--   the indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sslice 10 5 (Ix1 0 ... 10000000000000)
--   Array DS Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; sslice 10 5 (sfromList [0 :: Int .. ])
--   Array DS Seq (Sz1 5)
--     [ 10, 11, 12, 13, 14 ]
--   
--   &gt;&gt;&gt; sslice (-10) 5 (Ix1 0 ... 10000000000000)
--   Array DS Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   </pre>
--   
--   Unlike <a>slice</a> it has to iterate through each element until the
--   staring index is reached, therefore something like <tt>sslice
--   9999999999998 50 (Ix1 0 ... 10000000000000)</tt> will not be feasable.
--   
--   <pre>
--   &gt;&gt;&gt; import System.Timeout (timeout)
--   
--   &gt;&gt;&gt; let smallArr = sslice 9999999999998 50 (Ix1 0 ... 10000000000000)
--   
--   &gt;&gt;&gt; timeout 500000 (computeIO smallArr :: IO (Array P Ix1 Int))
--   Nothing
--   </pre>
sslice :: forall r e. Stream r Ix1 e => Ix1 -> Sz1 -> Vector r e -> Vector DS e

-- | Same as <a>sliceAt'</a>, except it never fails.
--   
--   <h4><b>Examples</b></h4>
sliceAt :: forall r e. Source r e => Sz1 -> Vector r e -> (Vector r e, Vector r e)

-- | Same as <a>splitAt'</a>, except for a flat vector.
--   
--   <h4><b>Examples</b></h4>
sliceAt' :: (HasCallStack, Source r e) => Sz1 -> Vector r e -> (Vector r e, Vector r e)

-- | Same as <a>splitAtM</a>, except for a flat vector.
--   
--   <h4><b>Examples</b></h4>
sliceAtM :: forall r e m. (Source r e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e, Vector r e)

-- | <i>O(1)</i> - Get a vector without the last element. Never fails.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.init (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   
--   &gt;&gt;&gt; A.init (empty :: Array D Ix1 Int)
--   Array D Seq (Sz1 0)
--     [  ]
--   </pre>
init :: forall r e. Source r e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the last element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; init' (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   </pre>
init' :: forall r e. (HasCallStack, Source r e) => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the last element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; initM (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
--   
--   &gt;&gt;&gt; maybe 0 A.sum $ initM (0 ..: 10)
--   36
--   
--   &gt;&gt;&gt; maybe 0 A.sum $ initM (empty :: Array D Ix1 Int)
--   0
--   </pre>
initM :: forall r e m. (Source r e, MonadThrow m) => Vector r e -> m (Vector r e)

-- | <i>O(1)</i> - Get a vector without the first element. Never fails
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.tail (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; A.tail (empty :: Array D Ix1 Int)
--   Array D Seq (Sz1 0)
--     [  ]
--   </pre>
tail :: forall r e. Source r e => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get a vector without the first element. Throws an error
--   on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; tail' (0 ..: 10) Array D Seq (Sz1 9) [ 1, 2, 3, 4, 5, 6, 7, 8, 9
--   ] λ&gt; tail' (empty :: Array D Ix1 Int) Array D *** Exception:
--   SizeEmptyException: (Sz1 0) corresponds to an empty array
tail' :: forall r e. (HasCallStack, Source r e) => Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector without the first element. Throws an
--   error on empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; tailM (0 ..: 10)
--   Array D Seq (Sz1 9)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; maybe 0 A.sum $ tailM (0 ..: 10)
--   45
--   
--   &gt;&gt;&gt; maybe 0 A.sum $ tailM (empty :: Array D Ix1 Int)
--   0
--   </pre>
tailM :: forall r e m. (Source r e, MonadThrow m) => Vector r e -> m (Vector r e)

-- | <i>O(1)</i> - Take first <tt>n</tt> elements from a vector. This
--   function never fails and has similar semantics as the <a>take</a> for
--   lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.take 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; A.take 0 (0 ..: 10)
--   Array D Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; A.take 100 (0 ..: 10)
--   Array D Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   </pre>
take :: Source r e => Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector with the first <tt>n</tt> elements.
--   Throws an error size is less than <tt>n</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take' 0 (0 ..: 0)
--   Array D Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; take' 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   </pre>
take' :: forall r e. (HasCallStack, Source r e) => Sz1 -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Get the vector with the first <tt>n</tt> elements.
--   Throws an error size is less than <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; takeM 5 (0 ..: 10)
--   Array D Seq (Sz1 5)
--     [ 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; maybe 0 A.sum $ takeM 5 (0 ..: 10)
--   10
--   
--   &gt;&gt;&gt; maybe (-1) A.sum $ takeM 15 (0 ..: 10)
--   -1
--   
--   &gt;&gt;&gt; takeM 15 (0 ..: 10)
--   *** Exception: SizeSubregionException: (Sz1 10) is to small for 0 (Sz1 15)
--   </pre>
takeM :: forall r e m. (Source r e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e)

-- | Slice a manifest vector in such a way that it will contain all initial
--   elements that satisfy the supplied predicate.
takeWhile :: Manifest r e => (e -> Bool) -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Create a <a>Stream</a> vector with the first <tt>n</tt>
--   elements. Never fails
--   
--   <h4><b>Examples</b></h4>
stake :: forall r e. Stream r Ix1 e => Sz1 -> Vector r e -> Vector DS e

-- | <i>O(1)</i> - Drop <tt>n</tt> elements from a vector. This function
--   never fails and has similar semantics as the <a>drop</a> for lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; v = makeVectorR D Seq 10 id
--   
--   &gt;&gt;&gt; v
--   Array D Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; A.drop 5 v
--   Array D Seq (Sz1 5)
--     [ 5, 6, 7, 8, 9 ]
--   
--   &gt;&gt;&gt; A.drop 25 v
--   Array D Seq (Sz1 0)
--     [  ]
--   </pre>
drop :: forall r e. Source r e => Sz1 -> Vector r e -> Vector r e

-- | Slice a manifest vector in such a way that it will not contain all
--   initial elements that satisfy the supplied predicate.
dropWhile :: forall r e. Manifest r e => (e -> Bool) -> Vector r e -> Vector r e

-- | <i>O(1)</i> - Drop <tt>n</tt> elements from a vector. Unlike
--   <a>drop</a>, this function will produce an error when supplied number
--   of elements to drop is larger than size of the supplied vector
--   
--   <h4><b>Examples</b></h4>
drop' :: forall r e. (HasCallStack, Source r e) => Sz1 -> Vector r e -> Vector r e

-- | <h4><b>Examples</b></h4>
dropM :: forall r e m. (Source r e, MonadThrow m) => Sz1 -> Vector r e -> m (Vector r e)

-- | Keep all but the first <tt>n</tt> elements from the delayed stream
--   vector.
--   
--   <h4><b>Examples</b></h4>
sdrop :: forall r e. Stream r Ix1 e => Sz1 -> Vector r e -> Vector DS e

-- | Create an Array with no elements. By itself it is not particularly
--   useful, but it serves as a nice base for constructing larger arrays.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; xs = empty @DL @Ix1 @Double
--   
--   &gt;&gt;&gt; snoc (cons 4 (cons 5 xs)) 22
--   Array DL Seq (Sz1 3)
--     [ 4.0, 5.0, 22.0 ]
--   </pre>
empty :: forall r ix e. Load r ix e => Array r ix e

-- | Create an empty delayed stream vector
--   
--   <h4><b>Examples</b></h4>
sempty :: Vector DS e

-- | Create an Array with a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; singleton 7 :: Array D Ix4 Double
--   Array D Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
--   
--   Instead of specifying type signature we could use
--   <tt>TypeApplications</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; singleton @U @Ix4 @Double 7
--   Array U Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
singleton :: forall r ix e. Load r ix e => e -> Array r ix e

-- | Create a delayed stream vector with a single element
--   
--   <h4><b>Examples</b></h4>
ssingleton :: e -> Vector DS e

-- | <i>O(1)</i> - Add an element to the vector from the left side
cons :: forall r e. (Size r, Load r Ix1 e) => e -> Vector r e -> Vector DL e

-- | <i>O(1)</i> - Add an element to the vector from the right side
snoc :: forall r e. (Size r, Load r Ix1 e) => Vector r e -> e -> Vector DL e

-- | Construct an array of the specified size that contains the same
--   element in all of the cells.
replicate :: Load r ix e => Comp -> Sz ix -> e -> Array r ix e

-- | Replicate the same element <tt>n</tt> times
--   
--   <h4><b>Examples</b></h4>
sreplicate :: Sz1 -> e -> Vector DS e

-- | Create a delayed vector of length <tt>n</tt> with a function that maps
--   an index to an element. Same as <tt>makeLinearArray</tt>
--   
--   <h4><b>Examples</b></h4>
generate :: Comp -> Sz1 -> (Ix1 -> e) -> Vector D e

-- | Create a delayed stream vector of length <tt>n</tt> with a function
--   that maps an index to an element. Same as <tt>makeLinearArray</tt>
--   
--   <h4><b>Examples</b></h4>
sgenerate :: Sz1 -> (Ix1 -> e) -> Vector DS e

-- | Create a delayed stream vector of infinite length by repeatedly
--   applying a function to the initial value.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stake 10 $ siterate succ 'a'
--   Array DS Seq (Sz1 10)
--     [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]
--   </pre>
siterate :: (e -> e) -> e -> Vector DS e

-- | Create a delayed stream vector of length <tt>n</tt> by repeatedly
--   applying a function to the initial value.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; siterateN 10 succ 'a'
--   Array DS Seq (Sz1 10)
--     [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]
--   </pre>
siterateN :: Sz1 -> (e -> e) -> e -> Vector DS e

-- | Create a vector by using the same monadic action <tt>n</tt> times
--   
--   <h4><b>Examples</b></h4>
sreplicateM :: forall e m. Monad m => Sz1 -> m e -> m (Vector DS e)

-- | Create a delayed stream vector of length <tt>n</tt> with a monadic
--   action that from an index generates an element.
--   
--   <h4><b>Examples</b></h4>
sgenerateM :: forall e m. Monad m => Sz1 -> (Ix1 -> m e) -> m (Vector DS e)

-- | Create a delayed stream vector of length <tt>n</tt> by repeatedly
--   apply a monadic action to the initial value.
--   
--   <h4><b>Examples</b></h4>
siterateNM :: forall e m. Monad m => Sz1 -> (e -> m e) -> e -> m (Vector DS e)

-- | Right unfolding function. Useful when it is unknown ahead of time how
--   many elements a vector will have.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; sunfoldr (\i -&gt; if i &lt; 9 then Just (i * i, i + 1) else Nothing) (0 :: Int)
--   Array DS Seq (Sz1 9)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64 ]
--   </pre>
sunfoldr :: forall e s. (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>sunfoldr</a>, but with monadic generating
--   function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (when, guard)
--   
--   &gt;&gt;&gt; sunfoldrM (\i -&gt; when (i == 0) (Left "Zero denominator") &gt;&gt; Right (guard (i &lt; 5) &gt;&gt; Just (100 `div` i, i + 1))) (-10 :: Int)
--   Left "Zero denominator"
--   
--   &gt;&gt;&gt; sunfoldrM (\i -&gt; when (i == 0) (Left "Zero denominator") &gt;&gt; Right (guard (i &lt; -5) &gt;&gt; Just (100 `div` i, i + 1))) (-10 :: Int)
--   Right (Array DS Seq (Sz1 5)
--     [ -10, -12, -13, -15, -17 ]
--   )
--   </pre>
sunfoldrM :: forall e s m. Monad m => (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Right unfolding function with at most <tt>n</tt> number
--   of elements.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; sunfoldrN 9 (\i -&gt; Just (i*i, i + 1)) (0 :: Int)
--   Array DS Seq (Sz1 9)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64 ]
--   </pre>
sunfoldrN :: forall e s. Sz1 -> (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>sunfoldrN</a>, but with monadic generating
--   function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad (guard)
--   
--   &gt;&gt;&gt; sunfoldrNM 6 (\i -&gt; print i &gt;&gt; pure (guard (i &lt; 5) &gt;&gt; Just (i * i, i + 1))) (10 :: Int)
--   10
--   Array DS Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; sunfoldrNM 6 (\i -&gt; print i &gt;&gt; pure (guard (i &lt; 15) &gt;&gt; Just (i * i, i + 1))) (10 :: Int)
--   10
--   11
--   12
--   13
--   14
--   15
--   Array DS Seq (Sz1 5)
--     [ 100, 121, 144, 169, 196 ]
--   </pre>
sunfoldrNM :: forall e s m. Monad m => Sz1 -> (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Similar to <a>sunfoldrN</a>, except the length of the
--   resulting vector will be exactly <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sunfoldrExactN 10 (\i -&gt; (i * i, i + 1)) (10 :: Int)
--   Array DS Seq (Sz1 10)
--     [ 100, 121, 144, 169, 196, 225, 256, 289, 324, 361 ]
--   </pre>
sunfoldrExactN :: forall e s. Sz1 -> (s -> (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Similar to <a>sunfoldrNM</a>, except the length of the
--   resulting vector will be exactly <tt>n</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; sunfoldrExactNM 11 (i -&gt; pure (100 <a>div</a> i, i + 1)) (-10
--   :: Int) Array DS *** Exception: divide by zero λ&gt; sunfoldrExactNM
--   11 (i -&gt; guard (i /= 0) &gt;&gt; Just (100 <a>div</a> i, i + 1))
--   (-10 :: Int) Nothing λ&gt; sunfoldrExactNM 9 (i -&gt; guard (i /= 0)
--   &gt;&gt; Just (100 <a>div</a> i, i + 1)) (-10 :: Int) Just (Array DS
--   Seq (Sz1 9) [ -10, -12, -13, -15, -17, -20, -25, -34, -50 ] )
sunfoldrExactNM :: forall e s m. Monad m => Sz1 -> (s -> m (e, s)) -> s -> m (Vector DS e)

-- | Handy synonym for <tt><a>rangeInclusive</a> <a>Seq</a></tt>. Similar
--   to <tt>..</tt> for list.
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ... 10
--   Array D Seq (Sz1 7)
--     [ 4, 5, 6, 7, 8, 9, 10 ]
--   </pre>
(...) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ...

-- | Handy synonym for <tt><a>range</a> <a>Seq</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ..: 10
--   Array D Seq (Sz1 6)
--     [ 4, 5, 6, 7, 8, 9 ]
--   </pre>
(..:) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ..:

-- | Same as <a>enumFromStepN</a> with step <tt>dx = 1</tt>.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromN Seq (5 :: Double) 3
--   Array D Seq (Sz1 3)
--     [ 5.0, 6.0, 7.0 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[i
--   .. i + n - 1]</tt>, except that <a>enumFromN</a> is faster, but it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i></li>
--   </ul>
enumFromN :: Num e => Comp -> e -> Sz1 -> Vector D e

-- | <i>O(n)</i> - Enumerate from a starting number <tt>x</tt> exactly
--   <tt>n</tt> times with a step <tt>1</tt>.
--   
--   <i>Related</i>: <a>senumFromStepN</a>, <a>enumFromN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <a>rangeStep'</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; senumFromN (10 :: Int) 9
--   Array DS Seq (Sz1 9)
--     [ 10, 11, 12, 13, 14, 15, 16, 17, 18 ]
--   </pre>
--   
--   <i><b>Similar</b></i>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[x
--   .. x + n - 1]</tt>, except that <a>senumFromN</a> is faster and it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i> Uses exactly
--   the same implementation underneath.</li>
--   </ul>
senumFromN :: Num e => e -> Sz1 -> Vector DS e

-- | Enumerate from a starting number <tt>x</tt> exactly <tt>n</tt> times
--   with a custom step value <tt>dx</tt>. Unlike <a>senumFromStepN</a>,
--   there is no dependency on neigboring elements therefore
--   <a>enumFromStepN</a> is parallelizable.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <a>rangeStepM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromStepN Seq 1 (0.1 :: Double) 5
--   Array D Seq (Sz1 5)
--     [ 1.0, 1.1, 1.2, 1.3, 1.4 ]
--   
--   &gt;&gt;&gt; enumFromStepN Seq (-pi :: Float) (pi/4) 9
--   Array D Seq (Sz1 9)
--     [ -3.1415927, -2.3561945, -1.5707964, -0.78539824, 0.0, 0.78539824, 1.5707963, 2.3561947, 3.1415927 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Similar to <tt>take n [x,
--   x + dx ..]</tt>, except that <a>enumFromStepN</a> is parallelizable
--   and it only works for <a>Num</a> and not for <a>Enum</a> elements.
--   Floating point value will be slightly different as well.</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Similar
--   in the outcome, but very different in the way it works.</li>
--   </ul>
enumFromStepN :: Num e => Comp -> e -> e -> Sz1 -> Vector D e

-- | <i>O(n)</i> - Enumerate from a starting number <tt>x</tt> exactly
--   <tt>n</tt> times with a custom step value <tt>dx</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; senumFromStepN (5 :: Int) 2 10
--   Array DS Seq (Sz1 10)
--     [ 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Just like <tt>take n [x, x
--   + dx ..]</tt>, except that <a>senumFromN</a> is faster and it only
--   works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Uses
--   exactly the same implementation underneath.</li>
--   </ul>
senumFromStepN :: Num e => e -> e -> Sz1 -> Vector DS e

-- | Append two vectors together
--   
--   <i>Related</i>: <tt>appendM</tt>, <a>appendOuterM</a>,
--   
--   <h4><b>Examples</b></h4>
--   
--   λ&gt; sappend (1 ..: 6) (senumFromStepN 6 (-1) 6) Array DS Seq (Sz1
--   11) [ 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1 ]
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Data.Semigroup.<a>&lt;&gt;</a></tt></i> <a>DS</a> and
--   <a>DL</a> arrays have instances for <a>Semigroup</a>, so they will
--   work in a similar fashion. <a>sappend</a> differs in that it accepts
--   <a>Stream</a> arrays with possibly different representations.</li>
--   <li><i><tt>Data.List.<a>++</a></tt></i> Same operation, but for
--   lists.</li>
--   <li><i><tt>Data.Vector.Generic.<a>++</a></tt></i> Uses exactly the
--   same implementation underneath as <a>sappend</a>, except that it
--   cannot append two vectors with different memory representations.</li>
--   </ul>
sappend :: forall r1 r2 e. (Stream r1 Ix1 e, Stream r2 Ix1 e) => Vector r1 e -> Vector r2 e -> Vector DS e

-- | Concat vectors together
--   
--   <i>Related</i>: <tt>concatM</tt>, <a>concatOuterM</a>,
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat [2 ... 6, empty, singleton 1, generate Seq 5 id]
--   Array DS Seq (Sz1 11)
--     [ 2, 3, 4, 5, 6, 1, 0, 1, 2, 3, 4 ]
--   
--   &gt;&gt;&gt; sconcat [senumFromN 2 5, sempty, ssingleton 1, sgenerate 5 id]
--   Array DS Seq (Sz1 11)
--     [ 2, 3, 4, 5, 6, 1, 0, 1, 2, 3, 4 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Data.Monoid.<a>mconcat</a></tt></i> <a>DS</a> and <a>DL</a>
--   arrays have instances for <a>Monoid</a>, so they will work in a
--   similar fashion. <a>sconcat</a> differs in that it accepts
--   <a>Stream</a> arrays of other representations.</li>
--   <li><i><tt>Data.List.<a>concat</a></tt></i> Same operation, but for
--   lists.</li>
--   <li><i><tt>Data.Vector.Generic.<a>concat</a></tt></i> Uses exactly the
--   same implementation underneath as <a>sconcat</a>.</li>
--   </ul>
sconcat :: forall r e. Stream r Ix1 e => [Vector r e] -> Vector DS e

-- | Map a function over a stream vector
--   
--   <h4><b>Examples</b></h4>
smap :: forall r ix a b. Stream r ix a => (a -> b) -> Array r ix a -> Vector DS b

-- | Map an index aware function over a stream vector
--   
--   <h4><b>Examples</b></h4>
simap :: forall r ix a b. Stream r ix a => (ix -> a -> b) -> Array r ix a -> Vector DS b

-- | Traverse a stream vector with an applicative function.
--   
--   <h4><b>Examples</b></h4>
straverse :: forall r ix a b f. (Stream r ix a, Applicative f) => (a -> f b) -> Array r ix a -> f (Vector DS b)

-- | Traverse a stream vector with an index aware applicative function.
--   
--   <h4><b>Examples</b></h4>
sitraverse :: forall r ix a b f. (Stream r ix a, Applicative f) => (ix -> a -> f b) -> Array r ix a -> f (Vector DS b)

-- | Traverse a stream vector with a monadic function.
--   
--   <h4><b>Examples</b></h4>
smapM :: forall r ix a b m. (Stream r ix a, Monad m) => (a -> m b) -> Array r ix a -> m (Vector DS b)

-- | Traverse a stream vector with a monadic function, while discarding the
--   result
--   
--   <h4><b>Examples</b></h4>
smapM_ :: forall r ix a b m. (Stream r ix a, Monad m) => (a -> m b) -> Array r ix a -> m ()

-- | Traverse a stream vector with a monadic index aware function.
--   
--   Corresponds to: <tt>mapM (uncurry f) . imap (,) v</tt>
--   
--   <h4><b>Examples</b></h4>
simapM :: forall r ix a b m. (Stream r ix a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m (Vector DS b)

-- | Traverse a stream vector with a monadic index aware function, while
--   discarding the result
--   
--   <h4><b>Examples</b></h4>
simapM_ :: forall r ix a b m. (Stream r ix a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m ()

-- | Same as <a>smapM</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
sforM :: forall r ix a b m. (Stream r ix a, Monad m) => Array r ix a -> (a -> m b) -> m (Vector DS b)

-- | Same as <a>smapM_</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
sforM_ :: (Stream r ix a, Monad m) => Array r ix a -> (a -> m b) -> m ()

-- | Same as <a>simapM</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
siforM :: forall r ix a b m. (Stream r ix a, Monad m) => Array r ix a -> (ix -> a -> m b) -> m (Vector DS b)

-- | Same as <a>simapM_</a>, but with arguments flipped.
--   
--   <h4><b>Examples</b></h4>
siforM_ :: forall r ix a b m. (Stream r ix a, Monad m) => Array r ix a -> (ix -> a -> m b) -> m ()

-- | Zip two vectors together into a vector. The length of a resulting
--   vector will be the smallest length of the supplied vectors.
--   
--   <h4><b>Examples</b></h4>
szip :: forall ra rb a b. (Stream ra Ix1 a, Stream rb Ix1 b) => Vector ra a -> Vector rb b -> Vector DS (a, b)

-- | Zip three vectors together into a vector. The length of a resulting
--   vector will be the smallest length of the supplied vectors.
szip3 :: forall ra rb rc a b c. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => Vector ra a -> Vector rb b -> Vector rc c -> Vector DS (a, b, c)

-- | Zip four vectors together into a vector. The length of a resulting
--   vector will be the smallest length of the supplied vectors.
szip4 :: forall ra rb rc rd a b c d. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS (a, b, c, d)

-- | Zip five vectors together into a vector. The length of a resulting
--   vector will be the smallest length of the supplied vectors.
szip5 :: forall ra rb rc rd re a b c d e. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS (a, b, c, d, e)

-- | Zip six vectors together into a vector. The length of a resulting
--   vector will be the smallest length of the supplied vectors.
szip6 :: forall ra rb rc rd re rf a b c d e f. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS (a, b, c, d, e, f)

-- | Zip two vectors together with a binary function into a vector. The
--   length of a resulting vector will be the smallest length of the
--   supplied vectors.
--   
--   <h4><b>Examples</b></h4>
szipWith :: forall ra rb a b c. (Stream ra Ix1 a, Stream rb Ix1 b) => (a -> b -> c) -> Vector ra a -> Vector rb b -> Vector DS c

-- | Zip three vectors together with a ternary function into a vector. The
--   length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith3 :: forall ra rb rc a b c d. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => (a -> b -> c -> d) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector DS d

-- | Zip four vectors together with a quaternary function into a vector.
--   The length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith4 :: forall ra rb rc rd a b c d e. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => (a -> b -> c -> d -> e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS e

-- | Zip five vectors together with a quinary function into a vector. The
--   length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith5 :: forall ra rb rc rd re a b c d e f. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => (a -> b -> c -> d -> e -> f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS f

-- | Zip six vectors together with a senary function into a vector. The
--   length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith6 :: forall ra rb rc rd re rf a b c d e f g. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => (a -> b -> c -> d -> e -> f -> g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS g

-- | Just like <a>szipWith</a>, zip two vectors together, but with an index
--   aware function. The length of a resulting vector will be the smallest
--   length of the supplied vectors.
--   
--   <h4><b>Examples</b></h4>
sizipWith :: forall ra rb a b c. (Stream ra Ix1 a, Stream rb Ix1 b) => (Ix1 -> a -> b -> c) -> Vector ra a -> Vector rb b -> Vector DS c

-- | Just like <a>szipWith3</a>, zip three vectors together, but with an
--   index aware function. The length of a resulting vector will be the
--   smallest length of the supplied vectors.
sizipWith3 :: forall ra rb rc a b c d. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c) => (Ix1 -> a -> b -> c -> d) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector DS d

-- | Just like <a>szipWith4</a>, zip four vectors together, but with an
--   index aware function. The length of a resulting vector will be the
--   smallest length of the supplied vectors.
sizipWith4 :: forall ra rb rc rd a b c d e. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d) => (Ix1 -> a -> b -> c -> d -> e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector DS e

-- | Just like <a>szipWith5</a>, zip five vectors together, but with an
--   index aware function. The length of a resulting vector will be the
--   smallest length of the supplied vectors.
sizipWith5 :: forall ra rb rc rd re a b c d e f. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e) => (Ix1 -> a -> b -> c -> d -> e -> f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector DS f

-- | Just like <a>szipWith6</a>, zip six vectors together, but with an
--   index aware function. The length of a resulting vector will be the
--   smallest length of the supplied vectors.
sizipWith6 :: forall ra rb rc rd re rf a b c d e f g. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f) => (Ix1 -> a -> b -> c -> d -> e -> f -> g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> Vector DS g

-- | Zip two vectors together with a binary monadic action into a vector.
--   The length of a resulting vector will be the smallest length of the
--   supplied vectors.
--   
--   <h4><b>Examples</b></h4>
szipWithM :: forall ra rb a b c m. (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (a -> b -> m c) -> Vector ra a -> Vector rb b -> m (Vector DS c)

-- | Zip three vectors together with a ternary monadic action into a
--   vector. The length of a resulting vector will be the smallest length
--   of the supplied vectors.
szipWith3M :: forall ra rb rc a b c d m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m (Vector DS d)

-- | Zip four vectors together with a quaternary monadic action into a
--   vector. The length of a resulting vector will be the smallest length
--   of the supplied vectors.
szipWith4M :: forall ra rb rc rd a b c d e m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m (Vector DS e)

-- | Zip five vectors together with a quinary monadic action into a vector.
--   The length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith5M :: forall ra rb rc rd re a b c d e f m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m (Vector DS f)

-- | Zip six vectors together with a senary monadic action into a vector.
--   The length of a resulting vector will be the smallest length of the
--   supplied vectors.
szipWith6M :: forall ra rb rc rd re rf a b c d e f g m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m (Vector DS g)

-- | Just like <a>szipWithM</a>, zip two vectors together, but with an
--   index aware monadic action. The length of a resulting vector will be
--   the smallest length of the supplied vectors.
--   
--   <h4><b>Examples</b></h4>
sizipWithM :: forall ra rb a b c m. (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (Ix1 -> a -> b -> m c) -> Vector ra a -> Vector rb b -> m (Vector DS c)

-- | Just like <a>szipWith3M</a>, zip three vectors together, but with an
--   index aware monadic action. The length of a resulting vector will be
--   the smallest length of the supplied vectors.
sizipWith3M :: forall ra rb rc a b c d m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (Ix1 -> a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m (Vector DS d)

-- | Just like <a>szipWith4M</a>, zip four vectors together, but with an
--   index aware monadic action. The length of a resulting vector will be
--   the smallest length of the supplied vectors.
sizipWith4M :: forall ra rb rc rd a b c d e m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (Ix1 -> a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m (Vector DS e)

-- | Just like <a>szipWith6M</a>, zip five vectors together, but with an
--   index aware monadic action. The length of a resulting vector will be
--   the smallest length of the supplied vectors.
sizipWith5M :: forall ra rb rc rd re a b c d e f m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m (Vector DS f)

-- | Just like <a>szipWith6M</a>, zip six vectors together, but with an
--   index aware monadic action. The length of a resulting vector will be
--   the smallest length of the supplied vectors.
--   
--   <h4><b>Examples</b></h4>
sizipWith6M :: forall ra rb rc rd re rf a b c d e f g m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m (Vector DS g)

-- | Similar to <a>szipWithM</a>, zip two vectors together with a binary
--   monadic action, while discarding its result. The action will be
--   invoked as many times as the length of the smallest vector.
--   
--   <h4><b>Examples</b></h4>
szipWithM_ :: forall ra rb a b c m. (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (a -> b -> m c) -> Vector ra a -> Vector rb b -> m ()

-- | Similar to <a>szipWith3M</a>, zip three vectors together with a
--   ternary monadic action, while discarding its result. The action will
--   be invoked as many times as the length of the smallest vector.
szipWith3M_ :: forall ra rb rc a b c d m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m ()

-- | Similar to <a>szipWith4M</a>, zip four vectors together with a
--   quaternary monadic action, while discarding its result. The action
--   will be invoked as many times as the length of the smallest vector.
szipWith4M_ :: forall ra rb rc rd a b c d e m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m ()

-- | Similar to <a>szipWith5M</a>, zip five vectors together with a quinary
--   monadic action, while discarding its result. The action will be
--   invoked as many times as the length of the smallest vector.
szipWith5M_ :: forall ra rb rc rd re a b c d e f m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m ()

-- | Similar to <a>szipWith6M</a>, zip six vectors together with a senary
--   monadic action, while discarding its result. The action will be
--   invoked as many times as the length of the smallest vector.
szipWith6M_ :: forall ra rb rc rd re rf a b c d e f g m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m ()

-- | Same as <a>szipWithM_</a>, zip two vectors together, but with an index
--   aware monadic action. The action will be invoked as many times as the
--   length of the smallest vector.
--   
--   <h4><b>Examples</b></h4>
sizipWithM_ :: forall ra rb a b c m. (Stream ra Ix1 a, Stream rb Ix1 b, Monad m) => (Ix1 -> a -> b -> m c) -> Vector ra a -> Vector rb b -> m ()

-- | Same as <a>szipWith3M_</a>, zip three vectors together, but with an
--   index aware monadic action. The action will be invoked as many times
--   as the length of the smallest vector.
sizipWith3M_ :: forall ra rb rc a b c d m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Monad m) => (Ix1 -> a -> b -> c -> m d) -> Vector ra a -> Vector rb b -> Vector rc c -> m ()

-- | Same as <a>szipWith4M_</a>, zip four vectors together, but with an
--   index aware monadic action. The action will be invoked as many times
--   as the length of the smallest vector.
sizipWith4M_ :: forall ra rb rc rd a b c d e m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Monad m) => (Ix1 -> a -> b -> c -> d -> m e) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> m ()

-- | Same as <a>szipWith5M_</a>, zip five vectors together, but with an
--   index aware monadic action. The action will be invoked as many times
--   as the length of the smallest vector.
sizipWith5M_ :: forall ra rb rc rd re a b c d e f m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> m f) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> m ()

-- | Same as <a>szipWith6M_</a>, zip six vectors together, but with an
--   index aware monadic action. The action will be invoked as many times
--   as the length of the smallest vector.
sizipWith6M_ :: forall ra rb rc rd re rf a b c d e f g m. (Stream ra Ix1 a, Stream rb Ix1 b, Stream rc Ix1 c, Stream rd Ix1 d, Stream re Ix1 e, Stream rf Ix1 f, Monad m) => (Ix1 -> a -> b -> c -> d -> e -> f -> m g) -> Vector ra a -> Vector rb b -> Vector rc c -> Vector rd d -> Vector re e -> Vector rf f -> m ()

-- | Sequentially filter out elements from the array according to the
--   supplied predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayR D Seq (Sz2 3 4) fromIx2
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 4))
--     [ [ (0,0), (0,1), (0,2), (0,3) ]
--     , [ (1,0), (1,1), (1,2), (1,3) ]
--     , [ (2,0), (2,1), (2,2), (2,3) ]
--     ]
--   
--   &gt;&gt;&gt; sfilter (even . fst) arr
--   Array DS Seq (Sz1 8)
--     [ (0,0), (0,1), (0,2), (0,3), (2,0), (2,1), (2,2), (2,3) ]
--   </pre>
sfilter :: forall r ix e. Stream r ix e => (e -> Bool) -> Array r ix e -> Vector DS e

-- | Similar to <a>sfilter</a>, but filter with an index aware function.
--   
--   <h4><b>Examples</b></h4>
sifilter :: forall r ix e. Stream r ix e => (ix -> e -> Bool) -> Array r ix e -> Vector DS e

-- | Sequentially filter out elements from the array according to the
--   supplied applicative predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayR D Seq (Sz2 3 4) fromIx2
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 4))
--     [ [ (0,0), (0,1), (0,2), (0,3) ]
--     , [ (1,0), (1,1), (1,2), (1,3) ]
--     , [ (2,0), (2,1), (2,2), (2,3) ]
--     ]
--   
--   &gt;&gt;&gt; sfilterM (Just . odd . fst) arr
--   Just (Array DS Seq (Sz1 4)
--     [ (1,0), (1,1), (1,2), (1,3) ]
--   )
--   
--   &gt;&gt;&gt; sfilterM (\ix@(_, j) -&gt; print ix &gt;&gt; return (even j)) arr
--   (0,0)
--   (0,1)
--   (0,2)
--   (0,3)
--   (1,0)
--   (1,1)
--   (1,2)
--   (1,3)
--   (2,0)
--   (2,1)
--   (2,2)
--   (2,3)
--   Array DS Seq (Sz1 6)
--     [ (0,0), (0,2), (1,0), (1,2), (2,0), (2,2) ]
--   </pre>
sfilterM :: forall r ix e f. (Stream r ix e, Applicative f) => (e -> f Bool) -> Array r ix e -> f (Vector DS e)

-- | Similar to <tt>filterM</tt>, but filter with an index aware function.
--   
--   Corresponds to: <tt><tt>filterM</tt> (uncurry f) . <a>simap</a>
--   (,)</tt>
sifilterM :: forall r ix e f. (Stream r ix e, Applicative f) => (ix -> e -> f Bool) -> Array r ix e -> f (Vector DS e)

-- | Apply a function to each element of the array, while discarding
--   <a>Nothing</a> and keeping the <a>Maybe</a> result.
--   
--   <h4><b>Examples</b></h4>
smapMaybe :: forall r ix a b. Stream r ix a => (a -> Maybe b) -> Array r ix a -> Vector DS b

-- | Similar to <a>smapMaybe</a>, but with the <a>Applicative</a> function.
--   
--   Similar to <tt>mapMaybe id <a>$</a> mapM f arr</tt>
--   
--   <h4><b>Examples</b></h4>
smapMaybeM :: forall r ix a b f. (Stream r ix a, Applicative f) => (a -> f (Maybe b)) -> Array r ix a -> f (Vector DS b)

-- | Keep all <a>Maybe</a>s and discard the <a>Nothing</a>s.
--   
--   <h4><b>Examples</b></h4>
scatMaybes :: forall r ix a. Stream r ix (Maybe a) => Array r ix (Maybe a) -> Vector DS a

-- | Similar to <a>smapMaybe</a>, but map with an index aware function.
--   
--   <h4><b>Examples</b></h4>
simapMaybe :: forall r ix a b. Stream r ix a => (ix -> a -> Maybe b) -> Array r ix a -> Vector DS b

-- | Similar to <a>smapMaybeM</a>, but map with an index aware function.
--   
--   <h4><b>Examples</b></h4>
simapMaybeM :: forall r ix a b f. (Stream r ix a, Applicative f) => (ix -> a -> f (Maybe b)) -> Array r ix a -> f (Vector DS b)

-- | <i>O(n)</i> - Perform a row-major search starting at <tt>0</tt> for an
--   element. Returns the index of the first occurance of an element or
--   <a>Nothing</a> if a predicate could not be satisifed after it was
--   applyied to all elements of the array.
findIndex :: (Index ix, Manifest r e) => (e -> Bool) -> Array r ix e -> Maybe ix

-- | Streaming fold over an array in a row-major fashion with a left biased
--   function and a strict accumulator.
--   
--   <h4><b>Examples</b></h4>
sfoldl :: forall r ix e a. Stream r ix e => (a -> e -> a) -> a -> Array r ix e -> a

-- | <h4><b>Examples</b></h4>
sfoldlM :: forall r ix e a m. (Stream r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m a

-- | <h4><b>Examples</b></h4>
sfoldlM_ :: forall r ix e a m. (Stream r ix e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sifoldl :: forall r ix e a. Stream r ix e => (a -> ix -> e -> a) -> a -> Array r ix e -> a

-- | <h4><b>Examples</b></h4>
sifoldlM :: forall r ix e a m. (Stream r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m a

-- | <h4><b>Examples</b></h4>
sifoldlM_ :: forall r ix e a m. (Stream r ix e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sfoldl1' :: forall r ix e. (HasCallStack, Stream r ix e) => (e -> e -> e) -> Array r ix e -> e

-- | <h4><b>Examples</b></h4>
sfoldl1M :: forall r ix e m. (Stream r ix e, MonadThrow m) => (e -> e -> m e) -> Array r ix e -> m e

-- | <h4><b>Examples</b></h4>
sfoldl1M_ :: forall r ix e m. (Stream r ix e, MonadThrow m) => (e -> e -> m e) -> Array r ix e -> m ()

-- | <h4><b>Examples</b></h4>
sor :: forall r ix. Stream r ix Bool => Array r ix Bool -> Bool

-- | <h4><b>Examples</b></h4>
sand :: forall r ix. Stream r ix Bool => Array r ix Bool -> Bool

-- | <h4><b>Examples</b></h4>
sall :: forall r ix e. Stream r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | <h4><b>Examples</b></h4>
sany :: forall r ix e. Stream r ix e => (e -> Bool) -> Array r ix e -> Bool

-- | Add all elements of the array together
--   
--   <i>Related</i>: <a>sum</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.ssum $ V.sfromList [10, 3, 70, 5 :: Int]
--   88
--   </pre>
ssum :: forall r ix e. (Num e, Stream r ix e) => Array r ix e -> e

-- | Multiply all elements of the array together
--   
--   <i>Related</i>: <a>product</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sproduct $ V.sfromList [10, 3, 70, 5 :: Int]
--   10500
--   </pre>
sproduct :: forall r ix e. (Num e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the largest value in the array. Throws an error on
--   empty.
--   
--   <i>Related</i>: <a>smaximumM</a>, <a>maximum</a>, <tt>maximumM</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.smaximum' $ V.sfromList [10, 3, 70, 5 :: Int]
--   70
--   </pre>
smaximum' :: forall r ix e. (HasCallStack, Ord e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the largest value in the array.
--   
--   <i>Related</i>: <tt>smaximum</tt>, <a>maximum</a>, <tt>maximumM</tt>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.smaximumM $ V.sfromList [10, 3, 70, 5 :: Int]
--   70
--   
--   &gt;&gt;&gt; V.smaximumM (V.empty :: Vector D Int) :: Maybe Int
--   Nothing
--   </pre>
smaximumM :: forall r ix e m. (Ord e, Stream r ix e, MonadThrow m) => Array r ix e -> m e

-- | <i>O(n)</i> - Find the smallest value in the array. Throws an error on
--   empty.
--   
--   <i>Related</i>: <a>sminimumM</a>, <a>minimum</a>, <tt>minimumM</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sminimum' $ V.sfromList [10, 3, 70, 5 :: Int]
--   3
--   </pre>
sminimum' :: forall r ix e. (HasCallStack, Ord e, Stream r ix e) => Array r ix e -> e

-- | <i>O(n)</i> - Find the smallest value in the array.
--   
--   <i>Related</i>: <a>sminimum'</a>, <a>minimum</a>, <tt>minimumM</tt>.
--   
--   <i><b>Throws Exceptions</b></i>: <a>SizeEmptyException</a> when array
--   is empty
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector as V
--   
--   &gt;&gt;&gt; V.sminimumM $ V.sfromList [10, 3, 70, 5 :: Int]
--   3
--   
--   &gt;&gt;&gt; V.sminimumM (V.empty :: Array D Ix2 Int) :: Maybe Int
--   Nothing
--   </pre>
sminimumM :: forall r ix e m. (Ord e, Stream r ix e, MonadThrow m) => Array r ix e -> m e

-- | <i>O(n)</i> - left scan with strict accumulator. First element is the
--   value of the accumulator. Last element is not included.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector
--   
--   &gt;&gt;&gt; sprescanl min 6 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 6, 6, 5, 5 ]
--   
--   &gt;&gt;&gt; sprescanl (+) 0 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 0, 10, 15, 85 ]
--   </pre>
sprescanl :: Stream r ix e => (a -> e -> a) -> a -> Array r ix e -> Vector DS a

-- | <i>O(n)</i> - left scan with strict accumulator. First element is the
--   result of applying the supplied function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector
--   
--   &gt;&gt;&gt; spostscanl min 6 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 6, 5, 5, 3 ]
--   
--   &gt;&gt;&gt; spostscanl (+) 0 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 10, 15, 85, 88 ]
--   </pre>
spostscanl :: Stream r ix e => (a -> e -> a) -> a -> Array r ix e -> Vector DS a

-- | <i>O(n)</i> - Just like <a>spostscanl</a> except it is possible to
--   produce a vector with an element type that differes from accumulator
--   type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector
--   
--   &gt;&gt;&gt; spostscanlAcc (\x y -&gt; if x &lt; y then (True, x) else (False, y)) 6 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ True, False, True, False ]
--   </pre>
spostscanlAcc :: Stream r ix e => (c -> e -> (a, c)) -> c -> Array r ix e -> Vector DS a

-- | <i>O(n)</i> - left scan with strict accumulator. First element is the
--   value of the accumulator.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector
--   
--   &gt;&gt;&gt; sscanl min 6 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 5)
--     [ 6, 6, 5, 5, 3 ]
--   
--   &gt;&gt;&gt; sscanl (+) 0 $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 5)
--     [ 0, 10, 15, 85, 88 ]
--   </pre>
sscanl :: Stream r ix e => (a -> e -> a) -> a -> Array r ix e -> Vector DS a

-- | <i>O(n)</i> - left scan with strict accumulator and no initial value
--   for the accumulator.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Vector
--   
--   &gt;&gt;&gt; sscanl1 min $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 10, 5, 5, 3 ]
--   
--   &gt;&gt;&gt; sscanl1 (+) $ sfromList [10, 5, 70, 3 :: Int]
--   Array DS Seq (Sz1 4)
--     [ 10, 15, 85, 88 ]
--   
--   &gt;&gt;&gt; sscanl1 (+) $ sfromList ([] :: [Int])
--   Array DS Seq (Sz1 0)
--     [  ]
--   </pre>
sscanl1 :: Stream r ix e => (e -> e -> e) -> Array r ix e -> Vector DS e

-- | Convert an array to a list by the means of a delayed stream vector.
--   
--   <i>Related</i>: <tt>toList</tt>
--   
--   <h4><b>Examples</b></h4>
stoList :: forall r ix e. Stream r ix e => Array r ix e -> [e]

-- | Convert a flat list into a vector
fromList :: forall r e. Manifest r e => Comp -> [e] -> Vector r e

-- | Convert a list to a delayed stream vector
--   
--   <i>Related</i>: <a>fromList</a>, <tt>fromListN</tt>, <a>sfromListN</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sfromList ([] :: [Int])
--   Array DS Seq (Sz1 0)
--     [  ]
--   
--   &gt;&gt;&gt; sfromList ([1,2,3] :: [Int])
--   Array DS Seq (Sz1 3)
--     [ 1, 2, 3 ]
--   </pre>
sfromList :: [e] -> Vector DS e

-- | Convert a list to a delayed stream vector. Length of the resulting
--   vector will be at most <tt>n</tt>. This version isn't really more
--   efficient then <a>sfromList</a>, but there is <a>unsafeFromListN</a>
--   
--   <i>Related</i>: <a>fromList</a>, <tt>fromListN</tt>, <a>sfromList</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; sfromListN 10 [1 :: Int ..]
--   Array DS Seq (Sz1 10)
--     [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
--   
--   &gt;&gt;&gt; sfromListN 10 [1 :: Int .. 5]
--   Array DS Seq (Sz1 5)
--     [ 1, 2, 3, 4, 5 ]
--   </pre>
sfromListN :: Sz1 -> [e] -> Vector DS e

-- | Ensure that Array is computed, i.e. represented with concrete elements
--   in memory, hence is the <a>Mutable</a> type class restriction. Use
--   <a>setComp</a> if you'd like to change computation strategy before
--   calling <tt>compute</tt>
compute :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array sequentially disregarding predefined computation
--   strategy. Very much the same as <a>computePrimM</a>, but executed in
--   <a>ST</a>, thus pure.
computeS :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Very similar to <a>compute</a>, but computes an array inside the
--   <a>IO</a> monad. Despite being deterministic and referentially
--   transparent, because this is an <a>IO</a> action it can be very useful
--   for enforcing the order of evaluation. Should be a prefered way of
--   computing an array during benchmarking.
computeIO :: forall r ix e r' m. (Manifest r e, Load r' ix e, MonadIO m) => Array r' ix e -> m (Array r ix e)

-- | Compute an array in <a>PrimMonad</a> sequentially disregarding
--   predefined computation strategy.
computePrimM :: forall r ix e r' m. (Manifest r e, Load r' ix e, PrimMonad m) => Array r' ix e -> m (Array r ix e)

-- | Just as <a>compute</a>, but let's you supply resulting representation
--   type as an argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeAs P $ range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   </pre>
computeAs :: (Manifest r e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>compute</a> and <a>computeAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   Useful only really for cases when representation constructor or
--   <tt>TypeApplications</tt> extension aren't desireable for some reason:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeProxy (Proxy :: Proxy P) $ (^ (2 :: Int)) &lt;$&gt; range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]
--   </pre>
computeProxy :: (Manifest r e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | This is just like <a>convert</a>, but restricted to <a>Source</a>
--   arrays. Will be a noop if resulting type is the same as the input.
computeSource :: forall r ix e r'. (Manifest r e, Source r' e, Index ix) => Array r' ix e -> Array r ix e

-- | Same as <a>compute</a>, but with <a>Stride</a>.
--   
--   <i>O(n div k)</i> - Where <tt>n</tt> is number of elements in the
--   source array and <tt>k</tt> is number of elements in the stride.
computeWithStride :: forall r ix e r'. (Manifest r e, StrideLoad r' ix e) => Stride ix -> Array r' ix e -> Array r ix e

-- | Same as <a>computeWithStride</a>, but with ability to specify
--   resulting array representation.
computeWithStrideAs :: (Manifest r e, StrideLoad r' ix e) => r -> Stride ix -> Array r' ix e -> Array r ix e

-- | <i>O(n)</i> - Make an exact immutable copy of an Array.
clone :: (Manifest r e, Index ix) => Array r ix e -> Array r ix e

-- | <i>O(n)</i> - conversion between array types. A full copy will occur,
--   unless when the source and result arrays are of the same
--   representation, in which case it is an <i>O(1)</i> operation.
convert :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>convert</a>, but let's you supply resulting representation
--   type as an argument.
convertAs :: (Manifest r e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>convert</a> and <a>convertAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
convertProxy :: (Manifest r e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e


module Data.Massiv.Array.Mutable.Algorithms

-- | Manifest version of <a>quicksort</a>
quicksortM_ :: (Ord e, Manifest r e, MonadPrimBase s m) => Scheduler s () -> MVector s r e -> m ()

-- | Same as <a>quicksortM_</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortByM_ :: (Manifest r e, MonadPrimBase s m) => (e -> e -> m Ordering) -> Scheduler s () -> MVector s r e -> m ()

-- | Partition elements of the supplied mutable vector according to the
--   predicate.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Massiv.Array.Mutable.Algorithms
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; m &lt;- thaw ([2,1,50,10,20,8] :: Array P Ix1 Int)
--   
--   &gt;&gt;&gt; unstablePartitionM m (pure . (&lt;= 10))
--   4
--   
--   &gt;&gt;&gt; freeze Seq m
--   Array P Seq (Sz1 6)
--     [ 2, 1, 8, 10, 20, 50 ]
--   </pre>
unstablePartitionM :: forall r e m. (Manifest r e, PrimMonad m) => MVector (PrimState m) r e -> (e -> m Bool) -> m Ix1

-- | Monadic version of <a>iterateUntil</a> where at each iteration mutable
--   version of an array is available. However it is less efficient then
--   the pure alternative, because an intermediate array must be copied at
--   each iteration.
iterateUntilM :: (Load r' ix e, Manifest r e, MonadIO m) => (Int -> Array r ix e -> MArray RealWorld r ix e -> m Bool) -> (Int -> Array r ix e -> m (Array r' ix e)) -> Array r ix e -> m (Array r ix e)


-- | Massiv is a library, that allows creation and manipulation of arrays
--   in parallel and sequentially. Depending on the representation
--   (<tt><b>r</b></tt>), an <tt><b><a>Array</a> r ix e</b></tt> will have
--   certain properties that are unique to that particular representation,
--   but all of them will share the same trait, that an array is simply a
--   mapping from an index (<tt><b>ix</b></tt>) of an arbitrary dimension
--   to an element (<tt><b>e</b></tt>) of some value. Which means that some
--   representations describe classic arrays and are backed by a contiguous
--   chunk of memory reserved for the elements (or pointers to elements),
--   namely arrays with <a>Manifest</a> representations:
--   
--   <ul>
--   <li><a>B</a> - The most basic type of array that can hold any type of
--   element in a boxed form, i.e. each element is a pointer to the actual
--   value, therefore it is also the slowest representation. Elements are
--   kept in a Weak Head Normal Form (WHNF).</li>
--   <li><a>BN</a> - Similar to <a>B</a>, it is also a boxed type, except
--   its elements are always kept in a Normal Form (NF). This property is
--   very useful for parallel processing, i.e. when calling <a>compute</a>
--   you do want all of your elements to be fully evaluated.</li>
--   <li><a>BL</a> - Similar to <a>B</a>, it is also a boxed type, but
--   lazy. Its elements are not evaluated when array is computed.</li>
--   <li><a>S</a> - Is a type of array that is backed by pinned memory,
--   therefore pointers to those arrays can be passed to FFI calls, because
--   Garbage Collector (GC) is guaranteed not to move it. Elements must be
--   an instance of <a>Storable</a> class. It is just as efficient as
--   <a>P</a> and <a>U</a> arrays, except it is subject to
--   fragmentation.</li>
--   <li><a>U</a> - Unboxed representation. Elements must be an instance of
--   <a>Unbox</a> class.</li>
--   <li><a>P</a> - Array that can hold Haskell primitives, such as
--   <a>Int</a>, <a>Word</a>, <a>Double</a>, etc. Any element must be an
--   instance of <a>Prim</a> class.</li>
--   </ul>
--   
--   There are also array representations that only describe how values for
--   its elements can be computed or loaded into memory, as such, they are
--   represented by functions and do not impose the memory overhead, that
--   is normally associated with arrays. They are needed for proper fusion
--   and parallelization of computation.
--   
--   <ul>
--   <li><a>D</a> - delayed array that is a mere function from an index to
--   an element. Also known as <i>Pull</i> array. Crucial representation
--   for fusing computation. Use <a>computeAs</a> in order to load array
--   into <a>Manifest</a> representation.</li>
--   <li><a>DL</a> - delayed load array representation that describes how
--   an array can be loaded. Also known as <i>Push</i> array. Useful for
--   fusing various array combining functions. Use <a>computeAs</a> in
--   order to load array into <a>Manifest</a> representation.</li>
--   <li><a>DS</a> - delayed stream vector representation that describes
--   how to handle a vector with possibility of unknown length. Useful for
--   filtering and unfolding. Use <a>computeAs</a> in order to load such
--   vector into <a>Manifest</a> representation.</li>
--   <li><a>DI</a> - delayed interleaved array. Same as <a>D</a>, but
--   performs better with unbalanced computation, when evaluation of one
--   element takes much longer than of its neighbor.</li>
--   <li><a>DW</a> - delayed windowed array. This peculiar representation
--   allows for very fast <a>Stencil</a> computation.</li>
--   </ul>
--   
--   Other Array types:
--   
--   <ul>
--   <li><a>L</a> - this type isn't particularly useful on its own, but
--   because it has unique ability to be converted to and from nested lists
--   in constant time, it provides a perfect intermediary for conversion of
--   nested lists into manifest arrays.</li>
--   </ul>
--   
--   Most of the <a>Manifest</a> arrays are capable of in-place mutation.
--   Check out <a>Data.Massiv.Array.Mutable</a> module for available
--   functionality.
--   
--   Many of the function names exported by this package will clash with
--   the ones from <a>Prelude</a>, hence it can be more convenient to
--   import like this:
--   
--   <pre>
--   import Prelude as P
--   import Data.Massiv.Array as A
--   </pre>
module Data.Massiv.Array

-- | Create an Array with no elements. By itself it is not particularly
--   useful, but it serves as a nice base for constructing larger arrays.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; xs = empty @DL @Ix1 @Double
--   
--   &gt;&gt;&gt; snoc (cons 4 (cons 5 xs)) 22
--   Array DL Seq (Sz1 3)
--     [ 4.0, 5.0, 22.0 ]
--   </pre>
empty :: forall r ix e. Load r ix e => Array r ix e

-- | Create an Array with a single element.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; singleton 7 :: Array D Ix4 Double
--   Array D Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
--   
--   Instead of specifying type signature we could use
--   <tt>TypeApplications</tt>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; singleton @U @Ix4 @Double 7
--   Array U Seq (Sz (1 :&gt; 1 :&gt; 1 :. 1))
--     [ [ [ [ 7.0 ]
--         ]
--       ]
--     ]
--   </pre>
singleton :: forall r ix e. Load r ix e => e -> Array r ix e

-- | Construct an array of the specified size that contains the same
--   element in all of the cells.
replicate :: Load r ix e => Comp -> Sz ix -> e -> Array r ix e

-- | Construct an Array. Resulting type either has to be unambiguously
--   inferred or restricted manually, like in the example below. Use
--   "Data.Massiv.Array.makeArrayR" if you'd like to specify representation
--   as an argument.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArray Seq (Sz (3 :. 4)) (\ (i :. j) -&gt; if i == j then i else 0) :: Array D Ix2 Int
--   Array D Seq (Sz (3 :. 4))
--     [ [ 0, 0, 0, 0 ]
--     , [ 0, 1, 0, 0 ]
--     , [ 0, 0, 2, 0 ]
--     ]
--   </pre>
--   
--   Instead of restricting the full type manually we can use
--   <tt>TypeApplications</tt> as convenience:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; makeArray @P @_ @Double Seq (Sz2 3 4) $ \(i :. j) -&gt; logBase (fromIntegral i) (fromIntegral j)
--   Array P Seq (Sz (3 :. 4))
--     [ [ NaN, -0.0, -0.0, -0.0 ]
--     , [ -Infinity, NaN, Infinity, Infinity ]
--     , [ -Infinity, 0.0, 1.0, 1.5849625007211563 ]
--     ]
--   </pre>
makeArray :: Load r ix e => Comp -> Sz ix -> (ix -> e) -> Array r ix e

-- | Same as <a>makeArray</a>, but produce elements using linear row-major
--   index.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArrayLinear Seq (Sz (2 :. 4)) id :: Array D Ix2 Int
--   Array D Seq (Sz (2 :. 4))
--     [ [ 0, 1, 2, 3 ]
--     , [ 4, 5, 6, 7 ]
--     ]
--   </pre>
makeArrayLinear :: Load r ix e => Comp -> Sz ix -> (Int -> e) -> Array r ix e

-- | Just like <a>makeArray</a> but with ability to specify the result
--   representation as an argument. Note the <a>U</a>nboxed type
--   constructor in the below example.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; makeArrayR U Par (Sz (2 :&gt; 3 :. 4)) (\ (i :&gt; j :. k) -&gt; i * i + j * j == k * k)
--   Array U Par (Sz (2 :&gt; 3 :. 4))
--     [ [ [ True, False, False, False ]
--       , [ False, True, False, False ]
--       , [ False, False, True, False ]
--       ]
--     , [ [ False, True, False, False ]
--       , [ False, False, False, False ]
--       , [ False, False, False, False ]
--       ]
--     ]
--   </pre>
makeArrayR :: Load r ix e => r -> Comp -> Sz ix -> (ix -> e) -> Array r ix e

-- | Same as <a>makeArrayLinear</a>, but with ability to supply resulting
--   representation
makeArrayLinearR :: Load r ix e => r -> Comp -> Sz ix -> (Int -> e) -> Array r ix e

-- | Same as <a>makeArrayR</a>, but restricted to 1-dimensional arrays.
makeVectorR :: Load r Ix1 e => r -> Comp -> Sz1 -> (Ix1 -> e) -> Vector r e

-- | Sequentially iterate over each cell in the array in the row-major
--   order while continuously aplying the accumulator at each step.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; iterateN (Sz2 2 10) succ (10 :: Int)
--   Array DL Seq (Sz (2 :. 10))
--     [ [ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 ]
--     , [ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 ]
--     ]
--   </pre>
iterateN :: forall ix e. Index ix => Sz ix -> (e -> e) -> e -> Array DL ix e

-- | Same as <a>iterateN</a>, but with index aware function.
iiterateN :: forall ix e. Index ix => Sz ix -> (e -> ix -> e) -> e -> Array DL ix e

-- | Unfold sequentially from the end. There is no way to save the
--   accumulator after unfolding is done, since resulting array is delayed,
--   but it's possible to use <a>unfoldlPrimM</a> to achieve such effect.
unfoldlS_ :: Index ix => Sz ix -> (a -> (a, e)) -> a -> Array DL ix e

-- | Unfold sequentially from the right with an index aware function.
iunfoldlS_ :: forall ix e a. Index ix => Sz ix -> (ix -> a -> (a, e)) -> a -> Array DL ix e

-- | Right unfold into a delayed load array. For the opposite direction use
--   <a>unfoldlS_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; unfoldrS_ (Sz1 10) (\xs -&gt; (Prelude.head xs, Prelude.tail xs)) ([10 ..] :: [Int])
--   Array DL Seq (Sz1 10)
--     [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ]
--   </pre>
unfoldrS_ :: forall ix e a. Index ix => Sz ix -> (a -> (e, a)) -> a -> Array DL ix e

-- | Right unfold of a delayed load array with index aware function
iunfoldrS_ :: forall ix e a. Index ix => Sz ix -> (a -> ix -> (e, a)) -> a -> Array DL ix e

-- | Create a delayed array with an initial seed and a splitting function.
--   It is somewhat similar to <a>iunfoldlS_</a> function, but it is
--   capable of parallelizing computation and iterating over the array
--   accoriding to the supplied <a>Iterator</a>. Upon parallelization every
--   job will get the second part of the result produced by the split
--   function, while the first part will be used for subsequent splits.
--   This function is similar to <a>generateSplitSeedArray</a>
makeSplitSeedArray :: forall ix e g it. (Iterator it, Index ix) => it -> g -> (g -> (g, g)) -> Comp -> Sz ix -> (Ix1 -> ix -> g -> (e, g)) -> Array DL ix e

-- | Generate a random array where all elements are sampled from a uniform
--   distribution.
uniformArray :: forall ix e g. (Index ix, RandomGen g, Uniform e) => g -> Comp -> Sz ix -> Array DL ix e

-- | Same as <a>uniformArray</a>, but will generate values in a supplied
--   range.
uniformRangeArray :: forall ix e g. (Index ix, RandomGen g, UniformRange e) => g -> (e, e) -> Comp -> Sz ix -> Array DL ix e

-- | Create an array with random values by using a pure splittable random
--   number generator such as one provided by either <a>splitmix</a> or
--   <a>random</a> packages. If you don't have a splittable generator
--   consider using <a>randomArrayS</a> or <a>randomArrayWS</a> instead.
--   
--   Because of the pure nature of the generator and its splitability we
--   are not only able to parallelize the random value generation, but also
--   guarantee that it will be deterministic, granted none of the arguments
--   have changed.
--   
--   <b>Note</b>: Starting with massiv-1.1.0 this function will be
--   deprecated in favor of a more general <tt>genSplitArray</tt>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.SplitMix as SplitMix
--   
--   &gt;&gt;&gt; gen = SplitMix.mkSMGen 217
--   
--   &gt;&gt;&gt; randomArray gen SplitMix.splitSMGen SplitMix.nextDouble (ParN 2) (Sz2 2 3) :: Array DL Ix2 Double
--   Array DL (ParN 2) (Sz (2 :. 3))
--     [ [ 0.7383156058619669, 0.39904053166835896, 0.5617584038393628 ]
--     , [ 0.7218718218678238, 0.7006722805067258, 0.7225894731396042 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random as Random
--   
--   &gt;&gt;&gt; gen = Random.mkStdGen 217
--   
--   &gt;&gt;&gt; randomArray gen Random.split Random.random (ParN 2) (Sz2 2 3) :: Array DL Ix2 Double
--   Array DL (ParN 2) (Sz (2 :. 3))
--     [ [ 0.2616843941380331, 0.600959468331641, 0.4382415961606372 ]
--     , [ 0.27812817813217605, 0.2993277194932741, 0.2774105268603957 ]
--     ]
--   </pre>
randomArray :: forall ix e g. Index ix => g -> (g -> (g, g)) -> (g -> (e, g)) -> Comp -> Sz ix -> Array DL ix e

-- | Similar to <a>randomArray</a> but performs generation sequentially,
--   which means it doesn't require splitability property. Another
--   consequence is that it returns the new generator together with
--   <i>manifest</i> array of random values.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.SplitMix as SplitMix
--   
--   &gt;&gt;&gt; gen = SplitMix.mkSMGen 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) SplitMix.nextDouble :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.8878273949359751, 0.11290807610140963, 0.7383156058619669 ]
--     , [ 0.39904053166835896, 0.5617584038393628, 0.16248374266020216 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random.Mersenne.Pure64 as MT
--   
--   &gt;&gt;&gt; gen = MT.pureMT 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) MT.randomDouble :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.5504018416543631, 0.22504666452851707, 0.4480480867867128 ]
--     , [ 0.7139711572975297, 0.49401087853770953, 0.9397201599368645 ]
--     ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import System.Random as System
--   
--   &gt;&gt;&gt; gen = System.mkStdGen 217
--   
--   &gt;&gt;&gt; snd $ randomArrayS gen (Sz2 2 3) System.random :: Array P Ix2 Double
--   Array P Seq (Sz (2 :. 3))
--     [ [ 0.11217260506402493, 0.8870919238985904, 0.2616843941380331 ]
--     , [ 0.600959468331641, 0.4382415961606372, 0.8375162573397977 ]
--     ]
--   </pre>
randomArrayS :: forall r ix e g. (Manifest r e, Index ix) => g -> Sz ix -> (g -> (e, g)) -> (g, Array r ix e)

-- | This is a stateful approach of generating random values. If your
--   generator is pure and splittable, it is better to use
--   <a>randomArray</a> instead, which will give you a pure, deterministic
--   and parallelizable generation of arrays. On the other hand, if your
--   generator is not thread safe, which is most likely the case, instead
--   of using some sort of global mutex, <a>WorkerStates</a> allows you to
--   keep track of individual state per worker (thread), which fits
--   parallelization of random value generation perfectly. All that needs
--   to be done is generators need to be initialized once per worker and
--   then they can be reused as many times as necessary.
--   
--   <h4><b>Examples</b></h4>
--   
--   In the example below we take a stateful random number generator from
--   <a>wmc-random</a>, which is not thread safe, and safely parallelize it
--   by giving each thread it's own generator. There is a caveat of course,
--   statistical independence will depend on the entropy in your initial
--   seeds, so do not use the example below verbatim, since initial seeds
--   are sequential numbers.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import System.Random.MWC as MWC (initialize)
--   
--   &gt;&gt;&gt; import System.Random.Stateful (uniformRM)
--   
--   &gt;&gt;&gt; import Control.Scheduler (initWorkerStates, getWorkerId)
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; gens &lt;- initWorkerStates Par (MWC.initialize . A.toPrimitiveVector . A.singleton @P @Ix1 . fromIntegral . getWorkerId)
--   
--   &gt;&gt;&gt; randomArrayWS gens (Sz2 2 3) (uniformRM (0, 9)) :: IO (Matrix P Double)
--   Array P Par (Sz (2 :. 3))
--     [ [ 8.999240522095299, 6.832223390653755, 3.065728078741671 ]
--     , [ 7.242581103346686, 2.4565807301968623, 0.4514262066689775 ]
--     ]
--   
--   &gt;&gt;&gt; randomArrayWS gens (Sz1 6) (uniformRM (0, 9)) :: IO (Vector P Int)
--   Array P Par (Sz1 6)
--     [ 8, 8, 7, 1, 1, 2 ]
--   </pre>
randomArrayWS :: forall r ix e g m. (Manifest r e, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates g -> Sz ix -> (g -> m e) -> m (Array r ix e)

-- | Similar to <a>makeArray</a>, but construct the array sequentially
--   using an <a>Applicative</a> interface.
--   
--   <i>Note</i> - using <a>generateArray</a> or <a>generateArrayS</a> will
--   always be faster, althought not always possible.
makeArrayA :: forall r ix e f. (Manifest r e, Index ix, Applicative f) => Sz ix -> (ix -> f e) -> f (Array r ix e)

-- | Same as <a>makeArrayA</a>, but with ability to supply result array
--   representation.
makeArrayAR :: forall r ix e f. (Manifest r e, Index ix, Applicative f) => r -> Sz ix -> (ix -> f e) -> f (Array r ix e)

-- | Same as <a>makeArrayA</a>, but with linear index.
makeArrayLinearA :: forall r ix e f. (Manifest r e, Index ix, Applicative f) => Sz ix -> (Int -> f e) -> f (Array r ix e)

-- | Handy synonym for <tt><a>rangeInclusive</a> <a>Seq</a></tt>. Similar
--   to <tt>..</tt> for list.
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ... 10
--   Array D Seq (Sz1 7)
--     [ 4, 5, 6, 7, 8, 9, 10 ]
--   </pre>
(...) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ...

-- | Handy synonym for <tt><a>range</a> <a>Seq</a></tt>
--   
--   <pre>
--   &gt;&gt;&gt; Ix1 4 ..: 10
--   Array D Seq (Sz1 6)
--     [ 4, 5, 6, 7, 8, 9 ]
--   </pre>
(..:) :: Index ix => ix -> ix -> Array D ix ix
infix 4 ..:

-- | Create an array of indices with a range from start to finish
--   (not-including), where indices are incremeted by one.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; range Seq (Ix1 1) 6
--   Array D Seq (Sz1 5)
--     [ 1, 2, 3, 4, 5 ]
--   
--   &gt;&gt;&gt; fromIx2 &lt;$&gt; range Seq (-1) (2 :. 2)
--   Array D Seq (Sz (3 :. 3))
--     [ [ (-1,-1), (-1,0), (-1,1) ]
--     , [ (0,-1), (0,0), (0,1) ]
--     , [ (1,-1), (1,0), (1,1) ]
--     ]
--   </pre>
range :: Index ix => Comp -> ix -> ix -> Array D ix ix

-- | Same as <a>range</a>, but with a custom step.
--   
--   <i><b>Throws Exceptions</b></i>: <a>IndexZeroException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; rangeStepM Seq (Ix1 1) 2 8
--   Array D Seq (Sz1 4)
--     [ 1, 3, 5, 7 ]
--   
--   &gt;&gt;&gt; rangeStepM Seq (Ix1 1) 0 8
--   *** Exception: IndexZeroException: 0
--   </pre>
rangeStepM :: forall ix m. (Index ix, MonadThrow m) => Comp -> ix -> ix -> ix -> m (Array D ix ix)

-- | Same as <a>rangeStepM</a>, but will throw an error whenever
--   <tt>step</tt> contains zeros.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; rangeStep' Seq (Ix1 1) 2 6
--   Array D Seq (Sz1 3)
--     [ 1, 3, 5 ]
--   </pre>
rangeStep' :: (HasCallStack, Index ix) => Comp -> ix -> ix -> ix -> Array D ix ix

-- | Just like <a>range</a>, except the finish index is included.
rangeInclusive :: Index ix => Comp -> ix -> ix -> Array D ix ix

-- | Just like <a>rangeStepM</a>, except the finish index is included.
rangeStepInclusiveM :: (MonadThrow m, Index ix) => Comp -> ix -> ix -> ix -> m (Array D ix ix)

-- | Just like <a>range</a>, except the finish index is included.
rangeStepInclusive' :: (HasCallStack, Index ix) => Comp -> ix -> ix -> ix -> Array D ix ix

-- | Create an array of specified size with indices starting with some
--   index at position <tt>0</tt> and incremented by <tt>1</tt> until the
--   end of the array is reached
rangeSize :: Index ix => Comp -> ix -> Sz ix -> Array D ix ix

-- | Same as <a>rangeSize</a>, but with ability to specify the step.
rangeStepSize :: Index ix => Comp -> ix -> ix -> Sz ix -> Array D ix ix

-- | Same as <a>enumFromStepN</a> with step <tt>dx = 1</tt>.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromStepN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromN Seq (5 :: Double) 3
--   Array D Seq (Sz1 3)
--     [ 5.0, 6.0, 7.0 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFromTo</a></tt></i> Very similar to <tt>[i
--   .. i + n - 1]</tt>, except that <a>enumFromN</a> is faster, but it
--   only works for <a>Num</a> and not for <a>Enum</a> elements</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromN</a></tt></i></li>
--   </ul>
enumFromN :: Num e => Comp -> e -> Sz1 -> Vector D e

-- | Enumerate from a starting number <tt>x</tt> exactly <tt>n</tt> times
--   with a custom step value <tt>dx</tt>. Unlike <a>senumFromStepN</a>,
--   there is no dependency on neigboring elements therefore
--   <a>enumFromStepN</a> is parallelizable.
--   
--   <i>Related</i>: <a>senumFromN</a>, <a>senumFromStepN</a>,
--   <a>enumFromN</a>, <a>rangeSize</a>, <a>rangeStepSize</a>,
--   <a>range</a>, <a>rangeStepM</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; enumFromStepN Seq 1 (0.1 :: Double) 5
--   Array D Seq (Sz1 5)
--     [ 1.0, 1.1, 1.2, 1.3, 1.4 ]
--   
--   &gt;&gt;&gt; enumFromStepN Seq (-pi :: Float) (pi/4) 9
--   Array D Seq (Sz1 9)
--     [ -3.1415927, -2.3561945, -1.5707964, -0.78539824, 0.0, 0.78539824, 1.5707963, 2.3561947, 3.1415927 ]
--   </pre>
--   
--   <b><i>Similar</i></b>:
--   
--   <ul>
--   <li><i><tt>Prelude.<a>enumFrom</a></tt></i> Similar to <tt>take n [x,
--   x + dx ..]</tt>, except that <a>enumFromStepN</a> is parallelizable
--   and it only works for <a>Num</a> and not for <a>Enum</a> elements.
--   Floating point value will be slightly different as well.</li>
--   <li><i><tt>Data.Vector.Generic.<a>enumFromStepN</a></tt></i> Similar
--   in the outcome, but very different in the way it works.</li>
--   </ul>
enumFromStepN :: Num e => Comp -> e -> e -> Sz1 -> Vector D e

-- | Function that expands an array to one with a higher dimension.
--   
--   This is useful for constructing arrays where there is shared
--   computation between multiple cells. The makeArray method of
--   constructing arrays:
--   
--   <pre>
--   makeArray :: Construct r ix e =&gt; Comp -&gt; ix -&gt; (ix -&gt; e) -&gt; Array r ix e
--   </pre>
--   
--   ...runs a function <tt>ix -&gt; e</tt> at every array index. This is
--   inefficient if there is a substantial amount of repeated computation
--   that could be shared while constructing elements on the same
--   dimension. The expand functions make this possible. First you
--   construct an <tt>Array r (Lower ix) a</tt> of one fewer dimensions
--   where <tt>a</tt> is something like <tt><a>Array</a> r <a>Ix1</a>
--   a</tt> or <tt><a>Array</a> r <a>Ix2</a> a</tt>. Then you use
--   <a>expandWithin</a> and a creation function <tt>a -&gt; Int -&gt;
--   b</tt> to create an <tt><a>Array</a> <a>D</a> <a>Ix2</a> b</tt> or
--   <tt><a>Array</a> <a>D</a> <a>Ix3</a> b</tt> respectfully.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = makeArrayR U Seq (Sz1 6) (+10) -- Imagine (+10) is some expensive function
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz1 6)
--     [ 10, 11, 12, 13, 14, 15 ]
--   
--   &gt;&gt;&gt; expandWithin Dim1 5 (\ e j -&gt; (j + 1) * 100 + e) a :: Array D Ix2 Int
--   Array D Seq (Sz (6 :. 5))
--     [ [ 110, 210, 310, 410, 510 ]
--     , [ 111, 211, 311, 411, 511 ]
--     , [ 112, 212, 312, 412, 512 ]
--     , [ 113, 213, 313, 413, 513 ]
--     , [ 114, 214, 314, 414, 514 ]
--     , [ 115, 215, 315, 415, 515 ]
--     ]
--   
--   &gt;&gt;&gt; expandWithin Dim2 5 (\ e j -&gt; (j + 1) * 100 + e) a :: Array D Ix2 Int
--   Array D Seq (Sz (5 :. 6))
--     [ [ 110, 111, 112, 113, 114, 115 ]
--     , [ 210, 211, 212, 213, 214, 215 ]
--     , [ 310, 311, 312, 313, 314, 315 ]
--     , [ 410, 411, 412, 413, 414, 415 ]
--     , [ 510, 511, 512, 513, 514, 515 ]
--     ]
--   </pre>
expandWithin :: forall n ix e r a. (IsIndexDimension ix n, Index (Lower ix), Manifest r a) => Dimension n -> Sz1 -> (a -> Ix1 -> e) -> Array r (Lower ix) a -> Array D ix e

-- | Similar to <a>expandWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
expandWithinM :: forall r ix a b m. (Index ix, Index (Lower ix), Manifest r a, MonadThrow m) => Dim -> Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> m (Array D ix b)

-- | Similar to <a>expandWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
expandWithin' :: forall r ix a b. (HasCallStack, Index ix, Index (Lower ix), Manifest r a) => Dim -> Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Similar to <a>expandWithin</a>, except it uses the outermost
--   dimension.
expandOuter :: forall r ix a b. (Index ix, Index (Lower ix), Manifest r a) => Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Similar to <a>expandWithin</a>, except it uses the innermost
--   dimension.
expandInner :: forall r ix a b. (Index ix, Index (Lower ix), Manifest r a) => Sz1 -> (a -> Ix1 -> b) -> Array r (Lower ix) a -> Array D ix b

-- | Get computation strategy of this array
getComp :: Strategy r => Array r ix e -> Comp

-- | Set computation strategy for this array
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; a = singleton @DL @Ix1 @Int 0
--   
--   &gt;&gt;&gt; a
--   Array DL Seq (Sz1 1)
--     [ 0 ]
--   
--   &gt;&gt;&gt; setComp (ParN 6) a -- use 6 capabilities
--   Array DL (ParN 6) (Sz1 1)
--     [ 0 ]
--   </pre>
setComp :: Strategy r => Comp -> Array r ix e -> Array r ix e

-- | Append computation strategy using <a>Comp</a>'s <a>Monoid</a>
--   instance.
appComp :: Strategy r => Comp -> Array r ix e -> Array r ix e

-- | Ensure that Array is computed, i.e. represented with concrete elements
--   in memory, hence is the <a>Mutable</a> type class restriction. Use
--   <a>setComp</a> if you'd like to change computation strategy before
--   calling <tt>compute</tt>
compute :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array sequentially disregarding predefined computation
--   strategy. Very much the same as <a>computePrimM</a>, but executed in
--   <a>ST</a>, thus pure.
computeS :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Compute array in parallel using all cores disregarding predefined
--   computation strategy. Computation stategy of the resulting array will
--   match the source, despite that it is diregarded.
computeP :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Very similar to <a>compute</a>, but computes an array inside the
--   <a>IO</a> monad. Despite being deterministic and referentially
--   transparent, because this is an <a>IO</a> action it can be very useful
--   for enforcing the order of evaluation. Should be a prefered way of
--   computing an array during benchmarking.
computeIO :: forall r ix e r' m. (Manifest r e, Load r' ix e, MonadIO m) => Array r' ix e -> m (Array r ix e)

-- | Compute an array in <a>PrimMonad</a> sequentially disregarding
--   predefined computation strategy.
computePrimM :: forall r ix e r' m. (Manifest r e, Load r' ix e, PrimMonad m) => Array r' ix e -> m (Array r ix e)

-- | Just as <a>compute</a>, but let's you supply resulting representation
--   type as an argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeAs P $ range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
--   </pre>
computeAs :: (Manifest r e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>compute</a> and <a>computeAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   Useful only really for cases when representation constructor or
--   <tt>TypeApplications</tt> extension aren't desireable for some reason:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Proxy
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; computeProxy (Proxy :: Proxy P) $ (^ (2 :: Int)) &lt;$&gt; range Seq (Ix1 0) 10
--   Array P Seq (Sz1 10)
--     [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 ]
--   </pre>
computeProxy :: (Manifest r e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | This is just like <a>convert</a>, but restricted to <a>Source</a>
--   arrays. Will be a noop if resulting type is the same as the input.
computeSource :: forall r ix e r'. (Manifest r e, Source r' e, Index ix) => Array r' ix e -> Array r ix e

-- | Same as <a>compute</a>, but with <a>Stride</a>.
--   
--   <i>O(n div k)</i> - Where <tt>n</tt> is number of elements in the
--   source array and <tt>k</tt> is number of elements in the stride.
computeWithStride :: forall r ix e r'. (Manifest r e, StrideLoad r' ix e) => Stride ix -> Array r' ix e -> Array r ix e

-- | Same as <a>computeWithStride</a>, but with ability to specify
--   resulting array representation.
computeWithStrideAs :: (Manifest r e, StrideLoad r' ix e) => r -> Stride ix -> Array r' ix e -> Array r ix e

-- | <i>O(n)</i> - Make an exact immutable copy of an Array.
clone :: (Manifest r e, Index ix) => Array r ix e -> Array r ix e

-- | <i>O(n)</i> - conversion between array types. A full copy will occur,
--   unless when the source and result arrays are of the same
--   representation, in which case it is an <i>O(1)</i> operation.
convert :: forall r ix e r'. (Manifest r e, Load r' ix e) => Array r' ix e -> Array r ix e

-- | Same as <a>convert</a>, but let's you supply resulting representation
--   type as an argument.
convertAs :: (Manifest r e, Load r' ix e) => r -> Array r' ix e -> Array r ix e

-- | Same as <a>convert</a> and <a>convertAs</a>, but let's you supply
--   resulting representation type as a proxy argument.
convertProxy :: (Manifest r e, Load r' ix e) => proxy r -> Array r' ix e -> Array r ix e

-- | Convert a ragged array into a common array with rectangular shape.
--   Throws <a>ShapeException</a> whenever supplied ragged array does not
--   have a rectangular shape.
fromRaggedArrayM :: forall r ix e r' m. (Manifest r e, Ragged r' ix e, MonadThrow m) => Array r' ix e -> m (Array r ix e)

-- | Same as <a>fromRaggedArrayM</a>, but will throw an impure exception if
--   its shape is not rectangular.
fromRaggedArray' :: forall r ix e r'. (HasCallStack, Manifest r e, Ragged r' ix e) => Array r' ix e -> Array r ix e

-- | <i>O(1)</i> - Get the exact size of an immutabe array. Most of the
--   time will produce the size in constant time, except for <a>DS</a>
--   representation, which could result in evaluation of the whole stream.
--   See <a>maxLinearSize</a> and <a>slength</a> for more info.
size :: Size r => Array r ix e -> Sz ix

-- | <i>O(1)</i> - Get the number of elements in the array.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; elemsCount $ range Seq (Ix1 10) 15
--   5
--   </pre>
elemsCount :: (Index ix, Size r) => Array r ix e -> Int

-- | <i>O(1)</i> - Check if array has elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isEmpty (singleton 1 :: Array D Ix2 Int)
--   False
--   
--   &gt;&gt;&gt; isEmpty (empty :: Array D Ix2 Int)
--   True
--   </pre>
isEmpty :: (Index ix, Size r) => Array r ix e -> Bool

-- | <i>O(1)</i> - Check if array has elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNotEmpty (singleton 1 :: Array D Ix2 Int)
--   True
--   
--   &gt;&gt;&gt; isNotEmpty (empty :: Array D Ix2 Int)
--   False
--   </pre>
isNotEmpty :: (Index ix, Size r) => Array r ix e -> Bool

-- | <i>O(1)</i> - Check whether an array is empty or not.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (11 :. 21)
--   False
--   
--   &gt;&gt;&gt; isNull $ range Seq (Ix2 10 20) (10 :. 21)
--   True
--   
--   &gt;&gt;&gt; isNull (empty :: Array D Ix5 Int)
--   True
--   
--   &gt;&gt;&gt; isNull $ sfromList []
--   True
--   </pre>
isNull :: Shape r ix => Array r ix e -> Bool

-- | <i>O(1)</i> - Check if array has elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; isNotNull (singleton 1 :: Array D Ix2 Int)
--   True
--   
--   &gt;&gt;&gt; isNotNull (empty :: Array D Ix2 Int)
--   False
--   </pre>
isNotNull :: Shape r ix => Array r ix e -> Bool

-- | <i>O(1)</i> - Infix version of <a>indexM</a>.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; a &lt;- fromListsM @U @Ix2 @Int Seq [[1,2,3],[4,5,6]]
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a !? 0 :. 2
--   3
--   
--   &gt;&gt;&gt; a !? 0 :. 3
--   *** Exception: IndexOutOfBoundsException: (0 :. 3) is not safe for (Sz (2 :. 3))
--   
--   &gt;&gt;&gt; a !? 0 :. 3 :: Maybe Int
--   Nothing
--   </pre>
(!?) :: forall r ix e m. (Index ix, Manifest r e, MonadThrow m) => Array r ix e -> ix -> m e
infixl 4 !?

-- | <i>O(1)</i> - Infix version of <a>index'</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; a = computeAs U $ iterateN (Sz (2 :. 3)) succ (0 :: Int)
--   
--   &gt;&gt;&gt; a
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a ! 0 :. 2
--   3
--   </pre>
(!) :: forall r ix e. (HasCallStack, Manifest r e, Index ix) => Array r ix e -> ix -> e
infixl 4 !

-- | <i>O(1)</i> - Lookup an element in the array, where array itself is
--   wrapped with <a>MonadThrow</a>. This operator is useful when used
--   together with slicing or other functions that can fail.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; ma = fromListsM @U @Ix3 @Int @Maybe Seq [[[1,2,3]],[[4,5,6]]]
--   
--   &gt;&gt;&gt; ma
--   Just (Array U Seq (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 1, 2, 3 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       ]
--     ]
--   )
--   
--   &gt;&gt;&gt; ma ??&gt; 1
--   Just (Array U Seq (Sz (1 :. 3))
--     [ [ 4, 5, 6 ]
--     ]
--   )
--   
--   &gt;&gt;&gt; ma ??&gt; 1 ?? 0 :. 2
--   Just 6
--   
--   &gt;&gt;&gt; ma ?? 1 :&gt; 0 :. 2
--   Just 6
--   </pre>
(??) :: (Index ix, Manifest r e, MonadThrow m) => m (Array r ix e) -> ix -> m e
infixl 4 ??

-- | <i>O(1)</i> - Lookup an element in the array.
--   
--   <i><b>Exceptions</b></i>: <a>IndexOutOfBoundsException</a>
indexM :: (Index ix, Manifest r e, MonadThrow m) => Array r ix e -> ix -> m e

-- | <i>O(1)</i> - Lookup an element in the array. Returns <a>Nothing</a>,
--   when index is out of bounds and returns the element at the supplied
--   index otherwise. Use <a>indexM</a> instead, since it is more general
--   and it can just as well be used with <a>Maybe</a>.
index :: (Index ix, Manifest r e) => Array r ix e -> ix -> Maybe e

-- | <i>O(1)</i> - Lookup an element in the array. This is a partial
--   function and it will throw an error when index is out of bounds. It is
--   safer to use <a>indexM</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; index' xs 50
--   50
--   </pre>
index' :: (HasCallStack, Index ix, Manifest r e) => Array r ix e -> ix -> e

-- | <i>O(1)</i> - Lookup an element in the array, while using default
--   element when index is out of bounds.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array P Ix1 Int
--   
--   &gt;&gt;&gt; defaultIndex 999 xs 100
--   100
--   
--   &gt;&gt;&gt; defaultIndex 999 xs 101
--   999
--   </pre>
defaultIndex :: (Index ix, Manifest r e) => e -> Array r ix e -> ix -> e

-- | <i>O(1)</i> - Lookup an element in the array. Use a border resolution
--   technique when index is out of bounds.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; xs = [0..100] :: Array U Ix1 Int
--   
--   &gt;&gt;&gt; borderIndex Wrap xs &lt;$&gt; range Seq 99 104
--   Array D Seq (Sz1 5)
--     [ 99, 100, 0, 1, 2 ]
--   </pre>
borderIndex :: (Index ix, Manifest r e) => Border e -> Array r ix e -> ix -> e

-- | This is just like <a>indexM</a> function, but it allows getting values
--   from delayed arrays as well as <a>Manifest</a>. As the name suggests,
--   indexing into a delayed array at the same index multiple times will
--   cause evaluation of the value each time and can destroy the performace
--   if used without care.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Exception
--   
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; evaluateM (range Seq (Ix2 10 20) (100 :. 210)) 50 :: Either SomeException Ix2
--   Right (60 :. 70)
--   
--   &gt;&gt;&gt; evaluateM (range Seq (Ix2 10 20) (100 :. 210)) 150 :: Either SomeException Ix2
--   Left (IndexOutOfBoundsException: (150 :. 150) is not safe for (Sz (90 :. 190)))
--   </pre>
evaluateM :: (Index ix, Source r e, MonadThrow m) => Array r ix e -> ix -> m e

-- | Similar to <a>evaluateM</a>, but will throw an error on out of bounds
--   indices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; evaluate' (range Seq (Ix2 10 20) (100 :. 210)) 50
--   60 :. 70
--   </pre>
evaluate' :: (HasCallStack, Index ix, Source r e) => Array r ix e -> ix -> e

-- | Map a function over an array
map :: (Index ix, Source r e') => (e' -> e) -> Array r ix e' -> Array D ix e

-- | Map an index aware function over an array
imap :: forall r ix e a. (Index ix, Source r e) => (ix -> e -> a) -> Array r ix e -> Array D ix a

-- | Traverse with an <a>Applicative</a> action over an array sequentially.
--   
--   <i>Note</i> - using <a>traversePrim</a> instead will always be
--   significantly faster, roughly about 30 times faster in practice.
traverseA :: forall r ix e r' a f. (Source r' a, Manifest r e, Index ix, Applicative f) => (a -> f e) -> Array r' ix a -> f (Array r ix e)

-- | Traverse sequentially over a source array, while discarding the
--   result.
traverseA_ :: forall r ix e a f. (Index ix, Source r e, Applicative f) => (e -> f a) -> Array r ix e -> f ()

-- | Traverse with an <a>Applicative</a> index aware action over an array
--   sequentially.
itraverseA :: forall r ix e r' a f. (Source r' a, Manifest r e, Index ix, Applicative f) => (ix -> a -> f e) -> Array r' ix a -> f (Array r ix e)

-- | Traverse with an <a>Applicative</a> index aware action over an array
--   sequentially.
itraverseA_ :: forall r ix e a f. (Source r a, Index ix, Applicative f) => (ix -> a -> f e) -> Array r ix a -> f ()

-- | Sequence actions in a source array.
sequenceA :: forall r ix e r' f. (Source r' (f e), Manifest r e, Index ix, Applicative f) => Array r' ix (f e) -> f (Array r ix e)

-- | Sequence actions in a source array, while discarding the result.
sequenceA_ :: forall r ix e f. (Index ix, Source r (f e), Applicative f) => Array r ix (f e) -> f ()

-- | Traverse sequentially within <a>PrimMonad</a> over an array with an
--   action.
traversePrim :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, PrimMonad m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>traversePrim</a>, but traverse with index aware action.
itraversePrim :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, PrimMonad m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Map a monadic action over an array sequentially.
mapM :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, Monad m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>mapM</a> except with arguments flipped.
forM :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, Monad m) => Array r' ix a -> (a -> m b) -> m (Array r ix b)

-- | Map an index aware monadic action over an array sequentially.
imapM :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, Monad m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>forM</a>, except with an index aware action.
iforM :: forall r ix b r' a m. (Source r' a, Manifest r b, Index ix, Monad m) => Array r' ix a -> (ix -> a -> m b) -> m (Array r ix b)

-- | Map a monadic function over an array sequentially, while discarding
--   the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; rangeStepM Par (Ix1 10) 12 60 &gt;&gt;= A.mapM_ print
--   10
--   22
--   34
--   46
--   58
--   </pre>
mapM_ :: (Source r a, Index ix, Monad m) => (a -> m b) -> Array r ix a -> m ()

-- | Just like <a>mapM_</a>, except with flipped arguments.
--   
--   <h4><b>Examples</b></h4>
--   
--   Here is a common way of iterating N times using a for loop in an
--   imperative language with mutation being an obvious side effect:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef 0 :: IO (IORef Int)
--   
--   &gt;&gt;&gt; A.forM_ (range Seq (Ix1 0) 1000) $ \ i -&gt; modifyIORef' ref (+i)
--   
--   &gt;&gt;&gt; readIORef ref
--   499500
--   </pre>
forM_ :: (Source r a, Index ix, Monad m) => Array r ix a -> (a -> m b) -> m ()

-- | Map a monadic index aware function over an array sequentially, while
--   discarding the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; imapM_ (curry print) $ range Seq (Ix1 10) 15
--   (0,10)
--   (1,11)
--   (2,12)
--   (3,13)
--   (4,14)
--   </pre>
imapM_ :: (Index ix, Source r a, Monad m) => (ix -> a -> m b) -> Array r ix a -> m ()

-- | Just like <a>imapM_</a>, except with flipped arguments.
iforM_ :: (Source r a, Index ix, Monad m) => Array r ix a -> (ix -> a -> m b) -> m ()

-- | Map an <a>IO</a> action over an <a>Array</a>. Underlying computation
--   strategy is respected and will be parallelized when requested.
--   Unfortunately no fusion is possible and new array will be create upon
--   each call.
mapIO :: forall r ix b r' a m. (Size r', Load r' ix a, Manifest r b, MonadUnliftIO m) => (a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>imapWS</a>, but without the index.
mapWS :: forall r ix b r' a s m. (Source r' a, Manifest r b, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> (a -> s -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Similar to <a>mapIO</a>, but ignores the result of mapping action and
--   does not create a resulting array, therefore it is faster. Use this
--   instead of <a>mapIO</a> when result is irrelevant. Most importantly it
--   will follow the iteration logic outlined by the supplied array.
mapIO_ :: forall r ix e a m. (Load r ix e, MonadUnliftIO m) => (e -> m a) -> Array r ix e -> m ()

-- | Same as <a>mapIO</a> but map an index aware action instead. Respects
--   computation strategy.
imapIO :: forall r ix b r' a m. (Size r', Load r' ix a, Manifest r b, MonadUnliftIO m) => (ix -> a -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>imapIO</a>, but ignores the inner computation strategy and
--   uses stateful workers during computation instead. Use
--   <a>initWorkerStates</a> for the <a>WorkerStates</a> initialization.
imapWS :: forall r ix b r' a s m. (Source r' a, Manifest r b, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> (ix -> a -> s -> m b) -> Array r' ix a -> m (Array r ix b)

-- | Same as <a>mapIO_</a>, but map an index aware action instead.
imapIO_ :: forall r ix e a m. (Load r ix e, MonadUnliftIO m) => (ix -> e -> m a) -> Array r ix e -> m ()

-- | Same as <a>mapIO</a> but with arguments flipped.
forIO :: forall r ix b r' a m. (Size r', Load r' ix a, Manifest r b, MonadUnliftIO m) => Array r' ix a -> (a -> m b) -> m (Array r ix b)

-- | Same as <a>iforWS</a>, but without the index.
forWS :: forall r ix b r' a s m. (Source r' a, Manifest r b, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Array r' ix a -> (a -> s -> m b) -> m (Array r ix b)

-- | Same as <a>mapIO_</a> but with arguments flipped.
--   
--   <h4><b>Example</b></h4>
--   
--   This is the same example as in <a>forM_</a>, with important difference
--   that accumulator <tt>ref</tt> will be modified concurrently by as many
--   threads as there are capabilities.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.IORef
--   
--   &gt;&gt;&gt; ref &lt;- newIORef 0 :: IO (IORef Int)
--   
--   &gt;&gt;&gt; forIO_ (range Par (Ix1 0) 1000) $ \ i -&gt; atomicModifyIORef' ref (\v -&gt; (v+i, ()))
--   
--   &gt;&gt;&gt; readIORef ref
--   499500
--   </pre>
forIO_ :: (Load r ix e, MonadUnliftIO m) => Array r ix e -> (e -> m a) -> m ()

-- | Same as <a>imapIO</a> but with arguments flipped.
iforIO :: forall r ix b r' a m. (Size r', Load r' ix a, Manifest r b, MonadUnliftIO m) => Array r' ix a -> (ix -> a -> m b) -> m (Array r ix b)

-- | Same as <a>imapWS</a>, but with source array and mapping action
--   arguments flipped.
iforWS :: forall r ix b r' a s m. (Source r' a, Manifest r b, Index ix, MonadUnliftIO m, PrimMonad m) => WorkerStates s -> Array r' ix a -> (ix -> a -> s -> m b) -> m (Array r ix b)

-- | Same as <a>imapIO_</a> but with arguments flipped.
iforIO_ :: forall r ix e a m. (Load r ix e, MonadUnliftIO m) => Array r ix e -> (ix -> e -> m a) -> m ()

-- | Same as <a>imapM_</a>, but will use the supplied scheduler.
imapSchedulerM_ :: (Index ix, Source r e, MonadPrimBase s m) => Scheduler s () -> (ix -> e -> m a) -> Array r ix e -> m ()

-- | Same as <a>imapM_</a>, but will use the supplied scheduler.
iforSchedulerM_ :: (Index ix, Source r e, MonadPrimBase s m) => Scheduler s () -> Array r ix e -> (ix -> e -> m a) -> m ()
iterArrayLinearM_ :: forall r ix e m s. (Load r ix e, MonadPrimBase s m) => Scheduler s () -> Array r ix e -> (Int -> e -> m ()) -> m ()
iterArrayLinearWithSetM_ :: forall r ix e m s. (Load r ix e, MonadPrimBase s m) => Scheduler s () -> Array r ix e -> (Int -> e -> m ()) -> (Ix1 -> Sz1 -> e -> m ()) -> m ()
iterArrayLinearWithStrideM_ :: forall r ix e m s. (StrideLoad r ix e, MonadPrimBase s m) => Scheduler s () -> Stride ix -> Sz ix -> Array r ix e -> (Int -> e -> m ()) -> m ()

-- | Zip two arrays
zip :: (Index ix, Source r1 e1, Source r2 e2) => Array r1 ix e1 -> Array r2 ix e2 -> Array D ix (e1, e2)

-- | Zip three arrays
zip3 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3) => Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix (e1, e2, e3)

-- | Zip four arrays
zip4 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3, Source r4 e4) => Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix (e1, e2, e3, e4)

-- | Unzip two arrays
unzip :: (Index ix, Source r (e1, e2)) => Array r ix (e1, e2) -> (Array D ix e1, Array D ix e2)

-- | Unzip three arrays
unzip3 :: (Index ix, Source r (e1, e2, e3)) => Array r ix (e1, e2, e3) -> (Array D ix e1, Array D ix e2, Array D ix e3)

-- | Unzip four arrays
unzip4 :: (Index ix, Source r (e1, e2, e3, e4)) => Array r ix (e1, e2, e3, e4) -> (Array D ix e1, Array D ix e2, Array D ix e3, Array D ix e4)

-- | Zip two arrays with a function. Resulting array will be an
--   intersection of source arrays in case their dimensions do not match.
zipWith :: (Index ix, Source r1 e1, Source r2 e2) => (e1 -> e2 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array D ix e

-- | Just like <a>zipWith</a>, except zip three arrays with a function.
zipWith3 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3) => (e1 -> e2 -> e3 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix e

-- | Just like <a>zipWith</a>, except zip four arrays with a function.
zipWith4 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3, Source r4 e4) => (e1 -> e2 -> e3 -> e4 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix e

-- | Just like <a>zipWith</a>, except with an index aware function.
izipWith :: (Index ix, Source r1 e1, Source r2 e2) => (ix -> e1 -> e2 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array D ix e

-- | Just like <a>zipWith3</a>, except with an index aware function.
izipWith3 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3) => (ix -> e1 -> e2 -> e3 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array D ix e

-- | Just like <a>zipWith4</a>, except with an index aware function.
izipWith4 :: (Index ix, Source r1 e1, Source r2 e2, Source r3 e3, Source r4 e4) => (ix -> e1 -> e2 -> e3 -> e4 -> e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> Array r4 ix e4 -> Array D ix e

-- | Similar to <a>zipWith</a>, except does it sequentially and using the
--   <a>Applicative</a>. Note that resulting array has Manifest
--   representation.
zipWithA :: (Source r1 e1, Source r2 e2, Applicative f, Manifest r e, Index ix) => (e1 -> e2 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> f (Array r ix e)

-- | Similar to <a>zipWith</a>, except does it sequentially and using the
--   <a>Applicative</a>. Note that resulting array has Manifest
--   representation.
izipWithA :: (Source r1 e1, Source r2 e2, Applicative f, Manifest r e, Index ix) => (ix -> e1 -> e2 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> f (Array r ix e)

-- | Same as <a>zipWithA</a>, but for three arrays.
zipWith3A :: (Source r1 e1, Source r2 e2, Source r3 e3, Applicative f, Manifest r e, Index ix) => (e1 -> e2 -> e3 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> f (Array r ix e)

-- | Same as <a>izipWithA</a>, but for three arrays.
izipWith3A :: (Source r1 e1, Source r2 e2, Source r3 e3, Applicative f, Manifest r e, Index ix) => (ix -> e1 -> e2 -> e3 -> f e) -> Array r1 ix e1 -> Array r2 ix e2 -> Array r3 ix e3 -> f (Array r ix e)

-- | <i>O(n)</i> - Unstructured fold of an array.
fold :: (Monoid e, Index ix, Source r e) => Array r ix e -> e

-- | <i>O(n)</i> - Monoidal fold over an array with an index aware
--   function. Also known as reduce.
ifoldMono :: (Index ix, Source r e, Monoid m) => (ix -> e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - This is exactly like <a>foldMap</a>, but for arrays.
--   Fold over an array, while converting each element into a
--   <a>Monoid</a>. Also known as map-reduce. If elements of the array are
--   already a <a>Monoid</a> you can use <a>fold</a> instead.
foldMono :: (Index ix, Source r e, Monoid m) => (e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - Semigroup fold over an array with an index aware
--   function.
ifoldSemi :: (Index ix, Source r e, Semigroup m) => (ix -> e -> m) -> m -> Array r ix e -> m

-- | <i>O(n)</i> - Semigroup fold over an array.
foldSemi :: (Index ix, Source r e, Semigroup m) => (e -> m) -> m -> Array r ix e -> m

-- | Reduce each outer slice into a monoid and mappend results together
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Monoid (Product(..))
--   
--   &gt;&gt;&gt; arr = computeAs P $ iterateN (Sz2 2 3) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (2 :. 3))
--     [ [ 11, 12, 13 ]
--     , [ 14, 15, 16 ]
--     ]
--   
--   &gt;&gt;&gt; getProduct $ foldOuterSlice (\row -&gt; Product (A.sum row)) arr
--   1620
--   
--   &gt;&gt;&gt; (11 + 12 + 13) * (14 + 15 + 16) :: Int
--   1620
--   </pre>
foldOuterSlice :: (Index ix, Index (Lower ix), Source r e, Monoid m) => (Array r (Lower ix) e -> m) -> Array r ix e -> m

-- | Reduce each outer slice into a monoid with an index aware function and
--   mappend results together
ifoldOuterSlice :: (Index ix, Index (Lower ix), Source r e, Monoid m) => (Ix1 -> Array r (Lower ix) e -> m) -> Array r ix e -> m

-- | Reduce each inner slice into a monoid and mappend results together
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; import Data.Monoid (Product(..))
--   
--   &gt;&gt;&gt; arr = computeAs P $ iterateN (Sz2 2 3) (+1) (10 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (2 :. 3))
--     [ [ 11, 12, 13 ]
--     , [ 14, 15, 16 ]
--     ]
--   
--   &gt;&gt;&gt; getProduct $ foldInnerSlice (\column -&gt; Product (A.sum column)) arr
--   19575
--   
--   &gt;&gt;&gt; (11 + 14) * (12 + 15) * (13 + 16) :: Int
--   19575
--   </pre>
foldInnerSlice :: (Source r e, Index ix, Monoid m) => (Array D (Lower ix) e -> m) -> Array r ix e -> m

-- | Reduce each inner slice into a monoid with an index aware function and
--   mappend results together
ifoldInnerSlice :: (Source r e, Index ix, Monoid m) => (Ix1 -> Array D (Lower ix) e -> m) -> Array r ix e -> m

-- | <i>O(n)</i> - Compute minimum of all elements.
minimumM :: (MonadThrow m, Shape r ix, Source r e, Ord e) => Array r ix e -> m e

-- | <i>O(n)</i> - Compute minimum of all elements.
minimum' :: forall r ix e. (HasCallStack, Shape r ix, Source r e, Ord e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute maximum of all elements.
maximumM :: (MonadThrow m, Shape r ix, Source r e, Ord e) => Array r ix e -> m e

-- | <i>O(n)</i> - Compute maximum of all elements.
maximum' :: forall r ix e. (HasCallStack, Shape r ix, Source r e, Ord e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute sum of all elements.
sum :: (Index ix, Source r e, Num e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute product of all elements.
product :: (Index ix, Source r e, Num e) => Array r ix e -> e

-- | <i>O(n)</i> - Compute conjunction of all elements.
and :: (Index ix, Source r Bool) => Array r ix Bool -> Bool

-- | <i>O(n)</i> - Compute disjunction of all elements.
or :: (Index ix, Source r Bool) => Array r ix Bool -> Bool

-- | <i>O(n)</i> - Determines whether all elements of the array satisfy a
--   predicate.
all :: (Index ix, Source r e) => (e -> Bool) -> Array r ix e -> Bool

-- | <i>O(n)</i> - Determines whether any element of the array satisfies a
--   predicate.
any :: (Index ix, Source r e) => (e -> Bool) -> Array r ix e -> Bool

-- | <i>O(n)</i> - Determines whether an element is present in the array.
elem :: (Eq e, Index ix, Source r e) => e -> Array r ix e -> Bool

-- | Compute array equality by applying a comparing function to each
--   element. Empty arrays are always equal, regardless of their size.
eqArrays :: (Index ix, Source r1 e1, Source r2 e2) => (e1 -> e2 -> Bool) -> Array r1 ix e1 -> Array r2 ix e2 -> Bool

-- | Compute array ordering by applying a comparing function to each
--   element. The exact ordering is unspecified so this is only intended
--   for use in maps and the like where you need an ordering but do not
--   care about which one is used.
compareArrays :: (Index ix, Source r1 e1, Source r2 e2) => (e1 -> e2 -> Ordering) -> Array r1 ix e1 -> Array r2 ix e2 -> Ordering

-- | Left fold over the inner most dimension with index aware function.
ifoldlInner :: (Index (Lower ix), Index ix, Source r e) => (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Left fold over the inner most dimension.
foldlInner :: (Index (Lower ix), Index ix, Source r e) => (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold over the inner most dimension with index aware function.
ifoldrInner :: (Index (Lower ix), Index ix, Source r e) => (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold over the inner most dimension.
foldrInner :: (Index (Lower ix), Index ix, Source r e) => (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over the inner most dimension.
foldInner :: (Monoid e, Index (Lower ix), Index ix, Source r e) => Array r ix e -> Array D (Lower ix) e

-- | Left fold along a specified dimension with an index aware function.
ifoldlWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r e) => Dimension n -> (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Left fold along a specified dimension.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @U Seq (Sz (2 :. 5)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :. 5))
--     [ [ 0, 1, 2, 3, 4 ]
--     , [ 5, 6, 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; foldlWithin Dim1 (flip (:)) [] arr
--   Array D Seq (Sz1 2)
--     [ [4,3,2,1,0], [9,8,7,6,5] ]
--   
--   &gt;&gt;&gt; foldlWithin Dim2 (flip (:)) [] arr
--   Array D Seq (Sz1 5)
--     [ [5,0], [6,1], [7,2], [8,3], [9,4] ]
--   </pre>
foldlWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r e) => Dimension n -> (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold along a specified dimension with an index aware function.
ifoldrWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r e) => Dimension n -> (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Right fold along a specified dimension.
foldrWithin :: (Index (Lower ix), IsIndexDimension ix n, Source r e) => Dimension n -> (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over some internal dimension.
foldWithin :: (Source r a, Monoid a, Index (Lower ix), IsIndexDimension ix n) => Dimension n -> Array r ix a -> Array D (Lower ix) a

-- | Similar to <a>ifoldlWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
ifoldlWithin' :: (HasCallStack, Index (Lower ix), Index ix, Source r e) => Dim -> (ix -> a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>foldlWithin</a>, except that dimension is specified at a
--   value level, which means it will throw an exception on an invalid
--   dimension.
foldlWithin' :: (HasCallStack, Index (Lower ix), Index ix, Source r e) => Dim -> (a -> e -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>ifoldrWithin</a>, except that dimension is specified at
--   a value level, which means it will throw an exception on an invalid
--   dimension.
ifoldrWithin' :: (HasCallStack, Index (Lower ix), Index ix, Source r e) => Dim -> (ix -> e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Similar to <a>foldrWithin</a>, except that dimension is specified at a
--   value level, which means it will throw an exception on an invalid
--   dimension.
foldrWithin' :: (HasCallStack, Index (Lower ix), Index ix, Source r e) => Dim -> (e -> a -> a) -> a -> Array r ix e -> Array D (Lower ix) a

-- | Monoidal fold over some internal dimension. This is a pratial function
--   and will result in <a>IndexDimensionException</a> if supplied
--   dimension is invalid.
foldWithin' :: (HasCallStack, Index ix, Source r a, Monoid a, Index (Lower ix)) => Dim -> Array r ix a -> Array D (Lower ix) a

-- | <i>O(n)</i> - Left fold, computed sequentially.
foldlS :: (Index ix, Source r e) => (a -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold, computed sequentially.
foldrS :: (Index ix, Source r e) => (e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Left fold with an index aware function, computed
--   sequentially.
ifoldlS :: (Index ix, Source r e) => (a -> ix -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold with an index aware function, computed
--   sequentially.
ifoldrS :: (Index ix, Source r e) => (ix -> e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Monadic left fold.
foldlM :: (Index ix, Source r e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic right fold.
foldrM :: (Index ix, Source r e, Monad m) => (e -> a -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic left fold, that discards the result.
foldlM_ :: (Index ix, Source r e, Monad m) => (a -> e -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic right fold, that discards the result.
foldrM_ :: (Index ix, Source r e, Monad m) => (e -> a -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic left fold with an index aware function.
ifoldlM :: (Index ix, Source r e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic right fold with an index aware function.
ifoldrM :: (Index ix, Source r e, Monad m) => (ix -> e -> a -> m a) -> a -> Array r ix e -> m a

-- | <i>O(n)</i> - Monadic left fold with an index aware function, that
--   discards the result.
ifoldlM_ :: (Index ix, Source r e, Monad m) => (a -> ix -> e -> m a) -> a -> Array r ix e -> m ()

-- | <i>O(n)</i> - Monadic right fold with an index aware function, that
--   discards the result.
ifoldrM_ :: (Index ix, Source r e, Monad m) => (ix -> e -> a -> m a) -> a -> Array r ix e -> m ()

-- | Version of foldr that supports <tt>foldr/build</tt> list fusion
--   implemented by GHC.
foldrFB :: (Index ix, Source r e) => (e -> b -> b) -> b -> Array r ix e -> b

-- | <i>O(n)</i> - Left fold, computed sequentially with lazy accumulator.
lazyFoldlS :: (Index ix, Source r e) => (a -> e -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Right fold, computed sequentially with lazy accumulator.
lazyFoldrS :: (Index ix, Source r e) => (e -> a -> a) -> a -> Array r ix e -> a

-- | <i>O(n)</i> - Left fold, computed with respect of array's computation
--   strategy. Because we do potentially split the folding among many
--   threads, we also need a combining function and an accumulator for the
--   results. Depending on the number of threads being used, results can be
--   different, hence is the <a>MonadIO</a> constraint.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (flip (:)) [] $ makeArrayR D Seq (Sz1 6) id
--   [[5,4,3,2,1,0]]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (++) [] $ makeArrayR D Seq (Sz1 6) id
--   [5,4,3,2,1,0]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (flip (:)) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [[5,4],[3,2],[1,0]]
--   
--   &gt;&gt;&gt; foldlP (flip (:)) [] (++) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [1,0,3,2,5,4]
--   </pre>
foldlP :: (MonadIO m, Index ix, Source r e) => (a -> e -> a) -> a -> (b -> a -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Right fold, computed with respect to computation
--   strategy. Same as <a>foldlP</a>, except directed from the last element
--   in the array towards beginning.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; foldrP (:) [] (++) [] $ makeArrayR D (ParN 2) (Sz2 2 3) fromIx2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   
--   &gt;&gt;&gt; foldrP (:) [] (:) [] $ makeArrayR D Seq (Sz1 6) id
--   [[0,1,2,3,4,5]]
--   
--   &gt;&gt;&gt; foldrP (:) [] (:) [] $ makeArrayR D (ParN 3) (Sz1 6) id
--   [[0,1],[2,3],[4,5]]
--   </pre>
foldrP :: (MonadIO m, Index ix, Source r e) => (e -> a -> a) -> a -> (a -> b -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Left fold with an index aware function, computed in
--   parallel. Just like <a>foldlP</a>, except that folding function will
--   receive an index of an element it is being applied to.
ifoldlP :: (MonadIO m, Index ix, Source r e) => (a -> ix -> e -> a) -> a -> (b -> a -> b) -> b -> Array r ix e -> m b

-- | <i>O(n)</i> - Right fold with an index aware function, while
--   respecting the computation strategy. Same as <a>ifoldlP</a>, except
--   directed from the last element in the array towards beginning, but
--   also row-major.
ifoldrP :: (MonadIO m, Index ix, Source r e) => (ix -> e -> a -> a) -> a -> (a -> b -> b) -> b -> Array r ix e -> m b

-- | Similar to <a>ifoldlP</a>, except that folding functions themselves do
--   live in IO
ifoldlIO :: (MonadUnliftIO m, Index ix, Source r e) => (a -> ix -> e -> m a) -> a -> (b -> a -> m b) -> b -> Array r ix e -> m b

-- | Similar to <a>ifoldrP</a>, except that folding functions themselves do
--   live in IO
ifoldrIO :: (MonadUnliftIO m, Index ix, Source r e) => (ix -> e -> a -> m a) -> a -> (a -> b -> m b) -> b -> Array r ix e -> m b

-- | Transpose a 2-dimensional array
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayLinearR D Seq (Sz (2 :. 3)) id
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (2 :. 3))
--     [ [ 0, 1, 2 ]
--     , [ 3, 4, 5 ]
--     ]
--   
--   &gt;&gt;&gt; transpose arr
--   Array D Seq (Sz (3 :. 2))
--     [ [ 0, 3 ]
--     , [ 1, 4 ]
--     , [ 2, 5 ]
--     ]
--   </pre>
transpose :: forall r e. Source r e => Matrix r e -> Matrix D e

-- | Transpose inner two dimensions of at least rank-2 array.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayLinearR U Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; transposeInner arr
--   Array D Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 12, 13, 14, 15 ]
--       ]
--     , [ [ 4, 5, 6, 7 ]
--       , [ 16, 17, 18, 19 ]
--       ]
--     , [ [ 8, 9, 10, 11 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   </pre>
transposeInner :: forall r ix e. (Index (Lower ix), Index ix, Source r e) => Array r ix e -> Array D ix e

-- | Transpose outer two dimensions of at least rank-2 array.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @U Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; transposeOuter arr
--   Array D Seq (Sz (2 :&gt; 4 :. 3))
--     [ [ [ 0, 4, 8 ]
--       , [ 1, 5, 9 ]
--       , [ 2, 6, 10 ]
--       , [ 3, 7, 11 ]
--       ]
--     , [ [ 12, 16, 20 ]
--       , [ 13, 17, 21 ]
--       , [ 14, 18, 22 ]
--       , [ 15, 19, 23 ]
--       ]
--     ]
--   </pre>
transposeOuter :: forall r ix e. (Index (Lower ix), Index ix, Source r e) => Array r ix e -> Array D ix e

-- | Reverse an array along some dimension. Dimension supplied is checked
--   at compile time.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = makeArrayLinear Seq (Sz2 4 5) (+10) :: Array D Ix2 Int
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 10, 11, 12, 13, 14 ]
--     , [ 15, 16, 17, 18, 19 ]
--     , [ 20, 21, 22, 23, 24 ]
--     , [ 25, 26, 27, 28, 29 ]
--     ]
--   
--   &gt;&gt;&gt; A.reverse Dim1 arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 14, 13, 12, 11, 10 ]
--     , [ 19, 18, 17, 16, 15 ]
--     , [ 24, 23, 22, 21, 20 ]
--     , [ 29, 28, 27, 26, 25 ]
--     ]
--   
--   &gt;&gt;&gt; A.reverse Dim2 arr
--   Array D Seq (Sz (4 :. 5))
--     [ [ 25, 26, 27, 28, 29 ]
--     , [ 20, 21, 22, 23, 24 ]
--     , [ 15, 16, 17, 18, 19 ]
--     , [ 10, 11, 12, 13, 14 ]
--     ]
--   </pre>
reverse :: forall n r ix e. (IsIndexDimension ix n, Index ix, Source r e) => Dimension n -> Array r ix e -> Array D ix e

-- | Reverse an array along some dimension. Same as <a>reverseM</a>, but
--   throws the <a>IndexDimensionException</a> from pure code.
reverse' :: forall r ix e. (HasCallStack, Index ix, Source r e) => Dim -> Array r ix e -> Array D ix e

-- | Similarly to <a>reverse</a>, flip an array along a particular
--   dimension, but throws <a>IndexDimensionException</a> for an incorrect
--   dimension.
reverseM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Dim -> Array r ix e -> m (Array D ix e)

-- | Rearrange elements of an array into a new one by using a function that
--   maps indices of the newly created one into the old one. This function
--   can throw <a>IndexOutOfBoundsException</a>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; arr = makeArrayLinear @D Seq (Sz (2 :&gt; 3 :. 4)) id
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (2 :&gt; 3 :. 4))
--     [ [ [ 0, 1, 2, 3 ]
--       , [ 4, 5, 6, 7 ]
--       , [ 8, 9, 10, 11 ]
--       ]
--     , [ [ 12, 13, 14, 15 ]
--       , [ 16, 17, 18, 19 ]
--       , [ 20, 21, 22, 23 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; backpermuteM @U (Sz (4 :. 2)) (\(i :. j) -&gt; j :&gt; j :. i) arr
--   Array U Seq (Sz (4 :. 2))
--     [ [ 0, 16 ]
--     , [ 1, 17 ]
--     , [ 2, 18 ]
--     , [ 3, 19 ]
--     ]
--   </pre>
backpermuteM :: forall r ix e r' ix' m. (Manifest r e, Index ix, Source r' e, Index ix', MonadUnliftIO m, PrimMonad m, MonadThrow m) => Sz ix -> (ix -> ix') -> Array r' ix' e -> m (Array r ix e)

-- | Similar to <a>backpermuteM</a>, with a few notable differences:
--   
--   <ul>
--   <li>Creates a delayed array, instead of manifest, therefore it can be
--   fused</li>
--   <li>Respects computation strategy, so it can be parallelized</li>
--   <li>Throws a runtime <a>IndexOutOfBoundsException</a> from pure
--   code.</li>
--   </ul>
backpermute' :: forall r ix ix' e. (HasCallStack, Source r e, Index ix, Index ix') => Sz ix' -> (ix' -> ix) -> Array r ix e -> Array D ix' e

-- | <i>O(1)</i> - Change the size of an array. Throws
--   <a>SizeElementsMismatchException</a> if total number of elements does
--   not match the supplied array.
resizeM :: forall r ix ix' e m. (MonadThrow m, Index ix', Index ix, Size r) => Sz ix' -> Array r ix e -> m (Array r ix' e)

-- | Same as <a>resizeM</a>, but will throw an error if supplied dimensions
--   are incorrect.
resize' :: forall r ix ix' e. (HasCallStack, Index ix', Index ix, Size r) => Sz ix' -> Array r ix e -> Array r ix' e

-- | <i>O(1)</i> - Reduce a multi-dimensional array into a flat vector
flatten :: forall r ix e. (Index ix, Size r) => Array r ix e -> Vector r e

-- | Extract a sub-array from within a larger source array. Array that is
--   being extracted must be fully encapsulated in a source array,
--   otherwise <a>SizeSubregionException</a> will be thrown.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; m &lt;- resizeM (Sz (3 :. 3)) $ Ix1 1 ... 9
--   
--   &gt;&gt;&gt; m
--   Array D Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; extractM (0 :. 1) (Sz (2 :. 2)) m
--   Array D Seq (Sz (2 :. 2))
--     [ [ 2, 3 ]
--     , [ 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; a &lt;- resizeM (Sz (3 :&gt; 2 :. 4)) $ Ix1 11 ... 34
--   
--   &gt;&gt;&gt; a
--   Array D Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ 11, 12, 13, 14 ]
--       , [ 15, 16, 17, 18 ]
--       ]
--     , [ [ 19, 20, 21, 22 ]
--       , [ 23, 24, 25, 26 ]
--       ]
--     , [ [ 27, 28, 29, 30 ]
--       , [ 31, 32, 33, 34 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; extractM (0 :&gt; 1 :. 1) (Sz (3 :&gt; 1 :. 2)) a
--   Array D Seq (Sz (3 :&gt; 1 :. 2))
--     [ [ [ 16, 17 ]
--       ]
--     , [ [ 24, 25 ]
--       ]
--     , [ [ 32, 33 ]
--       ]
--     ]
--   </pre>
extractM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => ix -> Sz ix -> Array r ix e -> m (Array D ix e)

-- | Same as <a>extractM</a>, but will throw a runtime exception from pure
--   code if supplied dimensions are incorrect.
extract' :: forall r ix e. (HasCallStack, Index ix, Source r e) => ix -> Sz ix -> Array r ix e -> Array D ix e

-- | Similar to <a>extractM</a>, except it takes starting and ending index.
--   Result array will not include the ending index.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;- resizeM (Sz (3 :&gt; 2 :. 4)) $ Ix1 11 ... 34
--   
--   &gt;&gt;&gt; a
--   Array D Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ 11, 12, 13, 14 ]
--       , [ 15, 16, 17, 18 ]
--       ]
--     , [ [ 19, 20, 21, 22 ]
--       , [ 23, 24, 25, 26 ]
--       ]
--     , [ [ 27, 28, 29, 30 ]
--       , [ 31, 32, 33, 34 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; extractFromToM (1 :&gt; 0 :. 1) (3 :&gt; 2 :. 4) a
--   Array D Seq (Sz (2 :&gt; 2 :. 3))
--     [ [ [ 20, 21, 22 ]
--       , [ 24, 25, 26 ]
--       ]
--     , [ [ 28, 29, 30 ]
--       , [ 32, 33, 34 ]
--       ]
--     ]
--   </pre>
extractFromToM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => ix -> ix -> Array r ix e -> m (Array D ix e)

-- | Same as <a>extractFromToM</a>, but throws an error on invalid indices.
extractFromTo' :: forall r ix e. (HasCallStack, Index ix, Source r e) => ix -> ix -> Array r ix e -> Array D ix e

-- | Similar to <a>deleteRegionM</a>, but drop a specified number of rows
--   from an array that has at least 2 dimensions.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx2 &lt;$&gt; (0 :. 0 ..: 3 :. 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (1,0), (1,1), (1,2), (1,3), (1,4), (1,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   
--   &gt;&gt;&gt; deleteRowsM 1 1 arr
--   Array DL Seq (Sz (2 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   </pre>
deleteRowsM :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Similar to <a>deleteRegionM</a>, but drop a specified number of
--   columns an array.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx2 &lt;$&gt; (0 :. 0 ..: 3 :. 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 6))
--     [ [ (0,0), (0,1), (0,2), (0,3), (0,4), (0,5) ]
--     , [ (1,0), (1,1), (1,2), (1,3), (1,4), (1,5) ]
--     , [ (2,0), (2,1), (2,2), (2,3), (2,4), (2,5) ]
--     ]
--   
--   &gt;&gt;&gt; deleteColumnsM 2 3 arr
--   Array DL Seq (Sz (3 :. 3))
--     [ [ (0,0), (0,1), (0,5) ]
--     , [ (1,0), (1,1), (1,5) ]
--     , [ (2,0), (2,1), (2,5) ]
--     ]
--   </pre>
deleteColumnsM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Delete a region from an array along the specified dimension.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = fromIx3 &lt;$&gt; (0 :&gt; 0 :. 0 ..: 3 :&gt; 2 :. 6)
--   
--   &gt;&gt;&gt; deleteRegionM 1 2 3 arr
--   Array DL Seq (Sz (3 :&gt; 2 :. 3))
--     [ [ [ (0,0,0), (0,0,1), (0,0,5) ]
--       , [ (0,1,0), (0,1,1), (0,1,5) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,5) ]
--       , [ (1,1,0), (1,1,1), (1,1,5) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,5) ]
--       , [ (2,1,0), (2,1,1), (2,1,5) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; v = Ix1 0 ... 10
--   
--   &gt;&gt;&gt; deleteRegionM 1 3 5 v
--   Array DL Seq (Sz1 6)
--     [ 0, 1, 2, 8, 9, 10 ]
--   </pre>
deleteRegionM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Dim -> Ix1 -> Sz Ix1 -> Array r ix e -> m (Array DL ix e)

-- | Append two arrays together along the outer most dimension. Inner
--   dimensions must agree, otherwise <a>SizeMismatchException</a>.
appendOuterM :: forall ix e m. (Index ix, MonadThrow m) => Array DL ix e -> Array DL ix e -> m (Array DL ix e)

-- | Append two arrays together along a particular dimension. Sizes of both
--   arrays must match, with an allowed exception of the dimension they are
--   being appended along, otherwise <a>Nothing</a> is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   Append two 2D arrays along both dimensions. Note that they do agree on
--   inner dimensions.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arrA = makeArrayR U Seq (Sz2 2 3) (\(i :. j) -&gt; ('A', i, j))
--   
--   &gt;&gt;&gt; arrB = makeArrayR U Seq (Sz2 2 3) (\(i :. j) -&gt; ('B', i, j))
--   
--   &gt;&gt;&gt; appendM 1 arrA arrB
--   Array DL Seq (Sz (2 :. 6))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2), ('B',0,0), ('B',0,1), ('B',0,2) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2), ('B',1,0), ('B',1,1), ('B',1,2) ]
--     ]
--   
--   &gt;&gt;&gt; appendM 2 arrA arrB
--   Array DL Seq (Sz (4 :. 3))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2) ]
--     , [ ('B',0,0), ('B',0,1), ('B',0,2) ]
--     , [ ('B',1,0), ('B',1,1), ('B',1,2) ]
--     ]
--   </pre>
--   
--   Now appending arrays with different sizes:
--   
--   <pre>
--   &gt;&gt;&gt; arrC = makeArrayR U Seq (Sz (2 :. 4)) (\(i :. j) -&gt; ('C', i, j))
--   
--   &gt;&gt;&gt; appendM 1 arrA arrC
--   Array DL Seq (Sz (2 :. 7))
--     [ [ ('A',0,0), ('A',0,1), ('A',0,2), ('C',0,0), ('C',0,1), ('C',0,2), ('C',0,3) ]
--     , [ ('A',1,0), ('A',1,1), ('A',1,2), ('C',1,0), ('C',1,1), ('C',1,2), ('C',1,3) ]
--     ]
--   
--   &gt;&gt;&gt; appendM 2 arrA arrC
--   *** Exception: SizeMismatchException: (Sz (2 :. 3)) vs (Sz (2 :. 4))
--   </pre>
appendM :: forall r1 r2 ix e m. (MonadThrow m, Index ix, Source r1 e, Source r2 e) => Dim -> Array r1 ix e -> Array r2 ix e -> m (Array DL ix e)

-- | Same as <a>appendM</a>, but will throw an exception in pure code on
--   mismatched sizes.
append' :: forall r1 r2 ix e. (HasCallStack, Index ix, Source r1 e, Source r2 e) => Dim -> Array r1 ix e -> Array r2 ix e -> Array DL ix e

-- | Concat arrays together along the outer most dimension. Inner
--   dimensions must agree for all arrays in the list, otherwise
--   <a>SizeMismatchException</a>.
concatOuterM :: forall ix e m. (Index ix, MonadThrow m) => [Array DL ix e] -> m (Array DL ix e)

-- | Concatenate many arrays together along some dimension. It is important
--   that all sizes are equal, with an exception of the dimensions along
--   which concatenation happens.
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeMismatchException</a>
concatM :: forall r ix e f m. (MonadThrow m, Foldable f, Index ix, Source r e) => Dim -> f (Array r ix e) -> m (Array DL ix e)

-- | Concat many arrays together along some dimension.
concat' :: forall f r ix e. (HasCallStack, Foldable f, Index ix, Source r e) => Dim -> f (Array r ix e) -> Array DL ix e

-- | Stack slices on top of each other along the specified dimension.
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   Here are the three different ways to stack up two 2D Matrix pages into
--   a 3D array.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; y = compute (iterateN 3 succ 9) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; y
--   Array P Seq (Sz (3 :. 3))
--     [ [ 10, 11, 12 ]
--     , [ 13, 14, 15 ]
--     , [ 16, 17, 18 ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 1 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (3 :&gt; 3 :. 2))
--     [ [ [ 1, 10 ]
--       , [ 2, 11 ]
--       , [ 3, 12 ]
--       ]
--     , [ [ 4, 13 ]
--       , [ 5, 14 ]
--       , [ 6, 15 ]
--       ]
--     , [ [ 7, 16 ]
--       , [ 8, 17 ]
--       , [ 9, 18 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 2 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (3 :&gt; 2 :. 3))
--     [ [ [ 1, 2, 3 ]
--       , [ 10, 11, 12 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       , [ 13, 14, 15 ]
--       ]
--     , [ [ 7, 8, 9 ]
--       , [ 16, 17, 18 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; stackSlicesM 3 [x, y] :: IO (Array DL Ix3 Int)
--   Array DL Seq (Sz (2 :&gt; 3 :. 3))
--     [ [ [ 1, 2, 3 ]
--       , [ 4, 5, 6 ]
--       , [ 7, 8, 9 ]
--       ]
--     , [ [ 10, 11, 12 ]
--       , [ 13, 14, 15 ]
--       , [ 16, 17, 18 ]
--       ]
--     ]
--   </pre>
stackSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Index (Lower ix), Source r e, Index ix) => Dim -> f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | Specialized <a>stackSlicesM</a> to handling stacking from the outside.
--   It is the inverse of <a>outerSlices</a>.
--   
--   <i><b>Exceptions</b></i>: <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example we stack vectors as row of a matrix from top to
--   bottom:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; rows = outerSlices x
--   
--   &gt;&gt;&gt; A.mapM_ print rows
--   Array P Seq (Sz1 3)
--     [ 1, 2, 3 ]
--   Array P Seq (Sz1 3)
--     [ 4, 5, 6 ]
--   Array P Seq (Sz1 3)
--     [ 7, 8, 9 ]
--   
--   &gt;&gt;&gt; stackOuterSlicesM rows :: IO (Matrix DL Int)
--   Array DL Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   </pre>
stackOuterSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Index (Lower ix), Source r e, Index ix) => f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | Specialized <a>stackSlicesM</a> to handling stacking from the inside.
--   It is the inverse of <a>innerSlices</a>.
--   
--   <i><b>Exceptions</b></i>: <a>SizeMismatchException</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   In this example we stack vectors as columns of a matrix from left to
--   right:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; x = compute (iterateN 3 succ 0) :: Matrix P Int
--   
--   &gt;&gt;&gt; x
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; columns = innerSlices x
--   
--   &gt;&gt;&gt; A.mapM_ print columns
--   Array D Seq (Sz1 3)
--     [ 1, 4, 7 ]
--   Array D Seq (Sz1 3)
--     [ 2, 5, 8 ]
--   Array D Seq (Sz1 3)
--     [ 3, 6, 9 ]
--   
--   &gt;&gt;&gt; stackInnerSlicesM columns :: IO (Matrix DL Int)
--   Array DL Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   </pre>
stackInnerSlicesM :: forall r ix e f m. (Foldable f, MonadThrow m, Index (Lower ix), Source r e, Index ix) => f (Array r (Lower ix) e) -> m (Array DL ix e)

-- | <i>O(1)</i> - Split an array into two at an index along a specified
--   dimension.
--   
--   <i>Related</i>: <a>splitAt'</a>, <a>splitExtractM</a>,
--   <a>sliceAt'</a>, <a>sliceAtM</a>
--   
--   <i><b>Exceptions</b></i>: <a>IndexDimensionException</a>,
--   <a>SizeSubregionException</a>
splitAtM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Dim -> Int -> Array r ix e -> m (Array D ix e, Array D ix e)

-- | <i>O(1)</i> - Split an array into two at an index along a specified
--   dimension. Throws an error for a wrong dimension or incorrect indices.
--   
--   <i>Related</i>: <a>splitAtM</a>, <a>splitExtractM</a>,
--   <a>sliceAt'</a>, <a>sliceAtM</a>
--   
--   <h4><b>Examples</b></h4>
splitAt' :: forall r ix e. (HasCallStack, Index ix, Source r e) => Dim -> Int -> Array r ix e -> (Array D ix e, Array D ix e)

-- | Split an array in three parts across some dimension
splitExtractM :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Dim -> Ix1 -> Sz Ix1 -> Array r ix e -> m (Array D ix e, Array D ix e, Array D ix e)

-- | Replace a slice of an array with another one
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz3 3 4 5) fromIx3
--   
--   &gt;&gt;&gt; arr' = makeArrayR U Seq (Sz3 3 4 5) (fromIx3 . liftIndex (* 100))
--   
--   &gt;&gt;&gt; replaceSlice 2 1 (arr' &lt;!&gt; (2, 3)) arr
--   Array DL Seq (Sz (3 :&gt; 4 :. 5))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4) ]
--       , [ (0,300,0), (0,300,100), (0,300,200), (0,300,300), (0,300,400) ]
--       , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4) ]
--       , [ (0,3,0), (0,3,1), (0,3,2), (0,3,3), (0,3,4) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3), (1,0,4) ]
--       , [ (100,300,0), (100,300,100), (100,300,200), (100,300,300), (100,300,400) ]
--       , [ (1,2,0), (1,2,1), (1,2,2), (1,2,3), (1,2,4) ]
--       , [ (1,3,0), (1,3,1), (1,3,2), (1,3,3), (1,3,4) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4) ]
--       , [ (200,300,0), (200,300,100), (200,300,200), (200,300,300), (200,300,400) ]
--       , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4) ]
--       , [ (2,3,0), (2,3,1), (2,3,2), (2,3,3), (2,3,4) ]
--       ]
--     ]
--   </pre>
replaceSlice :: forall r r' ix e m. (MonadThrow m, Source r e, Source r' e, Index ix, Index (Lower ix)) => Dim -> Ix1 -> Array r' (Lower ix) e -> Array r ix e -> m (Array DL ix e)

-- | Replace an outer slice of an array with another one
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz3 3 4 5) fromIx3
--   
--   &gt;&gt;&gt; arr' = makeArrayR U Seq (Sz3 3 4 5) (fromIx3 . liftIndex (* 100))
--   
--   &gt;&gt;&gt; replaceOuterSlice 1 (arr' !&gt; 2) arr
--   Array DL Seq (Sz (3 :&gt; 4 :. 5))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3), (0,0,4) ]
--       , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3), (0,1,4) ]
--       , [ (0,2,0), (0,2,1), (0,2,2), (0,2,3), (0,2,4) ]
--       , [ (0,3,0), (0,3,1), (0,3,2), (0,3,3), (0,3,4) ]
--       ]
--     , [ [ (200,0,0), (200,0,100), (200,0,200), (200,0,300), (200,0,400) ]
--       , [ (200,100,0), (200,100,100), (200,100,200), (200,100,300), (200,100,400) ]
--       , [ (200,200,0), (200,200,100), (200,200,200), (200,200,300), (200,200,400) ]
--       , [ (200,300,0), (200,300,100), (200,300,200), (200,300,300), (200,300,400) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3), (2,0,4) ]
--       , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3), (2,1,4) ]
--       , [ (2,2,0), (2,2,1), (2,2,2), (2,2,3), (2,2,4) ]
--       , [ (2,3,0), (2,3,1), (2,3,2), (2,3,3), (2,3,4) ]
--       ]
--     ]
--   </pre>
replaceOuterSlice :: forall r ix e m. (MonadThrow m, Index ix, Source r e, Load r (Lower ix) e) => Ix1 -> Array r (Lower ix) e -> Array r ix e -> m (Array DL ix e)

-- | Insert the same element into a <a>Load</a>able array according to the
--   supplied stride.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = iterateN (Sz2 3 2) succ (0 :: Int)
--   
--   &gt;&gt;&gt; arr
--   Array DL Seq (Sz (3 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     , [ 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; upsample 0 (Stride (2 :. 3)) arr
--   Array DL Seq (Sz (6 :. 6))
--     [ [ 1, 0, 0, 2, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     , [ 3, 0, 0, 4, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     , [ 5, 0, 0, 6, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; upsample 9 (Stride (1 :. 2)) arr
--   Array DL Seq (Sz (3 :. 4))
--     [ [ 1, 9, 2, 9 ]
--     , [ 3, 9, 4, 9 ]
--     , [ 5, 9, 6, 9 ]
--     ]
--   </pre>
upsample :: forall r ix e. Load r ix e => e -> Stride ix -> Array r ix e -> Array DL ix e

-- | Discard elements from the source array according to the stride.
downsample :: forall r ix e. (Source r e, Load r ix e) => Stride ix -> Array r ix e -> Array DL ix e

-- | Increaze the size of the array accoridng to the stride multiplier
--   while replicating the same element to fill the neighbors. It is
--   exactly the same as <a>zoomWithGrid</a>, but without the grid.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = resize' (Sz3 1 3 2) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (1 :&gt; 3 :. 2))
--     [ [ [ 1, 2 ]
--       , [ 3, 4 ]
--       , [ 5, 6 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; zoom (Stride (2 :&gt; 2 :. 3)) arr
--   Array DL Seq (Sz (2 :&gt; 6 :. 6))
--     [ [ [ 1, 1, 1, 2, 2, 2 ]
--       , [ 1, 1, 1, 2, 2, 2 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       ]
--     , [ [ 1, 1, 1, 2, 2, 2 ]
--       , [ 1, 1, 1, 2, 2, 2 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 3, 3, 3, 4, 4, 4 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       , [ 5, 5, 5, 6, 6, 6 ]
--       ]
--     ]
--   </pre>
zoom :: forall r ix e. (Index ix, Source r e) => Stride ix -> Array r ix e -> Array DL ix e

-- | Replicate each element of the array by a factor in stride along each
--   dimension and surround each such group with a box of supplied grid
--   value. It will essentially zoom up an array and create a grid around
--   each element from the original array. Very useful for zooming up
--   images to inspect individual pixels.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = resize' (Sz2 3 2) (Ix1 1 ... 6)
--   
--   &gt;&gt;&gt; arr
--   Array D Seq (Sz (3 :. 2))
--     [ [ 1, 2 ]
--     , [ 3, 4 ]
--     , [ 5, 6 ]
--     ]
--   
--   &gt;&gt;&gt; zoomWithGrid 0 (Stride (2 :. 3)) arr
--   Array DL Seq (Sz (10 :. 9))
--     [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 1, 1, 1, 0, 2, 2, 2, 0 ]
--     , [ 0, 1, 1, 1, 0, 2, 2, 2, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 3, 3, 3, 0, 4, 4, 4, 0 ]
--     , [ 0, 3, 3, 3, 0, 4, 4, 4, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 5, 5, 5, 0, 6, 6, 6, 0 ]
--     , [ 0, 5, 5, 5, 0, 6, 6, 6, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   </pre>
zoomWithGrid :: forall r ix e. (Index ix, Source r e) => e -> Stride ix -> Array r ix e -> Array DL ix e

-- | General array transformation, that forces computation and produces a
--   manifest array.
transformM :: forall r ix e r' ix' e' a m. (Manifest r e, Index ix, Source r' e', Index ix', MonadUnliftIO m, PrimMonad m, MonadThrow m) => (Sz ix' -> m (Sz ix, a)) -> (a -> (ix' -> m e') -> ix -> m e) -> Array r' ix' e' -> m (Array r ix e)

-- | General array transformation
transform' :: forall ix e r' ix' e' a. (HasCallStack, Source r' e', Index ix', Index ix) => (Sz ix' -> (Sz ix, a)) -> (a -> (ix' -> e') -> ix -> e) -> Array r' ix' e' -> Array D ix e

-- | Same as <a>transformM</a>, but operates on two arrays
transform2M :: (Manifest r e, Index ix, Source r1 e1, Source r2 e2, Index ix1, Index ix2, MonadUnliftIO m, PrimMonad m, MonadThrow m) => (Sz ix1 -> Sz ix2 -> m (Sz ix, a)) -> (a -> (ix1 -> m e1) -> (ix2 -> m e2) -> ix -> m e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> m (Array r ix e)

-- | Same as <a>transform'</a>, but operates on two arrays
transform2' :: (HasCallStack, Source r1 e1, Source r2 e2, Index ix, Index ix1, Index ix2) => (Sz ix1 -> Sz ix2 -> (Sz ix, a)) -> (a -> (ix1 -> e1) -> (ix2 -> e2) -> ix -> e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> Array D ix e

-- | <i>O(1)</i> - Slices the array from the outside. For 2-dimensional
--   array this will be equivalent of taking a row. Throws an error when
--   index is out of bounds.
--   
--   <h3><b>Examples</b></h3>
--   
--   You could say that slicing from outside is synonymous to slicing from
--   the end or slicing at the highermost dimension. For example with
--   rank-3 arrays outer slice would be equivalent to getting a page:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (3 :&gt; 2 :. 4)) fromIx3
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (3 :&gt; 2 :. 4))
--     [ [ [ (0,0,0), (0,0,1), (0,0,2), (0,0,3) ]
--       , [ (0,1,0), (0,1,1), (0,1,2), (0,1,3) ]
--       ]
--     , [ [ (1,0,0), (1,0,1), (1,0,2), (1,0,3) ]
--       , [ (1,1,0), (1,1,1), (1,1,2), (1,1,3) ]
--       ]
--     , [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3) ]
--       , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; arr !&gt; 2
--   Array U Seq (Sz (2 :. 4))
--     [ [ (2,0,0), (2,0,1), (2,0,2), (2,0,3) ]
--     , [ (2,1,0), (2,1,1), (2,1,2), (2,1,3) ]
--     ]
--   </pre>
--   
--   There is nothing wrong with chaining, mixing and matching slicing
--   operators:
--   
--   <pre>
--   &gt;&gt;&gt; arr !&gt; 2 !&gt; 0 ! 3
--   (2,0,3)
--   
--   &gt;&gt;&gt; evaluateM (arr !&gt; 2 &lt;! 3) 0
--   (2,0,3)
--   
--   &gt;&gt;&gt; (arr !&gt; 2 !&gt; 0 ! 3) == (arr ! 2 :&gt; 0 :. 3)
--   True
--   </pre>
(!>) :: forall r ix e. (HasCallStack, Index ix, Index (Lower ix), Source r e) => Array r ix e -> Int -> Array r (Lower ix) e
infixl 4 !>

-- | <i>O(1)</i> - Just like <a>!&gt;</a> slices the array from the
--   outside, but returns <a>Nothing</a> when index is out of bounds.
(!?>) :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => Array r ix e -> Int -> m (Array r (Lower ix) e)
infixl 4 !?>

-- | <i>O(1)</i> - Safe slicing continuation from the outside. Similarly to
--   (<a>!&gt;</a>) slices the array from the outside, but takes
--   <a>Maybe</a> array as input and returns <a>Nothing</a> when index is
--   out of bounds.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (3 :&gt; 2 :. 4)) fromIx3
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; 0 ?? 3 :: Maybe Ix3T
--   Just (2,0,3)
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; 0 ?? -1 :: Maybe Ix3T
--   Nothing
--   
--   &gt;&gt;&gt; arr !?&gt; 2 ??&gt; -10 ?? 1
--   *** Exception: IndexOutOfBoundsException: -10 is not safe for (Sz1 2)
--   </pre>
(??>) :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => m (Array r ix e) -> Int -> m (Array r (Lower ix) e)
infixl 4 ??>

-- | <i>O(1)</i> - Similarly to (<a>!&gt;</a>) slice an array from an
--   opposite direction.
(<!) :: forall r ix e. (HasCallStack, Index ix, Source r e) => Array r ix e -> Int -> Array D (Lower ix) e
infixl 4 <!

-- | <i>O(1)</i> - Safe slice from the inside
(<!?) :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => Array r ix e -> Int -> m (Array D (Lower ix) e)
infixl 4 <!?

-- | <i>O(1)</i> - Safe slicing continuation from the inside
(<??) :: forall r ix e m. (MonadThrow m, Index ix, Source r e) => m (Array r ix e) -> Int -> m (Array D (Lower ix) e)
infixl 4 <??

-- | <i>O(1)</i> - Slices the array in any available dimension. Throws an
--   error when index is out of bounds or dimensions is invalid.
(<!>) :: forall r ix e. (HasCallStack, Index ix, Index (Lower ix), Source r e) => Array r ix e -> (Dim, Int) -> Array D (Lower ix) e
infixl 4 <!>

-- | <i>O(1)</i> - Same as (<a>&lt;!&gt;</a>), but fails gracefully with a
--   <a>Nothing</a>, instead of an error
(<!?>) :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => Array r ix e -> (Dim, Int) -> m (Array D (Lower ix) e)
infixl 4 <!?>

-- | <i>O(1)</i> - Safe slicing continuation from within.
(<??>) :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => m (Array r ix e) -> (Dim, Int) -> m (Array D (Lower ix) e)
infixl 4 <??>

-- | Create a delayed array of outer slices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.mapM_ print $ outerSlices (0 ..: (3 :. 2))
--   Array D Seq (Sz1 2)
--     [ 0 :. 0, 0 :. 1 ]
--   Array D Seq (Sz1 2)
--     [ 1 :. 0, 1 :. 1 ]
--   Array D Seq (Sz1 2)
--     [ 2 :. 0, 2 :. 1 ]
--   </pre>
outerSlices :: forall r ix e. (Index ix, Index (Lower ix), Source r e) => Array r ix e -> Array D Ix1 (Array r (Lower ix) e)

-- | Create a delayed array of inner slices.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; A.mapM_ print $ innerSlices (0 ..: (3 :. 2))
--   Array D Seq (Sz1 3)
--     [ 0 :. 0, 1 :. 0, 2 :. 0 ]
--   Array D Seq (Sz1 3)
--     [ 0 :. 1, 1 :. 1, 2 :. 1 ]
--   </pre>
innerSlices :: forall r ix e. (Index ix, Source r e) => Array r ix e -> Array D Ix1 (Array D (Lower ix) e)

-- | Create a delayed array of slices from within. Checks dimension at
--   compile time.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; arr = fromIx3 &lt;$&gt; (0 ..: (4 :&gt; 3 :. 2))
--   
--   &gt;&gt;&gt; print arr
--   Array D Seq (Sz (4 :&gt; 3 :. 2))
--     [ [ [ (0,0,0), (0,0,1) ]
--       , [ (0,1,0), (0,1,1) ]
--       , [ (0,2,0), (0,2,1) ]
--       ]
--     , [ [ (1,0,0), (1,0,1) ]
--       , [ (1,1,0), (1,1,1) ]
--       , [ (1,2,0), (1,2,1) ]
--       ]
--     , [ [ (2,0,0), (2,0,1) ]
--       , [ (2,1,0), (2,1,1) ]
--       , [ (2,2,0), (2,2,1) ]
--       ]
--     , [ [ (3,0,0), (3,0,1) ]
--       , [ (3,1,0), (3,1,1) ]
--       , [ (3,2,0), (3,2,1) ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; A.mapM_ print $ withinSlices Dim2 arr
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,0,0), (0,0,1) ]
--     , [ (1,0,0), (1,0,1) ]
--     , [ (2,0,0), (2,0,1) ]
--     , [ (3,0,0), (3,0,1) ]
--     ]
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,1,0), (0,1,1) ]
--     , [ (1,1,0), (1,1,1) ]
--     , [ (2,1,0), (2,1,1) ]
--     , [ (3,1,0), (3,1,1) ]
--     ]
--   Array D Seq (Sz (4 :. 2))
--     [ [ (0,2,0), (0,2,1) ]
--     , [ (1,2,0), (1,2,1) ]
--     , [ (2,2,0), (2,2,1) ]
--     , [ (3,2,0), (3,2,1) ]
--     ]
--   </pre>
withinSlices :: forall n r ix e. (IsIndexDimension ix n, Index (Lower ix), Source r e) => Dimension n -> Array r ix e -> Array D Ix1 (Array D (Lower ix) e)

-- | Create a delayed array of slices from within. Same as
--   <a>withinSlices</a>, but throws an error on invalid dimension.
--   
--   <i><b>Throws Exceptions</b></i>: <a>IndexDimensionException</a>
withinSlicesM :: forall r ix e m. (MonadThrow m, Index ix, Index (Lower ix), Source r e) => Dim -> Array r ix e -> m (Array D Ix1 (Array D (Lower ix) e))

-- | This is an implementation of <a>Quicksort</a>, which is an efficient,
--   but unstable sort. This implementation uses Median-of-three for pivot
--   choosing, as such it performs very well not only for random values,
--   but also for common edge cases like already sorted, reversed sorted
--   and arrays with many duplicate elements. It will also respect the
--   computation strategy and will result in a nice speed up for systems
--   with multiple CPUs.
quicksort :: (Manifest r e, Ord e) => Vector r e -> Vector r e

-- | Same as <a>quicksortBy</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortBy :: Manifest r e => (e -> e -> Ordering) -> Vector r e -> Vector r e

-- | Same as <a>quicksortBy</a>, but instead of <a>Ord</a> constraint
--   expects a custom <a>Ordering</a>.
quicksortByM :: (Manifest r e, MonadUnliftIO m) => (e -> e -> m Ordering) -> Vector r e -> m (Vector r e)

-- | Count number of occurrences of each element in the array. Results will
--   be sorted in ascending order of the element.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; xs = fromList Seq [2, 4, 3, 2, 4, 5, 2, 1] :: Array P Ix1 Int
--   
--   &gt;&gt;&gt; xs
--   Array P Seq (Sz1 8)
--     [ 2, 4, 3, 2, 4, 5, 2, 1 ]
--   
--   &gt;&gt;&gt; tally xs
--   Array DS Seq (Sz1 5)
--     [ (1,1), (2,3), (3,1), (4,2), (5,1) ]
--   </pre>
tally :: (Manifest r e, Load r ix e, Ord e) => Array r ix e -> Vector DS (e, Int)

-- | Efficiently iterate a function until a convergence condition is
--   satisfied. If the size of array doesn't change between iterations then
--   no more than two new arrays will be allocated, regardless of the
--   number of iterations. If the size does change from one iteration to
--   another, an attempt will be made to grow/shrink the intermediate
--   mutable array instead of allocating a new one.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; let arr = computeAs P $ makeLoadArrayS (Sz2 8 8) (0 :: Int) $ \ w -&gt; () &lt;$ w (0 :. 0) 1
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (8 :. 8))
--     [ [ 1, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 0, 0, 0, 0, 0, 0, 0, 0 ]
--     ]
--   
--   &gt;&gt;&gt; let nextPascalRow cur above = if cur == 0 then above else cur
--   
--   &gt;&gt;&gt; let pascal = makeStencil (Sz2 2 2) 1 $ \ get -&gt; nextPascalRow (get (0 :. 0)) (get (-1 :. -1) + get (-1 :. 0))
--   
--   &gt;&gt;&gt; iterateUntil (\_ _ a -&gt; (a ! (7 :. 7)) /= 0) (\ _ -&gt; mapStencil (Fill 0) pascal) arr
--   Array P Seq (Sz (8 :. 8))
--     [ [ 1, 0, 0, 0, 0, 0, 0, 0 ]
--     , [ 1, 1, 0, 0, 0, 0, 0, 0 ]
--     , [ 1, 2, 1, 0, 0, 0, 0, 0 ]
--     , [ 1, 3, 3, 1, 0, 0, 0, 0 ]
--     , [ 1, 4, 6, 4, 1, 0, 0, 0 ]
--     , [ 1, 5, 10, 10, 5, 1, 0, 0 ]
--     , [ 1, 6, 15, 20, 15, 6, 1, 0 ]
--     , [ 1, 7, 21, 35, 35, 21, 7, 1 ]
--     ]
--   </pre>
iterateUntil :: (Load r' ix e, Manifest r e, NFData (Array r ix e)) => (Int -> Array r ix e -> Array r ix e -> Bool) -> (Int -> Array r ix e -> Array r' ix e) -> Array r ix e -> Array r ix e

-- | Convert a flat list into a vector
fromList :: forall r e. Manifest r e => Comp -> [e] -> Vector r e

-- | <i>O(n)</i> - Convert a nested list into an array. Nested list must be
--   of a rectangular shape, otherwise a runtime error will occur. Also,
--   nestedness must match the rank of resulting array, which should be
--   specified through an explicit type signature.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; fromListsM Seq [[1,2,3],[4,5,6]] :: Maybe (Array U Ix2 Int)
--   Just (Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromListsM Par [[[1,2,3]],[[4,5,6]]] :: Maybe (Array U Ix3 Int)
--   Just (Array U Par (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 1, 2, 3 ]
--       ]
--     , [ [ 4, 5, 6 ]
--       ]
--     ]
--   )
--   </pre>
--   
--   Elements of a boxed array could be lists themselves if necessary, but
--   cannot be ragged:
--   
--   <pre>
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5]]] :: Maybe (Array B Ix2 [Int])
--   Just (Array B Seq (Sz (2 :. 1))
--     [ [ [1,2,3] ]
--     , [ [4,5] ]
--     ]
--   )
--   
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5]]] :: Maybe (Array B Ix3 Integer)
--   Nothing
--   
--   &gt;&gt;&gt; fromListsM Seq [[[1,2,3]],[[4,5,6],[7,8,9]]] :: IO (Array B Ix3 Integer)
--   *** Exception: DimTooLongException for (Dim 2): expected (Sz1 1), got (Sz1 2)
--   
--   &gt;&gt;&gt; fromListsM Seq [[1,2,3,4],[5,6,7]] :: IO (Matrix B Integer)
--   *** Exception: DimTooShortException for (Dim 1): expected (Sz1 4), got (Sz1 3)
--   </pre>
fromListsM :: forall r ix e m. (Ragged L ix e, Manifest r e, MonadThrow m) => Comp -> [ListItem ix e] -> m (Array r ix e)

-- | Same as <a>fromListsM</a>, but will throw an error on irregular shaped
--   lists.
--   
--   <b>Note</b>: This function is the same as if you would turn on <tt>{-#
--   LANGUAGE OverloadedLists #-}</tt> extension. For that reason you can
--   also use <a>fromList</a>.
--   
--   <pre>
--   \xs -&gt; fromLists' Seq xs == (fromList Seq xs :: Vector P Int)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert a list of lists into a 2D Array
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array as A
--   
--   &gt;&gt;&gt; fromLists' Seq [[1,2,3],[4,5,6]] :: Array U Ix2 Int
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   </pre>
--   
--   Above example implemented using GHC's <tt>OverloadedLists</tt>
--   extension:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; [[1,2,3],[4,5,6]] :: Array U Ix2 Int
--   Array U Seq (Sz (2 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     ]
--   </pre>
fromLists' :: forall r ix e. (HasCallStack, Ragged L ix e, Manifest r e) => Comp -> [ListItem ix e] -> Array r ix e

-- | Convert any array to a flat list.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; toList $ makeArrayR U Seq (Sz (2 :. 3)) fromIx2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   </pre>
toList :: (Index ix, Source r e) => Array r ix e -> [e]

-- | <i>O(n)</i> - Convert an array into a nested list. Number of array
--   dimensions and list nestedness will always match, but you can use
--   <a>toList</a>, <a>toLists2</a>, etc. if flattening of inner dimensions
--   is desired.
--   
--   <b>Note</b>: This function is almost the same as <a>toList</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; arr = makeArrayR U Seq (Sz (2 :&gt; 1 :. 3)) id
--   
--   &gt;&gt;&gt; arr
--   Array U Seq (Sz (2 :&gt; 1 :. 3))
--     [ [ [ 0 :&gt; 0 :. 0, 0 :&gt; 0 :. 1, 0 :&gt; 0 :. 2 ]
--       ]
--     , [ [ 1 :&gt; 0 :. 0, 1 :&gt; 0 :. 1, 1 :&gt; 0 :. 2 ]
--       ]
--     ]
--   
--   &gt;&gt;&gt; toLists arr
--   [[[0 :&gt; 0 :. 0,0 :&gt; 0 :. 1,0 :&gt; 0 :. 2]],[[1 :&gt; 0 :. 0,1 :&gt; 0 :. 1,1 :&gt; 0 :. 2]]]
--   </pre>
toLists :: (Ragged L ix e, Shape r ix, Source r e) => Array r ix e -> [ListItem ix e]

-- | Convert an array with at least 2 dimensions into a list of lists.
--   Inner dimensions will get flattened.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; toLists2 $ makeArrayR U Seq (Sz2 2 3) fromIx2
--   [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)]]
--   
--   &gt;&gt;&gt; toLists2 $ makeArrayR U Seq (Sz3 2 1 3) fromIx3
--   [[(0,0,0),(0,0,1),(0,0,2)],[(1,0,0),(1,0,1),(1,0,2)]]
--   </pre>
toLists2 :: (Source r e, Index ix, Index (Lower ix)) => Array r ix e -> [[e]]

-- | Convert an array with at least 3 dimensions into a 3 deep nested list.
--   Inner dimensions will get flattened.
toLists3 :: (Source r e, Index ix, Index (Lower ix), Index (Lower (Lower ix))) => Array r ix e -> [[[e]]]

-- | Convert an array with at least 4 dimensions into a 4 deep nested list.
--   Inner dimensions will get flattened.
toLists4 :: (Source r e, Index ix, Index (Lower ix), Index (Lower (Lower ix)), Index (Lower (Lower (Lower ix)))) => Array r ix e -> [[[[e]]]]


module Data.Massiv.Array.Unsafe

-- | Specify how an array can be loaded/computed through creation of a
--   <a>DL</a> array. Unlike <a>makeLoadArrayS</a> or <a>makeLoadArray</a>
--   this function is unsafe, since there is no guarantee that all elements
--   will be initialized and the supplied element writing function does not
--   perform any bounds checking.
unsafeMakeLoadArray :: forall ix e. Index ix => Comp -> Sz ix -> Maybe e -> (forall s. Scheduler s () -> Ix1 -> (Ix1 -> e -> ST s ()) -> ST s ()) -> Array DL ix e

-- | Same as <a>unsafeMakeLoadArray</a>, except will ensure that starting
--   index is correctly adjusted. Which means the writing function gets one
--   less argument.
unsafeMakeLoadArrayAdjusted :: forall ix e. Index ix => Comp -> Sz ix -> Maybe e -> (forall s. Scheduler s () -> (Ix1 -> e -> ST s ()) -> ST s ()) -> Array DL ix e

-- | <a>Sz</a> is the size of the array. It describes total number of
--   elements along each dimension in the array. It is a wrapper around an
--   index of the same dimension, however it provides type safety
--   preventing mixup with index. Moreover the <tt>Sz</tt> constructor and
--   others such as <a>Sz1</a>, <a>Sz2</a>, ... that are specialized to
--   specific dimensions, prevent creation of invalid sizes with negative
--   values by clamping them to zero.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3)
--   Sz (1 :&gt; 2 :. 3)
--   </pre>
--   
--   <a>Sz</a> has a <a>Num</a> instance, which is very convenient:
--   
--   <pre>
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3) + 5
--   Sz (6 :&gt; 7 :. 8)
--   </pre>
--   
--   However subtraction can sometimes lead to surprising behavior, because
--   size is not allowed to take negative values it will be clamped at 0.
--   
--   <pre>
--   &gt;&gt;&gt; Sz (1 :&gt; 2 :. 3) - 2
--   Sz (0 :&gt; 0 :. 1)
--   </pre>
--   
--   <b>Warning</b>: It is always wrong to <a>negate</a> a size, thus it
--   will result in an error. For that reason also watch out for partially
--   applied <tt>(<a>-</a> sz)</tt>, which is deugared into
--   <tt><a>negate</a> sz</tt>. See more info about it in <a>#114</a>.
newtype Sz ix

-- | Safe size constructor. It is unsafe to use it without making sure that
--   it does not contain negative components. Use <a>Sz</a> pattern
--   instead.
SafeSz :: ix -> Sz ix

-- | Stride provides a way to ignore elements of an array if an index is
--   divisible by a corresponding value in a stride. So, for a <tt>Stride
--   (i :. j)</tt> only elements with indices will be kept around:
--   
--   <pre>
--   ( 0 :. 0) ( 0 :. j) ( 0 :. 2j) ( 0 :. 3j) ...
--   ( i :. 0) ( i :. j) ( i :. 2j) ( i :. 3j) ...
--   (2i :. 0) (2i :. j) (2i :. 2j) (2i :. 3j) ...
--   ...
--   </pre>
--   
--   Only positive strides make sense, so <a>Stride</a> pattern synonym
--   constructor will prevent a user from creating a stride with negative
--   or zero values, thus promoting safety of the library.
--   
--   <h4><b>Examples:</b></h4>
--   
--   <ul>
--   <li>Default and minimal stride of <tt><a>Stride</a> (<a>pureIndex</a>
--   1)</tt> will have no affect and all elements will kept.</li>
--   </ul>
--   
--   <ul>
--   <li>If stride is <tt><a>Stride</a> 2</tt>, then every 2nd element
--   (i.e. with index 1, 3, 5, ..) will be skipped and only elemnts with
--   indices divisible by 2 will be kept around.</li>
--   <li>In case of two dimensions, if what you want is to keep all rows
--   divisible by 5, but keep every column intact then you'd use <tt>Stride
--   (5 :. 1)</tt>.</li>
--   </ul>
newtype Stride ix
SafeStride :: ix -> Stride ix

-- | Lookup element in the array. No bounds check is performed and access
--   of arbitrary memory is possible when invalid index is supplied.
unsafeIndex :: Source r e => Index ix => Array r ix e -> ix -> e

-- | Alternative indexing function that can choose an index that is most
--   efficient for underlying representation
unsafePrefIndex :: Source r e => Index ix => Array r ix e -> PrefIndex ix e

-- | Lookup element in the array using flat index in a row-major fashion.
--   No bounds check is performed
unsafeLinearIndex :: Source r e => Index ix => Array r ix e -> Int -> e
unsafeLinearIndexM :: (Manifest r e, Index ix) => Array r ix e -> Int -> e
unsafeBackpermute :: (Index ix', Source r' e, Index ix) => Sz ix -> (ix -> ix') -> Array r' ix' e -> Array D ix e

-- | <i>O(1)</i> - Change the size of an array. Total number of elements
--   should be the same, but it is not validated.
unsafeResize :: (Size r, Index ix, Index ix') => Sz ix' -> Array r ix e -> Array r ix' e

-- | <i>O(1)</i> - Extract a portion of an array. Staring index and new
--   size are not validated.
unsafeExtract :: (Source r e, Index ix) => ix -> Sz ix -> Array r ix e -> Array D ix e

-- | Same <a>transform'</a>, except no bounds checking is performed, thus
--   making it faster, but unsafe.
unsafeTransform :: (Index ix', Source r' e', Index ix) => (Sz ix' -> (Sz ix, a)) -> (a -> (ix' -> e') -> ix -> e) -> Array r' ix' e' -> Array D ix e

-- | Same <a>transform2'</a>, except no bounds checking is performed, thus
--   making it faster, but unsafe.
unsafeTransform2 :: (Index ix1, Source r1 e1, Index ix2, Source r2 e2, Index ix) => (Sz ix1 -> Sz ix2 -> (Sz ix, a)) -> (a -> (ix1 -> e1) -> (ix2 -> e2) -> ix -> e) -> Array r1 ix1 e1 -> Array r2 ix2 e2 -> Array D ix e

-- | <i>O(1)</i> - Take a slice out of an array from within
unsafeSlice :: (Source r e, Index ix, Index (Lower ix), MonadThrow m) => Array r ix e -> ix -> Sz ix -> Dim -> m (Array D (Lower ix) e)

-- | <i>O(1)</i> - Take a slice out of an array from the outside
unsafeOuterSlice :: Source r e => (Index ix, Index (Lower ix)) => Array r ix e -> Sz (Lower ix) -> Int -> Array r (Lower ix) e

-- | <i>O(1)</i> - Take a slice out of an array from the inside
unsafeInnerSlice :: (Source r e, Index ix) => Array r ix e -> Sz (Lower ix) -> Int -> Array D (Lower ix) e

-- | <i>O(1)</i> - Source arrays also give us ability to look at their
--   linear slices in constant time
unsafeLinearSlice :: (Source r e, Index ix) => Ix1 -> Sz1 -> Array r ix e -> Array r Ix1 e

-- | <i>O(1)</i> - Change the size of a mutable array. The actual number of
--   elements should stay the same.
unsafeResizeMArray :: (Manifest r e, Index ix', Index ix) => Sz ix' -> MArray s r ix e -> MArray s r ix' e

-- | <i>O(1)</i> - Take a linear slice out of a mutable array.
unsafeLinearSliceMArray :: (Manifest r e, Index ix) => Ix1 -> Sz1 -> MArray s r ix e -> MVector s r e

-- | Convert immutable array into a mutable array without copy.
unsafeThaw :: (Manifest r e, Index ix, PrimMonad m) => Array r ix e -> m (MArray (PrimState m) r ix e)

-- | Convert mutable array into an immutable array without copy.
unsafeFreeze :: (Manifest r e, Index ix, PrimMonad m) => Comp -> MArray (PrimState m) r ix e -> m (Array r ix e)

-- | Create new mutable array, leaving it's elements uninitialized. Size
--   isn't validated either.
unsafeNew :: (Manifest r e, Index ix, PrimMonad m) => Sz ix -> m (MArray (PrimState m) r ix e)

-- | Load into a supplied mutable array sequentially. Returned array does
--   not have to be the same.
unsafeLoadIntoST :: (Load r ix e, Manifest r' e) => MVector s r' e -> Array r ix e -> ST s (MArray s r' ix e)

-- | Same as <a>unsafeLoadIntoST</a>, but respecting computation strategy.
unsafeLoadIntoIO :: (Load r ix e, Manifest r' e) => MVector RealWorld r' e -> Array r ix e -> IO (MArray RealWorld r' ix e)

-- | Load into a supplied mutable vector sequentially. Returned array is
--   not necesserally the same vector as the one that was supplied. It will
--   be the same only if it had enough space to load all the elements in.
unsafeLoadIntoS :: forall r r' ix e m s. (Load r ix e, Manifest r' e, MonadPrim s m) => MVector s r' e -> Array r ix e -> m (MArray s r' ix e)

-- | Same as <a>unsafeLoadIntoS</a>, but respecting computation strategy.
unsafeLoadIntoM :: forall r r' ix e m. (Load r ix e, Manifest r' e, MonadIO m) => MVector RealWorld r' e -> Array r ix e -> m (MArray RealWorld r' ix e)

-- | Same as <a>createArray</a>, but memory will not be initialized and for
--   unboxed types might contain garbage.
unsafeCreateArray :: forall r ix e a m b. (Manifest r e, Index ix, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler RealWorld a -> MArray RealWorld r ix e -> m b) -> m ([a], Array r ix e)

-- | Same as <a>createArray_</a>, but memory will not be initialized and
--   for unboxed types might contain garbage.
unsafeCreateArray_ :: forall r ix e a m b. (Manifest r e, Index ix, MonadUnliftIO m) => Comp -> Sz ix -> (Scheduler RealWorld a -> MArray RealWorld r ix e -> m b) -> m (Array r ix e)

-- | Same as <a>createArrayS</a>, but memory will not be initialized and
--   for unboxed types might contain garbage.
unsafeCreateArrayS :: forall r ix e a m. (Manifest r e, Index ix, PrimMonad m) => Sz ix -> (MArray (PrimState m) r ix e -> m a) -> m (a, Array r ix e)

-- | Read an array element
unsafeRead :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> m e

-- | Read an element at linear row-major index
unsafeLinearRead :: Manifest r e => (Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> m e

-- | Write an element into array
unsafeWrite :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> e -> m ()

-- | Write an element into mutable array with linear row-major index
unsafeLinearWrite :: Manifest r e => (Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> e -> m ()

-- | Modify an element in the array with a monadic action. Returns the
--   previous value.
unsafeModify :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> ix -> m e

-- | Modify an element in the array with a monadic action. Returns the
--   previous value.
unsafeLinearModify :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> (e -> m e) -> Int -> m e

-- | Swap two elements in a mutable array under the supplied indices.
--   Returns the previous values.
unsafeSwap :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> ix -> ix -> m (e, e)

-- | Swap two elements in a mutable array under the supplied linear
--   indices. Returns the previous values.
unsafeLinearSwap :: () => (Manifest r e, Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Int -> Int -> m (e, e)

-- | Set all cells in the mutable array within the range to a specified
--   value.
unsafeLinearSet :: Manifest r e => (Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> e -> m ()

-- | Copy part of one mutable array into another
unsafeLinearCopy :: Manifest r e => (Index ix', Index ix, PrimMonad m) => MArray (PrimState m) r ix' e -> Ix1 -> MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> m ()

-- | Copy a part of a pure array into a mutable array
unsafeArrayLinearCopy :: Manifest r e => (Index ix', Index ix, PrimMonad m) => Array r ix' e -> Ix1 -> MArray (PrimState m) r ix e -> Ix1 -> Sz1 -> m ()

-- | Linearly reduce the size of an array. Total number of elements should
--   be smaller or equal. There is no guarantee that the original array is
--   left unchanged, so it should no longer be used.
unsafeLinearShrink :: Manifest r e => (Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Sz ix -> m (MArray (PrimState m) r ix e)

-- | Linearly increase the size of an array. Total number of elements
--   should be larger or equal. There is no guarantee that the original
--   array is left unchanged, so it should no longer be used.
unsafeLinearGrow :: Manifest r e => (Index ix, PrimMonad m) => MArray (PrimState m) r ix e -> Sz ix -> m (MArray (PrimState m) r ix e)

-- | Allocate memory using <tt>malloc</tt> on C heap, instead of on Haskell
--   heap. Memory is left uninitialized
unsafeMallocMArray :: forall ix e m. (Index ix, Storable e, PrimMonad m) => Sz ix -> m (MArray (PrimState m) S ix e)

-- | A pointer to the beginning of the storable array. It is unsafe since,
--   if mutated, it can break referential transparency.
unsafeWithPtr :: MonadUnliftIO m => Array S ix e -> (Ptr e -> m b) -> m b

-- | <i>O(1)</i> - Yield the underlying <a>ForeignPtr</a> together with its
--   length.
unsafeArrayToForeignPtr :: Index ix => Array S ix e -> (ForeignPtr e, Int)

-- | <i>O(1)</i> - Yield the underlying <a>ForeignPtr</a> together with its
--   length.
unsafeMArrayToForeignPtr :: Index ix => MArray s S ix e -> (ForeignPtr e, Int)

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a>, an offset and it's size into a
--   pure storable array.
unsafeArrayFromForeignPtr :: Storable e => Comp -> ForeignPtr e -> Int -> Sz1 -> Array S Ix1 e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a> and it's size into a pure
--   storable array.
unsafeArrayFromForeignPtr0 :: Comp -> ForeignPtr e -> Sz1 -> Vector S e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a>, an offset and it's size into a
--   mutable storable array. It is still safe to modify the pointer, unless
--   the array gets frozen prior to modification.
unsafeMArrayFromForeignPtr :: Storable e => ForeignPtr e -> Int -> Sz1 -> MArray s S Ix1 e

-- | <i>O(1)</i> - Wrap a <a>ForeignPtr</a> and it's size into a mutable
--   storable array. It is still safe to modify the pointer, unless the
--   array gets frozen prior to modification.
unsafeMArrayFromForeignPtr0 :: ForeignPtr e -> Sz1 -> MArray s S Ix1 e

-- | Atomically read an <a>Int</a> element from the array
unsafeAtomicReadIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> m Int

-- | Atomically write an <a>Int</a> element int the array
unsafeAtomicWriteIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m ()

-- | Atomically modify an <a>Int</a> element of the array. Returns the old
--   value.
unsafeAtomicModifyIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> (Int -> Int) -> m Int

-- | Atomically add to an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicAddIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically subtract from an <a>Int</a> element in the array. Returns
--   the old value.
unsafeAtomicSubIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically AND an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicAndIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically NAND an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicNandIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically OR an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicOrIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically XOR an <a>Int</a> element in the array. Returns the old
--   value.
unsafeAtomicXorIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> m Int

-- | Atomically CAS an <a>Int</a> in the array. Returns the old value.
unsafeCasIntArray :: (Index ix, PrimMonad m) => MArray (PrimState m) P ix Int -> ix -> Int -> Int -> m Int

-- | <i>O(1)</i> - Cast a boxed lazy array. It is unsafe because it can
--   violate the invariant that all elements of <a>B</a> array are in WHNF.
coerceBoxedArray :: Array BL ix e -> Array B ix e

-- | <i>O(1)</i> - Cast a boxed lazy array. It is unsafe because it can
--   violate the invariant that all elements of <a>N</a> array are in NF.
coerceNormalBoxedArray :: Array BL ix e -> Array N ix e

-- | Partition a segment of a vector. Starting and ending indices are
--   unchecked.
unsafeUnstablePartitionRegionM :: forall r e m. (Manifest r e, PrimMonad m) => MVector (PrimState m) r e -> (e -> m Bool) -> Ix1 -> Ix1 -> m Ix1

unsafeHead :: Source r e => Vector r e -> e

unsafeLast :: Source r e => Vector r e -> e

unsafeIndexM :: (Source r e, Monad m) => Vector r e -> Ix1 -> m e

unsafeHeadM :: (Monad m, Source r e) => Vector r e -> m e

unsafeLastM :: (Monad m, Source r e) => Vector r e -> m e

unsafeInit :: Source r e => Vector r e -> Vector r e

unsafeTail :: Source r e => Vector r e -> Vector r e

unsafeTake :: Source r e => Sz1 -> Vector r e -> Vector r e

unsafeDrop :: Source r e => Sz1 -> Vector r e -> Vector r e

-- | <i>O(n)</i> - Right unfolding function with at most <tt>n</tt> number
--   of elements.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of when unfolding function returns a <a>Nothing</a>.
--   Supplying <tt>n</tt> that is too big will result in an asynchronous
--   <a>HeapOverflow</a> exception.
unsafeUnfoldrN :: Sz1 -> (s -> Maybe (e, s)) -> s -> Vector DS e

-- | <i>O(n)</i> - Same as <a>unsafeUnfoldrN</a>, but with monadic
--   generating function.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of when unfolding function returns a <a>Nothing</a>.
--   Supplying <tt>n</tt> that is too big will result in an asynchronous
--   <a>HeapOverflow</a> exception.
unsafeUnfoldrNM :: Monad m => Sz1 -> (s -> m (Maybe (e, s))) -> s -> m (Vector DS e)

-- | <i>O(n)</i> - Convert a list of a known length to a delayed stream
--   vector.
--   
--   <i>Unsafe</i> - This function is unsafe because it will allocate
--   enough space in memory for <tt>n</tt> elements ahead of time,
--   regardless of the actual size of the list. Supplying <tt>n</tt> that
--   is too big will result in an asynchronous <a>HeapOverflow</a>
--   exception.
unsafeFromListN :: Sz1 -> [e] -> Vector DS e

-- | Similar to <a>makeStencil</a>, but there are no guarantees that the
--   stencil will not read out of bounds memory. This stencil is also a bit
--   more powerful in sense it gets an extra peice of information, namely
--   the exact index for the element it is constructing.
makeUnsafeStencil :: Index ix => Sz ix -> ix -> (ix -> (ix -> e) -> a) -> Stencil ix e a

-- | Same as <a>makeConvolutionStencil</a>, but will result in reading
--   memory out of bounds and potential segfaults if supplied arguments are
--   not valid.
makeUnsafeConvolutionStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Same as <a>makeCorrelationStencil</a>, but will result in reading
--   memory out of bounds and potential segfaults if supplied arguments are
--   not valid.
makeUnsafeCorrelationStencil :: (Index ix, Num e) => Sz ix -> ix -> ((ix -> e -> e -> e) -> e -> e) -> Stencil ix e e

-- | Perform an arbitrary transformation of a stencil. This stencil
--   modifier can be used for example to turn a vector stencil into a
--   matrix stencil implement, or transpose a matrix stencil. It is really
--   easy to get this wrong, so be extremely careful.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert a 1D stencil into a row or column 2D stencil:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Massiv.Array
--   
--   &gt;&gt;&gt; import Data.Massiv.Array.Unsafe
--   
--   &gt;&gt;&gt; let arr = compute $ iterateN 3 succ 0 :: Array P Ix2 Int
--   
--   &gt;&gt;&gt; arr
--   Array P Seq (Sz (3 :. 3))
--     [ [ 1, 2, 3 ]
--     , [ 4, 5, 6 ]
--     , [ 7, 8, 9 ]
--     ]
--   
--   &gt;&gt;&gt; let rowStencil = unsafeTransformStencil (\(Sz n) -&gt; Sz (1 :. n)) (0 :.) $ \ f uget getVal (i :. j) -&gt; f (uget  . (i :.)) (getVal . (i :.)) j
--   
--   &gt;&gt;&gt; applyStencil noPadding (rowStencil (sumStencil (Sz1 3))) arr
--   Array DW Seq (Sz (3 :. 1))
--     [ [ 6 ]
--     , [ 15 ]
--     , [ 24 ]
--     ]
--   
--   &gt;&gt;&gt; let columnStencil = unsafeTransformStencil (\(Sz n) -&gt; Sz (n :. 1)) (:. 0) $ \ f uget getVal (i :. j) -&gt; f (uget . (:. j)) (getVal . (:. j)) i
--   
--   &gt;&gt;&gt; applyStencil noPadding (columnStencil (sumStencil (Sz1 3))) arr
--   Array DW Seq (Sz (1 :. 3))
--     [ [ 12, 15, 18 ]
--     ]
--   </pre>
unsafeTransformStencil :: (Sz ix' -> Sz ix) -> (ix' -> ix) -> (((ix' -> e) -> (ix' -> e) -> ix' -> a) -> (ix -> e) -> (ix -> e) -> ix -> a) -> Stencil ix' e a -> Stencil ix e a

-- | The array family. Representations <tt>r</tt> describe how data is
--   arranged or computed. All arrays have a common property that each
--   index <tt>ix</tt> always maps to the same unique element <tt>e</tt>,
--   even if that element does not yet exist in memory and the array has to
--   be computed in order to get the value of that element. Data is always
--   arranged in a nested row-major fashion. Rank of an array is specified
--   by <tt><a>Dimensions</a> ix</tt>.
data family Array r ix e :: Type

-- | Mutable version of a <a>Manifest</a> <a>Array</a>. The extra type
--   argument <tt>s</tt> is for the state token used by <a>IO</a> and
--   <a>ST</a>.
data family MArray s r ix e :: Type


module Data.Massiv.Array.Numeric.Integral

-- | Use midpoint rule to approximate an integral.
midpointRule :: (Fractional e, StrideLoad DW ix e, Manifest r e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array D ix e

-- | <b>Midpoint Rule</b>
--   
--   &lt;math&gt;
midpointStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Use trapezoid rule to approximate an integral.
trapezoidRule :: (Fractional e, StrideLoad DW ix e, Manifest r e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array D ix e

-- | <b>Trapezoid Rule</b>
--   
--   &lt;math&gt;
trapezoidStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Use Simpson's rule to approximate an integral.
simpsonsRule :: (Fractional e, StrideLoad DW ix e, Manifest r e) => Comp -> r -> ((Int -> e) -> ix -> e) -> e -> e -> Sz ix -> Int -> Array D ix e

-- | <b>Simpson's Rule</b>
--   
--   &lt;math&gt;
simpsonsStencil :: (Fractional e, Index ix) => e -> Dim -> Int -> Stencil ix e e

-- | Integrate with a stencil along a particular dimension.
integrateWith :: (Fractional e, StrideLoad DW ix e, Manifest r e) => (Dim -> Int -> Stencil ix e e) -> Dim -> Int -> Array r ix e -> Array r ix e

-- | Compute an approximation of integral using a supplied rule in a form
--   of <a>Stencil</a>.
integralApprox :: (Fractional e, StrideLoad DW ix e, Manifest r e) => (e -> Dim -> Int -> Stencil ix e e) -> e -> Sz ix -> Int -> Array r ix e -> Array D ix e

-- | Create an array from a function with sample points at the edges
--   
--   <pre>
--   &gt;&gt;&gt; fromFunction Seq (\ scale (i :. j) -&gt; scale i + scale j :: Double) (-2) 1 (Sz 4) 2
--   Array D Seq (Sz (9 :. 9))
--     [ [ -4.0, -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0 ]
--     , [ -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5 ]
--     , [ -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0 ]
--     , [ -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5 ]
--     , [ -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0 ]
--     , [ -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5 ]
--     , [ -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 ]
--     , [ -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5 ]
--     , [ 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0 ]
--     ]
--   </pre>
fromFunction :: (Index ix, Fractional a) => Comp -> ((Int -> a) -> ix -> e) -> a -> a -> Sz ix -> Int -> Array D ix e

-- | Similar to <a>fromFunction</a>, but will create an array from a
--   function with sample points in the middle of cells.
--   
--   <pre>
--   &gt;&gt;&gt; fromFunctionMidpoint Seq (\ scale (i :. j) -&gt; scale i + scale j :: Double) (-2) 1 (Sz 4) 2
--   Array D Seq (Sz (8 :. 8))
--     [ [ -3.5, -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0 ]
--     , [ -3.0, -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5 ]
--     , [ -2.5, -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0 ]
--     , [ -2.0, -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5 ]
--     , [ -1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0 ]
--     , [ -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5 ]
--     , [ -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0 ]
--     , [ 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5 ]
--     ]
--   </pre>
fromFunctionMidpoint :: (Index ix, Fractional a) => Comp -> ((Int -> a) -> ix -> e) -> a -> a -> Sz ix -> Int -> Array D ix e
