-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-codebase-sqlite
@version 0.0.0

module U.Codebase.Sqlite.DbId
newtype HashVersion
HashVersion :: Word64 -> HashVersion
newtype ObjectId
ObjectId :: Word64 -> ObjectId
newtype TextId
TextId :: Word64 -> TextId
newtype HashId
HashId :: Word64 -> HashId
newtype PatchObjectId
PatchObjectId :: ObjectId -> PatchObjectId
[$sel:unPatchObjectId:PatchObjectId] :: PatchObjectId -> ObjectId
newtype BranchObjectId
BranchObjectId :: ObjectId -> BranchObjectId
[$sel:unBranchObjectId:BranchObjectId] :: BranchObjectId -> ObjectId
newtype BranchHashId
BranchHashId :: HashId -> BranchHashId
[$sel:unBranchHashId:BranchHashId] :: BranchHashId -> HashId
newtype CausalHashId
CausalHashId :: HashId -> CausalHashId
[$sel:unCausalHashId:CausalHashId] :: CausalHashId -> HashId
newtype ProjectBranchId
ProjectBranchId :: UUID -> ProjectBranchId
[$sel:unProjectBranchId:ProjectBranchId] :: ProjectBranchId -> UUID
newtype ProjectId
ProjectId :: UUID -> ProjectId
[$sel:unProjectId:ProjectId] :: ProjectId -> UUID
newtype RemoteProjectBranchId
RemoteProjectBranchId :: Text -> RemoteProjectBranchId
[$sel:unRemoteProjectBranchId:RemoteProjectBranchId] :: RemoteProjectBranchId -> Text
newtype RemoteProjectId
RemoteProjectId :: Text -> RemoteProjectId
[$sel:unRemoteProjectId:RemoteProjectId] :: RemoteProjectId -> Text
newtype SchemaVersion
SchemaVersion :: Word64 -> SchemaVersion
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.HashVersion
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Real.Real U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Num.Num U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.HashVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.HashVersion
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.ObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.ObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.TextId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.TextId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.TextId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.TextId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.TextId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.TextId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.TextId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.HashId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.HashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.HashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.HashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.HashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.HashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.HashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.PatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.PatchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchObjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.BranchHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.CausalHashId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.ProjectBranchId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.ProjectBranchId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.ProjectBranchId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.ProjectBranchId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.ProjectBranchId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.ProjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.ProjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.ProjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.ProjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.ProjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.RemoteProjectBranchId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.RemoteProjectBranchId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.RemoteProjectBranchId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.RemoteProjectBranchId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.RemoteProjectBranchId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.RemoteProjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.RemoteProjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.RemoteProjectId
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.RemoteProjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.RemoteProjectId
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.DbId.SchemaVersion
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Bits.Bits U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Integral U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Enum.Enum U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Real.Real U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Num.Num U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Classes.Eq U.Codebase.Sqlite.DbId.SchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.DbId.CausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchHashId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.BranchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.DbId.PatchObjectId

module U.Codebase.Sqlite.Causal
type DbCausal = GDbCausal CausalHashId BranchHashId
data GDbCausal causalHash valueHash
DbCausal :: causalHash -> valueHash -> Set causalHash -> GDbCausal causalHash valueHash
[$sel:selfHash:DbCausal] :: GDbCausal causalHash valueHash -> causalHash
[$sel:valueHash:DbCausal] :: GDbCausal causalHash valueHash -> valueHash
[$sel:parents:DbCausal] :: GDbCausal causalHash valueHash -> Set causalHash
type SyncCausalFormat = SyncCausalFormat' CausalHashId BranchHashId
data SyncCausalFormat' causalHash valueHash
SyncCausalFormat :: valueHash -> Vector causalHash -> SyncCausalFormat' causalHash valueHash
[$sel:valueHash:SyncCausalFormat] :: SyncCausalFormat' causalHash valueHash -> valueHash
[$sel:parents:SyncCausalFormat] :: SyncCausalFormat' causalHash valueHash -> Vector causalHash

module U.Codebase.Sqlite.LocalIds

-- | A mapping between index ids that are local to an object and the ids in
--   the database
data LocalIds' t h
LocalIds :: Vector t -> Vector h -> LocalIds' t h
[$sel:textLookup:LocalIds] :: LocalIds' t h -> Vector t
[$sel:defnLookup:LocalIds] :: LocalIds' t h -> Vector h
type LocalIds = LocalIds' TextId ObjectId
type WatchLocalIds = LocalIds' TextId HashId

-- | represents an index into a textLookup
newtype LocalTextId
LocalTextId :: Word64 -> LocalTextId

-- | represents an index into a defnLookup
--   
--   In this context, "definition" means an object that is either a term
--   component or a (type) decl component, not a patch, namespace, or any
--   other kind of object.
newtype LocalDefnId
LocalDefnId :: Word64 -> LocalDefnId

-- | a local index to a hash, used when the corresponding object is allowed
--   to be absent
newtype LocalHashId
LocalHashId :: Word64 -> LocalHashId
newtype LocalPatchObjectId
LocalPatchObjectId :: Word64 -> LocalPatchObjectId
newtype LocalBranchChildId
LocalBranchChildId :: Word64 -> LocalBranchChildId

-- | causal hashes are treated differently from HashIds, which don't have
--   dependencies
newtype LocalCausalHashId
LocalCausalHashId :: Word64 -> LocalCausalHashId
t_ :: Traversal (LocalIds' t h) (LocalIds' t' h) t t'
h_ :: Traversal (LocalIds' t h) (LocalIds' t h') h h'
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.LocalIds.LocalIds' t h)
instance GHC.Base.Functor (U.Codebase.Sqlite.LocalIds.LocalIds' t)
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalTextId
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalDefnId
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalHashId
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalPatchObjectId
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalBranchChildId
instance GHC.Bits.Bits U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Integral U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Enum.Enum U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Real.Real U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Num.Num U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Show.Show U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Ord U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance GHC.Classes.Eq U.Codebase.Sqlite.LocalIds.LocalCausalHashId
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.LocalIds.LocalIds'
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.LocalIds.LocalIds'

module U.Codebase.Sqlite.Branch.Full

-- | <pre>
--   Branch
--     { terms :: Map LocalTextId (Map LocalReferent LocalMetadataSet),
--       types :: Map LocalTextId (Map LocalReference LocalMetadataSet),
--       patches :: Map LocalTextId LocalPatchObjectId,
--       children :: Map LocalTextId LocalBranchChildId
--     }
--   </pre>
type LocalBranch = Branch' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId

-- | <pre>
--   Branch
--     { terms :: Map TextId (Map Referent DbMetadataSet),
--       types :: Map TextId (Map Reference DbMetadataSet),
--       patches :: Map TextId PatchObjectId,
--       children :: Map TextId (BranchObjectId, CausalHashId)
--     }
--   </pre>
type DbBranch = Branch' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
type DbBranchV3 = GBranchV3 TextId ObjectId (BranchObjectId, CausalHashId)
type HashBranch = Branch' Text ComponentHash PatchHash (BranchHash, CausalHash)
type Referent'' t h = Referent' (TermReference' t h) (TypeReference' t h)
data Branch' t h p c
Branch :: !Map t (Map (Referent'' t h) (MetadataSetFormat' t h)) -> !Map t (Map (TypeReference' t h) (MetadataSetFormat' t h)) -> !Map t p -> !Map t c -> Branch' t h p c
[$sel:terms:Branch] :: Branch' t h p c -> !Map t (Map (Referent'' t h) (MetadataSetFormat' t h))
[$sel:types:Branch] :: Branch' t h p c -> !Map t (Map (TypeReference' t h) (MetadataSetFormat' t h))
[$sel:patches:Branch] :: Branch' t h p c -> !Map t p
[$sel:children:Branch] :: Branch' t h p c -> !Map t c

-- | A V3 branch; see U.Codebase.BranchV3
data GBranchV3 t h c
BranchV3 :: !Map t c -> !Map t (Referent'' t h) -> !Map t (TypeReference' t h) -> GBranchV3 t h c
[$sel:children:BranchV3] :: GBranchV3 t h c -> !Map t c
[$sel:terms:BranchV3] :: GBranchV3 t h c -> !Map t (Referent'' t h)
[$sel:types:BranchV3] :: GBranchV3 t h c -> !Map t (TypeReference' t h)
emptyBranch :: Branch' t h p c
branchHashes_ :: (Ord h', Ord t, Ord h) => Traversal (Branch' t h p c) (Branch' t h' p c) h h'
patches_ :: Traversal (Branch' t h p c) (Branch' t h p' c) p p'
childrenHashes_ :: Traversal (Branch' t h p c) (Branch' t h p c') c c'
branchCausalHashes_ :: Traversal (Branch' t h p c) (Branch' t h p c') c c'
type LocalMetadataSet = MetadataSetFormat' LocalTextId LocalDefnId
type DbMetadataSet = MetadataSetFormat' TextId ObjectId
data MetadataSetFormat' t h
Inline :: Set (Reference' t h) -> MetadataSetFormat' t h
metadataSetFormatReferences_ :: (Ord t, Ord h, Ord h') => Traversal (MetadataSetFormat' t h) (MetadataSetFormat' t h') (Reference' t h) (Reference' t h')
quadmap :: forall t h p c t' h' p' c'. (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Branch' t h p c -> Branch' t' h' p' c'
quadmapM :: forall t h p c t' h' p' c' m. (Ord t', Ord h', Applicative m) => (t -> m t') -> (h -> m h') -> (p -> m p') -> (c -> m c') -> Branch' t h p c -> m (Branch' t' h' p' c')

-- | Traversal over text references in a branch
t_ :: (Ord t', Ord h) => Traversal (Branch' t h p c) (Branch' t' h p c) t t'

-- | Traversal over hash references in a branch
h_ :: (Ord t, Ord h') => Traversal (Branch' t h p c) (Branch' t h' p c) h h'

-- | Traversal over patch references in a branch
p_ :: (Ord t, Ord h) => Traversal (Branch' t h p c) (Branch' t h p' c) p p'

-- | Traversal over child references in a branch
c_ :: (Ord t, Ord h) => Traversal (Branch' t h p c) (Branch' t h p c') c c'
instance (GHC.Show.Show t, GHC.Show.Show c, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.GBranchV3 t h c)
instance GHC.Generics.Generic (U.Codebase.Sqlite.Branch.Full.GBranchV3 t h c)
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.MetadataSetFormat' t h)
instance GHC.Generics.Generic (U.Codebase.Sqlite.Branch.Full.Branch' t h p c)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Full.Branch' t h p c)

module U.Codebase.Sqlite.Branch.Diff
type LocalDiff = Diff' LocalTextId LocalDefnId LocalPatchObjectId LocalBranchChildId
type Diff = Diff' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
data DefinitionOp' r
RemoveDef :: DefinitionOp' r
AddDefWithMetadata :: Set r -> DefinitionOp' r
AlterDefMetadata :: AddRemove r -> DefinitionOp' r
data PatchOp' p
PatchRemove :: PatchOp' p
PatchAddReplace :: p -> PatchOp' p
data ChildOp' c
ChildRemove :: ChildOp' c
ChildAddReplace :: c -> ChildOp' c
type AddRemove a = Map a Bool
type LocalDefinitionOp = DefinitionOp' (Metadata LocalTextId LocalDefnId)
type LocalPatchOp = PatchOp' LocalPatchObjectId
type LocalChildOp = ChildOp' LocalBranchChildId
type DefinitionOp = DefinitionOp' (Metadata TextId ObjectId)
type PatchOp = PatchOp' PatchObjectId
type ChildOp = ChildOp' (BranchObjectId, CausalHashId)
addsRemoves :: AddRemove a -> ([a], [a])
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Diff' t h p c
Diff :: Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h))) -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h))) -> Map t (PatchOp' p) -> Map t (ChildOp' c) -> Diff' t h p c
[$sel:terms:Diff] :: Diff' t h p c -> Map t (Map (Referent'' t h) (DefinitionOp' (Metadata t h)))
[$sel:types:Diff] :: Diff' t h p c -> Map t (Map (Reference' t h) (DefinitionOp' (Metadata t h)))
[$sel:patches:Diff] :: Diff' t h p c -> Map t (PatchOp' p)
[$sel:children:Diff] :: Diff' t h p c -> Map t (ChildOp' c)
type Metadata t h = Reference' t h
quadmap :: (Ord t', Ord h') => (t -> t') -> (h -> h') -> (p -> p') -> (c -> c') -> Diff' t h p c -> Diff' t' h' p' c'
instance GHC.Show.Show p => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.PatchOp' p)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.PatchOp'
instance GHC.Show.Show c => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.ChildOp' c)
instance GHC.Base.Functor U.Codebase.Sqlite.Branch.Diff.ChildOp'
instance GHC.Show.Show r => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.DefinitionOp' r)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Diff.Diff' t h p c)

module U.Codebase.Sqlite.Branch.Format

-- | A <a>BranchFormat</a> is a deserialized namespace object
--   (<tt>object.bytes</tt>).
--   
--   you can use the exact same <a>BranchLocalIds</a> when converting
--   between <a>Full</a> and <a>BranchFormat'</a>
data BranchFormat' text defRef patchRef childRef branchRef
Full :: BranchLocalIds' text defRef patchRef childRef -> LocalBranch -> BranchFormat' text defRef patchRef childRef branchRef
Diff :: branchRef -> BranchLocalIds' text defRef patchRef childRef -> LocalDiff -> BranchFormat' text defRef patchRef childRef branchRef

-- | The <a>BranchFormat'</a> used to store a branch in Sqlite
type BranchFormat = BranchFormat' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId) BranchObjectId

-- | A BranchFormat which uses Hashes and Text for all its references, no
--   Ids which are specific to a particular codebase.
type HashBranchFormat = BranchFormat' Text ComponentHash PatchHash (BranchHash, CausalHash)

-- | A <a>BranchLocalIds</a> is a mapping between local ids (local to this
--   object) encoded as offsets, and actual database ids.
--   
--   For example, a <tt>branchTextLookup</tt> vector of <tt>[50, 74]</tt>
--   means "local id 0 corresponds to database text id 50, and local id 1
--   corresponds to database text id 74".
type BranchLocalIds = BranchLocalIds' TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
data BranchLocalIds' t d p c
LocalIds :: Vector t -> Vector d -> Vector p -> Vector c -> BranchLocalIds' t d p c
[$sel:branchTextLookup:LocalIds] :: BranchLocalIds' t d p c -> Vector t
[$sel:branchDefnLookup:LocalIds] :: BranchLocalIds' t d p c -> Vector d
[$sel:branchPatchLookup:LocalIds] :: BranchLocalIds' t d p c -> Vector p
[$sel:branchChildLookup:LocalIds] :: BranchLocalIds' t d p c -> Vector c
type HashBranchLocalIds = BranchLocalIds' Text ComponentHash PatchHash (BranchHash, CausalHash)
type SyncBranchFormat = SyncBranchFormat' BranchObjectId TextId ObjectId PatchObjectId (BranchObjectId, CausalHashId)
data SyncBranchFormat' parent text defn patch child
SyncFull :: BranchLocalIds' text defn patch child -> LocalBranchBytes -> SyncBranchFormat' parent text defn patch child
SyncDiff :: parent -> BranchLocalIds' text defn patch child -> LocalBranchBytes -> SyncBranchFormat' parent text defn patch child

-- | Bytes encoding a LocalBranch
newtype LocalBranchBytes
LocalBranchBytes :: ByteString -> LocalBranchBytes
localToDbBranch :: BranchLocalIds -> LocalBranch -> DbBranch
localToDbDiff :: BranchLocalIds -> LocalDiff -> Diff
localToHashBranch :: HashBranchLocalIds -> LocalBranch -> HashBranch
localToBranch :: (Ord t, Ord d) => BranchLocalIds' t d p c -> LocalBranch -> Branch' t d p c
instance (GHC.Show.Show t, GHC.Show.Show d, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Format.BranchLocalIds' t d p c)
instance (GHC.Show.Show text, GHC.Show.Show defRef, GHC.Show.Show patchRef, GHC.Show.Show childRef, GHC.Show.Show branchRef) => GHC.Show.Show (U.Codebase.Sqlite.Branch.Format.BranchFormat' text defRef patchRef childRef branchRef)
instance GHC.Classes.Ord U.Codebase.Sqlite.Branch.Format.LocalBranchBytes
instance GHC.Classes.Eq U.Codebase.Sqlite.Branch.Format.LocalBranchBytes
instance GHC.Show.Show U.Codebase.Sqlite.Branch.Format.LocalBranchBytes


-- | Types related to working with NameLookups. We define these low-level
--   types rather than use Path's because we don't have access to those
--   domain types given the package dependency tree.
module U.Codebase.Sqlite.NameLookups
newtype ReversedName
ReversedName :: NonEmpty Text -> ReversedName
newtype ReversedPath
ReversedPath :: [Text] -> ReversedPath
newtype PathSegments
PathSegments :: [Text] -> PathSegments

-- | A namespace rendered as a path, no leading <a>.</a> E.g. "base.data"
type NamespaceText = Text

-- | <pre>
--   &gt;&gt;&gt; reversedSegmentsToNamespaceText (["List", "data", "base"])
--   "base.data.List"
--   </pre>
reversedNameToNamespaceText :: ReversedName -> NamespaceText
reversedNameToPathSegments :: ReversedName -> PathSegments

-- | <pre>
--   &gt;&gt;&gt; pathSegmentsToText (PathSegments ["base", "data", "List"])
--   "base.data.List"
--   </pre>
pathSegmentsToText :: PathSegments -> Text

-- | <pre>
--   &gt;&gt;&gt; textToPathSegments "base.data.List"
--   PathSegments ["base","data","List"]
--   </pre>
textToPathSegments :: Text -> PathSegments
instance GHC.Show.Show U.Codebase.Sqlite.NameLookups.ReversedName
instance GHC.Classes.Ord U.Codebase.Sqlite.NameLookups.ReversedName
instance GHC.Classes.Eq U.Codebase.Sqlite.NameLookups.ReversedName
instance GHC.Show.Show U.Codebase.Sqlite.NameLookups.ReversedPath
instance GHC.Classes.Ord U.Codebase.Sqlite.NameLookups.ReversedPath
instance GHC.Classes.Eq U.Codebase.Sqlite.NameLookups.ReversedPath
instance GHC.Base.Monoid U.Codebase.Sqlite.NameLookups.PathSegments
instance GHC.Base.Semigroup U.Codebase.Sqlite.NameLookups.PathSegments
instance GHC.Show.Show U.Codebase.Sqlite.NameLookups.PathSegments
instance GHC.Classes.Ord U.Codebase.Sqlite.NameLookups.PathSegments
instance GHC.Classes.Eq U.Codebase.Sqlite.NameLookups.PathSegments
instance Witch.From.From U.Codebase.Sqlite.NameLookups.PathSegments [Data.Text.Internal.Text]
instance Witch.From.From [Data.Text.Internal.Text] U.Codebase.Sqlite.NameLookups.PathSegments
instance Witch.From.From U.Codebase.Sqlite.NameLookups.ReversedPath [Data.Text.Internal.Text]
instance Witch.From.From [Data.Text.Internal.Text] U.Codebase.Sqlite.NameLookups.ReversedPath
instance Witch.From.From U.Codebase.Sqlite.NameLookups.ReversedName (GHC.Base.NonEmpty Data.Text.Internal.Text)
instance Witch.From.From (GHC.Base.NonEmpty Data.Text.Internal.Text) U.Codebase.Sqlite.NameLookups.ReversedName
instance Witch.From.From U.Codebase.Sqlite.NameLookups.ReversedName [Data.Text.Internal.Text]

module U.Codebase.Sqlite.NamedRef
data ConstructorType
DataConstructor :: ConstructorType
EffectConstructor :: ConstructorType
data NamedRef ref
NamedRef :: ReversedName -> ref -> NamedRef ref
[$sel:reversedSegments:NamedRef] :: NamedRef ref -> ReversedName
[$sel:ref:NamedRef] :: NamedRef ref -> ref

-- | The new <tt>scoped</tt> name lookup format is different from the old
--   version.
--   
--   Specifically, the scoped format adds the <tt>lastNameSegment</tt> as
--   well as adding a trailing <a>.</a> to the db format of both the
--   namespace and reversed_name.
--   
--   This type has a ToRow instance of the form: [reversedName, namespace,
--   lastNameSegment] &lt;&gt; ref fields...
newtype ScopedRow ref
ScopedRow :: NamedRef ref -> ScopedRow ref
instance Data.Traversable.Traversable U.Codebase.Sqlite.NamedRef.NamedRef
instance Data.Foldable.Foldable U.Codebase.Sqlite.NamedRef.NamedRef
instance GHC.Base.Functor U.Codebase.Sqlite.NamedRef.NamedRef
instance GHC.Show.Show ref => GHC.Show.Show (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.ToRow.ToRow ref => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.NamedRef.ScopedRow ref)
instance Database.SQLite.Simple.ToRow.ToRow ref => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.FromRow.FromRow ref => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.NamedRef.NamedRef ref)
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.NamedRef.ConstructorType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.NamedRef.ConstructorType

module U.Codebase.Sqlite.ObjectType

-- | Don't reorder these, they are part of the database, and the ToField
--   and FromField implementation currently depends on the derived Enum
--   implementation.
data ObjectType
TermComponent :: ObjectType
DeclComponent :: ObjectType
Namespace :: ObjectType
Patch :: ObjectType
instance GHC.Enum.Enum U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Show.Show U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Ord U.Codebase.Sqlite.ObjectType.ObjectType
instance GHC.Classes.Eq U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.ObjectType.ObjectType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.ObjectType.ObjectType

module U.Codebase.Sqlite.Orphans
newtype AsSqlite a
AsSqlite :: a -> AsSqlite a
[$sel:fromSQLite:AsSqlite] :: AsSqlite a -> a
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Sqlite.Orphans.AsSqlite a)
instance Database.SQLite.Simple.ToField.ToField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.FromField.FromField U.Util.Base32Hex.Base32Hex
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Reference.Reference)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Referent.Referent)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Referent.Referent)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.Orphans.AsSqlite U.Codebase.Reference.Reference)
instance Database.SQLite.Simple.ToField.ToField (U.Codebase.Sqlite.Orphans.AsSqlite Unison.Hash.Hash)
instance Database.SQLite.Simple.FromField.FromField (U.Codebase.Sqlite.Orphans.AsSqlite Unison.Hash.Hash)
instance Database.SQLite.Simple.ToField.ToField U.Codebase.WatchKind.WatchKind
instance Database.SQLite.Simple.FromField.FromField U.Codebase.WatchKind.WatchKind
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Branch.Type.NamespaceStats
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Branch.Type.NamespaceStats
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reflog.Entry U.Codebase.Sqlite.DbId.CausalHashId Data.Text.Internal.Text)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reflog.Entry U.Codebase.Sqlite.DbId.CausalHashId Data.Text.Internal.Text)

module U.Codebase.Sqlite.Patch.TermEdit
type TermEdit = TermEdit' TextId ObjectId
type HashTermEdit = TermEdit' Text ComponentHash
type LocalTermEdit = TermEdit' LocalTextId LocalDefnId
type Referent' t h = Referent' (Reference' t h) (Reference' t h)
data TermEdit' t h
Replace :: Referent' t h -> Typing -> TermEdit' t h
Deprecate :: TermEdit' t h
_Replace :: Prism (TermEdit' t h) (TermEdit' t' h') (Referent' t h, Typing) (Referent' t' h', Typing)
h_ :: Traversal (TermEdit' t h) (TermEdit' t h') h h'
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
instance GHC.Show.Show U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Ord U.Codebase.Sqlite.Patch.TermEdit.Typing
instance GHC.Classes.Eq U.Codebase.Sqlite.Patch.TermEdit.Typing
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t h)
instance GHC.Base.Functor (U.Codebase.Sqlite.Patch.TermEdit.TermEdit' t)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TermEdit.TermEdit'

module U.Codebase.Sqlite.Patch.TypeEdit
type LocalTypeEdit = TypeEdit' LocalTextId LocalDefnId
type TypeEdit = TypeEdit' TextId ObjectId
type HashTypeEdit = TypeEdit' Text ComponentHash
data TypeEdit' t h
Replace :: Reference' t h -> TypeEdit' t h
Deprecate :: TypeEdit' t h
_Replace :: Prism (TypeEdit' t h) (TypeEdit' t' h') (Reference' t h) (Reference' t' h')
h_ :: Traversal (TypeEdit' t h) (TypeEdit' t h') h h'
instance (GHC.Show.Show t, GHC.Show.Show h) => GHC.Show.Show (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance GHC.Base.Functor (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit' t h)
instance Data.Bifunctor.Bifunctor U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bifoldable.Bifoldable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'
instance Data.Bitraversable.Bitraversable U.Codebase.Sqlite.Patch.TypeEdit.TypeEdit'

module U.Codebase.Sqlite.Patch.Full

-- | <pre>
--   LocalPatch
--     { termEdits :: Map ReferentH (Set TermEdit),
--       typeEdits :: Map ReferenceH (Set TypeEdit)
--     }
--   </pre>
type Patch = Patch' TextId HashId ObjectId

-- | A version of Patch' which can be used for hashing.
type HashPatch = Patch' Text ComponentHash ComponentHash

-- | <pre>
--   LocalPatch
--     { termEdits :: Map LocalReferentH (Set LocalTermEdit),
--       typeEdits :: Map LocalReferenceH (Set LocalTypeEdit)
--     }
--   </pre>
type LocalPatch = Patch' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)
data Patch' t h o
Patch :: Map (Referent'' t h) (Set (TermEdit' t o)) -> Map (Reference' t h) (Set (TypeEdit' t o)) -> Patch' t h o
[$sel:termEdits:Patch] :: Patch' t h o -> Map (Referent'' t h) (Set (TermEdit' t o))
[$sel:typeEdits:Patch] :: Patch' t h o -> Map (Reference' t h) (Set (TypeEdit' t o))
patchT_ :: (Ord t', Ord h, Ord o) => Traversal (Patch' t h o) (Patch' t' h o) t t'
patchH_ :: (Ord t, Ord h') => Traversal (Patch' t h o) (Patch' t h' o) h h'
patchO_ :: (Ord t, Ord o') => Traversal (Patch' t h o) (Patch' t h o') o o'
trimap :: (Ord t', Ord h', Ord o') => (t -> t') -> (h -> h') -> (o -> o') -> Patch' t h o -> Patch' t' h' o'

module U.Codebase.Sqlite.Patch.Diff
type PatchDiff = PatchDiff' TextId HashId ObjectId
type LocalPatchDiff = PatchDiff' LocalTextId LocalHashId LocalDefnId
type Referent'' t h = Referent' (Reference' t h) (Reference' t h)

-- | diff. = min. - sub.
data PatchDiff' t h d
PatchDiff :: Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> Map (Referent'' t h) (Set (TermEdit' t d)) -> Map (Reference' t h) (Set (TypeEdit' t d)) -> PatchDiff' t h d

-- | elements present in min. but absent in sub.
[$sel:addedTermEdits:PatchDiff] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[$sel:addedTypeEdits:PatchDiff] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))

-- | elements missing in min. but present in sub.
[$sel:removedTermEdits:PatchDiff] :: PatchDiff' t h d -> Map (Referent'' t h) (Set (TermEdit' t d))
[$sel:removedTypeEdits:PatchDiff] :: PatchDiff' t h d -> Map (Reference' t h) (Set (TypeEdit' t d))
trimap :: (Ord t', Ord h', Ord d') => (t -> t') -> (h -> h') -> (d -> d') -> PatchDiff' t h d -> PatchDiff' t' h' d'
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Ord t, GHC.Classes.Ord h, GHC.Classes.Ord d) => GHC.Classes.Ord (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)
instance (GHC.Classes.Eq t, GHC.Classes.Eq h, GHC.Classes.Eq d) => GHC.Classes.Eq (U.Codebase.Sqlite.Patch.Diff.PatchDiff' t h d)

module U.Codebase.Sqlite.Patch.Format
data PatchFormat
Full :: PatchLocalIds -> LocalPatch -> PatchFormat
Diff :: PatchObjectId -> PatchLocalIds -> LocalPatchDiff -> PatchFormat
type PatchLocalIds = PatchLocalIds' TextId HashId ObjectId
data PatchLocalIds' t h d
LocalIds :: Vector t -> Vector h -> Vector d -> PatchLocalIds' t h d
[$sel:patchTextLookup:LocalIds] :: PatchLocalIds' t h d -> Vector t
[$sel:patchHashLookup:LocalIds] :: PatchLocalIds' t h d -> Vector h
[$sel:patchDefnLookup:LocalIds] :: PatchLocalIds' t h d -> Vector d

-- | LocalIds type which can be used in hashing the Patch.
type HashPatchLocalIds = PatchLocalIds' Text ComponentHash ComponentHash
type SyncPatchFormat = SyncPatchFormat' PatchObjectId TextId HashId ObjectId
data SyncPatchFormat' parent text hash defn
SyncFull :: PatchLocalIds' text hash defn -> ByteString -> SyncPatchFormat' parent text hash defn

-- | p is the identity of the thing that the diff is relative to
SyncDiff :: parent -> PatchLocalIds' text hash defn -> ByteString -> SyncPatchFormat' parent text hash defn

-- | Apply a list of patch diffs to a patch, left to right.
applyPatchDiffs :: Patch -> [PatchDiff] -> Patch

-- | Type specialized version of <a>localToPatch'</a>.
localPatchToPatch :: PatchLocalIds -> LocalPatch -> Patch

-- | Generic version of <a>localPatchToPatch</a> that works with any
--   <a>PatchLocalIds'</a>.
localPatchToPatch' :: (Ord t, Ord h, Ord d) => PatchLocalIds' t h d -> Patch' LocalTextId LocalHashId LocalDefnId -> Patch' t h d
localPatchDiffToPatchDiff :: PatchLocalIds -> LocalPatchDiff -> PatchDiff
localPatchToHashPatch :: HashPatchLocalIds -> LocalPatch -> HashPatch

module U.Codebase.Sqlite.Project

-- | A project.
data Project
Project :: !ProjectId -> !ProjectName -> Project
[$sel:projectId:Project] :: Project -> !ProjectId
[$sel:name:Project] :: Project -> !ProjectName
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Project.Project
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Project.Project
instance GHC.Classes.Eq U.Codebase.Sqlite.Project.Project
instance GHC.Show.Show U.Codebase.Sqlite.Project.Project
instance GHC.Generics.Generic U.Codebase.Sqlite.Project.Project

module U.Codebase.Sqlite.ProjectBranch

-- | A project branch.
data ProjectBranch
ProjectBranch :: !ProjectId -> !ProjectBranchId -> !ProjectBranchName -> !Maybe ProjectBranchId -> ProjectBranch
[$sel:projectId:ProjectBranch] :: ProjectBranch -> !ProjectId
[$sel:branchId:ProjectBranch] :: ProjectBranch -> !ProjectBranchId
[$sel:name:ProjectBranch] :: ProjectBranch -> !ProjectBranchName
[$sel:parentBranchId:ProjectBranch] :: ProjectBranch -> !Maybe ProjectBranchId
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.ProjectBranch.ProjectBranch
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.ProjectBranch.ProjectBranch
instance GHC.Show.Show U.Codebase.Sqlite.ProjectBranch.ProjectBranch
instance GHC.Generics.Generic U.Codebase.Sqlite.ProjectBranch.ProjectBranch
instance GHC.Classes.Eq U.Codebase.Sqlite.ProjectBranch.ProjectBranch

module U.Codebase.Sqlite.ProjectReflog
data Entry project branch causal
Entry :: project -> branch -> UTCTime -> Maybe causal -> causal -> Text -> Entry project branch causal
[$sel:project:Entry] :: Entry project branch causal -> project
[$sel:branch:Entry] :: Entry project branch causal -> branch
[$sel:time:Entry] :: Entry project branch causal -> UTCTime
[$sel:fromRootCausalHash:Entry] :: Entry project branch causal -> Maybe causal
[$sel:toRootCausalHash:Entry] :: Entry project branch causal -> causal
[$sel:reason:Entry] :: Entry project branch causal -> Text
project_ :: Lens (Entry project branch causal) (Entry project' branch causal) project project'
branch_ :: Lens (Entry project branch causal) (Entry project branch' causal) branch branch'

-- | Both Project and Branch Ids are required to load a branch, so this is
--   often more useful.
projectAndBranch_ :: Lens (Entry project branch causal) (Entry project' branch' causal) (project, branch) (project', branch')
instance Data.Traversable.Traversable (U.Codebase.Sqlite.ProjectReflog.Entry project branch)
instance Data.Foldable.Foldable (U.Codebase.Sqlite.ProjectReflog.Entry project branch)
instance GHC.Base.Functor (U.Codebase.Sqlite.ProjectReflog.Entry project branch)
instance (GHC.Show.Show project, GHC.Show.Show branch, GHC.Show.Show causal) => GHC.Show.Show (U.Codebase.Sqlite.ProjectReflog.Entry project branch causal)
instance (GHC.Classes.Eq project, GHC.Classes.Eq branch, GHC.Classes.Eq causal) => GHC.Classes.Eq (U.Codebase.Sqlite.ProjectReflog.Entry project branch causal)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Sqlite.ProjectReflog.Entry U.Codebase.Sqlite.DbId.ProjectId U.Codebase.Sqlite.DbId.ProjectBranchId U.Codebase.Sqlite.DbId.CausalHashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Sqlite.ProjectReflog.Entry U.Codebase.Sqlite.DbId.ProjectId U.Codebase.Sqlite.DbId.ProjectBranchId U.Codebase.Sqlite.DbId.CausalHashId)

module U.Codebase.Sqlite.Reference
type Reference = Reference' TextId ObjectId
type TermReference = Reference
type TypeReference = Reference

-- | The name lookup table uses this because normalizing/denormalizing
--   hashes to ids is slower than we'd like when writing/reading the entire
--   name lookup table.
type TextReference = Reference' Text Base32Hex
type Id = Id' ObjectId
type TermReferenceId = Id
type TypeReferenceId = Id
type LocalReferenceH = Reference' LocalTextId LocalHashId
type LocalReference = Reference' LocalTextId LocalDefnId
type LocalId = Id' LocalDefnId
type ReferenceH = Reference' TextId HashId
type IdH = Id' HashId
referenceToRow :: (ToField t, ToField h) => Reference' t h -> [SQLData]
referenceFromRow' :: (FromField t, FromField h, Show t, Show h) => RowParser (Reference' t h)
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Reference.Reference
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Reference.Reference
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' Data.Text.Internal.Text U.Util.Base32Hex.Base32Hex)
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' U.Codebase.Sqlite.DbId.TextId U.Codebase.Sqlite.DbId.HashId)
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' Data.Text.Internal.Text U.Util.Base32Hex.Base32Hex)
instance Database.SQLite.Simple.ToField.ToField h => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Id' h)
instance Database.SQLite.Simple.FromField.FromField h => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Id' h)

module U.Codebase.Sqlite.Referent
type Referent = Referent' Reference Reference

-- | The name lookup table uses this because normalizing/denormalizing
--   hashes to ids is slower than we'd like when writing/reading the entire
--   name lookup table.
type TextReferent = Referent' TextReference TextReference
type ReferentH = Referent' ReferenceH ReferenceH
type Id = Id' ObjectId ObjectId
type LocalReferent = Referent' LocalReference LocalReference
type LocalReferentH = Referent' LocalReferenceH LocalReferenceH
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.Referent.Id
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.Referent.Id
instance Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Reference.Reference' t h) => Database.SQLite.Simple.ToRow.ToRow (U.Codebase.Referent.Referent' (U.Codebase.Reference.Reference' t h) (U.Codebase.Reference.Reference' t h))
instance Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Reference.Reference' t h) => Database.SQLite.Simple.FromRow.FromRow (U.Codebase.Referent.Referent' (U.Codebase.Reference.Reference' t h) (U.Codebase.Reference.Reference' t h))


-- | This module facilitates the creation of "localized" versions of
--   objects, suitable for storage.
--   
--   Localization is a stateful process in which the real database
--   identifiers contained within an object, e.g. <a>DbBranch</a>, are
--   canonicalized as local identifiers counting up from 0 in the order
--   they are encountered in the object. The association between real and
--   local identifier is captured in a vector, where the <tt>ith</tt> index
--   maps local identifier <tt>i</tt> to the real identifier it corresponds
--   to.
--   
--   For example, consider a branch object that refers to terms
--   <tt>#foo</tt> and <tt>#bar</tt>. In totally made-up syntax,
--   
--   <pre>
--   branch = {
--     terms = [#foo, #bar]
--   }
--   </pre>
--   
--   The localized version of this branch would be
--   
--   <pre>
--   branch = {
--     terms = [0, 1]
--   }
--   terms = [#foo, #bar]
--   </pre>
--   
--   where all terms, types, etc. within the <tt>branch</tt> structure
--   refer to offsets in the associated vectors.
module U.Codebase.Sqlite.LocalizeObject

-- | Localize a branch object.
localizeBranch :: DbBranch -> (BranchLocalIds, LocalBranch)

-- | Generalized form of <a>localizeBranch</a>.
localizeBranchG :: forall t d p c. (Ord t, Ord d, Ord p, Ord c) => Branch' t d p c -> (BranchLocalIds' t d p c, LocalBranch)

-- | Localize a patch object.
localizePatch :: Patch -> (PatchLocalIds, LocalPatch)
localizePatchG :: forall t h d. (Ord t, Ord h, Ord d) => Patch' t h d -> (PatchLocalIds' t h d, LocalPatch)
instance GHC.Generics.Generic (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)
instance (GHC.Show.Show t, GHC.Show.Show d, GHC.Show.Show p, GHC.Show.Show c) => GHC.Show.Show (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)
instance GHC.Generics.Generic (U.Codebase.Sqlite.LocalizeObject.LocalizePatchState t h d)
instance (GHC.Show.Show t, GHC.Show.Show h, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.LocalizeObject.LocalizePatchState t h d)
instance GHC.Classes.Ord t => U.Codebase.Sqlite.LocalizeObject.ContainsText t (U.Codebase.Sqlite.LocalizeObject.LocalizePatchState t h d)
instance GHC.Classes.Ord h => U.Codebase.Sqlite.LocalizeObject.ContainsHashes h (U.Codebase.Sqlite.LocalizeObject.LocalizePatchState t h d)
instance GHC.Classes.Ord d => U.Codebase.Sqlite.LocalizeObject.ContainsDefns d (U.Codebase.Sqlite.LocalizeObject.LocalizePatchState t h d)
instance GHC.Classes.Ord t => U.Codebase.Sqlite.LocalizeObject.ContainsText t (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)
instance GHC.Classes.Ord d => U.Codebase.Sqlite.LocalizeObject.ContainsDefns d (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)
instance GHC.Classes.Ord p => U.Codebase.Sqlite.LocalizeObject.ContainsPatches p (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)
instance GHC.Classes.Ord c => U.Codebase.Sqlite.LocalizeObject.ContainsBranches c (U.Codebase.Sqlite.LocalizeObject.LocalizeBranchState t d p c)

module U.Codebase.Sqlite.RemoteProject

-- | A remote project.
data RemoteProject
RemoteProject :: RemoteProjectId -> URI -> ProjectName -> RemoteProject
[$sel:projectId:RemoteProject] :: RemoteProject -> RemoteProjectId
[$sel:host:RemoteProject] :: RemoteProject -> URI
[$sel:name:RemoteProject] :: RemoteProject -> ProjectName
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.RemoteProject.RemoteProject
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.RemoteProject.RemoteProject
instance GHC.Show.Show U.Codebase.Sqlite.RemoteProject.RemoteProject
instance GHC.Generics.Generic U.Codebase.Sqlite.RemoteProject.RemoteProject

module U.Codebase.Sqlite.RemoteProjectBranch
data RemoteProjectBranch
RemoteProjectBranch :: RemoteProjectId -> RemoteProjectBranchId -> URI -> ProjectBranchName -> RemoteProjectBranch
[$sel:projectId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectId
[$sel:branchId:RemoteProjectBranch] :: RemoteProjectBranch -> RemoteProjectBranchId
[$sel:host:RemoteProjectBranch] :: RemoteProjectBranch -> URI
[$sel:name:RemoteProjectBranch] :: RemoteProjectBranch -> ProjectBranchName
instance Database.SQLite.Simple.FromRow.FromRow U.Codebase.Sqlite.RemoteProjectBranch.RemoteProjectBranch
instance Database.SQLite.Simple.ToRow.ToRow U.Codebase.Sqlite.RemoteProjectBranch.RemoteProjectBranch
instance GHC.Show.Show U.Codebase.Sqlite.RemoteProjectBranch.RemoteProjectBranch
instance GHC.Generics.Generic U.Codebase.Sqlite.RemoteProjectBranch.RemoteProjectBranch

module U.Codebase.Sqlite.Symbol
data Symbol
Symbol :: !Word64 -> !Text -> Symbol
instance GHC.Show.Show U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Ord U.Codebase.Sqlite.Symbol.Symbol
instance GHC.Classes.Eq U.Codebase.Sqlite.Symbol.Symbol
instance U.Core.ABT.Var.Var U.Codebase.Sqlite.Symbol.Symbol

module U.Codebase.Sqlite.Decl.Format

-- | Add new formats here
data DeclFormat' text defn
Decl :: LocallyIndexedComponent' text defn -> DeclFormat' text defn
type DeclFormat = DeclFormat' TextId ObjectId

-- | A DeclFormat which uses hash references instead of database ids.
type HashDeclFormat = DeclFormat' Text Hash32

-- | V1: Decls included <tt>Hash</tt>es inline V2: Instead of
--   <tt>Hash</tt>, we use a smaller index.
type LocallyIndexedComponent = LocallyIndexedComponent' TextId ObjectId
newtype LocallyIndexedComponent' t d
LocallyIndexedComponent :: Vector (LocalIds' t d, Decl Symbol) -> LocallyIndexedComponent' t d
[$sel:unLocallyIndexedComponent:LocallyIndexedComponent] :: LocallyIndexedComponent' t d -> Vector (LocalIds' t d, Decl Symbol)
type SyncDeclFormat = SyncDeclFormat' TextId ObjectId
data SyncDeclFormat' t d
SyncDecl :: SyncLocallyIndexedComponent' t d -> SyncDeclFormat' t d
newtype SyncLocallyIndexedComponent' t d
SyncLocallyIndexedComponent :: Vector (LocalIds' t d, ByteString) -> SyncLocallyIndexedComponent' t d
type Decl v = DeclR TypeRef v
type Type v = Term F v ()
type F = F' TypeRef
type TypeRef = Reference' LocalTextId (Maybe LocalDefnId)
instance (GHC.Show.Show t, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Decl.Format.LocallyIndexedComponent' t d)
instance (GHC.Show.Show text, GHC.Show.Show defn) => GHC.Show.Show (U.Codebase.Sqlite.Decl.Format.DeclFormat' text defn)

module U.Codebase.Sqlite.TempEntityType

-- | Don't reorder these, they are part of the database, and the ToField
--   and FromField implementation currently depends on the derived Enum
--   implementation.
data TempEntityType
TermComponentType :: TempEntityType
DeclComponentType :: TempEntityType
NamespaceType :: TempEntityType
PatchType :: TempEntityType
CausalType :: TempEntityType
instance GHC.Enum.Enum U.Codebase.Sqlite.TempEntityType.TempEntityType
instance GHC.Show.Show U.Codebase.Sqlite.TempEntityType.TempEntityType
instance GHC.Classes.Ord U.Codebase.Sqlite.TempEntityType.TempEntityType
instance GHC.Classes.Eq U.Codebase.Sqlite.TempEntityType.TempEntityType
instance Database.SQLite.Simple.ToField.ToField U.Codebase.Sqlite.TempEntityType.TempEntityType
instance Database.SQLite.Simple.FromField.FromField U.Codebase.Sqlite.TempEntityType.TempEntityType

module U.Codebase.Sqlite.Term.Format

-- | <ul>
--   <li>Builtin terms are represented as local text ids.</li>
--   <li>Non-builtin terms are represented as local definition ids, with an
--   added distinguished element (here <tt>Nothing</tt>) which represents a
--   self-reference.</li>
--   </ul>
type TermRef = Reference' LocalTextId (Maybe LocalDefnId)

-- | <ul>
--   <li>Builtin types are represented as a local text id.</li>
--   <li>Non-builtin types are represented by a local definition id.</li>
--   </ul>
type TypeRef = Reference' LocalTextId LocalDefnId
type TermLink = Referent' TermRef TypeRef
type TypeLink = TypeRef

-- | A <a>LocallyIndexedComponent</a> is a vector that has one element per
--   member of the component (invariant: 1+).
--   
--   Each element is a term, which is represented as:
--   
--   <ul>
--   <li>Lookup vectors that map local ids to database ids for texts and
--   objects referenced by the term.</li>
--   <li>The term itself, with internal references to local ids (offsets
--   into the lookup vectors).</li>
--   <li>The term's type, also with internal references to local id.</li>
--   </ul>
type LocallyIndexedComponent = LocallyIndexedComponent' TextId ObjectId

-- | A locally indexed component which uses hash references instead of
--   database ids.
type HashLocallyIndexedComponent = LocallyIndexedComponent' Text Hash32
newtype LocallyIndexedComponent' t d
LocallyIndexedComponent :: Vector (LocalIds' t d, Term, Type) -> LocallyIndexedComponent' t d
[$sel:unLocallyIndexedComponent:LocallyIndexedComponent] :: LocallyIndexedComponent' t d -> Vector (LocalIds' t d, Term, Type)
newtype SyncLocallyIndexedComponent' t d
SyncLocallyIndexedComponent :: Vector (LocalIds' t d, ByteString) -> SyncLocallyIndexedComponent' t d
type F = F' LocalTextId TermRef TypeRef TermLink TypeLink Symbol
type FT = F' TypeRef
type Term = Term F Symbol ()
type Type = Term FT Symbol ()
type FTT = F' Reference
type TypeOfTerm = Term FTT Symbol ()
type TermFormat = TermFormat' TextId ObjectId

-- | A TermFormat which uses hash references instead of database ids.
type HashTermFormat = TermFormat' Text Hash32
data TermFormat' t d
Term :: LocallyIndexedComponent' t d -> TermFormat' t d
type SyncTermFormat = SyncTermFormat' TextId ObjectId
data SyncTermFormat' t d
SyncTerm :: SyncLocallyIndexedComponent' t d -> SyncTermFormat' t d
data WatchResultFormat
WatchResult :: WatchLocalIds -> Term -> WatchResultFormat
data SyncWatchResultFormat
SyncWatchResult :: WatchLocalIds -> ByteString -> SyncWatchResultFormat
instance (GHC.Show.Show t, GHC.Show.Show d) => GHC.Show.Show (U.Codebase.Sqlite.Term.Format.LocallyIndexedComponent' t d)

module U.Codebase.Sqlite.HashHandle
data HashHandle
HashHandle :: (Type Symbol -> Reference) -> (Type Symbol -> Set Reference) -> (Hash -> TypeD Symbol -> Reference) -> (Hash -> TypeD Symbol -> Set Reference) -> (forall m. Monad m => Branch m -> m BranchHash) -> (forall m. BranchV3 m -> BranchHash) -> (BranchHash -> Set CausalHash -> CausalHash) -> (HashBranchLocalIds -> LocalBranch -> BranchHash) -> (HashPatchLocalIds -> LocalPatch -> PatchHash) -> (ComponentHash -> HashTermFormat -> Maybe HashMismatch) -> (ComponentHash -> HashDeclFormat -> Maybe DeclHashingError) -> HashHandle

-- | Hash type
[$sel:toReference:HashHandle] :: HashHandle -> Type Symbol -> Reference

-- | Hash type's mentions
[$sel:toReferenceMentions:HashHandle] :: HashHandle -> Type Symbol -> Set Reference

-- | Hash the type of a single constructor in a decl component. The
--   provided hash argument is the hash of the decl component.
[$sel:toReferenceDecl:HashHandle] :: HashHandle -> Hash -> TypeD Symbol -> Reference

-- | Hash decl's mentions
[$sel:toReferenceDeclMentions:HashHandle] :: HashHandle -> Hash -> TypeD Symbol -> Set Reference
[$sel:hashBranch:HashHandle] :: HashHandle -> forall m. Monad m => Branch m -> m BranchHash
[$sel:hashBranchV3:HashHandle] :: HashHandle -> forall m. BranchV3 m -> BranchHash
[$sel:hashCausal:HashHandle] :: HashHandle -> BranchHash -> Set CausalHash -> CausalHash
[$sel:hashBranchFormatFull:HashHandle] :: HashHandle -> HashBranchLocalIds -> LocalBranch -> BranchHash
[$sel:hashPatchFormatFull:HashHandle] :: HashHandle -> HashPatchLocalIds -> LocalPatch -> PatchHash
[$sel:verifyTermFormatHash:HashHandle] :: HashHandle -> ComponentHash -> HashTermFormat -> Maybe HashMismatch
[$sel:verifyDeclFormatHash:HashHandle] :: HashHandle -> ComponentHash -> HashDeclFormat -> Maybe DeclHashingError
data HashMismatch
HashMismatch :: Hash -> Hash -> HashMismatch
[$sel:expectedHash:HashMismatch] :: HashMismatch -> Hash
[$sel:actualHash:HashMismatch] :: HashMismatch -> Hash
data DeclHashingError
DeclHashMismatch :: HashMismatch -> DeclHashingError
DeclHashResolutionFailure :: DeclHashingError

module U.Codebase.Sqlite.Entity

-- | data SyncEntity = TC SyncTermFormat | DC SyncDeclFormat | N
--   SyncBranchFormat | P SyncPatchFormat | C SyncCausalFormat
type SyncEntity = SyncEntity' TextId HashId ObjectId PatchObjectId BranchHashId BranchObjectId CausalHashId
data SyncEntity' text hash defn patch branchh branch causal
TC :: SyncTermFormat' text defn -> SyncEntity' text hash defn patch branchh branch causal
DC :: SyncDeclFormat' text defn -> SyncEntity' text hash defn patch branchh branch causal
N :: SyncBranchFormat' branch text defn patch (branch, causal) -> SyncEntity' text hash defn patch branchh branch causal
P :: SyncPatchFormat' patch text hash defn -> SyncEntity' text hash defn patch branchh branch causal
C :: SyncCausalFormat' causal branchh -> SyncEntity' text hash defn patch branchh branch causal
entityType :: SyncEntity' text hash defn patch branchh branch causal -> TempEntityType

module U.Codebase.Sqlite.TempEntity

-- | data TempEntity = TC TempTermFormat | DC TempDeclFormat | N
--   TempNamespaceFormat | P TempPatchFormat | C TempCausalFormat
type TempEntity = SyncEntity' Text Hash32 Hash32 Hash32 Hash32 Hash32 Hash32
type TempLocalIds = LocalIds' Text Hash32
type TempTermFormat = SyncTermFormat' Text Hash32
type TempDeclFormat = SyncDeclFormat' Text Hash32
type TempPatchFormat = SyncPatchFormat' Hash32 Text Hash32 Hash32
type TempPatchLocalIds = PatchLocalIds' Text Hash32 Hash32
type TempNamespaceFormat = SyncBranchFormat' Hash32 Text Hash32 Hash32 (Hash32, Hash32)
type TempNamespaceLocalIds = BranchLocalIds' Text Hash32 Hash32 (Hash32, Hash32)
type TempCausalFormat = SyncCausalFormat' Hash32 Hash32

module U.Codebase.Sqlite.Serialization
decomposeBranchFormat :: MonadGet m => m SyncBranchFormat
decomposeDeclFormat :: MonadGet m => m SyncDeclFormat
decomposePatchFormat :: MonadGet m => m SyncPatchFormat
decomposeTermFormat :: MonadGet m => m SyncTermFormat
decomposeWatchFormat :: MonadGet m => m SyncWatchResultFormat
getBranchFormat :: MonadGet m => m BranchFormat
getLocalBranch :: MonadGet m => m LocalBranch
getDeclElement :: MonadGet m => m (Decl Symbol)

-- | Get the number of constructors in a decl element.
getDeclElementNumConstructors :: MonadGet m => m Int
getDeclFormat :: MonadGet m => m DeclFormat
getPatchFormat :: MonadGet m => m PatchFormat
getLocalPatch :: MonadGet m => m LocalPatch
getTempCausalFormat :: MonadGet m => m TempCausalFormat
getTempDeclFormat :: MonadGet m => m TempDeclFormat
getTempNamespaceFormat :: MonadGet m => m TempNamespaceFormat
getTempPatchFormat :: MonadGet m => m TempPatchFormat
getTempTermFormat :: MonadGet m => m TempTermFormat
getTermAndType :: MonadGet m => m (Term, Type)

-- | Decode ONLY the type of a term-component element. This is useful
--   during sync and when we need the type of a term component element but
--   don't want to decode the whole term (which can be expensive).
getTypeFromTermAndType :: MonadGet m => m Type
getTermFormat :: MonadGet m => m TermFormat
getWatchResultFormat :: MonadGet m => m WatchResultFormat
lookupDeclElement :: MonadGet m => Pos -> m (LocalIds, Decl Symbol)
lookupDeclElementNumConstructors :: MonadGet m => Pos -> m Int
lookupTermElement :: MonadGet m => Pos -> m (LocalIds, Term, Type)
lookupTermElementDiscardingTerm :: MonadGet m => Pos -> m (LocalIds, Type)
lookupTermElementDiscardingType :: MonadGet m => Pos -> m (LocalIds, Term)
putBranchFormat :: MonadPut m => BranchFormat -> m ()
putDeclFormat :: MonadPut m => DeclFormat -> m ()
putPatchFormat :: MonadPut m => PatchFormat -> m ()
putTempEntity :: MonadPut m => TempEntity -> m ()
putTermFormat :: MonadPut m => TermFormat -> m ()
putWatchResultFormat :: MonadPut m => WatchResultFormat -> m ()
recomposeBranchFormat :: MonadPut m => SyncBranchFormat -> m ()
recomposeDeclFormat :: MonadPut m => SyncDeclFormat -> m ()
recomposePatchFormat :: MonadPut m => SyncPatchFormat -> m ()
recomposeTermFormat :: MonadPut m => SyncTermFormat -> m ()
recomposeWatchFormat :: MonadPut m => SyncWatchResultFormat -> m ()
putTermAndType :: MonadPut m => (Term, Type) -> m ()

-- | Encode a single term without its type or component. Don't use this on
--   its own unless you're encoding a watch result.
putSingleTerm :: MonadPut m => Term -> m ()
putDeclElement :: MonadPut m => DeclR TypeRef Symbol -> m ()
getSingleTerm :: MonadGet m => m Term
putLocalIdsWith :: MonadPut m => (t -> m ()) -> (d -> m ()) -> LocalIds' t d -> m ()
getLocalIdsWith :: MonadGet m => m t -> m d -> m (LocalIds' t d)
putLocalBranch :: MonadPut m => LocalBranch -> m ()
putLocalPatch :: MonadPut m => LocalPatch -> m ()


-- | This module contains decoders for blobs stored in SQLite.
module U.Codebase.Sqlite.Decode
data DecodeError
DecodeError :: Text -> String -> DecodeError
[$sel:decoder:DecodeError] :: DecodeError -> Text
[$sel:err:DecodeError] :: DecodeError -> String
decodeBranchFormat :: ByteString -> Either DecodeError BranchFormat
decodeComponentLengthOnly :: ByteString -> Either DecodeError Word64
decodeDeclElement :: Word64 -> ByteString -> Either DecodeError (LocalIds, Decl Symbol)
decodeDeclElementNumConstructors :: Word64 -> ByteString -> Either DecodeError Int
decodeDeclFormat :: ByteString -> Either DecodeError DeclFormat
decodePatchFormat :: ByteString -> Either DecodeError PatchFormat
decodeSyncDeclFormat :: ByteString -> Either DecodeError SyncDeclFormat
decodeSyncNamespaceFormat :: ByteString -> Either DecodeError SyncBranchFormat
decodeSyncPatchFormat :: ByteString -> Either DecodeError SyncPatchFormat
decodeSyncTermFormat :: ByteString -> Either DecodeError SyncTermFormat

-- | N.B. The bytestring here is not the entire object.bytes column -- it's
--   just the serialized term and type from <a>SyncTermFormat</a>.
decodeSyncTermAndType :: ByteString -> Either DecodeError (Term, Type)
decodeTermElementDiscardingTerm :: Pos -> ByteString -> Either DecodeError (LocalIds, Type)
decodeTermElementDiscardingType :: Pos -> ByteString -> Either DecodeError (LocalIds, Term)
decodeTermElementWithType :: Pos -> ByteString -> Either DecodeError (LocalIds, Term, Type)
decodeTermFormat :: ByteString -> Either DecodeError TermFormat
decodeTempCausalFormat :: ByteString -> Either DecodeError TempCausalFormat
decodeTempDeclFormat :: ByteString -> Either DecodeError TempDeclFormat
decodeTempNamespaceFormat :: ByteString -> Either DecodeError TempNamespaceFormat
decodeTempPatchFormat :: ByteString -> Either DecodeError TempPatchFormat
decodeTempTermFormat :: ByteString -> Either DecodeError TempTermFormat
decodeWatchResultFormat :: ByteString -> Either DecodeError WatchResultFormat
unsyncTermComponent :: HasCallStack => SyncLocallyIndexedComponent' t d -> Either DecodeError (LocallyIndexedComponent' t d)
unsyncDeclComponent :: SyncLocallyIndexedComponent' t d -> Either DecodeError (LocallyIndexedComponent' t d)
instance GHC.Exception.Type.Exception U.Codebase.Sqlite.Decode.DecodeError
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Decode.DecodeError
instance GHC.Show.Show U.Codebase.Sqlite.Decode.DecodeError


-- | Some naming conventions used in this module:
--   
--   <ul>
--   <li><tt>32</tt>: the base32 representation of a hash</li>
--   <li><tt>expect</tt>: retrieve something that's known to exist</li>
--   <li><tt>load</tt>: retrieve something that's not known to exist (so
--   the return type is a Maybe, or another container that could be
--   empty)</li>
--   <li><tt>save</tt>: idempotent (on conflict do nothing) insert, and
--   return the id of the thing (usually)</li>
--   </ul>
module U.Codebase.Sqlite.Queries
saveText :: Text -> Transaction TextId
saveTexts :: Traversable f => f Text -> Transaction (f TextId)
loadTextId :: Text -> Transaction (Maybe TextId)
expectTextId :: Text -> Transaction TextId
expectText :: TextId -> Transaction Text
expectTextCheck :: SqliteExceptionReason e => TextId -> (Text -> Either e a) -> Transaction a
saveNameSegment :: NameSegment -> Transaction TextId
expectNameSegment :: TextId -> Transaction NameSegment
saveHash :: Hash32 -> Transaction HashId
saveHashes :: Traversable f => f Hash32 -> Transaction (f HashId)
saveHashHash :: Hash -> Transaction HashId
loadHashId :: Hash32 -> Transaction (Maybe HashId)
expectHash :: HashId -> Transaction Hash
expectHash32 :: HashId -> Transaction Hash32
expectBranchHash :: BranchHashId -> Transaction BranchHash
expectBranchHashId :: BranchHash -> Transaction BranchHashId
loadHashIdByHash :: Hash -> Transaction (Maybe HashId)
expectHashIdByHash :: Hash -> Transaction HashId
saveCausalHash :: CausalHash -> Transaction CausalHashId
expectCausalHash :: CausalHashId -> Transaction CausalHash
expectBranchHashForCausalHash :: CausalHash -> Transaction BranchHash
saveBranchHash :: BranchHash -> Transaction BranchHashId
saveHashObject :: HashId -> ObjectId -> HashVersion -> Transaction ()
expectHashIdsForObject :: ObjectId -> Transaction (NonEmpty HashId)
hashIdWithVersionForObject :: ObjectId -> Transaction [(HashId, HashVersion)]
loadObjectIdForPrimaryHashId :: HashId -> Transaction (Maybe ObjectId)

-- | Not all hashes have corresponding objects; e.g., hashes of term types
expectObjectIdForPrimaryHashId :: HashId -> Transaction ObjectId
loadObjectIdForPrimaryHash :: Hash -> Transaction (Maybe ObjectId)
expectObjectIdForPrimaryHash :: Hash -> Transaction ObjectId
loadPatchObjectIdForPrimaryHash :: PatchHash -> Transaction (Maybe PatchObjectId)
loadObjectIdForAnyHash :: Hash -> Transaction (Maybe ObjectId)
loadObjectIdForAnyHashId :: HashId -> Transaction (Maybe ObjectId)
expectObjectIdForAnyHashId :: HashId -> Transaction ObjectId

-- | <tt>recordObjectRehash old new</tt> records that object <tt>old</tt>
--   was rehashed and inserted as a new object, <tt>new</tt>.
--   
--   This function rewrites <tt>old</tt>'s <tt>hash_object</tt> rows in
--   place to point at the new object.
recordObjectRehash :: ObjectId -> ObjectId -> Transaction ()
saveObject :: HashHandle -> HashId -> ObjectType -> ByteString -> Transaction ObjectId

-- | Does a hash correspond to an object?
isObjectHash :: HashId -> Transaction Bool
expectObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | All objects have corresponding hashes.
expectPrimaryHashByObjectId :: ObjectId -> Transaction Hash
expectPrimaryHashIdForObject :: ObjectId -> Transaction HashId
expectObjectWithHashIdAndType :: ObjectId -> Transaction (HashId, ObjectType, ByteString)

-- | Expect a decl component object.
expectDeclObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a decl component object.
loadDeclObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a namespace object.
expectNamespaceObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a namespace object.
loadNamespaceObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a patch object.
expectPatchObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Load a patch object.
loadPatchObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Load a term component object.
loadTermObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction (Maybe a)

-- | Expect a term component object.
expectTermObject :: SqliteExceptionReason e => ObjectId -> (ByteString -> Either e a) -> Transaction a

-- | Save statistics about a given branch.
saveNamespaceStats :: BranchHashId -> NamespaceStats -> Transaction ()

-- | Looks up statistics for a given branch, there's no guarantee that we
--   have computed and saved stats for any given branch.
loadNamespaceStatsByHashId :: BranchHashId -> Transaction (Maybe NamespaceStats)

-- | Maybe we would generalize this to something other than NamespaceHash
--   if we end up wanting to store other kinds of Causals here too.
saveCausal :: HashHandle -> CausalHashId -> BranchHashId -> [CausalHashId] -> Transaction ()
isCausalHash :: HashId -> Transaction Bool

-- | Return whether or not a causal exists with the given hash32.
causalExistsByHash32 :: Hash32 -> Transaction Bool
expectCausal :: CausalHashId -> Transaction SyncCausalFormat
loadCausalHashIdByCausalHash :: CausalHash -> Transaction (Maybe CausalHashId)
expectCausalHashIdByCausalHash :: CausalHash -> Transaction CausalHashId
expectCausalValueHashId :: CausalHashId -> Transaction BranchHashId
loadCausalByCausalHash :: CausalHash -> Transaction (Maybe (CausalHashId, BranchHashId))
expectCausalByCausalHash :: CausalHash -> Transaction (CausalHashId, BranchHashId)
loadBranchObjectIdByCausalHashId :: CausalHashId -> Transaction (Maybe BranchObjectId)
loadBranchObjectIdByBranchHashId :: BranchHashId -> Transaction (Maybe BranchObjectId)
expectBranchObjectIdByCausalHashId :: CausalHashId -> Transaction BranchObjectId
expectBranchObjectIdByBranchHashId :: BranchHashId -> Transaction BranchObjectId

-- | Get the causal hash result from squashing the provided branch hash if
--   we've squashed it at some point in the past.
tryGetSquashResult :: BranchHashId -> Transaction (Maybe CausalHashId)

-- | Save the result of running a squash on the provided branch hash id.
saveSquashResult :: BranchHashId -> CausalHashId -> Transaction ()
saveCausalParents :: CausalHashId -> [CausalHashId] -> Transaction ()
loadCausalParents :: CausalHashId -> Transaction [CausalHashId]

-- | Like <a>loadCausalParents</a>, but the input and outputs are hashes,
--   not hash ids.
loadCausalParentsByHash :: Hash32 -> Transaction [Hash32]

-- | <tt>before x y</tt> returns whether or not <tt>x</tt> occurred before
--   <tt>y</tt>, i.e. <tt>x</tt> is an ancestor of <tt>y</tt>.
before :: CausalHashId -> CausalHashId -> Transaction Bool
lca :: CausalHashId -> CausalHashId -> Transaction (Maybe CausalHashId)
saveWatch :: WatchKind -> IdH -> ByteString -> Transaction ()
loadWatch :: SqliteExceptionReason e => WatchKind -> IdH -> (ByteString -> Either e a) -> Transaction (Maybe a)
loadWatchesByWatchKind :: WatchKind -> Transaction [IdH]
loadWatchKindsByReference :: IdH -> Transaction [WatchKind]

-- | Delete all watches that were put by <tt>putWatch</tt>.
clearWatches :: Transaction ()

-- | Does a project exist with this id?
projectExists :: ProjectId -> Transaction Bool

-- | Check if any projects exist
doProjectsExist :: Transaction Bool

-- | Does a project exist by this name?
projectExistsByName :: ProjectName -> Transaction Bool
loadProject :: ProjectId -> Transaction (Maybe Project)
loadProjectByName :: ProjectName -> Transaction (Maybe Project)
expectProject :: ProjectId -> Transaction Project

-- | Load all projects.
loadAllProjects :: Transaction [Project]

-- | Load all projects whose name matches a prefix.
loadAllProjectsBeginningWith :: Maybe Text -> Transaction [Project]

-- | Insert a <a>project</a> row.
insertProject :: ProjectId -> ProjectName -> Transaction ()

-- | Rename a <a>project</a> row.
--   
--   Precondition: the new name is available.
renameProject :: ProjectId -> ProjectName -> Transaction ()
deleteProject :: ProjectId -> Transaction ()

-- | Does a project branch exist by this name?
projectBranchExistsByName :: ProjectId -> ProjectBranchName -> Transaction Bool
loadProjectBranchByName :: ProjectId -> ProjectBranchName -> Transaction (Maybe ProjectBranch)
loadProjectBranchByNames :: ProjectName -> ProjectBranchName -> Transaction (Maybe ProjectBranch)
expectProjectBranch :: ProjectId -> ProjectBranchId -> Transaction ProjectBranch

-- | Load all branch id/name pairs in a project whose name matches an
--   optional prefix.
loadAllProjectBranchesBeginningWith :: ProjectId -> Maybe Text -> Transaction [(ProjectBranchId, ProjectBranchName)]

-- | Load info about all branches in a project, for display by the
--   <tt>branches</tt> command.
--   
--   Each branch name maps to a possibly-empty collection of associated
--   remote branches.
loadAllProjectBranchInfo :: ProjectId -> Transaction (Map ProjectBranchName (Map URI (ProjectName, ProjectBranchName)))
loadProjectAndBranchNames :: ProjectId -> ProjectBranchId -> Transaction (Maybe (ProjectName, ProjectBranchName))

-- | Load ALL project/branch name pairs Useful for
--   autocomplete/fuzzy-finding
loadAllProjectBranchNamePairs :: Transaction [(ProjectAndBranch ProjectName ProjectBranchName, ProjectAndBranch ProjectId ProjectBranchId)]
loadProjectBranch :: ProjectId -> ProjectBranchId -> Transaction (Maybe ProjectBranch)

-- | Insert a project branch.
insertProjectBranch :: HasCallStack => Text -> CausalHashId -> ProjectBranch -> Transaction ()

-- | Rename a project branch.
--   
--   Precondition: the new name is available.
renameProjectBranch :: ProjectId -> ProjectBranchId -> ProjectBranchName -> Transaction ()

-- | Delete a project branch.
--   
--   Re-parenting happens in the obvious way:
--   
--   Before:
--   
--   main &lt;- topic &lt;- topic2
--   
--   After deleting <tt>topic</tt>:
--   
--   main &lt;- topic2
deleteProjectBranch :: HasCallStack => ProjectId -> ProjectBranchId -> Transaction ()

-- | Set project branch HEAD
setProjectBranchHead :: Text -> ProjectId -> ProjectBranchId -> CausalHashId -> Transaction ()
expectProjectBranchHead :: HasCallStack => ProjectId -> ProjectBranchId -> Transaction CausalHashId
setMostRecentBranch :: ProjectId -> ProjectBranchId -> Transaction ()
loadMostRecentBranch :: ProjectId -> Transaction (Maybe ProjectBranchId)
loadRemoteProject :: RemoteProjectId -> URI -> Transaction (Maybe RemoteProject)
ensureRemoteProject :: RemoteProjectId -> URI -> ProjectName -> Transaction ()
expectRemoteProjectName :: RemoteProjectId -> URI -> Transaction ProjectName
setRemoteProjectName :: RemoteProjectId -> ProjectName -> Transaction ()

-- | Determine the remote mapping for a local project/branch by looking at
--   the mapping for the given pair, then falling back to the project of
--   the nearest ancestor.
loadRemoteProjectBranch :: ProjectId -> URI -> ProjectBranchId -> Transaction (Maybe (RemoteProjectId, Maybe RemoteProjectBranchId))

-- | Load the default merge target for a local branch (i.e. The nearest
--   ancestor's remote mapping)
loadDefaultMergeTargetForLocalProjectBranch :: ProjectId -> URI -> ProjectBranchId -> Transaction (Maybe (RemoteProjectId, RemoteProjectBranchId))
loadRemoteBranch :: RemoteProjectId -> URI -> RemoteProjectBranchId -> Transaction (Maybe RemoteProjectBranch)
ensureRemoteProjectBranch :: RemoteProjectId -> URI -> RemoteProjectBranchId -> ProjectBranchName -> Transaction ()
expectRemoteProjectBranchName :: URI -> RemoteProjectId -> RemoteProjectBranchId -> Transaction ProjectBranchName
setRemoteProjectBranchName :: RemoteProjectId -> URI -> RemoteProjectBranchId -> ProjectBranchName -> Transaction ()
insertBranchRemoteMapping :: ProjectId -> ProjectBranchId -> RemoteProjectId -> URI -> RemoteProjectBranchId -> Transaction ()
ensureBranchRemoteMapping :: ProjectId -> ProjectBranchId -> RemoteProjectId -> URI -> RemoteProjectBranchId -> Transaction ()
deleteBranchRemoteMapping :: ProjectId -> ProjectBranchId -> URI -> Transaction ()
addToDependentsIndex :: [Reference] -> Id -> Transaction ()

-- | Which dependents should be returned?
--   
--   <ul>
--   <li><i>IncludeAllDependents</i>. Include all dependents, including
--   references from one's own component-mates, and references from oneself
--   (e.g. those in recursive functions)</li>
--   <li><i>ExcludeSelf</i>. Include all dependents, including references
--   from one's own component-mates, but excluding actual self references
--   (e.g. those in recursive functions).</li>
--   <li><i>ExcludeOwnComponent</i>. Include all dependents outside of
--   one's own component.</li>
--   </ul>
data DependentsSelector
IncludeAllDependents :: DependentsSelector
ExcludeSelf :: DependentsSelector
ExcludeOwnComponent :: DependentsSelector

-- | Get dependents of a dependency.
getDependentsForDependency :: DependentsSelector -> Reference -> Transaction (Set Id)
getDependentsForDependencyComponent :: ObjectId -> Transaction [Id]

-- | Get non-self dependencies of a user-defined dependent.
getDependenciesForDependent :: Id -> Transaction [Reference]

-- | Get non-self, user-defined dependencies of a user-defined dependent.
getDependencyIdsForDependent :: Id -> Transaction [Id]

-- | Given two term (components) A and B, return the set of all terms that
--   are along any "dependency path" from A to B, not including A nor B;
--   i.e., the transitive dependencies of A that are transitive dependents
--   of B.
--   
--   For example, if A depends on X and Y, X depends on Q, Y depends on Z,
--   and X and Z depend on B...
--   
--   <ul>
--   <li>-X-----Q / A B / Y---Z</li>
--   </ul>
--   
--   ...then `getDependenciesBetweenTerms A B` would return the set {X Y Z}
getDependenciesBetweenTerms :: ObjectId -> ObjectId -> Transaction (Set ObjectId)
getDirectDependenciesOfScope :: DefnsF Set TermReferenceId TypeReferenceId -> Transaction (DefnsF Set TermReference TypeReference)

-- | `getDirectDependentsWithinScope scope query` returns all direct
--   dependents of <tt>query</tt> that are in <tt>scope</tt> (not including
--   <tt>query</tt> itself).
getDirectDependentsWithinScope :: Set Id -> Set Reference -> Transaction (DefnsF Set TermReferenceId TypeReferenceId)

-- | `getTransitiveDependentsWithinScope scope query` returns all
--   transitive dependents of <tt>query</tt> that are in <tt>scope</tt>
--   (not including <tt>query</tt> itself).
getTransitiveDependentsWithinScope :: Set Id -> Set Reference -> Transaction (DefnsF Set TermReferenceId TypeReferenceId)
addToTypeIndex :: ReferenceH -> Id -> Transaction ()
getReferentsByType :: ReferenceH -> Transaction [Id]
getTypeReferenceForReferent :: Id -> Transaction ReferenceH
getTypeReferencesForComponent :: ObjectId -> Transaction [(ReferenceH, Id)]
filterTermsByReferenceHavingType :: ReferenceH -> [Id] -> Transaction [Id]
filterTermsByReferentHavingType :: ReferenceH -> [Id] -> Transaction [Id]
addToTypeMentionsIndex :: ReferenceH -> Id -> Transaction ()
getReferentsByTypeMention :: ReferenceH -> Transaction [Id]
getTypeMentionsReferencesForComponent :: ObjectId -> Transaction [(ReferenceH, Id)]
objectIdByBase32Prefix :: ObjectType -> Text -> Transaction [ObjectId]
namespaceHashIdByBase32Prefix :: Text -> Transaction [BranchHashId]
causalHashIdByBase32Prefix :: Text -> Transaction [CausalHashId]

-- | Copies existing name lookup rows but replaces their branch hash id;
--   This is a low-level operation used as part of deriving a new name
--   lookup index from an existing one as performantly as possible.
copyScopedNameLookup :: BranchHashId -> BranchHashId -> Transaction ()

-- | Insert the given set of term names into the name lookup table
insertScopedTermNames :: BranchHashId -> [NamedRef (TextReferent, Maybe ConstructorType)] -> Transaction ()

-- | Insert the given set of type names into the name lookup table
insertScopedTypeNames :: BranchHashId -> [NamedRef TextReference] -> Transaction ()

-- | Remove the given set of term names into the name lookup table
removeScopedTermNames :: BranchHashId -> [NamedRef TextReferent] -> Transaction ()

-- | Remove the given set of term names into the name lookup table
removeScopedTypeNames :: BranchHashId -> [NamedRef TextReference] -> Transaction ()

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of a term names in the provided name lookup and relative
--   namespace. Includes dependencies, but not transitive dependencies.
termNamesWithinNamespace :: BranchHashId -> PathSegments -> Transaction [NamedRef (TextReferent, Maybe ConstructorType)]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of a type names in the provided name lookup and relative
--   namespace. Includes dependencies, but not transitive dependencies.
typeNamesWithinNamespace :: BranchHashId -> PathSegments -> Transaction [NamedRef TextReference]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of term names for a given Referent within a given
--   namespace. Considers one level of dependencies, but not transitive
--   dependencies.
termNamesForRefWithinNamespace :: BranchHashId -> PathSegments -> TextReferent -> Maybe ReversedName -> Transaction [ReversedName]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of type names for a given Reference within a given
--   namespace. Considers one level of dependencies, but not transitive
--   dependencies.
typeNamesForRefWithinNamespace :: BranchHashId -> PathSegments -> TextReference -> Maybe ReversedName -> Transaction [ReversedName]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Searches all dependencies transitively looking for the provided
--   referent. Prefer <a>termNamesForRefWithinNamespace</a> in most cases.
--   This is slower and only necessary when resolving the name of
--   references when you don't know which dependency it may exist in.
--   
--   Searching transitive dependencies is exponential so we want to replace
--   this with a more efficient approach as soon as possible.
--   
--   Note: this returns the first name it finds by searching in order of:
--   Names in the current namespace, then names in the current namespace's
--   dependencies, then through the current namespace's dependencies'
--   dependencies, etc.
recursiveTermNameSearch :: BranchHashId -> TextReferent -> Transaction (Maybe ReversedName)

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Searches all dependencies transitively looking for the provided
--   referent. Prefer <a>typeNamesForRefWithinNamespace</a> in most cases.
--   This is slower and only necessary when resolving the name of
--   references when you don't know which dependency it may exist in.
--   
--   Searching transitive dependencies is exponential so we want to replace
--   this with a more efficient approach as soon as possible.
--   
--   Note: this returns the first name it finds by searching in order of:
--   Names in the current namespace, then names in the current namespace's
--   dependencies, then through the current namespace's dependencies'
--   dependencies, etc.
recursiveTypeNameSearch :: BranchHashId -> TextReference -> Transaction (Maybe ReversedName)

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the set of refs for an exact name. This will only return results
--   which are within the name lookup for the provided branch hash id. It's
--   the caller's job to select the correct name lookup for your exact
--   name.
--   
--   See termRefsForExactName in U.Codebase.Sqlite.Operations
termRefsForExactName :: BranchHashId -> ReversedName -> Transaction [NamedRef (TextReferent, Maybe ConstructorType)]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the set of refs for an exact name. This will only return results
--   which are within the name lookup for the provided branch hash id. It's
--   the caller's job to select the correct name lookup for your exact
--   name.
--   
--   See termRefsForExactName in U.Codebase.Sqlite.Operations
typeRefsForExactName :: BranchHashId -> ReversedName -> Transaction [NamedRef TextReference]

-- | Check if we've already got an index for the desired root branch hash.
checkBranchHashNameLookupExists :: BranchHashId -> Transaction Bool

-- | Inserts a new record into the name_lookups table
trackNewBranchHashNameLookup :: BranchHashId -> Transaction ()

-- | Delete the specified name lookup. This should only be used if you're
--   sure it's unused, or if you're going to re-create it in the same
--   transaction.
deleteNameLookup :: BranchHashId -> Transaction ()

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of term names within a given namespace which have the
--   given suffix.
termNamesBySuffix :: BranchHashId -> PathSegments -> ReversedName -> Transaction [NamedRef (TextReferent, Maybe ConstructorType)]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of type names within a given namespace which have the
--   given suffix.
typeNamesBySuffix :: BranchHashId -> PathSegments -> ReversedName -> Transaction [NamedRef TextReference]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   The goal of this query is to search the codebase for the single name
--   which has a different hash from the provided name, but shares longest
--   matching suffix for for that name.
--   
--   Including this name in the pretty-printer object causes it to
--   suffixify the name so that it is unambiguous from other names in
--   scope.
--   
--   Sqlite doesn't provide enough functionality to do this query in a
--   single query, so we do it iteratively, querying for longer and longer
--   suffixes we no longer find matches. Then we return the name with
--   longest matching suffix.
--   
--   This is still relatively efficient because we can use an index and
--   LIMIT 1 to make each individual query fast, and in the common case
--   we'll only need two or three queries to find the longest matching
--   suffix.
--   
--   Considers one level of dependencies, but not transitive dependencies.
longestMatchingTermNameForSuffixification :: BranchHashId -> PathSegments -> NamedRef TextReferent -> Transaction (Maybe (NamedRef (TextReferent, Maybe ConstructorType)))

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   The goal of this query is to search the codebase for the single name
--   which has a different hash from the provided name, but shares longest
--   matching suffix for for that name.
--   
--   Including this name in the pretty-printer object causes it to
--   suffixify the name so that it is unambiguous from other names in
--   scope.
--   
--   Sqlite doesn't provide enough functionality to do this query in a
--   single query, so we do it iteratively, querying for longer and longer
--   suffixes we no longer find matches. Then we return the name with
--   longest matching suffix.
--   
--   This is still relatively efficient because we can use an index and
--   LIMIT 1 to make each individual query fast, and in the common case
--   we'll only need two or three queries to find the longest matching
--   suffix.
--   
--   Considers one level of dependencies, but not transitive dependencies.
longestMatchingTypeNameForSuffixification :: BranchHashId -> PathSegments -> NamedRef TextReference -> Transaction (Maybe (NamedRef TextReference))

-- | Associate name lookup indexes for dependencies to specific mounting
--   points within another name lookup.
associateNameLookupMounts :: BranchHashId -> [(PathSegments, BranchHashId)] -> Transaction ()

-- | Fetch the name lookup mounts for a given name lookup index.
listNameLookupMounts :: BranchHashId -> Transaction [(PathSegments, BranchHashId)]

-- | Delete any name lookup that's not in the provided list.
--   
--   This can be used to garbage collect unreachable name lookups.
deleteNameLookupsExceptFor :: [BranchHashId] -> Transaction ()

-- | Searches for all names within the given name lookup which contain the
--   provided list of segments in order. Search is case insensitive.
fuzzySearchTerms :: Bool -> BranchHashId -> Int -> PathSegments -> [Text] -> Transaction [NamedRef (TextReferent, Maybe ConstructorType)]

-- | Searches for all names within the given name lookup which contain the
--   provided list of segments in order.
--   
--   Search is case insensitive.
fuzzySearchTypes :: Bool -> BranchHashId -> Int -> PathSegments -> [Text] -> Transaction [NamedRef TextReference]
getDeprecatedRootReflog :: Int -> Transaction [Entry CausalHashId Text]
appendProjectBranchReflog :: Entry ProjectId ProjectBranchId CausalHashId -> Transaction ()

-- | Get x number of entries from the project reflog for the provided
--   project
getProjectReflog :: Int -> ProjectId -> Transaction [Entry ProjectId ProjectBranchId CausalHashId]

-- | Get x number of entries from the project reflog for the provided
--   branch.
getProjectBranchReflog :: Int -> ProjectBranchId -> Transaction [Entry ProjectId ProjectBranchId CausalHashId]

-- | Get x number of entries from the global reflog spanning all projects
getGlobalReflog :: Int -> Transaction [Entry ProjectId ProjectBranchId CausalHashId]

-- | Delete objects without hashes. An object typically *would* have a
--   hash, but (for example) during a migration in which an object's hash
--   may change, its corresponding hash_object row may be updated to point
--   at a new version of that object. This procedure clears out all
--   references to objects that do not have any corresponding hash_object
--   rows.
garbageCollectObjectsWithoutHashes :: Transaction ()

-- | Delete all
garbageCollectWatchesWithoutObjects :: Transaction ()

-- | Where an entity is stored.
data EntityLocation

-- | <tt>object</tt> / <tt>causal</tt>
EntityInMainStorage :: EntityLocation

-- | <tt>temp_entity</tt>
EntityInTempStorage :: EntityLocation

-- | Does this entity already exist in the database, i.e. in the
--   <tt>object</tt> or <tt>causal</tt> table?
entityExists :: Hash32 -> Transaction Bool

-- | Where is an entity stored?
entityLocation :: Hash32 -> Transaction (Maybe EntityLocation)

-- | Read an entity out of main storage.
expectEntity :: Hash32 -> Transaction SyncEntity

-- | looking up all of the text and hashes is the first step of converting
--   a SyncEntity to a Share.Entity
syncToTempEntity :: SyncEntity -> Transaction TempEntity

-- | Insert a new <tt>temp_entity</tt> row, and its associated 1+
--   <tt>temp_entity_missing_dependency</tt> rows.
--   
--   Preconditions: 1. The entity does not already exist in "main" storage
--   (<tt>object</tt> / <tt>causal</tt>) 2. The entity does not already
--   exist in <tt>temp_entity</tt>.
insertTempEntity :: Hash32 -> TempEntity -> NEMap Hash32 Text -> Transaction ()

-- | Save a temp entity in main storage.
--   
--   Precondition: all of its dependencies are already in main storage.
saveTempEntityInMain :: HashHandle -> Hash32 -> TempEntity -> Transaction (Either CausalHashId ObjectId)

-- | Read an entity out of temp storage.
expectTempEntity :: Hash32 -> Transaction TempEntity

-- | Delete a row from the <tt>temp_entity</tt> table, if it exists.
deleteTempEntity :: Hash32 -> Transaction ()

-- | Clears the <tt>temp_entity</tt> and
--   <tt>temp_entity_missing_dependency</tt> tables. The hashjwts stored in
--   temp entity tables can sometimes go stale, so we clear them out. This
--   is safe because temp entities are generally considered ephemeral
--   except during an active pull.
clearTempEntityTables :: Transaction ()

-- | <a>Elaborate</a> a set of <tt>temp_entity</tt> hashes.
--   
--   Given a set of <tt>temp_entity</tt> hashes, returns the (known) set of
--   transitive dependencies that haven't already been downloaded (i.e.
--   aren't in the <tt>temp_entity</tt> table)
--   
--   For example, if we have temp entities A and B, where A depends on B
--   and B depends on C...
--   
--   | temp_entity | | temp_entity_missing_dependency | |=============|
--   |================================| | hash | | dependent | dependency |
--   |-------------| |--------------|-----------------| | A | | A | B | | B
--   | | B | C |
--   
--   ... then `elaborateHashes {A}` would return the singleton set {C}
--   (because we take the set of transitive dependencies {A,B,C} and
--   subtract the set we already have, {A,B}).
elaborateHashes :: NonEmpty Hash32 -> Transaction [Text]

-- | Get the most recent namespace the user has visited.
expectCurrentProjectPath :: HasCallStack => Transaction (ProjectId, ProjectBranchId, [NameSegment])

-- | Set the most recent namespace the user has visited.
setCurrentProjectPath :: ProjectId -> ProjectBranchId -> [NameSegment] -> Transaction ()
runCreateSql :: Transaction ()
addTempEntityTables :: Transaction ()

-- | Deprecated in favour of project-branch reflog
addReflogTable :: Transaction ()
addNamespaceStatsTables :: Transaction ()
addProjectTables :: Transaction ()
addMostRecentBranchTable :: Transaction ()
fixScopedNameLookupTables :: Transaction ()
addNameLookupMountTables :: Transaction ()
addMostRecentNamespaceTable :: Transaction ()
addSquashResultTable :: Transaction ()

-- | Added as a fix because <a>addSquashResultTable</a> was missed in the
--   createSchema action for a portion of time.
addSquashResultTableIfNotExists :: Transaction ()
cdToProjectRoot :: Transaction ()
addCurrentProjectPathTable :: Transaction ()

-- | Deprecated in favour of project-branch reflog
addProjectBranchReflogTable :: Transaction ()
addProjectBranchCausalHashIdColumn :: Transaction ()
currentSchemaVersion :: SchemaVersion

-- | Expect the given schema version.
expectSchemaVersion :: SchemaVersion -> Transaction ()
setSchemaVersion :: SchemaVersion -> Transaction ()
countObjects :: Transaction Int
countCausals :: Transaction Int
countWatches :: Transaction Int

-- | Finds all causals that refer to a branch for which we don't have an
--   object stored. Although there are plans to support this in the future,
--   currently all such cases are the result of database inconsistencies
--   and are unexpected.
getCausalsWithoutBranchObjects :: Transaction [CausalHashId]

-- | Delete all hash objects of a given hash version. Leaves the
--   corresponding <tt>hash</tt>es in the hash table alone.
removeHashObjectsByHashingVersion :: HashVersion -> Transaction ()
addTypeMentionsToIndexForTerm :: Id -> Set Reference -> Transaction ()
addTypeToIndexForTerm :: Id -> Reference -> Transaction ()

-- | implementation detail of c2{s,w}Term The Type is optional, because we
--   don't store them for watch expression results.
c2xTerm :: forall m t d. Monad m => (Text -> m t) -> (Hash -> m d) -> Term Symbol -> Maybe (Type Symbol) -> m (LocalIds' t d, Term, Maybe Type)

-- | implementation detail of {s,w}2c*Term* &amp; s2cDecl
localIdsToLookups :: Monad m => (t -> m Text) -> (d -> m Hash) -> LocalIds' t d -> m (LocalTextId -> Text, LocalDefnId -> Hash)

-- | Unlocalize a decl.
s2cDecl :: LocalIds -> Decl Symbol -> Transaction (Decl Symbol)
s2cTermWithType :: LocalIds -> Term -> Type -> Transaction (Term Symbol, Type Symbol)
saveDeclComponent :: HashHandle -> Maybe ByteString -> Hash -> [Decl Symbol] -> Transaction ObjectId

-- | Save the text and hash parts of a Reference to the database and
--   substitute their ids.
saveReferenceH :: Reference -> Transaction ReferenceH
saveSyncEntity :: HashHandle -> Hash32 -> SyncEntity -> Transaction (Either CausalHashId ObjectId)
saveTermComponent :: HashHandle -> Maybe ByteString -> Hash -> [(Term Symbol, Type Symbol)] -> Transaction ObjectId
schemaVersion :: Transaction SchemaVersion

-- | implementation detail of {s,w}2c*Term*
x2cTType :: (LocalTextId -> Text) -> (LocalDefnId -> Hash) -> Type -> Type Symbol

-- | implementation detail of {s,w}2c*Term*
x2cTerm :: (LocalTextId -> Text) -> (LocalDefnId -> Hash) -> Term -> Term Symbol
x2cDecl :: (r -> r1) -> DeclR r Symbol -> DeclR r1 Symbol

-- | Checks whether the codebase contains the actual branch value for a
--   given causal hash.
checkBranchExistsForCausalHash :: CausalHash -> Transaction Bool

-- | A namespace rendered as a path, no leading <a>.</a> E.g. "base.data"
type NamespaceText = Text
type TextPathSegments = [Text]
data JsonParseFailure
JsonParseFailure :: !Text -> !Text -> JsonParseFailure
[$sel:bytes:JsonParseFailure] :: JsonParseFailure -> !Text
[$sel:failure:JsonParseFailure] :: JsonParseFailure -> !Text
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Queries.UnexpectedSchemaVersion
instance GHC.Show.Show U.Codebase.Sqlite.Queries.UnexpectedSchemaVersion
instance GHC.Classes.Ord U.Codebase.Sqlite.Queries.EntityLocation
instance GHC.Show.Show U.Codebase.Sqlite.Queries.EntityLocation
instance GHC.Classes.Eq U.Codebase.Sqlite.Queries.EntityLocation
instance GHC.Classes.Eq U.Codebase.Sqlite.Queries.LoadRemoteBranchFlag
instance GHC.Show.Show U.Codebase.Sqlite.Queries.LoadRemoteBranchFlag
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Queries.EmptyName
instance GHC.Show.Show U.Codebase.Sqlite.Queries.EmptyName
instance GHC.Classes.Eq U.Codebase.Sqlite.Queries.EmptyName
instance Unison.Sqlite.Exception.SqliteExceptionReason U.Codebase.Sqlite.Queries.JsonParseFailure
instance GHC.Show.Show U.Codebase.Sqlite.Queries.JsonParseFailure

module U.Codebase.Sqlite.Operations

-- | Load the causal hash at the given path from the provided root, if
--   Nothing, use the codebase root.
loadCausalHashAtPath :: CausalHash -> [NameSegment] -> Transaction (Maybe CausalHash)

-- | Expect the causal hash at the given path from the provided root, if
--   Nothing, use the codebase root.
expectCausalHashAtPath :: CausalHash -> [NameSegment] -> Transaction CausalHash
loadCausalBranchAtPath :: CausalHash -> [NameSegment] -> Transaction (Maybe (CausalBranch Transaction))
loadBranchAtPath :: CausalHash -> [NameSegment] -> Transaction (Maybe (Branch Transaction))
saveBranch :: HashHandle -> CausalBranch Transaction -> Transaction (BranchObjectId, CausalHashId)
saveBranchV3 :: HashHandle -> CausalBranchV3 Transaction -> Transaction (BranchObjectId, CausalHashId)
loadCausalBranchByCausalHash :: CausalHash -> Transaction (Maybe (CausalBranch Transaction))
expectCausalBranchByCausalHash :: CausalHash -> Transaction (CausalBranch Transaction)
expectBranchByCausalHashId :: CausalHashId -> Transaction (Branch Transaction)
expectBranchByBranchHash :: BranchHash -> Transaction (Branch Transaction)
expectBranchByBranchHashId :: BranchHashId -> Transaction (Branch Transaction)

-- | Looks up statistics for a given branch, if none exist, we compute them
--   and save them then return them.
expectNamespaceStatsByHash :: BranchHash -> Transaction NamespaceStats

-- | Looks up statistics for a given branch, if none exist, we compute them
--   and save them then return them.
expectNamespaceStatsByHashId :: BranchHashId -> Transaction NamespaceStats

-- | Get the causal hash which would be the result of squashing the
--   provided branch hash. Returns Nothing if we haven't computed it
--   before.
tryGetSquashResult :: BranchHash -> Transaction (Maybe CausalHash)

-- | Saves the result of a squash
saveSquashResult :: BranchHash -> CausalHash -> Transaction ()
saveTermComponent :: HashHandle -> Maybe ByteString -> Hash -> [(Term Symbol, Type Symbol)] -> Transaction ObjectId
loadTermComponent :: Hash -> MaybeT Transaction [(Term Symbol, Type Symbol)]
loadTermByReference :: Id -> MaybeT Transaction (Term Symbol)
loadTypeOfTermByTermReference :: Id -> MaybeT Transaction (Type Symbol)
saveDeclComponent :: HashHandle -> Maybe ByteString -> Hash -> [Decl Symbol] -> Transaction ObjectId
loadDeclComponent :: Hash -> MaybeT Transaction [Decl Symbol]
loadDeclByReference :: Id -> MaybeT Transaction (Decl Symbol)
expectDeclByReference :: Id -> Transaction (Decl Symbol)
expectDeclNumConstructors :: Id -> Transaction Int

-- | Get the <a>DeclType</a> of a <a>Id</a>.
expectDeclTypeById :: Id -> Transaction DeclType
getCycleLen :: Hash -> Transaction (Maybe Word64)
savePatch :: HashHandle -> PatchHash -> Patch -> Transaction PatchObjectId
expectPatch :: PatchObjectId -> Transaction Patch
objectExistsForHash :: Hash -> Transaction Bool
saveWatch :: WatchKind -> Id -> Term Symbol -> Transaction ()

-- | returns Nothing if the expression isn't cached.
loadWatch :: WatchKind -> Id -> MaybeT Transaction (Term Symbol)
listWatches :: WatchKind -> Transaction [Id]

-- | Delete all watches that were put by <tt>putWatch</tt>.
clearWatches :: Transaction ()
before :: CausalHash -> CausalHash -> Transaction (Maybe Bool)
lca :: CausalHash -> CausalHash -> Transaction (Maybe CausalHash)
componentReferencesByPrefix :: ObjectType -> Text -> Maybe Pos -> Transaction [Id]
termReferentsByPrefix :: Text -> Maybe Word64 -> Transaction [Id]
declReferentsByPrefix :: Text -> Maybe Pos -> Maybe ConstructorId -> Transaction [(Hash, Pos, DeclType, [ConstructorId])]
causalHashesByPrefix :: ShortCausalHash -> Transaction (Set CausalHash)
directDependenciesOfScope :: DefnsF Set TermReferenceId TypeReferenceId -> Transaction (DefnsF Set TermReference TypeReference)

-- | returns a list of known definitions referencing <tt>r</tt>
dependents :: DependentsSelector -> Reference -> Transaction (Set Id)

-- | returns a list of known definitions referencing <tt>h</tt>
dependentsOfComponent :: Hash -> Transaction (Set Id)

-- | `directDependentsWithinScope scope query` returns all direct
--   dependents of <tt>query</tt> that are in <tt>scope</tt> (not including
--   <tt>query</tt> itself).
directDependentsWithinScope :: Set Id -> Set Reference -> Transaction (DefnsF Set TermReferenceId TypeReferenceId)

-- | `transitiveDependentsWithinScope scope query` returns all transitive
--   dependents of <tt>query</tt> that are in <tt>scope</tt> (not including
--   <tt>query</tt> itself).
transitiveDependentsWithinScope :: Set Id -> Set Reference -> Transaction (DefnsF Set TermReferenceId TypeReferenceId)
addTypeToIndexForTerm :: Id -> Reference -> Transaction ()
termsHavingType :: Reference -> Transaction (Set Id)
filterTermsByReferenceHavingType :: TypeReference -> [Id] -> Transaction [Id]
filterTermsByReferentHavingType :: TypeReference -> [Id] -> Transaction [Id]
addTypeMentionsToIndexForTerm :: Id -> Set Reference -> Transaction ()
termsMentioningType :: Reference -> Transaction (Set Id)

-- | Get all the term and type names for the given namespace from the
--   lookup table. Requires that an index for this branch hash already
--   exists, which is currently only true on Share.
allNamesInPerspective :: NamesPerspective -> Transaction NamesInPerspective
data NamesInPerspective
NamesInPerspective :: [NamedRef (Referent, Maybe ConstructorType)] -> [NamedRef Reference] -> NamesInPerspective
[$sel:termNamesInPerspective:NamesInPerspective] :: NamesInPerspective -> [NamedRef (Referent, Maybe ConstructorType)]
[$sel:typeNamesInPerspective:NamesInPerspective] :: NamesInPerspective -> [NamedRef Reference]

-- | Any time we need to lookup or search names we need to know what the
--   scope of that search should be. This can be complicated to keep track
--   of, so this is a helper type to make it easy to pass around.
--   
--   You should use <a>namesPerspectiveForRootAndPath</a> to construct this
--   type.
--   
--   E.g. if we're in loose code, we need to search the correct name lookup
--   for the user's perspective. If their perspective is
--   "myprojects.json.latest.lib.base.data.List", we need to search names
--   using the name index mounted at "myprojects.json.latest.lib.base".
--   
--   The NamesPerspective representing this viewpoint would be:
--   
--   @<tt> NamesPerspective { nameLookupBranchHashId = #libbasehash ,
--   pathToMountedNameLookup = ["myprojects.json", "latest", "lib", "base"]
--   , relativePerspective = ["data", <a>List</a>] } </tt>@
data NamesPerspective
NamesPerspective :: BranchHashId -> PathSegments -> PathSegments -> NamesPerspective

-- | The branch hash of the name lookup we'll use for queries
[$sel:nameLookupBranchHashId:NamesPerspective] :: NamesPerspective -> BranchHashId

-- | Where the name lookup is mounted relative to the root branch
[$sel:pathToMountedNameLookup:NamesPerspective] :: NamesPerspective -> PathSegments

-- | The path to the perspective relative to the current name lookup
[$sel:relativePerspective:NamesPerspective] :: NamesPerspective -> PathSegments

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of a names for a given Referent.
termNamesForRefWithinNamespace :: NamesPerspective -> Referent -> Maybe ReversedName -> Transaction [ReversedName]

-- | NOTE: requires that the codebase has an up-to-date name lookup index.
--   As of writing, this is only true on Share.
--   
--   Get the list of a names for a given Reference, with an optional
--   required suffix.
typeNamesForRefWithinNamespace :: NamesPerspective -> Reference -> Maybe ReversedName -> Transaction [ReversedName]
termNamesBySuffix :: NamesPerspective -> ReversedName -> Transaction [NamedRef (Referent, Maybe ConstructorType)]
typeNamesBySuffix :: NamesPerspective -> ReversedName -> Transaction [NamedRef Reference]
termRefsForExactName :: NamesPerspective -> ReversedName -> Transaction [NamedRef (Referent, Maybe ConstructorType)]
typeRefsForExactName :: NamesPerspective -> ReversedName -> Transaction [NamedRef Reference]

-- | Searches all dependencies transitively looking for the provided ref
--   within the provided namespace. Prefer
--   <a>termNamesForRefWithinNamespace</a> in most cases. This is slower
--   and only necessary when resolving the name of refs when you don't know
--   which dependency it may exist in.
--   
--   Searching transitive dependencies is exponential so we want to replace
--   this with a more efficient approach as soon as possible.
--   
--   Note: this returns the first name it finds by searching in order of:
--   Names in the current namespace, then names in the current namespace's
--   dependencies, then through the current namespace's dependencies'
--   dependencies, etc.
recursiveTermNameSearch :: NamesPerspective -> Referent -> Transaction (Maybe ReversedName)

-- | Searches all dependencies transitively looking for the provided ref
--   within the provided namespace. Prefer
--   <a>typeNamesForRefWithinNamespace</a> in most cases. This is slower
--   and only necessary when resolving the name of references when you
--   don't know which dependency it may exist in.
--   
--   Searching transitive dependencies is exponential so we want to replace
--   this with a more efficient approach as soon as possible.
--   
--   Note: this returns the first name it finds by searching in order of:
--   Names in the current namespace, then names in the current namespace's
--   dependencies, then through the current namespace's dependencies'
--   dependencies, etc.
recursiveTypeNameSearch :: NamesPerspective -> Reference -> Transaction (Maybe ReversedName)

-- | Check whether we've already got an index for a given branch hash.
checkBranchHashNameLookupExists :: BranchHash -> Transaction Bool

-- | Apply a set of name updates to an existing index.
buildNameLookupForBranchHash :: Maybe BranchHash -> BranchHash -> ((([NamedRef (Referent, Maybe ConstructorType)], [NamedRef Referent]) -> ([NamedRef Reference], [NamedRef Reference]) -> Transaction ()) -> Transaction ()) -> Transaction ()

-- | Save a list of (mount-path, branch hash) mounts for the provided name
--   lookup index branch hash.
--   
--   E.g. associateNameLookupMounts #roothash [(["lib", "base"],
--   #basehash)]
associateNameLookupMounts :: BranchHash -> [(PathSegments, BranchHash)] -> Transaction ()

-- | Get the name within the provided namespace that has the longest
--   matching suffix with the provided name, but a different ref. This is a
--   bit of a hack but allows us to shortcut suffixification. We can clean
--   this up if we make a custom PPE type just for sqlite pretty printing,
--   but for now this works fine.
longestMatchingTermNameForSuffixification :: NamesPerspective -> NamedRef Referent -> Transaction (Maybe (NamedRef (Referent, Maybe ConstructorType)))

-- | Get the name within the provided namespace that has the longest
--   matching suffix with the provided name, but a different ref. This is a
--   bit of a hack but allows us to shortcut suffixification. We can clean
--   this up if we make a custom PPE type just for sqlite pretty printing,
--   but for now this works fine.
longestMatchingTypeNameForSuffixification :: NamesPerspective -> NamedRef Reference -> Transaction (Maybe (NamedRef Reference))

-- | Delete any name lookup that's not in the provided list.
--   
--   This can be used to garbage collect unreachable name lookups.
deleteNameLookupsExceptFor :: Set BranchHash -> Transaction ()

-- | Search for term or type names which contain the provided list of
--   segments in order. Search is case insensitive.
fuzzySearchDefinitions :: Bool -> NamesPerspective -> Int -> [Text] -> Transaction ([NamedRef (Referent, Maybe ConstructorType)], [NamedRef Reference])

-- | Determine which nameLookup is the closest parent of the provided
--   perspective.
--   
--   Returns (rootBranchId of the closest parent index, namespace that
--   index is mounted at, location of the perspective within the mounted
--   namespace)
--   
--   E.g. If your namespace is "lib.distributed.lib.base.data.List", you'd
--   get back (rootBranchId of the lib.distributed.lib.base name lookup,
--   "lib.distributed.lib.base", "data.List")
--   
--   Or if your namespace is "subnamespace.user", you'd get back (the
--   rootBranchId you provided, "", "subnamespace.user")
namesPerspectiveForRootAndPath :: BranchHash -> PathSegments -> Transaction NamesPerspective
expectProjectAndBranchNames :: ProjectId -> ProjectBranchId -> Transaction (ProjectName, ProjectBranchName)
expectProjectBranchHead :: ProjectId -> ProjectBranchId -> Transaction CausalHash

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getDeprecatedRootReflog :: Int -> Transaction [Entry CausalHash Text]

-- | Gets the specified number of reflog entries for the given project in
--   chronological order, most recent first.
getProjectReflog :: Int -> ProjectId -> Transaction [Entry Project ProjectBranch CausalHash]

-- | Gets the specified number of reflog entries for the specified
--   ProjectBranch in chronological order, most recent first.
getProjectBranchReflog :: Int -> ProjectBranchId -> Transaction [Entry Project ProjectBranch CausalHash]

-- | Gets the specified number of reflog entries in chronological order,
--   most recent first.
getGlobalReflog :: Int -> Transaction [Entry Project ProjectBranch CausalHash]
appendProjectReflog :: Entry ProjectId ProjectBranchId CausalHash -> Transaction ()
expectDbBranch :: BranchObjectId -> Transaction DbBranch

-- | Save a <a>DbBranch</a>, given its hash (which the caller is expected
--   to produce from the branch).
--   
--   Note: long-standing question: should this package depend on the
--   hashing package? (If so, we would only need to take the DbBranch, and
--   hash internally).
saveDbBranch :: HashHandle -> BranchHash -> NamespaceStats -> DbBranchV -> Transaction BranchObjectId

-- | Variant of <a>saveDbBranch</a> that might be preferred by callers that
--   already have a hash id, not a hash.
saveDbBranchUnderHashId :: HashHandle -> BranchHashId -> NamespaceStats -> DbBranchV -> Transaction BranchObjectId
expectDbPatch :: PatchObjectId -> Transaction Patch
saveDbPatch :: HashHandle -> PatchHash -> PatchFormat -> Transaction PatchObjectId

-- | Expect a branch value given its causal hash id.
expectDbBranchByCausalHashId :: CausalHashId -> Transaction DbBranch
namespaceStatsForDbBranch :: DbBranchV -> Transaction NamespaceStats
c2sReferenceId :: Id -> Transaction Id
c2sReferentId :: Id -> Transaction Id

-- | produces a diff diff = full - ref; full = diff + ref
diffPatch :: LocalPatch -> LocalPatch -> LocalPatchDiff
decodeTermElementWithType :: Pos -> ByteString -> Either DecodeError (LocalIds, Term, Type)
loadTermWithTypeByReference :: Id -> MaybeT Transaction (Term Symbol, Type Symbol)
s2cTermWithType :: LocalIds -> Term -> Type -> Transaction (Term Symbol, Type Symbol)

-- | Unlocalize a decl.
s2cDecl :: LocalIds -> Decl Symbol -> Transaction (Decl Symbol)
declReferencesByPrefix :: Text -> Maybe Word64 -> Transaction [Id]
namespaceHashesByPrefix :: ShortNamespaceHash -> Transaction (Set BranchHash)

-- | returns empty set for unknown inputs; doesn't distinguish between term
--   and decl
derivedDependencies :: Id -> Transaction (Set Id)
data BranchV m
BranchV2 :: !Branch m -> BranchV m
BranchV3 :: !BranchV3 m -> BranchV m
data DbBranchV
DbBranchV2 :: !DbBranch -> DbBranchV
DbBranchV3 :: !DbBranchV3 -> DbBranchV
instance GHC.Show.Show U.Codebase.Sqlite.Operations.NamesPerspective
instance GHC.Classes.Eq U.Codebase.Sqlite.Operations.NamesPerspective

module U.Codebase.Causal.Squash
squashCausal :: HashHandle -> CausalBranch Transaction -> Transaction (CausalBranch Transaction)

module U.Codebase.Branch
nonEmptyChildren :: Branch m -> Transaction (Map NameSegment (CausalBranch m))
childStats :: Branch m -> Transaction (Map NameSegment (CausalBranch m, NamespaceStats))
isEmpty :: Branch m -> Transaction Bool
