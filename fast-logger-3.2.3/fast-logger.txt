-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A fast logging system
--   
--   A fast logging system for Haskell
@package fast-logger
@version 3.2.3

module System.Log.FastLogger.Types
type TimeFormat = ByteString

-- | Type aliaes for date format and formatted date.
type FormattedTime = ByteString

module System.Log.FastLogger.File

-- | The spec for logging files
data FileLogSpec
FileLogSpec :: FilePath -> Integer -> Int -> FileLogSpec
[log_file] :: FileLogSpec -> FilePath

-- | Max log file size (in bytes) before requiring rotation.
[log_file_size] :: FileLogSpec -> Integer

-- | Max number of rotated log files to keep around before overwriting the
--   oldest one.
[log_backup_number] :: FileLogSpec -> Int

-- | The spec for time based rotation. It supports post processing of log
--   files. Does not delete any logs. Example:
--   
--   <pre>
--   timeRotate fname = LogFileTimedRotate
--                  (TimedFileLogSpec fname timeFormat sametime compressFile)
--                  defaultBufSize
--      where
--          timeFormat = "%FT%H%M%S"
--          sametime = (==) <tt>on</tt> C8.takeWhile (/=<tt>T</tt>)
--          compressFile fp = void . forkIO $
--              callProcess "tar" [ "--remove-files", "-caf", fp &lt;&gt; ".gz", fp ]
--   </pre>
data TimedFileLogSpec
TimedFileLogSpec :: FilePath -> TimeFormat -> (FormattedTime -> FormattedTime -> Bool) -> (FilePath -> IO ()) -> TimedFileLogSpec

-- | base file path
[timed_log_file] :: TimedFileLogSpec -> FilePath

-- | time format to prepend
[timed_timefmt] :: TimedFileLogSpec -> TimeFormat

-- | function that compares two formatted times as specified by
--   timed_timefmt and decides if a new rotation is supposed to begin
[timed_same_timeframe] :: TimedFileLogSpec -> FormattedTime -> FormattedTime -> Bool

-- | processing function called asynchronously after a file is added to the
--   rotation
[timed_post_process] :: TimedFileLogSpec -> FilePath -> IO ()

-- | Checking if a log file can be written.
check :: FilePath -> IO ()

-- | Rotating log files.
rotate :: FileLogSpec -> IO ()

-- | Prefix file name with formatted time
prefixTime :: FormattedTime -> FilePath -> FilePath


-- | Formatting time is slow. This package provides mechanisms to cache
--   formatted date.
module System.Log.FastLogger.Date

-- | Make <a>IO</a> action which get cached formatted local time. Use this
--   to avoid the cost of frequently time formatting by caching an auto
--   updating formatted time, this cache update every 1 second. more detail
--   in <a>Control.AutoUpdate</a>
newTimeCache :: TimeFormat -> IO (IO FormattedTime)

-- | A simple time cache using format <tt>"%d<i>%b</i>%Y:%T %z"</tt>
simpleTimeFormat :: TimeFormat

-- | A simple time cache using format <tt>"%d-%b-%Y %T"</tt>
simpleTimeFormat' :: TimeFormat

module System.Log.FastLogger.LoggerSet

-- | A set of loggers. The number of loggers is the capabilities of GHC
--   RTS. You can specify it with "+RTS -N&lt;x&gt;". A buffer is prepared
--   for each capability.
data LoggerSet

-- | Creating a new <a>LoggerSet</a> using a file.
--   
--   Uses <tt>numCapabilties</tt> many buffers, which will result in log
--   output that is not ordered by time (see <a>newFileLoggerSetN</a>).
newFileLoggerSet :: BufSize -> FilePath -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using a file, using only the given
--   number of capabilites.
--   
--   Giving <tt>mn = Just 1</tt> scales less well on multi-core machines,
--   but provides time-ordered output.
newFileLoggerSetN :: BufSize -> Maybe Int -> FilePath -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using stdout.
newStdoutLoggerSet :: BufSize -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using stdout, with the given number of
--   buffers (see <a>newFileLoggerSetN</a>).
newStdoutLoggerSetN :: BufSize -> Maybe Int -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using stderr.
newStderrLoggerSet :: BufSize -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using stderr, with the given number of
--   buffers (see <a>newFileLoggerSetN</a>).
newStderrLoggerSetN :: BufSize -> Maybe Int -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a>. If <a>Nothing</a> is specified to the
--   second argument, stdout is used. Please note that the minimum
--   <a>BufSize</a> is 1.

-- | <i>Deprecated: Use newFileLoggerSet etc instead</i>
newLoggerSet :: BufSize -> Maybe Int -> Maybe FilePath -> IO LoggerSet

-- | Creating a new <a>LoggerSet</a> using a FD.
newFDLoggerSet :: BufSize -> Maybe Int -> Maybe FilePath -> FD -> IO LoggerSet

-- | Renewing the internal file information in <a>LoggerSet</a>. This does
--   nothing for stdout and stderr.
renewLoggerSet :: LoggerSet -> IO ()

-- | Flushing the buffers, closing the internal file information and
--   freeing the buffers.
rmLoggerSet :: LoggerSet -> IO ()

-- | Writing a log message to the corresponding buffer. If the buffer
--   becomes full, the log messages in the buffer are written to its
--   corresponding file, stdout, or stderr.
pushLogStr :: LoggerSet -> LogStr -> IO ()

-- | Same as <a>pushLogStr</a> but also appends a newline.
pushLogStrLn :: LoggerSet -> LogStr -> IO ()

-- | Flushing log messages in buffers. This function must be called
--   explicitly when the program is being terminated.
--   
--   Note: Since version 2.1.6, this function does not need to be
--   explicitly called, as every push includes an auto-debounced flush
--   courtesy of the auto-update package. Since version 2.2.2, this
--   function can be used to force flushing outside of the debounced flush
--   calls.
flushLogStr :: LoggerSet -> IO ()

-- | Replacing the file path in <a>LoggerSet</a> and returning a new
--   <a>LoggerSet</a> and the old file path.
replaceLoggerSet :: LoggerSet -> FilePath -> (LoggerSet, Maybe FilePath)


-- | This module provides a fast logging system which scales on multicore
--   environments (i.e. +RTS -N&lt;x&gt;).
--   
--   Note: This library does not guarantee correct ordering of log messages
--   when program is run on more than one core thus users should rely more
--   on message timestamps than on their order in the log.
module System.Log.FastLogger

-- | <a>FastLogger</a> simply log <tt>logStr</tt>.
type FastLogger = LogStr -> IO ()
type LogType = LogType' LogStr

-- | Logger Type.
data LogType' a
[LogNone] :: LogType' LogStr
[LogStdout] :: BufSize -> LogType' LogStr
[LogStderr] :: BufSize -> LogType' LogStr
[LogFileNoRotate] :: FilePath -> BufSize -> LogType' LogStr
[LogFile] :: FileLogSpec -> BufSize -> LogType' LogStr
[LogFileTimedRotate] :: TimedFileLogSpec -> BufSize -> LogType' LogStr
[LogCallback] :: (v -> IO ()) -> IO () -> LogType' v

-- | Initialize a <a>FastLogger</a> without attaching timestamp a tuple of
--   logger and clean up action are returned. This type signature should be
--   read as:
--   
--   <pre>
--   newFastLogger :: LogType -&gt; IO (FastLogger, IO ())
--   </pre>
--   
--   This logger uses <tt>numCapabilities</tt> many buffers, and thus does
--   not provide time-ordered output. For time-ordered output, use
--   <a>newFastLogger1</a>.
newFastLogger :: LogType' v -> IO (v -> IO (), IO ())

-- | Like <a>newFastLogger</a>, but creating a logger that uses only 1
--   internal builder. This scales less on multi-core machines and consumes
--   more memory because of an internal queue but provides time-ordered
--   output.
newFastLogger1 :: LogType' v -> IO (v -> IO (), IO ())

-- | <a>bracket</a> version of <a>newFastLogger</a>
withFastLogger :: LogType -> (FastLogger -> IO a) -> IO a

-- | <a>TimedFastLogger</a> pass <a>FormattedTime</a> to callback and
--   simply log its result. this can be used to customize how to log
--   timestamp.
--   
--   Usually, one would write a wrapper on top of <a>TimedFastLogger</a>,
--   for example:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   log :: TimedFastLogger -&gt; LogStr -&gt; IO ()
--   log logger msg = logger (\time -&gt; toLogStr (show time) &lt;&gt; " " &lt;&gt; msg &lt;&gt; "\n")
--   </pre>
type TimedFastLogger = (FormattedTime -> LogStr) -> IO ()

-- | Initialize a <a>FastLogger</a> with timestamp attached to each
--   message. a tuple of logger and clean up action are returned.
newTimedFastLogger :: IO FormattedTime -> LogType -> IO (TimedFastLogger, IO ())

-- | <a>bracket</a> version of <tt>newTimeFastLogger</tt>
withTimedFastLogger :: IO FormattedTime -> LogType -> (TimedFastLogger -> IO a) -> IO a

-- | Log message builder. Use (<a>&lt;&gt;</a>) to append two LogStr in
--   O(1).
data LogStr

-- | Types that can be converted to a <a>LogStr</a>. Instances for types
--   from the <tt>text</tt> library use a UTF-8 encoding. Instances for
--   numerical types use a decimal encoding.
class ToLogStr msg
toLogStr :: ToLogStr msg => msg -> LogStr

-- | Converting <a>LogStr</a> to <a>ByteString</a>.
fromLogStr :: LogStr -> ByteString

-- | Obtaining the length of <a>LogStr</a>.
logStrLength :: LogStr -> Int

-- | The type for buffer size of each core.
type BufSize = Int

-- | The default buffer size (4,096 bytes).
defaultBufSize :: BufSize


-- | The contents of this module can change at any time without warning.
module System.Log.FastLogger.Internal
type Buffer = Ptr Word8

-- | The type for buffer size of each core.
type BufSize = Int

-- | The default buffer size (4,096 bytes).
defaultBufSize :: BufSize
getBuffer :: BufSize -> IO Buffer
freeBuffer :: Buffer -> IO ()
toBufIOWith :: Buffer -> BufSize -> (Buffer -> Int -> IO ()) -> Builder -> IO ()
type FD = FD
closeFD :: FD -> IO ()
openFileFD :: FilePath -> IO FD
getStderrFD :: IO FD
getStdoutFD :: IO FD
writeRawBufferPtr2FD :: IORef FD -> Ptr Word8 -> Int -> IO Int
invalidFD :: FD
isFDValid :: FD -> Bool

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data () => Builder

-- | Log message builder. Use (<a>&lt;&gt;</a>) to append two LogStr in
--   O(1).
data LogStr
LogStr :: !Int -> Builder -> LogStr

-- | Obtaining the length of <a>LogStr</a>.
logStrLength :: LogStr -> Int

-- | Converting <a>LogStr</a> to <a>ByteString</a>.
fromLogStr :: LogStr -> ByteString

-- | Types that can be converted to a <a>LogStr</a>. Instances for types
--   from the <tt>text</tt> library use a UTF-8 encoding. Instances for
--   numerical types use a decimal encoding.
class ToLogStr msg
toLogStr :: ToLogStr msg => msg -> LogStr

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | A non-scale but time-ordered logger.
data SingleLogger

-- | Creating <a>SingleLogger</a>.
newSingleLogger :: BufSize -> IORef FD -> IO SingleLogger

-- | A scale but non-time-ordered logger.
data MultiLogger

-- | Creating <a>MultiLogger</a>. The first argument is the number of the
--   internal builders.
newMultiLogger :: Int -> BufSize -> IORef FD -> IO MultiLogger

-- | Writting <a>LogStr</a> using a buffer in blocking mode. The size of
--   <a>LogStr</a> must be smaller or equal to the size of buffer.
writeLogStr :: Buffer -> IORef FD -> LogStr -> IO ()

-- | Writting <a>LogStr</a> using a temporary buffer.
writeBigLogStr :: IORef FD -> LogStr -> IO ()

-- | A class for internal loggers.
class Loggers a
stopLoggers :: Loggers a => a -> IO ()
pushLog :: Loggers a => a -> LogStr -> IO ()
flushAllLog :: Loggers a => a -> IO ()
