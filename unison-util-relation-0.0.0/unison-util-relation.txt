-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util-relation
@version 0.0.0

module Unison.Util.Relation

-- | This implementation avoids using <tt>"Set (a,b)"</tt> because it it is
--   necessary to search for an item without knowing both <tt>D</tt> and
--   <tt>R</tt>.
--   
--   In <a>Set</a>, you must know both values to search.
--   
--   Thus, we have are two maps to updated together.
--   
--   <ol>
--   <li>Always be careful with the associated set of the key.</li>
--   <li>If you union two relations, apply union to the set of values.</li>
--   <li>If you subtract, take care when handling the set of values.</li>
--   </ol>
--   
--   As a multi-map, each key is associated with a Set of values v.
--   
--   We do not allow the associations with the <a>empty</a> Set.
data Relation a b

-- | Construct a relation with no elements.
empty :: Relation a b

-- | Builds a <a>Relation</a> consiting of an association between:
--   <tt>x</tt> and <tt>y</tt>.
singleton :: a -> b -> Relation a b

-- | The list must be formatted like: [(k1, v1), (k2, v2),..,(kn, vn)].
fromList :: (Ord a, Ord b) => [(a, b)] -> Relation a b
fromManyDom :: (Foldable f, Ord a, Ord b) => f a -> b -> Relation a b
fromManyRan :: (Foldable f, Ord a, Ord b) => a -> f b -> Relation a b
fromMap :: (Ord a, Ord b) => Map a b -> Relation a b
fromMultimap :: (Ord a, Ord b) => Map a (Set b) -> Relation a b
fromSet :: (Ord a, Ord b) => Set (a, b) -> Relation a b

-- | Construct a relation from a mapping from the domain and range
--   mappings.
--   
--   <i>Precondition</i>: the multimaps together form a valid relation;
--   i.e. if <tt>x</tt> is related to <tt>y</tt> in one map then <tt>y</tt>
--   is related to <tt>x</tt> in the other.
--   
--   <i>O(1)</i>.
unsafeFromMultimaps :: Map a (Set b) -> Map b (Set a) -> Relation a b

-- | True if the relation <tt>r</tt> is the <a>empty</a> relation.
--   
--   <i>O(1)</i>.
null :: Relation a b -> Bool

-- | <tt>size r</tt> returns the number of tuples in the relation.
size :: Relation a b -> Int

-- | True if the relation contains the association <tt>x</tt> and
--   <tt>y</tt>
member :: (Ord a, Ord b) => a -> b -> Relation a b -> Bool

-- | True if the relation <i>does not</i> contain the association
--   <tt>x</tt> and <tt>y</tt>
notMember :: (Ord a, Ord b) => a -> b -> Relation a b -> Bool

-- | True if the element exists in the domain.
memberDom :: Ord a => a -> Relation a b -> Bool

-- | True if the element exists in the range.
memberRan :: Ord b => b -> Relation a b -> Bool
lookupDom :: Ord a => a -> Relation a b -> Set b
lookupRan :: Ord b => b -> Relation a b -> Set a

-- | True if a value appears more than one time in the relation.
manyDom :: Ord a => a -> Relation a b -> Bool
manyRan :: Ord b => b -> Relation a b -> Bool

-- | <pre>
--   (Case b &lt;| r a)
--   </pre>
(<$|) :: (Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set a

-- | <pre>
--   ( Case a |&gt; r b )
--   </pre>
(|$>) :: (Ord a, Ord b) => Set a -> Set b -> Relation a b -> Set b
searchDom :: (Ord a, Ord b) => (a -> Ordering) -> Relation a b -> Set b
searchDomG :: (Ord a, Monoid c) => (a -> Set b -> c) -> (a -> Ordering) -> Relation a b -> c
searchRan :: (Ord a, Ord b) => (b -> Ordering) -> Relation a b -> Set a
filter :: (Ord a, Ord b) => ((a, b) -> Bool) -> Relation a b -> Relation a b
filterM :: (Applicative m, Ord a, Ord b) => ((a, b) -> m Bool) -> Relation a b -> m (Relation a b)
filterDom :: (Ord a, Ord b) => (a -> Bool) -> Relation a b -> Relation a b
filterDomM :: (Applicative m, Ord a, Ord b) => (a -> m Bool) -> Relation a b -> m (Relation a b)

-- | Restricts the relation to domain elements having multiple range
--   elements
filterManyDom :: (Ord a, Ord b) => Relation a b -> Relation a b
filterRan :: (Ord a, Ord b) => (b -> Bool) -> Relation a b -> Relation a b
filterRanM :: (Applicative m, Ord a, Ord b) => (b -> m Bool) -> Relation a b -> m (Relation a b)

-- | Named version of (<a>&lt;||</a>).
subtractDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b

-- | Restrict the domain to not include these <tt>a</tt>s.
(<||) :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b

-- | Named version of (<a>||&gt;</a>).
subtractRan :: (Ord a, Ord b) => Set b -> Relation a b -> Relation a b

-- | Restrict the range to not include these <tt>b</tt>s.
(||>) :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b

-- | Domain restriction for a relation. Modeled on z.
restrictDom :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b

-- | Domain restriction for a relation. Modeled on z.
(<|) :: (Ord a, Ord b) => Set a -> Relation a b -> Relation a b

-- | Range restriction for a relation. Modeled on z.
restrictRan :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b

-- | Range restriction for a relation. Modeled on z.
(|>) :: (Ord a, Ord b) => Relation a b -> Set b -> Relation a b
collectRan :: Ord a => Ord c => (b -> Maybe c) -> Relation a b -> Relation a c

-- | This fragment provided by:
--   
--   <pre>
--   Module      :  Data.Map
--   Copyright   :  (c) Daan Leijen 2002
--                  (c) Andriy Palamarchuk 2008
--   License     :  BSD-style
--   Maintainer  :  libraries@haskell.org
--   Stability   :  provisional
--   Portability :  portable
--   </pre>
foldlStrict :: (a -> b -> a) -> a -> [b] -> a
map :: (Ord a, Ord b, Ord c, Ord d) => ((a, b) -> (c, d)) -> Relation a b -> Relation c d
mapDom :: (Ord a, Ord a', Ord b) => (a -> a') -> Relation a b -> Relation a' b

-- | Like <a>mapDom</a>, but takes a function that must be monotonic; i.e.
--   <tt>compare x y == compare (f x) (f y)</tt>.
mapDomMonotonic :: (Ord a, Ord a', Ord b) => (a -> a') -> Relation a b -> Relation a' b
mapRan :: (Ord a, Ord b, Ord b') => (b -> b') -> Relation a b -> Relation a b'

-- | Like <a>mapRan</a>, but takes a function that must be monotonic; i.e.
--   <tt>compare x y == compare (f x) (f y)</tt>.
mapRanMonotonic :: (Ord a, Ord b, Ord b') => (b -> b') -> Relation a b -> Relation a b'
bimap :: (Ord a, Ord b, Ord c, Ord d) => (a -> c) -> (b -> d) -> Relation a b -> Relation c d
bitraverse :: (Applicative f, Ord a, Ord b, Ord c, Ord d) => (a -> f c) -> (b -> f d) -> Relation a b -> f (Relation c d)
swap :: Relation a b -> Relation b a

-- | Insert a relation <tt> x </tt> and <tt> y </tt> in the relation <tt> r
--   </tt>
insert :: (Ord a, Ord b) => a -> b -> Relation a b -> Relation a b
insertManyDom :: (Foldable f, Ord a, Ord b) => f a -> b -> Relation a b -> Relation a b
insertManyRan :: (Foldable f, Ord a, Ord b) => a -> f b -> Relation a b -> Relation a b

-- | Delete an association in the relation.
delete :: (Ord a, Ord b) => a -> b -> Relation a b -> Relation a b
deleteDom :: (Ord a, Ord b) => a -> Relation a b -> Relation a b
deleteRan :: (Ord a, Ord b) => b -> Relation a b -> Relation a b
deleteDomWhere :: (Ord a, Ord b) => (a -> Bool) -> b -> Relation a b -> Relation a b
deleteRanWhere :: (Ord a, Ord b) => (b -> Bool) -> a -> Relation a b -> Relation a b

-- | <tt>replaceDom x y r</tt> replaces all <tt>(x, _)</tt> with <tt>(y,
--   _)</tt> in <tt>r</tt>.
replaceDom :: (Ord a, Ord b) => a -> a -> Relation a b -> Relation a b

-- | <tt>replaceRan x y r</tt> replaces all <tt>(_, x)</tt> with <tt>(_,
--   y)</tt> in <tt>r</tt>.
replaceRan :: (Ord a, Ord b) => b -> b -> Relation a b -> Relation a b
updateDom :: (Ord a, Ord b) => (a -> a) -> b -> Relation a b -> Relation a b
updateRan :: (Ord a, Ord b) => (b -> b) -> a -> Relation a b -> Relation a b

-- | Compute the difference of two relations.
difference :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b

-- | Like <a>difference</a>, but returns <tt>Nothing</tt> if the difference
--   is empty.
difference1 :: (Ord a, Ord b) => Relation a b -> Relation a b -> Maybe (Relation a b)
intersection :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b
joinDom :: (Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Relation a (b, c)
joinRan :: (Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Relation (a, b) c

-- | <tt>innerJoinDomMultimaps xs ys</tt> returns the "inner join" of the
--   domains of <tt>xs</tt> and <tt>ys</tt>, which has intersection-like
--   semantics:
--   
--   <ul>
--   <li><tt>a</tt>s that do not exist in both <tt>xs</tt> and <tt>ys</tt>
--   are dropped.</li>
--   <li>The <tt>a</tt>s that remain are therefore associated with
--   non-empty sets of <tt>b</tt>s and <tt>c</tt>s.</li>
--   </ul>
--   
--   <i>O(a2 * log(a1</i>a2 + 1)), a1 &lt;= a2<i>, where </i>a1<i> and
--   </i>a2/ are the numbers of elements in each relation's domain.
innerJoinDomMultimaps :: (Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Map a (Set b, Set c)

-- | <tt>innerJoinRanMultimaps xs ys</tt> returns the "inner join" of the
--   ranges of <tt>xs</tt> and <tt>ys</tt>. See
--   <a>innerJoinDomMultimaps</a> for more info.
--   
--   <i>O(c2 * log(c1</i>c2 + 1)), c1 &lt;= c2<i>, where </i>c1<i> and
--   </i>c2/ are the numbers of elements in each relation's range.
innerJoinRanMultimaps :: (Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Map c (Set a, Set b)
outerJoinDomMultimaps :: (Ord a, Ord b, Ord c) => Relation a b -> Relation a c -> Map a (Set b, Set c)
outerJoinRanMultimaps :: (Ord a, Ord b, Ord c) => Relation a c -> Relation b c -> Map c (Set a, Set b)

-- | The <a>Relation</a> that results from the union of two relations:
--   <tt>r</tt> and <tt>s</tt>.
union :: (Ord a, Ord b) => Relation a b -> Relation a b -> Relation a b

-- | Union a list of relations using the <a>empty</a> relation.
unions :: (Ord a, Ord b) => [Relation a b] -> Relation a b
unionDomainWith :: (Ord a, Ord b) => (a -> Set b -> Set b -> Set b) -> Relation a b -> Relation a b -> Relation a b
unionRangeWith :: (Ord a, Ord b) => (b -> Set a -> Set a -> Set a) -> Relation a b -> Relation a b -> Relation a b

-- | Builds a List from a Relation.
toList :: Relation a b -> [(a, b)]
domain :: Relation a b -> Map a (Set b)
range :: Relation a b -> Map b (Set a)
toMap :: Ord a => Relation a b -> Maybe (Map a b)
toMultimap :: Relation a b -> Map a (Set b)
toUnzippedMultimap :: Ord a => Ord b => Ord c => Relation a (b, c) -> Map a (Set b, Set c)

-- | Returns the domain in the relation, as a Set, in its entirety.
--   
--   <i>O(a)</i>.
dom :: Relation a b -> Set a

-- | Returns the range of the relation, as a Set, in its entirety.
--   
--   <i>O(b)</i>.
ran :: Relation a b -> Set b

-- | Builds a Set from a Relation
toSet :: (Ord a, Ord b) => Relation a b -> Set (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Unison.Util.Relation.Relation a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Unison.Util.Relation.Relation a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Unison.Util.Relation.Relation a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Unison.Util.Relation.Relation a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Base.Monoid (Unison.Util.Relation.Relation a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Base.Semigroup (Unison.Util.Relation.Relation a b)


-- | A left-unique relation.
module Unison.Util.BiMultimap

-- | A left-unique relation.
--   
--   "Left-unique" means that for all <tt>(x, y)</tt> in the relation,
--   <tt>y</tt> is related only to <tt>x</tt>.
data BiMultimap a b

-- | An empty left-unique relation.
empty :: (Ord a, Ord b) => BiMultimap a b

-- | Is a left-unique relation empty?
isEmpty :: BiMultimap a b -> Bool
memberDom :: Ord a => a -> BiMultimap a b -> Bool

-- | Look up the set of <tt>b</tt> related to an <tt>a</tt>.
--   
--   <i>O(log a)</i>.
lookupDom :: Ord a => a -> BiMultimap a b -> Set b

-- | Look up the <tt>a</tt> related to a <tt>b</tt>.
--   
--   <i>O(log b)</i>.
lookupRan :: Ord b => b -> BiMultimap a b -> Maybe a

-- | Look up the <tt>a</tt> related to a <tt>b</tt>.
--   
--   <i>O(log b)</i>.
unsafeLookupRan :: Ord b => b -> BiMultimap a b -> a

-- | Look up the preimage of a <tt>b</tt>, that is, the set of <tt>b</tt>
--   that are related to the same <tt>a</tt> as the input <tt>b</tt>.
--   
--   /O(log a + log b)
lookupPreimage :: (Ord a, Ord b) => b -> BiMultimap a b -> Set b

-- | Traverse over the domain a left-unique relation.
--   
--   The caller is responsible for maintaining left-uniqueness.
unsafeTraverseDom :: forall a b m x. (Monad m, Ord b, Ord x) => (a -> m b) -> BiMultimap a x -> m (BiMultimap b x)

-- | Filter a left-unique relation, keeping only members <tt>(a, b)</tt>
--   that satisfy a predicate.
filter :: (Ord a, Ord b) => (a -> b -> Bool) -> BiMultimap a b -> BiMultimap a b

-- | Filter a left-unique relation, keeping only members <tt>(a, b)</tt>
--   whose <tt>a</tt> satisfies a predicate.
filterDom :: (Ord a, Ord b) => (a -> Bool) -> BiMultimap a b -> BiMultimap a b

-- | Filter a left-unique relation, keeping only members <tt>(a, b)</tt>
--   whose <tt>a</tt> and set of <tt>b</tt> satisfies a predicate.
filterDomain :: (Ord a, Ord b) => (a -> NESet b -> Bool) -> BiMultimap a b -> BiMultimap a b

-- | Restrict a left-unique relation to only those <tt>(a, b)</tt> members
--   whose <tt>a</tt> is in the given set.
restrictDom :: (Ord a, Ord b) => Set a -> BiMultimap a b -> BiMultimap a b

-- | Restrict a left-unique relation to only those <tt>(a, b)</tt> members
--   whose <tt>b</tt> is in the given set.
restrictRan :: (Ord a, Ord b) => Set b -> BiMultimap a b -> BiMultimap a b

-- | Restrict a left-unique relation to only those <tt>(a, b)</tt> members
--   whose <tt>a</tt> is not in the given set.
withoutDom :: (Ord a, Ord b) => Set a -> BiMultimap a b -> BiMultimap a b

-- | Restrict a left-unique relation to only those <tt>(a, b)</tt> members
--   whose <tt>b</tt> is not in the given set.
withoutRan :: (Ord a, Ord b) => Set b -> BiMultimap a b -> BiMultimap a b
domain :: BiMultimap a b -> Map a (NESet b)

-- | <i>O(1)</i>.
range :: BiMultimap a b -> Map b a

-- | Construct a left-unique relation from a mapping from its left-elements
--   to set-of-right-elements. The caller is responsible for ensuring that
--   no right-element is mapped to by two different left-elements.
unsafeFromDomain :: Ord b => Map a (NESet b) -> BiMultimap a b

-- | Construct a left-unique relation from a mapping from its
--   right-elements to its left-elements.
fromRange :: (Ord a, Ord b) => Map b a -> BiMultimap a b

-- | Returns the domain of the relation, as a Set, in its entirety.
--   
--   <i>O(a)</i>.
dom :: BiMultimap a b -> Set a

-- | Returns the range of the relation, as a Set, in its entirety.
--   
--   <i>O(a)</i>.
ran :: BiMultimap a b -> Set b

-- | Convert a left-unique relation to a relation (forgetting its
--   left-uniqueness).
toRelation :: (Ord a, Ord b) => BiMultimap a b -> Relation a b

-- | Insert a pair into a left-unique relation, maintaining
--   left-uniqueness, preferring the latest inserted element.
--   
--   That is, if a left-unique relation already contains the pair <tt>(x,
--   y)</tt>, then inserting the pair <tt>(z, y)</tt> will cause the
--   <tt>(x, y)</tt> pair to be deleted.
insert :: (Ord a, Ord b) => a -> b -> BiMultimap a b -> BiMultimap a b

-- | Like <tt>insert x y</tt>, but the caller is responsible maintaining
--   left-uniqueness.
unsafeInsert :: (Ord a, Ord b) => a -> b -> BiMultimap a b -> BiMultimap a b

-- | Union two left-unique relations together.
--   
--   The caller is responsible for maintaining left-uniqueness.
unsafeUnion :: (Ord a, Ord b) => BiMultimap a b -> BiMultimap a b -> BiMultimap a b
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Unison.Util.BiMultimap.BiMultimap a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Unison.Util.BiMultimap.BiMultimap a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Unison.Util.BiMultimap.BiMultimap a b)

module Unison.Util.Relation3
data Relation3 a b c
Relation3 :: Map a (Relation b c) -> Map b (Relation a c) -> Map c (Relation a b) -> Relation3 a b c
[d1] :: Relation3 a b c -> Map a (Relation b c)
[d2] :: Relation3 a b c -> Map b (Relation a c)
[d3] :: Relation3 a b c -> Map c (Relation a b)
d1s :: Relation3 a b c -> Set a
d2s :: Relation3 a b c -> Set b
d3s :: Relation3 a b c -> Set c

-- | Project out a relation that only includes the 1st and 2nd dimensions.
d12 :: Relation3 a b c -> Relation a b

-- | Project out a relation that only includes the 1st and 3rd dimensions.
d13 :: Relation3 a b c -> Relation a c

-- | Project out a relation that only includes the 2nd and 3rd dimensions.
d23 :: Relation3 a b c -> Relation b c
filter :: (Ord a, Ord b, Ord c) => ((a, b, c) -> Bool) -> Relation3 a b c -> Relation3 a b c
mapD1 :: (Ord a, Ord a', Ord b, Ord c) => (a -> a') -> Relation3 a b c -> Relation3 a' b c

-- | Like <a>mapD1</a>, but takes a function that must be monotonic; i.e.
--   <tt>compare x y == compare (f x) (f y)</tt>.
mapD1Monotonic :: (Ord a, Ord a', Ord b, Ord c) => (a -> a') -> Relation3 a b c -> Relation3 a' b c
mapD2 :: (Ord a, Ord b, Ord b', Ord c) => (b -> b') -> Relation3 a b c -> Relation3 a b' c

-- | Like <a>mapD2</a>, but takes a function that must be monotonic; i.e.
--   <tt>compare x y == compare (f x) (f y)</tt>.
mapD2Monotonic :: (Ord a, Ord b, Ord b', Ord c) => (b -> b') -> Relation3 a b c -> Relation3 a b' c
member :: (Ord a, Ord b, Ord c) => a -> b -> c -> Relation3 a b c -> Bool
memberD2 :: Ord b => b -> Relation3 a b c -> Bool
lookupD1 :: (Ord a, Ord b, Ord c) => a -> Relation3 a b c -> Relation b c
lookupD2 :: (Ord a, Ord b, Ord c) => b -> Relation3 a b c -> Relation a c
lookupD3 :: (Ord a, Ord b, Ord c) => c -> Relation3 a b c -> Relation a b
size :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Int
toList :: Relation3 a b c -> [(a, b, c)]
toNestedList :: Relation3 a b c -> [(a, (b, c))]
nestD12 :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Relation (a, b) c
fromNestedDom :: (Ord a, Ord b, Ord c) => Relation (a, b) c -> Relation3 a b c
fromNestedRan :: (Ord a, Ord b, Ord c) => Relation a (b, c) -> Relation3 a b c
fromList :: (Ord a, Ord b, Ord c) => [(a, b, c)] -> Relation3 a b c
empty :: (Ord a, Ord b, Ord c) => Relation3 a b c
null :: Relation3 a b c -> Bool
insert :: (Ord a, Ord b, Ord c) => a -> b -> c -> Relation3 a b c -> Relation3 a b c
delete :: (Ord a, Ord b, Ord c) => a -> b -> c -> Relation3 a b c -> Relation3 a b c
insertAll :: Foldable f => Ord a => Ord b => Ord c => f (a, b, c) -> Relation3 a b c -> Relation3 a b c
deleteAll :: Foldable f => Ord a => Ord b => Ord c => f (a, b, c) -> Relation3 a b c -> Relation3 a b c

-- | Compute the difference of two relations.
difference :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Relation3 a b c -> Relation3 a b c

-- | <tt>union x y</tt> computes the union of <tt>x</tt> and <tt>y</tt>.
union :: (Ord a, Ord b, Ord c) => Relation3 a b c -> Relation3 a b c -> Relation3 a b c
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Unison.Util.Relation3.Relation3 a b c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (Unison.Util.Relation3.Relation3 a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Unison.Util.Relation3.Relation3 a b c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Base.Semigroup (Unison.Util.Relation3.Relation3 a b c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Base.Monoid (Unison.Util.Relation3.Relation3 a b c)

module Unison.Util.Relation4
data Relation4 a b c d
Relation4 :: Map a (Relation3 b c d) -> Map b (Relation3 a c d) -> Map c (Relation3 a b d) -> Map d (Relation3 a b c) -> Relation4 a b c d
[d1] :: Relation4 a b c d -> Map a (Relation3 b c d)
[d2] :: Relation4 a b c d -> Map b (Relation3 a c d)
[d3] :: Relation4 a b c d -> Map c (Relation3 a b d)
[d4] :: Relation4 a b c d -> Map d (Relation3 a b c)
size :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d -> Int
toNestedList :: Relation4 a b c d -> [(a, (b, (c, d)))]
toList :: Relation4 a b c d -> [(a, b, c, d)]
empty :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d
null :: Relation4 a b c d -> Bool
fromList :: (Ord a, Ord b, Ord c, Ord d) => [(a, b, c, d)] -> Relation4 a b c d
filter :: (Ord a, Ord b, Ord c, Ord d) => ((a, b, c, d) -> Bool) -> Relation4 a b c d -> Relation4 a b c d
memberD13 :: (Ord a, Ord c) => a -> c -> Relation4 a b c d -> Bool
selectD3 :: (Ord a, Ord b, Ord c, Ord d) => c -> Relation4 a b c d -> Relation4 a b c d
selectD34 :: (Ord a, Ord b, Ord c, Ord d) => c -> d -> Relation4 a b c d -> Relation4 a b c d
restrict34d12 :: (Ord a, Ord b, Ord c, Ord d) => (c, d) -> Relation4 a b c d -> Relation a b
keys :: Relation4 a b c d -> (Set a, Set b, Set c, Set d)
lookupD1 :: (Ord a, Ord b, Ord c, Ord d) => a -> Relation4 a b c d -> Relation3 b c d
lookupD2 :: (Ord a, Ord b, Ord c, Ord d) => b -> Relation4 a b c d -> Relation3 a c d
d1set :: Ord a => Relation4 a b c d -> Set a
d12 :: (Ord a, Ord b) => Relation4 a b c d -> Relation a b
d13 :: (Ord a, Ord c) => Relation4 a b c d -> Relation a c
d34 :: (Ord c, Ord d) => Relation4 a b c d -> Relation c d

-- | Project out a relation that only includes the 1st, 2nd, and 4th
--   dimensions.
d124 :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d -> Relation3 a b d

-- | Project out a relation that only includes the 2nd, 3rd, and 4th
--   dimensions.
d234 :: (Ord a, Ord b, Ord c, Ord d) => Relation4 a b c d -> Relation3 b c d
d12s :: (Ord a, Ord b) => Relation4 a b c d -> [(a, b)]
d3s :: Relation4 a b c d -> Set c
d4s :: Relation4 a b c d -> Set d
insert :: (Ord a, Ord b, Ord c, Ord d) => a -> b -> c -> d -> Relation4 a b c d -> Relation4 a b c d
delete :: (Ord a, Ord b, Ord c, Ord d) => a -> b -> c -> d -> Relation4 a b c d -> Relation4 a b c d
mapD2 :: (Ord a, Ord b, Ord b', Ord c, Ord d) => (b -> b') -> Relation4 a b c d -> Relation4 a b' c d

-- | Like <a>mapD2</a>, but takes a function that must be monotonic; i.e.
--   <tt>compare x y == compare (f x) (f y)</tt>.
mapD2Monotonic :: (Ord a, Ord b, Ord b', Ord c, Ord d) => (b -> b') -> Relation4 a b c d -> Relation4 a b' c d
insertAll :: Foldable f => Ord a => Ord b => Ord c => Ord d => f (a, b, c, d) -> Relation4 a b c d -> Relation4 a b c d
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (Unison.Util.Relation4.Relation4 a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (Unison.Util.Relation4.Relation4 a b c d)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (Unison.Util.Relation4.Relation4 a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Base.Semigroup (Unison.Util.Relation4.Relation4 a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Base.Monoid (Unison.Util.Relation4.Relation4 a b c d)
