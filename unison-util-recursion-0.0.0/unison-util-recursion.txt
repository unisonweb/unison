-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-util-recursion
@version 0.0.0

module Unison.Util.Recursion
type Algebra f a = f a -> a
class Recursive t f | t -> f
cata :: Recursive t f => Algebra f a -> t -> a
cata :: (Recursive t f, Functor f) => (f a -> a) -> t -> a
project :: Recursive t f => t -> f t
project :: (Recursive t f, Functor f) => t -> f t
embed :: Recursive t f => f t -> t
cataM :: (Recursive t f, Traversable f, Monad m) => (f a -> m a) -> t -> m a
para :: (Recursive t f, Functor f) => (f (t, a) -> a) -> t -> a
newtype Fix f
Fix :: f (Fix f) -> Fix f
data Cofree' f a x
(:<<) :: a -> f x -> Cofree' f a x
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Unison.Util.Recursion.Cofree' f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Unison.Util.Recursion.Cofree' f a)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Unison.Util.Recursion.Cofree' f a)
instance (forall a. GHC.Show.Show a => GHC.Show.Show (f a)) => GHC.Show.Show (Unison.Util.Recursion.Fix f)
instance (forall a. GHC.Classes.Eq a => GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Unison.Util.Recursion.Fix f)
instance (GHC.Classes.Eq (Unison.Util.Recursion.Fix f), forall a. GHC.Classes.Ord a => GHC.Classes.Ord (f a)) => GHC.Classes.Ord (Unison.Util.Recursion.Fix f)
instance GHC.Base.Functor f => Unison.Util.Recursion.Recursive (Control.Comonad.Cofree.Cofree f a) (Unison.Util.Recursion.Cofree' f a)
instance GHC.Base.Functor f => Unison.Util.Recursion.Recursive (Unison.Util.Recursion.Fix f) f
