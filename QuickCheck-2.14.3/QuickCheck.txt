-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic testing of Haskell programs
--   
--   QuickCheck is a library for random testing of program properties. The
--   programmer provides a specification of the program, in the form of
--   properties which functions should satisfy, and QuickCheck then tests
--   that the properties hold in a large number of randomly generated
--   cases. Specifications are expressed in Haskell, using combinators
--   provided by QuickCheck. QuickCheck provides combinators to define
--   properties, observe the distribution of test data, and define test
--   data generators.
--   
--   Most of QuickCheck's functionality is exported by the main
--   <a>Test.QuickCheck</a> module. The main exception is the monadic
--   property testing library in <a>Test.QuickCheck.Monadic</a>.
--   
--   If you are new to QuickCheck, you can try looking at the following
--   resources:
--   
--   <ul>
--   <li>The <a>official QuickCheck manual</a>. It's a bit out-of-date in
--   some details and doesn't cover newer QuickCheck features, but is still
--   full of good advice.</li>
--   
--   <li><a>https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html</a>,
--   a detailed tutorial written by a user of QuickCheck.</li>
--   </ul>
--   
--   The <a>quickcheck-instances</a> companion package provides instances
--   for types in Haskell Platform packages at the cost of additional
--   dependencies.
@package QuickCheck
@version 2.14.3


-- | Test case generation.
--   
--   <b>Note</b>: the contents of this module (except for the definition of
--   <a>Gen</a>) are re-exported by <a>Test.QuickCheck</a>. You probably do
--   not need to import it directly.
module Test.QuickCheck.Gen

-- | A generator for values of type <tt>a</tt>.
--   
--   The third-party packages <a>QuickCheck-GenT</a> and
--   <a>quickcheck-transformer</a> provide monad transformer versions of
--   <tt>Gen</tt>.
newtype Gen a
MkGen :: (QCGen -> Int -> a) -> Gen a

-- | Run the generator on a particular seed. If you just want to get a
--   random value out, consider using <a>generate</a>.
[unGen] :: Gen a -> QCGen -> Int -> a

-- | Modifies a generator using an integer seed.
variant :: Integral n => n -> Gen a -> Gen a

-- | Used to construct generators that depend on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = sized $ \n -&gt;
--     do k &lt;- choose (0,n)
--        vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>getSize</a>.
sized :: (Int -> Gen a) -> Gen a

-- | Returns the size parameter. Used to construct generators that depend
--   on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = do
--     n &lt;- getSize
--     k &lt;- choose (0,n)
--     vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>sized</a>.
getSize :: Gen Int

-- | Overrides the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: Int -> Gen a -> Gen a

-- | Adjust the size parameter, by transforming it with the given function.
scale :: (Int -> Int) -> Gen a -> Gen a

-- | Generates a random element in the given inclusive range. For integral
--   and enumerated types, the specialised variants of <a>choose</a> below
--   run much quicker.
choose :: Random a => (a, a) -> Gen a

-- | Generates a random element over the natural range of <tt>a</tt>.
chooseAny :: Random a => Gen a

-- | A fast implementation of <a>choose</a> for enumerated types.
chooseEnum :: Enum a => (a, a) -> Gen a

-- | A fast implementation of <a>choose</a> for <a>Int</a>.
chooseInt :: (Int, Int) -> Gen Int

-- | A fast implementation of <a>choose</a> for bounded integral types.
chooseBoundedIntegral :: (Bounded a, Integral a) => (a, a) -> Gen a

-- | A fast implementation of <a>choose</a> for <a>Integer</a>.
chooseInteger :: (Integer, Integer) -> Gen Integer
chooseWord64 :: (Word64, Word64) -> Gen Word64
chooseInt64 :: (Int64, Int64) -> Gen Int64
chooseUpTo :: Word64 -> Gen Word64

-- | Run a generator. The size passed to the generator is always 30; if you
--   want another size then you should explicitly use <a>resize</a>.
generate :: Gen a -> IO a

-- | Generates some example values.
sample' :: Gen a -> IO [a]

-- | Generates some example values and prints them to <tt>stdout</tt>.
sample :: Show a => Gen a -> IO ()

-- | Generate <a>Double</a> in 0..1 range
genDouble :: Gen Double

-- | Generate <a>Float</a> in 0..1 range
genFloat :: Gen Float

-- | Generates a value that satisfies a predicate.
suchThat :: Gen a -> (a -> Bool) -> Gen a

-- | Generates a value for which the given function returns a <a>Just</a>,
--   and then applies the function.
suchThatMap :: Gen a -> (a -> Maybe b) -> Gen b

-- | Tries to generate a value that satisfies a predicate. If it fails to
--   do so after enough attempts, returns <tt>Nothing</tt>.
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)

-- | Randomly uses one of the given generators. The input list must be
--   non-empty.
oneof :: [Gen a] -> Gen a

-- | Chooses one of the given generators, with a weighted random
--   distribution. The input list must be non-empty.
frequency :: [(Int, Gen a)] -> Gen a

-- | Generates one of the given values. The input list must be non-empty.
elements :: [a] -> Gen a

-- | Generates a random subsequence of the given list.
sublistOf :: [a] -> Gen [a]

-- | Generates a random permutation of the given list.
shuffle :: [a] -> Gen [a]

-- | Takes a list of elements of increasing size, and chooses among an
--   initial segment of the list. The size of this initial segment
--   increases with the size parameter. The input list must be non-empty.
growingElements :: [a] -> Gen a

-- | Generates a list of random length. The maximum length depends on the
--   size parameter.
listOf :: Gen a -> Gen [a]

-- | Generates a non-empty list of random length. The maximum length
--   depends on the size parameter.
listOf1 :: Gen a -> Gen [a]

-- | Generates a list of the given length.
vectorOf :: Int -> Gen a -> Gen [a]

-- | Generates an infinite list.
infiniteListOf :: Gen a -> Gen [a]
instance GHC.Base.Functor Test.QuickCheck.Gen.Gen
instance GHC.Base.Applicative Test.QuickCheck.Gen.Gen
instance GHC.Base.Monad Test.QuickCheck.Gen.Gen
instance Control.Monad.Fix.MonadFix Test.QuickCheck.Gen.Gen


-- | Unsafe combinators for the <a>Gen</a> monad.
--   
--   <a>Gen</a> is only morally a monad: two generators that are supposed
--   to be equal will give the same probability distribution, but they
--   might be different as functions from random number seeds to values.
--   QuickCheck maintains the illusion that a <a>Gen</a> is a probability
--   distribution and does not allow you to distinguish two generators that
--   have the same distribution.
--   
--   The functions in this module allow you to break this illusion by
--   reusing the same random number seed twice. This is unsafe because by
--   applying the same seed to two morally equal generators, you can see
--   whether they are really equal or not.
module Test.QuickCheck.Gen.Unsafe

-- | Promotes a monadic generator to a generator of monadic values.
promote :: Monad m => m (Gen a) -> Gen (m a)

-- | Randomly generates a function of type <tt><a>Gen</a> a -&gt; a</tt>,
--   which you can then use to evaluate generators. Mostly useful in
--   implementing <a>promote</a>.
delay :: Gen (Gen a -> a)

-- | A variant of <a>delay</a> that returns a polymorphic evaluation
--   function. Can be used in a pinch to generate polymorphic (rank-2)
--   values:
--   
--   <pre>
--   genSelector :: Gen (a -&gt; a -&gt; a)
--   genSelector = elements [\x y -&gt; x, \x y -&gt; y]
--   
--   data Selector = Selector (forall a. a -&gt; a -&gt; a)
--   genPolySelector :: Gen Selector
--   genPolySelector = do
--     Capture eval &lt;- capture
--     return (Selector (eval genSelector))
--   </pre>
capture :: Gen Capture
newtype Capture
Capture :: (forall a. Gen a -> a) -> Capture


-- | Type classes for random generation of values.
--   
--   <b>Note</b>: the contents of this module are re-exported by
--   <a>Test.QuickCheck</a>. You do not need to import it directly.
module Test.QuickCheck.Arbitrary

-- | Random generation and shrinking of values.
--   
--   QuickCheck provides <tt>Arbitrary</tt> instances for most types in
--   <tt>base</tt>, except those which incur extra dependencies. For a
--   wider range of <tt>Arbitrary</tt> instances see the
--   <a>quickcheck-instances</a> package.
class Arbitrary a

-- | A generator for values of the given type.
--   
--   It is worth spending time thinking about what sort of test data you
--   want - good generators are often the difference between finding bugs
--   and not finding them. You can use <a>sample</a>, <tt>label</tt> and
--   <tt>classify</tt> to check the quality of your test data.
--   
--   There is no generic <tt>arbitrary</tt> implementation included because
--   we don't know how to make a high-quality one. If you want one,
--   consider using the <a>testing-feat</a> or <a>generic-random</a>
--   packages.
--   
--   The <a>QuickCheck manual</a> goes into detail on how to write good
--   generators. Make sure to look at it, especially if your type is
--   recursive!
arbitrary :: Arbitrary a => Gen a

-- | Produces a (possibly) empty list of all the possible immediate shrinks
--   of the given value.
--   
--   The default implementation returns the empty list, so will not try to
--   shrink the value. If your data type has no special invariants, you can
--   enable shrinking by defining <tt>shrink = <a>genericShrink</a></tt>,
--   but by customising the behaviour of <tt>shrink</tt> you can often get
--   simpler counterexamples.
--   
--   Most implementations of <a>shrink</a> should try at least three
--   things:
--   
--   <ol>
--   <li>Shrink a term to any of its immediate subterms. You can use
--   <a>subterms</a> to do this.</li>
--   <li>Recursively apply <a>shrink</a> to all immediate subterms. You can
--   use <a>recursivelyShrink</a> to do this.</li>
--   <li>Type-specific shrinkings such as replacing a constructor by a
--   simpler constructor.</li>
--   </ol>
--   
--   For example, suppose we have the following implementation of binary
--   trees:
--   
--   <pre>
--   data Tree a = Nil | Branch a (Tree a) (Tree a)
--   </pre>
--   
--   We can then define <a>shrink</a> as follows:
--   
--   <pre>
--   shrink Nil = []
--   shrink (Branch x l r) =
--     -- shrink Branch to Nil
--     [Nil] ++
--     -- shrink to subterms
--     [l, r] ++
--     -- recursively shrink subterms
--     [Branch x' l' r' | (x', l', r') &lt;- shrink (x, l, r)]
--   </pre>
--   
--   There are a couple of subtleties here:
--   
--   <ul>
--   <li>QuickCheck tries the shrinking candidates in the order they appear
--   in the list, so we put more aggressive shrinking steps (such as
--   replacing the whole tree by <tt>Nil</tt>) before smaller ones (such as
--   recursively shrinking the subtrees).</li>
--   <li>It is tempting to write the last line as <tt>[Branch x' l' r' | x'
--   &lt;- shrink x, l' &lt;- shrink l, r' &lt;- shrink r]</tt> but this is
--   the <i>wrong thing</i>! It will force QuickCheck to shrink <tt>x</tt>,
--   <tt>l</tt> and <tt>r</tt> in tandem, and shrinking will stop once
--   <i>one</i> of the three is fully shrunk.</li>
--   </ul>
--   
--   There is a fair bit of boilerplate in the code above. We can avoid it
--   with the help of some generic functions. The function
--   <a>genericShrink</a> tries shrinking a term to all of its subterms
--   and, failing that, recursively shrinks the subterms. Using it, we can
--   define <a>shrink</a> as:
--   
--   <pre>
--   shrink x = shrinkToNil x ++ genericShrink x
--     where
--       shrinkToNil Nil = []
--       shrinkToNil (Branch _ l r) = [Nil]
--   </pre>
--   
--   <a>genericShrink</a> is a combination of <a>subterms</a>, which
--   shrinks a term to any of its subterms, and <a>recursivelyShrink</a>,
--   which shrinks all subterms of a term. These may be useful if you need
--   a bit more control over shrinking than <a>genericShrink</a> gives you.
--   
--   A final gotcha: we cannot define <a>shrink</a> as simply
--   <tt><a>shrink</a> x = Nil:<a>genericShrink</a> x</tt> as this shrinks
--   <tt>Nil</tt> to <tt>Nil</tt>, and shrinking will go into an infinite
--   loop.
--   
--   If all this leaves you bewildered, you might try <tt><a>shrink</a> =
--   <a>genericShrink</a></tt> to begin with, after deriving
--   <tt>Generic</tt> for your type. However, if your data type has any
--   special invariants, you will need to check that <a>genericShrink</a>
--   can't break those invariants.
shrink :: Arbitrary a => a -> [a]

-- | Used for random generation of functions. You should consider using
--   <a>Fun</a> instead, which can show the generated functions as strings.
--   
--   If you are using a recent GHC, there is a default definition of
--   <a>coarbitrary</a> using <a>genericCoarbitrary</a>, so if your type
--   has a <a>Generic</a> instance it's enough to say
--   
--   <pre>
--   instance CoArbitrary MyType
--   </pre>
--   
--   You should only use <a>genericCoarbitrary</a> for data types where
--   equality is structural, i.e. if you can't have two different
--   representations of the same value. An example where it's not safe is
--   sets implemented using binary search trees: the same set can be
--   represented as several different trees. Here you would have to
--   explicitly define <tt>coarbitrary s = coarbitrary (toList s)</tt>.
class CoArbitrary a

-- | Used to generate a function of type <tt>a -&gt; b</tt>. The first
--   argument is a value, the second a generator. You should use
--   <a>variant</a> to perturb the random generator; the goal is that
--   different values for the first argument will lead to different calls
--   to <a>variant</a>. An example will help:
--   
--   <pre>
--   instance CoArbitrary a =&gt; CoArbitrary [a] where
--     coarbitrary []     = <a>variant</a> 0
--     coarbitrary (x:xs) = <a>variant</a> 1 . coarbitrary (x,xs)
--   </pre>
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b

-- | Used to generate a function of type <tt>a -&gt; b</tt>. The first
--   argument is a value, the second a generator. You should use
--   <a>variant</a> to perturb the random generator; the goal is that
--   different values for the first argument will lead to different calls
--   to <a>variant</a>. An example will help:
--   
--   <pre>
--   instance CoArbitrary a =&gt; CoArbitrary [a] where
--     coarbitrary []     = <a>variant</a> 0
--     coarbitrary (x:xs) = <a>variant</a> 1 . coarbitrary (x,xs)
--   </pre>
coarbitrary :: (CoArbitrary a, Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Lifting of the <a>Arbitrary</a> class to unary type constructors.
class Arbitrary1 f
liftArbitrary :: Arbitrary1 f => Gen a -> Gen (f a)
liftShrink :: Arbitrary1 f => (a -> [a]) -> f a -> [f a]
arbitrary1 :: (Arbitrary1 f, Arbitrary a) => Gen (f a)
shrink1 :: (Arbitrary1 f, Arbitrary a) => f a -> [f a]

-- | Lifting of the <a>Arbitrary</a> class to binary type constructors.
class Arbitrary2 f
liftArbitrary2 :: Arbitrary2 f => Gen a -> Gen b -> Gen (f a b)
liftShrink2 :: Arbitrary2 f => (a -> [a]) -> (b -> [b]) -> f a b -> [f a b]
arbitrary2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => Gen (f a b)
shrink2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => f a b -> [f a b]

-- | Apply a binary function to random arguments.
applyArbitrary2 :: (Arbitrary a, Arbitrary b) => (a -> b -> r) -> Gen r

-- | Apply a ternary function to random arguments.
applyArbitrary3 :: (Arbitrary a, Arbitrary b, Arbitrary c) => (a -> b -> c -> r) -> Gen r

-- | Apply a function of arity 4 to random arguments.
applyArbitrary4 :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => (a -> b -> c -> d -> r) -> Gen r

-- | Generates an integral number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedIntegral :: Integral a => Gen a

-- | Generates a natural number. The number's maximum value depends on the
--   size parameter.
arbitrarySizedNatural :: Integral a => Gen a

-- | Generates an integral number. The number is chosen uniformly from the
--   entire range of the type. You may want to use
--   <a>arbitrarySizedBoundedIntegral</a> instead.
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an integral number from a bounded domain. The number is
--   chosen from the entire range of the type, but small numbers are
--   generated more often than big numbers. Inspired by demands from Phil
--   Wadler.
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Uniformly generates a fractional number. The number can be positive or
--   negative and its maximum absolute value depends on the size parameter.
arbitrarySizedFractional :: Fractional a => Gen a

-- | Generates an element of a bounded type. The element is chosen from the
--   entire range of the type.
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a

-- | Generates an element of a bounded enumeration.
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a

-- | Generates any Unicode character (but not a surrogate)
arbitraryUnicodeChar :: Gen Char

-- | Generates a random ASCII character (0-127).
arbitraryASCIIChar :: Gen Char

-- | Generates a printable Unicode character.
arbitraryPrintableChar :: Gen Char
class RecursivelyShrink f
class GSubterms f a

-- | Shrink a term to any of its immediate subterms, and also recursively
--   shrink all subterms.
genericShrink :: (Generic a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]

-- | All immediate subterms of a term.
subterms :: (Generic a, GSubterms (Rep a) a) => a -> [a]

-- | Recursively shrink all immediate subterms.
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]

-- | Generic CoArbitrary implementation.
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Returns no shrinking alternatives.
shrinkNothing :: a -> [a]

-- | Shrink a list of values given a shrinking function for individual
--   values.
shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- | Map a shrink function to another domain. This is handy if your data
--   type has special invariants, but is <i>almost</i> isomorphic to some
--   other type.
--   
--   <pre>
--   shrinkOrderedList :: (Ord a, Arbitrary a) =&gt; [a] -&gt; [[a]]
--   shrinkOrderedList = shrinkMap sort id
--   
--   shrinkSet :: (Ord a, Arbitrary a) =&gt; Set a -&gt; [Set a]
--   shrinkSet = shrinkMap fromList toList
--   </pre>
shrinkMap :: Arbitrary a => (a -> b) -> (b -> a) -> b -> [b]

-- | Non-overloaded version of <a>shrinkMap</a>.
shrinkMapBy :: (a -> b) -> (b -> a) -> (a -> [a]) -> b -> [b]

-- | Shrink an integral number.
shrinkIntegral :: Integral a => a -> [a]

-- | Shrink a fraction, preferring numbers with smaller numerators or
--   denominators. See also <a>shrinkDecimal</a>.
shrinkRealFrac :: RealFrac a => a -> [a]

-- | Shrink an element of a bounded enumeration.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   data MyEnum = E0 | E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9
--      deriving (Bounded, Enum, Eq, Ord, Show)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E9
--   [E0,E5,E7,E8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E5
--   [E0,E3,E4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E0
--   []
--   </pre>
shrinkBoundedEnum :: (Bounded a, Enum a, Eq a) => a -> [a]

-- | Shrink a real number, preferring numbers with shorter decimal
--   representations. See also <a>shrinkRealFrac</a>.
shrinkDecimal :: RealFrac a => a -> [a]

-- | A <a>coarbitrary</a> implementation for integral numbers.
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for real numbers.
coarbitraryReal :: Real a => a -> Gen b -> Gen b

-- | <a>coarbitrary</a> helper for lazy people :-).
coarbitraryShow :: Show a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for enums.
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b

-- | Combine two generator perturbing functions, for example the results of
--   calls to <a>variant</a> or <a>coarbitrary</a>.

-- | <i>Deprecated: Use ordinary function composition instead</i>
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a

-- | Generates a list of a given length.
vector :: Arbitrary a => Int -> Gen [a]

-- | Generates an ordered list.
orderedList :: (Ord a, Arbitrary a) => Gen [a]

-- | Generates an infinite list.
infiniteList :: Arbitrary a => Gen [a]
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.Arbitrary1 ((->) a)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b) => Test.QuickCheck.Arbitrary.Arbitrary (a -> b)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Semigroup.Internal.Endo a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.GCoArbitrary (GHC.Generics.K1 i a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b) => Test.QuickCheck.Arbitrary.CoArbitrary (a -> b)
instance Test.QuickCheck.Arbitrary.CoArbitrary ()
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Bool
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Ordering
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (GHC.Maybe.Maybe a)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Either.Either a b)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary [a]
instance (GHC.Real.Integral a, Test.QuickCheck.Arbitrary.CoArbitrary a) => Test.QuickCheck.Arbitrary.CoArbitrary (GHC.Real.Ratio a)
instance forall k (a :: k). Data.Fixed.HasResolution a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Fixed.Fixed a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Complex.Complex a)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b) => Test.QuickCheck.Arbitrary.CoArbitrary (a, b)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary c) => Test.QuickCheck.Arbitrary.CoArbitrary (a, b, c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary c, Test.QuickCheck.Arbitrary.CoArbitrary d) => Test.QuickCheck.Arbitrary.CoArbitrary (a, b, c, d)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary c, Test.QuickCheck.Arbitrary.CoArbitrary d, Test.QuickCheck.Arbitrary.CoArbitrary e) => Test.QuickCheck.Arbitrary.CoArbitrary (a, b, c, d, e)
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Num.Integer.Integer
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Int
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Int.Int8
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Int.Int16
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Int.Int32
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Int.Int64
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Word
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Word.Word8
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Word.Word16
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Word.Word32
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Word.Word64
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Char
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Float
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.Types.Double
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Set.Internal.Set a)
instance (Test.QuickCheck.Arbitrary.CoArbitrary k, Test.QuickCheck.Arbitrary.CoArbitrary v) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Map.Internal.Map k v)
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.IntSet.Internal.IntSet
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.IntMap.Internal.IntMap a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Sequence.Internal.Seq a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Tree.Tree a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Control.Applicative.ZipList a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Functor.Constant.Constant a b)
instance forall k a (b :: k). Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Functor.Const.Const a b)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Semigroup.Internal.Dual a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary a) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Semigroup.Internal.Endo a)
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.Semigroup.Internal.All
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.Semigroup.Internal.Any
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Semigroup.Internal.Sum a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Semigroup.Internal.Product a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Monoid.First a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Test.QuickCheck.Arbitrary.CoArbitrary (f a) => Test.QuickCheck.Arbitrary.CoArbitrary (Data.Semigroup.Internal.Alt f a)
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.Version.Version
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.IO.Handle.Types.Newline
instance Test.QuickCheck.Arbitrary.CoArbitrary GHC.IO.Handle.Types.NewlineMode
instance Test.QuickCheck.Arbitrary.GCoArbitrary GHC.Generics.U1
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Arbitrary.GCoArbitrary f, Test.QuickCheck.Arbitrary.GCoArbitrary g) => Test.QuickCheck.Arbitrary.GCoArbitrary (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Arbitrary.GCoArbitrary f, Test.QuickCheck.Arbitrary.GCoArbitrary g) => Test.QuickCheck.Arbitrary.GCoArbitrary (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Test.QuickCheck.Arbitrary.GCoArbitrary f => Test.QuickCheck.Arbitrary.GCoArbitrary (GHC.Generics.M1 i c f)
instance (Test.QuickCheck.Arbitrary.GSubtermsIncl f a, Test.QuickCheck.Arbitrary.GSubtermsIncl g a) => Test.QuickCheck.Arbitrary.GSubterms (f GHC.Generics.:*: g) a
instance (Test.QuickCheck.Arbitrary.GSubtermsIncl f a, Test.QuickCheck.Arbitrary.GSubtermsIncl g a) => Test.QuickCheck.Arbitrary.GSubterms (f GHC.Generics.:+: g) a
instance Test.QuickCheck.Arbitrary.GSubtermsIncl GHC.Generics.V1 a
instance Test.QuickCheck.Arbitrary.GSubtermsIncl GHC.Generics.U1 a
instance (Test.QuickCheck.Arbitrary.GSubtermsIncl f a, Test.QuickCheck.Arbitrary.GSubtermsIncl g a) => Test.QuickCheck.Arbitrary.GSubtermsIncl (f GHC.Generics.:*: g) a
instance (Test.QuickCheck.Arbitrary.GSubtermsIncl f a, Test.QuickCheck.Arbitrary.GSubtermsIncl g a) => Test.QuickCheck.Arbitrary.GSubtermsIncl (f GHC.Generics.:+: g) a
instance Test.QuickCheck.Arbitrary.GSubtermsIncl f a => Test.QuickCheck.Arbitrary.GSubtermsIncl (GHC.Generics.M1 i c f) a
instance Test.QuickCheck.Arbitrary.GSubtermsIncl (GHC.Generics.K1 i a) a
instance Test.QuickCheck.Arbitrary.GSubtermsIncl (GHC.Generics.K1 i a) b
instance Test.QuickCheck.Arbitrary.GSubterms GHC.Generics.V1 a
instance Test.QuickCheck.Arbitrary.GSubterms GHC.Generics.U1 a
instance Test.QuickCheck.Arbitrary.GSubterms f a => Test.QuickCheck.Arbitrary.GSubterms (GHC.Generics.M1 i c f) a
instance Test.QuickCheck.Arbitrary.GSubterms (GHC.Generics.K1 i a) b
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Arbitrary.RecursivelyShrink f, Test.QuickCheck.Arbitrary.RecursivelyShrink g) => Test.QuickCheck.Arbitrary.RecursivelyShrink (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Arbitrary.RecursivelyShrink f, Test.QuickCheck.Arbitrary.RecursivelyShrink g) => Test.QuickCheck.Arbitrary.RecursivelyShrink (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Test.QuickCheck.Arbitrary.RecursivelyShrink f => Test.QuickCheck.Arbitrary.RecursivelyShrink (GHC.Generics.M1 i c f)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.RecursivelyShrink (GHC.Generics.K1 i a)
instance Test.QuickCheck.Arbitrary.RecursivelyShrink GHC.Generics.U1
instance Test.QuickCheck.Arbitrary.RecursivelyShrink GHC.Generics.V1
instance Test.QuickCheck.Arbitrary.Arbitrary2 Data.Either.Either
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Either.Either a)
instance Test.QuickCheck.Arbitrary.Arbitrary2 (,)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary1 ((,) a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Data.Tree.Tree
instance Test.QuickCheck.Arbitrary.Arbitrary2 Data.Functor.Constant.Constant
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Functor.Constant.Constant a)
instance Test.QuickCheck.Arbitrary.Arbitrary2 Data.Functor.Const.Const
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Functor.Const.Const a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 GHC.Maybe.Maybe
instance Test.QuickCheck.Arbitrary.Arbitrary1 []
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Map.Internal.Map k)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Data.IntMap.Internal.IntMap
instance Test.QuickCheck.Arbitrary.Arbitrary1 Data.Sequence.Internal.Seq
instance Test.QuickCheck.Arbitrary.Arbitrary1 Control.Applicative.ZipList
instance Test.QuickCheck.Arbitrary.Arbitrary1 Data.Functor.Identity.Identity
instance (Test.QuickCheck.Arbitrary.Arbitrary1 f, Test.QuickCheck.Arbitrary.Arbitrary1 g) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Functor.Product.Product f g)
instance (Test.QuickCheck.Arbitrary.Arbitrary1 f, Test.QuickCheck.Arbitrary.Arbitrary1 g, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Functor.Product.Product f g a)
instance (Test.QuickCheck.Arbitrary.Arbitrary1 f, Test.QuickCheck.Arbitrary.Arbitrary1 g) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.Functor.Compose.Compose f g)
instance (Test.QuickCheck.Arbitrary.Arbitrary1 f, Test.QuickCheck.Arbitrary.Arbitrary1 g, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Functor.Compose.Compose f g a)
instance Test.QuickCheck.Arbitrary.Arbitrary ()
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Bool
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Ordering
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (GHC.Maybe.Maybe a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Either.Either a b)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary [a]
instance GHC.Real.Integral a => Test.QuickCheck.Arbitrary.Arbitrary (GHC.Real.Ratio a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Complex.Complex a)
instance forall k (a :: k). Data.Fixed.HasResolution a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Fixed.Fixed a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b) => Test.QuickCheck.Arbitrary.Arbitrary (a, b)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e, Test.QuickCheck.Arbitrary.Arbitrary f) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e, f)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e, Test.QuickCheck.Arbitrary.Arbitrary f, Test.QuickCheck.Arbitrary.Arbitrary g) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e, f, g)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e, Test.QuickCheck.Arbitrary.Arbitrary f, Test.QuickCheck.Arbitrary.Arbitrary g, Test.QuickCheck.Arbitrary.Arbitrary h) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e, f, g, h)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e, Test.QuickCheck.Arbitrary.Arbitrary f, Test.QuickCheck.Arbitrary.Arbitrary g, Test.QuickCheck.Arbitrary.Arbitrary h, Test.QuickCheck.Arbitrary.Arbitrary i) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e, f, g, h, i)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c, Test.QuickCheck.Arbitrary.Arbitrary d, Test.QuickCheck.Arbitrary.Arbitrary e, Test.QuickCheck.Arbitrary.Arbitrary f, Test.QuickCheck.Arbitrary.Arbitrary g, Test.QuickCheck.Arbitrary.Arbitrary h, Test.QuickCheck.Arbitrary.Arbitrary i, Test.QuickCheck.Arbitrary.Arbitrary j) => Test.QuickCheck.Arbitrary.Arbitrary (a, b, c, d, e, f, g, h, i, j)
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Num.Integer.Integer
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Int
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Int.Int8
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Int.Int16
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Int.Int32
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Int.Int64
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Word
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Word.Word8
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Word.Word16
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Word.Word32
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Word.Word64
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Char
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Float
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Types.Double
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CChar
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CSChar
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUChar
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CShort
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUShort
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CInt
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUInt
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CLong
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CULong
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CPtrdiff
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CSize
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CWchar
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CSigAtomic
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CLLong
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CULLong
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CIntPtr
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUIntPtr
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CIntMax
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUIntMax
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CClock
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CTime
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CUSeconds
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CSUSeconds
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CFloat
instance Test.QuickCheck.Arbitrary.Arbitrary Foreign.C.Types.CDouble
instance (GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Set.Internal.Set a)
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Map.Internal.Map k v)
instance Test.QuickCheck.Arbitrary.Arbitrary Data.IntSet.Internal.IntSet
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.IntMap.Internal.IntMap a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Sequence.Internal.Seq a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Tree.Tree a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Control.Applicative.ZipList a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Functor.Constant.Constant a b)
instance forall k a (b :: k). Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Functor.Const.Const a b)
instance Test.QuickCheck.Arbitrary.Arbitrary (m a) => Test.QuickCheck.Arbitrary.Arbitrary (Control.Applicative.WrappedMonad m a)
instance Test.QuickCheck.Arbitrary.Arbitrary (a b c) => Test.QuickCheck.Arbitrary.Arbitrary (Control.Applicative.WrappedArrow a b c)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Semigroup.Internal.Dual a)
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Semigroup.Internal.All
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Semigroup.Internal.Any
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Semigroup.Internal.Sum a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Semigroup.Internal.Product a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Monoid.First a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Test.QuickCheck.Arbitrary.Arbitrary (f a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Semigroup.Internal.Alt f a)
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Version.Version
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Random.QCGen
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.IO.Exception.ExitCode
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.IO.Handle.Types.Newline
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.IO.Handle.Types.NewlineMode


-- | Types to help with testing polymorphic properties.
--   
--   Types <a>A</a>, <a>B</a> and <a>C</a> are <tt>newtype</tt> wrappers
--   around <a>Integer</a> that implement <a>Eq</a>, <a>Show</a>,
--   <a>Arbitrary</a> and <a>CoArbitrary</a>. Types <a>OrdA</a>,
--   <a>OrdB</a> and <a>OrdC</a> also implement <a>Ord</a> and <a>Num</a>.
--   
--   See also <a>Test.QuickCheck.All</a> for an automatic way of testing
--   polymorphic properties.
module Test.QuickCheck.Poly
newtype A
A :: Integer -> A
[unA] :: A -> Integer
newtype B
B :: Integer -> B
[unB] :: B -> Integer
newtype C
C :: Integer -> C
[unC] :: C -> Integer
newtype OrdA
OrdA :: Integer -> OrdA
[unOrdA] :: OrdA -> Integer
newtype OrdB
OrdB :: Integer -> OrdB
[unOrdB] :: OrdB -> Integer
newtype OrdC
OrdC :: Integer -> OrdC
[unOrdC] :: OrdC -> Integer
instance GHC.Classes.Eq Test.QuickCheck.Poly.A
instance GHC.Classes.Eq Test.QuickCheck.Poly.B
instance GHC.Classes.Eq Test.QuickCheck.Poly.C
instance GHC.Classes.Ord Test.QuickCheck.Poly.OrdA
instance GHC.Classes.Eq Test.QuickCheck.Poly.OrdA
instance GHC.Classes.Ord Test.QuickCheck.Poly.OrdB
instance GHC.Classes.Eq Test.QuickCheck.Poly.OrdB
instance GHC.Classes.Ord Test.QuickCheck.Poly.OrdC
instance GHC.Classes.Eq Test.QuickCheck.Poly.OrdC
instance GHC.Num.Num Test.QuickCheck.Poly.OrdC
instance GHC.Show.Show Test.QuickCheck.Poly.OrdC
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.OrdC
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.OrdC
instance GHC.Num.Num Test.QuickCheck.Poly.OrdB
instance GHC.Show.Show Test.QuickCheck.Poly.OrdB
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.OrdB
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.OrdB
instance GHC.Num.Num Test.QuickCheck.Poly.OrdA
instance GHC.Show.Show Test.QuickCheck.Poly.OrdA
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.OrdA
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.OrdA
instance GHC.Show.Show Test.QuickCheck.Poly.C
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.C
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.C
instance GHC.Show.Show Test.QuickCheck.Poly.B
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.B
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.B
instance GHC.Show.Show Test.QuickCheck.Poly.A
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Poly.A
instance Test.QuickCheck.Arbitrary.CoArbitrary Test.QuickCheck.Poly.A


-- | Modifiers for test data.
--   
--   These types do things such as restricting the kind of test data that
--   can be generated. They can be pattern-matched on in properties as a
--   stylistic alternative to using explicit quantification.
--   
--   <b>Note</b>: the contents of this module are re-exported by
--   <a>Test.QuickCheck</a>. You do not need to import it directly.
--   
--   Examples:
--   
--   <pre>
--   -- Functions cannot be shown (but see <a>Test.QuickCheck.Function</a>)
--   prop_TakeDropWhile (<a>Blind</a> p) (xs :: [<tt>A</tt>]) =
--     takeWhile p xs ++ dropWhile p xs == xs
--   </pre>
--   
--   <pre>
--   prop_TakeDrop (<a>NonNegative</a> n) (xs :: [<tt>A</tt>]) =
--     take n xs ++ drop n xs == xs
--   </pre>
--   
--   <pre>
--   -- cycle does not work for empty lists
--   prop_Cycle (<a>NonNegative</a> n) (<a>NonEmpty</a> (xs :: [<tt>A</tt>])) =
--     take n (cycle xs) == take n (xs ++ cycle xs)
--   </pre>
--   
--   <pre>
--   -- Instead of <tt>forAll</tt> <a>orderedList</a>
--   prop_Sort (<a>Ordered</a> (xs :: [<tt>OrdA</tt>])) =
--     sort xs == xs
--   </pre>
module Test.QuickCheck.Modifiers

-- | <tt>Blind x</tt>: as x, but x does not have to be in the <a>Show</a>
--   class.
newtype Blind a
Blind :: a -> Blind a
[getBlind] :: Blind a -> a

-- | <tt>Fixed x</tt>: as x, but will not be shrunk.
newtype Fixed a
Fixed :: a -> Fixed a
[getFixed] :: Fixed a -> a

-- | <tt>Ordered xs</tt>: guarantees that xs is ordered.
newtype OrderedList a
Ordered :: [a] -> OrderedList a
[getOrdered] :: OrderedList a -> [a]

-- | <tt>NonEmpty xs</tt>: guarantees that xs is non-empty.
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
[getNonEmpty] :: NonEmptyList a -> [a]

-- | <tt>InfiniteList xs _</tt>: guarantees that xs is an infinite list.
--   When a counterexample is found, only prints the prefix of xs that was
--   used by the program.
--   
--   Here is a contrived example property:
--   
--   <pre>
--   prop_take_10 :: InfiniteList Char -&gt; Bool
--   prop_take_10 (InfiniteList xs _) =
--     or [ x == 'a' | x &lt;- take 10 xs ]
--   </pre>
--   
--   In the following counterexample, the list must start with
--   <tt>"bbbbbbbbbb"</tt> but the remaining (infinite) part can contain
--   anything:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_take_10
--   *** Failed! Falsified (after 1 test and 14 shrinks):
--   "bbbbbbbbbb" ++ ...
--   </pre>
data InfiniteList a
InfiniteList :: [a] -> InfiniteListInternalData a -> InfiniteList a
[getInfiniteList] :: InfiniteList a -> [a]
[infiniteListInternalData] :: InfiniteList a -> InfiniteListInternalData a

-- | <tt>Sorted xs</tt>: guarantees that xs is sorted.
newtype SortedList a
Sorted :: [a] -> SortedList a
[getSorted] :: SortedList a -> [a]

-- | <tt>Positive x</tt>: guarantees that <tt>x &gt; 0</tt>.
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a

-- | <tt>Negative x</tt>: guarantees that <tt>x &lt; 0</tt>.
newtype Negative a
Negative :: a -> Negative a
[getNegative] :: Negative a -> a

-- | <tt>NonZero x</tt>: guarantees that <tt>x /= 0</tt>.
newtype NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a

-- | <tt>NonNegative x</tt>: guarantees that <tt>x &gt;= 0</tt>.
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a

-- | <tt>NonPositive x</tt>: guarantees that <tt>x &lt;= 0</tt>.
newtype NonPositive a
NonPositive :: a -> NonPositive a
[getNonPositive] :: NonPositive a -> a

-- | <tt>Large x</tt>: by default, QuickCheck generates <a>Int</a>s drawn
--   from a small range. <tt>Large Int</tt> gives you values drawn from the
--   entire range instead.
newtype Large a
Large :: a -> Large a
[getLarge] :: Large a -> a

-- | <tt>Small x</tt>: generates values of <tt>x</tt> drawn from a small
--   range. The opposite of <a>Large</a>.
newtype Small a
Small :: a -> Small a
[getSmall] :: Small a -> a

-- | <tt>Smart _ x</tt>: tries a different order when shrinking.
data Smart a
Smart :: Int -> a -> Smart a

-- | <tt>Shrink2 x</tt>: allows 2 shrinking steps at the same time when
--   shrinking x
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
[getShrink2] :: Shrink2 a -> a

-- | <tt>Shrinking _ x</tt>: allows for maintaining a state during
--   shrinking.
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]

-- | <tt>ASCIIString</tt>: generates an ASCII string.
newtype ASCIIString
ASCIIString :: String -> ASCIIString
[getASCIIString] :: ASCIIString -> String

-- | <tt>UnicodeString</tt>: generates a unicode String. The string will
--   not contain surrogate pairs.
newtype UnicodeString
UnicodeString :: String -> UnicodeString
[getUnicodeString] :: UnicodeString -> String

-- | <tt>PrintableString</tt>: generates a printable unicode String. The
--   string will not contain surrogate pairs.
newtype PrintableString
PrintableString :: String -> PrintableString
[getPrintableString] :: PrintableString -> String
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Real.Real a => GHC.Real.Real (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Num.Num a => GHC.Num.Num (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Blind a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Real.Real a => GHC.Real.Real (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Num.Num a => GHC.Num.Num (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.OrderedList a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.OrderedList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.OrderedList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.OrderedList a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.NonEmptyList a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.NonEmptyList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.NonEmptyList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.NonEmptyList a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.SortedList a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.SortedList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.SortedList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.SortedList a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Test.QuickCheck.Modifiers.Large a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Large a)
instance GHC.Real.Real a => GHC.Real.Real (Test.QuickCheck.Modifiers.Large a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.QuickCheck.Modifiers.Large a)
instance GHC.Num.Num a => GHC.Num.Num (Test.QuickCheck.Modifiers.Large a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Large a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Large a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Large a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Large a)
instance GHC.Ix.Ix a => GHC.Ix.Ix (Test.QuickCheck.Modifiers.Small a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Small a)
instance GHC.Real.Real a => GHC.Real.Real (Test.QuickCheck.Modifiers.Small a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.QuickCheck.Modifiers.Small a)
instance GHC.Num.Num a => GHC.Num.Num (Test.QuickCheck.Modifiers.Small a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Small a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Small a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Small a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Small a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Real.Real a => GHC.Real.Real (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Real.Integral a => GHC.Real.Integral (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Num.Num a => GHC.Num.Num (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Read.Read a => GHC.Read.Read (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Read.Read Test.QuickCheck.Modifiers.ASCIIString
instance GHC.Show.Show Test.QuickCheck.Modifiers.ASCIIString
instance GHC.Classes.Ord Test.QuickCheck.Modifiers.ASCIIString
instance GHC.Classes.Eq Test.QuickCheck.Modifiers.ASCIIString
instance GHC.Read.Read Test.QuickCheck.Modifiers.UnicodeString
instance GHC.Show.Show Test.QuickCheck.Modifiers.UnicodeString
instance GHC.Classes.Ord Test.QuickCheck.Modifiers.UnicodeString
instance GHC.Classes.Eq Test.QuickCheck.Modifiers.UnicodeString
instance GHC.Read.Read Test.QuickCheck.Modifiers.PrintableString
instance GHC.Show.Show Test.QuickCheck.Modifiers.PrintableString
instance GHC.Classes.Ord Test.QuickCheck.Modifiers.PrintableString
instance GHC.Classes.Eq Test.QuickCheck.Modifiers.PrintableString
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Modifiers.PrintableString
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Modifiers.UnicodeString
instance Test.QuickCheck.Arbitrary.Arbitrary Test.QuickCheck.Modifiers.ASCIIString
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Test.QuickCheck.Modifiers.ShrinkState s a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Shrinking s a)
instance GHC.Base.Functor (Test.QuickCheck.Modifiers.Shrinking s)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Shrinking s a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Smart
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.Smart a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Smart a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Shrink2
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Shrink2 a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Small
instance GHC.Real.Integral a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Small a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Large
instance (GHC.Real.Integral a, GHC.Enum.Bounded a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Large a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.NonPositive
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.NonPositive a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.NonNegative
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.NonNegative a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.NonZero
instance (GHC.Num.Num a, GHC.Classes.Eq a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.NonZero a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Negative
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Negative a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Positive
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Positive a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.SortedList
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Classes.Ord a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.SortedList a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Modifiers.InfiniteList a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.InfiniteList a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.InfiniteListInternalData a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.NonEmptyList
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.NonEmptyList a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.OrderedList
instance (GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.OrderedList a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Fixed
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Fixed a)
instance GHC.Base.Functor Test.QuickCheck.Modifiers.Blind
instance GHC.Show.Show (Test.QuickCheck.Modifiers.Blind a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Modifiers.Blind a)


-- | Generation of random shrinkable, showable functions. See the paper
--   "Shrinking and showing functions" by Koen Claessen.
--   
--   <b>Note</b>: most of the contents of this module are re-exported by
--   <a>Test.QuickCheck</a>. You probably do not need to import it
--   directly.
--   
--   Example of use:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   
--   &gt;&gt;&gt; let prop :: Fun String Integer -&gt; Bool
--   
--   &gt;&gt;&gt; prop (Fun _ f) = f "monkey" == f "banana" || f "banana" == f "elephant"
--   
--   &gt;&gt;&gt; :}
--   
--   &gt;&gt;&gt; quickCheck prop
--   *** Failed! Falsified (after 3 tests and 134 shrinks):
--   {"elephant"-&gt;1, "monkey"-&gt;1, _-&gt;0}
--   </pre>
--   
--   To generate random values of type <tt><a>Fun</a> a b</tt>, you must
--   have an instance <tt><a>Function</a> a</tt>. If your type has a
--   <a>Show</a> instance, you can use <a>functionShow</a> to write the
--   instance; otherwise, use <a>functionMap</a> to give a bijection
--   between your type and a type that is already an instance of
--   <a>Function</a>. See the <tt><a>Function</a> [a]</tt> instance for an
--   example of the latter.
module Test.QuickCheck.Function

-- | Generation of random shrinkable, showable functions.
--   
--   To generate random values of type <tt><a>Fun</a> a b</tt>, you must
--   have an instance <tt><a>Function</a> a</tt>.
--   
--   See also <a>applyFun</a>, and <a>Fn</a> with GHC &gt;= 7.8.
data Fun a b
Fun :: (a :-> b, b, Shrunk) -> (a -> b) -> Fun a b

-- | Extracts the value of a function.
--   
--   <a>Fn</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop f = applyFun f "banana" == applyFun f "monkey"
--         || applyFun f "banana" == applyFun f "elephant"
--   </pre>
applyFun :: Fun a b -> a -> b

-- | Alias to <a>applyFun</a>.
apply :: Fun a b -> a -> b

-- | Extracts the value of a binary function.
--   
--   <a>Fn2</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith f xs ys = zipWith (applyFun2 f) xs ys == [ applyFun2 f x y | (x, y) &lt;- zip xs ys]
--   </pre>
applyFun2 :: Fun (a, b) c -> a -> b -> c

-- | Extracts the value of a ternary function. <a>Fn3</a> is the pattern
--   equivalent of this function.
applyFun3 :: Fun (a, b, c) d -> a -> b -> c -> d

-- | The type of possibly partial concrete functions
data a :-> c

-- | The class <tt>Function a</tt> is used for random generation of
--   showable functions of type <tt>a -&gt; b</tt>.
--   
--   There is a default implementation for <a>function</a>, which you can
--   use if your type has structural equality. Otherwise, you can normally
--   use <a>functionMap</a> or <a>functionShow</a>.
class Function a
function :: Function a => (a -> b) -> a :-> b
function :: (Function a, Generic a, GFunction (Rep a)) => (a -> b) -> a :-> b

-- | The basic building block for <a>Function</a> instances. Provides a
--   <a>Function</a> instance by mapping to and from a type that already
--   has a <a>Function</a> instance.
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types with <a>Show</a> and
--   <a>Read</a>.
functionShow :: (Show a, Read a) => (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types with <a>Integral</a>.
functionIntegral :: Integral a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>RealFrac</a>.
functionRealFrac :: RealFrac a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>Bounded</a> and
--   <a>Enum</a>. Use only for small types (i.e. not integers): creates the
--   list <tt>[<a>minBound</a>..<a>maxBound</a>]</tt>!
functionBoundedEnum :: (Eq a, Bounded a, Enum a) => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for small finite types.
functionElements :: Eq a => [a] -> (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types isomorphic to
--   <a>Void</a>.
--   
--   An actual <tt><a>Function</a> <a>Void</a></tt> instance is defined in
--   <tt>quickcheck-instances</tt>.
functionVoid :: (forall b. void -> b) -> void :-> c

functionMapWith :: ((b -> c) -> b :-> c) -> (a -> b) -> (b -> a) -> (a -> c) -> a :-> c

functionEitherWith :: ((a -> c) -> a :-> c) -> ((b -> c) -> b :-> c) -> (Either a b -> c) -> Either a b :-> c

functionPairWith :: ((a -> b -> c) -> a :-> (b -> c)) -> ((b -> c) -> b :-> c) -> ((a, b) -> c) -> (a, b) :-> c

-- | A modifier for testing functions.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop (Fn f) = f "banana" == f "monkey"
--              || f "banana" == f "elephant"
--   </pre>
pattern Fn :: (a -> b) -> Fun a b

-- | A modifier for testing binary functions.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith (Fn2 f) xs ys = zipWith f xs ys == [ f x y | (x, y) &lt;- zip xs ys]
--   </pre>
pattern Fn2 :: (a -> b -> c) -> Fun (a, b) c

-- | A modifier for testing ternary functions.
pattern Fn3 :: (a -> b -> c -> d) -> Fun (a, b, c) d
instance GHC.Classes.Eq Test.QuickCheck.Function.Shrunk
instance GHC.Base.Functor (Test.QuickCheck.Function.Fun a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Test.QuickCheck.Function.Fun a b)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Function.Fun a b)
instance Test.QuickCheck.Function.Function ()
instance forall k a (b :: k). Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Functor.Const.Const a b)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Functor.Identity.Identity a)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b) => Test.QuickCheck.Function.Function (a, b)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b) => Test.QuickCheck.Function.Function (Data.Either.Either a b)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b, Test.QuickCheck.Function.Function c) => Test.QuickCheck.Function.Function (a, b, c)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b, Test.QuickCheck.Function.Function c, Test.QuickCheck.Function.Function d) => Test.QuickCheck.Function.Function (a, b, c, d)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b, Test.QuickCheck.Function.Function c, Test.QuickCheck.Function.Function d, Test.QuickCheck.Function.Function e) => Test.QuickCheck.Function.Function (a, b, c, d, e)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b, Test.QuickCheck.Function.Function c, Test.QuickCheck.Function.Function d, Test.QuickCheck.Function.Function e, Test.QuickCheck.Function.Function f) => Test.QuickCheck.Function.Function (a, b, c, d, e, f)
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b, Test.QuickCheck.Function.Function c, Test.QuickCheck.Function.Function d, Test.QuickCheck.Function.Function e, Test.QuickCheck.Function.Function f, Test.QuickCheck.Function.Function g) => Test.QuickCheck.Function.Function (a, b, c, d, e, f, g)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function [a]
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (GHC.Maybe.Maybe a)
instance Test.QuickCheck.Function.Function GHC.Types.Bool
instance Test.QuickCheck.Function.Function GHC.Num.Integer.Integer
instance Test.QuickCheck.Function.Function GHC.Types.Int
instance Test.QuickCheck.Function.Function GHC.Types.Word
instance Test.QuickCheck.Function.Function GHC.Types.Char
instance Test.QuickCheck.Function.Function GHC.Types.Float
instance Test.QuickCheck.Function.Function GHC.Types.Double
instance Test.QuickCheck.Function.Function GHC.Types.Ordering
instance (GHC.Real.Integral a, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (GHC.Real.Ratio a)
instance forall k (a :: k). Data.Fixed.HasResolution a => Test.QuickCheck.Function.Function (Data.Fixed.Fixed a)
instance (GHC.Float.RealFloat a, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.Complex.Complex a)
instance (GHC.Classes.Ord a, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.Set.Internal.Set a)
instance (GHC.Classes.Ord a, Test.QuickCheck.Function.Function a, Test.QuickCheck.Function.Function b) => Test.QuickCheck.Function.Function (Data.Map.Internal.Map a b)
instance Test.QuickCheck.Function.Function Data.IntSet.Internal.IntSet
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.IntMap.Internal.IntMap a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Sequence.Internal.Seq a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Tree.Tree a)
instance Test.QuickCheck.Function.Function GHC.Int.Int8
instance Test.QuickCheck.Function.Function GHC.Int.Int16
instance Test.QuickCheck.Function.Function GHC.Int.Int32
instance Test.QuickCheck.Function.Function GHC.Int.Int64
instance Test.QuickCheck.Function.Function GHC.Word.Word8
instance Test.QuickCheck.Function.Function GHC.Word.Word16
instance Test.QuickCheck.Function.Function GHC.Word.Word32
instance Test.QuickCheck.Function.Function GHC.Word.Word64
instance Test.QuickCheck.Function.Function GHC.IO.Handle.Types.Newline
instance Test.QuickCheck.Function.Function GHC.IO.Handle.Types.NewlineMode
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Semigroup.Internal.Dual a)
instance Test.QuickCheck.Function.Function Data.Semigroup.Internal.All
instance Test.QuickCheck.Function.Function Data.Semigroup.Internal.Any
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Semigroup.Internal.Sum a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Semigroup.Internal.Product a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Monoid.First a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Test.QuickCheck.Function.Function (f a) => Test.QuickCheck.Function.Function (Data.Semigroup.Internal.Alt f a)
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.A
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.B
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.C
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.OrdA
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.OrdB
instance Test.QuickCheck.Function.Function Test.QuickCheck.Poly.OrdC
instance (Test.QuickCheck.Function.Function a, Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b) => Test.QuickCheck.Arbitrary.Arbitrary (a Test.QuickCheck.Function.:-> b)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.GFunction (GHC.Generics.K1 i a)
instance Test.QuickCheck.Function.GFunction GHC.Generics.U1
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Function.GFunction f, Test.QuickCheck.Function.GFunction g) => Test.QuickCheck.Function.GFunction (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.Function.GFunction f, Test.QuickCheck.Function.GFunction g) => Test.QuickCheck.Function.GFunction (f GHC.Generics.:+: g)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Test.QuickCheck.Function.GFunction f => Test.QuickCheck.Function.GFunction (GHC.Generics.M1 i c f)
instance GHC.Base.Functor ((Test.QuickCheck.Function.:->) a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a Test.QuickCheck.Function.:-> b)


-- | Allows testing of monadic values. Will generally follow this form:
--   
--   <pre>
--   prop_monadic a b = <a>monadicIO</a> $ do
--     a' &lt;- <a>run</a> (f a)
--     b' &lt;- <a>run</a> (f b)
--     -- ...
--     <a>assert</a> someBoolean
--   </pre>
--   
--   Example using the <tt>FACTOR(1)</tt> command-line utility:
--   
--   <pre>
--   import System.Process
--   import Test.QuickCheck
--   import Test.QuickCheck.Monadic
--   
--   -- $ factor 16
--   -- 16: 2 2 2 2
--   factor :: Integer -&gt; IO [Integer]
--   factor n = parse `fmap` <a>readProcess</a> "factor" [show n] "" where
--   
--     parse :: String -&gt; [Integer]
--     parse = map read . tail . words
--   
--   prop_factor :: Positive Integer -&gt; Property
--   prop_factor (<a>Positive</a> n) = <a>monadicIO</a> $ do
--     factors &lt;- <a>run</a> (factor n)
--   
--     <a>assert</a> (product factors == n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_factor
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   See the paper "<a>Testing Monadic Code with QuickCheck</a>".
module Test.QuickCheck.Monadic

-- | The property monad is really a monad transformer that can contain
--   monadic computations in the monad <tt>m</tt> it is parameterized by:
--   
--   <ul>
--   <li><tt>m</tt> - the <tt>m</tt>-computations that may be performed
--   within <tt>PropertyM</tt></li>
--   </ul>
--   
--   Elements of <tt>PropertyM m a</tt> may mix property operations and
--   <tt>m</tt>-computations.
newtype PropertyM m a
MkPropertyM :: ((a -> Gen (m Property)) -> Gen (m Property)) -> PropertyM m a
[unPropertyM] :: PropertyM m a -> (a -> Gen (m Property)) -> Gen (m Property)

-- | The lifting operation of the property monad. Allows embedding
--   monadic/<a>IO</a>-actions in properties:
--   
--   <pre>
--   log :: Int -&gt; IO ()
--   
--   prop_foo n = monadicIO $ do
--     run (log n)
--     -- ...
--   </pre>
run :: Monad m => m a -> PropertyM m a

-- | Allows embedding non-monadic properties into monadic ones.
assert :: Monad m => Bool -> PropertyM m ()

-- | Like <a>assert</a> but allows caller to specify an explicit message to
--   show on failure.
--   
--   <b>Example:</b>
--   
--   <pre>
--   do
--     assertWith True  "My first predicate."
--     assertWith False "My other predicate."
--     ...
--   </pre>
--   
--   <pre>
--   Assertion failed (after 2 tests):
--       Passed: My first predicate
--       Failed: My other predicate
--   </pre>
assertWith :: Monad m => Bool -> String -> PropertyM m ()

-- | Tests preconditions. Unlike <a>assert</a> this does not cause the
--   property to fail, rather it discards them just like using the
--   implication combinator <a>==&gt;</a>.
--   
--   This allows representing the <a>Hoare triple</a>
--   
--   <pre>
--   {p} x ← e{q}
--   </pre>
--   
--   as
--   
--   <pre>
--   pre p
--   x &lt;- run e
--   assert q
--   </pre>
pre :: Monad m => Bool -> PropertyM m ()

-- | The <a>weakest precondition</a>
--   
--   <pre>
--   wp(x ← e, p)
--   </pre>
--   
--   can be expressed as in code as <tt>wp e (\x -&gt; p)</tt>.
wp :: Monad m => m a -> (a -> PropertyM m b) -> PropertyM m b

-- | Quantification in a monadic property, fits better with
--   <i>do-notation</i> than <a>forAllM</a>. <b>Note</b>: values generated
--   by <a>pick</a> do not shrink.
pick :: (Monad m, Show a) => Gen a -> PropertyM m a

-- | Quantification in monadic properties to <a>pick</a>, with a notation
--   similar to <a>forAll</a>. <b>Note</b>: values generated by
--   <a>forAllM</a> do not shrink.
forAllM :: (Monad m, Show a) => Gen a -> (a -> PropertyM m b) -> PropertyM m b

-- | Allows making observations about the test data:
--   
--   <pre>
--   monitor (<a>collect</a> e)
--   </pre>
--   
--   collects the distribution of value of <tt>e</tt>.
--   
--   <pre>
--   monitor (<a>counterexample</a> "Failure!")
--   </pre>
--   
--   Adds <tt>"Failure!"</tt> to the counterexamples.
monitor :: Monad m => (Property -> Property) -> PropertyM m ()
stop :: (Testable prop, Monad m) => prop -> PropertyM m a
monadic :: (Testable a, Monad m) => (m Property -> Property) -> PropertyM m a -> Property
monadic' :: (Testable a, Monad m) => PropertyM m a -> Gen (m Property)

-- | Runs the property monad for <a>IO</a>-computations.
--   
--   <pre>
--   prop_cat msg = monadicIO $ do
--     (exitCode, stdout, _) &lt;- run (<a>readProcessWithExitCode</a> "cat" [] msg)
--   
--     pre (<a>ExitSuccess</a> == exitCode)
--   
--     assert (stdout == msg)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_cat
--   +++ OK, passed 100 tests.
--   </pre>
monadicIO :: Testable a => PropertyM IO a -> Property

-- | Runs the property monad for <a>ST</a>-computations.
--   
--   <pre>
--   -- Your mutable sorting algorithm here
--   sortST :: Ord a =&gt; [a] -&gt; <a>ST</a> s (MVector s a)
--   sortST = <a>thaw</a> . <a>fromList</a> . <a>sort</a>
--   
--   prop_sortST xs = monadicST $ do
--     sorted  &lt;- run (<a>freeze</a> =&lt;&lt; sortST xs)
--     assert (<a>toList</a> sorted == sort xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sortST
--   +++ OK, passed 100 tests.
--   </pre>
monadicST :: Testable a => (forall s. PropertyM (ST s) a) -> Property
runSTGen :: (forall s. Gen (ST s a)) -> Gen a
instance GHC.Base.Functor (Test.QuickCheck.Monadic.PropertyM m)
instance GHC.Base.Applicative (Test.QuickCheck.Monadic.PropertyM m)
instance GHC.Base.Monad m => GHC.Base.Monad (Test.QuickCheck.Monadic.PropertyM m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Test.QuickCheck.Monadic.PropertyM m)
instance Control.Monad.Trans.Class.MonadTrans Test.QuickCheck.Monadic.PropertyM
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Test.QuickCheck.Monadic.PropertyM m)


-- | <b>Note</b>: the contents of this module are re-exported by
--   <a>Test.QuickCheck</a>. You do not need to import it directly.
--   
--   Test all properties in the current module, using Template Haskell. You
--   need to have a <tt>{-# LANGUAGE TemplateHaskell #-}</tt> pragma in
--   your module for any of these to work.
module Test.QuickCheck.All

-- | Test all properties in the current module. The name of the property
--   must begin with <tt>prop_</tt>. Polymorphic properties will be
--   defaulted to <a>Integer</a>. Returns <a>True</a> if all tests
--   succeeded, <a>False</a> otherwise.
--   
--   To use <a>quickCheckAll</a>, add a definition to your module along the
--   lines of
--   
--   <pre>
--   return []
--   runTests = $quickCheckAll
--   </pre>
--   
--   and then execute <tt>runTests</tt>.
--   
--   Note: the bizarre <tt>return []</tt> in the example above is needed on
--   GHC 7.8 and later; without it, <a>quickCheckAll</a> will not be able
--   to find any of the properties. For the curious, the <tt>return []</tt>
--   is a Template Haskell splice that makes GHC insert the empty list of
--   declarations at that point in the program; GHC typechecks everything
--   before the <tt>return []</tt> before it starts on the rest of the
--   module, which means that the later call to <a>quickCheckAll</a> can
--   see everything that was defined before the <tt>return []</tt>. Yikes!
quickCheckAll :: Q Exp

-- | Test all properties in the current module. This is just a convenience
--   function that combines <a>quickCheckAll</a> and <a>verbose</a>.
--   
--   <a>verboseCheckAll</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
verboseCheckAll :: Q Exp

-- | Test all properties in the current module, using a custom
--   <a>quickCheck</a> function. The same caveats as with
--   <a>quickCheckAll</a> apply.
--   
--   <tt>$<a>forAllProperties</a></tt> has type <tt>(<a>Property</a> -&gt;
--   <a>IO</a> <a>Result</a>) -&gt; <a>IO</a> <a>Bool</a></tt>. An example
--   invocation is <tt>$<a>forAllProperties</a>
--   <a>quickCheckResult</a></tt>, which does the same thing as
--   <tt>$<a>quickCheckAll</a></tt>.
--   
--   <a>forAllProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
forAllProperties :: Q Exp

-- | List all properties in the current module.
--   
--   <tt>$<a>allProperties</a></tt> has type <tt>[(<a>String</a>,
--   <a>Property</a>)]</tt>.
--   
--   <a>allProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
allProperties :: Q Exp

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>.
--   
--   Invoke as <tt>$(<a>polyQuickCheck</a> 'prop)</tt>, where <tt>prop</tt>
--   is a property. Note that just evaluating <tt><a>quickCheck</a>
--   prop</tt> in GHCi will seem to work, but will silently default all
--   type variables to <tt>()</tt>!
--   
--   <tt>$(<a>polyQuickCheck</a> 'prop)</tt> means the same as
--   <tt><a>quickCheck</a> $(<a>monomorphic</a> 'prop)</tt>. If you want to
--   supply custom arguments to <a>polyQuickCheck</a>, you will have to
--   combine <a>quickCheckWith</a> and <a>monomorphic</a> yourself.
--   
--   If you want to use <a>polyQuickCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyQuickCheck :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>. This is just a convenience function that combines
--   <a>verboseCheck</a> and <a>monomorphic</a>.
--   
--   If you want to use <a>polyVerboseCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyVerboseCheck :: Name -> ExpQ

-- | Monomorphise an arbitrary property by defaulting all type variables to
--   <a>Integer</a>.
--   
--   For example, if <tt>f</tt> has type <tt><a>Ord</a> a =&gt; [a] -&gt;
--   [a]</tt> then <tt>$(<a>monomorphic</a> 'f)</tt> has type
--   <tt>[<a>Integer</a>] -&gt; [<a>Integer</a>]</tt>.
--   
--   If you want to use <a>monomorphic</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
monomorphic :: Name -> ExpQ


-- | The <a>QuickCheck manual</a> gives detailed information about using
--   QuickCheck effectively. You can also try
--   <a>https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html</a>,
--   a tutorial written by a user of QuickCheck.
--   
--   To start using QuickCheck, write down your property as a function
--   returning <tt>Bool</tt>. For example, to check that reversing a list
--   twice gives back the same list you can write:
--   
--   <pre>
--   import Test.QuickCheck
--   
--   prop_reverse :: [Int] -&gt; Bool
--   prop_reverse xs = reverse (reverse xs) == xs
--   </pre>
--   
--   You can then use QuickCheck to test <tt>prop_reverse</tt> on 100
--   random lists:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_reverse
--   +++ OK, passed 100 tests.
--   </pre>
--   
--   To run more tests you can use the <a>withMaxSuccess</a> combinator:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck (withMaxSuccess 10000 prop_reverse)
--   +++ OK, passed 10000 tests.
--   </pre>
--   
--   To use QuickCheck on your own data types you will need to write
--   <a>Arbitrary</a> instances for those types. See the <a>QuickCheck
--   manual</a> for details about how to do that.
module Test.QuickCheck

-- | Tests a property and prints the results to <tt>stdout</tt>.
--   
--   By default up to 100 tests are performed, which may not be enough to
--   find all bugs. To run more tests, use <a>withMaxSuccess</a>.
--   
--   If you want to get the counterexample as a Haskell value, rather than
--   just printing it, try the <a>quickcheck-with-counterexamples</a>
--   package.
quickCheck :: Testable prop => prop -> IO ()

-- | Args specifies arguments to the QuickCheck driver
data Args
Args :: Maybe (QCGen, Int) -> Int -> Int -> Int -> Bool -> Int -> Args

-- | Should we replay a previous test? Note: saving a seed from one version
--   of QuickCheck and replaying it in another is not supported. If you
--   want to store a test case permanently you should save the test case
--   itself.
[replay] :: Args -> Maybe (QCGen, Int)

-- | Maximum number of successful tests before succeeding. Testing stops at
--   the first failure. If all tests are passing and you want to run more
--   tests, increase this number.
[maxSuccess] :: Args -> Int

-- | Maximum number of discarded tests per successful test before giving up
[maxDiscardRatio] :: Args -> Int

-- | Size to use for the biggest test cases
[maxSize] :: Args -> Int

-- | Whether to print anything
[chatty] :: Args -> Bool

-- | Maximum number of shrinks to before giving up. Setting this to zero
--   turns shrinking off.
[maxShrinks] :: Args -> Int

-- | Result represents the test result
data Result

-- | A successful test run
Success :: Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | Number of tests performed
[numTests] :: Result -> Int

-- | Number of tests skipped
[numDiscarded] :: Result -> Int

-- | The number of test cases having each combination of labels (see
--   <a>label</a>)
[labels] :: Result -> !Map [String] Int

-- | The number of test cases having each class (see <a>classify</a>)
[classes] :: Result -> !Map String Int

-- | Data collected by <a>tabulate</a>
[tables] :: Result -> !Map String (Map String Int)

-- | Printed output
[output] :: Result -> String

-- | Given up
GaveUp :: Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | Number of tests performed
[numTests] :: Result -> Int

-- | Number of tests skipped
[numDiscarded] :: Result -> Int

-- | The number of test cases having each combination of labels (see
--   <a>label</a>)
[labels] :: Result -> !Map [String] Int

-- | The number of test cases having each class (see <a>classify</a>)
[classes] :: Result -> !Map String Int

-- | Data collected by <a>tabulate</a>
[tables] :: Result -> !Map String (Map String Int)

-- | Printed output
[output] :: Result -> String

-- | A failed test run
Failure :: Int -> Int -> Int -> Int -> Int -> QCGen -> Int -> String -> Maybe AnException -> String -> [String] -> [String] -> Set String -> Result

-- | Number of tests performed
[numTests] :: Result -> Int

-- | Number of tests skipped
[numDiscarded] :: Result -> Int

-- | Number of successful shrinking steps performed
[numShrinks] :: Result -> Int

-- | Number of unsuccessful shrinking steps performed
[numShrinkTries] :: Result -> Int

-- | Number of unsuccessful shrinking steps performed since last successful
--   shrink
[numShrinkFinal] :: Result -> Int

-- | What seed was used
[usedSeed] :: Result -> QCGen

-- | What was the test size
[usedSize] :: Result -> Int

-- | Why did the property fail
[reason] :: Result -> String

-- | The exception the property threw, if any
[theException] :: Result -> Maybe AnException

-- | Printed output
[output] :: Result -> String

-- | The test case which provoked the failure
[failingTestCase] :: Result -> [String]

-- | The test case's labels (see <a>label</a>)
[failingLabels] :: Result -> [String]

-- | The test case's classes (see <a>classify</a>)
[failingClasses] :: Result -> Set String

-- | A property that should have failed did not
NoExpectedFailure :: Int -> Int -> !Map [String] Int -> !Map String Int -> !Map String (Map String Int) -> String -> Result

-- | Number of tests performed
[numTests] :: Result -> Int

-- | Number of tests skipped
[numDiscarded] :: Result -> Int

-- | The number of test cases having each combination of labels (see
--   <a>label</a>)
[labels] :: Result -> !Map [String] Int

-- | The number of test cases having each class (see <a>classify</a>)
[classes] :: Result -> !Map String Int

-- | Data collected by <a>tabulate</a>
[tables] :: Result -> !Map String (Map String Int)

-- | Printed output
[output] :: Result -> String

-- | The default test arguments
stdArgs :: Args

-- | Tests a property, using test arguments, and prints the results to
--   <tt>stdout</tt>.
quickCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results to <tt>stdout</tt>.
quickCheckWithResult :: Testable prop => Args -> prop -> IO Result

-- | Tests a property, produces a test result, and prints the results to
--   <tt>stdout</tt>.
quickCheckResult :: Testable prop => prop -> IO Result

-- | Check if the test run result was a success
isSuccess :: Result -> Bool

-- | Tests a property and prints the results and all test cases generated
--   to <tt>stdout</tt>. This is just a convenience function that means the
--   same as <tt><a>quickCheck</a> . <a>verbose</a></tt>.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verboseCheck :: Testable prop => prop -> IO ()

-- | Tests a property, using test arguments, and prints the results and all
--   test cases generated to <tt>stdout</tt>. This is just a convenience
--   function that combines <a>quickCheckWith</a> and <a>verbose</a>.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verboseCheckWith :: Testable prop => Args -> prop -> IO ()

-- | Tests a property, using test arguments, produces a test result, and
--   prints the results and all test cases generated to <tt>stdout</tt>.
--   This is just a convenience function that combines
--   <a>quickCheckWithResult</a> and <a>verbose</a>.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verboseCheckWithResult :: Testable prop => Args -> prop -> IO Result

-- | Tests a property, produces a test result, and prints the results and
--   all test cases generated to <tt>stdout</tt>. This is just a
--   convenience function that combines <a>quickCheckResult</a> and
--   <a>verbose</a>.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verboseCheckResult :: Testable prop => prop -> IO Result

-- | Test all properties in the current module. The name of the property
--   must begin with <tt>prop_</tt>. Polymorphic properties will be
--   defaulted to <a>Integer</a>. Returns <a>True</a> if all tests
--   succeeded, <a>False</a> otherwise.
--   
--   To use <a>quickCheckAll</a>, add a definition to your module along the
--   lines of
--   
--   <pre>
--   return []
--   runTests = $quickCheckAll
--   </pre>
--   
--   and then execute <tt>runTests</tt>.
--   
--   Note: the bizarre <tt>return []</tt> in the example above is needed on
--   GHC 7.8 and later; without it, <a>quickCheckAll</a> will not be able
--   to find any of the properties. For the curious, the <tt>return []</tt>
--   is a Template Haskell splice that makes GHC insert the empty list of
--   declarations at that point in the program; GHC typechecks everything
--   before the <tt>return []</tt> before it starts on the rest of the
--   module, which means that the later call to <a>quickCheckAll</a> can
--   see everything that was defined before the <tt>return []</tt>. Yikes!
quickCheckAll :: Q Exp

-- | Test all properties in the current module. This is just a convenience
--   function that combines <a>quickCheckAll</a> and <a>verbose</a>.
--   
--   <a>verboseCheckAll</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
verboseCheckAll :: Q Exp

-- | Test all properties in the current module, using a custom
--   <a>quickCheck</a> function. The same caveats as with
--   <a>quickCheckAll</a> apply.
--   
--   <tt>$<a>forAllProperties</a></tt> has type <tt>(<a>Property</a> -&gt;
--   <a>IO</a> <a>Result</a>) -&gt; <a>IO</a> <a>Bool</a></tt>. An example
--   invocation is <tt>$<a>forAllProperties</a>
--   <a>quickCheckResult</a></tt>, which does the same thing as
--   <tt>$<a>quickCheckAll</a></tt>.
--   
--   <a>forAllProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
forAllProperties :: Q Exp

-- | List all properties in the current module.
--   
--   <tt>$<a>allProperties</a></tt> has type <tt>[(<a>String</a>,
--   <a>Property</a>)]</tt>.
--   
--   <a>allProperties</a> has the same issue with scoping as
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
allProperties :: Q Exp

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>.
--   
--   Invoke as <tt>$(<a>polyQuickCheck</a> 'prop)</tt>, where <tt>prop</tt>
--   is a property. Note that just evaluating <tt><a>quickCheck</a>
--   prop</tt> in GHCi will seem to work, but will silently default all
--   type variables to <tt>()</tt>!
--   
--   <tt>$(<a>polyQuickCheck</a> 'prop)</tt> means the same as
--   <tt><a>quickCheck</a> $(<a>monomorphic</a> 'prop)</tt>. If you want to
--   supply custom arguments to <a>polyQuickCheck</a>, you will have to
--   combine <a>quickCheckWith</a> and <a>monomorphic</a> yourself.
--   
--   If you want to use <a>polyQuickCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyQuickCheck :: Name -> ExpQ

-- | Test a polymorphic property, defaulting all type variables to
--   <a>Integer</a>. This is just a convenience function that combines
--   <a>verboseCheck</a> and <a>monomorphic</a>.
--   
--   If you want to use <a>polyVerboseCheck</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
polyVerboseCheck :: Name -> ExpQ

-- | Monomorphise an arbitrary property by defaulting all type variables to
--   <a>Integer</a>.
--   
--   For example, if <tt>f</tt> has type <tt><a>Ord</a> a =&gt; [a] -&gt;
--   [a]</tt> then <tt>$(<a>monomorphic</a> 'f)</tt> has type
--   <tt>[<a>Integer</a>] -&gt; [<a>Integer</a>]</tt>.
--   
--   If you want to use <a>monomorphic</a> in the same file where you
--   defined the property, the same scoping problems pop up as in
--   <a>quickCheckAll</a>: see the note there about <tt>return []</tt>.
monomorphic :: Name -> ExpQ

-- | Random generation and shrinking of values.
--   
--   QuickCheck provides <tt>Arbitrary</tt> instances for most types in
--   <tt>base</tt>, except those which incur extra dependencies. For a
--   wider range of <tt>Arbitrary</tt> instances see the
--   <a>quickcheck-instances</a> package.
class Arbitrary a

-- | A generator for values of the given type.
--   
--   It is worth spending time thinking about what sort of test data you
--   want - good generators are often the difference between finding bugs
--   and not finding them. You can use <a>sample</a>, <tt>label</tt> and
--   <tt>classify</tt> to check the quality of your test data.
--   
--   There is no generic <tt>arbitrary</tt> implementation included because
--   we don't know how to make a high-quality one. If you want one,
--   consider using the <a>testing-feat</a> or <a>generic-random</a>
--   packages.
--   
--   The <a>QuickCheck manual</a> goes into detail on how to write good
--   generators. Make sure to look at it, especially if your type is
--   recursive!
arbitrary :: Arbitrary a => Gen a

-- | Produces a (possibly) empty list of all the possible immediate shrinks
--   of the given value.
--   
--   The default implementation returns the empty list, so will not try to
--   shrink the value. If your data type has no special invariants, you can
--   enable shrinking by defining <tt>shrink = <a>genericShrink</a></tt>,
--   but by customising the behaviour of <tt>shrink</tt> you can often get
--   simpler counterexamples.
--   
--   Most implementations of <a>shrink</a> should try at least three
--   things:
--   
--   <ol>
--   <li>Shrink a term to any of its immediate subterms. You can use
--   <a>subterms</a> to do this.</li>
--   <li>Recursively apply <a>shrink</a> to all immediate subterms. You can
--   use <a>recursivelyShrink</a> to do this.</li>
--   <li>Type-specific shrinkings such as replacing a constructor by a
--   simpler constructor.</li>
--   </ol>
--   
--   For example, suppose we have the following implementation of binary
--   trees:
--   
--   <pre>
--   data Tree a = Nil | Branch a (Tree a) (Tree a)
--   </pre>
--   
--   We can then define <a>shrink</a> as follows:
--   
--   <pre>
--   shrink Nil = []
--   shrink (Branch x l r) =
--     -- shrink Branch to Nil
--     [Nil] ++
--     -- shrink to subterms
--     [l, r] ++
--     -- recursively shrink subterms
--     [Branch x' l' r' | (x', l', r') &lt;- shrink (x, l, r)]
--   </pre>
--   
--   There are a couple of subtleties here:
--   
--   <ul>
--   <li>QuickCheck tries the shrinking candidates in the order they appear
--   in the list, so we put more aggressive shrinking steps (such as
--   replacing the whole tree by <tt>Nil</tt>) before smaller ones (such as
--   recursively shrinking the subtrees).</li>
--   <li>It is tempting to write the last line as <tt>[Branch x' l' r' | x'
--   &lt;- shrink x, l' &lt;- shrink l, r' &lt;- shrink r]</tt> but this is
--   the <i>wrong thing</i>! It will force QuickCheck to shrink <tt>x</tt>,
--   <tt>l</tt> and <tt>r</tt> in tandem, and shrinking will stop once
--   <i>one</i> of the three is fully shrunk.</li>
--   </ul>
--   
--   There is a fair bit of boilerplate in the code above. We can avoid it
--   with the help of some generic functions. The function
--   <a>genericShrink</a> tries shrinking a term to all of its subterms
--   and, failing that, recursively shrinks the subterms. Using it, we can
--   define <a>shrink</a> as:
--   
--   <pre>
--   shrink x = shrinkToNil x ++ genericShrink x
--     where
--       shrinkToNil Nil = []
--       shrinkToNil (Branch _ l r) = [Nil]
--   </pre>
--   
--   <a>genericShrink</a> is a combination of <a>subterms</a>, which
--   shrinks a term to any of its subterms, and <a>recursivelyShrink</a>,
--   which shrinks all subterms of a term. These may be useful if you need
--   a bit more control over shrinking than <a>genericShrink</a> gives you.
--   
--   A final gotcha: we cannot define <a>shrink</a> as simply
--   <tt><a>shrink</a> x = Nil:<a>genericShrink</a> x</tt> as this shrinks
--   <tt>Nil</tt> to <tt>Nil</tt>, and shrinking will go into an infinite
--   loop.
--   
--   If all this leaves you bewildered, you might try <tt><a>shrink</a> =
--   <a>genericShrink</a></tt> to begin with, after deriving
--   <tt>Generic</tt> for your type. However, if your data type has any
--   special invariants, you will need to check that <a>genericShrink</a>
--   can't break those invariants.
shrink :: Arbitrary a => a -> [a]

-- | Shrink a term to any of its immediate subterms, and also recursively
--   shrink all subterms.
genericShrink :: (Generic a, RecursivelyShrink (Rep a), GSubterms (Rep a) a) => a -> [a]

-- | All immediate subterms of a term.
subterms :: (Generic a, GSubterms (Rep a) a) => a -> [a]

-- | Recursively shrink all immediate subterms.
recursivelyShrink :: (Generic a, RecursivelyShrink (Rep a)) => a -> [a]

-- | Returns no shrinking alternatives.
shrinkNothing :: a -> [a]

-- | Shrink a list of values given a shrinking function for individual
--   values.
shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- | Map a shrink function to another domain. This is handy if your data
--   type has special invariants, but is <i>almost</i> isomorphic to some
--   other type.
--   
--   <pre>
--   shrinkOrderedList :: (Ord a, Arbitrary a) =&gt; [a] -&gt; [[a]]
--   shrinkOrderedList = shrinkMap sort id
--   
--   shrinkSet :: (Ord a, Arbitrary a) =&gt; Set a -&gt; [Set a]
--   shrinkSet = shrinkMap fromList toList
--   </pre>
shrinkMap :: Arbitrary a => (a -> b) -> (b -> a) -> b -> [b]

-- | Non-overloaded version of <a>shrinkMap</a>.
shrinkMapBy :: (a -> b) -> (b -> a) -> (a -> [a]) -> b -> [b]

-- | Shrink an integral number.
shrinkIntegral :: Integral a => a -> [a]

-- | Shrink a fraction, preferring numbers with smaller numerators or
--   denominators. See also <a>shrinkDecimal</a>.
shrinkRealFrac :: RealFrac a => a -> [a]

-- | Shrink an element of a bounded enumeration.
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   data MyEnum = E0 | E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9
--      deriving (Bounded, Enum, Eq, Ord, Show)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E9
--   [E0,E5,E7,E8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E5
--   [E0,E3,E4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkBoundedEnum E0
--   []
--   </pre>
shrinkBoundedEnum :: (Bounded a, Enum a, Eq a) => a -> [a]

-- | Shrink a real number, preferring numbers with shorter decimal
--   representations. See also <a>shrinkRealFrac</a>.
shrinkDecimal :: RealFrac a => a -> [a]

-- | Lifting of the <a>Arbitrary</a> class to unary type constructors.
class Arbitrary1 f
liftArbitrary :: Arbitrary1 f => Gen a -> Gen (f a)
liftShrink :: Arbitrary1 f => (a -> [a]) -> f a -> [f a]
arbitrary1 :: (Arbitrary1 f, Arbitrary a) => Gen (f a)
shrink1 :: (Arbitrary1 f, Arbitrary a) => f a -> [f a]

-- | Lifting of the <a>Arbitrary</a> class to binary type constructors.
class Arbitrary2 f
liftArbitrary2 :: Arbitrary2 f => Gen a -> Gen b -> Gen (f a b)
liftShrink2 :: Arbitrary2 f => (a -> [a]) -> (b -> [b]) -> f a b -> [f a b]
arbitrary2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => Gen (f a b)
shrink2 :: (Arbitrary2 f, Arbitrary a, Arbitrary b) => f a b -> [f a b]

-- | A generator for values of type <tt>a</tt>.
--   
--   The third-party packages <a>QuickCheck-GenT</a> and
--   <a>quickcheck-transformer</a> provide monad transformer versions of
--   <tt>Gen</tt>.
data Gen a

-- | Generates a random element in the given inclusive range. For integral
--   and enumerated types, the specialised variants of <a>choose</a> below
--   run much quicker.
choose :: Random a => (a, a) -> Gen a

-- | A fast implementation of <a>choose</a> for <a>Int</a>.
chooseInt :: (Int, Int) -> Gen Int

-- | A fast implementation of <a>choose</a> for <a>Integer</a>.
chooseInteger :: (Integer, Integer) -> Gen Integer

-- | A fast implementation of <a>choose</a> for bounded integral types.
chooseBoundedIntegral :: (Bounded a, Integral a) => (a, a) -> Gen a

-- | A fast implementation of <a>choose</a> for enumerated types.
chooseEnum :: Enum a => (a, a) -> Gen a

-- | Generates a random element over the natural range of <tt>a</tt>.
chooseAny :: Random a => Gen a

-- | Randomly uses one of the given generators. The input list must be
--   non-empty.
oneof :: [Gen a] -> Gen a

-- | Chooses one of the given generators, with a weighted random
--   distribution. The input list must be non-empty.
frequency :: [(Int, Gen a)] -> Gen a

-- | Generates one of the given values. The input list must be non-empty.
elements :: [a] -> Gen a

-- | Takes a list of elements of increasing size, and chooses among an
--   initial segment of the list. The size of this initial segment
--   increases with the size parameter. The input list must be non-empty.
growingElements :: [a] -> Gen a

-- | Used to construct generators that depend on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = sized $ \n -&gt;
--     do k &lt;- choose (0,n)
--        vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>getSize</a>.
sized :: (Int -> Gen a) -> Gen a

-- | Returns the size parameter. Used to construct generators that depend
--   on the size parameter.
--   
--   For example, <a>listOf</a>, which uses the size parameter as an upper
--   bound on length of lists it generates, can be defined like this:
--   
--   <pre>
--   listOf :: Gen a -&gt; Gen [a]
--   listOf gen = do
--     n &lt;- getSize
--     k &lt;- choose (0,n)
--     vectorOf k gen
--   </pre>
--   
--   You can also do this using <a>sized</a>.
getSize :: Gen Int

-- | Overrides the size parameter. Returns a generator which uses the given
--   size instead of the runtime-size parameter.
resize :: Int -> Gen a -> Gen a

-- | Adjust the size parameter, by transforming it with the given function.
scale :: (Int -> Int) -> Gen a -> Gen a

-- | Generates a value that satisfies a predicate.
suchThat :: Gen a -> (a -> Bool) -> Gen a

-- | Generates a value for which the given function returns a <a>Just</a>,
--   and then applies the function.
suchThatMap :: Gen a -> (a -> Maybe b) -> Gen b

-- | Tries to generate a value that satisfies a predicate. If it fails to
--   do so after enough attempts, returns <tt>Nothing</tt>.
suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)

-- | Apply a binary function to random arguments.
applyArbitrary2 :: (Arbitrary a, Arbitrary b) => (a -> b -> r) -> Gen r

-- | Apply a ternary function to random arguments.
applyArbitrary3 :: (Arbitrary a, Arbitrary b, Arbitrary c) => (a -> b -> c -> r) -> Gen r

-- | Apply a function of arity 4 to random arguments.
applyArbitrary4 :: (Arbitrary a, Arbitrary b, Arbitrary c, Arbitrary d) => (a -> b -> c -> d -> r) -> Gen r

-- | Generates a list of random length. The maximum length depends on the
--   size parameter.
listOf :: Gen a -> Gen [a]

-- | Generates a non-empty list of random length. The maximum length
--   depends on the size parameter.
listOf1 :: Gen a -> Gen [a]

-- | Generates a list of the given length.
vectorOf :: Int -> Gen a -> Gen [a]

-- | Generates a list of a given length.
vector :: Arbitrary a => Int -> Gen [a]

-- | Generates an infinite list.
infiniteListOf :: Gen a -> Gen [a]

-- | Generates an infinite list.
infiniteList :: Arbitrary a => Gen [a]

-- | Generates a random permutation of the given list.
shuffle :: [a] -> Gen [a]

-- | Generates a random subsequence of the given list.
sublistOf :: [a] -> Gen [a]

-- | Generates an ordered list.
orderedList :: (Ord a, Arbitrary a) => Gen [a]

-- | Generates an integral number. The number can be positive or negative
--   and its maximum absolute value depends on the size parameter.
arbitrarySizedIntegral :: Integral a => Gen a

-- | Generates a natural number. The number's maximum value depends on the
--   size parameter.
arbitrarySizedNatural :: Integral a => Gen a

-- | Uniformly generates a fractional number. The number can be positive or
--   negative and its maximum absolute value depends on the size parameter.
arbitrarySizedFractional :: Fractional a => Gen a

-- | Generates an integral number from a bounded domain. The number is
--   chosen from the entire range of the type, but small numbers are
--   generated more often than big numbers. Inspired by demands from Phil
--   Wadler.
arbitrarySizedBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an integral number. The number is chosen uniformly from the
--   entire range of the type. You may want to use
--   <a>arbitrarySizedBoundedIntegral</a> instead.
arbitraryBoundedIntegral :: (Bounded a, Integral a) => Gen a

-- | Generates an element of a bounded type. The element is chosen from the
--   entire range of the type.
arbitraryBoundedRandom :: (Bounded a, Random a) => Gen a

-- | Generates an element of a bounded enumeration.
arbitraryBoundedEnum :: (Bounded a, Enum a) => Gen a

-- | Generates any Unicode character (but not a surrogate)
arbitraryUnicodeChar :: Gen Char

-- | Generates a random ASCII character (0-127).
arbitraryASCIIChar :: Gen Char

-- | Generates a printable Unicode character.
arbitraryPrintableChar :: Gen Char

-- | Run a generator. The size passed to the generator is always 30; if you
--   want another size then you should explicitly use <a>resize</a>.
generate :: Gen a -> IO a

-- | Generates some example values and prints them to <tt>stdout</tt>.
sample :: Show a => Gen a -> IO ()

-- | Generates some example values.
sample' :: Gen a -> IO [a]

-- | Generation of random shrinkable, showable functions.
--   
--   To generate random values of type <tt><a>Fun</a> a b</tt>, you must
--   have an instance <tt><a>Function</a> a</tt>.
--   
--   See also <a>applyFun</a>, and <a>Fn</a> with GHC &gt;= 7.8.
data Fun a b
Fun :: (a :-> b, b, Shrunk) -> (a -> b) -> Fun a b

-- | Extracts the value of a function.
--   
--   <a>Fn</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop f = applyFun f "banana" == applyFun f "monkey"
--         || applyFun f "banana" == applyFun f "elephant"
--   </pre>
applyFun :: Fun a b -> a -> b

-- | Extracts the value of a binary function.
--   
--   <a>Fn2</a> is the pattern equivalent of this function.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith f xs ys = zipWith (applyFun2 f) xs ys == [ applyFun2 f x y | (x, y) &lt;- zip xs ys]
--   </pre>
applyFun2 :: Fun (a, b) c -> a -> b -> c

-- | Extracts the value of a ternary function. <a>Fn3</a> is the pattern
--   equivalent of this function.
applyFun3 :: Fun (a, b, c) d -> a -> b -> c -> d

-- | A modifier for testing functions.
--   
--   <pre>
--   prop :: Fun String Integer -&gt; Bool
--   prop (Fn f) = f "banana" == f "monkey"
--              || f "banana" == f "elephant"
--   </pre>
pattern Fn :: (a -> b) -> Fun a b

-- | A modifier for testing binary functions.
--   
--   <pre>
--   prop_zipWith :: Fun (Int, Bool) Char -&gt; [Int] -&gt; [Bool] -&gt; Bool
--   prop_zipWith (Fn2 f) xs ys = zipWith f xs ys == [ f x y | (x, y) &lt;- zip xs ys]
--   </pre>
pattern Fn2 :: (a -> b -> c) -> Fun (a, b) c

-- | A modifier for testing ternary functions.
pattern Fn3 :: (a -> b -> c -> d) -> Fun (a, b, c) d

-- | The class <tt>Function a</tt> is used for random generation of
--   showable functions of type <tt>a -&gt; b</tt>.
--   
--   There is a default implementation for <a>function</a>, which you can
--   use if your type has structural equality. Otherwise, you can normally
--   use <a>functionMap</a> or <a>functionShow</a>.
class Function a
function :: Function a => (a -> b) -> a :-> b
function :: (Function a, Generic a, GFunction (Rep a)) => (a -> b) -> a :-> b

-- | The basic building block for <a>Function</a> instances. Provides a
--   <a>Function</a> instance by mapping to and from a type that already
--   has a <a>Function</a> instance.
functionMap :: Function b => (a -> b) -> (b -> a) -> (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types with <a>Show</a> and
--   <a>Read</a>.
functionShow :: (Show a, Read a) => (a -> c) -> a :-> c

-- | Provides a <a>Function</a> instance for types with <a>Integral</a>.
functionIntegral :: Integral a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>RealFrac</a>.
functionRealFrac :: RealFrac a => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types with <a>Bounded</a> and
--   <a>Enum</a>. Use only for small types (i.e. not integers): creates the
--   list <tt>[<a>minBound</a>..<a>maxBound</a>]</tt>!
functionBoundedEnum :: (Eq a, Bounded a, Enum a) => (a -> b) -> a :-> b

-- | Provides a <a>Function</a> instance for types isomorphic to
--   <a>Void</a>.
--   
--   An actual <tt><a>Function</a> <a>Void</a></tt> instance is defined in
--   <tt>quickcheck-instances</tt>.
functionVoid :: (forall b. void -> b) -> void :-> c

-- | Used for random generation of functions. You should consider using
--   <a>Fun</a> instead, which can show the generated functions as strings.
--   
--   If you are using a recent GHC, there is a default definition of
--   <a>coarbitrary</a> using <a>genericCoarbitrary</a>, so if your type
--   has a <a>Generic</a> instance it's enough to say
--   
--   <pre>
--   instance CoArbitrary MyType
--   </pre>
--   
--   You should only use <a>genericCoarbitrary</a> for data types where
--   equality is structural, i.e. if you can't have two different
--   representations of the same value. An example where it's not safe is
--   sets implemented using binary search trees: the same set can be
--   represented as several different trees. Here you would have to
--   explicitly define <tt>coarbitrary s = coarbitrary (toList s)</tt>.
class CoArbitrary a

-- | Used to generate a function of type <tt>a -&gt; b</tt>. The first
--   argument is a value, the second a generator. You should use
--   <a>variant</a> to perturb the random generator; the goal is that
--   different values for the first argument will lead to different calls
--   to <a>variant</a>. An example will help:
--   
--   <pre>
--   instance CoArbitrary a =&gt; CoArbitrary [a] where
--     coarbitrary []     = <a>variant</a> 0
--     coarbitrary (x:xs) = <a>variant</a> 1 . coarbitrary (x,xs)
--   </pre>
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b

-- | Used to generate a function of type <tt>a -&gt; b</tt>. The first
--   argument is a value, the second a generator. You should use
--   <a>variant</a> to perturb the random generator; the goal is that
--   different values for the first argument will lead to different calls
--   to <a>variant</a>. An example will help:
--   
--   <pre>
--   instance CoArbitrary a =&gt; CoArbitrary [a] where
--     coarbitrary []     = <a>variant</a> 0
--     coarbitrary (x:xs) = <a>variant</a> 1 . coarbitrary (x,xs)
--   </pre>
coarbitrary :: (CoArbitrary a, Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Generic CoArbitrary implementation.
genericCoarbitrary :: (Generic a, GCoArbitrary (Rep a)) => a -> Gen b -> Gen b

-- | Modifies a generator using an integer seed.
variant :: Integral n => n -> Gen a -> Gen a

-- | A <a>coarbitrary</a> implementation for integral numbers.
coarbitraryIntegral :: Integral a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for real numbers.
coarbitraryReal :: Real a => a -> Gen b -> Gen b

-- | <a>coarbitrary</a> helper for lazy people :-).
coarbitraryShow :: Show a => a -> Gen b -> Gen b

-- | A <a>coarbitrary</a> implementation for enums.
coarbitraryEnum :: Enum a => a -> Gen b -> Gen b

-- | Combine two generator perturbing functions, for example the results of
--   calls to <a>variant</a> or <a>coarbitrary</a>.

-- | <i>Deprecated: Use ordinary function composition instead</i>
(><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a

-- | <tt>Blind x</tt>: as x, but x does not have to be in the <a>Show</a>
--   class.
newtype Blind a
Blind :: a -> Blind a
[getBlind] :: Blind a -> a

-- | <tt>Fixed x</tt>: as x, but will not be shrunk.
newtype Fixed a
Fixed :: a -> Fixed a
[getFixed] :: Fixed a -> a

-- | <tt>Ordered xs</tt>: guarantees that xs is ordered.
newtype OrderedList a
Ordered :: [a] -> OrderedList a
[getOrdered] :: OrderedList a -> [a]

-- | <tt>NonEmpty xs</tt>: guarantees that xs is non-empty.
newtype NonEmptyList a
NonEmpty :: [a] -> NonEmptyList a
[getNonEmpty] :: NonEmptyList a -> [a]

-- | <tt>InfiniteList xs _</tt>: guarantees that xs is an infinite list.
--   When a counterexample is found, only prints the prefix of xs that was
--   used by the program.
--   
--   Here is a contrived example property:
--   
--   <pre>
--   prop_take_10 :: InfiniteList Char -&gt; Bool
--   prop_take_10 (InfiniteList xs _) =
--     or [ x == 'a' | x &lt;- take 10 xs ]
--   </pre>
--   
--   In the following counterexample, the list must start with
--   <tt>"bbbbbbbbbb"</tt> but the remaining (infinite) part can contain
--   anything:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_take_10
--   *** Failed! Falsified (after 1 test and 14 shrinks):
--   "bbbbbbbbbb" ++ ...
--   </pre>
data InfiniteList a
InfiniteList :: [a] -> InfiniteListInternalData a -> InfiniteList a
[getInfiniteList] :: InfiniteList a -> [a]
[infiniteListInternalData] :: InfiniteList a -> InfiniteListInternalData a

-- | <tt>Sorted xs</tt>: guarantees that xs is sorted.
newtype SortedList a
Sorted :: [a] -> SortedList a
[getSorted] :: SortedList a -> [a]

-- | <tt>Positive x</tt>: guarantees that <tt>x &gt; 0</tt>.
newtype Positive a
Positive :: a -> Positive a
[getPositive] :: Positive a -> a

-- | <tt>Negative x</tt>: guarantees that <tt>x &lt; 0</tt>.
newtype Negative a
Negative :: a -> Negative a
[getNegative] :: Negative a -> a

-- | <tt>NonZero x</tt>: guarantees that <tt>x /= 0</tt>.
newtype NonZero a
NonZero :: a -> NonZero a
[getNonZero] :: NonZero a -> a

-- | <tt>NonNegative x</tt>: guarantees that <tt>x &gt;= 0</tt>.
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a

-- | <tt>NonPositive x</tt>: guarantees that <tt>x &lt;= 0</tt>.
newtype NonPositive a
NonPositive :: a -> NonPositive a
[getNonPositive] :: NonPositive a -> a

-- | <tt>Large x</tt>: by default, QuickCheck generates <a>Int</a>s drawn
--   from a small range. <tt>Large Int</tt> gives you values drawn from the
--   entire range instead.
newtype Large a
Large :: a -> Large a
[getLarge] :: Large a -> a

-- | <tt>Small x</tt>: generates values of <tt>x</tt> drawn from a small
--   range. The opposite of <a>Large</a>.
newtype Small a
Small :: a -> Small a
[getSmall] :: Small a -> a

-- | <tt>Smart _ x</tt>: tries a different order when shrinking.
data Smart a
Smart :: Int -> a -> Smart a

-- | <tt>Shrink2 x</tt>: allows 2 shrinking steps at the same time when
--   shrinking x
newtype Shrink2 a
Shrink2 :: a -> Shrink2 a
[getShrink2] :: Shrink2 a -> a

-- | <tt>Shrinking _ x</tt>: allows for maintaining a state during
--   shrinking.
data Shrinking s a
Shrinking :: s -> a -> Shrinking s a
class ShrinkState s a
shrinkInit :: ShrinkState s a => a -> s
shrinkState :: ShrinkState s a => a -> s -> [(a, s)]

-- | <tt>ASCIIString</tt>: generates an ASCII string.
newtype ASCIIString
ASCIIString :: String -> ASCIIString
[getASCIIString] :: ASCIIString -> String

-- | <tt>UnicodeString</tt>: generates a unicode String. The string will
--   not contain surrogate pairs.
newtype UnicodeString
UnicodeString :: String -> UnicodeString
[getUnicodeString] :: UnicodeString -> String

-- | <tt>PrintableString</tt>: generates a printable unicode String. The
--   string will not contain surrogate pairs.
newtype PrintableString
PrintableString :: String -> PrintableString
[getPrintableString] :: PrintableString -> String

-- | The type of properties.
data Property

-- | The class of properties, i.e., types which QuickCheck knows how to
--   test. Typically a property will be a function returning <a>Bool</a> or
--   <a>Property</a>.
--   
--   If a property does no quantification, i.e. has no parameters and
--   doesn't use <a>forAll</a>, it will only be tested once. This may not
--   be what you want if your property is an <tt>IO Bool</tt>. You can
--   change this behaviour using the <a>again</a> combinator.
class Testable prop

-- | Convert the thing to a property.
property :: Testable prop => prop -> Property

-- | Optional; used internally in order to improve shrinking. Tests a
--   property but also quantifies over an extra value (with a custom shrink
--   and show function). The <a>Testable</a> instance for functions defines
--   <tt>propertyForAllShrinkShow</tt> in a way that improves shrinking.
propertyForAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> [String]) -> (a -> prop) -> Property

-- | Explicit universal quantification: uses an explicitly given test case
--   generator.
forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but tries to shrink the argument for failing test
--   cases.
forAllShrink :: (Show a, Testable prop) => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but with an explicitly given show function.
forAllShow :: Testable prop => Gen a -> (a -> String) -> (a -> prop) -> Property

-- | Like <a>forAllShrink</a>, but with an explicitly given show function.
forAllShrinkShow :: Testable prop => Gen a -> (a -> [a]) -> (a -> String) -> (a -> prop) -> Property

-- | Like <a>forAll</a>, but without printing the generated value.
forAllBlind :: Testable prop => Gen a -> (a -> prop) -> Property

-- | Like <a>forAllShrink</a>, but without printing the generated value.
forAllShrinkBlind :: Testable prop => Gen a -> (a -> [a]) -> (a -> prop) -> Property

-- | Shrinks the argument to a property if it fails. Shrinking is done
--   automatically for most types. This function is only needed when you
--   want to override the default behavior.
shrinking :: Testable prop => (a -> [a]) -> a -> (a -> prop) -> Property

-- | Implication for properties: The resulting property holds if the first
--   argument is <a>False</a> (in which case the test case is discarded),
--   or if the given property holds. Note that using implication carelessly
--   can severely skew test case distribution: consider using <a>cover</a>
--   to make sure that your test data is still good quality.
(==>) :: Testable prop => Bool -> prop -> Property
infixr 0 ==>

-- | If a property returns <a>Discard</a>, the current test case is
--   discarded, the same as if a precondition was false.
--   
--   An example is the definition of <a>==&gt;</a>:
--   
--   <pre>
--   (==&gt;) :: Testable prop =&gt; Bool -&gt; prop -&gt; Property
--   False ==&gt; _ = property Discard
--   True  ==&gt; p = property p
--   </pre>
data Discard
Discard :: Discard

-- | A special error value. If a property evaluates <a>discard</a>, it
--   causes QuickCheck to discard the current test case. This can be useful
--   if you want to discard the current test case, but are somewhere you
--   can't use <a>==&gt;</a>, such as inside a generator.
discard :: a

-- | Like <a>==</a>, but prints a counterexample when it fails.
(===) :: (Eq a, Show a) => a -> a -> Property
infix 4 ===

-- | Like <a>/=</a>, but prints a counterexample when it fails.
(=/=) :: (Eq a, Show a) => a -> a -> Property
infix 4 =/=

-- | Checks that a value is total, i.e., doesn't crash when evaluated.
total :: NFData a => a -> Property

-- | Do I/O inside a property.
--   
--   Warning: any random values generated inside of the argument to
--   <tt>ioProperty</tt> will not currently be shrunk. For best results,
--   generate all random values before calling <tt>ioProperty</tt>, or use
--   <a>idempotentIOProperty</a> if that is safe.
--   
--   Note: if your property does no quantification, it will only be tested
--   once. To test it repeatedly, use <a>again</a>.
ioProperty :: Testable prop => IO prop -> Property

-- | Do I/O inside a property.
--   
--   Warning: during shrinking, the I/O may not always be re-executed.
--   Instead, the I/O may be executed once and then its result retained. If
--   this is not acceptable, use <a>ioProperty</a> instead.
idempotentIOProperty :: Testable prop => IO prop -> Property

-- | Prints out the generated test case every time the property is tested.
--   Only variables quantified over <i>inside</i> the <a>verbose</a> are
--   printed.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verbose :: Testable prop => prop -> Property

-- | Prints out the generated test case every time the property fails,
--   including during shrinking. Only variables quantified over
--   <i>inside</i> the <a>verboseShrinking</a> are printed.
--   
--   Note: for technical reasons, the test case is printed out <i>after</i>
--   the property is tested. To debug a property that goes into an infinite
--   loop, use <a>within</a> to add a timeout instead.
verboseShrinking :: Testable prop => prop -> Property

-- | Disables shrinking for a property altogether. Only quantification
--   <i>inside</i> the call to <a>noShrinking</a> is affected.
noShrinking :: Testable prop => prop -> Property

-- | Configures how many times a property will be tested.
--   
--   For example,
--   
--   <pre>
--   quickCheck (withMaxSuccess 1000 p)
--   </pre>
--   
--   will test <tt>p</tt> up to 1000 times.
withMaxSuccess :: Testable prop => Int -> prop -> Property

-- | Considers a property failed if it does not complete within the given
--   number of microseconds.
--   
--   Note: if the property times out, variables quantified inside the
--   <a>within</a> will not be printed. Therefore, you should use
--   <a>within</a> only in the body of your property.
--   
--   Good: <tt>prop_foo a b c = within 1000000 ...</tt>
--   
--   Bad: <tt>prop_foo = within 1000000 $ \a b c -&gt; ...</tt>
--   
--   Bad: <tt>prop_foo a b c = ...; main = quickCheck (within 1000000
--   prop_foo)</tt>
within :: Testable prop => Int -> prop -> Property

-- | Discards the test case if it does not complete within the given number
--   of microseconds. This can be useful when testing algorithms that have
--   pathological cases where they run extremely slowly.
discardAfter :: Testable prop => Int -> prop -> Property

-- | Modifies a property so that it only will be tested once. Opposite of
--   <a>again</a>.
once :: Testable prop => prop -> Property

-- | Modifies a property so that it will be tested repeatedly. Opposite of
--   <a>once</a>.
again :: Testable prop => prop -> Property

-- | Adjust the test case size for a property, by transforming it with the
--   given function.
mapSize :: Testable prop => (Int -> Int) -> prop -> Property

-- | Nondeterministic choice: <tt>p1</tt> <a>.&amp;.</a> <tt>p2</tt> picks
--   randomly one of <tt>p1</tt> and <tt>p2</tt> to test. If you test the
--   property 100 times it makes 100 random choices.
(.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .&.

-- | Conjunction: <tt>p1</tt> <a>.&amp;&amp;.</a> <tt>p2</tt> passes if
--   both <tt>p1</tt> and <tt>p2</tt> pass.
(.&&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .&&.

-- | Take the conjunction of several properties.
conjoin :: Testable prop => [prop] -> Property

-- | Disjunction: <tt>p1</tt> <a>.||.</a> <tt>p2</tt> passes unless
--   <tt>p1</tt> and <tt>p2</tt> simultaneously fail.
(.||.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
infixr 1 .||.

-- | Take the disjunction of several properties.
disjoin :: Testable prop => [prop] -> Property

-- | Adds the given string to the counterexample if the property fails.
counterexample :: Testable prop => String -> prop -> Property

-- | Adds the given string to the counterexample if the property fails.

-- | <i>Deprecated: Use counterexample instead</i>
printTestCase :: Testable prop => String -> prop -> Property

-- | Performs an <a>IO</a> action after the last failure of a property.
whenFail :: Testable prop => IO () -> prop -> Property

-- | Performs an <a>IO</a> action every time a property fails. Thus, if
--   shrinking is done, this can be used to keep track of the failures
--   along the way.
whenFail' :: Testable prop => IO () -> prop -> Property

-- | Indicates that a property is supposed to fail. QuickCheck will report
--   an error if it does not fail.
expectFailure :: Testable prop => prop -> Property

-- | Attaches a label to a test case. This is used for reporting test case
--   distribution.
--   
--   For example:
--   
--   <pre>
--   prop_reverse_reverse :: [Int] -&gt; Property
--   prop_reverse_reverse xs =
--     label ("length of input is " ++ show (length xs)) $
--       reverse (reverse xs) === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_reverse_reverse
--   +++ OK, passed 100 tests:
--   7% length of input is 7
--   6% length of input is 3
--   5% length of input is 4
--   4% length of input is 6
--   ...
--   </pre>
--   
--   Each use of <a>label</a> in your property results in a separate table
--   of test case distribution in the output. If this is not what you want,
--   use <a>tabulate</a>.
label :: Testable prop => String -> prop -> Property

-- | Attaches a label to a test case. This is used for reporting test case
--   distribution.
--   
--   <pre>
--   collect x = label (show x)
--   </pre>
--   
--   For example:
--   
--   <pre>
--   prop_reverse_reverse :: [Int] -&gt; Property
--   prop_reverse_reverse xs =
--     collect (length xs) $
--       reverse (reverse xs) === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_reverse_reverse
--   +++ OK, passed 100 tests:
--   7% 7
--   6% 3
--   5% 4
--   4% 6
--   ...
--   </pre>
--   
--   Each use of <a>collect</a> in your property results in a separate
--   table of test case distribution in the output. If this is not what you
--   want, use <a>tabulate</a>.
collect :: (Show a, Testable prop) => a -> prop -> Property

-- | Reports how many test cases satisfy a given condition.
--   
--   For example:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     classify (length xs &gt; 1) "non-trivial" $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests (22% non-trivial).
--   </pre>
classify :: Testable prop => Bool -> String -> prop -> Property

-- | Collects information about test case distribution into a table. The
--   arguments to <a>tabulate</a> are the table's name and a list of values
--   associated with the current test case. After testing, QuickCheck
--   prints the frequency of all collected values. The frequencies are
--   expressed as a percentage of the total number of values collected.
--   
--   You should prefer <a>tabulate</a> to <a>label</a> when each test case
--   is associated with a varying number of values. Here is a (not terribly
--   useful) example, where the test data is a list of integers and we
--   record all values that occur in the list:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     tabulate "List elements" (map show xs) $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests; 1684 discarded.
--   
--   List elements (109 in total):
--    3.7% 0
--    3.7% 17
--    3.7% 2
--    3.7% 6
--    2.8% -6
--    2.8% -7
--   </pre>
--   
--   Here is a more useful example. We are testing a chatroom, where the
--   user can log in, log out, or send a message:
--   
--   <pre>
--   data Command = LogIn | LogOut | SendMessage String deriving (Data, Show)
--   instance Arbitrary Command where ...
--   </pre>
--   
--   There are some restrictions on command sequences; for example, the
--   user must log in before doing anything else. The function <tt>valid ::
--   [Command] -&gt; Bool</tt> checks that a command sequence is allowed.
--   Our property then has the form:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     valid cmds ==&gt;
--       ...
--   </pre>
--   
--   The use of <a>==&gt;</a> may skew test case distribution. We use
--   <a>collect</a> to see the length of the command sequences, and
--   <a>tabulate</a> to get the frequencies of the individual commands:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     'collect' (length cmds) $
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheckWith stdArgs{maxDiscardRatio = 1000} prop_chatroom
--   +++ OK, passed 100 tests; 2775 discarded:
--   60% 0
--   20% 1
--   15% 2
--    3% 3
--    1% 4
--    1% 5
--   
--   Commands (68 in total):
--   62% LogIn
--   22% SendMessage
--   16% LogOut
--   </pre>
tabulate :: Testable prop => String -> [String] -> prop -> Property

-- | Checks that at least the given proportion of <i>successful</i> test
--   cases belong to the given class. Discarded tests (i.e. ones with a
--   false precondition) do not affect coverage.
--   
--   <b>Note:</b> If the coverage check fails, QuickCheck prints out a
--   warning, but the property does <i>not</i> fail. To make the property
--   fail, use <a>checkCoverage</a>.
--   
--   For example:
--   
--   <pre>
--   prop_sorted_sort :: [Int] -&gt; Property
--   prop_sorted_sort xs =
--     sorted xs ==&gt;
--     cover 50 (length xs &gt; 1) "non-trivial" $
--     sort xs === xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_sorted_sort
--   +++ OK, passed 100 tests; 135 discarded (26% non-trivial).
--   
--   Only 26% non-trivial, but expected 50%
--   </pre>
cover :: Testable prop => Double -> Bool -> String -> prop -> Property

-- | Checks that the values in a given <tt>table</tt> appear a certain
--   proportion of the time. A call to <a>coverTable</a> <tt>table</tt>
--   <tt>[(x1, p1), ..., (xn, pn)]</tt> asserts that of the values in
--   <tt>table</tt>, <tt>x1</tt> should appear at least <tt>p1</tt> percent
--   of the time, <tt>x2</tt> at least <tt>p2</tt> percent of the time, and
--   so on.
--   
--   <b>Note:</b> If the coverage check fails, QuickCheck prints out a
--   warning, but the property does <i>not</i> fail. To make the property
--   fail, use <a>checkCoverage</a>.
--   
--   Continuing the example from the <tt>tabular</tt> combinator...
--   
--   <pre>
--   data Command = LogIn | LogOut | SendMessage String deriving (Data, Show)
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ...
--   </pre>
--   
--   ...we can add a coverage requirement as follows, which checks that
--   <tt>LogIn</tt>, <tt>LogOut</tt> and <tt>SendMessage</tt> each occur at
--   least 25% of the time:
--   
--   <pre>
--   prop_chatroom :: [Command] -&gt; Property
--   prop_chatroom cmds =
--     wellFormed cmds LoggedOut ==&gt;
--     coverTable "Commands" [("LogIn", 25), ("LogOut", 25), ("SendMessage", 25)] $
--     'tabulate' "Commands" (map (show . 'Data.Data.toConstr') cmds) $
--       ... property goes here ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_chatroom
--   +++ OK, passed 100 tests; 2909 discarded:
--   56% 0
--   17% 1
--   10% 2
--    6% 3
--    5% 4
--    3% 5
--    3% 7
--   
--   Commands (111 in total):
--   51.4% LogIn
--   30.6% SendMessage
--   18.0% LogOut
--   
--   Table 'Commands' had only 18.0% LogOut, but expected 25.0%
--   </pre>
coverTable :: Testable prop => String -> [(String, Double)] -> prop -> Property

-- | Check that all coverage requirements defined by <a>cover</a> and
--   <a>coverTable</a> are met, using a statistically sound test, and fail
--   if they are not met.
--   
--   Ordinarily, a failed coverage check does not cause the property to
--   fail. This is because the coverage requirement is not tested in a
--   statistically sound way. If you use <a>cover</a> to express that a
--   certain value must appear 20% of the time, QuickCheck will warn you if
--   the value only appears in 19 out of 100 test cases - but since the
--   coverage varies randomly, you may have just been unlucky, and there
--   may not be any real problem with your test generation.
--   
--   When you use <a>checkCoverage</a>, QuickCheck uses a statistical test
--   to account for the role of luck in coverage failures. It will run as
--   many tests as needed until it is sure about whether the coverage
--   requirements are met. If a coverage requirement is not met, the
--   property fails.
--   
--   Example:
--   
--   <pre>
--   quickCheck (checkCoverage prop_foo)
--   </pre>
checkCoverage :: Testable prop => prop -> Property

-- | Check coverage requirements using a custom confidence level. See
--   <a>stdConfidence</a>.
--   
--   An example of making the statistical test less stringent in order to
--   improve performance:
--   
--   <pre>
--   quickCheck (checkCoverageWith stdConfidence{certainty = 10^6} prop_foo)
--   </pre>
checkCoverageWith :: Testable prop => Confidence -> prop -> Property

-- | The statistical parameters used by <tt>checkCoverage</tt>.
data Confidence
Confidence :: Integer -> Double -> Confidence

-- | How certain <tt>checkCoverage</tt> must be before the property fails.
--   If the coverage requirement is met, and the certainty parameter is
--   <tt>n</tt>, then you should get a false positive at most one in
--   <tt>n</tt> runs of QuickCheck. The default value is <tt>10^9</tt>.
--   
--   Lower values will speed up <tt>checkCoverage</tt> at the cost of false
--   positives.
--   
--   If you are using <tt>checkCoverage</tt> as part of a test suite, you
--   should be careful not to set <tt>certainty</tt> too low. If you want,
--   say, a 1% chance of a false positive during a project's lifetime, then
--   <tt>certainty</tt> should be set to at least <tt>100 * m * n</tt>,
--   where <tt>m</tt> is the number of uses of <tt>cover</tt> in the test
--   suite, and <tt>n</tt> is the number of times you expect the test suite
--   to be run during the project's lifetime. The default value is chosen
--   to be big enough for most projects.
[certainty] :: Confidence -> Integer

-- | For statistical reasons, <tt>checkCoverage</tt> will not reject
--   coverage levels that are only slightly below the required levels. If
--   the required level is <tt>p</tt> then an actual level of <tt>tolerance
--   * p</tt> will be accepted. The default value is <tt>0.9</tt>.
--   
--   Lower values will speed up <tt>checkCoverage</tt> at the cost of not
--   detecting minor coverage violations.
[tolerance] :: Confidence -> Double

-- | The standard parameters used by <a>checkCoverage</a>: <tt>certainty =
--   10^9</tt>, <tt>tolerance = 0.9</tt>. See <a>Confidence</a> for the
--   meaning of the parameters.
stdConfidence :: Confidence

-- | Given a property, which must use <a>label</a>, <a>collect</a>,
--   <a>classify</a> or <a>cover</a> to associate labels with test cases,
--   find an example test case for each possible label. The example test
--   cases are minimised using shrinking.
--   
--   For example, suppose we test <tt><a>delete</a> x xs</tt> and record
--   the number of times that <tt>x</tt> occurs in <tt>xs</tt>:
--   
--   <pre>
--   prop_delete :: Int -&gt; [Int] -&gt; Property
--   prop_delete x xs =
--     classify (count x xs == 0) "count x xs == 0" $
--     classify (count x xs == 1) "count x xs == 1" $
--     classify (count x xs &gt;= 2) "count x xs &gt;= 2" $
--     counterexample (show (delete x xs)) $
--     count x (delete x xs) == max 0 (count x xs-1)
--     where count x xs = length (filter (== x) xs)
--   </pre>
--   
--   <a>labelledExamples</a> generates three example test cases, one for
--   each label:
--   
--   <pre>
--   &gt;&gt;&gt; labelledExamples prop_delete
--   *** Found example of count x xs == 0
--   0
--   []
--   []
--   
--   *** Found example of count x xs == 1
--   0
--   [0]
--   []
--   
--   *** Found example of count x xs &gt;= 2
--   5
--   [5,5]
--   [5]
--   
--   +++ OK, passed 100 tests:
--   78% count x xs == 0
--   21% count x xs == 1
--    1% count x xs &gt;= 2
--   </pre>
labelledExamples :: Testable prop => prop -> IO ()

-- | A variant of <a>labelledExamples</a> that takes test arguments.
labelledExamplesWith :: Testable prop => Args -> prop -> IO ()

-- | A variant of <a>labelledExamples</a> that takes test arguments and
--   returns a result.
labelledExamplesWithResult :: Testable prop => Args -> prop -> IO Result

-- | A variant of <a>labelledExamples</a> that returns a result.
labelledExamplesResult :: Testable prop => prop -> IO Result
