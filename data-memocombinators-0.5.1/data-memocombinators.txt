-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for building memo tables.
--   
--   Combinators for building memo tables.
@package data-memocombinators
@version 0.5.1


-- | This module provides combinators for building memo tables over various
--   data types, so that the type of table can be customized depending on
--   the application.
--   
--   This module is designed to be imported <i>qualified</i>, eg.
--   
--   <pre>
--   import qualified Data.MemoCombinators as Memo
--   </pre>
--   
--   Usage is straightforward: apply an object of type <tt>Memo a</tt> to a
--   function of type <tt>a -&gt; b</tt>, and get a memoized function of
--   type <tt>a -&gt; b</tt>. For example:
--   
--   <pre>
--   fib = Memo.integral fib'
--      where
--      fib' 0 = 0
--      fib' 1 = 1
--      fib' x = fib (x-1) + fib (x-2)
--   </pre>
module Data.MemoCombinators

-- | The type of a memo table for functions of a.
type Memo a = forall r. (a -> r) -> (a -> r)

-- | Given a memoizer for a and an isomorphism between a and b, build a
--   memoizer for b.
wrap :: (a -> b) -> (b -> a) -> Memo a -> Memo b

-- | Memoize a two argument function (just apply the table directly for
--   single argument functions).
memo2 :: Memo a -> Memo b -> (a -> b -> r) -> a -> b -> r

-- | Memoize a three argument function.
memo3 :: Memo a -> Memo b -> Memo c -> (a -> b -> c -> r) -> a -> b -> c -> r

-- | Memoize the second argument of a function.
memoSecond :: Memo b -> (a -> b -> r) -> a -> b -> r

-- | Memoize the third argument of a function.
memoThird :: Memo c -> (a -> b -> c -> r) -> a -> b -> c -> r
bool :: Memo Bool
char :: Memo Char
list :: Memo a -> Memo [a]

-- | Build a table which memoizes all lists of less than the given length.
boundedList :: Int -> Memo a -> Memo [a]
either :: Memo a -> Memo b -> Memo (Either a b)
maybe :: Memo a -> Memo (Maybe a)
unit :: Memo ()
pair :: Memo a -> Memo b -> Memo (a, b)

-- | Memoize an enum type.
enum :: Enum a => Memo a

-- | Memoize an integral type.
integral :: Integral a => Memo a

-- | Memoize an ordered type with a bits instance.
bits :: (Num a, Ord a, Bits a) => Memo a

-- | <tt>switch p a b</tt> uses the memo table a whenever p gives true and
--   the memo table b whenever p gives false.
switch :: (a -> Bool) -> Memo a -> Memo a -> Memo a

-- | The type of builders for ranged tables; takes a lower bound and an
--   upper bound, and returns a memo table for that range.
type RangeMemo a = (a, a) -> Memo a

-- | Build a memo table for a range using a flat array. If items are given
--   outside the range, don't memoize.
arrayRange :: Ix a => RangeMemo a

-- | Build a memo table for a range using a flat array. If items are given
--   outside the range, behavior is undefined.
unsafeArrayRange :: Ix a => RangeMemo a

-- | Given a list of ranges, (lazily) build a memo table for each one and
--   combine them using linear search.
chunks :: Ix a => RangeMemo a -> [(a, a)] -> Memo a

module Data.MemoCombinators.Class

-- | The class of types which have complete memo tables.
class MemoTable a
table :: MemoTable a => Memo a

-- | The class of functions which can be completely memoized.
class Memoizable a
memoize :: Memoizable a => a -> a
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b) => Data.MemoCombinators.Class.MemoTable (a, b)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c) => Data.MemoCombinators.Class.MemoTable (a, b, c)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d) => Data.MemoCombinators.Class.MemoTable (a, b, c, d)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j, Data.MemoCombinators.Class.MemoTable k) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j, k)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j, Data.MemoCombinators.Class.MemoTable k, Data.MemoCombinators.Class.MemoTable l) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j, Data.MemoCombinators.Class.MemoTable k, Data.MemoCombinators.Class.MemoTable l, Data.MemoCombinators.Class.MemoTable m) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j, Data.MemoCombinators.Class.MemoTable k, Data.MemoCombinators.Class.MemoTable l, Data.MemoCombinators.Class.MemoTable m, Data.MemoCombinators.Class.MemoTable n) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b, Data.MemoCombinators.Class.MemoTable c, Data.MemoCombinators.Class.MemoTable d, Data.MemoCombinators.Class.MemoTable e, Data.MemoCombinators.Class.MemoTable f, Data.MemoCombinators.Class.MemoTable g, Data.MemoCombinators.Class.MemoTable h, Data.MemoCombinators.Class.MemoTable i, Data.MemoCombinators.Class.MemoTable j, Data.MemoCombinators.Class.MemoTable k, Data.MemoCombinators.Class.MemoTable l, Data.MemoCombinators.Class.MemoTable m, Data.MemoCombinators.Class.MemoTable n, Data.MemoCombinators.Class.MemoTable o) => Data.MemoCombinators.Class.MemoTable (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Data.MemoCombinators.Class.MemoTable a => Data.MemoCombinators.Class.Memoizable (a -> b)
instance Data.MemoCombinators.Class.MemoTable GHC.Types.Bool
instance Data.MemoCombinators.Class.MemoTable GHC.Types.Char
instance Data.MemoCombinators.Class.MemoTable GHC.Types.Int
instance Data.MemoCombinators.Class.MemoTable GHC.Int.Int8
instance Data.MemoCombinators.Class.MemoTable GHC.Int.Int16
instance Data.MemoCombinators.Class.MemoTable GHC.Int.Int32
instance Data.MemoCombinators.Class.MemoTable GHC.Int.Int64
instance Data.MemoCombinators.Class.MemoTable GHC.Num.Integer.Integer
instance Data.MemoCombinators.Class.MemoTable GHC.Types.Ordering
instance Data.MemoCombinators.Class.MemoTable GHC.Types.Word
instance Data.MemoCombinators.Class.MemoTable GHC.Word.Word8
instance Data.MemoCombinators.Class.MemoTable GHC.Word.Word16
instance Data.MemoCombinators.Class.MemoTable GHC.Word.Word32
instance Data.MemoCombinators.Class.MemoTable GHC.Word.Word64
instance Data.MemoCombinators.Class.MemoTable ()
instance Data.MemoCombinators.Class.MemoTable a => Data.MemoCombinators.Class.MemoTable [a]
instance Data.MemoCombinators.Class.MemoTable a => Data.MemoCombinators.Class.MemoTable (GHC.Maybe.Maybe a)
instance (Data.MemoCombinators.Class.MemoTable a, Data.MemoCombinators.Class.MemoTable b) => Data.MemoCombinators.Class.MemoTable (Data.Either.Either a b)
instance (GHC.Real.Integral a, Data.MemoCombinators.Class.MemoTable a) => Data.MemoCombinators.Class.MemoTable (GHC.Real.Ratio a)
