-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provide exclusive access to a resource using lock file.
--   
--   Provide exclusive access to a resource using lock file, which are
--   files whose purpose is to signal by their presence that some resource
--   is locked.
--   
--   Code example can be found in <a>System.IO.LockFile</a> module.
@package lock-file
@version 0.7.0.0


-- | Low-level API for providing exclusive access to a resource using lock
--   file.
module System.IO.LockFile.Internal

-- | Open lock file write PID of a current process in to it and return its
--   handle.
--   
--   If operation doesn't succeed, then <a>LockingException</a> is raised.
--   See also <a>LockingParameters</a> and <a>RetryStrategy</a> for
--   details.
lock :: (MonadMask m, MonadIO m) => LockingParameters -> FilePath -> m Handle

-- | Close lock file handle and then delete it.
unlock :: (MonadMask m, MonadIO m) => FilePath -> Handle -> m ()

-- | Locking algorithm parameters. When in doubt, use <a>def</a>, otherwise
--   start with it. Example:
--   
--   <pre>
--   lockedDo
--       :: (<a>MonadMask</a> m, <a>MonadIO</a> m)
--       =&gt; <a>FilePath</a>
--       -&gt; m a
--       -&gt; m a
--   lockedDo = <a>withLockFile</a> lockParams lockFile
--     where
--       lockParams = <a>def</a>
--           { <a>retryToAcquireLock</a> = <a>NumberOfTimes</a> 3
--           }
--   
--       lockFile = <a>withLockExt</a> "/var/lock/my-app"
--   </pre>
data LockingParameters
LockingParameters :: !RetryStrategy -> {-# UNPACK #-} !Word64 -> LockingParameters

-- | Strategy for handling situations when lock-file is already acquired.
[retryToAcquireLock] :: LockingParameters -> !RetryStrategy

-- | Sleep interval in microseconds.
[sleepBetweenRetries] :: LockingParameters -> {-# UNPACK #-} !Word64

-- | Defines strategy for handling situations when lock-file is already
--   acquired.
data RetryStrategy

-- | Don't retry at all.
No :: RetryStrategy

-- | Retry indefinitely.
Indefinitely :: RetryStrategy

-- | Retry only specified number of times. If equal to zero then it is
--   interpreted same way as <a>No</a>.
NumberOfTimes :: {-# UNPACK #-} !Word8 -> RetryStrategy
data LockingException

-- | Wasn't able to aquire lock file specified as an argument.
UnableToAcquireLockFile :: FilePath -> LockingException

-- | <a>IOException</a> occurred while creating or removing lock file.
CaughtIOException :: IOException -> LockingException
instance GHC.Show.Show System.IO.LockFile.Internal.RetryStrategy
instance GHC.Read.Read System.IO.LockFile.Internal.RetryStrategy
instance GHC.Generics.Generic System.IO.LockFile.Internal.RetryStrategy
instance GHC.Classes.Eq System.IO.LockFile.Internal.RetryStrategy
instance Data.Data.Data System.IO.LockFile.Internal.RetryStrategy
instance GHC.Show.Show System.IO.LockFile.Internal.LockingParameters
instance GHC.Read.Read System.IO.LockFile.Internal.LockingParameters
instance GHC.Generics.Generic System.IO.LockFile.Internal.LockingParameters
instance GHC.Classes.Eq System.IO.LockFile.Internal.LockingParameters
instance Data.Data.Data System.IO.LockFile.Internal.LockingParameters
instance GHC.Show.Show System.IO.LockFile.Internal.LockingException
instance GHC.Exception.Type.Exception System.IO.LockFile.Internal.LockingException
instance Data.Default.Class.Default System.IO.LockFile.Internal.LockingParameters
instance Data.Default.Class.Default System.IO.LockFile.Internal.RetryStrategy


-- | Provide exclusive access to a resource using lock file.
module System.IO.LockFile

-- | Acquire a lock file before running computation and release it when
--   it's done.
--   
--   If "action" raises <tt>IOException</tt> then this is not wrapped by
--   <a>LockingException</a>. Only <tt>IOException</tt> that occurred
--   during locking or unlocking is mapped to <a>LockingException</a>. This
--   doesn't affect the fact that lock file is removed even if "action"
--   fails.
withLockFile :: (MonadMask m, MonadIO m) => LockingParameters -> FilePath -> m a -> m a

-- | Type restricted version of <a>withLockFile</a> that discards result of
--   the action.
withLockFile_ :: (MonadMask m, MonadIO m) => LockingParameters -> FilePath -> m a -> m ()

-- | Locking algorithm parameters. When in doubt, use <a>def</a>, otherwise
--   start with it. Example:
--   
--   <pre>
--   lockedDo
--       :: (<a>MonadMask</a> m, <a>MonadIO</a> m)
--       =&gt; <a>FilePath</a>
--       -&gt; m a
--       -&gt; m a
--   lockedDo = <a>withLockFile</a> lockParams lockFile
--     where
--       lockParams = <a>def</a>
--           { <a>retryToAcquireLock</a> = <a>NumberOfTimes</a> 3
--           }
--   
--       lockFile = <a>withLockExt</a> "/var/lock/my-app"
--   </pre>
data LockingParameters
LockingParameters :: !RetryStrategy -> {-# UNPACK #-} !Word64 -> LockingParameters

-- | Strategy for handling situations when lock-file is already acquired.
[retryToAcquireLock] :: LockingParameters -> !RetryStrategy

-- | Sleep interval in microseconds.
[sleepBetweenRetries] :: LockingParameters -> {-# UNPACK #-} !Word64

-- | Defines strategy for handling situations when lock-file is already
--   acquired.
data RetryStrategy

-- | Don't retry at all.
No :: RetryStrategy

-- | Retry indefinitely.
Indefinitely :: RetryStrategy

-- | Retry only specified number of times. If equal to zero then it is
--   interpreted same way as <a>No</a>.
NumberOfTimes :: {-# UNPACK #-} !Word8 -> RetryStrategy
data LockingException

-- | Wasn't able to aquire lock file specified as an argument.
UnableToAcquireLockFile :: FilePath -> LockingException

-- | <a>IOException</a> occurred while creating or removing lock file.
CaughtIOException :: IOException -> LockingException

-- | Append default lock file extension. Useful e.g. for generating lock
--   file name out of regular file name.
withLockExt :: FilePath -> FilePath
