<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.Vector.Algorithms.Tim</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">vector-algorithms-0.9.0.2: Efficient algorithms for vector arrays</span><ul class="links" id="page-menu"><li><a href="src/Data.Vector.Algorithms.Tim.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2013-2015 Dan Doel 2015 Tim Baumann</td></tr><tr><th>Maintainer</th><td>Dan Doel &lt;dan.doel@gmail.com&gt;</td></tr><tr><th>Stability</th><td>Experimental</td></tr><tr><th>Portability</th><td>Non-portable (bang patterns)</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Vector.Algorithms.Tim</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Timsort is a complex, adaptive, bottom-up merge sort. It is designed to
 minimize comparisons as much as possible, even at some cost in overhead.
 Thus, it may not be ideal for sorting simple primitive types, for which
 comparison is cheap. It may, however, be significantly faster for sorting
 arrays of complex values (strings would be an example, though an algorithm
 not based on comparison would probably be superior in that particular
 case).</p><p>For more information on the details of the algorithm, read on.</p><p>The first step of the algorithm is to identify runs of elements. These can
 either be non-decreasing or strictly decreasing sequences of elements in
 the input. Strictly decreasing sequences are used rather than
 non-increasing so that they can be easily reversed in place without the
 sort becoming unstable.</p><p>If the natural runs are too short, they are padded to a minimum value. The
 minimum is chosen based on the length of the array, and padded runs are put
 in order using insertion sort. The length of the minimum run size is
 determined as follows:</p><ul><li>If the length of the array is less than 64, the minimum size is the
     length of the array, and insertion sort is used for the entirety</li><li>Otherwise, a value between 32 and 64 is chosen such that N/min is
     either equal to or just below a power of two. This avoids having a
     small chunk left over to merge into much larger chunks at the end.</li></ul><p>This is accomplished by taking the the mininum to be the lowest six bits
 containing the highest set bit, and adding one if any other bits are set.
 For instance:</p><p>length: 00000000 00000000 00000000 00011011 = 25
     min:    00000000 00000000 00000000 00011011 = 25</p><p>length: 00000000 11111100 00000000 00000000 = 63 * 2^18
     min:    00000000 00000000 00000000 00111111 = 63</p><p>length: 00000000 11111100 00000000 00000001 = 63 * 2^18 + 1
     min:    00000000 00000000 00000000 01000000 = 64</p><p>Once chunks can be produced, the next step is merging them. The indices of
 all runs are stored in a stack. When we identify a new run, we push it onto
 the stack. However, certain invariants are maintained of the stack entries.
 Namely:</p><p>if stk = _ :&gt; z :&gt; y :&gt; x
     length x + length y &lt; length z</p><p>if stk = _ :&gt; y :&gt; x
     length x &lt; length y</p><p>This ensures that the chunks stored are decreasing, and that the chunk
 sizes follow something like the fibonacci sequence, ensuring there at most
 log-many chunks at any time. If pushing a new chunk on the stack would
 violate either of the invariants, we first perform a merge.</p><p>If length x + length y &gt;= length z, then y is merged with the smaller of x
 and z (if they are tied, x is chosen, because it is more likely to be
 cached). If, further,  length x &gt;= length y then they are merged. These steps
 are repeated until the invariants are established.</p><p>The last important piece of the algorithm is the merging. At first, two
 chunks are merged element-wise. However, while doing so, counts are kept of
 the number of elements taken from one chunk without any from its partner. If
 this count exceeds a threshold, the merge switches to searching for elements
 from one chunk in the other, and copying chunks at a time. If these chunks
 start falling below the threshold, the merge switches back to element-wise.</p><p>The search used in the merge is also special. It uses a galloping strategy,
 where exponentially increasing indices are tested, and once two such indices
 are determined to bracket the desired value, binary search is used to find
 the exact index within that range. This is asymptotically the same as simply
 using binary search, but is likely to do fewer comparisons than binary search
 would.</p><p>One aspect that is not yet implemented from the original Tim sort is the
 adjustment of the above threshold. When galloping saves time, the threshold
 is lowered, and when it doesn't, it is raised. This may be implemented in the
 future.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:sort">sort</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m ()</li><li class="src short"><a href="#v:sortUniq">sortUniq</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m (v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e)</li><li class="src short"><a href="#v:sortBy">sortBy</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e) =&gt; <a href="Data-Vector-Algorithms-Optimal.html#t:Comparison" title="Data.Vector.Algorithms.Optimal">Comparison</a> e -&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m ()</li><li class="src short"><a href="#v:sortUniqBy">sortUniqBy</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e) =&gt; <a href="Data-Vector-Algorithms-Optimal.html#t:Comparison" title="Data.Vector.Algorithms.Optimal">Comparison</a> e -&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m (v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e)</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:sort" class="def">sort</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m () <a href="src/Data.Vector.Algorithms.Tim.html#sort" class="link">Source</a> <a href="#v:sort" class="selflink">#</a></p><div class="doc"><p>Sorts an array using the default comparison.</p></div></div><div class="top"><p class="src"><a id="v:sortUniq" class="def">sortUniq</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> e) =&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m (v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e) <a href="src/Data.Vector.Algorithms.Tim.html#sortUniq" class="link">Source</a> <a href="#v:sortUniq" class="selflink">#</a></p><div class="doc"><p>A variant on <code><a href="Data-Vector-Algorithms-Tim.html#v:sort" title="Data.Vector.Algorithms.Tim">sort</a></code> that returns a vector of unique elements.</p></div></div><div class="top"><p class="src"><a id="v:sortBy" class="def">sortBy</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e) =&gt; <a href="Data-Vector-Algorithms-Optimal.html#t:Comparison" title="Data.Vector.Algorithms.Optimal">Comparison</a> e -&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m () <a href="src/Data.Vector.Algorithms.Tim.html#sortBy" class="link">Source</a> <a href="#v:sortBy" class="selflink">#</a></p><div class="doc"><p>Sorts an array using a custom comparison.</p></div></div><div class="top"><p class="src"><a id="v:sortUniqBy" class="def">sortUniqBy</a> :: (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimMonad" title="Control.Monad.Primitive">PrimMonad</a> m, <a href="../vector-0.13.1.0/Data-Vector-Generic-Mutable-Base.html#t:MVector" title="Data.Vector.Generic.Mutable.Base">MVector</a> v e) =&gt; <a href="Data-Vector-Algorithms-Optimal.html#t:Comparison" title="Data.Vector.Algorithms.Optimal">Comparison</a> e -&gt; v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e -&gt; m (v (<a href="../primitive-0.8.0.0/Control-Monad-Primitive.html#t:PrimState" title="Control.Monad.Primitive">PrimState</a> m) e) <a href="src/Data.Vector.Algorithms.Tim.html#sortUniqBy" class="link">Source</a> <a href="#v:sortUniqBy" class="selflink">#</a></p><div class="doc"><p>A variant on <code><a href="Data-Vector-Algorithms-Tim.html#v:sortBy" title="Data.Vector.Algorithms.Tim">sortBy</a></code> which returns a vector of unique elements.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>