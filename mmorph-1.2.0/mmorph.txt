-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monad morphisms
--   
--   This library provides monad morphism utilities, most commonly used for
--   manipulating monad transformer stacks.
@package mmorph
@version 1.2.0


-- | A monad morphism is a natural transformation:
--   
--   <pre>
--   morph :: forall a . m a -&gt; n a
--   </pre>
--   
--   ... that obeys the following two laws:
--   
--   <pre>
--   morph $ do x &lt;- m  =  do x &lt;- morph m
--              f x           morph (f x)
--   
--   morph (return x) = return x
--   </pre>
--   
--   ... which are equivalent to the following two functor laws:
--   
--   <pre>
--   morph . (f &gt;=&gt; g) = morph . f &gt;=&gt; morph . g
--   
--   morph . return = return
--   </pre>
--   
--   Examples of monad morphisms include:
--   
--   <ul>
--   <li><a>lift</a> (from <a>MonadTrans</a>)</li>
--   <li><a>squash</a> (See below)</li>
--   <li><tt><a>hoist</a> f</tt> (See below), if <tt>f</tt> is a monad
--   morphism</li>
--   <li><tt>(f . g)</tt>, if <tt>f</tt> and <tt>g</tt> are both monad
--   morphisms</li>
--   <li><a>id</a></li>
--   </ul>
--   
--   Monad morphisms commonly arise when manipulating existing monad
--   transformer code for compatibility purposes. The <a>MFunctor</a>,
--   <a>MonadTrans</a>, and <a>MMonad</a> classes define standard ways to
--   change monad transformer stacks:
--   
--   <ul>
--   <li><a>lift</a> introduces a new monad transformer layer of any
--   type.</li>
--   <li><a>squash</a> flattens two identical monad transformer layers into
--   a single layer of the same type.</li>
--   <li><a>hoist</a> maps monad morphisms to modify deeper layers of the
--   monad transformer stack.</li>
--   </ul>
module Control.Monad.Morph

-- | A functor in the category of monads, using <a>hoist</a> as the analog
--   of <a>fmap</a>:
--   
--   <pre>
--   hoist (f . g) = hoist f . hoist g
--   
--   hoist id = id
--   </pre>
class MFunctor t

-- | Lift a monad morphism from <tt>m</tt> to <tt>n</tt> into a monad
--   morphism from <tt>(t m)</tt> to <tt>(t n)</tt>
--   
--   The first argument to <a>hoist</a> must be a monad morphism, even
--   though the type system does not enforce this
hoist :: (MFunctor t, Monad m) => (forall a. m a -> n a) -> t m b -> t n b

-- | A function that <tt>generalize</tt>s the <a>Identity</a> base monad to
--   be any monad.
generalize :: Monad m => Identity a -> m a

-- | A monad in the category of monads, using <a>lift</a> from
--   <a>MonadTrans</a> as the analog of <a>return</a> and <a>embed</a> as
--   the analog of (<a>=&lt;&lt;</a>):
--   
--   <pre>
--   embed lift = id
--   
--   embed f (lift m) = f m
--   
--   embed g (embed f t) = embed (\m -&gt; embed g (f m)) t
--   </pre>
class (MFunctor t, MonadTrans t) => MMonad t

-- | Embed a newly created <a>MMonad</a> layer within an existing layer
--   
--   <a>embed</a> is analogous to (<a>=&lt;&lt;</a>)
embed :: (MMonad t, Monad n) => (forall a. m a -> t n a) -> t m b -> t n b

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Squash two <a>MMonad</a> layers into a single layer
--   
--   <a>squash</a> is analogous to <a>join</a>
squash :: (Monad m, MMonad t) => t (t m) a -> t m a

-- | Compose two <a>MMonad</a> layer-building functions
--   
--   (<a>&gt;|&gt;</a>) is analogous to (<a>&gt;=&gt;</a>)
(>|>) :: (Monad m3, MMonad t) => (forall a. m1 a -> t m2 a) -> (forall b. m2 b -> t m3 b) -> m1 c -> t m3 c
infixr 2 >|>

-- | Equivalent to (<a>&gt;|&gt;</a>) with the arguments flipped
--   
--   (<a>&lt;|&lt;</a>) is analogous to (<a>&lt;=&lt;</a>)
(<|<) :: (Monad m3, MMonad t) => (forall b. m2 b -> t m3 b) -> (forall a. m1 a -> t m2 a) -> m1 c -> t m3 c
infixl 2 <|<

-- | An infix operator equivalent to <a>embed</a>
--   
--   (<a>=&lt;|</a>) is analogous to (<a>=&lt;&lt;</a>)
(=<|) :: (Monad n, MMonad t) => (forall a. m a -> t n a) -> t m b -> t n b
infixr 2 =<|

-- | Equivalent to (<a>=&lt;|</a>) with the arguments flipped
--   
--   (<a>|&gt;=</a>) is analogous to (<a>&gt;&gt;=</a>)
(|>=) :: (Monad n, MMonad t) => t m b -> (forall a. m a -> t n a) -> t n b
infixl 2 |>=
instance Control.Monad.Morph.MMonad (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.Morph.MMonad Control.Monad.Trans.Identity.IdentityT
instance Control.Monad.Morph.MMonad Control.Monad.Trans.Maybe.MaybeT
instance Control.Monad.Morph.MMonad (Control.Monad.Trans.Reader.ReaderT r)
instance GHC.Base.Monoid w => Control.Monad.Morph.MMonad (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Control.Monad.Morph.MMonad (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.Morph.MFunctor Control.Monad.Trans.Identity.IdentityT
instance Control.Monad.Morph.MFunctor Control.Monad.Trans.Maybe.MaybeT
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.Reader.ReaderT r)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.State.Lazy.StateT s)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.State.Strict.StateT s)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Control.Monad.Morph.MFunctor (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Functor f => Control.Monad.Morph.MFunctor (Data.Functor.Compose.Compose f)
instance Control.Monad.Morph.MFunctor (Data.Functor.Product.Product f)
instance Control.Monad.Morph.MFunctor Control.Applicative.Backwards.Backwards
instance Control.Monad.Morph.MFunctor Control.Applicative.Lift.Lift


-- | Composition of monad transformers. A higher-order version of
--   <a>Data.Functor.Compose</a>.
module Control.Monad.Trans.Compose

-- | Composition of monad transformers.
newtype ComposeT (f :: (* -> *) -> * -> *) (g :: (* -> *) -> * -> *) m a
ComposeT :: f (g m) a -> ComposeT (f :: (* -> *) -> * -> *) (g :: (* -> *) -> * -> *) m a
[getComposeT] :: ComposeT (f :: (* -> *) -> * -> *) (g :: (* -> *) -> * -> *) m a -> f (g m) a
infixr 9 `ComposeT`
infixr 9 `ComposeT`

-- | Transform the computation inside a <a>ComposeT</a>.
mapComposeT :: (f (g m) a -> p (q n) b) -> ComposeT f g m a -> ComposeT p q n b
instance Control.Monad.Writer.Class.MonadWriter w (f (g m)) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.State.Class.MonadState s (f (g m)) => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Compose.ComposeT f g m)
instance (Control.Monad.Reader.Class.MonadReader r (f (g m)), Control.Monad.Writer.Class.MonadWriter w (f (g m)), Control.Monad.State.Class.MonadState s (f (g m))) => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.Reader.Class.MonadReader r (f (g m)) => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Compose.ComposeT f g m)
instance GHC.Base.MonadPlus (f (g m)) => GHC.Base.MonadPlus (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.IO.Class.MonadIO (f (g m)) => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.Fail.MonadFail (f (g m)) => Control.Monad.Fail.MonadFail (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.Error.Class.MonadError e (f (g m)) => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Compose.ComposeT f g m)
instance Control.Monad.Cont.Class.MonadCont (f (g m)) => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Compose.ComposeT f g m)
instance GHC.Base.Monad (f (g m)) => GHC.Base.Monad (Control.Monad.Trans.Compose.ComposeT f g m)
instance Data.Traversable.Traversable (f (g m)) => Data.Traversable.Traversable (Control.Monad.Trans.Compose.ComposeT f g m)
instance GHC.Show.Show (f (g m) a) => GHC.Show.Show (Control.Monad.Trans.Compose.ComposeT f g m a)
instance GHC.Read.Read (f (g m) a) => GHC.Read.Read (Control.Monad.Trans.Compose.ComposeT f g m a)
instance GHC.Classes.Ord (f (g m) a) => GHC.Classes.Ord (Control.Monad.Trans.Compose.ComposeT f g m a)
instance GHC.Base.Functor (f (g m)) => GHC.Base.Functor (Control.Monad.Trans.Compose.ComposeT f g m)
instance Data.Foldable.Foldable (f (g m)) => Data.Foldable.Foldable (Control.Monad.Trans.Compose.ComposeT f g m)
instance GHC.Classes.Eq (f (g m) a) => GHC.Classes.Eq (Control.Monad.Trans.Compose.ComposeT f g m a)
instance GHC.Base.Applicative (f (g m)) => GHC.Base.Applicative (Control.Monad.Trans.Compose.ComposeT f g m)
instance GHC.Base.Alternative (f (g m)) => GHC.Base.Alternative (Control.Monad.Trans.Compose.ComposeT f g m)
instance (Control.Monad.Morph.MFunctor f, Control.Monad.Trans.Class.MonadTrans f, Control.Monad.Trans.Class.MonadTrans g) => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Compose.ComposeT f g)
instance (Control.Monad.Morph.MFunctor f, Control.Monad.Morph.MFunctor g, forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Monad (g m)) => Control.Monad.Morph.MFunctor (Control.Monad.Trans.Compose.ComposeT f g)
