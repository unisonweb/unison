<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Language.Haskell.TH.Syntax.Compat</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">th-compat-0.1.5: Backward- (and forward-)compatible Quote and Code types</span><ul class="links" id="page-menu"><li><a href="src/Language.Haskell.TH.Syntax.Compat.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Language.Haskell.TH.Syntax.Compat</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The <code>Quote</code> class</a></li><li><a href="#g:2"><code>Quote</code> functionality</a><ul><li><a href="#g:3">The <code>unsafeQToQuote</code> function</a></li><li><a href="#g:4">Functions from <code>Language.Haskell.TH.Syntax</code></a></li></ul></li><li><a href="#g:5">The <code>Code</code> and <code>CodeQ</code> types</a></li><li><a href="#g:6"><code>Code</code> functionality</a><ul><li><a href="#g:7">The <code>IsCode</code> class</a></li><li><a href="#g:8">Limitations of <code>IsCode</code></a></li></ul></li><li><a href="#g:9">Compatibility with <code>Splice</code>s</a></li><li><a href="#g:10">Package root functions</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module exists to make it possible to define code that works across
 a wide range of <code>template-haskell</code> versions with as little CPP as possible.
 To that end, this module currently backports the following
 <code>template-haskell</code> constructs:</p><ul><li>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> class</li><li>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> type</li><li>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:getPackageRoot" title="Language.Haskell.TH.Syntax.Compat">getPackageRoot</a></code> and <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:makeRelativeToProject" title="Language.Haskell.TH.Syntax.Compat">makeRelativeToProject</a></code> utility functions</li></ul><p>Refer to the Haddocks below for examples of how to use each of these in a
 backwards-compatible way.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">class</span> <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="#t:Quote">Quote</a> (m :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><a href="#v:newName">newName</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a></li></ul></li><li class="src short"><a href="#v:unsafeQToQuote">unsafeQToQuote</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> a -&gt; m a</li><li class="src short"><a href="#v:unTypeQQuote">unTypeQQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:unsafeTExpCoerceQuote">unsafeTExpCoerceQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a)</li><li class="src short"><a href="#v:liftQuote">liftQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (t :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:liftTypedQuote">liftTypedQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (t :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m t</li><li class="src short"><a href="#v:liftStringQuote">liftStringQuote</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Code">Code</a> (m :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) = <a href="#v:Code">Code</a> {<ul class="subs"><li><a href="#v:examineCode">examineCode</a> :: m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a)</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:CodeQ">CodeQ</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:IsCode">IsCode</a> q (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) c | c -&gt; a q <span class="keyword">where</span><ul class="subs"><li><a href="#v:toCode">toCode</a> :: c -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a</li><li><a href="#v:fromCode">fromCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; c</li></ul></li><li class="src short"><a href="#v:unsafeCodeCoerce">unsafeCodeCoerce</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a</li><li class="src short"><a href="#v:liftCode">liftCode</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a</li><li class="src short"><a href="#v:unTypeCode">unTypeCode</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:hoistCode">hoistCode</a> :: <span class="keyword">forall</span> m n (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> n a</li><li class="src short"><a href="#v:bindCode">bindCode</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; (a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b</li><li class="src short"><a href="#v:bindCode_">bindCode_</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b</li><li class="src short"><a href="#v:joinCode">joinCode</a> :: <span class="keyword">forall</span> m (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Splice">Splice</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> :: <span class="keyword">forall</span> r. (* -&gt; *) -&gt; <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; *</li><li class="src short"><span class="keyword">type</span> <a href="#t:SpliceQ">SpliceQ</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; *</li><li class="src short"><a href="#v:bindSplice">bindSplice</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; (a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b</li><li class="src short"><a href="#v:bindSplice_">bindSplice_</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b</li><li class="src short"><a href="#v:examineSplice">examineSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) m (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a)</li><li class="src short"><a href="#v:hoistSplice">hoistSplice</a> :: <span class="keyword">forall</span> m n (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> n a</li><li class="src short"><a href="#v:joinSplice">joinSplice</a> :: <span class="keyword">forall</span> m (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a</li><li class="src short"><a href="#v:liftSplice">liftSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a</li><li class="src short"><a href="#v:liftTypedFromUntypedSplice">liftTypedFromUntypedSplice</a> :: (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m t</li><li class="src short"><a href="#v:unsafeSpliceCoerce">unsafeSpliceCoerce</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a</li><li class="src short"><a href="#v:unTypeSplice">unTypeSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></li><li class="src short"><a href="#v:expToSplice">expToSplice</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a</li><li class="src short"><a href="#v:getPackageRoot">getPackageRoot</a> :: <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></li><li class="src short"><a href="#v:makeRelativeToProject">makeRelativeToProject</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The <code>Quote</code> class</h1></a><div class="doc"><p>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> class (first proposed in
 <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0246-overloaded-bracket.rst">GHC Proposal 246</a>)
 was introduced in <code>template-haskell-2.17.0.0</code>. This module defines a version
 of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> that is backward-compatible with older <code>template-haskell</code>
 releases and is forward-compatible with the existing <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> class.</p><p>In addition to <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>, this module also backports versions of functions in
 <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a> that work over any <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> instance instead of
 just <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>. Since this module is designed to coexist with the existing
 definitions in <code>template-haskell</code> as much as possible, the backported
 functions are suffixed with <code>-Quote</code> to avoid name clashes. For instance,
 the backported version of <code>lift</code> is named <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftQuote" title="Language.Haskell.TH.Syntax.Compat">liftQuote</a></code>.</p><p>The one exception to the no-name-clashes policy is the backported <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code>
 method of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>. We could have conceivably named it <code>newNameQuote</code>, but
 then it would not have been possible to define backwards-compatible <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>
 instances without the use of CPP. As a result, some care must be exercised
 when combining this module with <a href="../template-haskell-2.20.0.0/Language-Haskell-TH.html">Language.Haskell.TH</a> or
 <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a> on older versions of <code>template-haskell</code>, as
 they both export a version of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code> with a different type. Here is an
 example of how to safely combine these modules:</p><pre>{-# LANGUAGE GeneralizedNewtypeDeriving, TemplateHaskell #-}

import Control.Monad.State (MonadState(..), State, evalState)
import <a href="../template-haskell-2.20.0.0/Language-Haskell-TH.html">Language.Haskell.TH</a> hiding (<code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code>)
import <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a> hiding (<code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code>)
import <a href="Language-Haskell-TH-Syntax-Compat.html">Language.Haskell.TH.Syntax.Compat</a>

newtype PureQ a = MkPureQ (State Uniq a)
  deriving (Functor, Applicative, Monad, MonadState Uniq)

runPureQ :: PureQ a -&gt; a
runPureQ m = case m of MkPureQ m' -&gt; evalState m' 0

instance <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> PureQ where
  <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code> s = state $ i -&gt; (mkNameU s i, i + 1)

main :: IO ()
main = putStrLn $ runPureQ $ do
  a &lt;- newName &quot;a&quot;
  return $ nameBase a
</pre><p>We do not make an effort to backport any combinators from the
 <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Lib.html">Language.Haskell.TH.Lib</a> module, as the surface area is simply too large.
 If you wish to generalize code that uses these combinators to work over
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> in a backwards-compatible way, use the <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeQToQuote" title="Language.Haskell.TH.Syntax.Compat">unsafeQToQuote</a></code> function.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a id="t:Quote" class="def">Quote</a> (m :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="#t:Quote" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> class implements the minimal interface which is necessary for
 desugaring quotations.</p><ul><li>The <code>Monad m</code> superclass is needed to stitch together the different
 AST fragments.</li><li><code><a href="Language-Haskell-TH-Syntax-Compat.html#v:newName" title="Language.Haskell.TH.Syntax.Compat">newName</a></code> is used when desugaring binding structures such as lambdas
 to generate fresh names.</li></ul><p>Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m Exp`</p><p>For many years the type of a quotation was fixed to be `Q Exp` but by
 more precisely specifying the minimal interface it enables the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> to
 be extracted purely from the quotation without interacting with <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:newName" class="def">newName</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> <a href="#v:newName" class="selflink">#</a></p><div class="doc"><p>Generate a fresh name, which cannot be captured.</p><p>For example, this:</p><pre>f = $(do
    nm1 &lt;- newName &quot;x&quot;
    let nm2 = <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:mkName" title="Language.Haskell.TH.Syntax">mkName</a></code> &quot;x&quot;
    return (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:LamE" title="Language.Haskell.TH.Syntax">LamE</a></code> [<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:VarP" title="Language.Haskell.TH.Syntax">VarP</a></code> nm1] (LamE [VarP nm2] (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:VarE" title="Language.Haskell.TH.Syntax">VarE</a></code> nm1)))
   )</pre><p>will produce the splice</p><pre>f = \x0 -&gt; \x -&gt; x0</pre><p>In particular, the occurrence <code>VarE nm1</code> refers to the binding <code>VarP nm1</code>,
  and is not captured by the binding <code>VarP nm2</code>.</p><p>Although names generated by <code>newName</code> cannot <em>be captured</em>, they can
  <em>capture</em> other names. For example, this:</p><pre>g = $(do
  nm1 &lt;- newName &quot;x&quot;
  let nm2 = mkName &quot;x&quot;
  return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
 )</pre><p>will produce the splice</p><pre>g = \x -&gt; \x0 -&gt; x0</pre><p>since the occurrence <code>VarE nm2</code> is captured by the innermost binding
  of <code>x</code>, namely <code>VarP nm1</code>.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Quote">Instances</h4><details id="i:Quote" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Quote:Quote:1"></span> <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Quote:Quote:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:newName">newName</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> <a href="#v:newName" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Quote:Quote:2"></span> <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></span></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Quote:Quote:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:newName">newName</a> :: <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Name" title="Language.Haskell.TH.Syntax">Name</a> <a href="#v:newName" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1><code>Quote</code> functionality</h1></a><a href="#g:3" id="g:3"><h2>The <code>unsafeQToQuote</code> function</h2></a><div class="top"><p class="src"><a id="v:unsafeQToQuote" class="def">unsafeQToQuote</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> a -&gt; m a <a href="src/Language.Haskell.TH.Syntax.Compat.html#unsafeQToQuote" class="link">Source</a> <a href="#v:unsafeQToQuote" class="selflink">#</a></p><div class="doc"><p>Use a <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> computation in a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> context. This function is only safe
 when the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> computation performs actions from the <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> instance for <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>
 or any of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>'s subclasses (<code><a href="../base-4.18.2.1/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code>, <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code>, and <code><a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code>).
 Attempting to perform actions from the <code><a href="../base-4.18.2.1/Control-Monad-Fail.html#t:MonadFail" title="Control.Monad.Fail">MonadFail</a></code>, <code><a href="../base-4.18.2.1/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a></code>, or <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Quasi" title="Language.Haskell.TH.Syntax">Quasi</a></code>
 instances for <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> will result in runtime errors.</p><p>This is useful when you have some <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>-valued functions that only performs
 actions from <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> and wish to generalise it from <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> to <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> without
 having to rewrite the internals of the function. This is especially handy
 for code defined in terms of combinators from <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Lib.html">Language.Haskell.TH.Lib</a>,
 which were all hard-coded to <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> prior to <code>template-haskell-2.17.0.0</code>. For
 instance, consider this function:</p><pre>apply :: <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code>
apply f x = <code><a href="Lib.html#v:appE" title="Lib">appE</a></code> (return x) (return y)
</pre><p>There are two ways to generalize this function to use <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> in a
 backwards-compatible way. One way to do so is to rewrite <code>apply</code> to avoid
 the use of <code><a href="Lib.html#v:appE" title="Lib">appE</a></code>, like so:</p><pre>applyQuote :: <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> m =&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; m <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code>
applyQuote f x = return (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:AppE" title="Language.Haskell.TH.Syntax">AppE</a></code> x y)
</pre><p>For a small example like <code>applyQuote</code>, there isn't much work involved. But
 this can become tiresome for larger examples. In such cases,
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeQToQuote" title="Language.Haskell.TH.Syntax.Compat">unsafeQToQuote</a></code> can do the heavy lifting for you. For example, <code>applyQuote</code>
 can also be defined as:</p><pre>applyQuote :: <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> m =&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code> -&gt; m <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a></code>
applyQuote f x = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeQToQuote" title="Language.Haskell.TH.Syntax.Compat">unsafeQToQuote</a></code> (apply f x)
</pre></div></div><a href="#g:4" id="g:4"><h2>Functions from <code>Language.Haskell.TH.Syntax</code></h2></a><div class="top"><p class="src"><a id="v:unTypeQQuote" class="def">unTypeQQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Language.Haskell.TH.Syntax.Compat.html#unTypeQQuote" class="link">Source</a> <a href="#v:unTypeQQuote" class="selflink">#</a></p><div class="doc"><p>Discard the type annotation and produce a plain Template Haskell
 expression</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p><p>This is a variant of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:unTypeQ" title="Language.Haskell.TH.Syntax">unTypeQ</a></code> function that is always guaranteed to
 use a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> constraint, even on old versions of <code>template-haskell</code>.</p><p>As this function interacts with typed Template Haskell, this function is
 only defined on <code>template-haskell-2.9.0.0</code> (GHC 7.8) or later.</p></div></div><div class="top"><p class="src"><a id="v:unsafeTExpCoerceQuote" class="def">unsafeTExpCoerceQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) <a href="src/Language.Haskell.TH.Syntax.Compat.html#unsafeTExpCoerceQuote" class="link">Source</a> <a href="#v:unsafeTExpCoerceQuote" class="selflink">#</a></p><div class="doc"><p>Annotate the Template Haskell expression with a type</p><p>This is unsafe because GHC cannot check for you that the expression
 really does have the type you claim it has.</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p><p>This is a variant of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:unsafeTExpCoerce" title="Language.Haskell.TH.Syntax">unsafeTExpCoerce</a></code> function that is always
 guaranteed to use a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> constraint, even on old versions of
 <code>template-haskell</code>.</p><p>As this function interacts with typed Template Haskell, this function is
 only defined on <code>template-haskell-2.9.0.0</code> (GHC 7.8) or later.</p></div></div><div class="top"><p class="src"><a id="v:liftQuote" class="def">liftQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (t :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Language.Haskell.TH.Syntax.Compat.html#liftQuote" class="link">Source</a> <a href="#v:liftQuote" class="selflink">#</a></p><div class="doc"><p>Turn a value into a Template Haskell expression, suitable for use in
 a splice.</p><p>This is a variant of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> method of <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> that is
 always guaranteed to use a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> constraint, even on old versions of
 <code>template-haskell</code>.</p><p>Levity-polymorphic since <em>template-haskell-2.17.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:liftTypedQuote" class="def">liftTypedQuote</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (t :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m t <a href="src/Language.Haskell.TH.Syntax.Compat.html#liftTypedQuote" class="link">Source</a> <a href="#v:liftTypedQuote" class="selflink">#</a></p><div class="doc"><p>Turn a value into a Template Haskell typed expression, suitable for use
 in a typed splice.</p><p>This is a variant of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> method of <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> that is
 always guaranteed to use a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> constraint and return a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>, even on
 old versions of <code>template-haskell</code>.</p><p>As this function interacts with typed Template Haskell, this function is
 only defined on <code>template-haskell-2.9.0.0</code> (GHC 7.8) or later. While the
 <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> method of <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> was first introduced in
 <code>template-haskell-2.16.0.0</code>, we are able to backport it back to
 <code>template-haskell-2.9.0.0</code> by making use of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> method on
 older versions of <code>template-haskell</code>. This crucially relies on the
 <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> law that <code><code>lift</code> x &#8801; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:unTypeQ" title="Language.Haskell.TH.Syntax">unTypeQ</a></code> (<code>liftTyped</code> x)</code> to work,
 so beware if you use <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedQuote" title="Language.Haskell.TH.Syntax.Compat">liftTypedQuote</a></code> with an unlawful <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code>
 instance.</p><p>Levity-polymorphic since <em>template-haskell-2.17.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:liftStringQuote" class="def">liftStringQuote</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a> -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Language.Haskell.TH.Syntax.Compat.html#liftStringQuote" class="link">Source</a> <a href="#v:liftStringQuote" class="selflink">#</a></p><div class="doc"><p>This is a variant of the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftString" title="Language.Haskell.TH.Syntax">liftString</a></code> function that is always
 guaranteed to use a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> constraint, even on old versions of
 <code>template-haskell</code>.</p></div></div><a href="#g:5" id="g:5"><h1>The <code>Code</code> and <code>CodeQ</code> types</h1></a><div class="doc"><p>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> type (first proposed in
 <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0195-code-texp.rst">GHC Proposal 195</a>)
 was introduced in <code>template-haskell-2.17.0.0</code>. This module defines a version
 of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> that is backward-compatible with older <code>template-haskell</code>
 releases and is forward-compatible with the existing <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> class.
 In addition to <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>, this module also backports the functions in
 <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html">Language.Haskell.TH.Syntax</a> that manipulate <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> values.</p><p>One troublesome aspect of writing backwards-compatible code involving <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>
 is that GHC 9.0 changed the types of typed Template Haskell splices. Before,
 they were of type <code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code>TExp</code> a)</code>, but they are now of type <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> a</code>.
 This modules provides two mechanisms for smoothing over the differences
 between these two types:</p><ul><li>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a></code> class can be used to convert <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> or <code>TExp</code> values to
   <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>, and vice versa.</li><li>The <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> type synonym uses CPP so that <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> q a</code> is a synonym for
   <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> q a</code> on GHC 9.0 or later and <code>q (<code>TExp</code> a)</code> on older versions of
   GHC. This module also defines versions of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>- and <code>TExp</code>-related
   combinators that work over <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>.</li></ul><p>Refer to the Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a></code> and <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on each
 approach. Both approaches have pros and cons, and as a result, neither
 approach is a one-size-fits-all solution.</p><p>Because <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> interacts with typed Template Haskell, the <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> type and
 any function that mentions <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> in its type are only defined on
 <code>template-haskell-2.9.0.0</code> (GHC 7.8) or later.</p></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:Code" class="def">Code</a> (m :: <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) <a href="#t:Code" class="selflink">#</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Code" class="def">Code</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:examineCode" class="def">examineCode</a> :: m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a)</dfn><div class="doc"><p>Underlying monadic value</p></div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Code">Instances</h4><details id="i:Code" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Code:IsCode:1"></span> <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> q =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a> q (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a)</span> <a href="src/Language.Haskell.TH.Syntax.Compat.html#line-541" class="link">Source</a> <a href="#t:IsCode" class="selflink">#</a></td><td class="doc"><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></td></tr><tr><td colspan="2"><details id="i:id:Code:IsCode:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Language-Haskell-TH-Syntax-Compat.html">Language.Haskell.TH.Syntax.Compat</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toCode">toCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a <a href="src/Language.Haskell.TH.Syntax.Compat.html#toCode" class="link">Source</a> <a href="#v:toCode" class="selflink">#</a></p><p class="src"><a href="#v:fromCode">fromCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a <a href="src/Language.Haskell.TH.Syntax.Compat.html#fromCode" class="link">Source</a> <a href="#v:fromCode" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:CodeQ" class="def">CodeQ</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; <a href="../base-4.18.2.1/Data-Kind.html#t:Type" title="Data.Kind">Type</a> <a href="#t:CodeQ" class="selflink">#</a></p></div><a href="#g:6" id="g:6"><h1><code>Code</code> functionality</h1></a><a href="#g:7" id="g:7"><h2>The <code>IsCode</code> class</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:IsCode" class="def">IsCode</a> q (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) c | c -&gt; a q <span class="keyword">where</span> <a href="src/Language.Haskell.TH.Syntax.Compat.html#IsCode" class="link">Source</a> <a href="#t:IsCode" class="selflink">#</a></p><div class="doc"><p>A class that allows one to smooth over the differences between
 <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> <code>m</code> a</code> (the type of typed Template Haskell quotations on
 <code>template-haskell-2.17.0.0</code> or later) and <code><code>m</code> (<code>TExp</code> a)</code> (the type of
 typed Template Haskell quotations on older versions of <code>template-haskell</code>).
 Here are two examples that demonstrate how to use each method of <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a></code>:</p><pre>{-# LANGUAGE TemplateHaskell #-}

import <a href="../template-haskell-2.20.0.0/Language-Haskell-TH.html">Language.Haskell.TH</a>
import <a href="Language-Haskell-TH-Syntax-Compat.html">Language.Haskell.TH.Syntax.Compat</a>

-- <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:toCode" title="Language.Haskell.TH.Syntax.Compat">toCode</a></code> will ensure that the end result is a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>, regardless of
-- whether the quote itself returns a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> or a <code>TExp</code>.
myCode :: <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> Int
myCode = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:toCode" title="Language.Haskell.TH.Syntax.Compat">toCode</a></code> [|| 42 ||]

-- <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:fromCode" title="Language.Haskell.TH.Syntax.Compat">fromCode</a></code> will ensure that the input <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> is suitable for splicing
-- (i.e., it will return a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> or a <code>TExp</code> depending on the
-- <code>template-haskell</code> version in use).
fortyTwo :: Int
fortyTwo = $$(<code><a href="Language-Haskell-TH-Syntax-Compat.html#v:fromCode" title="Language.Haskell.TH.Syntax.Compat">fromCode</a></code> myCode)
</pre><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:toCode" class="def">toCode</a> :: c -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a <a href="src/Language.Haskell.TH.Syntax.Compat.html#toCode" class="link">Source</a> <a href="#v:toCode" class="selflink">#</a></p><div class="doc"><p>Convert something to a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>.</p></div><p class="src"><a id="v:fromCode" class="def">fromCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; c <a href="src/Language.Haskell.TH.Syntax.Compat.html#fromCode" class="link">Source</a> <a href="#v:fromCode" class="selflink">#</a></p><div class="doc"><p>Convert to something from a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:IsCode">Instances</h4><details id="i:IsCode" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsCode:IsCode:1"></span> texp <a href="../base-4.18.2.1/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> texp)</span> <a href="src/Language.Haskell.TH.Syntax.Compat.html#line-552" class="link">Source</a> <a href="#t:IsCode" class="selflink">#</a></td><td class="doc"><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></td></tr><tr><td colspan="2"><details id="i:ic:IsCode:IsCode:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Language-Haskell-TH-Syntax-Compat.html">Language.Haskell.TH.Syntax.Compat</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toCode">toCode</a> :: <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> texp -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> a <a href="src/Language.Haskell.TH.Syntax.Compat.html#toCode" class="link">Source</a> <a href="#v:toCode" class="selflink">#</a></p><p class="src"><a href="#v:fromCode">fromCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> a -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> texp <a href="src/Language.Haskell.TH.Syntax.Compat.html#fromCode" class="link">Source</a> <a href="#v:fromCode" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsCode:IsCode:2"></span> <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> q =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a> q (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a)</span> <a href="src/Language.Haskell.TH.Syntax.Compat.html#line-541" class="link">Source</a> <a href="#t:IsCode" class="selflink">#</a></td><td class="doc"><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></td></tr><tr><td colspan="2"><details id="i:ic:IsCode:IsCode:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Language-Haskell-TH-Syntax-Compat.html">Language.Haskell.TH.Syntax.Compat</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toCode">toCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a <a href="src/Language.Haskell.TH.Syntax.Compat.html#toCode" class="link">Source</a> <a href="#v:toCode" class="selflink">#</a></p><p class="src"><a href="#v:fromCode">fromCode</a> :: <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> q a <a href="src/Language.Haskell.TH.Syntax.Compat.html#fromCode" class="link">Source</a> <a href="#v:fromCode" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:8" id="g:8"><h2>Limitations of <code>IsCode</code></h2></a><div class="doc"><p><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:IsCode" title="Language.Haskell.TH.Syntax.Compat">IsCode</a></code> makes it possible to backport code involving typed Template Haskell
 quotations and splices where the types are monomorphized to <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>. GHC 9.0
 and later, however, make it possible to use typed TH quotations and splices
 that are polymorphic over any <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> instance. Unfortunately, the
 <code>th-compat</code> library does not yet have a good story for backporting
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>-polymorphic quotations or splices. For example, consider this code:</p><pre>instance (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> a, <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code> q, <code><a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a></code> a) =&gt; <code><a href="../base-4.18.2.1/Prelude.html#t:Num" title="Prelude">Num</a></code> (<code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> q a) where
  -- ...
  x + y = [|| $$x + $$y ||]
  -- ...
</pre><p>How might we backport this code? If we were in a setting where <code>q</code> were
 monomorphized to <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>, we could simply write this:</p><pre>  x + y = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:toCode" title="Language.Haskell.TH.Syntax.Compat">toCode</a></code> [|| $$(<code><a href="Language-Haskell-TH-Syntax-Compat.html#v:fromCode" title="Language.Haskell.TH.Syntax.Compat">fromCode</a></code> x) + $$(<code><a href="Language-Haskell-TH-Syntax-Compat.html#v:fromCode" title="Language.Haskell.TH.Syntax.Compat">fromCode</a></code> y) ||]
</pre><p>In a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a></code>-polymorphic setting, however, we run into issues. While this
 will compile on GHC 9.0 or later, it will not compile on earlier GHC
 versions because all typed TH quotations and splices must use <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code>. At
 present, the <code>th-compat</code> library does not offer any solution to this
 problem.</p></div><div class="top"><p class="src"><a id="v:unsafeCodeCoerce" class="def">unsafeCodeCoerce</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a <a href="#v:unsafeCodeCoerce" class="selflink">#</a></p><div class="doc"><p>Unsafely convert an untyped code representation into a typed code
 representation.</p></div></div><div class="top"><p class="src"><a id="v:liftCode" class="def">liftCode</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a <a href="#v:liftCode" class="selflink">#</a></p><div class="doc"><p>Lift a monadic action producing code into the typed <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>
 representation</p></div></div><div class="top"><p class="src"><a id="v:unTypeCode" class="def">unTypeCode</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="#v:unTypeCode" class="selflink">#</a></p><div class="doc"><p>Extract the untyped representation from the typed representation</p></div></div><div class="top"><p class="src"><a id="v:hoistCode" class="def">hoistCode</a> :: <span class="keyword">forall</span> m n (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> n a <a href="#v:hoistCode" class="selflink">#</a></p><div class="doc"><p>Modify the ambient monad used during code generation. For example, you
 can use <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:hoistCode" title="Language.Haskell.TH.Syntax.Compat">hoistCode</a></code> to handle a state effect:
 <code>
  handleState :: Code (StateT Int Q) a -&gt; Code Q a
  handleState = hoistCode (flip runState 0)
 </code></p></div></div><div class="top"><p class="src"><a id="v:bindCode" class="def">bindCode</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; (a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b <a href="#v:bindCode" class="selflink">#</a></p><div class="doc"><p>Variant of (&gt;&gt;=) which allows effectful computations to be injected
 into code generation.</p></div></div><div class="top"><p class="src"><a id="v:bindCode_" class="def">bindCode_</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m b <a href="#v:bindCode_" class="selflink">#</a></p><div class="doc"><p>Variant of (&gt;&gt;) which allows effectful computations to be injected
 into code generation.</p></div></div><div class="top"><p class="src"><a id="v:joinCode" class="def">joinCode</a> :: <span class="keyword">forall</span> m (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> m a <a href="#v:joinCode" class="selflink">#</a></p><div class="doc"><p>A useful combinator for embedding monadic actions into <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>
 <code>
 myCode :: ... =&gt; Code m a
 myCode = joinCode $ do
   x &lt;- someSideEffect
   return (makeCodeWith x)
 </code></p></div></div><a href="#g:9" id="g:9"><h1>Compatibility with <code>Splice</code>s</h1></a><div class="doc"><p>This section of code is useful for library authors looking to provide
 a typed <code>TemplateHaskell</code> interface that is backwards- and
 forward-compatible. This section may be useful for you if you
 specifically intend for the splice to be done directly.</p><p>Prior to GHC 9, you'd offer a value with type <code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>.
 After GHC 9, these values are no longer acceptable in a typed splice:
 typed splices must operate in <code>Code m a</code> instead.</p><p>The <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> m a</code> type is used to work with both versions - it is a type
 alias, and depending on the version of <code>template-haskell</code> that was
 compiled, it will either be <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> m a</code> or <code>m (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>.</p><p>The function <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftSplice" title="Language.Haskell.TH.Syntax.Compat">liftSplice</a></code> can be used to convert a <code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>
 expression into a <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> a</code> expression in a compatible manner - by
 lifting to <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:SpliceQ" title="Language.Haskell.TH.Syntax.Compat">SpliceQ</a></code>, you get the right behavior depending on your
 <code>template-haskell</code> version.</p><p>The function <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:examineSplice" title="Language.Haskell.TH.Syntax.Compat">examineSplice</a></code> can be used on typed QuasiQuoters, and the
 result will be converted into an appropriate <code>m (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>. This
 allows you to use typed quasiquoters in a <code>do</code> block, much like
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:examineCode" title="Language.Haskell.TH.Syntax.Compat">examineCode</a></code> does with <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code>.</p><p>With <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:expToSplice" title="Language.Haskell.TH.Syntax.Compat">expToSplice</a></code>, you can substitute uses of <code><a href="../base-4.18.2.1/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> when given the
 specific type:</p><pre>pureTExp :: <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)
pureTExp = pure
</pre><p>This allows you to splice <code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a</code> values directly into a typed
 quasiquoter.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Splice" class="def">Splice</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a> :: <span class="keyword">forall</span> r. (* -&gt; *) -&gt; <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; * <a href="src/Language.Haskell.TH.Syntax.Compat.html#Splice" class="link">Source</a> <a href="#t:Splice" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> m a</code> is a type alias for:</p><ul><li><code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> m a</code>, if using <code>template-haskell-2.17.0.0</code> or later, or</li><li><code>m (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>, if using an older version of <code>template-haskell</code>.</li></ul><p>This should be used with caution, as its definition differs depending on
 which version of <code>template-haskell</code> you are using. It is mostly useful for
 contexts in which one is writing a definition that is intended to be used
 directly in a typed Template Haskell splice, as the types of TH splices
 differ between <code>template-haskell</code> versions as well.</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SpliceQ" class="def">SpliceQ</a> = <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r -&gt; * <a href="src/Language.Haskell.TH.Syntax.Compat.html#SpliceQ" class="link">Source</a> <a href="#t:SpliceQ" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:SpliceQ" title="Language.Haskell.TH.Syntax.Compat">SpliceQ</a></code> a</code> is a type alias for:</p><ul><li><code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> a</code>, if using <code>template-haskell-2.17.0.0</code> or later, or</li><li><code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>, if using an older version of <code>template-haskell</code>.</li></ul><p>This should be used with caution, as its definition differs depending on
 which version of <code>template-haskell</code> you are using. It is mostly useful for
 contexts in which one is writing a definition that is intended to be used
 directly in a typed Template Haskell splice, as the types of TH splices
 differ between <code>template-haskell</code> versions as well.</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:bindSplice" class="def">bindSplice</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; (a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b <a href="src/Language.Haskell.TH.Syntax.Compat.html#bindSplice" class="link">Source</a> <a href="#v:bindSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:bindCode" title="Language.Haskell.TH.Syntax.Compat">bindCode</a></code> that works over <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>s. Because this function
 uses <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the type of this function will be different depending on
 which version of <code>template-haskell</code> you are using. (See the Haddocks for
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:bindSplice_" class="def">bindSplice_</a> :: <span class="keyword">forall</span> m a (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (b :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m b <a href="src/Language.Haskell.TH.Syntax.Compat.html#bindSplice_" class="link">Source</a> <a href="#v:bindSplice_" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:bindCode_" title="Language.Haskell.TH.Syntax.Compat">bindCode_</a></code> that works over <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>s. Because this function
 uses <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the type of this function will be different depending on
 which version of <code>template-haskell</code> you are using. (See the Haddocks for
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:examineSplice" class="def">examineSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) m (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) <a href="src/Language.Haskell.TH.Syntax.Compat.html#examineSplice" class="link">Source</a> <a href="#v:examineSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:examineCode" title="Language.Haskell.TH.Syntax.Compat">examineCode</a></code> that takes a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> as an argument. Because
 this function takes a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> as an argyment, the type of this function
 will be different depending on which version of <code>template-haskell</code> you are
 using. (See the Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:hoistSplice" class="def">hoistSplice</a> :: <span class="keyword">forall</span> m n (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> n a <a href="src/Language.Haskell.TH.Syntax.Compat.html#hoistSplice" class="link">Source</a> <a href="#v:hoistSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:hoistCode" title="Language.Haskell.TH.Syntax.Compat">hoistCode</a></code> that works over <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>s. Because this function
 uses <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the type of this function will be different depending on
 which version of <code>template-haskell</code> you are using. (See the Haddocks for
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:joinSplice" class="def">joinSplice</a> :: <span class="keyword">forall</span> m (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r). <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m (<a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a <a href="src/Language.Haskell.TH.Syntax.Compat.html#joinSplice" class="link">Source</a> <a href="#v:joinSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:joinCode" title="Language.Haskell.TH.Syntax.Compat">joinCode</a></code> that works over <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>s. Because this function
 uses <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the type of this function will be different depending on
 which version of <code>template-haskell</code> you are using. (See the Haddocks for
 <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:liftSplice" class="def">liftSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. m (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a) -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a <a href="src/Language.Haskell.TH.Syntax.Compat.html#liftSplice" class="link">Source</a> <a href="#v:liftSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftCode" title="Language.Haskell.TH.Syntax.Compat">liftCode</a></code> that returns a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>. Because this function
 returns a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the return type of this function will be different
 depending on which version of <code>template-haskell</code> you are using. (See the
 Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more
 information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:liftTypedFromUntypedSplice" class="def">liftTypedFromUntypedSplice</a> :: (<a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a> t, <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m) =&gt; t -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m t <a href="src/Language.Haskell.TH.Syntax.Compat.html#liftTypedFromUntypedSplice" class="link">Source</a> <a href="#v:liftTypedFromUntypedSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedQuote" title="Language.Haskell.TH.Syntax.Compat">liftTypedQuote</a></code> that is:</p><ol><li value="1">Always implemented in terms of <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> behind the scenes, and</li><li value="2">Returns a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>. This means that the return type of this function will
    be different depending on which version of <code>template-haskell</code> you are
    using. (See the Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this
    point.)</li></ol><p>This is especially useful for minimizing CPP in one particular scenario:
 implementing <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> in hand-written <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> instances
 where the corresponding <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> implementation cannot be derived. For
 instance, consider this example from the <code>text</code> library:</p><pre>instance <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> Text where
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> = appE (varE 'pack) . stringE . unpack
#if MIN_VERSION_template_haskell(2,17,0)
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeCodeCoerce" title="Language.Haskell.TH.Syntax.Compat">unsafeCodeCoerce</a></code> . <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code>
#elif MIN_VERSION_template_haskell(2,16,0)
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> = <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:unsafeTExpCoerce" title="Language.Haskell.TH.Syntax">unsafeTExpCoerce</a></code> . <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code>
#endif
</pre><p>The precise details of how this <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> implementation works are not
 important, only that it is something that <code>DeriveLift</code> could not generate.
 The main point of this example is to illustrate how tiresome it is to write
 the CPP necessary to define <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> in a way that works across
 multiple versions of <code>template-haskell</code>. With <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedFromUntypedSplice" title="Language.Haskell.TH.Syntax.Compat">liftTypedFromUntypedSplice</a></code>,
 however, this becomes slightly easier to manage:</p><pre>instance <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> Text where
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> = appE (varE 'pack) . stringE . unpack
#if MIN_VERSION_template_haskell(2,16,0)
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedFromUntypedSplice" title="Language.Haskell.TH.Syntax.Compat">liftTypedFromUntypedSplice</a></code>
#endif
</pre><p>Note that due to the way this function is defined, this will only work
 for <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> instances <code>t</code> such that <code>(t :: Type)</code>. If you wish to
 manually define <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> for a type with a different kind, you
 will have to use <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeSpliceCoerce" title="Language.Haskell.TH.Syntax.Compat">unsafeSpliceCoerce</a></code> to overcome levity polymorphism
 restrictions.</p></div></div><div class="top"><p class="src"><a id="v:unsafeSpliceCoerce" class="def">unsafeSpliceCoerce</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a <a href="src/Language.Haskell.TH.Syntax.Compat.html#unsafeSpliceCoerce" class="link">Source</a> <a href="#v:unsafeSpliceCoerce" class="selflink">#</a></p><div class="doc"><p>Unsafely convert an untyped splice representation into a typed <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>
 representation. Because this function returns a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>, the return type of
 this function will be different depending on which version of
 <code>template-haskell</code> you are using. (See the Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more
 information on this point.)</p><p>This is especially useful for minimizing CPP when:</p><ol><li value="1">You need to implement <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> in a hand-written <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code>
    instance where the corresponding <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> implementation cannot be
    derived, and</li><li value="2">The data type receiving a <code>Lift</code> instance has a kind besides <code>Type</code>.</li></ol><p>Condition (2) is important because while it is possible to simply define
 <code>'Syntax.liftTyped = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedFromUntypedSplice" title="Language.Haskell.TH.Syntax.Compat">liftTypedFromUntypedSplice</a></code></code> for <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code>
 instances <code>t</code> such that <code>(t :: Type)</code>, this will not work for types with
 different types, such as unboxed types or unlifted newtypes. This is because
 GHC restrictions prevent defining <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftTypedFromUntypedSplice" title="Language.Haskell.TH.Syntax.Compat">liftTypedFromUntypedSplice</a></code> in a levity
 polymorphic fashion, so one must use <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeSpliceCoerce" title="Language.Haskell.TH.Syntax.Compat">unsafeSpliceCoerce</a></code> to work around
 these restrictions. Here is an example of how to use <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeSpliceCoerce" title="Language.Haskell.TH.Syntax.Compat">unsafeSpliceCoerce</a></code>:</p><pre>instance <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Lift" title="Language.Haskell.TH.Syntax">Lift</a></code> Int# where
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> x = litE (intPrimL (fromIntegral (I# x)))
#if MIN_VERSION_template_haskell(2,16,0)
  <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:liftTyped" title="Language.Haskell.TH.Syntax">liftTyped</a></code> x = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unsafeSpliceCoerce" title="Language.Haskell.TH.Syntax.Compat">unsafeSpliceCoerce</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:lift" title="Language.Haskell.TH.Syntax">lift</a></code> x)
#endif
</pre><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:unTypeSplice" class="def">unTypeSplice</a> :: <span class="keyword">forall</span> (r :: <a href="../base-4.18.2.1/GHC-Exts.html#t:RuntimeRep" title="GHC.Exts">RuntimeRep</a>) (a :: <a href="../base-4.18.2.1/GHC-Exts.html#t:TYPE" title="GHC.Exts">TYPE</a> r) m. <a href="Language-Haskell-TH-Syntax-Compat.html#t:Quote" title="Language.Haskell.TH.Syntax.Compat">Quote</a> m =&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a -&gt; m <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Exp" title="Language.Haskell.TH.Syntax">Exp</a> <a href="src/Language.Haskell.TH.Syntax.Compat.html#unTypeSplice" class="link">Source</a> <a href="#v:unTypeSplice" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:unTypeCode" title="Language.Haskell.TH.Syntax.Compat">unTypeCode</a></code> that takes a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> as an argument. Because
 this function takes a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> as an argyment, the type of this function
 will be different depending on which version of <code>template-haskell</code> you are
 using. (See the Haddocks for <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code> for more information on this point.)</p><p>Levity-polymorphic since <em>template-haskell-2.16.0.0</em>.</p></div></div><div class="top"><p class="src"><a id="v:expToSplice" class="def">expToSplice</a> :: <a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a> a -&gt; <a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a> m a <a href="src/Language.Haskell.TH.Syntax.Compat.html#expToSplice" class="link">Source</a> <a href="#v:expToSplice" class="selflink">#</a></p><div class="doc"><p>Lift a <code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a</code> into a <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Splice" title="Language.Haskell.TH.Syntax.Compat">Splice</a></code>. This is useful when splicing
 in the result of a computation into a typed QuasiQuoter.</p><p>One example is <code><a href="../base-4.18.2.1/Data-Traversable.html#v:traverse" title="Data.Traversable">traverse</a></code>ing over a list of elements and returning an
 expression from each element.</p><pre>mkInt :: <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>)
mkInt str = [|| length $$str ||]

mkInts :: [<code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code>] -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> [<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>]
mkInts = traverse mkInt
</pre><p>This gives us a list of <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code>, not a <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> of a list. We
 can push the list inside the type with this function:</p><pre>listTE :: [<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a] -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> [a]
listTE = <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> . <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:ListE" title="Language.Haskell.TH.Syntax">ListE</a></code> . <code><a href="../base-4.18.2.1/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#v:unType" title="Language.Haskell.TH.Syntax">unType</a></code>
</pre><p>In a <code>do</code> block using <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftSplice" title="Language.Haskell.TH.Syntax.Compat">liftSplice</a></code>, we can bind the resulting</p><p><code><code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> [<code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>]</code> out of the expression.</p><pre>foo :: <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> Int)
foo = do
     ints &lt;- mkInts [&quot;hello&quot;, &quot;world&quot;, &quot;goodybe&quot;, &quot;bob&quot;]
     [|| sum $$(pure (listTE ints)) ||]
</pre><p>Prior to GHC 9, with the <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> type, we can write <code><code><a href="../base-4.18.2.1/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> :: <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a)</code>,
 which is a valid thing to use in a typed quasiquoter.
 However, after GHC 9, this code will fail to type check. There is no
 <code><a href="../base-4.18.2.1/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance for <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> m a</code>, so we need another way to
 splice it in.</p><p>A GHC 9 only solution can use <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> :: m (<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> a) -&gt; Code
 m a</code> and <code><a href="../base-4.18.2.1/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> together, like: <code><code><a href="Language-Haskell-TH-Syntax-Compat.html#t:Code" title="Language.Haskell.TH.Syntax.Compat">Code</a></code> . <code><a href="../base-4.18.2.1/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code></code>.</p><p>With <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:expToSplice" title="Language.Haskell.TH.Syntax.Compat">expToSplice</a></code>, we can splice it in a backwards compatible way.
 A fully backwards- and forwards-compatible example looks like this:</p><pre>mkInt :: <code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code> -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>
mkInt str = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:examineSplice" title="Language.Haskell.TH.Syntax.Compat">examineSplice</a></code> [|| length $$str ||]

mkInts :: [<code><a href="../base-4.18.2.1/Data-String.html#t:String" title="Data.String">String</a></code>] -&gt; <code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a></code> [<code><a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:TExp" title="Language.Haskell.TH.Syntax">TExp</a></code> <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>]
mkInts = traverse mkInt

foo :: <code><a href="Language-Haskell-TH-Syntax-Compat.html#t:SpliceQ" title="Language.Haskell.TH.Syntax.Compat">SpliceQ</a></code> <code><a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a></code>
foo = <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:liftSplice" title="Language.Haskell.TH.Syntax.Compat">liftSplice</a></code> $ do
     ints &lt;- mkInts [&quot;hello&quot;, &quot;world&quot;, &quot;goodybe&quot;, &quot;bob&quot;]
     <code><a href="Language-Haskell-TH-Syntax-Compat.html#v:examineSplice" title="Language.Haskell.TH.Syntax.Compat">examineSplice</a></code> [|| sum $$(expToSplice (listTE ints)) ||]
</pre><p><em>Since: 0.1.3</em></p></div></div><a href="#g:10" id="g:10"><h1>Package root functions</h1></a><div class="top"><p class="src"><a id="v:getPackageRoot" class="def">getPackageRoot</a> :: <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="#v:getPackageRoot" class="selflink">#</a></p><div class="doc"><p>Get the package root for the current package which is being compiled.
 This can be set explicitly with the -package-root flag but is normally
 just the current working directory.</p><p>The motivation for this flag is to provide a principled means to remove the
 assumption from splices that they will be executed in the directory where the
 cabal file resides. Projects such as haskell-language-server can't and don't
 change directory when compiling files but instead set the -package-root flag
 appropiately.</p></div></div><div class="top"><p class="src"><a id="v:makeRelativeToProject" class="def">makeRelativeToProject</a> :: <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="../template-haskell-2.20.0.0/Language-Haskell-TH-Syntax.html#t:Q" title="Language.Haskell.TH.Syntax">Q</a> <a href="../base-4.18.2.1/System-IO.html#t:FilePath" title="System.IO">FilePath</a> <a href="#v:makeRelativeToProject" class="selflink">#</a></p><div class="doc"><p>The input is a filepath, which if relative is offset by the package root.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>