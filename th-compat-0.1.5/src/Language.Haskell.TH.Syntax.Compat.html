<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FunctionalDependencies #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE GADTs #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE KindSignatures #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE RankNTypes #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &gt;= 702
</span><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 706
</span><span class="hs-pragma">{-# LANGUAGE PolyKinds #-}</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 708
</span><span class="hs-pragma">{-# LANGUAGE RoleAnnotations #-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- | This module exists to make it possible to define code that works across</span><span>
</span><span id="line-25"></span><span class="hs-comment">-- a wide range of @template-haskell@ versions with as little CPP as possible.</span><span>
</span><span id="line-26"></span><span class="hs-comment">-- To that end, this module currently backports the following</span><span>
</span><span id="line-27"></span><span class="hs-comment">-- @template-haskell@ constructs:</span><span>
</span><span id="line-28"></span><span class="hs-comment">--</span><span>
</span><span id="line-29"></span><span class="hs-comment">-- * The 'Quote' class</span><span>
</span><span id="line-30"></span><span class="hs-comment">--</span><span>
</span><span id="line-31"></span><span class="hs-comment">-- * The 'Code' type</span><span>
</span><span id="line-32"></span><span class="hs-comment">--</span><span>
</span><span id="line-33"></span><span class="hs-comment">-- * The 'getPackageRoot' and 'makeRelativeToProject' utility functions</span><span>
</span><span id="line-34"></span><span class="hs-comment">--</span><span>
</span><span id="line-35"></span><span class="hs-comment">-- Refer to the Haddocks below for examples of how to use each of these in a</span><span>
</span><span id="line-36"></span><span class="hs-comment">-- backwards-compatible way.</span><span>
</span><span id="line-37"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Syntax.Compat</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><span class="hs-comment">-- * The @Quote@ class</span></span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><span class="hs-comment">-- $quote</span></span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><span class="hs-identifier">Quote</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span>    </span><span class="annot"><span class="hs-comment">-- * @Quote@ functionality</span></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** The @unsafeQToQuote@ function</span></span><span>
</span><span id="line-43"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeQToQuote"><span class="hs-identifier">unsafeQToQuote</span></a></span><span>
</span><span id="line-44"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Functions from @Language.Haskell.TH.Syntax@</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,9,0)
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeQQuote"><span class="hs-identifier">unTypeQQuote</span></a></span><span>
</span><span id="line-47"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeTExpCoerceQuote"><span class="hs-identifier">unsafeTExpCoerceQuote</span></a></span><span class="hs-cpp">
#endif
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftQuote"><span class="hs-identifier">liftQuote</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,9,0)
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedQuote"><span class="hs-identifier">liftTypedQuote</span></a></span><span class="hs-cpp">
#endif
</span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftStringQuote"><span class="hs-identifier">liftStringQuote</span></a></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,9,0)
</span><span>    </span><span class="annot"><span class="hs-comment">-- * The @Code@ and @CodeQ@ types</span></span><span>
</span><span id="line-57"></span><span>    </span><span class="annot"><span class="hs-comment">-- $code</span></span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Code</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">CodeQ</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><span class="hs-comment">-- * @Code@ functionality</span></span><span>
</span><span id="line-60"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** The @IsCode@ class</span></span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#IsCode"><span class="hs-identifier">IsCode</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>    </span><span class="annot"><span class="hs-comment">-- ** Limitations of @IsCode@</span></span><span>
</span><span id="line-63"></span><span>    </span><span class="hs-comment">-- $isCodeLimitations</span><span>
</span><span id="line-64"></span><span>    </span><span class="hs-comment">-- ** Functions from @Language.Haskell.TH.Syntax@</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unsafeCodeCoerce</span></span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftCode</span></span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unTypeCode</span></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">hoistCode</span></span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">bindCode</span></span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">bindCode_</span></span><span>
</span><span id="line-71"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">joinCode</span></span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Compatibility with @Splice@s</span></span><span>
</span><span id="line-74"></span><span>  </span><span class="annot"><span class="hs-comment">-- $splice</span></span><span>
</span><span id="line-75"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier">Splice</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#SpliceQ"><span class="hs-identifier">SpliceQ</span></a></span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice"><span class="hs-identifier">bindSplice</span></a></span><span>
</span><span id="line-78"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice_"><span class="hs-identifier">bindSplice_</span></a></span><span>
</span><span id="line-79"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#examineSplice"><span class="hs-identifier">examineSplice</span></a></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#hoistSplice"><span class="hs-identifier">hoistSplice</span></a></span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#joinSplice"><span class="hs-identifier">joinSplice</span></a></span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftSplice"><span class="hs-identifier">liftSplice</span></a></span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedFromUntypedSplice"><span class="hs-identifier">liftTypedFromUntypedSplice</span></a></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeSpliceCoerce"><span class="hs-identifier">unsafeSpliceCoerce</span></a></span><span>
</span><span id="line-85"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeSplice"><span class="hs-identifier">unTypeSplice</span></a></span><span>
</span><span id="line-86"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#expToSplice"><span class="hs-identifier">expToSplice</span></a></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-89"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Package root functions</span></span><span>
</span><span id="line-90"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">getPackageRoot</span></span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">makeRelativeToProject</span></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Fail</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Fail</span></span><span>
</span><span id="line-95"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.IO.Class</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadIO</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-96"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Exp</span></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Lib</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Lib</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Q</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">runQ</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Quasi</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Syntax</span></span><span class="hs-cpp">

#if !(MIN_VERSION_base(4,8,0))
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Applicative</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,16,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Exts</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">RuntimeRep</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">TYPE</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,17,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Lib</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">CodeQ</span></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Code</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Quote</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">bindCode</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">bindCode_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">hoistCode</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">joinCode</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftCode</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unsafeCodeCoerce</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unTypeCode</span></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unsafeTExpCoerce</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">unTypeQ</span></span><span> </span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language.Haskell.TH</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Name</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,19,0)
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">getPackageRoot</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">makeRelativeToProject</span></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">System.FilePath</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">isRelative</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">takeExtension</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">takeDirectory</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;/&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">System.Directory</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">getDirectoryContents</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">canonicalizePath</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-126"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-127"></span><span class="hs-comment">-- Quote</span><span>
</span><span id="line-128"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="hs-comment">-- $quote</span><span>
</span><span id="line-131"></span><span class="hs-comment">-- The 'Quote' class (first proposed in</span><span>
</span><span id="line-132"></span><span class="hs-comment">-- &lt;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0246-overloaded-bracket.rst GHC Proposal 246&gt;)</span><span>
</span><span id="line-133"></span><span class="hs-comment">-- was introduced in @template-haskell-2.17.0.0@. This module defines a version</span><span>
</span><span id="line-134"></span><span class="hs-comment">-- of 'Quote' that is backward-compatible with older @template-haskell@</span><span>
</span><span id="line-135"></span><span class="hs-comment">-- releases and is forward-compatible with the existing 'Quote' class.</span><span>
</span><span id="line-136"></span><span class="hs-comment">--</span><span>
</span><span id="line-137"></span><span class="hs-comment">-- In addition to 'Quote', this module also backports versions of functions in</span><span>
</span><span id="line-138"></span><span class="hs-comment">-- &quot;Language.Haskell.TH.Syntax&quot; that work over any 'Quote' instance instead of</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- just 'Q'. Since this module is designed to coexist with the existing</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- definitions in @template-haskell@ as much as possible, the backported</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- functions are suffixed with @-Quote@ to avoid name clashes. For instance,</span><span>
</span><span id="line-142"></span><span class="hs-comment">-- the backported version of 'lift' is named 'liftQuote'.</span><span>
</span><span id="line-143"></span><span class="hs-comment">--</span><span>
</span><span id="line-144"></span><span class="hs-comment">-- The one exception to the no-name-clashes policy is the backported 'newName'</span><span>
</span><span id="line-145"></span><span class="hs-comment">-- method of 'Quote'. We could have conceivably named it 'newNameQuote', but</span><span>
</span><span id="line-146"></span><span class="hs-comment">-- then it would not have been possible to define backwards-compatible 'Quote'</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- instances without the use of CPP. As a result, some care must be exercised</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- when combining this module with &quot;Language.Haskell.TH&quot; or</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- &quot;Language.Haskell.TH.Syntax&quot; on older versions of @template-haskell@, as</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- they both export a version of 'newName' with a different type. Here is an</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- example of how to safely combine these modules:</span><span>
</span><span id="line-152"></span><span class="hs-comment">--</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-154"></span><span class="hs-comment">-- &amp;#123;-&amp;#35; LANGUAGE GeneralizedNewtypeDeriving, TemplateHaskell &amp;#35;-&amp;#125;</span><span>
</span><span id="line-155"></span><span class="hs-comment">--</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- import Control.Monad.State (MonadState(..), State, evalState)</span><span>
</span><span id="line-157"></span><span class="hs-comment">-- import &quot;Language.Haskell.TH&quot; hiding ('newName')</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- import &quot;Language.Haskell.TH.Syntax&quot; hiding ('newName')</span><span>
</span><span id="line-159"></span><span class="hs-comment">-- import &quot;Language.Haskell.TH.Syntax.Compat&quot;</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- newtype PureQ a = MkPureQ (State Uniq a)</span><span>
</span><span id="line-162"></span><span class="hs-comment">--   deriving (Functor, Applicative, Monad, MonadState Uniq)</span><span>
</span><span id="line-163"></span><span class="hs-comment">--</span><span>
</span><span id="line-164"></span><span class="hs-comment">-- runPureQ :: PureQ a -&gt; a</span><span>
</span><span id="line-165"></span><span class="hs-comment">-- runPureQ m = case m of MkPureQ m' -&gt; evalState m' 0</span><span>
</span><span id="line-166"></span><span class="hs-comment">--</span><span>
</span><span id="line-167"></span><span class="hs-comment">-- instance 'Quote' PureQ where</span><span>
</span><span id="line-168"></span><span class="hs-comment">--   'newName' s = state $ \i -&gt; (mkNameU s i, i + 1)</span><span>
</span><span id="line-169"></span><span class="hs-comment">--</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- main :: IO ()</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- main = putStrLn $ runPureQ $ do</span><span>
</span><span id="line-172"></span><span class="hs-comment">--   a &lt;- newName &quot;a&quot;</span><span>
</span><span id="line-173"></span><span class="hs-comment">--   return $ nameBase a</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-175"></span><span class="hs-comment">--</span><span>
</span><span id="line-176"></span><span class="hs-comment">-- We do not make an effort to backport any combinators from the</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- &quot;Language.Haskell.TH.Lib&quot; module, as the surface area is simply too large.</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- If you wish to generalize code that uses these combinators to work over</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- 'Quote' in a backwards-compatible way, use the 'unsafeQToQuote' function.</span><span class="hs-cpp">

#if !(MIN_VERSION_template_haskell(2,17,0))
</span><span class="hs-comment">-- | The 'Quote' class implements the minimal interface which is necessary for</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- desugaring quotations.</span><span>
</span><span id="line-184"></span><span class="hs-comment">--</span><span>
</span><span id="line-185"></span><span class="hs-comment">-- * The @Monad m@ superclass is needed to stitch together the different</span><span>
</span><span id="line-186"></span><span class="hs-comment">-- AST fragments.</span><span>
</span><span id="line-187"></span><span class="hs-comment">-- * 'newName' is used when desugaring binding structures such as lambdas</span><span>
</span><span id="line-188"></span><span class="hs-comment">-- to generate fresh names.</span><span>
</span><span id="line-189"></span><span class="hs-comment">--</span><span>
</span><span id="line-190"></span><span class="hs-comment">-- Therefore the type of an untyped quotation in GHC is `Quote m =&gt; m Exp`</span><span>
</span><span id="line-191"></span><span class="hs-comment">--</span><span>
</span><span id="line-192"></span><span class="hs-comment">-- For many years the type of a quotation was fixed to be `Q Exp` but by</span><span>
</span><span id="line-193"></span><span class="hs-comment">-- more precisely specifying the minimal interface it enables the `Exp` to</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- be extracted purely from the quotation without interacting with `Q`.</span><span>
</span><span id="line-195"></span><span class="hs-keyword">class</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span class="hs-cpp">
# if   !(MIN_VERSION_template_haskell(2,7,0))
</span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Functor</span><span> </span><span class="hs-identifier">m</span><span class="hs-cpp">
# elif !(MIN_VERSION_template_haskell(2,10,0))
</span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">Applicative</span><span> </span><span class="hs-identifier">m</span><span class="hs-cpp">
# endif
</span><span>      </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">Quote</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-comment">{- |
  Generate a fresh name, which cannot be captured.

  For example, this:

  @f = $(do
    nm1 &lt;- newName \&quot;x\&quot;
    let nm2 = 'mkName' \&quot;x\&quot;
    return ('LamE' ['VarP' nm1] (LamE [VarP nm2] ('VarE' nm1)))
   )@

  will produce the splice

  &gt;f = \x0 -&gt; \x -&gt; x0

  In particular, the occurrence @VarE nm1@ refers to the binding @VarP nm1@,
  and is not captured by the binding @VarP nm2@.

  Although names generated by @newName@ cannot /be captured/, they can
  /capture/ other names. For example, this:

  &gt;g = $(do
  &gt;  nm1 &lt;- newName &quot;x&quot;
  &gt;  let nm2 = mkName &quot;x&quot;
  &gt;  return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
  &gt; )

  will produce the splice

  &gt;g = \x -&gt; \x0 -&gt; x0

  since the occurrence @VarE nm2@ is captured by the innermost binding
  of @x@, namely @VarP nm1@.
  -}</span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-identifier">newName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">Name</span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">Quote</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-identifier">newName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">qNewName</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,9,0)
</span><span class="hs-comment">-- | Discard the type annotation and produce a plain Template Haskell</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- expression</span><span>
</span><span id="line-245"></span><span class="hs-comment">--</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-247"></span><span class="hs-comment">--</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- This is a variant of the 'unTypeQ' function that is always guaranteed to</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- use a 'Quote' constraint, even on old versions of @template-haskell@.</span><span>
</span><span id="line-250"></span><span class="hs-comment">--</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- As this function interacts with typed Template Haskell, this function is</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- only defined on @template-haskell-2.9.0.0@ (GHC 7.8) or later.</span><span>
</span><span id="line-253"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeQQuote"><span class="hs-identifier hs-type">unTypeQQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039390"><span class="annot"><a href="#local-6989586621679039390"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039392"><span class="annot"><a href="#local-6989586621679039392"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039390"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039391"><span class="annot"><a href="#local-6989586621679039391"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039392"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039391"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="unTypeQQuote"><span class="annot"><span class="annottext">unTypeQQuote :: forall a (m :: * -&gt; *). Quote m =&gt; m (TExp a) -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeQQuote"><span class="hs-identifier hs-var hs-var">unTypeQQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; m Exp
forall a (m :: * -&gt; *). Quote m =&gt; m (TExp a) -&gt; m Exp
</span><span class="hs-identifier hs-var">unTypeQ</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">unTypeQQuote</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">e</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">m</span><span>
</span><span id="line-264"></span><span>                    </span><span class="hs-special">;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">e</span><span> </span><span class="hs-special">}</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-267"></span><span class="hs-comment">-- | Annotate the Template Haskell expression with a type</span><span>
</span><span id="line-268"></span><span class="hs-comment">--</span><span>
</span><span id="line-269"></span><span class="hs-comment">-- This is unsafe because GHC cannot check for you that the expression</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- really does have the type you claim it has.</span><span>
</span><span id="line-271"></span><span class="hs-comment">--</span><span>
</span><span id="line-272"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-273"></span><span class="hs-comment">--</span><span>
</span><span id="line-274"></span><span class="hs-comment">-- This is a variant of the 'unsafeTExpCoerce' function that is always</span><span>
</span><span id="line-275"></span><span class="hs-comment">-- guaranteed to use a 'Quote' constraint, even on old versions of</span><span>
</span><span id="line-276"></span><span class="hs-comment">-- @template-haskell@.</span><span>
</span><span id="line-277"></span><span class="hs-comment">--</span><span>
</span><span id="line-278"></span><span class="hs-comment">-- As this function interacts with typed Template Haskell, this function is</span><span>
</span><span id="line-279"></span><span class="hs-comment">-- only defined on @template-haskell-2.9.0.0@ (GHC 7.8) or later.</span><span>
</span><span id="line-280"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeTExpCoerceQuote"><span class="hs-identifier hs-type">unsafeTExpCoerceQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039397"><span class="annot"><a href="#local-6989586621679039397"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039399"><span class="annot"><a href="#local-6989586621679039399"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039397"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039398"><span class="annot"><a href="#local-6989586621679039398"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039398"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039398"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039398"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039399"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="unsafeTExpCoerceQuote"><span class="annot"><span class="annottext">unsafeTExpCoerceQuote :: forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeTExpCoerceQuote"><span class="hs-identifier hs-var hs-var">unsafeTExpCoerceQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; m (TExp a)
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; m (TExp a)
</span><span class="hs-identifier hs-var">unsafeTExpCoerce</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">unsafeTExpCoerceQuote</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">e</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">m</span><span>
</span><span id="line-291"></span><span>                             </span><span class="hs-special">;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">e</span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span>
</span><span id="line-295"></span><span class="hs-comment">-- | Turn a value into a Template Haskell expression, suitable for use in</span><span>
</span><span id="line-296"></span><span class="hs-comment">-- a splice.</span><span>
</span><span id="line-297"></span><span class="hs-comment">--</span><span>
</span><span id="line-298"></span><span class="hs-comment">-- This is a variant of the 'Syntax.lift' method of 'Syntax.Lift' that is</span><span>
</span><span id="line-299"></span><span class="hs-comment">-- always guaranteed to use a 'Quote' constraint, even on old versions of</span><span>
</span><span id="line-300"></span><span class="hs-comment">-- @template-haskell@.</span><span>
</span><span id="line-301"></span><span class="hs-comment">--</span><span>
</span><span id="line-302"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.17.0.0/.</span><span>
</span><span id="line-303"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftQuote"><span class="hs-identifier hs-type">liftQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,17,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039403"><span class="annot"><a href="#local-6989586621679039403"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039404"><span class="annot"><a href="#local-6989586621679039404"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039403"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039405"><span class="annot"><a href="#local-6989586621679039405"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#endif
</span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.Lift</span></span><span> </span><span class="annot"><a href="#local-6989586621679039404"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039405"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039404"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039405"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,17,0)
</span><span id="liftQuote"><span class="annot"><span class="annottext">liftQuote :: forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftQuote"><span class="hs-identifier hs-var hs-var">liftQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">t -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; t -&gt; m Exp
</span><span class="hs-identifier hs-var">Syntax.lift</span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">liftQuote</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unsafeQToQuote</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Syntax.lift</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,9,0)
</span><span class="hs-comment">-- | Turn a value into a Template Haskell typed expression, suitable for use</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- in a typed splice.</span><span>
</span><span id="line-319"></span><span class="hs-comment">--</span><span>
</span><span id="line-320"></span><span class="hs-comment">-- This is a variant of the 'Syntax.liftTyped' method of 'Syntax.Lift' that is</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- always guaranteed to use a 'Quote' constraint and return a 'Code', even on</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- old versions of @template-haskell@.</span><span>
</span><span id="line-323"></span><span class="hs-comment">--</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- As this function interacts with typed Template Haskell, this function is</span><span>
</span><span id="line-325"></span><span class="hs-comment">-- only defined on @template-haskell-2.9.0.0@ (GHC 7.8) or later. While the</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- 'Syntax.liftTyped' method of 'Syntax.Lift' was first introduced in</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- @template-haskell-2.16.0.0@, we are able to backport it back to</span><span>
</span><span id="line-328"></span><span class="hs-comment">-- @template-haskell-2.9.0.0@ by making use of the 'Syntax.lift' method on</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- older versions of @template-haskell@. This crucially relies on the</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- 'Syntax.Lift' law that @'lift' x &#8801; 'unTypeQ' ('liftTyped' x)@ to work,</span><span>
</span><span id="line-331"></span><span class="hs-comment">-- so beware if you use 'liftTypedQuote' with an unlawful 'Syntax.Lift'</span><span>
</span><span id="line-332"></span><span class="hs-comment">-- instance.</span><span>
</span><span id="line-333"></span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.17.0.0/.</span><span>
</span><span id="line-335"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedQuote"><span class="hs-identifier hs-type">liftTypedQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039412"><span class="annot"><a href="#local-6989586621679039412"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039413"><span class="annot"><a href="#local-6989586621679039413"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039412"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039414"><span class="annot"><a href="#local-6989586621679039414"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.Lift</span></span><span> </span><span class="annot"><a href="#local-6989586621679039413"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039414"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039413"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Code</span></span><span> </span><span class="annot"><a href="#local-6989586621679039414"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039413"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="liftTypedQuote"><span class="annot"><span class="annottext">liftTypedQuote :: forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; Code m t
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedQuote"><span class="hs-identifier hs-var hs-var">liftTypedQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">t -&gt; Code m t
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; Code m t
forall (m :: * -&gt; *). Quote m =&gt; t -&gt; Code m t
</span><span class="hs-identifier hs-var">Syntax.liftTyped</span></span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,16,0)
</span><span class="hs-identifier">liftTypedQuote</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">liftCode</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">unsafeQToQuote</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Syntax.liftTyped</span><span class="hs-cpp">
# else
</span><span class="hs-identifier">liftTypedQuote</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unsafeCodeCoerce</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">liftQuote</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span>
</span><span id="line-351"></span><span class="hs-comment">-- | This is a variant of the 'Syntax.liftString' function that is always</span><span>
</span><span id="line-352"></span><span class="hs-comment">-- guaranteed to use a 'Quote' constraint, even on old versions of</span><span>
</span><span id="line-353"></span><span class="hs-comment">-- @template-haskell@.</span><span>
</span><span id="line-354"></span><span id="local-6989586621679039419"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftStringQuote"><span class="hs-identifier hs-type">liftStringQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039419"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,17,0)
</span><span id="liftStringQuote"><span class="annot"><span class="annottext">liftStringQuote :: forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftStringQuote"><span class="hs-identifier hs-var hs-var">liftStringQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m Exp
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Exp
</span><span class="hs-identifier hs-var">Syntax.liftString</span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">liftStringQuote</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unsafeQToQuote</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">Syntax.liftString</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-361"></span><span class="hs-comment">-- | Use a 'Q' computation in a 'Quote' context. This function is only safe</span><span>
</span><span id="line-362"></span><span class="hs-comment">-- when the 'Q' computation performs actions from the 'Quote' instance for 'Q'</span><span>
</span><span id="line-363"></span><span class="hs-comment">-- or any of `Quote`'s subclasses ('Functor', 'Applicative', and 'Monad').</span><span>
</span><span id="line-364"></span><span class="hs-comment">-- Attempting to perform actions from the 'MonadFail', 'MonadIO', or 'Quasi'</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- instances for 'Q' will result in runtime errors.</span><span>
</span><span id="line-366"></span><span class="hs-comment">--</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- This is useful when you have some 'Q'-valued functions that only performs</span><span>
</span><span id="line-368"></span><span class="hs-comment">-- actions from 'Quote' and wish to generalise it from 'Q' to 'Quote' without</span><span>
</span><span id="line-369"></span><span class="hs-comment">-- having to rewrite the internals of the function. This is especially handy</span><span>
</span><span id="line-370"></span><span class="hs-comment">-- for code defined in terms of combinators from &quot;Language.Haskell.TH.Lib&quot;,</span><span>
</span><span id="line-371"></span><span class="hs-comment">-- which were all hard-coded to 'Q' prior to @template-haskell-2.17.0.0@. For</span><span>
</span><span id="line-372"></span><span class="hs-comment">-- instance, consider this function:</span><span>
</span><span id="line-373"></span><span class="hs-comment">--</span><span>
</span><span id="line-374"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-375"></span><span class="hs-comment">-- apply :: 'Exp' -&gt; 'Exp' -&gt; 'Q' 'Exp'</span><span>
</span><span id="line-376"></span><span class="hs-comment">-- apply f x = 'Lib.appE' (return x) (return y)</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-378"></span><span class="hs-comment">--</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- There are two ways to generalize this function to use 'Quote' in a</span><span>
</span><span id="line-380"></span><span class="hs-comment">-- backwards-compatible way. One way to do so is to rewrite @apply@ to avoid</span><span>
</span><span id="line-381"></span><span class="hs-comment">-- the use of 'Lib.appE', like so:</span><span>
</span><span id="line-382"></span><span class="hs-comment">--</span><span>
</span><span id="line-383"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-384"></span><span class="hs-comment">-- applyQuote :: 'Quote' m =&gt; 'Exp' -&gt; 'Exp' -&gt; m 'Exp'</span><span>
</span><span id="line-385"></span><span class="hs-comment">-- applyQuote f x = return ('Syntax.AppE' x y)</span><span>
</span><span id="line-386"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-387"></span><span class="hs-comment">--</span><span>
</span><span id="line-388"></span><span class="hs-comment">-- For a small example like @applyQuote@, there isn't much work involved. But</span><span>
</span><span id="line-389"></span><span class="hs-comment">-- this can become tiresome for larger examples. In such cases,</span><span>
</span><span id="line-390"></span><span class="hs-comment">-- 'unsafeQToQuote' can do the heavy lifting for you. For example, @applyQuote@</span><span>
</span><span id="line-391"></span><span class="hs-comment">-- can also be defined as:</span><span>
</span><span id="line-392"></span><span class="hs-comment">--</span><span>
</span><span id="line-393"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-394"></span><span class="hs-comment">-- applyQuote :: 'Quote' m =&gt; 'Exp' -&gt; 'Exp' -&gt; m 'Exp'</span><span>
</span><span id="line-395"></span><span class="hs-comment">-- applyQuote f x = 'unsafeQToQuote' (apply f x)</span><span>
</span><span id="line-396"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-397"></span><span id="local-6989586621679039421"><span id="local-6989586621679039422"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeQToQuote"><span class="hs-identifier hs-type">unsafeQToQuote</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039421"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679039422"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039421"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039422"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-398"></span><span id="unsafeQToQuote"><span class="annot"><span class="annottext">unsafeQToQuote :: forall (m :: * -&gt; *) a. Quote m =&gt; Q a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeQToQuote"><span class="hs-identifier hs-var hs-var">unsafeQToQuote</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">QuoteToQuasi m a -&gt; m a
forall (m :: * -&gt; *) a. QuoteToQuasi m a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unQTQ"><span class="hs-identifier hs-var">unQTQ</span></a></span><span> </span><span class="annot"><span class="annottext">(QuoteToQuasi m a -&gt; m a)
-&gt; (Q a -&gt; QuoteToQuasi m a) -&gt; Q a -&gt; m a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Q a -&gt; QuoteToQuasi m a
forall (m :: * -&gt; *) a. Quasi m =&gt; Q a -&gt; m a
</span><span class="hs-identifier hs-var">runQ</span></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span class="hs-comment">-- | An internal definition that powers 'unsafeQToQuote'. Its 'Quasi' instance</span><span>
</span><span id="line-401"></span><span class="hs-comment">-- defines 'qNewName' in terms of 'newName' from 'Quote', but defines every</span><span>
</span><span id="line-402"></span><span class="hs-comment">-- other method of 'Quasi' to be an error, since they cannot be implemented</span><span>
</span><span id="line-403"></span><span class="hs-comment">-- using 'Quote' alone. Similarly, its 'MonadFail' and 'MonadIO' instances</span><span>
</span><span id="line-404"></span><span class="hs-comment">-- define 'fail' and 'liftIO', respectively, to be errors.</span><span>
</span><span id="line-405"></span><span class="hs-keyword">newtype</span><span> </span><span id="QuoteToQuasi"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#QuoteToQuasi"><span class="hs-identifier hs-var">QuoteToQuasi</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039428"><span class="annot"><a href="#local-6989586621679039428"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039429"><span class="annot"><a href="#local-6989586621679039429"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="QTQ"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#QTQ"><span class="hs-identifier hs-var">QTQ</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="unQTQ"><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. QuoteToQuasi m a -&gt; m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unQTQ"><span class="hs-identifier hs-var hs-var">unQTQ</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679039428"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039429"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-406"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039668"><span id="local-6989586621679039672"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b)
-&gt; (forall a b. a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a)
-&gt; Functor (QuoteToQuasi m)
forall a b. a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
forall a b. (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *) a b.
Functor m =&gt;
a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
forall (m :: * -&gt; *) a b.
Functor m =&gt;
(a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall (m :: * -&gt; *) a b.
Functor m =&gt;
(a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
fmap :: forall a b. (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
$c&lt;$ :: forall (m :: * -&gt; *) a b.
Functor m =&gt;
a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
&lt;$ :: forall a b. a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679039682"><span id="local-6989586621679039686"><span id="local-6989586621679039690"><span id="local-6989586621679039694"><span id="local-6989586621679039698"><span class="annot"><span class="annottext">Functor (QuoteToQuasi m)
Functor (QuoteToQuasi m) =&gt;
(forall a. a -&gt; QuoteToQuasi m a)
-&gt; (forall a b.
    QuoteToQuasi m (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b)
-&gt; (forall a b c.
    (a -&gt; b -&gt; c)
    -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m c)
-&gt; (forall a b.
    QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b)
-&gt; (forall a b.
    QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a)
-&gt; Applicative (QuoteToQuasi m)
forall a. a -&gt; QuoteToQuasi m a
forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
forall a b.
QuoteToQuasi m (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
forall a b c.
(a -&gt; b -&gt; c)
-&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m c
forall (f :: * -&gt; *).
Functor f =&gt;
(forall a. a -&gt; f a)
-&gt; (forall a b. f (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c)
-&gt; (forall a b. f a -&gt; f b -&gt; f b)
-&gt; (forall a b. f a -&gt; f b -&gt; f a)
-&gt; Applicative f
forall (m :: * -&gt; *). Applicative m =&gt; Functor (QuoteToQuasi m)
forall (m :: * -&gt; *) a. Applicative m =&gt; a -&gt; QuoteToQuasi m a
forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; c)
-&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m c
$cpure :: forall (m :: * -&gt; *) a. Applicative m =&gt; a -&gt; QuoteToQuasi m a
pure :: forall a. a -&gt; QuoteToQuasi m a
$c&lt;*&gt; :: forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
&lt;*&gt; :: forall a b.
QuoteToQuasi m (a -&gt; b) -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b
$cliftA2 :: forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; c)
-&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m c
liftA2 :: forall a b c.
(a -&gt; b -&gt; c)
-&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m c
$c*&gt; :: forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
*&gt; :: forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
$c&lt;* :: forall (m :: * -&gt; *) a b.
Applicative m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
&lt;* :: forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Applicative</span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679039709"><span id="local-6989586621679039713"><span id="local-6989586621679039717"><span class="annot"><span class="annottext">Applicative (QuoteToQuasi m)
Applicative (QuoteToQuasi m) =&gt;
(forall a b.
 QuoteToQuasi m a -&gt; (a -&gt; QuoteToQuasi m b) -&gt; QuoteToQuasi m b)
-&gt; (forall a b.
    QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b)
-&gt; (forall a. a -&gt; QuoteToQuasi m a)
-&gt; Monad (QuoteToQuasi m)
forall a. a -&gt; QuoteToQuasi m a
forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
forall a b.
QuoteToQuasi m a -&gt; (a -&gt; QuoteToQuasi m b) -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *). Monad m =&gt; Applicative (QuoteToQuasi m)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; QuoteToQuasi m a
forall (m :: * -&gt; *) a b.
Monad m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *) a b.
Monad m =&gt;
QuoteToQuasi m a -&gt; (a -&gt; QuoteToQuasi m b) -&gt; QuoteToQuasi m b
forall (m :: * -&gt; *).
Applicative m =&gt;
(forall a b. m a -&gt; (a -&gt; m b) -&gt; m b)
-&gt; (forall a b. m a -&gt; m b -&gt; m b)
-&gt; (forall a. a -&gt; m a)
-&gt; Monad m
$c&gt;&gt;= :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
QuoteToQuasi m a -&gt; (a -&gt; QuoteToQuasi m b) -&gt; QuoteToQuasi m b
&gt;&gt;= :: forall a b.
QuoteToQuasi m a -&gt; (a -&gt; QuoteToQuasi m b) -&gt; QuoteToQuasi m b
$c&gt;&gt; :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
&gt;&gt; :: forall a b.
QuoteToQuasi m a -&gt; QuoteToQuasi m b -&gt; QuoteToQuasi m b
$creturn :: forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; QuoteToQuasi m a
return :: forall a. a -&gt; QuoteToQuasi m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Monad</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span id="local-6989586621679039487"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-type">qtqError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039487"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-409"></span><span id="qtqError"><span class="annot"><span class="annottext">qtqError :: forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var hs-var">qtqError</span></a></span></span><span> </span><span id="local-6989586621679039726"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679039726"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; a) -&gt; String -&gt; a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;`unsafeQToQuote` does not support code that uses &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679039726"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679039499"><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039499"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fail.MonadFail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#QuoteToQuasi"><span class="hs-identifier hs-type">QuoteToQuasi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039499"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-412"></span><span>  </span><span id="local-6989586621679039734"><span class="annot"><span class="annottext">fail :: forall a. String -&gt; QuoteToQuasi m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">fail</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; QuoteToQuasi m a
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;MonadFail.fail&quot;</span></span><span>
</span><span id="line-413"></span><span>
</span><span id="line-414"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679039505"><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039505"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#QuoteToQuasi"><span class="hs-identifier hs-type">QuoteToQuasi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039505"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-415"></span><span>  </span><span id="local-6989586621679039741"><span class="annot"><span class="annottext">liftIO :: forall a. IO a -&gt; QuoteToQuasi m a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">liftIO</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; IO a -&gt; QuoteToQuasi m a
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;liftIO&quot;</span></span><span>
</span><span id="line-416"></span><span>
</span><span id="line-417"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679039426"><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039426"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quasi</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#QuoteToQuasi"><span class="hs-identifier hs-type">QuoteToQuasi</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039426"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-418"></span><span>  </span><span id="local-6989586621679039778"><span class="annot"><span class="annottext">qNewName :: String -&gt; QuoteToQuasi m Name
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">qNewName</span></span></span><span> </span><span id="local-6989586621679039779"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679039779"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Name -&gt; QuoteToQuasi m Name
forall (m :: * -&gt; *) a. m a -&gt; QuoteToQuasi m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#QTQ"><span class="hs-identifier hs-var">QTQ</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; m Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679039779"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span>  </span><span id="local-6989586621679039780"><span class="annot"><span class="annottext">qRecover :: forall a. QuoteToQuasi m a -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m a
</span><a href="#local-6989586621679039780"><span class="hs-identifier hs-var hs-var hs-var hs-var">qRecover</span></a></span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m a -&gt; QuoteToQuasi m a
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qRecover&quot;</span></span><span>
</span><span id="line-421"></span><span>  </span><span id="local-6989586621679039782"><span class="annot"><span class="annottext">qReport :: Bool -&gt; String -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039782"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReport</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; String -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReport&quot;</span></span><span>
</span><span id="line-422"></span><span>  </span><span id="local-6989586621679039784"><span class="annot"><span class="annottext">qReify :: Name -&gt; QuoteToQuasi m Info
</span><a href="#local-6989586621679039784"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReify</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; QuoteToQuasi m Info
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReify&quot;</span></span><span>
</span><span id="line-423"></span><span>  </span><span id="local-6989586621679039786"><span class="annot"><span class="annottext">qLocation :: QuoteToQuasi m Loc
</span><a href="#local-6989586621679039786"><span class="hs-identifier hs-var hs-var hs-var hs-var">qLocation</span></a></span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; QuoteToQuasi m Loc
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qLocation&quot;</span></span><span>
</span><span id="line-424"></span><span>  </span><span id="local-6989586621679039788"><span class="annot"><span class="annottext">qRunIO :: forall a. IO a -&gt; QuoteToQuasi m a
</span><a href="#local-6989586621679039788"><span class="hs-identifier hs-var hs-var hs-var hs-var">qRunIO</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; IO a -&gt; QuoteToQuasi m a
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qRunIO&quot;</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,7,0)
</span><span>  </span><span id="local-6989586621679039790"><span class="annot"><span class="annottext">qReifyInstances :: Name -&gt; [Type] -&gt; QuoteToQuasi m [Dec]
</span><a href="#local-6989586621679039790"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyInstances</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; [Type] -&gt; QuoteToQuasi m [Dec]
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyInstances&quot;</span></span><span>
</span><span id="line-427"></span><span>  </span><span id="local-6989586621679039792"><span class="annot"><span class="annottext">qLookupName :: Bool -&gt; String -&gt; QuoteToQuasi m (Maybe Name)
</span><a href="#local-6989586621679039792"><span class="hs-identifier hs-var hs-var hs-var hs-var">qLookupName</span></a></span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; String -&gt; QuoteToQuasi m (Maybe Name)
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qLookupName&quot;</span></span><span>
</span><span id="line-428"></span><span>  </span><span id="local-6989586621679039794"><span class="annot"><span class="annottext">qAddDependentFile :: String -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039794"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddDependentFile</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddDependentFile&quot;</span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,9,0)
</span><span>  </span><span id="local-6989586621679039796"><span class="annot"><span class="annottext">qReifyRoles :: Name -&gt; QuoteToQuasi m [Role]
</span><a href="#local-6989586621679039796"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyRoles</span></a></span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; QuoteToQuasi m [Role]
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyRoles&quot;</span></span><span>
</span><span id="line-431"></span><span>  </span><span id="local-6989586621679039799"><span class="annot"><span class="annottext">qReifyAnnotations :: forall a. Data a =&gt; AnnLookup -&gt; QuoteToQuasi m [a]
</span><a href="#local-6989586621679039799"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyAnnotations</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; AnnLookup -&gt; QuoteToQuasi m [a]
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyAnnotations&quot;</span></span><span>
</span><span id="line-432"></span><span>  </span><span id="local-6989586621679039801"><span class="annot"><span class="annottext">qReifyModule :: Module -&gt; QuoteToQuasi m ModuleInfo
</span><a href="#local-6989586621679039801"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyModule</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Module -&gt; QuoteToQuasi m ModuleInfo
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyModule&quot;</span></span><span>
</span><span id="line-433"></span><span>  </span><span id="local-6989586621679039803"><span class="annot"><span class="annottext">qAddTopDecls :: [Dec] -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039803"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddTopDecls</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; [Dec] -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddTopDecls&quot;</span></span><span>
</span><span id="line-434"></span><span>  </span><span id="local-6989586621679039805"><span class="annot"><span class="annottext">qAddModFinalizer :: Q () -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039805"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddModFinalizer</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q () -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddModFinalizer&quot;</span></span><span>
</span><span id="line-435"></span><span>  </span><span id="local-6989586621679039808"><span class="annot"><span class="annottext">qGetQ :: forall a. Typeable a =&gt; QuoteToQuasi m (Maybe a)
</span><a href="#local-6989586621679039808"><span class="hs-identifier hs-var hs-var hs-var hs-var">qGetQ</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; QuoteToQuasi m (Maybe a)
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qGetQ&quot;</span></span><span>
</span><span id="line-436"></span><span>  </span><span id="local-6989586621679039811"><span class="annot"><span class="annottext">qPutQ :: forall a. Typeable a =&gt; a -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039811"><span class="hs-identifier hs-var hs-var hs-var hs-var">qPutQ</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qPutQ&quot;</span></span><span class="hs-cpp">
# endif
</span><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,11,0)
</span><span>  </span><span id="local-6989586621679039813"><span class="annot"><span class="annottext">qReifyFixity :: Name -&gt; QuoteToQuasi m (Maybe Fixity)
</span><a href="#local-6989586621679039813"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyFixity</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; QuoteToQuasi m (Maybe Fixity)
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyFixity&quot;</span></span><span>
</span><span id="line-440"></span><span>  </span><span id="local-6989586621679039815"><span class="annot"><span class="annottext">qReifyConStrictness :: Name -&gt; QuoteToQuasi m [DecidedStrictness]
</span><a href="#local-6989586621679039815"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyConStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; QuoteToQuasi m [DecidedStrictness]
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyConStrictness&quot;</span></span><span>
</span><span id="line-441"></span><span>  </span><span id="local-6989586621679039817"><span class="annot"><span class="annottext">qIsExtEnabled :: Extension -&gt; QuoteToQuasi m Bool
</span><a href="#local-6989586621679039817"><span class="hs-identifier hs-var hs-var hs-var hs-var">qIsExtEnabled</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Extension -&gt; QuoteToQuasi m Bool
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qIsExtEnabled&quot;</span></span><span>
</span><span id="line-442"></span><span>  </span><span id="local-6989586621679039819"><span class="annot"><span class="annottext">qExtsEnabled :: QuoteToQuasi m [Extension]
</span><a href="#local-6989586621679039819"><span class="hs-identifier hs-var hs-var hs-var hs-var">qExtsEnabled</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; QuoteToQuasi m [Extension]
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qExtsEnabled&quot;</span></span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,5,0)
</span><span>  </span><span class="hs-identifier">qClassInstances</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">qtqError</span><span> </span><span class="hs-string">&quot;qClassInstances&quot;</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,13,0)
</span><span>  </span><span id="local-6989586621679039821"><span class="annot"><span class="annottext">qAddCorePlugin :: String -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039821"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddCorePlugin</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddCorePlugin&quot;</span></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,14,0)
</span><span>  </span><span id="local-6989586621679039823"><span class="annot"><span class="annottext">qAddForeignFilePath :: ForeignSrcLang -&gt; String -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039823"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddForeignFilePath</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; ForeignSrcLang -&gt; String -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddForeignFilePath&quot;</span></span><span>
</span><span id="line-452"></span><span>  </span><span id="local-6989586621679039825"><span class="annot"><span class="annottext">qAddTempFile :: String -&gt; QuoteToQuasi m String
</span><a href="#local-6989586621679039825"><span class="hs-identifier hs-var hs-var hs-var hs-var">qAddTempFile</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; QuoteToQuasi m String
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qAddTempFile&quot;</span></span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,12,0)
</span><span>  </span><span class="hs-identifier">qAddForeignFile</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">qtqError</span><span> </span><span class="hs-string">&quot;qAddForeignFile&quot;</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span id="local-6989586621679039827"><span class="annot"><span class="annottext">qReifyType :: Name -&gt; QuoteToQuasi m Type
</span><a href="#local-6989586621679039827"><span class="hs-identifier hs-var hs-var hs-var hs-var">qReifyType</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Name -&gt; QuoteToQuasi m Type
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qReifyType&quot;</span></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,18,0)
</span><span>  </span><span id="local-6989586621679039829"><span class="annot"><span class="annottext">qGetDoc :: DocLoc -&gt; QuoteToQuasi m (Maybe String)
</span><a href="#local-6989586621679039829"><span class="hs-identifier hs-var hs-var hs-var hs-var">qGetDoc</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; DocLoc -&gt; QuoteToQuasi m (Maybe String)
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qGetDoc&quot;</span></span><span>
</span><span id="line-461"></span><span>  </span><span id="local-6989586621679039831"><span class="annot"><span class="annottext">qPutDoc :: DocLoc -&gt; String -&gt; QuoteToQuasi m ()
</span><a href="#local-6989586621679039831"><span class="hs-identifier hs-var hs-var hs-var hs-var">qPutDoc</span></a></span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; DocLoc -&gt; String -&gt; QuoteToQuasi m ()
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qPutDoc&quot;</span></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,19,0)
</span><span>  </span><span id="local-6989586621679039833"><span class="annot"><span class="annottext">qGetPackageRoot :: QuoteToQuasi m String
</span><a href="#local-6989586621679039833"><span class="hs-identifier hs-var hs-var hs-var hs-var">qGetPackageRoot</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; QuoteToQuasi m String
forall a. String -&gt; a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#qtqError"><span class="hs-identifier hs-var">qtqError</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qGetPackageRoot&quot;</span></span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-467"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-468"></span><span class="hs-comment">-- Code</span><span>
</span><span id="line-469"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-470"></span><span>
</span><span id="line-471"></span><span class="hs-comment">-- $code</span><span>
</span><span id="line-472"></span><span class="hs-comment">-- The 'Code' type (first proposed in</span><span>
</span><span id="line-473"></span><span class="hs-comment">-- &lt;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0195-code-texp.rst GHC Proposal 195&gt;)</span><span>
</span><span id="line-474"></span><span class="hs-comment">-- was introduced in @template-haskell-2.17.0.0@. This module defines a version</span><span>
</span><span id="line-475"></span><span class="hs-comment">-- of 'Code' that is backward-compatible with older @template-haskell@</span><span>
</span><span id="line-476"></span><span class="hs-comment">-- releases and is forward-compatible with the existing 'Code' class.</span><span>
</span><span id="line-477"></span><span class="hs-comment">-- In addition to 'Code', this module also backports the functions in</span><span>
</span><span id="line-478"></span><span class="hs-comment">-- &quot;Language.Haskell.TH.Syntax&quot; that manipulate 'Code' values.</span><span>
</span><span id="line-479"></span><span class="hs-comment">--</span><span>
</span><span id="line-480"></span><span class="hs-comment">-- One troublesome aspect of writing backwards-compatible code involving 'Code'</span><span>
</span><span id="line-481"></span><span class="hs-comment">-- is that GHC 9.0 changed the types of typed Template Haskell splices. Before,</span><span>
</span><span id="line-482"></span><span class="hs-comment">-- they were of type @'Q' ('TExp' a)@, but they are now of type @'Code' 'Q' a@.</span><span>
</span><span id="line-483"></span><span class="hs-comment">-- This modules provides two mechanisms for smoothing over the differences</span><span>
</span><span id="line-484"></span><span class="hs-comment">-- between these two types:</span><span>
</span><span id="line-485"></span><span class="hs-comment">--</span><span>
</span><span id="line-486"></span><span class="hs-comment">-- * The 'IsCode' class can be used to convert 'Code' or 'TExp' values to</span><span>
</span><span id="line-487"></span><span class="hs-comment">--   'Code', and vice versa.</span><span>
</span><span id="line-488"></span><span class="hs-comment">--</span><span>
</span><span id="line-489"></span><span class="hs-comment">-- * The 'Splice' type synonym uses CPP so that @'Splice' q a@ is a synonym for</span><span>
</span><span id="line-490"></span><span class="hs-comment">--   @'Code' q a@ on GHC 9.0 or later and @q ('TExp' a)@ on older versions of</span><span>
</span><span id="line-491"></span><span class="hs-comment">--   GHC. This module also defines versions of 'Code'- and 'TExp'-related</span><span>
</span><span id="line-492"></span><span class="hs-comment">--   combinators that work over 'Splice'.</span><span>
</span><span id="line-493"></span><span class="hs-comment">--</span><span>
</span><span id="line-494"></span><span class="hs-comment">-- Refer to the Haddocks for 'IsCode' and 'Splice' for more information on each</span><span>
</span><span id="line-495"></span><span class="hs-comment">-- approach. Both approaches have pros and cons, and as a result, neither</span><span>
</span><span id="line-496"></span><span class="hs-comment">-- approach is a one-size-fits-all solution.</span><span>
</span><span id="line-497"></span><span class="hs-comment">--</span><span>
</span><span id="line-498"></span><span class="hs-comment">-- Because 'Code' interacts with typed Template Haskell, the 'Code' type and</span><span>
</span><span id="line-499"></span><span class="hs-comment">-- any function that mentions 'Code' in its type are only defined on</span><span>
</span><span id="line-500"></span><span class="hs-comment">-- @template-haskell-2.9.0.0@ (GHC 7.8) or later.</span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,9,0)
</span><span class="hs-comment">-- | A class that allows one to smooth over the differences between</span><span>
</span><span id="line-504"></span><span class="hs-comment">-- @'Code' 'm' a@ (the type of typed Template Haskell quotations on</span><span>
</span><span id="line-505"></span><span class="hs-comment">-- @template-haskell-2.17.0.0@ or later) and @'m' ('TExp' a)@ (the type of</span><span>
</span><span id="line-506"></span><span class="hs-comment">-- typed Template Haskell quotations on older versions of @template-haskell@).</span><span>
</span><span id="line-507"></span><span class="hs-comment">-- Here are two examples that demonstrate how to use each method of 'IsCode':</span><span>
</span><span id="line-508"></span><span class="hs-comment">--</span><span>
</span><span id="line-509"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-510"></span><span class="hs-comment">-- &amp;#123;-&amp;#35; LANGUAGE TemplateHaskell &amp;#35;-&amp;#125;</span><span>
</span><span id="line-511"></span><span class="hs-comment">--</span><span>
</span><span id="line-512"></span><span class="hs-comment">-- import &quot;Language.Haskell.TH&quot;</span><span>
</span><span id="line-513"></span><span class="hs-comment">-- import &quot;Language.Haskell.TH.Syntax.Compat&quot;</span><span>
</span><span id="line-514"></span><span class="hs-comment">--</span><span>
</span><span id="line-515"></span><span class="hs-comment">-- -- 'toCode' will ensure that the end result is a 'Code', regardless of</span><span>
</span><span id="line-516"></span><span class="hs-comment">-- -- whether the quote itself returns a 'Code' or a 'TExp'.</span><span>
</span><span id="line-517"></span><span class="hs-comment">-- myCode :: 'Code' 'Q' Int</span><span>
</span><span id="line-518"></span><span class="hs-comment">-- myCode = 'toCode' [|| 42 ||]</span><span>
</span><span id="line-519"></span><span class="hs-comment">--</span><span>
</span><span id="line-520"></span><span class="hs-comment">-- -- 'fromCode' will ensure that the input 'Code' is suitable for splicing</span><span>
</span><span id="line-521"></span><span class="hs-comment">-- -- (i.e., it will return a 'Code' or a 'TExp' depending on the</span><span>
</span><span id="line-522"></span><span class="hs-comment">-- -- @template-haskell@ version in use).</span><span>
</span><span id="line-523"></span><span class="hs-comment">-- fortyTwo :: Int</span><span>
</span><span id="line-524"></span><span class="hs-comment">-- fortyTwo = $$('fromCode' myCode)</span><span>
</span><span id="line-525"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-526"></span><span class="hs-comment">--</span><span>
</span><span id="line-527"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-528"></span><span class="hs-keyword">class</span><span> </span><span id="IsCode"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#IsCode"><span class="hs-identifier hs-var">IsCode</span></a></span></span><span> </span><span id="local-6989586621679039535"><span id="local-6989586621679039537"><span class="annot"><a href="#local-6989586621679039537"><span class="hs-identifier hs-type">q</span></a></span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>             </span><span class="hs-special">(</span><span id="local-6989586621679039538"><span class="annot"><a href="#local-6989586621679039538"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039535"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# else
</span><span>             </span><span class="hs-identifier">a</span><span class="hs-cpp">
# endif
</span><span>             </span><span id="local-6989586621679039536"><span class="annot"><a href="#local-6989586621679039536"><span class="hs-identifier hs-type">c</span></a></span></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="#local-6989586621679039536"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039538"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039537"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-535"></span><span>  </span><span class="hs-comment">-- | Convert something to a 'Code'.</span><span>
</span><span id="line-536"></span><span>  </span><span id="toCode"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#toCode"><span class="hs-identifier hs-type">toCode</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679039536"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Code</span></span><span> </span><span class="annot"><a href="#local-6989586621679039537"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039538"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-537"></span><span>  </span><span class="hs-comment">-- | Convert to something from a 'Code'.</span><span>
</span><span id="line-538"></span><span>  </span><span id="fromCode"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#fromCode"><span class="hs-identifier hs-type">fromCode</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Code</span></span><span> </span><span class="annot"><a href="#local-6989586621679039537"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039538"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039536"><span class="hs-identifier hs-type">c</span></a></span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span class="annot"><span class="hs-comment">-- | Levity-polymorphic since /template-haskell-2.16.0.0/.</span></span><span>
</span><span id="line-541"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679039539"><span id="local-6989586621679039540"><span id="local-6989586621679039541"><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039540"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#IsCode"><span class="hs-identifier hs-type">IsCode</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039540"><span class="hs-identifier hs-type">q</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>                           </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679039541"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039539"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# else
</span><span>                           </span><span class="hs-identifier">a</span><span class="hs-cpp">
# endif
</span><span>                           </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Code</span></span><span> </span><span class="annot"><a href="#local-6989586621679039540"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039541"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-548"></span><span>  </span><span id="local-6989586621679039842"><span class="annot"><span class="annottext">toCode :: Code q a -&gt; Code q a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#toCode"><span class="hs-identifier hs-var hs-var hs-var hs-var">toCode</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code q a -&gt; Code q a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-549"></span><span>  </span><span id="local-6989586621679039844"><span class="annot"><span class="annottext">fromCode :: Code q a -&gt; Code q a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#fromCode"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromCode</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code q a -&gt; Code q a
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-550"></span><span>
</span><span id="line-551"></span><span class="annot"><span class="hs-comment">-- | Levity-polymorphic since /template-haskell-2.16.0.0/.</span></span><span>
</span><span id="line-552"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679039546"><span id="local-6989586621679039547"><span id="local-6989586621679039548"><span class="annot"><a href="#local-6989586621679039547"><span class="hs-identifier hs-type">texp</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039548"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#IsCode"><span class="hs-identifier hs-type">IsCode</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>                                        </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679039548"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039546"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# else
</span><span>                                        </span><span class="hs-identifier">a</span><span class="hs-cpp">
# endif
</span><span>                                        </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679039547"><span class="hs-identifier hs-type">texp</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-559"></span><span>  </span><span id="local-6989586621679039850"><span class="annot"><span class="annottext">toCode :: Q texp -&gt; Code Q a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#toCode"><span class="hs-identifier hs-var hs-var hs-var hs-var">toCode</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q texp -&gt; Code Q a
Q (TExp a) -&gt; Code Q a
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><span class="hs-identifier hs-var">liftCode</span></span><span>
</span><span id="line-560"></span><span>  </span><span id="local-6989586621679039851"><span class="annot"><span class="annottext">fromCode :: Code Q a -&gt; Q texp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#fromCode"><span class="hs-identifier hs-var hs-var hs-var hs-var">fromCode</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code Q a -&gt; Q texp
Code Q a -&gt; Q (TExp a)
forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><span class="hs-identifier hs-var">examineCode</span></span><span>
</span><span id="line-561"></span><span>
</span><span id="line-562"></span><span class="hs-comment">-- $isCodeLimitations</span><span>
</span><span id="line-563"></span><span class="hs-comment">-- 'IsCode' makes it possible to backport code involving typed Template Haskell</span><span>
</span><span id="line-564"></span><span class="hs-comment">-- quotations and splices where the types are monomorphized to 'Q'. GHC 9.0</span><span>
</span><span id="line-565"></span><span class="hs-comment">-- and later, however, make it possible to use typed TH quotations and splices</span><span>
</span><span id="line-566"></span><span class="hs-comment">-- that are polymorphic over any 'Quote' instance. Unfortunately, the</span><span>
</span><span id="line-567"></span><span class="hs-comment">-- @th-compat@ library does not yet have a good story for backporting</span><span>
</span><span id="line-568"></span><span class="hs-comment">-- 'Quote'-polymorphic quotations or splices. For example, consider this code:</span><span>
</span><span id="line-569"></span><span class="hs-comment">--</span><span>
</span><span id="line-570"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-571"></span><span class="hs-comment">-- instance ('Syntax.Lift' a, 'Quote' q, 'Num' a) =&gt; 'Num' ('Code' q a) where</span><span>
</span><span id="line-572"></span><span class="hs-comment">--   -- ...</span><span>
</span><span id="line-573"></span><span class="hs-comment">--   x + y = [|| $$x + $$y ||]</span><span>
</span><span id="line-574"></span><span class="hs-comment">--   -- ...</span><span>
</span><span id="line-575"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-576"></span><span class="hs-comment">--</span><span>
</span><span id="line-577"></span><span class="hs-comment">-- How might we backport this code? If we were in a setting where @q@ were</span><span>
</span><span id="line-578"></span><span class="hs-comment">-- monomorphized to 'Q', we could simply write this:</span><span>
</span><span id="line-579"></span><span class="hs-comment">--</span><span>
</span><span id="line-580"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-581"></span><span class="hs-comment">--   x + y = 'toCode' [|| $$('fromCode' x) + $$('fromCode' y) ||]</span><span>
</span><span id="line-582"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-583"></span><span class="hs-comment">--</span><span>
</span><span id="line-584"></span><span class="hs-comment">-- In a 'Quote'-polymorphic setting, however, we run into issues. While this</span><span>
</span><span id="line-585"></span><span class="hs-comment">-- will compile on GHC 9.0 or later, it will not compile on earlier GHC</span><span>
</span><span id="line-586"></span><span class="hs-comment">-- versions because all typed TH quotations and splices must use 'Q'. At</span><span>
</span><span id="line-587"></span><span class="hs-comment">-- present, the @th-compat@ library does not offer any solution to this</span><span>
</span><span id="line-588"></span><span class="hs-comment">-- problem.</span><span>
</span><span id="line-589"></span><span>
</span><span id="line-590"></span><span class="annot"><span class="hs-comment">-- | Levity-polymorphic since /template-haskell-2.16.0.0/.</span></span><span class="hs-cpp">
# if !(MIN_VERSION_template_haskell(2,17,0))
</span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">role</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">representational</span><span> </span><span class="hs-identifier">nominal</span><span>
</span><span id="line-593"></span><span class="hs-keyword">newtype</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>             </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#  else
</span><span>             </span><span class="hs-identifier">a</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span>
</span><span id="line-600"></span><span>  </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">examineCode</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Underlying monadic value</span><span>
</span><span id="line-601"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-602"></span><span>
</span><span id="line-603"></span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">CodeQ</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">Q</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>                    </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator">*</span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-608"></span><span class="hs-comment">-- | Unsafely convert an untyped code representation into a typed code</span><span>
</span><span id="line-609"></span><span class="hs-comment">-- representation.</span><span>
</span><span id="line-610"></span><span class="hs-comment">--</span><span>
</span><span id="line-611"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-612"></span><span class="hs-identifier">unsafeCodeCoerce</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Quote</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">Exp</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-619"></span><span class="hs-identifier">unsafeCodeCoerce</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">unsafeTExpCoerceQuote</span><span> </span><span class="hs-identifier">m</span><span class="hs-special">)</span><span>
</span><span id="line-620"></span><span>
</span><span id="line-621"></span><span class="hs-comment">-- | Lift a monadic action producing code into the typed 'Code'</span><span>
</span><span id="line-622"></span><span class="hs-comment">-- representation</span><span>
</span><span id="line-623"></span><span class="hs-comment">--</span><span>
</span><span id="line-624"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-625"></span><span class="hs-identifier">liftCode</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-632"></span><span class="hs-identifier">liftCode</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span>
</span><span id="line-633"></span><span>
</span><span id="line-634"></span><span class="hs-comment">-- | Extract the untyped representation from the typed representation</span><span>
</span><span id="line-635"></span><span class="hs-comment">--</span><span>
</span><span id="line-636"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-637"></span><span class="hs-identifier">unTypeCode</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Quote</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">Exp</span><span>
</span><span id="line-644"></span><span class="hs-identifier">unTypeCode</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unTypeQQuote</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">examineCode</span><span>
</span><span id="line-645"></span><span>
</span><span id="line-646"></span><span class="hs-comment">-- | Modify the ambient monad used during code generation. For example, you</span><span>
</span><span id="line-647"></span><span class="hs-comment">-- can use `hoistCode` to handle a state effect:</span><span>
</span><span id="line-648"></span><span class="hs-comment">--</span><span>
</span><span id="line-649"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-650"></span><span class="hs-comment">--  handleState :: Code (StateT Int Q) a -&gt; Code Q a</span><span>
</span><span id="line-651"></span><span class="hs-comment">--  handleState = hoistCode (flip runState 0)</span><span>
</span><span id="line-652"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-653"></span><span class="hs-comment">--</span><span>
</span><span id="line-654"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-655"></span><span class="hs-identifier">hoistCode</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-662"></span><span class="hs-identifier">hoistCode</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span>
</span><span id="line-663"></span><span>
</span><span id="line-664"></span><span>
</span><span id="line-665"></span><span class="hs-comment">-- | Variant of (&gt;&gt;=) which allows effectful computations to be injected</span><span>
</span><span id="line-666"></span><span class="hs-comment">-- into code generation.</span><span>
</span><span id="line-667"></span><span class="hs-comment">--</span><span>
</span><span id="line-668"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-669"></span><span class="hs-identifier">bindCode</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">b</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">b</span><span>
</span><span id="line-676"></span><span class="hs-identifier">bindCode</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">liftCode</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">q</span><span> </span><span class="hs-operator">&gt;&gt;=</span><span> </span><span class="hs-identifier">examineCode</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>
</span><span id="line-677"></span><span>
</span><span id="line-678"></span><span class="hs-comment">-- | Variant of (&gt;&gt;) which allows effectful computations to be injected</span><span>
</span><span id="line-679"></span><span class="hs-comment">-- into code generation.</span><span>
</span><span id="line-680"></span><span class="hs-comment">--</span><span>
</span><span id="line-681"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-682"></span><span class="hs-identifier">bindCode_</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">b</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">b</span><span>
</span><span id="line-689"></span><span class="hs-identifier">bindCode_</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">liftCode</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-operator">&gt;&gt;</span><span> </span><span class="hs-identifier">examineCode</span><span> </span><span class="hs-identifier">c</span><span class="hs-special">)</span><span>
</span><span id="line-690"></span><span>
</span><span id="line-691"></span><span class="hs-comment">-- | A useful combinator for embedding monadic actions into 'Code'</span><span>
</span><span id="line-692"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-693"></span><span class="hs-comment">-- myCode :: ... =&gt; Code m a</span><span>
</span><span id="line-694"></span><span class="hs-comment">-- myCode = joinCode $ do</span><span>
</span><span id="line-695"></span><span class="hs-comment">--   x &lt;- someSideEffect</span><span>
</span><span id="line-696"></span><span class="hs-comment">--   return (makeCodeWith x)</span><span>
</span><span id="line-697"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-698"></span><span class="hs-comment">--</span><span>
</span><span id="line-699"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-700"></span><span class="hs-identifier">joinCode</span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">RuntimeRep</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="hs-identifier">Monad</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span>
</span><span id="line-707"></span><span class="hs-identifier">joinCode</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">flip</span><span> </span><span class="hs-identifier">bindCode</span><span> </span><span class="hs-identifier">id</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-710"></span><span class="hs-comment">-- $splice</span><span>
</span><span id="line-711"></span><span class="hs-comment">--</span><span>
</span><span id="line-712"></span><span class="hs-comment">-- This section of code is useful for library authors looking to provide</span><span>
</span><span id="line-713"></span><span class="hs-comment">-- a typed @TemplateHaskell@ interface that is backwards- and</span><span>
</span><span id="line-714"></span><span class="hs-comment">-- forward-compatible. This section may be useful for you if you</span><span>
</span><span id="line-715"></span><span class="hs-comment">-- specifically intend for the splice to be done directly.</span><span>
</span><span id="line-716"></span><span class="hs-comment">--</span><span>
</span><span id="line-717"></span><span class="hs-comment">-- Prior to GHC 9, you'd offer a value with type @'Q' ('Syntax.TExp' a)@.</span><span>
</span><span id="line-718"></span><span class="hs-comment">-- After GHC 9, these values are no longer acceptable in a typed splice:</span><span>
</span><span id="line-719"></span><span class="hs-comment">-- typed splices must operate in @Code m a@ instead.</span><span>
</span><span id="line-720"></span><span class="hs-comment">--</span><span>
</span><span id="line-721"></span><span class="hs-comment">-- The @'Splice' m a@ type is used to work with both versions - it is a type</span><span>
</span><span id="line-722"></span><span class="hs-comment">-- alias, and depending on the version of @template-haskell@ that was</span><span>
</span><span id="line-723"></span><span class="hs-comment">-- compiled, it will either be @'Code' m a@ or @m ('Syntax.TExp' a)@.</span><span>
</span><span id="line-724"></span><span class="hs-comment">--</span><span>
</span><span id="line-725"></span><span class="hs-comment">-- The function 'liftSplice' can be used to convert a @'Q' ('Syntax.TExp' a)@</span><span>
</span><span id="line-726"></span><span class="hs-comment">-- expression into a @'Code' 'Q' a@ expression in a compatible manner - by</span><span>
</span><span id="line-727"></span><span class="hs-comment">-- lifting to 'SpliceQ', you get the right behavior depending on your</span><span>
</span><span id="line-728"></span><span class="hs-comment">-- @template-haskell@ version.</span><span>
</span><span id="line-729"></span><span class="hs-comment">--</span><span>
</span><span id="line-730"></span><span class="hs-comment">-- The function 'examineSplice' can be used on typed QuasiQuoters, and the</span><span>
</span><span id="line-731"></span><span class="hs-comment">-- result will be converted into an appropriate @m ('Syntax.TExp' a)@. This</span><span>
</span><span id="line-732"></span><span class="hs-comment">-- allows you to use typed quasiquoters in a @do@ block, much like</span><span>
</span><span id="line-733"></span><span class="hs-comment">-- 'examineCode' does with 'Code'.</span><span>
</span><span id="line-734"></span><span class="hs-comment">--</span><span>
</span><span id="line-735"></span><span class="hs-comment">-- With 'expToSplice', you can substitute uses of 'pure' when given the</span><span>
</span><span id="line-736"></span><span class="hs-comment">-- specific type:</span><span>
</span><span id="line-737"></span><span class="hs-comment">--</span><span>
</span><span id="line-738"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-739"></span><span class="hs-comment">-- pureTExp :: 'Syntax.TExp' a -&gt; 'Q' ('Syntax.TExp' a)</span><span>
</span><span id="line-740"></span><span class="hs-comment">-- pureTExp = pure</span><span>
</span><span id="line-741"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-742"></span><span class="hs-comment">--</span><span>
</span><span id="line-743"></span><span class="hs-comment">-- This allows you to splice @'Syntax.TExp' a@ values directly into a typed</span><span>
</span><span id="line-744"></span><span class="hs-comment">-- quasiquoter.</span><span>
</span><span id="line-745"></span><span>
</span><span id="line-746"></span><span class="hs-comment">-- | @'Splice' m a@ is a type alias for:</span><span>
</span><span id="line-747"></span><span class="hs-comment">--</span><span>
</span><span id="line-748"></span><span class="hs-comment">-- * @'Code' m a@, if using @template-haskell-2.17.0.0@ or later, or</span><span>
</span><span id="line-749"></span><span class="hs-comment">--</span><span>
</span><span id="line-750"></span><span class="hs-comment">-- * @m ('Syntax.TExp' a)@, if using an older version of @template-haskell@.</span><span>
</span><span id="line-751"></span><span class="hs-comment">--</span><span>
</span><span id="line-752"></span><span class="hs-comment">-- This should be used with caution, as its definition differs depending on</span><span>
</span><span id="line-753"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. It is mostly useful for</span><span>
</span><span id="line-754"></span><span class="hs-comment">-- contexts in which one is writing a definition that is intended to be used</span><span>
</span><span id="line-755"></span><span class="hs-comment">-- directly in a typed Template Haskell splice, as the types of TH splices</span><span>
</span><span id="line-756"></span><span class="hs-comment">-- differ between @template-haskell@ versions as well.</span><span>
</span><span id="line-757"></span><span class="hs-comment">--</span><span>
</span><span id="line-758"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,22,0)
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">Splice</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Code</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator">*</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator">*</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">r</span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator">*</span><span class="hs-special">)</span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,17,0)
</span><span class="hs-keyword">type</span><span> </span><span id="Splice"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-var">Splice</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Code</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039854"><span class="annot"><a href="#local-6989586621679039854"><span class="hs-identifier hs-type">r</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039854"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span class="hs-special">)</span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,16,0)
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">Splice</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span class="hs-cpp">
# else
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">Splice</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Syntax.TExp</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-769"></span><span class="hs-comment">-- | @'SpliceQ' a@ is a type alias for:</span><span>
</span><span id="line-770"></span><span class="hs-comment">--</span><span>
</span><span id="line-771"></span><span class="hs-comment">-- * @'Code' 'Q' a@, if using @template-haskell-2.17.0.0@ or later, or</span><span>
</span><span id="line-772"></span><span class="hs-comment">--</span><span>
</span><span id="line-773"></span><span class="hs-comment">-- * @'Q' ('Syntax.TExp' a)@, if using an older version of @template-haskell@.</span><span>
</span><span id="line-774"></span><span class="hs-comment">--</span><span>
</span><span id="line-775"></span><span class="hs-comment">-- This should be used with caution, as its definition differs depending on</span><span>
</span><span id="line-776"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. It is mostly useful for</span><span>
</span><span id="line-777"></span><span class="hs-comment">-- contexts in which one is writing a definition that is intended to be used</span><span>
</span><span id="line-778"></span><span class="hs-comment">-- directly in a typed Template Haskell splice, as the types of TH splices</span><span>
</span><span id="line-779"></span><span class="hs-comment">-- differ between @template-haskell@ versions as well.</span><span>
</span><span id="line-780"></span><span class="hs-comment">--</span><span>
</span><span id="line-781"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span class="hs-keyword">type</span><span> </span><span id="SpliceQ"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#SpliceQ"><span class="hs-identifier hs-var">SpliceQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span id="local-6989586621679039855"><span class="annot"><a href="#local-6989586621679039855"><span class="hs-identifier hs-type hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span class="hs-special">)</span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,16,0)
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">SpliceQ</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">TYPE</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Splice</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">a</span><span class="hs-cpp">
# else
</span><span class="hs-keyword">type</span><span> </span><span class="hs-identifier">SpliceQ</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Splice</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">a</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-790"></span><span class="hs-comment">-- | A variant of 'bindCode' that works over 'Splice's. Because this function</span><span>
</span><span id="line-791"></span><span class="hs-comment">-- uses 'Splice', the type of this function will be different depending on</span><span>
</span><span id="line-792"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. (See the Haddocks for</span><span>
</span><span id="line-793"></span><span class="hs-comment">-- 'Splice' for more information on this point.)</span><span>
</span><span id="line-794"></span><span class="hs-comment">--</span><span>
</span><span id="line-795"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-796"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice"><span class="hs-identifier hs-type">bindSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039556"><span class="annot"><a href="#local-6989586621679039556"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679039557"><span class="annot"><a href="#local-6989586621679039557"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039555"><span class="annot"><a href="#local-6989586621679039555"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039558"><span class="annot"><a href="#local-6989586621679039558"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039555"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039556"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039556"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039557"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679039557"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039556"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039558"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039556"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039558"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="bindSplice"><span class="annot"><span class="annottext">bindSplice :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; (a -&gt; Splice m b) -&gt; Splice m b
</span><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice"><span class="hs-identifier hs-var hs-var">bindSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; (a -&gt; Code m b) -&gt; Code m b
forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; (a -&gt; Splice m b) -&gt; Splice m b
</span><span class="hs-identifier hs-var">bindCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">bindSplice</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">liftSplice</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">q</span><span> </span><span class="hs-operator">&gt;&gt;=</span><span> </span><span class="hs-identifier">examineSplice</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-809"></span><span class="hs-comment">-- | A variant of 'bindCode_' that works over 'Splice's. Because this function</span><span>
</span><span id="line-810"></span><span class="hs-comment">-- uses 'Splice', the type of this function will be different depending on</span><span>
</span><span id="line-811"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. (See the Haddocks for</span><span>
</span><span id="line-812"></span><span class="hs-comment">-- 'Splice' for more information on this point.)</span><span>
</span><span id="line-813"></span><span class="hs-comment">--</span><span>
</span><span id="line-814"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-815"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice_"><span class="hs-identifier hs-type">bindSplice_</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039565"><span class="annot"><a href="#local-6989586621679039565"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679039566"><span class="annot"><a href="#local-6989586621679039566"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039564"><span class="annot"><a href="#local-6989586621679039564"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039567"><span class="annot"><a href="#local-6989586621679039567"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039564"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">b</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039565"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039565"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039566"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039565"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039567"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039565"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039567"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="bindSplice_"><span class="annot"><span class="annottext">bindSplice_ :: forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; Splice m b -&gt; Splice m b
</span><a href="Language.Haskell.TH.Syntax.Compat.html#bindSplice_"><span class="hs-identifier hs-var hs-var">bindSplice_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m a -&gt; Code m b -&gt; Code m b
forall (m :: * -&gt; *) a b.
Monad m =&gt;
m a -&gt; Splice m b -&gt; Splice m b
</span><span class="hs-identifier hs-var">bindCode_</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">bindSplice_</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">liftSplice</span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-identifier">q</span><span> </span><span class="hs-operator">&gt;&gt;</span><span> </span><span class="hs-identifier">examineSplice</span><span> </span><span class="hs-identifier">c</span><span class="hs-special">)</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-828"></span><span class="hs-comment">-- | Lift a @'Syntax.TExp' a@ into a 'Splice'. This is useful when splicing</span><span>
</span><span id="line-829"></span><span class="hs-comment">-- in the result of a computation into a typed QuasiQuoter.</span><span>
</span><span id="line-830"></span><span class="hs-comment">--</span><span>
</span><span id="line-831"></span><span class="hs-comment">-- One example is 'traverse'ing over a list of elements and returning an</span><span>
</span><span id="line-832"></span><span class="hs-comment">-- expression from each element.</span><span>
</span><span id="line-833"></span><span class="hs-comment">--</span><span>
</span><span id="line-834"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-835"></span><span class="hs-comment">-- mkInt :: 'String' -&gt; 'Q' ('Syntax.TExp' 'Int')</span><span>
</span><span id="line-836"></span><span class="hs-comment">-- mkInt str = [|| length $$str ||]</span><span>
</span><span id="line-837"></span><span class="hs-comment">--</span><span>
</span><span id="line-838"></span><span class="hs-comment">-- mkInts :: ['String'] -&gt; 'Q' ['Syntax.TExp' 'Int']</span><span>
</span><span id="line-839"></span><span class="hs-comment">-- mkInts = traverse mkInt</span><span>
</span><span id="line-840"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-841"></span><span class="hs-comment">--</span><span>
</span><span id="line-842"></span><span class="hs-comment">-- This gives us a list of 'Syntax.TExp', not a 'Syntax.TExp' of a list. We</span><span>
</span><span id="line-843"></span><span class="hs-comment">-- can push the list inside the type with this function:</span><span>
</span><span id="line-844"></span><span class="hs-comment">--</span><span>
</span><span id="line-845"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-846"></span><span class="hs-comment">-- listTE :: ['Syntax.TExp' a] -&gt; 'Syntax.TExp' [a]</span><span>
</span><span id="line-847"></span><span class="hs-comment">-- listTE = 'Syntax.TExp' . 'Syntax.ListE' . 'map' 'Syntax.unType'</span><span>
</span><span id="line-848"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-849"></span><span class="hs-comment">--</span><span>
</span><span id="line-850"></span><span class="hs-comment">-- In a @do@ block using 'liftSplice', we can bind the resulting</span><span>
</span><span id="line-851"></span><span class="hs-comment">--</span><span>
</span><span id="line-852"></span><span class="hs-comment">-- @'Syntax.TExp' ['Int']@ out of the expression.</span><span>
</span><span id="line-853"></span><span class="hs-comment">--</span><span>
</span><span id="line-854"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-855"></span><span class="hs-comment">-- foo :: 'Q' ('Syntax.TExp' Int)</span><span>
</span><span id="line-856"></span><span class="hs-comment">-- foo = do</span><span>
</span><span id="line-857"></span><span class="hs-comment">--      ints &lt;- mkInts [&quot;hello&quot;, &quot;world&quot;, &quot;goodybe&quot;, &quot;bob&quot;]</span><span>
</span><span id="line-858"></span><span class="hs-comment">--      [|| sum $$(pure (listTE ints)) ||]</span><span>
</span><span id="line-859"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-860"></span><span class="hs-comment">--</span><span>
</span><span id="line-861"></span><span class="hs-comment">-- Prior to GHC 9, with the 'Q' type, we can write @'pure' :: 'Syntax.TExp' a -&gt; 'Q' ('Syntax.TExp' a)@,</span><span>
</span><span id="line-862"></span><span class="hs-comment">-- which is a valid thing to use in a typed quasiquoter.</span><span>
</span><span id="line-863"></span><span class="hs-comment">-- However, after GHC 9, this code will fail to type check. There is no</span><span>
</span><span id="line-864"></span><span class="hs-comment">-- 'Applicative' instance for @'Code' m a@, so we need another way to</span><span>
</span><span id="line-865"></span><span class="hs-comment">-- splice it in.</span><span>
</span><span id="line-866"></span><span class="hs-comment">--</span><span>
</span><span id="line-867"></span><span class="hs-comment">-- A GHC 9 only solution can use @'Code' :: m ('Syntax.TExp' a) -&gt; Code</span><span>
</span><span id="line-868"></span><span class="hs-comment">-- m a@ and 'pure' together, like: @'Code' . 'pure'@.</span><span>
</span><span id="line-869"></span><span class="hs-comment">--</span><span>
</span><span id="line-870"></span><span class="hs-comment">-- With 'expToSplice', we can splice it in a backwards compatible way.</span><span>
</span><span id="line-871"></span><span class="hs-comment">-- A fully backwards- and forwards-compatible example looks like this:</span><span>
</span><span id="line-872"></span><span class="hs-comment">--</span><span>
</span><span id="line-873"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-874"></span><span class="hs-comment">-- mkInt :: 'String' -&gt; 'Q' 'Int'</span><span>
</span><span id="line-875"></span><span class="hs-comment">-- mkInt str = 'examineSplice' [|| length $$str ||]</span><span>
</span><span id="line-876"></span><span class="hs-comment">--</span><span>
</span><span id="line-877"></span><span class="hs-comment">-- mkInts :: ['String'] -&gt; 'Q' ['Syntax.TExp' 'Int']</span><span>
</span><span id="line-878"></span><span class="hs-comment">-- mkInts = traverse mkInt</span><span>
</span><span id="line-879"></span><span class="hs-comment">--</span><span>
</span><span id="line-880"></span><span class="hs-comment">-- foo :: 'SpliceQ' 'Int'</span><span>
</span><span id="line-881"></span><span class="hs-comment">-- foo = 'liftSplice' $ do</span><span>
</span><span id="line-882"></span><span class="hs-comment">--      ints &lt;- mkInts [&quot;hello&quot;, &quot;world&quot;, &quot;goodybe&quot;, &quot;bob&quot;]</span><span>
</span><span id="line-883"></span><span class="hs-comment">--      'examineSplice' [|| sum $$(expToSplice (listTE ints)) ||]</span><span>
</span><span id="line-884"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-885"></span><span class="hs-comment">--</span><span>
</span><span id="line-886"></span><span class="hs-comment">-- @since 0.1.3</span><span>
</span><span id="line-887"></span><span id="local-6989586621679039572"><span id="local-6989586621679039573"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#expToSplice"><span class="hs-identifier hs-type">expToSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679039572"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039573"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039572"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039573"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-888"></span><span id="expToSplice"><span class="annot"><span class="annottext">expToSplice :: forall (m :: * -&gt; *) a. Applicative m =&gt; TExp a -&gt; Splice m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#expToSplice"><span class="hs-identifier hs-var hs-var">expToSplice</span></a></span></span><span> </span><span id="local-6989586621679039864"><span class="annot"><span class="annottext">TExp a
</span><a href="#local-6989586621679039864"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; Splice m a
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftSplice"><span class="hs-identifier hs-var">liftSplice</span></a></span><span> </span><span class="annot"><span class="annottext">(m (TExp a) -&gt; Splice m a) -&gt; m (TExp a) -&gt; Splice m a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TExp a -&gt; m (TExp a)
forall a. a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">TExp a
</span><a href="#local-6989586621679039864"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-889"></span><span>
</span><span id="line-890"></span><span class="hs-comment">-- | A variant of 'examineCode' that takes a 'Splice' as an argument. Because</span><span>
</span><span id="line-891"></span><span class="hs-comment">-- this function takes a 'Splice' as an argyment, the type of this function</span><span>
</span><span id="line-892"></span><span class="hs-comment">-- will be different depending on which version of @template-haskell@ you are</span><span>
</span><span id="line-893"></span><span class="hs-comment">-- using. (See the Haddocks for 'Splice' for more information on this point.)</span><span>
</span><span id="line-894"></span><span class="hs-comment">--</span><span>
</span><span id="line-895"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-896"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#examineSplice"><span class="hs-identifier hs-type">examineSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039865"><span class="annot"><a href="#local-6989586621679039865"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039866"><span class="annot"><a href="#local-6989586621679039866"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039867"><span class="annot"><a href="#local-6989586621679039867"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039865"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039866"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039867"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039866"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039867"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="examineSplice"><span class="annot"><span class="annottext">examineSplice :: forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><a href="Language.Haskell.TH.Syntax.Compat.html#examineSplice"><span class="hs-identifier hs-var hs-var">examineSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code m a -&gt; m (TExp a)
forall (m :: * -&gt; *) a. Code m a -&gt; m (TExp a)
</span><span class="hs-identifier hs-var">examineCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">examineSplice</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">id</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-909"></span><span class="hs-comment">-- | A variant of 'hoistCode' that works over 'Splice's. Because this function</span><span>
</span><span id="line-910"></span><span class="hs-comment">-- uses 'Splice', the type of this function will be different depending on</span><span>
</span><span id="line-911"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. (See the Haddocks for</span><span>
</span><span id="line-912"></span><span class="hs-comment">-- 'Splice' for more information on this point.)</span><span>
</span><span id="line-913"></span><span class="hs-comment">--</span><span>
</span><span id="line-914"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-915"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#hoistSplice"><span class="hs-identifier hs-type">hoistSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039580"><span class="annot"><a href="#local-6989586621679039580"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621679039582"><span class="annot"><a href="#local-6989586621679039582"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039579"><span class="annot"><a href="#local-6989586621679039579"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039583"><span class="annot"><a href="#local-6989586621679039583"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039579"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039580"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039581"><span class="annot"><a href="#local-6989586621679039581"><span class="hs-identifier hs-type">x</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="#local-6989586621679039580"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039581"><span class="hs-identifier hs-type">x</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039582"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039581"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039580"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039583"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039582"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039583"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="hoistSplice"><span class="annot"><span class="annottext">hoistSplice :: forall (m :: * -&gt; *) (n :: * -&gt; *) a.
Monad m =&gt;
(forall x. m x -&gt; n x) -&gt; Splice m a -&gt; Splice n a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#hoistSplice"><span class="hs-identifier hs-var hs-var">hoistSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(forall x. m x -&gt; n x) -&gt; Code m a -&gt; Code n a
forall (m :: * -&gt; *) (n :: * -&gt; *) a.
Monad m =&gt;
(forall x. m x -&gt; n x) -&gt; Splice m a -&gt; Splice n a
</span><span class="hs-identifier hs-var">hoistCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">hoistSplice</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">a</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-928"></span><span class="hs-comment">-- | A variant of 'joinCode' that works over 'Splice's. Because this function</span><span>
</span><span id="line-929"></span><span class="hs-comment">-- uses 'Splice', the type of this function will be different depending on</span><span>
</span><span id="line-930"></span><span class="hs-comment">-- which version of @template-haskell@ you are using. (See the Haddocks for</span><span>
</span><span id="line-931"></span><span class="hs-comment">-- 'Splice' for more information on this point.)</span><span>
</span><span id="line-932"></span><span class="hs-comment">--</span><span>
</span><span id="line-933"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-934"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#joinSplice"><span class="hs-identifier hs-type">joinSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
#  if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621679039590"><span class="annot"><a href="#local-6989586621679039590"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039589"><span class="annot"><a href="#local-6989586621679039589"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039591"><span class="annot"><a href="#local-6989586621679039591"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039589"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
#  endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621679039590"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039590"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039590"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039591"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039590"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039591"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="joinSplice"><span class="annot"><span class="annottext">joinSplice :: forall (m :: * -&gt; *) a. Monad m =&gt; m (Splice m a) -&gt; Splice m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#joinSplice"><span class="hs-identifier hs-var hs-var">joinSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (Code m a) -&gt; Code m a
forall (m :: * -&gt; *) a. Monad m =&gt; m (Splice m a) -&gt; Splice m a
</span><span class="hs-identifier hs-var">joinCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">joinSplice</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">flip</span><span> </span><span class="hs-identifier">bindSplice</span><span> </span><span class="hs-identifier">id</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-947"></span><span class="hs-comment">-- | A variant of 'liftCode' that returns a 'Splice'. Because this function</span><span>
</span><span id="line-948"></span><span class="hs-comment">-- returns a 'Splice', the return type of this function will be different</span><span>
</span><span id="line-949"></span><span class="hs-comment">-- depending on which version of @template-haskell@ you are using. (See the</span><span>
</span><span id="line-950"></span><span class="hs-comment">-- Haddocks for 'Splice' for more</span><span>
</span><span id="line-951"></span><span class="hs-comment">-- information on this point.)</span><span>
</span><span id="line-952"></span><span class="hs-comment">--</span><span>
</span><span id="line-953"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-954"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftSplice"><span class="hs-identifier hs-type">liftSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039872"><span class="annot"><a href="#local-6989586621679039872"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039873"><span class="annot"><a href="#local-6989586621679039873"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039872"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039874"><span class="annot"><a href="#local-6989586621679039874"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><a href="#local-6989586621679039874"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.TExp</span></span><span> </span><span class="annot"><a href="#local-6989586621679039873"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039874"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039873"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="liftSplice"><span class="annot"><span class="annottext">liftSplice :: forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftSplice"><span class="hs-identifier hs-var hs-var">liftSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m (TExp a) -&gt; Code m a
forall a (m :: * -&gt; *). m (TExp a) -&gt; Code m a
</span><span class="hs-identifier hs-var">liftCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">liftSplice</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">id</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-967"></span><span class="hs-comment">-- | A variant of 'liftTypedQuote' that is:</span><span>
</span><span id="line-968"></span><span class="hs-comment">--</span><span>
</span><span id="line-969"></span><span class="hs-comment">-- 1. Always implemented in terms of 'Syntax.lift' behind the scenes, and</span><span>
</span><span id="line-970"></span><span class="hs-comment">--</span><span>
</span><span id="line-971"></span><span class="hs-comment">-- 2. Returns a 'Splice'. This means that the return type of this function will</span><span>
</span><span id="line-972"></span><span class="hs-comment">--    be different depending on which version of @template-haskell@ you are</span><span>
</span><span id="line-973"></span><span class="hs-comment">--    using. (See the Haddocks for 'Splice' for more information on this</span><span>
</span><span id="line-974"></span><span class="hs-comment">--    point.)</span><span>
</span><span id="line-975"></span><span class="hs-comment">--</span><span>
</span><span id="line-976"></span><span class="hs-comment">-- This is especially useful for minimizing CPP in one particular scenario:</span><span>
</span><span id="line-977"></span><span class="hs-comment">-- implementing 'Syntax.liftTyped' in hand-written 'Syntax.Lift' instances</span><span>
</span><span id="line-978"></span><span class="hs-comment">-- where the corresponding 'Syntax.lift' implementation cannot be derived. For</span><span>
</span><span id="line-979"></span><span class="hs-comment">-- instance, consider this example from the @text@ library:</span><span>
</span><span id="line-980"></span><span class="hs-comment">--</span><span>
</span><span id="line-981"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-982"></span><span class="hs-comment">-- instance 'Syntax.Lift' Text where</span><span>
</span><span id="line-983"></span><span class="hs-comment">--   'Syntax.lift' = appE (varE 'pack) . stringE . unpack</span><span>
</span><span id="line-984"></span><span class="hs-comment">-- #if MIN\_VERSION\_template\_haskell(2,17,0)</span><span>
</span><span id="line-985"></span><span class="hs-comment">--   'Syntax.liftTyped' = 'unsafeCodeCoerce' . 'Syntax.lift'</span><span>
</span><span id="line-986"></span><span class="hs-comment">-- #elif MIN\_VERSION\_template\_haskell(2,16,0)</span><span>
</span><span id="line-987"></span><span class="hs-comment">--   'Syntax.liftTyped' = 'Syntax.unsafeTExpCoerce' . 'Syntax.lift'</span><span>
</span><span id="line-988"></span><span class="hs-comment">-- #endif</span><span>
</span><span id="line-989"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-990"></span><span class="hs-comment">--</span><span>
</span><span id="line-991"></span><span class="hs-comment">-- The precise details of how this 'Syntax.lift' implementation works are not</span><span>
</span><span id="line-992"></span><span class="hs-comment">-- important, only that it is something that @DeriveLift@ could not generate.</span><span>
</span><span id="line-993"></span><span class="hs-comment">-- The main point of this example is to illustrate how tiresome it is to write</span><span>
</span><span id="line-994"></span><span class="hs-comment">-- the CPP necessary to define 'Syntax.liftTyped' in a way that works across</span><span>
</span><span id="line-995"></span><span class="hs-comment">-- multiple versions of @template-haskell@. With 'liftTypedFromUntypedSplice',</span><span>
</span><span id="line-996"></span><span class="hs-comment">-- however, this becomes slightly easier to manage:</span><span>
</span><span id="line-997"></span><span class="hs-comment">--</span><span>
</span><span id="line-998"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-999"></span><span class="hs-comment">-- instance 'Syntax.Lift' Text where</span><span>
</span><span id="line-1000"></span><span class="hs-comment">--   'Syntax.lift' = appE (varE 'pack) . stringE . unpack</span><span>
</span><span id="line-1001"></span><span class="hs-comment">-- #if MIN\_VERSION\_template\_haskell(2,16,0)</span><span>
</span><span id="line-1002"></span><span class="hs-comment">--   'Syntax.liftTyped' = 'liftTypedFromUntypedSplice'</span><span>
</span><span id="line-1003"></span><span class="hs-comment">-- #endif</span><span>
</span><span id="line-1004"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1005"></span><span class="hs-comment">--</span><span>
</span><span id="line-1006"></span><span class="hs-comment">-- Note that due to the way this function is defined, this will only work</span><span>
</span><span id="line-1007"></span><span class="hs-comment">-- for 'Syntax.Lift' instances @t@ such that @(t :: Type)@. If you wish to</span><span>
</span><span id="line-1008"></span><span class="hs-comment">-- manually define 'Syntax.liftTyped' for a type with a different kind, you</span><span>
</span><span id="line-1009"></span><span class="hs-comment">-- will have to use 'unsafeSpliceCoerce' to overcome levity polymorphism</span><span>
</span><span id="line-1010"></span><span class="hs-comment">-- restrictions.</span><span>
</span><span id="line-1011"></span><span id="local-6989586621679039598"><span id="local-6989586621679039599"><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedFromUntypedSplice"><span class="hs-identifier hs-type">liftTypedFromUntypedSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Syntax.Lift</span></span><span> </span><span class="annot"><a href="#local-6989586621679039598"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039599"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039598"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039599"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039598"><span class="hs-identifier hs-type">t</span></a></span></span></span><span>
</span><span id="line-1012"></span><span id="liftTypedFromUntypedSplice"><span class="annot"><span class="annottext">liftTypedFromUntypedSplice :: forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; Splice m t
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftTypedFromUntypedSplice"><span class="hs-identifier hs-var hs-var">liftTypedFromUntypedSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Splice m t
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Splice m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeSpliceCoerce"><span class="hs-identifier hs-var">unsafeSpliceCoerce</span></a></span><span> </span><span class="annot"><span class="annottext">(m Exp -&gt; Splice m t) -&gt; (t -&gt; m Exp) -&gt; t -&gt; Splice m t
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; m Exp
forall t (m :: * -&gt; *). (Lift t, Quote m) =&gt; t -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#liftQuote"><span class="hs-identifier hs-var">liftQuote</span></a></span><span>
</span><span id="line-1013"></span><span>
</span><span id="line-1014"></span><span class="hs-comment">-- | Unsafely convert an untyped splice representation into a typed 'Splice'</span><span>
</span><span id="line-1015"></span><span class="hs-comment">-- representation. Because this function returns a 'Splice', the return type of</span><span>
</span><span id="line-1016"></span><span class="hs-comment">-- this function will be different depending on which version of</span><span>
</span><span id="line-1017"></span><span class="hs-comment">-- @template-haskell@ you are using. (See the Haddocks for 'Splice' for more</span><span>
</span><span id="line-1018"></span><span class="hs-comment">-- information on this point.)</span><span>
</span><span id="line-1019"></span><span class="hs-comment">--</span><span>
</span><span id="line-1020"></span><span class="hs-comment">-- This is especially useful for minimizing CPP when:</span><span>
</span><span id="line-1021"></span><span class="hs-comment">--</span><span>
</span><span id="line-1022"></span><span class="hs-comment">-- 1. You need to implement 'Syntax.liftTyped' in a hand-written 'Syntax.Lift'</span><span>
</span><span id="line-1023"></span><span class="hs-comment">--    instance where the corresponding 'Syntax.lift' implementation cannot be</span><span>
</span><span id="line-1024"></span><span class="hs-comment">--    derived, and</span><span>
</span><span id="line-1025"></span><span class="hs-comment">--</span><span>
</span><span id="line-1026"></span><span class="hs-comment">-- 2. The data type receiving a 'Lift' instance has a kind besides @Type@.</span><span>
</span><span id="line-1027"></span><span class="hs-comment">--</span><span>
</span><span id="line-1028"></span><span class="hs-comment">-- Condition (2) is important because while it is possible to simply define</span><span>
</span><span id="line-1029"></span><span class="hs-comment">-- @'Syntax.liftTyped = 'liftTypedFromUntypedSplice'@ for 'Syntax.Lift'</span><span>
</span><span id="line-1030"></span><span class="hs-comment">-- instances @t@ such that @(t :: Type)@, this will not work for types with</span><span>
</span><span id="line-1031"></span><span class="hs-comment">-- different types, such as unboxed types or unlifted newtypes. This is because</span><span>
</span><span id="line-1032"></span><span class="hs-comment">-- GHC restrictions prevent defining 'liftTypedFromUntypedSplice' in a levity</span><span>
</span><span id="line-1033"></span><span class="hs-comment">-- polymorphic fashion, so one must use 'unsafeSpliceCoerce' to work around</span><span>
</span><span id="line-1034"></span><span class="hs-comment">-- these restrictions. Here is an example of how to use 'unsafeSpliceCoerce`:</span><span>
</span><span id="line-1035"></span><span class="hs-comment">--</span><span>
</span><span id="line-1036"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1037"></span><span class="hs-comment">-- instance 'Syntax.Lift' Int# where</span><span>
</span><span id="line-1038"></span><span class="hs-comment">--   'Syntax.lift' x = litE (intPrimL (fromIntegral (I# x)))</span><span>
</span><span id="line-1039"></span><span class="hs-comment">-- #if MIN\_VERSION\_template\_haskell(2,16,0)</span><span>
</span><span id="line-1040"></span><span class="hs-comment">--   'Syntax.liftTyped' x = 'unsafeSpliceCoerce' ('Syntax.lift' x)</span><span>
</span><span id="line-1041"></span><span class="hs-comment">-- #endif</span><span>
</span><span id="line-1042"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1043"></span><span class="hs-comment">--</span><span>
</span><span id="line-1044"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-1045"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeSpliceCoerce"><span class="hs-identifier hs-type">unsafeSpliceCoerce</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039602"><span class="annot"><a href="#local-6989586621679039602"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039604"><span class="annot"><a href="#local-6989586621679039604"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039602"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039603"><span class="annot"><a href="#local-6989586621679039603"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039603"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039603"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039603"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039604"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="unsafeSpliceCoerce"><span class="annot"><span class="annottext">unsafeSpliceCoerce :: forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Splice m a
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unsafeSpliceCoerce"><span class="hs-identifier hs-var hs-var">unsafeSpliceCoerce</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">m Exp -&gt; Code m a
forall a (m :: * -&gt; *). Quote m =&gt; m Exp -&gt; Splice m a
</span><span class="hs-identifier hs-var">unsafeCodeCoerce</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">unsafeSpliceCoerce</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unsafeTExpCoerceQuote</span><span class="hs-cpp">
# endif
</span><span>
</span><span id="line-1058"></span><span class="hs-comment">-- | A variant of 'unTypeCode' that takes a 'Splice' as an argument. Because</span><span>
</span><span id="line-1059"></span><span class="hs-comment">-- this function takes a 'Splice' as an argyment, the type of this function</span><span>
</span><span id="line-1060"></span><span class="hs-comment">-- will be different depending on which version of @template-haskell@ you are</span><span>
</span><span id="line-1061"></span><span class="hs-comment">-- using. (See the Haddocks for 'Splice' for more information on this point.)</span><span>
</span><span id="line-1062"></span><span class="hs-comment">--</span><span>
</span><span id="line-1063"></span><span class="hs-comment">-- Levity-polymorphic since /template-haskell-2.16.0.0/.</span><span>
</span><span id="line-1064"></span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeSplice"><span class="hs-identifier hs-type">unTypeSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,16,0)
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039608"><span class="annot"><a href="#local-6989586621679039608"><span class="hs-identifier hs-type">r</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">RuntimeRep</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679039610"><span class="annot"><a href="#local-6989586621679039610"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TYPE</span></span><span> </span><span class="annot"><a href="#local-6989586621679039608"><span class="hs-identifier hs-type">r</span></a></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679039609"><span class="annot"><a href="#local-6989586621679039609"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# else
</span><span>  </span><span class="hs-keyword">forall</span><span> </span><span class="hs-identifier">a</span><span> </span><span class="hs-identifier">m</span><span> </span><span class="hs-operator">.</span><span class="hs-cpp">
# endif
</span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Quote</span></span><span> </span><span class="annot"><a href="#local-6989586621679039609"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Syntax.Compat.html#Splice"><span class="hs-identifier hs-type">Splice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039609"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679039610"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679039609"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,17,0)
</span><span id="unTypeSplice"><span class="annot"><span class="annottext">unTypeSplice :: forall a (m :: * -&gt; *). Quote m =&gt; Splice m a -&gt; m Exp
</span><a href="Language.Haskell.TH.Syntax.Compat.html#unTypeSplice"><span class="hs-identifier hs-var hs-var">unTypeSplice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code m a -&gt; m Exp
forall a (m :: * -&gt; *). Quote m =&gt; Splice m a -&gt; m Exp
</span><span class="hs-identifier hs-var">unTypeCode</span></span><span class="hs-cpp">
# else
</span><span class="hs-identifier">unTypeSplice</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unTypeQQuote</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span>
</span><span id="line-1078"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-1079"></span><span class="hs-comment">-- Package root</span><span>
</span><span id="line-1080"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span class="hs-cpp">

#if !MIN_VERSION_template_haskell(2,19,0)
</span><span>
</span><span id="line-1084"></span><span class="hs-comment">-- | Get the package root for the current package which is being compiled.</span><span>
</span><span id="line-1085"></span><span class="hs-comment">-- This can be set explicitly with the -package-root flag but is normally</span><span>
</span><span id="line-1086"></span><span class="hs-comment">-- just the current working directory.</span><span>
</span><span id="line-1087"></span><span class="hs-comment">--</span><span>
</span><span id="line-1088"></span><span class="hs-comment">-- The motivation for this flag is to provide a principled means to remove the</span><span>
</span><span id="line-1089"></span><span class="hs-comment">-- assumption from splices that they will be executed in the directory where the</span><span>
</span><span id="line-1090"></span><span class="hs-comment">-- cabal file resides. Projects such as haskell-language-server can't and don't</span><span>
</span><span id="line-1091"></span><span class="hs-comment">-- change directory when compiling files but instead set the -package-root flag</span><span>
</span><span id="line-1092"></span><span class="hs-comment">-- appropiately.</span><span>
</span><span id="line-1093"></span><span class="hs-comment">--</span><span>
</span><span id="line-1094"></span><span class="hs-comment">-- This is best-effort compatibility implementation.</span><span>
</span><span id="line-1095"></span><span class="hs-comment">-- This function looks at the source location of the Haskell file calling it,</span><span>
</span><span id="line-1096"></span><span class="hs-comment">-- finds the first parent directory with a @.cabal@ file, and uses that as the</span><span>
</span><span id="line-1097"></span><span class="hs-comment">-- root directory for fixing the relative path.</span><span>
</span><span id="line-1098"></span><span class="hs-comment">--</span><span>
</span><span id="line-1099"></span><span class="hs-identifier">getPackageRoot</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">FilePath</span><span>
</span><span id="line-1100"></span><span class="hs-identifier">getPackageRoot</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">getPackageRootPredicate</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-special">(</span><span class="hs-operator">==</span><span class="hs-special">)</span><span> </span><span class="hs-string">&quot;.cabal&quot;</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">takeExtension</span><span>
</span><span id="line-1101"></span><span>
</span><span id="line-1102"></span><span class="hs-comment">-- The implementation is modified from the makeRelativeToLocationPredicate</span><span>
</span><span id="line-1103"></span><span class="hs-comment">-- function in the file-embed package</span><span>
</span><span id="line-1104"></span><span class="hs-comment">-- Copyright 2008, Michael Snoyman. All rights reserved.</span><span>
</span><span id="line-1105"></span><span class="hs-comment">-- under BSD-2-Clause license.</span><span>
</span><span id="line-1106"></span><span class="hs-identifier">getPackageRootPredicate</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FilePath</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Bool</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">FilePath</span><span>
</span><span id="line-1107"></span><span class="hs-identifier">getPackageRootPredicate</span><span> </span><span class="hs-identifier">isTargetFile</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1108"></span><span>    </span><span class="hs-identifier">loc</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">qLocation</span><span>
</span><span id="line-1109"></span><span>    </span><span class="hs-special">(</span><span class="hs-identifier">srcFP</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mdir</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">Syntax.runIO</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1110"></span><span>        </span><span class="hs-identifier">srcFP</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">canonicalizePath</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Syntax.loc_filename</span><span> </span><span class="hs-identifier">loc</span><span>
</span><span id="line-1111"></span><span>        </span><span class="hs-identifier">mdir</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">findProjectDir</span><span> </span><span class="hs-identifier">srcFP</span><span>
</span><span id="line-1112"></span><span>        </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">srcFP</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mdir</span><span class="hs-special">)</span><span>
</span><span id="line-1113"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mdir</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1114"></span><span>        </span><span class="hs-identifier">Nothing</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fail</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-string">&quot;Could not find .cabal file for path: &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">srcFP</span><span>
</span><span id="line-1115"></span><span>        </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">dir</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">dir</span><span>
</span><span id="line-1116"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1117"></span><span>    </span><span class="hs-identifier">findProjectDir</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1118"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">dir</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">takeDirectory</span><span> </span><span class="hs-identifier">x</span><span>
</span><span id="line-1119"></span><span>        </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">dir</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">x</span><span>
</span><span id="line-1120"></span><span>        </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-1121"></span><span>        </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1122"></span><span>            </span><span class="hs-identifier">contents</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">getDirectoryContents</span><span> </span><span class="hs-identifier">dir</span><span>
</span><span id="line-1123"></span><span>            </span><span class="hs-keyword">if</span><span> </span><span class="hs-identifier">any</span><span> </span><span class="hs-identifier">isTargetFile</span><span> </span><span class="hs-identifier">contents</span><span>
</span><span id="line-1124"></span><span>            </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">dir</span><span class="hs-special">)</span><span>
</span><span id="line-1125"></span><span>            </span><span class="hs-keyword">else</span><span> </span><span class="hs-identifier">findProjectDir</span><span> </span><span class="hs-identifier">dir</span><span>
</span><span id="line-1126"></span><span>
</span><span id="line-1127"></span><span class="hs-comment">-- | The input is a filepath, which if relative is offset by the package root.</span><span>
</span><span id="line-1128"></span><span class="hs-identifier">makeRelativeToProject</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">FilePath</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-identifier">FilePath</span><span>
</span><span id="line-1129"></span><span class="hs-identifier">makeRelativeToProject</span><span> </span><span class="hs-identifier">fp</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">isRelative</span><span> </span><span class="hs-identifier">fp</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1130"></span><span>  </span><span class="hs-identifier">root</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">getPackageRoot</span><span>
</span><span id="line-1131"></span><span>  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">root</span><span> </span><span class="hs-operator">&lt;/&gt;</span><span> </span><span class="hs-identifier">fp</span><span class="hs-special">)</span><span>
</span><span id="line-1132"></span><span class="hs-identifier">makeRelativeToProject</span><span> </span><span class="hs-identifier">fp</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">fp</span><span class="hs-cpp">

#endif
</span></pre></body></html>