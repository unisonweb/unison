-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | MurmurHash2 implementation for Haskell.
--   
--   Implements MurmurHash2, a good, fast, general-purpose,
--   non-cryptographic hashing function. See
--   <a>http://murmurhash.googlepages.com/</a> for details.
--   
--   This implementation is pure Haskell, so it might be a bit slower than
--   a C FFI binding.
@package murmur-hash
@version 0.1.0.10


-- | Type class and primitives for constructing 32 bit hashes using the
--   MurmurHash2 algorithm. See <a>http://murmurhash.googlepages.com</a>
--   for details on MurmurHash2.
module Data.Digest.Murmur32

-- | A 32 bit hash.
data Hash32

-- | Extract 32 bit word from hash.
asWord32 :: Hash32 -> Word32
class Hashable32 a
hash32Add :: Hashable32 a => a -> Hash32 -> Hash32
hash32AddWord32 :: Word32 -> Hash32 -> Hash32
hash32AddInt :: Int -> Hash32 -> Hash32

-- | Create a hash using the default seed.
hash32 :: Hashable32 a => a -> Hash32

-- | Create a hash using a custom seed.
--   
--   The seed should be non-zero, but other than that can be an arbitrary
--   number. Different seeds will give different hashes, and thus (most
--   likely) different hash collisions.
hash32WithSeed :: Hashable32 a => Word32 -> a -> Hash32
instance GHC.Enum.Bounded Data.Digest.Murmur32.Hash32
instance GHC.Classes.Ord Data.Digest.Murmur32.Hash32
instance GHC.Classes.Eq Data.Digest.Murmur32.Hash32
instance Data.Digest.Murmur32.Hashable32 GHC.Types.Char
instance Data.Digest.Murmur32.Hashable32 GHC.Types.Int
instance Data.Digest.Murmur32.Hashable32 GHC.Word.Word32
instance Data.Digest.Murmur32.Hashable32 a => Data.Digest.Murmur32.Hashable32 [a]
instance Data.Digest.Murmur32.Hashable32 GHC.Num.Integer.Integer
instance Data.Digest.Murmur32.Hashable32 GHC.Types.Bool
instance Data.Digest.Murmur32.Hashable32 a => Data.Digest.Murmur32.Hashable32 (GHC.Maybe.Maybe a)
instance (Data.Digest.Murmur32.Hashable32 a, Data.Digest.Murmur32.Hashable32 b) => Data.Digest.Murmur32.Hashable32 (Data.Either.Either a b)
instance Data.Digest.Murmur32.Hashable32 ()
instance (Data.Digest.Murmur32.Hashable32 a, Data.Digest.Murmur32.Hashable32 b) => Data.Digest.Murmur32.Hashable32 (a, b)
instance (Data.Digest.Murmur32.Hashable32 a, Data.Digest.Murmur32.Hashable32 b, Data.Digest.Murmur32.Hashable32 c) => Data.Digest.Murmur32.Hashable32 (a, b, c)
instance (Data.Digest.Murmur32.Hashable32 a, Data.Digest.Murmur32.Hashable32 b, Data.Digest.Murmur32.Hashable32 c, Data.Digest.Murmur32.Hashable32 d) => Data.Digest.Murmur32.Hashable32 (a, b, c, d)
instance Data.Digest.Murmur32.Hashable32 Data.ByteString.Internal.Type.ByteString
instance Data.Digest.Murmur32.Hashable32 Data.ByteString.Lazy.Internal.ByteString
instance GHC.Show.Show Data.Digest.Murmur32.Hash32


-- | Type class and primitives for constructing 64 bit hashes using the
--   MurmurHash2 algorithm. See <a>http://murmurhash.googlepages.com</a>
--   for details on MurmurHash2.
module Data.Digest.Murmur64

-- | A 64 bit hash.
data Hash64

-- | Extract 64 bit word from hash.
asWord64 :: Hash64 -> Word64
class Hashable64 a
hash64Add :: Hashable64 a => a -> Hash64 -> Hash64

-- | Add a 64 bit word to the hash.
hash64AddWord64 :: Word64 -> Hash64 -> Hash64
hash64AddInt :: Int -> Hash64 -> Hash64

-- | Create a hash using the default seed.
hash64 :: Hashable64 a => a -> Hash64

-- | Create a hash using a custom seed.
--   
--   The seed should be non-zero, but other than that can be an arbitrary
--   number. Different seeds will give different hashes, and thus (most
--   likely) different hash collisions.
hash64WithSeed :: Hashable64 a => Word64 -> a -> Hash64

-- | Combine two hash generators. E.g.,
--   
--   <pre>
--   hashFoo (Foo a) = hash64AddInt 1 <a>combine</a> hash64Add a
--   </pre>
combine :: (Hash64 -> Hash64) -> (Hash64 -> Hash64) -> Hash64 -> Hash64
instance GHC.Enum.Bounded Data.Digest.Murmur64.Hash64
instance GHC.Classes.Ord Data.Digest.Murmur64.Hash64
instance GHC.Classes.Eq Data.Digest.Murmur64.Hash64
instance Data.Digest.Murmur64.Hashable64 GHC.Types.Char
instance Data.Digest.Murmur64.Hashable64 GHC.Types.Int
instance Data.Digest.Murmur64.Hashable64 GHC.Word.Word64
instance Data.Digest.Murmur64.Hashable64 a => Data.Digest.Murmur64.Hashable64 [a]
instance Data.Digest.Murmur64.Hashable64 GHC.Num.Integer.Integer
instance Data.Digest.Murmur64.Hashable64 GHC.Types.Bool
instance Data.Digest.Murmur64.Hashable64 a => Data.Digest.Murmur64.Hashable64 (GHC.Maybe.Maybe a)
instance (Data.Digest.Murmur64.Hashable64 a, Data.Digest.Murmur64.Hashable64 b) => Data.Digest.Murmur64.Hashable64 (Data.Either.Either a b)
instance Data.Digest.Murmur64.Hashable64 ()
instance (Data.Digest.Murmur64.Hashable64 a, Data.Digest.Murmur64.Hashable64 b) => Data.Digest.Murmur64.Hashable64 (a, b)
instance (Data.Digest.Murmur64.Hashable64 a, Data.Digest.Murmur64.Hashable64 b, Data.Digest.Murmur64.Hashable64 c) => Data.Digest.Murmur64.Hashable64 (a, b, c)
instance (Data.Digest.Murmur64.Hashable64 a, Data.Digest.Murmur64.Hashable64 b, Data.Digest.Murmur64.Hashable64 c, Data.Digest.Murmur64.Hashable64 d) => Data.Digest.Murmur64.Hashable64 (a, b, c, d)
instance Data.Digest.Murmur64.Hashable64 Data.ByteString.Internal.Type.ByteString
instance Data.Digest.Murmur64.Hashable64 Data.ByteString.Lazy.Internal.ByteString
instance GHC.Show.Show Data.Digest.Murmur64.Hash64
