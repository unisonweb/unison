-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-codebase
@version 0.0.0

module U.Codebase.Causal
data Causal m hc he pe e
Causal :: hc -> he -> Map hc (m (Causal m hc he pe pe)) -> m e -> Causal m hc he pe e
[$sel:causalHash:Causal] :: Causal m hc he pe e -> hc
[$sel:valueHash:Causal] :: Causal m hc he pe e -> he
[$sel:parents:Causal] :: Causal m hc he pe e -> Map hc (m (Causal m hc he pe pe))
[$sel:value:Causal] :: Causal m hc he pe e -> m e

-- | <tt>emap f g</tt> maps over the values and parents' values with
--   <tt>f</tt> and <tt>g</tt>.
emap :: Functor m => (e -> e') -> (pe -> pe') -> Causal m hc he pe e -> Causal m hc he pe' e'
hoist :: Functor n => (forall x. m x -> n x) -> Causal m hc he pe e -> Causal n hc he pe e
instance GHC.Generics.Generic (U.Codebase.Causal.Causal m hc he pe e)
instance GHC.Base.Functor m => GHC.Base.Functor (U.Codebase.Causal.Causal m hc he pe)
instance GHC.Classes.Eq hc => GHC.Classes.Eq (U.Codebase.Causal.Causal m hc he pe e)

module U.Codebase.Kind
data Kind
Star :: Kind
Arrow :: Kind -> Kind -> Kind
instance GHC.Show.Show U.Codebase.Kind.Kind
instance GHC.Read.Read U.Codebase.Kind.Kind
instance GHC.Classes.Ord U.Codebase.Kind.Kind
instance GHC.Classes.Eq U.Codebase.Kind.Kind

module U.Codebase.Reflog
data Entry causal text
Entry :: UTCTime -> causal -> causal -> text -> Entry causal text
[$sel:time:Entry] :: Entry causal text -> UTCTime
[$sel:fromRootCausalHash:Entry] :: Entry causal text -> causal
[$sel:toRootCausalHash:Entry] :: Entry causal text -> causal
[$sel:reason:Entry] :: Entry causal text -> text
instance GHC.Base.Functor (U.Codebase.Reflog.Entry causal)
instance Data.Bifunctor.Bifunctor U.Codebase.Reflog.Entry
instance Data.Bifoldable.Bifoldable U.Codebase.Reflog.Entry
instance Data.Bitraversable.Bitraversable U.Codebase.Reflog.Entry

module U.Codebase.Type

-- | For standalone types, like those in Term.Ann
type FT = F' Reference

-- | For potentially recursive types, like those in DataDeclaration
type FD = F' (Reference' Text (Maybe Hash))
data F' r a
Ref :: r -> F' r a
Arrow :: a -> a -> F' r a
Ann :: a -> Kind -> F' r a
App :: a -> a -> F' r a
Effect :: a -> a -> F' r a
Effects :: [a] -> F' r a
Forall :: a -> F' r a
IntroOuter :: a -> F' r a

-- | Non-recursive type
type TypeT v = Term FT v ()

-- | Potentially-recursive type
type TypeD v = Term FD v ()
type TypeR r v = Term (F' r) v ()
rmap :: Ord v => (r -> r') -> Term (F' r) v a -> Term (F' r') v a
rmapM :: (Ord v, Monad f) => (r -> f r') -> Term (F' r) v a -> f (Term (F' r') v a)
typeD2T :: Ord v => Hash -> TypeD v -> TypeT v
dependencies :: (Ord v, Ord r) => Term (F' r) v a -> Set r
instance Data.Traversable.Traversable (U.Codebase.Type.F' r)
instance (GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (U.Codebase.Type.F' r a)
instance (GHC.Classes.Ord r, GHC.Classes.Ord a) => GHC.Classes.Ord (U.Codebase.Type.F' r a)
instance (GHC.Classes.Eq r, GHC.Classes.Eq a) => GHC.Classes.Eq (U.Codebase.Type.F' r a)
instance GHC.Base.Functor (U.Codebase.Type.F' r)
instance Data.Foldable.Foldable (U.Codebase.Type.F' r)

module U.Codebase.Decl
type ConstructorId = Word64
data DeclType
Data :: DeclType
Effect :: DeclType
type Decl v = DeclR TypeRef v
type HashableDecl v = DeclR HashableTypeRef v
type TypeRef = Reference' Text (Maybe Hash)
type HashableTypeRef = Reference' Text Hash
type Type v = TypeR TypeRef v
type HashableType v = TypeR HashableTypeRef v
data Modifier
Structural :: Modifier
Unique :: Text -> Modifier
data DeclR r v
DataDeclaration :: DeclType -> Modifier -> [v] -> [TypeR r v] -> DeclR r v
[$sel:declType:DataDeclaration] :: DeclR r v -> DeclType
[$sel:modifier:DataDeclaration] :: DeclR r v -> Modifier
[$sel:bound:DataDeclaration] :: DeclR r v -> [v]
[$sel:constructorTypes:DataDeclaration] :: DeclR r v -> [TypeR r v]
allVars :: Ord v => DeclR r v -> Set v
vmap :: Ord v' => (v -> v') -> DeclR r v -> DeclR r v'
rmap :: Ord v => (r -> r') -> DeclR r v -> DeclR r' v
dependencies :: (Ord r, Ord v) => DeclR r v -> Set r
data V v
Bound :: v -> V v
Ctor :: Int -> V v
data F a
Type :: FD a -> F a
LetRec :: [a] -> a -> F a
Constructors :: [a] -> F a
Modified :: DeclType -> Modifier -> a -> F a

-- | Given the pieces of a single decl component, replaces all
--   <a>Nothing</a> self-referential hashes with a variable reference to
--   the relevant piece of the component in the component map.
unhashComponent :: forall v extra. Var v => Hash -> (Id -> v) -> Map Id (Decl v, extra) -> Map Id (v, HashableDecl v, extra)
instance GHC.Enum.Enum U.Codebase.Decl.DeclType
instance GHC.Show.Show U.Codebase.Decl.DeclType
instance GHC.Classes.Ord U.Codebase.Decl.DeclType
instance GHC.Classes.Eq U.Codebase.Decl.DeclType
instance GHC.Show.Show U.Codebase.Decl.Modifier
instance GHC.Classes.Ord U.Codebase.Decl.Modifier
instance GHC.Classes.Eq U.Codebase.Decl.Modifier
instance (GHC.Show.Show v, GHC.Show.Show r) => GHC.Show.Show (U.Codebase.Decl.DeclR r v)
instance GHC.Show.Show a => GHC.Show.Show (U.Codebase.Decl.F a)
instance Data.Foldable.Foldable U.Codebase.Decl.F
instance GHC.Base.Functor U.Codebase.Decl.F

module U.Codebase.Referent
data ConstructorType
DataConstructor :: ConstructorType
EffectConstructor :: ConstructorType
type Referent = Referent' Reference Reference
type ReferentH = Referent' (Reference' Text (Maybe Hash)) (Reference' Text Hash)
data Referent' termRef typeRef
Ref :: termRef -> Referent' termRef typeRef
Con :: typeRef -> ConstructorId -> Referent' termRef typeRef
refs_ :: Traversal (Referent' ref ref) (Referent' ref' ref') ref ref'
typeRef_ :: Traversal (Referent' termRef typeRef) (Referent' termRef typeRef') typeRef typeRef'
termRef_ :: Traversal (Referent' termRef typeRef) (Referent' termRef' typeRef) termRef termRef'
_Ref :: Prism (Referent' tmr tyr) (Referent' tmr' tyr) tmr tmr'
_Con :: Prism (Referent' tmr tyr) (Referent' tmr tyr') (tyr, ConstructorId) (tyr', ConstructorId)
toReference :: Referent -> Reference
toReferenceId :: Referent -> Maybe Id
toTermReference :: Referent' termRef typeRef -> Maybe termRef
type Id = Id' Hash Hash
data Id' hTm hTp
RefId :: Id' hTm -> Id' hTm hTp
ConId :: Id' hTp -> ConstructorId -> Id' hTm hTp
toShortHash :: Referent -> ShortHash
instance GHC.Classes.Ord U.Codebase.Referent.ConstructorType
instance GHC.Classes.Eq U.Codebase.Referent.ConstructorType
instance GHC.Show.Show U.Codebase.Referent.ConstructorType
instance Data.Traversable.Traversable (U.Codebase.Referent.Referent' termRef)
instance Data.Foldable.Foldable (U.Codebase.Referent.Referent' termRef)
instance GHC.Base.Functor (U.Codebase.Referent.Referent' termRef)
instance GHC.Generics.Generic (U.Codebase.Referent.Referent' termRef typeRef)
instance (GHC.Show.Show termRef, GHC.Show.Show typeRef) => GHC.Show.Show (U.Codebase.Referent.Referent' termRef typeRef)
instance (GHC.Classes.Ord termRef, GHC.Classes.Ord typeRef) => GHC.Classes.Ord (U.Codebase.Referent.Referent' termRef typeRef)
instance (GHC.Classes.Eq termRef, GHC.Classes.Eq typeRef) => GHC.Classes.Eq (U.Codebase.Referent.Referent' termRef typeRef)
instance (GHC.Show.Show hTm, GHC.Show.Show hTp) => GHC.Show.Show (U.Codebase.Referent.Id' hTm hTp)
instance (GHC.Classes.Ord hTm, GHC.Classes.Ord hTp) => GHC.Classes.Ord (U.Codebase.Referent.Id' hTm hTp)
instance GHC.Base.Functor (U.Codebase.Referent.Id' hTm)
instance (GHC.Classes.Eq hTm, GHC.Classes.Eq hTp) => GHC.Classes.Eq (U.Codebase.Referent.Id' hTm hTp)
instance Data.Bifunctor.Bifunctor U.Codebase.Referent.Id'
instance Data.Bifoldable.Bifoldable U.Codebase.Referent.Id'
instance Data.Bitraversable.Bitraversable U.Codebase.Referent.Id'
instance Data.Bifunctor.Bifunctor U.Codebase.Referent.Referent'
instance Data.Bifoldable.Bifoldable U.Codebase.Referent.Referent'
instance Data.Bitraversable.Bitraversable U.Codebase.Referent.Referent'

module U.Codebase.TermEdit
data TermEdit
Replace :: Referent -> Typing -> TermEdit
Deprecate :: TermEdit
data Typing
Same :: Typing
Subtype :: Typing
Different :: Typing
instance GHC.Show.Show U.Codebase.TermEdit.Typing
instance GHC.Classes.Ord U.Codebase.TermEdit.Typing
instance GHC.Classes.Eq U.Codebase.TermEdit.Typing
instance GHC.Show.Show U.Codebase.TermEdit.TermEdit
instance GHC.Classes.Ord U.Codebase.TermEdit.TermEdit
instance GHC.Classes.Eq U.Codebase.TermEdit.TermEdit

module U.Codebase.Term
type ConstructorId = Word64
type Term v = Term (F v) v ()

-- | A version of <a>Term</a> but where TermRefs never have a
--   <a>Nothing</a> Hash, but instead self references are filled with User
--   Variable references to the relevant piece of the component in a
--   component map.
type HashableTerm v = Term (F' Text HashableTermRef TypeRef HashableTermLink TypeLink v) v ()
type Type v = TypeR TypeRef v
type TermRef = Reference' Text (Maybe Hash)
type HashableTermRef = Reference' Text Hash
type TypeRef = Reference
type TermLink = Referent' (Reference' Text (Maybe Hash)) (Reference' Text Hash)
type HashableTermLink = Referent' (Reference' Text Hash) (Reference' Text Hash)
type TypeLink = Reference

-- | Base functor for terms in the Unison codebase
type F vt = F' Text TermRef TypeRef TermLink TypeLink vt

-- | Generalized version. We could generalize further to allow sharing
--   within terms.
data F' text termRef typeRef termLink typeLink vt a
Int :: Int64 -> F' text termRef typeRef termLink typeLink vt a
Nat :: Word64 -> F' text termRef typeRef termLink typeLink vt a
Float :: Double -> F' text termRef typeRef termLink typeLink vt a
Boolean :: Bool -> F' text termRef typeRef termLink typeLink vt a
Text :: text -> F' text termRef typeRef termLink typeLink vt a
Char :: Char -> F' text termRef typeRef termLink typeLink vt a
Ref :: termRef -> F' text termRef typeRef termLink typeLink vt a
Constructor :: typeRef -> ConstructorId -> F' text termRef typeRef termLink typeLink vt a
Request :: typeRef -> ConstructorId -> F' text termRef typeRef termLink typeLink vt a
Handle :: a -> a -> F' text termRef typeRef termLink typeLink vt a
App :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Ann :: a -> TypeR typeRef vt -> F' text termRef typeRef termLink typeLink vt a
List :: Seq a -> F' text termRef typeRef termLink typeLink vt a
If :: a -> a -> a -> F' text termRef typeRef termLink typeLink vt a
And :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Or :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Lam :: a -> F' text termRef typeRef termLink typeLink vt a
LetRec :: [a] -> a -> F' text termRef typeRef termLink typeLink vt a
Let :: a -> a -> F' text termRef typeRef termLink typeLink vt a
Match :: a -> [MatchCase text typeRef a] -> F' text termRef typeRef termLink typeLink vt a
TermLink :: termLink -> F' text termRef typeRef termLink typeLink vt a
TypeLink :: typeLink -> F' text termRef typeRef termLink typeLink vt a
data MatchCase t r a
MatchCase :: Pattern t r -> Maybe a -> a -> MatchCase t r a
data Pattern t r
PUnbound :: Pattern t r
PVar :: Pattern t r
PBoolean :: !Bool -> Pattern t r
PInt :: !Int64 -> Pattern t r
PNat :: !Word64 -> Pattern t r
PFloat :: !Double -> Pattern t r
PText :: !t -> Pattern t r
PChar :: !Char -> Pattern t r
PConstructor :: !r -> !ConstructorId -> [Pattern t r] -> Pattern t r
PAs :: Pattern t r -> Pattern t r
PEffectPure :: Pattern t r -> Pattern t r
PEffectBind :: !r -> !ConstructorId -> [Pattern t r] -> Pattern t r -> Pattern t r
PSequenceLiteral :: [Pattern t r] -> Pattern t r
PSequenceOp :: Pattern t r -> !SeqOp -> Pattern t r -> Pattern t r
data SeqOp
PCons :: SeqOp
PSnoc :: SeqOp
PConcat :: SeqOp
extraMap :: forall text termRef typeRef termLink typeLink vt text' termRef' typeRef' termLink' typeLink' vt' v a. (Ord v, Ord vt') => (text -> text') -> (termRef -> termRef') -> (typeRef -> typeRef') -> (termLink -> termLink') -> (typeLink -> typeLink') -> (vt -> vt') -> Term (F' text termRef typeRef termLink typeLink vt) v a -> Term (F' text' termRef' typeRef' termLink' typeLink' vt') v a
extraMapM :: forall m text termRef typeRef termLink typeLink vt text' termRef' typeRef' termLink' typeLink' vt' v a. (Ord v, Ord vt', Monad m) => (text -> m text') -> (termRef -> m termRef') -> (typeRef -> m typeRef') -> (termLink -> m termLink') -> (typeLink -> m typeLink') -> (vt -> m vt') -> Term (F' text termRef typeRef termLink typeLink vt) v a -> m (Term (F' text' termRef' typeRef' termLink' typeLink' vt') v a)
rmapPattern :: (t -> t') -> (r -> r') -> Pattern t r -> Pattern t' r'
rmapPatternM :: Applicative m => (t -> m t') -> (r -> m r') -> Pattern t r -> m (Pattern t' r')
dependencies :: (Ord termRef, Ord typeRef, Ord termLink, Ord typeLink, Ord v) => Term (F' text termRef typeRef termLink typeLink vt) v a -> (Set termRef, Set typeRef, Set termLink, Set typeLink)

-- | Given the pieces of a single term component, replaces all
--   <a>Nothing</a> self-referential hashes with a variable reference to
--   the relevant piece of the component in the component map.
unhashComponent :: forall v extra. Var v => Hash -> (Id -> v) -> Map Id (Term v, extra) -> Map Id (v, HashableTerm v, extra)
instance GHC.Show.Show U.Codebase.Term.SeqOp
instance GHC.Classes.Eq U.Codebase.Term.SeqOp
instance (GHC.Show.Show t, GHC.Show.Show r) => GHC.Show.Show (U.Codebase.Term.Pattern t r)
instance Data.Traversable.Traversable (U.Codebase.Term.Pattern t)
instance Data.Foldable.Foldable (U.Codebase.Term.Pattern t)
instance GHC.Base.Functor (U.Codebase.Term.Pattern t)
instance GHC.Generics.Generic (U.Codebase.Term.Pattern t r)
instance (GHC.Show.Show t, GHC.Show.Show r, GHC.Show.Show a) => GHC.Show.Show (U.Codebase.Term.MatchCase t r a)
instance Data.Traversable.Traversable (U.Codebase.Term.MatchCase t r)
instance GHC.Generics.Generic1 (U.Codebase.Term.MatchCase t r)
instance GHC.Generics.Generic (U.Codebase.Term.MatchCase t r a)
instance GHC.Base.Functor (U.Codebase.Term.MatchCase t r)
instance Data.Foldable.Foldable (U.Codebase.Term.MatchCase t r)
instance (GHC.Show.Show text, GHC.Show.Show termRef, GHC.Show.Show vt, GHC.Show.Show a, GHC.Show.Show termLink, GHC.Show.Show typeLink, GHC.Show.Show typeRef) => GHC.Show.Show (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt a)
instance Data.Traversable.Traversable (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)
instance GHC.Base.Functor (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)
instance Data.Foldable.Foldable (U.Codebase.Term.F' text termRef typeRef termLink typeLink vt)

module U.Codebase.TypeEdit
data TypeEdit
Replace :: Reference -> TypeEdit
Deprecate :: TypeEdit
instance GHC.Show.Show U.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Ord U.Codebase.TypeEdit.TypeEdit
instance GHC.Classes.Eq U.Codebase.TypeEdit.TypeEdit

module U.Codebase.Branch.Type

-- | A re-imagining of Unison.Codebase.Branch which is less eager in what
--   it loads, which can often speed up load times and keep fewer things in
--   memory.
data Branch m
Branch :: !Map NameSegment (Map Referent (m MdValues)) -> !Map NameSegment (Map Reference (m MdValues)) -> !Map NameSegment (PatchHash, m Patch) -> !Map NameSegment (CausalBranch m) -> Branch m
[$sel:terms:Branch] :: Branch m -> !Map NameSegment (Map Referent (m MdValues))
[$sel:types:Branch] :: Branch m -> !Map NameSegment (Map Reference (m MdValues))
[$sel:patches:Branch] :: Branch m -> !Map NameSegment (PatchHash, m Patch)
[$sel:children:Branch] :: Branch m -> !Map NameSegment (CausalBranch m)
type CausalBranch m = Causal m CausalHash BranchHash (Branch m) (Branch m)
data Patch
Patch :: !Map Referent (Set TermEdit) -> !Map Reference (Set TypeEdit) -> Patch
[$sel:termEdits:Patch] :: Patch -> !Map Referent (Set TermEdit)
[$sel:typeEdits:Patch] :: Patch -> !Map Reference (Set TypeEdit)
type MetadataType = Reference
type MetadataValue = Reference
newtype MdValues
MdValues :: Set MetadataValue -> MdValues
[$sel:unMdValues:MdValues] :: MdValues -> Set MetadataValue

-- | Useful statistics about a namespace. All contained statistics should
--   be <tt>static</tt>, i.e. they can be computed when a branch is first
--   saved, and won't change unless the branch hash also changes.
data NamespaceStats
NamespaceStats :: !Int -> !Int -> !Int -> NamespaceStats
[$sel:numContainedTerms:NamespaceStats] :: NamespaceStats -> !Int
[$sel:numContainedTypes:NamespaceStats] :: NamespaceStats -> !Int
[$sel:numContainedPatches:NamespaceStats] :: NamespaceStats -> !Int

-- | Whether the provided stats indicate the presence of any definitions in
--   the namespace.
hasDefinitions :: NamespaceStats -> Bool
childAt :: NameSegment -> Branch m -> Maybe (CausalBranch m)
hoist :: Functor n => (forall x. m x -> n x) -> Branch m -> Branch n
hoistCausalBranch :: Functor n => (forall x. m x -> n x) -> CausalBranch m -> CausalBranch n
empty :: Branch m
instance GHC.Show.Show U.Codebase.Branch.Type.MdValues
instance GHC.Classes.Ord U.Codebase.Branch.Type.MdValues
instance GHC.Classes.Eq U.Codebase.Branch.Type.MdValues
instance GHC.Generics.Generic (U.Codebase.Branch.Type.Branch m)
instance GHC.Classes.Ord U.Codebase.Branch.Type.NamespaceStats
instance GHC.Classes.Eq U.Codebase.Branch.Type.NamespaceStats
instance GHC.Show.Show U.Codebase.Branch.Type.NamespaceStats
instance GHC.Base.Semigroup U.Codebase.Branch.Type.NamespaceStats
instance GHC.Base.Monoid U.Codebase.Branch.Type.NamespaceStats
instance GHC.Show.Show (U.Codebase.Branch.Type.Branch m)


-- | V3 branches and causals.
module U.Codebase.BranchV3

-- | A V3 branch is a trimmed-down V2 branch:
--   
--   <ul>
--   <li>Names can't be conflicted.</li>
--   <li>Metadata doesn't exist.</li>
--   <li>Patches don't exist.</li>
--   </ul>
data BranchV3 m
BranchV3 :: !Map NameSegment (CausalBranchV3 m) -> !Map NameSegment Referent -> !Map NameSegment TypeReference -> BranchV3 m
[$sel:children:BranchV3] :: BranchV3 m -> !Map NameSegment (CausalBranchV3 m)
[$sel:terms:BranchV3] :: BranchV3 m -> !Map NameSegment Referent
[$sel:types:BranchV3] :: BranchV3 m -> !Map NameSegment TypeReference

-- | A V3 branch's history has V3 branches everywhere at the latest causal
--   (so, no metadata, no patches, etc. in any children namespaces), but
--   when we go back in history, we find V2 branches, because that's what
--   we used to have ;)
type CausalBranchV3 m = Causal m CausalHash BranchHash (Branch m) (BranchV3 m)
instance GHC.Generics.Generic (U.Codebase.BranchV3.BranchV3 m)

module U.Codebase.WatchKind
data WatchKind
RegularWatch :: WatchKind
TestWatch :: WatchKind
instance GHC.Show.Show U.Codebase.WatchKind.WatchKind
instance GHC.Classes.Ord U.Codebase.WatchKind.WatchKind
instance GHC.Classes.Eq U.Codebase.WatchKind.WatchKind
