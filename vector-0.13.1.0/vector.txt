-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient Arrays
--   
--   An efficient implementation of <tt>Int</tt>-indexed arrays (both
--   mutable and immutable), with a powerful loop optimisation framework .
--   
--   It is structured as follows:
--   
--   <ul>
--   <li><i><a>Data.Vector</a></i> Boxed vectors of arbitrary types.</li>
--   <li><i><a>Data.Vector.Unboxed</a></i> Unboxed vectors with an adaptive
--   representation based on data type families.</li>
--   <li><i><a>Data.Vector.Storable</a></i> Unboxed vectors of
--   <a>Storable</a> types.</li>
--   <li><i><a>Data.Vector.Primitive</a></i> Unboxed vectors of primitive
--   types as defined by the <tt>primitive</tt> package.
--   <a>Data.Vector.Unboxed</a> is more flexible at no performance
--   cost.</li>
--   <li><i><a>Data.Vector.Generic</a></i> Generic interface to the vector
--   types.</li>
--   </ul>
--   
--   There is also a (draft) tutorial on common uses of vector.
--   
--   <ul>
--   
--   <li><a>http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial</a></li>
--   </ul>
@package vector
@version 0.13.1.0


-- | Monadic stream combinators.
module Data.Vector.Fusion.Stream.Monadic


-- | Fusion-related utility types
module Data.Vector.Fusion.Util

-- | Identity monad
newtype Id a
Id :: a -> Id a
[unId] :: Id a -> a

-- | Box monad
data () => Box a
Box :: a -> Box a
[unBox] :: Box a -> a
liftBox :: Monad m => Box a -> m a

-- | Delay inlining a function until late in the game (simplifier phase 0).
delay_inline :: (a -> b) -> a -> b

-- | <a>min</a> inlined in phase 0
delayed_min :: Int -> Int -> Int
instance GHC.Base.Functor Data.Vector.Fusion.Util.Id
instance GHC.Base.Applicative Data.Vector.Fusion.Util.Id
instance GHC.Base.Monad Data.Vector.Fusion.Util.Id


-- | Size hints for streams.
module Data.Vector.Fusion.Bundle.Size

-- | Size hint
data Size

-- | Exact size
Exact :: {-# UNPACK #-} !Int -> Size

-- | Upper bound on the size
Max :: {-# UNPACK #-} !Int -> Size

-- | Unknown size
Unknown :: Size

-- | Subtract two sizes with clamping to 0, for drop-like things
clampedSubtract :: Size -> Size -> Size

-- | Minimum of two size hints
smaller :: Size -> Size -> Size

-- | Select a safe smaller than known size.
smallerThan :: Int -> Size -> Size

-- | Maximum of two size hints
larger :: Size -> Size -> Size

-- | Convert a size hint to an upper bound
toMax :: Size -> Size

-- | Compute the maximum size from a size hint if possible
upperBound :: Size -> Maybe Int

-- | Compute the minimum size from a size hint
lowerBound :: Size -> Int
instance GHC.Show.Show Data.Vector.Fusion.Bundle.Size.Size
instance GHC.Classes.Eq Data.Vector.Fusion.Bundle.Size.Size
instance GHC.Num.Num Data.Vector.Fusion.Bundle.Size.Size


-- | Class of mutable vectors.
module Data.Vector.Generic.Mutable.Base

-- | Class of mutable vectors parameterised with a primitive state token.
class MVector v a

-- | Length of the mutable vector. This method should not be called
--   directly, use <a>length</a> instead.
basicLength :: MVector v a => v s a -> Int

-- | Yield a part of the mutable vector without copying it. This method
--   should not be called directly, use <tt>unsafeSlice</tt> instead.
basicUnsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a

-- | Check whether two vectors overlap. This method should not be called
--   directly, use <tt>overlaps</tt> instead.
basicOverlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length. This method should not be
--   called directly, use <tt>unsafeNew</tt> instead.
basicUnsafeNew :: MVector v a => Int -> ST s (v s a)

-- | Initialize a vector to a standard value. This is intended to be called
--   as part of the safe new operation (and similar operations), to
--   properly blank the newly allocated memory if necessary.
--   
--   Vectors that are necessarily initialized as part of creation may
--   implement this as a no-op.
basicInitialize :: MVector v a => v s a -> ST s ()

-- | Create a mutable vector of the given length and fill it with an
--   initial value. This method should not be called directly, use
--   <a>replicate</a> instead.
basicUnsafeReplicate :: MVector v a => Int -> a -> ST s (v s a)

-- | Yield the element at the given position. This method should not be
--   called directly, use <tt>unsafeRead</tt> instead.
basicUnsafeRead :: MVector v a => v s a -> Int -> ST s a

-- | Replace the element at the given position. This method should not be
--   called directly, use <tt>unsafeWrite</tt> instead.
basicUnsafeWrite :: MVector v a => v s a -> Int -> a -> ST s ()

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors. This method should not be called directly, use <tt>clear</tt>
--   instead.
basicClear :: MVector v a => v s a -> ST s ()

-- | Set all elements of the vector to the given value. This method should
--   not be called directly, use <tt>set</tt> instead.
basicSet :: MVector v a => v s a -> a -> ST s ()

-- | Copy a vector. The two vectors may not overlap. This method should not
--   be called directly, use <tt>unsafeCopy</tt> instead.
basicUnsafeCopy :: MVector v a => v s a -> v s a -> ST s ()

-- | Move the contents of a vector. The two vectors may overlap. This
--   method should not be called directly, use <tt>unsafeMove</tt> instead.
basicUnsafeMove :: MVector v a => v s a -> v s a -> ST s ()

-- | Grow a vector by the given number of elements. Allocates a new vector
--   and copies all of the elements over starting at 0 index. This method
--   should not be called directly, use <tt>grow</tt>/<tt>unsafeGrow</tt>
--   instead.
basicUnsafeGrow :: MVector v a => v s a -> Int -> ST s (v s a)


-- | Monadic bundles.
module Data.Vector.Fusion.Bundle.Monadic

-- | Monadic streams
data Bundle m v a
Bundle :: Stream m a -> Stream m (Chunk v a) -> Maybe (v a) -> Size -> Bundle m v a
[sElems] :: Bundle m v a -> Stream m a
[sChunks] :: Bundle m v a -> Stream m (Chunk v a)
[sVector] :: Bundle m v a -> Maybe (v a)
[sSize] :: Bundle m v a -> Size
data Chunk v a
Chunk :: Int -> (forall m. (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m ()) -> Chunk v a

-- | Convert a pure stream to a monadic stream
lift :: Monad m => Bundle Id v a -> Bundle m v a

-- | <a>Size</a> hint of a <a>Bundle</a>
size :: Bundle m v a -> Size

-- | Attach a <a>Size</a> hint to a <a>Bundle</a>
sized :: Bundle m v a -> Size -> Bundle m v a

-- | Length of a <a>Bundle</a>
length :: Monad m => Bundle m v a -> m Int

-- | Check if a <a>Bundle</a> is empty
null :: Monad m => Bundle m v a -> m Bool

-- | Empty <a>Bundle</a>
empty :: Monad m => Bundle m v a

-- | Singleton <a>Bundle</a>
singleton :: Monad m => a -> Bundle m v a

-- | Prepend an element
cons :: Monad m => a -> Bundle m v a -> Bundle m v a

-- | Append an element
snoc :: Monad m => Bundle m v a -> a -> Bundle m v a

-- | Replicate a value to a given length
replicate :: Monad m => Int -> a -> Bundle m v a

-- | Yield a <a>Bundle</a> of values obtained by performing the monadic
--   action the given number of times
replicateM :: Monad m => Int -> m a -> Bundle m v a
generate :: Monad m => Int -> (Int -> a) -> Bundle m v a

-- | Generate a stream from its indices
generateM :: Monad m => Int -> (Int -> m a) -> Bundle m v a

-- | Concatenate two <a>Bundle</a>s
(++) :: Monad m => Bundle m v a -> Bundle m v a -> Bundle m v a
infixr 5 ++

-- | First element of the <a>Bundle</a> or error if empty
head :: Monad m => Bundle m v a -> m a

-- | Last element of the <a>Bundle</a> or error if empty
last :: Monad m => Bundle m v a -> m a

-- | Element at the given position
(!!) :: Monad m => Bundle m v a -> Int -> m a
infixl 9 !!

-- | Element at the given position or <a>Nothing</a> if out of bounds
(!?) :: Monad m => Bundle m v a -> Int -> m (Maybe a)
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Monad m => Int -> Int -> Bundle m v a -> Bundle m v a

-- | All but the last element
init :: Monad m => Bundle m v a -> Bundle m v a

-- | All but the first element
tail :: Monad m => Bundle m v a -> Bundle m v a

-- | The first <tt>n</tt> elements
take :: Monad m => Int -> Bundle m v a -> Bundle m v a

-- | All but the first <tt>n</tt> elements
drop :: Monad m => Int -> Bundle m v a -> Bundle m v a

-- | Map a function over a <a>Bundle</a>
map :: Monad m => (a -> b) -> Bundle m v a -> Bundle m v b

-- | Map a monadic function over a <a>Bundle</a>
mapM :: Monad m => (a -> m b) -> Bundle m v a -> Bundle m v b

-- | Execute a monadic action for each element of the <a>Bundle</a>
mapM_ :: Monad m => (a -> m b) -> Bundle m v a -> m ()

-- | Transform a <a>Bundle</a> to use a different monad
trans :: (Monad m, Monad m') => (forall z. m z -> m' z) -> Bundle m v a -> Bundle m' v a
unbox :: Monad m => Bundle m v (Box a) -> Bundle m v a
concatMap :: Monad m => (a -> Bundle m v b) -> Bundle m v a -> Bundle m v b

-- | Create a <a>Bundle</a> of values from a <a>Bundle</a> of streamable
--   things
flatten :: Monad m => (a -> m s) -> (s -> m (Step s b)) -> Size -> Bundle m v a -> Bundle m v b

-- | Pair each element in a <a>Bundle</a> with its index
indexed :: Monad m => Bundle m v a -> Bundle m v (Int, a)

-- | Pair each element in a <a>Bundle</a> with its index, starting from the
--   right and counting down
indexedR :: Monad m => Int -> Bundle m v a -> Bundle m v (Int, a)
zipWithM_ :: Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> m ()

-- | Zip two <a>Bundle</a>s with the given monadic function
zipWithM :: Monad m => (a -> b -> m c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
zipWith3M :: Monad m => (a -> b -> c -> m d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
zipWith4M :: Monad m => (a -> b -> c -> d -> m e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
zipWith5M :: Monad m => (a -> b -> c -> d -> e -> m f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
zipWith6M :: Monad m => (a -> b -> c -> d -> e -> f -> m g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
zipWith :: Monad m => (a -> b -> c) -> Bundle m v a -> Bundle m v b -> Bundle m v c
zipWith3 :: Monad m => (a -> b -> c -> d) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d
zipWith4 :: Monad m => (a -> b -> c -> d -> e) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e
zipWith5 :: Monad m => (a -> b -> c -> d -> e -> f) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f
zipWith6 :: Monad m => (a -> b -> c -> d -> e -> f -> g) -> Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v g
zip :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v (a, b)
zip3 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v (a, b, c)
zip4 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v (a, b, c, d)
zip5 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v (a, b, c, d, e)
zip6 :: Monad m => Bundle m v a -> Bundle m v b -> Bundle m v c -> Bundle m v d -> Bundle m v e -> Bundle m v f -> Bundle m v (a, b, c, d, e, f)

-- | Check if two <a>Bundle</a>s are equal
eqBy :: Monad m => (a -> b -> Bool) -> Bundle m v a -> Bundle m v b -> m Bool

-- | Lexicographically compare two <a>Bundle</a>s
cmpBy :: Monad m => (a -> b -> Ordering) -> Bundle m v a -> Bundle m v b -> m Ordering

-- | Drop elements which do not satisfy the predicate
filter :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Drop elements which do not satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Apply monadic function to each element and drop all Nothings
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> Bundle m v a -> Bundle m v b

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Longest prefix of elements that satisfy the monadic predicate
takeWhileM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: Monad m => (a -> Bool) -> Bundle m v a -> Bundle m v a

-- | Drop the longest prefix of elements that satisfy the monadic predicate
dropWhileM :: Monad m => (a -> m Bool) -> Bundle m v a -> Bundle m v a

-- | Check whether the <a>Bundle</a> contains an element
elem :: (Monad m, Eq a) => a -> Bundle m v a -> m Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: (Monad m, Eq a) => a -> Bundle m v a -> m Bool
infix 4 `notElem`

-- | Yield <a>Just</a> the first element that satisfies the predicate or
--   <a>Nothing</a> if no such element exists.
find :: Monad m => (a -> Bool) -> Bundle m v a -> m (Maybe a)

-- | Yield <a>Just</a> the first element that satisfies the monadic
--   predicate or <a>Nothing</a> if no such element exists.
findM :: Monad m => (a -> m Bool) -> Bundle m v a -> m (Maybe a)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   predicate or <a>Nothing</a> if no such element exists.
findIndex :: Monad m => (a -> Bool) -> Bundle m v a -> m (Maybe Int)

-- | Yield <a>Just</a> the index of the first element that satisfies the
--   monadic predicate or <a>Nothing</a> if no such element exists.
findIndexM :: Monad m => (a -> m Bool) -> Bundle m v a -> m (Maybe Int)

-- | Left fold
foldl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a

-- | Left fold with a monadic operator
foldlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Left fold over a non-empty <a>Bundle</a>
foldl1 :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a monadic operator
foldl1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Same as <a>foldlM</a>
foldM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Same as <a>foldl1M</a>
fold1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Left fold with a strict accumulator
foldl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> m a

-- | Left fold with a strict accumulator and a monadic operator
foldlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a strict accumulator
foldl1' :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Left fold over a non-empty <a>Bundle</a> with a strict accumulator and
--   a monadic operator
foldl1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Same as <a>foldlM'</a>
foldM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> m a

-- | Same as <a>foldl1M'</a>
fold1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a

-- | Right fold
foldr :: Monad m => (a -> b -> b) -> b -> Bundle m v a -> m b

-- | Right fold with a monadic operator
foldrM :: Monad m => (a -> b -> m b) -> b -> Bundle m v a -> m b

-- | Right fold over a non-empty stream
foldr1 :: Monad m => (a -> a -> a) -> Bundle m v a -> m a

-- | Right fold over a non-empty stream with a monadic operator
foldr1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> m a
and :: Monad m => Bundle m v Bool -> m Bool
or :: Monad m => Bundle m v Bool -> m Bool
concatMapM :: Monad m => (a -> m (Bundle m v b)) -> Bundle m v a -> Bundle m v b

-- | Unfold
unfoldr :: Monad m => (s -> Maybe (a, s)) -> s -> Bundle m u a

-- | Unfold with a monadic function
unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Bundle m u a

-- | Unfold at most <tt>n</tt> elements
unfoldrN :: Monad m => Int -> (s -> Maybe (a, s)) -> s -> Bundle m u a

-- | Unfold at most <tt>n</tt> elements with a monadic function.
unfoldrNM :: Monad m => Int -> (s -> m (Maybe (a, s))) -> s -> Bundle m u a

-- | Unfold exactly <tt>n</tt> elements
unfoldrExactN :: Monad m => Int -> (s -> (a, s)) -> s -> Bundle m u a

-- | Unfold exactly <tt>n</tt> elements with a monadic function.
unfoldrExactNM :: Monad m => Int -> (s -> m (a, s)) -> s -> Bundle m u a

-- | <i>O(n)</i> Apply function &lt;math&gt; times to an initial value,
--   producing a monadic bundle of exact length &lt;math&gt;. Zeroth
--   element will contain the initial value.
iterateN :: Monad m => Int -> (a -> a) -> a -> Bundle m u a

-- | <i>O(n)</i> Apply monadic function &lt;math&gt; times to an initial
--   value, producing a monadic bundle of exact length &lt;math&gt;. Zeroth
--   element will contain the initial value.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> Bundle m u a

-- | Prefix scan
prescanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with a monadic operator
prescanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with strict accumulator
prescanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Prefix scan with strict accumulator and a monadic operator
prescanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan
postscanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with a monadic operator
postscanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with strict accumulator
postscanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Suffix scan with strict accumulator and a monadic operator
postscanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan
scanl :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with a monadic operator
scanlM :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with strict accumulator
scanl' :: Monad m => (a -> b -> a) -> a -> Bundle m v b -> Bundle m v a

-- | Haskell-style scan with strict accumulator and a monadic operator
scanlM' :: Monad m => (a -> b -> m a) -> a -> Bundle m v b -> Bundle m v a

-- | Initial-value free scan over a <a>Bundle</a>
scanl1 :: Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a

-- | Initial-value free scan over a <a>Bundle</a> with a monadic operator
scanl1M :: Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a

-- | Initial-value free scan over a <a>Bundle</a> with a strict accumulator
scanl1' :: Monad m => (a -> a -> a) -> Bundle m v a -> Bundle m v a

-- | Initial-value free scan over a <a>Bundle</a> with a strict accumulator
--   and a monadic operator
scanl1M' :: Monad m => (a -> a -> m a) -> Bundle m v a -> Bundle m v a

-- | Yield a <a>Bundle</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: (Num a, Monad m) => a -> a -> Int -> Bundle m v a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operation can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: (Enum a, Monad m) => a -> a -> Bundle m v a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operation is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Enum a, Monad m) => a -> a -> a -> Bundle m v a

-- | Convert a <a>Bundle</a> to a list
toList :: Monad m => Bundle m v a -> m [a]

-- | Convert a list to a <a>Bundle</a>
fromList :: Monad m => [a] -> Bundle m v a

-- | Convert the first <tt>n</tt> elements of a list to a <a>Bundle</a>
fromListN :: Monad m => Int -> [a] -> Bundle m v a

-- | Convert a list to a <a>Bundle</a> with the given <a>Size</a> hint.
unsafeFromList :: Monad m => Size -> [a] -> Bundle m v a
fromVector :: (Monad m, Vector v a) => v a -> Bundle m v a
reVector :: Monad m => Bundle m u a -> Bundle m v a
fromVectors :: forall m v a. (Monad m, Vector v a) => [v a] -> Bundle m v a
concatVectors :: (Monad m, Vector v a) => Bundle m u (v a) -> Bundle m v a
fromStream :: Monad m => Stream m a -> Size -> Bundle m v a
chunks :: Bundle m v a -> Stream m (Chunk v a)
elements :: Bundle m v a -> Stream m a
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Vector.Fusion.Bundle.Monadic.Bundle m v)


-- | Bundles for stream fusion
module Data.Vector.Fusion.Bundle

-- | Result of taking a single step in a stream
data () => Step s a
[Yield] :: forall a s. a -> s -> Step s a
[Skip] :: forall s a. s -> Step s a
[Done] :: forall s a. Step s a
data Chunk v a
Chunk :: Int -> (forall m. (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m ()) -> Chunk v a

-- | The type of pure streams
type Bundle = Bundle Id

-- | Alternative name for monadic streams
type MBundle = Bundle
inplace :: (forall m. Monad m => Stream m a -> Stream m b) -> (Size -> Size) -> Bundle v a -> Bundle v b

-- | <a>Size</a> hint of a <a>Bundle</a>
size :: Bundle v a -> Size

-- | Attach a <a>Size</a> hint to a <a>Bundle</a>
sized :: Bundle v a -> Size -> Bundle v a

-- | Length of a <a>Bundle</a>
length :: Bundle v a -> Int

-- | Check if a <a>Bundle</a> is empty
null :: Bundle v a -> Bool

-- | Empty <a>Bundle</a>
empty :: Bundle v a

-- | Singleton <a>Bundle</a>
singleton :: a -> Bundle v a

-- | Prepend an element
cons :: a -> Bundle v a -> Bundle v a

-- | Append an element
snoc :: Bundle v a -> a -> Bundle v a

-- | Replicate a value to a given length
replicate :: Int -> a -> Bundle v a

-- | Generate a stream from its indices
generate :: Int -> (Int -> a) -> Bundle v a

-- | Concatenate two <a>Bundle</a>s
(++) :: Bundle v a -> Bundle v a -> Bundle v a
infixr 5 ++

-- | First element of the <a>Bundle</a> or error if empty
head :: Bundle v a -> a

-- | Last element of the <a>Bundle</a> or error if empty
last :: Bundle v a -> a

-- | Element at the given position
(!!) :: Bundle v a -> Int -> a
infixl 9 !!

-- | Element at the given position or <tt>Nothing</tt> if out of bounds
(!?) :: Bundle v a -> Int -> Maybe a
infixl 9 !?

-- | Extract a substream of the given length starting at the given
--   position.
slice :: Int -> Int -> Bundle v a -> Bundle v a

-- | All but the last element
init :: Bundle v a -> Bundle v a

-- | All but the first element
tail :: Bundle v a -> Bundle v a

-- | The first <tt>n</tt> elements
take :: Int -> Bundle v a -> Bundle v a

-- | All but the first <tt>n</tt> elements
drop :: Int -> Bundle v a -> Bundle v a

-- | Map a function over a <a>Bundle</a>
map :: (a -> b) -> Bundle v a -> Bundle v b
concatMap :: (a -> Bundle v b) -> Bundle v a -> Bundle v b

-- | Create a <a>Bundle</a> of values from a <a>Bundle</a> of streamable
--   things
flatten :: (a -> s) -> (s -> Step s b) -> Size -> Bundle v a -> Bundle v b
unbox :: Bundle v (Box a) -> Bundle v a

-- | Pair each element in a <a>Bundle</a> with its index
indexed :: Bundle v a -> Bundle v (Int, a)

-- | Pair each element in a <a>Bundle</a> with its index, starting from the
--   right and counting down
indexedR :: Int -> Bundle v a -> Bundle v (Int, a)

-- | Zip two <a>Bundle</a>s with the given function
zipWith :: (a -> b -> c) -> Bundle v a -> Bundle v b -> Bundle v c

-- | Zip three <a>Bundle</a>s with the given function
zipWith3 :: (a -> b -> c -> d) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d
zipWith4 :: (a -> b -> c -> d -> e) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v g
zip :: Bundle v a -> Bundle v b -> Bundle v (a, b)
zip3 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v (a, b, c)
zip4 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v (a, b, c, d)
zip5 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v (a, b, c, d, e)
zip6 :: Bundle v a -> Bundle v b -> Bundle v c -> Bundle v d -> Bundle v e -> Bundle v f -> Bundle v (a, b, c, d, e, f)

-- | Drop elements which do not satisfy the predicate
filter :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Longest prefix of elements that satisfy the predicate
takeWhile :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Drop the longest prefix of elements that satisfy the predicate
dropWhile :: (a -> Bool) -> Bundle v a -> Bundle v a

-- | Check whether the <a>Bundle</a> contains an element
elem :: Eq a => a -> Bundle v a -> Bool
infix 4 `elem`

-- | Inverse of <a>elem</a>
notElem :: Eq a => a -> Bundle v a -> Bool
infix 4 `notElem`

-- | Yield <tt>Just</tt> the first element matching the predicate or
--   <tt>Nothing</tt> if no such element exists.
find :: (a -> Bool) -> Bundle v a -> Maybe a

-- | Yield <tt>Just</tt> the index of the first element matching the
--   predicate or <tt>Nothing</tt> if no such element exists.
findIndex :: (a -> Bool) -> Bundle v a -> Maybe Int

-- | Left fold
foldl :: (a -> b -> a) -> a -> Bundle v b -> a

-- | Left fold on non-empty <a>Bundle</a>s
foldl1 :: (a -> a -> a) -> Bundle v a -> a

-- | Left fold with strict accumulator
foldl' :: (a -> b -> a) -> a -> Bundle v b -> a

-- | Left fold on non-empty <a>Bundle</a>s with strict accumulator
foldl1' :: (a -> a -> a) -> Bundle v a -> a

-- | Right fold
foldr :: (a -> b -> b) -> b -> Bundle v a -> b

-- | Right fold on non-empty <a>Bundle</a>s
foldr1 :: (a -> a -> a) -> Bundle v a -> a
and :: Bundle v Bool -> Bool
or :: Bundle v Bool -> Bool

-- | Unfold
unfoldr :: (s -> Maybe (a, s)) -> s -> Bundle v a

-- | Unfold at most <tt>n</tt> elements
unfoldrN :: Int -> (s -> Maybe (a, s)) -> s -> Bundle v a

-- | Unfold exactly <tt>n</tt> elements
unfoldrExactN :: Int -> (s -> (a, s)) -> s -> Bundle v a

-- | <i>O(n)</i> Apply function &lt;math&gt; times to an initial value,
--   producing a pure bundle of exact length &lt;math&gt;. Zeroth element
--   will contain the initial value.
iterateN :: Int -> (a -> a) -> a -> Bundle v a

-- | Prefix scan
prescanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Prefix scan with strict accumulator
prescanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Suffix scan
postscanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Suffix scan with strict accumulator
postscanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Haskell-style scan
scanl :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Haskell-style scan with strict accumulator
scanl' :: (a -> b -> a) -> a -> Bundle v b -> Bundle v a

-- | Initial-value free scan over a <a>Bundle</a>
scanl1 :: (a -> a -> a) -> Bundle v a -> Bundle v a

-- | Initial-value free scan over a <a>Bundle</a> with a strict accumulator
scanl1' :: (a -> a -> a) -> Bundle v a -> Bundle v a

-- | Yield a <a>Bundle</a> of the given length containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc.
enumFromStepN :: Num a => a -> a -> Int -> Bundle v a

-- | Enumerate values
--   
--   <i>WARNING:</i> This operations can be very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromTo :: Enum a => a -> a -> Bundle v a

-- | Enumerate values with a given step.
--   
--   <i>WARNING:</i> This operations is very inefficient. If at all
--   possible, use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Bundle v a

-- | Convert a <a>Bundle</a> to a list
toList :: Bundle v a -> [a]

-- | Create a <a>Bundle</a> from a list
fromList :: [a] -> Bundle v a

-- | Create a <a>Bundle</a> from the first <tt>n</tt> elements of a list
--   
--   <pre>
--   fromListN n xs = fromList (take n xs)
--   </pre>
fromListN :: Int -> [a] -> Bundle v a
unsafeFromList :: Size -> [a] -> Bundle v a

-- | Convert a pure stream to a monadic stream
lift :: Monad m => Bundle Id v a -> Bundle m v a
fromVector :: Vector v a => v a -> Bundle v a
reVector :: Bundle u a -> Bundle v a
fromVectors :: Vector v a => [v a] -> Bundle v a
concatVectors :: Vector v a => Bundle u (v a) -> Bundle v a

-- | Apply a monadic action to each element of the stream, producing a
--   monadic stream of results
mapM :: Monad m => (a -> m b) -> Bundle v a -> Bundle m v b

-- | Apply a monadic action to each element of the stream
mapM_ :: Monad m => (a -> m b) -> Bundle v a -> m ()
zipWithM :: Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> Bundle m v c
zipWithM_ :: Monad m => (a -> b -> m c) -> Bundle v a -> Bundle v b -> m ()

-- | Yield a monadic stream of elements that satisfy the monadic predicate
filterM :: Monad m => (a -> m Bool) -> Bundle v a -> Bundle m v a

-- | <i>O(n)</i> Apply monadic function to each element of a bundle and
--   discard elements returning Nothing.
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> Bundle v a -> Bundle m v b

-- | Monadic fold
foldM :: Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a

-- | Monadic fold over non-empty stream
fold1M :: Monad m => (a -> a -> m a) -> Bundle v a -> m a

-- | Monadic fold with strict accumulator
foldM' :: Monad m => (a -> b -> m a) -> a -> Bundle v b -> m a

-- | Monad fold over non-empty stream with strict accumulator
fold1M' :: Monad m => (a -> a -> m a) -> Bundle v a -> m a

-- | Check if two <a>Bundle</a>s are equal
eq :: Eq a => Bundle v a -> Bundle v a -> Bool

-- | Lexicographically compare two <a>Bundle</a>s
cmp :: Ord a => Bundle v a -> Bundle v a -> Ordering
eqBy :: (a -> b -> Bool) -> Bundle v a -> Bundle v b -> Bool
cmpBy :: (a -> b -> Ordering) -> Bundle v a -> Bundle v b -> Ordering
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v a)
instance Data.Functor.Classes.Eq1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v)
instance Data.Functor.Classes.Ord1 (Data.Vector.Fusion.Bundle.Monadic.Bundle Data.Vector.Fusion.Util.Id v)


-- | Generic interface to mutable vectors.
module Data.Vector.Generic.Mutable

-- | Class of mutable vectors parameterised with a primitive state token.
class MVector v a

-- | Length of the mutable vector. This method should not be called
--   directly, use <a>length</a> instead.
basicLength :: MVector v a => v s a -> Int

-- | Yield a part of the mutable vector without copying it. This method
--   should not be called directly, use <tt>unsafeSlice</tt> instead.
basicUnsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a

-- | Check whether two vectors overlap. This method should not be called
--   directly, use <tt>overlaps</tt> instead.
basicOverlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length. This method should not be
--   called directly, use <tt>unsafeNew</tt> instead.
basicUnsafeNew :: MVector v a => Int -> ST s (v s a)

-- | Initialize a vector to a standard value. This is intended to be called
--   as part of the safe new operation (and similar operations), to
--   properly blank the newly allocated memory if necessary.
--   
--   Vectors that are necessarily initialized as part of creation may
--   implement this as a no-op.
basicInitialize :: MVector v a => v s a -> ST s ()

-- | Create a mutable vector of the given length and fill it with an
--   initial value. This method should not be called directly, use
--   <a>replicate</a> instead.
basicUnsafeReplicate :: MVector v a => Int -> a -> ST s (v s a)

-- | Yield the element at the given position. This method should not be
--   called directly, use <tt>unsafeRead</tt> instead.
basicUnsafeRead :: MVector v a => v s a -> Int -> ST s a

-- | Replace the element at the given position. This method should not be
--   called directly, use <tt>unsafeWrite</tt> instead.
basicUnsafeWrite :: MVector v a => v s a -> Int -> a -> ST s ()

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors. This method should not be called directly, use <tt>clear</tt>
--   instead.
basicClear :: MVector v a => v s a -> ST s ()

-- | Set all elements of the vector to the given value. This method should
--   not be called directly, use <tt>set</tt> instead.
basicSet :: MVector v a => v s a -> a -> ST s ()

-- | Copy a vector. The two vectors may not overlap. This method should not
--   be called directly, use <tt>unsafeCopy</tt> instead.
basicUnsafeCopy :: MVector v a => v s a -> v s a -> ST s ()

-- | Move the contents of a vector. The two vectors may overlap. This
--   method should not be called directly, use <tt>unsafeMove</tt> instead.
basicUnsafeMove :: MVector v a => v s a -> v s a -> ST s ()

-- | Grow a vector by the given number of elements. Allocates a new vector
--   and copies all of the elements over starting at 0 index. This method
--   should not be called directly, use <tt>grow</tt>/<tt>unsafeGrow</tt>
--   instead.
basicUnsafeGrow :: MVector v a => v s a -> Int -> ST s (v s a)

-- | Length of the mutable vector.
length :: MVector v a => v s a -> Int

-- | Check whether the vector is empty.
null :: MVector v a => v s a -> Bool

-- | Yield a part of the mutable vector without copying it. The vector must
--   contain at least <tt>i+n</tt> elements.
slice :: (HasCallStack, MVector v a) => Int -> Int -> v s a -> v s a

-- | Drop the last element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
init :: MVector v a => v s a -> v s a

-- | Drop the first element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
tail :: MVector v a => v s a -> v s a

-- | Take the <tt>n</tt> first elements of the mutable vector without
--   making a copy. For negative <tt>n</tt>, the empty vector is returned.
--   If <tt>n</tt> is larger than the vector's length, the vector is
--   returned unchanged.
take :: MVector v a => Int -> v s a -> v s a

-- | Drop the <tt>n</tt> first element of the mutable vector without making
--   a copy. For negative <tt>n</tt>, the vector is returned unchanged. If
--   <tt>n</tt> is larger than the vector's length, the empty vector is
--   returned.
drop :: MVector v a => Int -> v s a -> v s a

-- | <i>O(1)</i> Split the mutable vector into the first <tt>n</tt>
--   elements and the remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: MVector v a => Int -> v s a -> (v s a, v s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: MVector v a => Int -> Int -> v s a -> v s a

-- | Same as <a>init</a>, but doesn't do range checks.
unsafeInit :: MVector v a => v s a -> v s a

-- | Same as <a>tail</a>, but doesn't do range checks.
unsafeTail :: MVector v a => v s a -> v s a

-- | Unsafe variant of <a>take</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeTake :: MVector v a => Int -> v s a -> v s a

-- | Unsafe variant of <a>drop</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeDrop :: MVector v a => Int -> v s a -> v s a

-- | Check whether two vectors overlap.
overlaps :: MVector v a => v s a -> v s a -> Bool

-- | Create a mutable vector of the given length.
new :: (HasCallStack, PrimMonad m, MVector v a) => Int -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length. The vector content should
--   be assumed to be uninitialized. However, the exact semantics depend on
--   the vector implementation. For example, unboxed and storable vectors
--   will create a vector filled with whatever the underlying memory buffer
--   happens to contain, while boxed vector's elements are initialized to
--   bottoms which will throw exception when evaluated.
unsafeNew :: (PrimMonad m, MVector v a) => Int -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, MVector v a) => Int -> a -> m (v (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, MVector v a) => Int -> m a -> m (v (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   function to each index. Iteration starts at index 0.
generate :: (PrimMonad m, MVector v a) => Int -> (Int -> a) -> m (v (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   monadic function to each index. Iteration starts at index 0.
generateM :: (PrimMonad m, MVector v a) => Int -> (Int -> m a) -> m (v (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m (v (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must not be
--   negative, otherwise an exception is thrown. The semantics of this
--   function are exactly the same as of <a>unsafeGrow</a>, except that it
--   will initialize the newly allocated memory first.
--   
--   It is important to note that mutating the returned vector will not
--   affect the vector that was used as a source. In other words, it does
--   not, nor will it ever have the semantics of <tt>realloc</tt> from C.
--   
--   <pre>
--   grow mv 0 === clone mv
--   </pre>
grow :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Grow a vector by allocating a new mutable vector of the same size plus
--   the the given number of elements and copying all the data over to the
--   new vector, starting at its beginning. The newly allocated memory is
--   not initialized and the extra space at the end will likely contain
--   garbage data or bottoms. Use <a>unsafeGrowFront</a> to make the extra
--   space available in the front of the new vector.
--   
--   It is important to note that mutating the returned vector will not
--   affect elements of the vector that was used as a source. In other
--   words, it does not, nor will it ever have the semantics of
--   <tt>realloc</tt> from C. Keep in mind, however, that values themselves
--   can be of a mutable type (eg. <a>Ptr</a>), in which case it would be
--   possible to affect values stored in both vectors.
--   
--   <pre>
--   unsafeGrow mv 0 === clone mv
--   </pre>
unsafeGrow :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Same as <a>grow</a>, except that it copies data towards the end of the
--   newly allocated vector, making extra space available at the beginning.
growFront :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Same as <a>unsafeGrow</a>, except that it copies data towards the end
--   of the newly allocated vector, making extra space available at the
--   beginning.
unsafeGrowFront :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (v (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()

-- | Yield the element at the given position. Will throw an exception if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; v &lt;- MV.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MV.read v 3
--   9
--   </pre>
read :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Yield the element at the given position. Returns <a>Nothing</a> if the
--   index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; v &lt;- MV.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MV.readMaybe v 3
--   Just 9
--   
--   &gt;&gt;&gt; MV.readMaybe v 13
--   Nothing
--   </pre>
readMaybe :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m (Maybe a)

-- | Replace the element at the given position.
write :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function.
modifyM :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
exchange :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function. No
--   bounds checks are performed.
unsafeModifyM :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Int -> a -> m a

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results.
mapM_ :: (PrimMonad m, MVector v a) => (a -> m b) -> v (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results.
imapM_ :: (PrimMonad m, MVector v a) => (Int -> a -> m b) -> v (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results. It's the same as <tt>flip mapM_</tt>.
forM_ :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results. It's the same as <tt>flip
--   imapM_</tt>.
iforM_ :: (PrimMonad m, MVector v a) => v (PrimState m) a -> (Int -> a -> m b) -> m ()

-- | <i>O(n)</i> Pure left fold.
foldl :: (PrimMonad m, MVector v a) => (b -> a -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator.
foldl' :: (PrimMonad m, MVector v a) => (b -> a -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold.
foldM :: (PrimMonad m, MVector v a) => (b -> a -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (PrimMonad m, MVector v a) => (b -> a -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold.
foldr :: (PrimMonad m, MVector v a) => (a -> b -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator.
foldr' :: (PrimMonad m, MVector v a) => (a -> b -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold.
foldrM :: (PrimMonad m, MVector v a) => (a -> b -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator.
foldrM' :: (PrimMonad m, MVector v a) => (a -> b -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold using a function applied to each element
--   and its index.
ifoldl :: (PrimMonad m, MVector v a) => (b -> Int -> a -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator using a function
--   applied to each element and its index.
ifoldl' :: (PrimMonad m, MVector v a) => (b -> Int -> a -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (PrimMonad m, MVector v a) => (b -> Int -> a -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (PrimMonad m, MVector v a) => (b -> Int -> a -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold using a function applied to each element
--   and its index.
ifoldr :: (PrimMonad m, MVector v a) => (Int -> a -> b -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: (PrimMonad m, MVector v a) => (Int -> a -> b -> b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold using a function applied to each
--   element and its index.
ifoldrM :: (PrimMonad m, MVector v a) => (Int -> a -> b -> m b) -> b -> v (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator using a
--   function applied to each element and its index.
ifoldrM' :: (PrimMonad m, MVector v a) => (Int -> a -> b -> m b) -> b -> v (PrimState m) a -> m b

-- | Compute the (lexicographically) next permutation of the given vector
--   in-place. Returns False when the input is the last permutation.
nextPermutation :: (PrimMonad m, Ord e, MVector v e) => v (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, MVector v a) => v (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap, but this is not checked.
unsafeCopy :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, MVector v a) => v (PrimState m) a -> v (PrimState m) a -> m ()
mstream :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a
mstreamR :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a>. The vector will grow exponentially if the maximum size
--   of the <a>Bundle</a> is unknown.
unstream :: (PrimMonad m, MVector v a) => Bundle u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a> from right to left. The vector will grow exponentially
--   if the maximum size of the <a>Bundle</a> is unknown.
unstreamR :: (PrimMonad m, MVector v a) => Bundle u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the
--   <a>Bundle</a>. The vector will grow exponentially if the maximum size
--   of the <a>Bundle</a> is unknown.
vunstream :: (PrimMonad m, Vector v a) => Bundle v a -> m (Mutable v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the monadic
--   stream. The vector will grow exponentially if the maximum size of the
--   stream is unknown.
munstream :: (PrimMonad m, MVector v a) => MBundle m u a -> m (v (PrimState m) a)

-- | Create a new mutable vector and fill it with elements from the monadic
--   stream from right to left. The vector will grow exponentially if the
--   maximum size of the stream is unknown.
munstreamR :: (PrimMonad m, MVector v a) => MBundle m u a -> m (v (PrimState m) a)
transform :: (PrimMonad m, MVector v a) => (Stream m a -> Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
transformR :: (PrimMonad m, MVector v a) => (Stream m a -> Stream m a) -> v (PrimState m) a -> m (v (PrimState m) a)
fill :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a -> m (v (PrimState m) a)
fillR :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Stream m a -> m (v (PrimState m) a)
unsafeAccum :: (PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Bundle u (Int, b) -> m ()
accum :: forall m v a b u. (HasCallStack, PrimMonad m, MVector v a) => (a -> b -> a) -> v (PrimState m) a -> Bundle u (Int, b) -> m ()
unsafeUpdate :: (PrimMonad m, MVector v a) => v (PrimState m) a -> Bundle u (Int, a) -> m ()
update :: forall m v a u. (HasCallStack, PrimMonad m, MVector v a) => v (PrimState m) a -> Bundle u (Int, a) -> m ()
reverse :: (PrimMonad m, MVector v a) => v (PrimState m) a -> m ()
unstablePartition :: forall m v a. (PrimMonad m, MVector v a) => (a -> Bool) -> v (PrimState m) a -> m Int
unstablePartitionBundle :: (PrimMonad m, MVector v a) => (a -> Bool) -> Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
partitionBundle :: (PrimMonad m, MVector v a) => (a -> Bool) -> Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
partitionWithBundle :: (PrimMonad m, MVector v a, MVector v b, MVector v c) => (a -> Either b c) -> Bundle u a -> m (v (PrimState m) b, v (PrimState m) c)

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type)

-- | State token type.
type family PrimState (m :: Type -> Type)

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld


-- | Purely functional interface to initialisation of mutable vectors
module Data.Vector.Generic.New

-- | This data type is a wrapper around a monadic action which produces a
--   mutable vector. It's used by a number of rewrite rules in order to
--   facilitate the reuse of buffers allocated for vectors. See "Recycle
--   your arrays!" for a detailed explanation.
--   
--   Note that this data type must be declared as <tt>data</tt> and not
--   <tt>newtype</tt> since it's used for rewrite rules and rules won't
--   fire with <tt>newtype</tt>.
data New v a
New :: (forall s. ST s (Mutable v s a)) -> New v a
create :: (forall s. ST s (Mutable v s a)) -> New v a
run :: New v a -> ST s (Mutable v s a)
runPrim :: PrimMonad m => New v a -> m (Mutable v (PrimState m) a)
apply :: (forall s. Mutable v s a -> Mutable v s a) -> New v a -> New v a
modify :: (forall s. Mutable v s a -> ST s ()) -> New v a -> New v a
modifyWithBundle :: (forall s. Mutable v s a -> Bundle u b -> ST s ()) -> New v a -> Bundle u b -> New v a
unstream :: Vector v a => Bundle v a -> New v a
transform :: Vector v a => (forall m. Monad m => Stream m a -> Stream m a) -> (Size -> Size) -> New v a -> New v a
unstreamR :: Vector v a => Bundle v a -> New v a
transformR :: Vector v a => (forall m. Monad m => Stream m a -> Stream m a) -> (Size -> Size) -> New v a -> New v a
slice :: Vector v a => Int -> Int -> New v a -> New v a
init :: Vector v a => New v a -> New v a
tail :: Vector v a => New v a -> New v a
take :: Vector v a => Int -> New v a -> New v a
drop :: Vector v a => Int -> New v a -> New v a
unsafeSlice :: Vector v a => Int -> Int -> New v a -> New v a
unsafeInit :: Vector v a => New v a -> New v a
unsafeTail :: Vector v a => New v a -> New v a


-- | Generic interface to immutable vectors.
module Data.Vector.Generic

-- | Class of immutable vectors. Every immutable vector is associated with
--   its mutable version through the <a>Mutable</a> type family. Methods of
--   this class should not be used directly. Instead,
--   <a>Data.Vector.Generic</a> and other <tt>Data.Vector</tt> modules
--   provide safe and fusible wrappers.
--   
--   Minimum complete implementation:
--   
--   <ul>
--   <li><a>basicUnsafeFreeze</a></li>
--   <li><a>basicUnsafeThaw</a></li>
--   <li><a>basicLength</a></li>
--   <li><a>basicUnsafeSlice</a></li>
--   <li><a>basicUnsafeIndexM</a></li>
--   </ul>
class MVector (Mutable v) a => Vector v a

-- | <i>Assumed complexity: O(1)</i>
--   
--   Unsafely convert a mutable vector to its immutable version without
--   copying. The mutable vector may not be used after this operation.
basicUnsafeFreeze :: Vector v a => Mutable v s a -> ST s (v a)

-- | <i>Assumed complexity: O(1)</i>
--   
--   Unsafely convert an immutable vector to its mutable version without
--   copying. The immutable vector may not be used after this operation.
basicUnsafeThaw :: Vector v a => v a -> ST s (Mutable v s a)

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield the length of the vector.
basicLength :: Vector v a => v a -> Int

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield a slice of the vector without copying it. No range checks are
--   performed.
basicUnsafeSlice :: Vector v a => Int -> Int -> v a -> v a

-- | <i>Assumed complexity: O(1)</i>
--   
--   Yield the element at the given position in a monad. No range checks
--   are performed.
--   
--   The monad allows us to be strict in the vector if we want. Suppose we
--   had
--   
--   <pre>
--   unsafeIndex :: v a -&gt; Int -&gt; a
--   </pre>
--   
--   instead. Now, if we wanted to copy a vector, we'd do something like
--   
--   <pre>
--   copy mv v ... = ... unsafeWrite mv i (unsafeIndex v i) ...
--   </pre>
--   
--   For lazy vectors, the indexing would not be evaluated, which means
--   that we would retain a reference to the original vector in each
--   element we write. This is not what we want!
--   
--   With <a>basicUnsafeIndexM</a>, we can do
--   
--   <pre>
--   copy mv v ... = ... case basicUnsafeIndexM v i of
--                         Box x -&gt; unsafeWrite mv i x ...
--   </pre>
--   
--   which does not have this problem, because indexing (but not the
--   returned element!) is evaluated immediately.
basicUnsafeIndexM :: Vector v a => v a -> Int -> Box a

-- | <i>Assumed complexity: O(n)</i>
--   
--   Copy an immutable vector into a mutable one. The two vectors must have
--   the same length, but this is not checked.
--   
--   Instances of <a>Vector</a> should redefine this method if they wish to
--   support an efficient block copy operation.
--   
--   Default definition: copying based on <a>basicUnsafeIndexM</a> and
--   <tt>basicUnsafeWrite</tt>.
basicUnsafeCopy :: Vector v a => Mutable v s a -> v a -> ST s ()

-- | Evaluate <tt>a</tt> as far as storing it in a vector would and yield
--   <tt>b</tt>. The <tt>v a</tt> argument only fixes the type and is not
--   touched. This method is only used for optimisation purposes. Thus, it
--   is safe for instances of <a>Vector</a> to evaluate <tt>a</tt> less
--   than it would be when stored in a vector, although this might result
--   in suboptimal code.
--   
--   <pre>
--   elemseq v x y = (singleton x `asTypeOf` v) `seq` y
--   </pre>
--   
--   Default defintion: <tt>a</tt> is not evaluated at all.
elemseq :: Vector v a => v a -> a -> b -> b

-- | <tt>Mutable v s a</tt> is the mutable version of the immutable vector
--   type <tt>v a</tt> with the state token <tt>s</tt>. It is injective on
--   GHC 8 and newer.
type family Mutable (v :: Type -> Type) = (mv :: Type -> Type -> Type) | mv -> v

-- | <i>O(1)</i> Yield the length of the vector.
length :: Vector v a => v a -> Int

-- | <i>O(1)</i> Test whether a vector is empty.
null :: Vector v a => v a -> Bool

-- | O(1) Indexing.
(!) :: (HasCallStack, Vector v a) => v a -> Int -> a
infixl 9 !

-- | O(1) Safe indexing.
(!?) :: Vector v a => v a -> Int -> Maybe a
infixl 9 !?

-- | <i>O(1)</i> First element.
head :: Vector v a => v a -> a

-- | <i>O(1)</i> Last element.
last :: Vector v a => v a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking.
unsafeIndex :: Vector v a => v a -> Int -> a

-- | <i>O(1)</i> First element, without checking if the vector is empty.
unsafeHead :: Vector v a => v a -> a

-- | <i>O(1)</i> Last element, without checking if the vector is empty.
unsafeLast :: Vector v a => v a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the element) is evaluated eagerly.
indexM :: (HasCallStack, Vector v a, Monad m) => v a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Indexing in a monad, without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Vector v a, Monad m) => v a -> Int -> m a

-- | <i>O(1)</i> First element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Last element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Vector v a, Monad m) => v a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: (HasCallStack, Vector v a) => Int -> Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector may contain less than <tt>n</tt> elements, in which case it is
--   returned unchanged.
take :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements, in
--   which case an empty vector is returned.
drop :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Vector v a => Int -> v a -> (v a, v a)

-- | <i>O(1)</i> Yield the <a>head</a> and <a>tail</a> of the vector, or
--   <a>Nothing</a> if the vector is empty.
uncons :: Vector v a => v a -> Maybe (a, v a)

-- | <i>O(1)</i> Yield the <a>last</a> and <a>init</a> of the vector, or
--   <a>Nothing</a> if the vector is empty.
unsnoc :: Vector v a => v a -> Maybe (v a, a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements, but this is not checked.
unsafeSlice :: Vector v a => Int -> Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty, but this is not checked.
unsafeInit :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty, but this is not checked.
unsafeTail :: Vector v a => v a -> v a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements, but this is not
--   checked.
unsafeTake :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements, but
--   this is not checked.
unsafeDrop :: Vector v a => Int -> v a -> v a

-- | <i>O(1)</i> The empty vector.
empty :: Vector v a => v a

-- | <i>O(1)</i> A vector with exactly one element.
singleton :: forall v a. Vector v a => a -> v a

-- | <i>O(n)</i> A vector of the given length with the same value in each
--   position.
replicate :: forall v a. Vector v a => Int -> a -> v a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
generate :: Vector v a => Int -> (Int -> a) -> v a

-- | <i>O(n)</i> Apply the function &lt;math&gt; times to an initial value,
--   producing a vector of length &lt;math&gt;. The 0th element will
--   contain the initial value, which is why there is one less function
--   application than the number of elements in the produced vector.
--   
--   &lt;math&gt;
iterateN :: Vector v a => Int -> (a -> a) -> a -> v a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Vector v a) => Int -> m a -> m (v a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index.
generateM :: (Monad m, Vector v a) => Int -> (Int -> m a) -> m (v a)

-- | <i>O(n)</i> Apply the monadic function &lt;math&gt; times to an
--   initial value, producing a vector of length &lt;math&gt;. The 0th
--   element will contain the initial value, which is why there is one less
--   function application than the number of elements in the produced
--   vector.
--   
--   For a non-monadic version, see <a>iterateN</a>.
iterateNM :: (Monad m, Vector v a) => Int -> (a -> m a) -> a -> m (v a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- <a>new</a> 2; <a>write</a> v 0 'a'; <a>write</a> v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Vector v a => (forall s. ST s (Mutable v s a)) -> v a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Vector v a) => (forall s. ST s (f (Mutable v s a))) -> f (v a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <a>Just</a> the next
--   element and the new seed or <a>Nothing</a> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Vector v a => (b -> Maybe (a, b)) -> b -> v a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <a>Just</a> the next element and the new seed or
--   <a>Nothing</a> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Vector v a => Int -> (b -> Maybe (a, b)) -> b -> v a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields the next element and the new seed.
--   
--   <pre>
--   unfoldrExactN 3 (\n -&gt; (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrExactN :: Vector v a => Int -> (b -> (a, b)) -> b -> v a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrM :: (Monad m, Vector v a) => (b -> m (Maybe (a, b))) -> b -> m (v a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <a>Just</a> the next element and the new seed or <a>Nothing</a> if
--   there are no more elements.
unfoldrNM :: (Monad m, Vector v a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (v a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the monadic generator function to a seed. The
--   generator function yields the next element and the new seed.
unfoldrExactNM :: (Monad m, Vector v a) => Int -> (b -> m (a, b)) -> b -> m (v a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in &lt;a,b,c&gt;
--   </pre>
constructN :: forall v a. Vector v a => Int -> (v a -> a) -> v a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in &lt;c,b,a&gt;
--   </pre>
constructrN :: forall v a. Vector v a => Int -> (v a -> a) -> v a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Vector v a, Num a) => a -> Int -> v a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 2 5 = &lt;1,3,5,7,9&gt;
--   </pre>
enumFromStepN :: forall v a. (Vector v a, Num a) => a -> a -> Int -> v a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromN</a> instead.
enumFromTo :: (Vector v a, Enum a) => a -> a -> v a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Vector v a, Enum a) => a -> a -> a -> v a

-- | <i>O(n)</i> Prepend an element.
cons :: forall v a. Vector v a => a -> v a -> v a

-- | <i>O(n)</i> Append an element.
snoc :: forall v a. Vector v a => v a -> a -> v a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: Vector v a => v a -> v a -> v a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list.
concat :: Vector v a => [v a] -> v a

-- | <i>O(n)</i> Concatenate all vectors in the non-empty list.
concatNE :: Vector v a => NonEmpty (v a) -> v a

-- | <i>O(n)</i> Yield the argument, but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Vector v a => v a -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Vector v a => v a -> [(Int, a)] -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>update</a> is probably more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a

-- | Same as (<a>//</a>), but without bounds checking.
unsafeUpd :: Vector v a => v a -> [(Int, a)] -> v a

-- | Same as <a>update</a>, but without bounds checking.
unsafeUpdate :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a) -> v a

-- | Same as <a>update_</a>, but without bounds checking.
unsafeUpdate_ :: (Vector v a, Vector v Int) => v a -> v Int -> v a -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.accum (+) (V.fromList [1000,2000,3000]) [(2,4),(1,6),(0,3),(1,10)]
--   [1003,2016,3004]
--   </pre>
accum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.accumulate (+) (V.fromList [1000,2000,3000]) (V.fromList [(2,4),(1,6),(0,3),(1,10)])
--   [1003,2016,3004]
--   </pre>
accumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   This function is useful for instances of <a>Vector</a> that cannot
--   store pairs. Otherwise, <a>accumulate</a> is probably more convenient:
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a

-- | Same as <a>accum</a>, but without bounds checking.
unsafeAccum :: Vector v a => (a -> b -> a) -> v a -> [(Int, b)] -> v a

-- | Same as <a>accumulate</a>, but without bounds checking.
unsafeAccumulate :: (Vector v a, Vector v (Int, b)) => (a -> b -> a) -> v a -> v (Int, b) -> v a

-- | Same as <a>accumulate_</a>, but without bounds checking.
unsafeAccumulate_ :: (Vector v a, Vector v Int, Vector v b) => (a -> b -> a) -> v a -> v Int -> v b -> v a

-- | <i>O(n)</i> Reverse a vector.
reverse :: Vector v a => v a -> v a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt>, but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: forall v a. (HasCallStack, Vector v a, Vector v Int) => v a -> v Int -> v a

-- | Same as <a>backpermute</a>, but without bounds checking.
unsafeBackpermute :: (Vector v a, Vector v Int) => v a -> v Int -> v a

-- | Apply a destructive operation to a vector. The operation may be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise (see <a>New</a> for details).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; V.modify (\v -&gt; MV.write v 0 'x') $ V.replicate 4 'a'
--   "xaaa"
--   </pre>
modify :: Vector v a => (forall s. Mutable v s a -> ST s ()) -> v a -> v a

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: (Vector v a, Vector v (Int, a)) => v a -> v (Int, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: (Vector v a, Vector v b) => (a -> b) -> v a -> v b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: (Vector v a, Vector v b) => (Int -> a -> b) -> v a -> v b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Vector v a, Vector v b) => (a -> v b) -> v a -> v b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: (Monad m, Vector v a, Vector v b) => (a -> m b) -> v a -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: (Monad m, Vector v a, Vector v b) => (Int -> a -> m b) -> v a -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: (Monad m, Vector v a) => (a -> m b) -> v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: (Monad m, Vector v a) => (Int -> a -> m b) -> v a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Vector v a, Vector v b) => v a -> (a -> m b) -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Vector v a) => v a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices, yielding a vector of results. Equivalent to
--   <tt><a>flip</a> <a>imapM</a></tt>.
iforM :: (Monad m, Vector v a, Vector v b) => v a -> (Int -> a -> m b) -> m (v b)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices and ignore the results. Equivalent to <tt><a>flip</a>
--   <a>imapM_</a></tt>.
iforM_ :: (Monad m, Vector v a) => v a -> (Int -> a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> v a -> v b -> v c

-- | Zip three vectors with the given function.
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> v a -> v b -> v c -> v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> c) -> v a -> v b -> v c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (Int -> a -> b -> c -> d) -> v a -> v b -> v c -> v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (Int -> a -> b -> c -> d -> e) -> v a -> v b -> v c -> v d -> v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (Int -> a -> b -> c -> d -> e -> f) -> v a -> v b -> v c -> v d -> v e -> v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> v a -> v b -> v c -> v d -> v e -> v f -> v g

-- | <i>O(min(m,n))</i> Zip two vectors.
zip :: (Vector v a, Vector v b, Vector v (a, b)) => v a -> v b -> v (a, b)

-- | Zip together three vectors into a vector of triples.
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v a -> v b -> v c -> v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v a -> v b -> v c -> v d -> v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v a -> v b -> v c -> v d -> v e -> v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v a -> v b -> v c -> v d -> v e -> v f -> v (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results.
zipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> v a -> v b -> m (v c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results.
izipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (Int -> a -> b -> m c) -> v a -> v b -> m (v c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results.
zipWithM_ :: (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> v a -> v b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results.
izipWithM_ :: (Monad m, Vector v a, Vector v b) => (Int -> a -> b -> m c) -> v a -> v b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => v (a, b) -> (v a, v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => v (a, b, c) -> (v a, v b, v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => v (a, b, c, d) -> (v a, v b, v c, v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => v (a, b, c, d, e) -> (v a, v b, v c, v d, v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => v (a, b, c, d, e, f) -> (v a, v b, v c, v d, v e, v f)

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate.
filter :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate which
--   is applied to the values and their indices.
ifilter :: Vector v a => (Int -> a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop all elements that do not satisfy the monadic
--   predicate.
filterM :: (Monad m, Vector v a) => (a -> m Bool) -> v a -> m (v a)

-- | <i>O(n)</i> Drop repeated adjacent elements. The first element in each
--   group is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.uniq $ V.fromList [1,3,3,200,3]
--   [1,3,200,3]
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.uniq $ V.fromList [ Arg 1 'a', Arg 1 'b', Arg 1 'c']
--   [Arg 1 'a']
--   </pre>
uniq :: (Vector v a, Eq a) => v a -> v a

-- | <i>O(n)</i> Map the values and collect the <a>Just</a> results.
mapMaybe :: (Vector v a, Vector v b) => (a -> Maybe b) -> v a -> v b

-- | <i>O(n)</i> Map the indices/values and collect the <a>Just</a>
--   results.
imapMaybe :: (Vector v a, Vector v b) => (Int -> a -> Maybe b) -> v a -> v b

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and discard elements returning <a>Nothing</a>.
mapMaybeM :: (Monad m, Vector v a, Vector v b) => (a -> m (Maybe b)) -> v a -> m (v b)

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and its index. Discard elements returning <a>Nothing</a>.
imapMaybeM :: (Monad m, Vector v a, Vector v b) => (Int -> a -> m (Maybe b)) -> v a -> m (v b)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate. The current implementation is not copy-free, unless the
--   result vector is fused away.
takeWhile :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Vector v a => (a -> Bool) -> v a -> v a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector into two parts, the first one containing
--   the <tt><tt>Left</tt></tt> elements and the second containing the
--   <tt><tt>Right</tt></tt> elements. The relative order of the elements
--   is preserved.
partitionWith :: (Vector v a, Vector v b, Vector v c) => (a -> Either b c) -> v a -> (v b, v c)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved, but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Vector v a => (a -> Bool) -> v a -> (v a, v a)

-- | <i>O(n)</i> Split a vector into a list of slices.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements, as determined by
--   the equality predicate function.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; import           Data.Char (isUpper)
--   
--   &gt;&gt;&gt; V.groupBy (\a b -&gt; isUpper a == isUpper b) (V.fromList "Mississippi River")
--   ["M","ississippi ","R","iver"]
--   </pre>
--   
--   See also <a>groupBy</a>.
groupBy :: Vector v a => (a -> a -> Bool) -> v a -> [v a]

-- | <i>O(n)</i> Split a vector into a list of slices.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements.
--   
--   This is the equivalent of 'groupBy (==)'.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.group (V.fromList "Mississippi")
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   See also <a>group</a>.
group :: (Vector v a, Eq a) => v a -> [v a]

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: (Vector v a, Eq a) => a -> v a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: (Vector v a, Eq a) => a -> v a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <a>Just</a> the first element matching the predicate
--   or <a>Nothing</a> if no such element exists.
find :: Vector v a => (a -> Bool) -> v a -> Maybe a

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first element matching
--   the predicate or <a>Nothing</a> if no such element exists.
findIndex :: Vector v a => (a -> Bool) -> v a -> Maybe Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the <i>last</i> element
--   matching the predicate or <a>Nothing</a> if no such element exists.
--   
--   Does not fuse.
findIndexR :: Vector v a => (a -> Bool) -> v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: (Vector v a, Vector v Int) => (a -> Bool) -> v a -> v Int

-- | <i>O(n)</i> Yield <a>Just</a> the index of the first occurrence of the
--   given element or <a>Nothing</a> if the vector does not contain the
--   element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Vector v a, Eq a) => a -> v a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurrences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Vector v a, Vector v Int, Eq a) => a -> v a -> v Int

-- | <i>O(n)</i> Left fold.
foldl :: Vector v b => (a -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: Vector v b => (a -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Right fold.
foldr :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: Vector v a => (a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: Vector v a => (a -> a -> a) -> v a -> a

-- | <i>O(n)</i> Left fold using a function applied to each element and its
--   index.
ifoldl :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Left fold with strict accumulator using a function applied
--   to each element and its index.
ifoldl' :: Vector v b => (a -> Int -> b -> a) -> a -> v b -> a

-- | <i>O(n)</i> Right fold using a function applied to each element and
--   its index.
ifoldr :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: Vector v a => (Int -> a -> b -> b) -> b -> v a -> b

-- | <i>O(n)</i> Map each element of the structure to a monoid and combine
--   the results. It uses the same implementation as the corresponding
--   method of the <tt>Foldable</tt> type cless. Note that it's implemented
--   in terms of <a>foldr</a> and won't fuse with functions that traverse
--   the vector from left to right (<a>map</a>, <a>generate</a>, etc.).
foldMap :: (Monoid m, Vector v a) => (a -> m) -> v a -> m

-- | <i>O(n)</i> Like <a>foldMap</a>, but strict in the accumulator. It
--   uses the same implementation as the corresponding method of the
--   <tt>Foldable</tt> type class. Note that it's implemented in terms of
--   <a>foldl'</a>, so it fuses in most contexts.
foldMap' :: (Monoid m, Vector v a) => (a -> m) -> v a -> m

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.all even $ V.fromList [2, 4, 12]
--   True
--   
--   &gt;&gt;&gt; V.all even $ V.fromList [2, 4, 13]
--   False
--   
--   &gt;&gt;&gt; V.all even (V.empty :: V.Vector Int)
--   True
--   </pre>
all :: Vector v a => (a -> Bool) -> v a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.any even $ V.fromList [1, 3, 7]
--   False
--   
--   &gt;&gt;&gt; V.any even $ V.fromList [3, 2, 13]
--   True
--   
--   &gt;&gt;&gt; V.any even (V.empty :: V.Vector Int)
--   False
--   </pre>
any :: Vector v a => (a -> Bool) -> v a -> Bool

-- | <i>O(n)</i> Check if all elements are <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.and $ V.fromList [True, False]
--   False
--   
--   &gt;&gt;&gt; V.and V.empty
--   True
--   </pre>
and :: Vector v Bool => v Bool -> Bool

-- | <i>O(n)</i> Check if any element is <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.or $ V.fromList [True, False]
--   True
--   
--   &gt;&gt;&gt; V.or V.empty
--   False
--   </pre>
or :: Vector v Bool => v Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.sum $ V.fromList [300,20,1]
--   321
--   
--   &gt;&gt;&gt; V.sum (V.empty :: V.Vector Int)
--   0
--   </pre>
sum :: (Vector v a, Num a) => v a -> a

-- | <i>O(n)</i> Compute the product of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.product $ V.fromList [1,2,3,4]
--   24
--   
--   &gt;&gt;&gt; V.product (V.empty :: V.Vector Int)
--   1
--   </pre>
product :: (Vector v a, Num a) => v a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [2, 1]
--   2
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [Arg 1 'a', Arg 2 'b']
--   Arg 2 'b'
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [Arg 1 'a', Arg 1 'b']
--   Arg 1 'a'
--   </pre>
maximum :: (Vector v a, Ord a) => v a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins. This behavior is different from
--   <a>maximumBy</a> which returns the last tie.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximumBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; V.maximumBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
maximumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximumOn fst $ V.fromList [(2,'a'), (1,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; V.maximumOn fst $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
maximumOn :: (Ord b, Vector v a) => (a -> b) -> v a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [2, 1]
--   1
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [Arg 2 'a', Arg 1 'b']
--   Arg 1 'b'
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [Arg 1 'a', Arg 1 'b']
--   Arg 1 'a'
--   </pre>
minimum :: (Vector v a, Ord a) => v a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimumBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; V.minimumBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
minimumBy :: Vector v a => (a -> a -> Ordering) -> v a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimumOn fst $ V.fromList [(2,'a'), (1,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; V.minimumOn fst $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
minimumOn :: (Ord b, Vector v a) => (a -> b) -> v a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Vector v a, Ord a) => v a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minIndexBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   1
--   
--   &gt;&gt;&gt; V.minIndexBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
minIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Vector v a, Ord a) => v a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maxIndexBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   0
--   
--   &gt;&gt;&gt; V.maxIndexBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
maxIndexBy :: Vector v a => (a -> a -> Ordering) -> v a -> Int

-- | <i>O(n)</i> Monadic fold.
foldM :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result using a function
--   applied to each element and its index.
ifoldM_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: (Monad m, Vector v b) => (a -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result using a function applied to each element and its index.
ifoldM'_ :: (Monad m, Vector v b) => (a -> Int -> b -> m a) -> a -> v b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()

-- | <i>O(n)</i> Monad fold over non-empty vectors with strict accumulator
--   that discards the result.
fold1M'_ :: (Monad m, Vector v a) => (a -> a -> m a) -> v a -> m ()

-- | Evaluate each action and collect the results.
sequence :: (Monad m, Vector v a, Vector v (m a)) => v (m a) -> m (v a)

-- | Evaluate each action and discard the results.
sequence_ :: (Monad m, Vector v (m a)) => v (m a) -> m ()

-- | <i>O(n)</i> Left-to-right prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.prescanl (+) 0 (V.fromList [1,2,3,4])
--   [0,1,3,6]
--   </pre>
prescanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right prescan with strict accumulator.
prescanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right postscan.
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.postscanl (+) 0 (V.fromList [1,2,3,4])
--   [1,3,6,10]
--   </pre>
postscanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right postscan with strict accumulator.
postscanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right scan.
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl (+) 0 (V.fromList [1,2,3,4])
--   [0,1,3,6,10]
--   </pre>
scanl :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right scan with strict accumulator.
scanl' :: (Vector v a, Vector v b) => (a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector.
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl1 min $ V.fromListN 5 [4,2,4,1,3]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; V.scanl1 max $ V.fromListN 5 [1,3,2,5,4]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; V.scanl1 min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanl1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector with a
--   strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl1' min $ V.fromListN 5 [4,2,4,1,3]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; V.scanl1' max $ V.fromListN 5 [1,3,2,5,4]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; V.scanl1' min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanl1' :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Left-to-right scan over a vector with its index.
iscanl :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Left-to-right scan over a vector (strictly) with its
--   index.
iscanl' :: (Vector v a, Vector v b) => (Int -> a -> b -> a) -> a -> v b -> v a

-- | <i>O(n)</i> Right-to-left prescan.
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left postscan.
postscanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left postscan with strict accumulator.
postscanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan.
scanr :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
scanr' :: (Vector v a, Vector v b) => (a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanr1 min $ V.fromListN 5 [3,1,4,2,4]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; V.scanr1 max $ V.fromListN 5 [4,5,2,3,1]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; V.scanr1 min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanr1 :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector with
--   a strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanr1' min $ V.fromListN 5 [3,1,4,2,4]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; V.scanr1' max $ V.fromListN 5 [4,5,2,3,1]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; V.scanr1' min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanr1' :: Vector v a => (a -> a -> a) -> v a -> v a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index.
iscanr :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its
--   index.
iscanr' :: (Vector v a, Vector v b) => (Int -> a -> b -> b) -> b -> v a -> v b

-- | <i>O(n)</i> Convert a vector to a list.
toList :: Vector v a => v a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: Vector v a => [a] -> v a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. It's expected that the supplied list will be exactly
--   <tt>n</tt> elements long. As an optimization, this function allocates
--   a buffer for <tt>n</tt> elements, which could be used for DoS-attacks
--   by exhausting the memory if an attacker controls that parameter.
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.fromListN 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; V.fromListN 3 [1]
--   [1]
--   </pre>
fromListN :: Vector v a => Int -> [a] -> v a

-- | <i>O(n)</i> Convert between different vector types.
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)

-- | <i>O(n)</i> Yield a mutable copy of an immutable vector.
thaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (HasCallStack, PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. Note that this is a very dangerous function and
--   generally it's only safe to read from the resulting vector. In this
--   case, the immutable vector could be used safely as well.
--   
--   Problems with mutation happen because GHC has a lot of freedom to
--   introduce sharing. As a result mutable vectors produced by
--   <tt>unsafeThaw</tt> may or may not share the same underlying buffer.
--   For example:
--   
--   <pre>
--   foo = do
--     let vec = V.generate 10 id
--     mvec &lt;- V.unsafeThaw vec
--     do_something mvec
--   </pre>
--   
--   Here GHC could lift <tt>vec</tt> outside of foo which means that all
--   calls to <tt>do_something</tt> will use same buffer with possibly
--   disastrous results. Whether such aliasing happens or not depends on
--   the program in question, optimization levels, and GHC flags.
--   
--   All in all, attempts to modify a vector produced by
--   <tt>unsafeThaw</tt> fall out of domain of software engineering and
--   into realm of black magic, dark rituals, and unspeakable horrors. The
--   only advice that could be given is: "Don't attempt to mutate a vector
--   produced by <tt>unsafeThaw</tt> unless you know how to prevent GHC
--   from aliasing buffers accidentally. We don't."
unsafeThaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> v a -> m ()

-- | <i>O(1)</i> Convert a vector to a <a>Bundle</a>.
stream :: Vector v a => v a -> Bundle v a

-- | <i>O(n)</i> Construct a vector from a <a>Bundle</a>.
unstream :: Vector v a => Bundle v a -> v a

-- | Load a monadic stream bundle into a newly allocated vector. This
--   function goes through a list, so prefer using <a>unstream</a>, unless
--   you need to be in a monad.
unstreamM :: (Monad m, Vector v a) => MBundle m u a -> m (v a)

-- | <i>O(1)</i> Convert a vector to a <a>Bundle</a>, proceeding from right
--   to left.
streamR :: Vector v a => v a -> Bundle u a

-- | <i>O(n)</i> Construct a vector from a <a>Bundle</a>, proceeding from
--   right to left.
unstreamR :: Vector v a => Bundle v a -> v a

-- | Construct a vector from a monadic initialiser.
new :: Vector v a => New v a -> v a

-- | Convert a vector to an initialiser which, when run, produces a copy of
--   the vector.
clone :: Vector v a => v a -> New v a

-- | <i>O(n)</i> Check if two vectors are equal. All <a>Vector</a>
--   instances are also instances of <a>Eq</a> and it is usually more
--   appropriate to use those. This function is primarily intended for
--   implementing <a>Eq</a> instances for new vector types.
eq :: (Vector v a, Eq a) => v a -> v a -> Bool

-- | <i>O(n)</i> Compare two vectors lexicographically. All <a>Vector</a>
--   instances are also instances of <a>Ord</a> and it is usually more
--   appropriate to use those. This function is primarily intended for
--   implementing <a>Ord</a> instances for new vector types.
cmp :: (Vector v a, Ord a) => v a -> v a -> Ordering

-- | <i>O(n)</i> Check if two vectors are equal using the supplied equality
--   predicate.
eqBy :: (Vector v a, Vector v b) => (a -> b -> Bool) -> v a -> v b -> Bool

-- | <i>O(n)</i> Compare two vectors using the supplied comparison function
--   for vector elements. Comparison works the same as for lists.
--   
--   <pre>
--   cmpBy compare == cmp
--   </pre>
cmpBy :: (Vector v a, Vector v b) => (a -> b -> Ordering) -> v a -> v b -> Ordering

-- | Generic definition of <a>showsPrec</a>.
showsPrec :: (Vector v a, Show a) => Int -> v a -> ShowS

-- | Generic definition of <a>readPrec</a>.
readPrec :: (Vector v a, Read a) => ReadPrec (v a)
liftShowsPrec :: Vector v a => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> v a -> ShowS

-- | <i>Note:</i> uses <a>ReadS</a>.
liftReadsPrec :: Vector v a => (Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (v a)

-- | Generic definion of <a>gfoldl</a> that views a <a>Vector</a> as a
--   list.
gfoldl :: (Vector v a, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> v a -> c (v a)
gunfold :: (Vector v a, Data a, HasCallStack) => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c (v a)
dataCast :: (Vector v a, Data a, Typeable v, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c (v a))
mkVecType :: String -> DataType
mkVecConstr :: String -> Constr

-- | <i>Deprecated: Use Data.Data.mkNoRepType</i>
mkType :: String -> DataType


-- | Mutable boxed vectors.
module Data.Vector.Mutable

-- | Mutable boxed vectors keyed on the monad they live in (<tt>IO</tt> or
--   <tt><tt>ST</tt> s</tt>).
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableArray s a -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | Length of the mutable vector.
length :: MVector s a -> Int

-- | Check whether the vector is empty.
null :: MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it. The vector must
--   contain at least <tt>i+n</tt> elements.
slice :: Int -> Int -> MVector s a -> MVector s a

-- | Drop the last element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
init :: MVector s a -> MVector s a

-- | Drop the first element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
tail :: MVector s a -> MVector s a

-- | Take the <tt>n</tt> first elements of the mutable vector without
--   making a copy. For negative <tt>n</tt>, the empty vector is returned.
--   If <tt>n</tt> is larger than the vector's length, the vector is
--   returned unchanged.
take :: Int -> MVector s a -> MVector s a

-- | Drop the <tt>n</tt> first element of the mutable vector without making
--   a copy. For negative <tt>n</tt>, the vector is returned unchanged. If
--   <tt>n</tt> is larger than the vector's length, the empty vector is
--   returned.
drop :: Int -> MVector s a -> MVector s a

-- | <i>O(1)</i> Split the mutable vector into the first <tt>n</tt>
--   elements and the remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Int -> Int -> MVector s a -> MVector s a

-- | Same as <a>init</a>, but doesn't do range checks.
unsafeInit :: MVector s a -> MVector s a

-- | Same as <a>tail</a>, but doesn't do range checks.
unsafeTail :: MVector s a -> MVector s a

-- | Unsafe variant of <a>take</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeTake :: Int -> MVector s a -> MVector s a

-- | Unsafe variant of <a>drop</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeDrop :: Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The vector elements are
--   set to bottom, so accessing them will cause an exception.
unsafeNew :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: PrimMonad m => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: PrimMonad m => Int -> m a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   function to each index. Iteration starts at index 0.
generate :: PrimMonad m => Int -> (Int -> a) -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   monadic function to each index. Iteration starts at index 0.
generateM :: PrimMonad m => Int -> (Int -> m a) -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: PrimMonad m => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a boxed vector by the given number of elements. The number must
--   be non-negative. This has the same semantics as <a>grow</a> for
--   generic vectors. It differs from <tt>grow</tt> functions for unpacked
--   vectors, however, in that only pointers to values are copied over,
--   therefore the values themselves will be shared between the two
--   vectors. This is an important distinction to know about during memory
--   usage analysis and in case the values themselves are of a mutable
--   type, e.g. <a>IORef</a> or another mutable vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; mv &lt;- V.thaw $ V.fromList ([10, 20, 30] :: [Integer])
--   
--   &gt;&gt;&gt; mv' &lt;- MV.grow mv 2
--   </pre>
--   
--   The two extra elements at the end of the newly allocated vector will
--   be uninitialized and will result in an error if evaluated, so me must
--   overwrite them with new values first:
--   
--   <pre>
--   &gt;&gt;&gt; MV.write mv' 3 999
--   
--   &gt;&gt;&gt; MV.write mv' 4 777
--   
--   &gt;&gt;&gt; V.freeze mv'
--   [10,20,30,999,777]
--   </pre>
--   
--   It is important to note that the source mutable vector is not affected
--   when the newly allocated one is mutated.
--   
--   <pre>
--   &gt;&gt;&gt; MV.write mv' 2 888
--   
--   &gt;&gt;&gt; V.freeze mv'
--   [10,20,888,999,777]
--   
--   &gt;&gt;&gt; V.freeze mv
--   [10,20,30]
--   </pre>
grow :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   non-negative, but this is not checked. This has the same semantics as
--   <a>unsafeGrow</a> for generic vectors.
unsafeGrow :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects.
clear :: PrimMonad m => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position. Will throw an exception if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; v &lt;- MV.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MV.read v 3
--   9
--   </pre>
read :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Yield the element at the given position. Returns <tt>Nothing</tt> if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; v &lt;- MV.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MV.readMaybe v 3
--   Just 9
--   
--   &gt;&gt;&gt; MV.readMaybe v 13
--   Nothing
--   </pre>
readMaybe :: PrimMonad m => MVector (PrimState m) a -> Int -> m (Maybe a)

-- | Replace the element at the given position.
write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: PrimMonad m => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function.
modifyM :: PrimMonad m => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: PrimMonad m => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
exchange :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: PrimMonad m => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function. No
--   bounds checks are performed.
unsafeModifyM :: PrimMonad m => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: PrimMonad m => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m a

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results.
mapM_ :: PrimMonad m => (a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results.
imapM_ :: PrimMonad m => (Int -> a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results. It's the same as <tt>flip mapM_</tt>.
forM_ :: PrimMonad m => MVector (PrimState m) a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results. It's the same as <tt>flip
--   imapM_</tt>.
iforM_ :: PrimMonad m => MVector (PrimState m) a -> (Int -> a -> m b) -> m ()

-- | <i>O(n)</i> Pure left fold.
foldl :: PrimMonad m => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator.
foldl' :: PrimMonad m => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold.
foldM :: PrimMonad m => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: PrimMonad m => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold.
foldr :: PrimMonad m => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator.
foldr' :: PrimMonad m => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold.
foldrM :: PrimMonad m => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator.
foldrM' :: PrimMonad m => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold using a function applied to each element
--   and its index.
ifoldl :: PrimMonad m => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator using a function
--   applied to each element and its index.
ifoldl' :: PrimMonad m => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: PrimMonad m => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: PrimMonad m => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold using a function applied to each element
--   and its index.
ifoldr :: PrimMonad m => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: PrimMonad m => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold using a function applied to each
--   element and its index.
ifoldrM :: PrimMonad m => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator using a
--   function applied to each element and its index.
ifoldrM' :: PrimMonad m => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | Compute the (lexicographically) next permutation of the given vector
--   in-place. Returns False when the input is the last permutation.
nextPermutation :: (PrimMonad m, Ord e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: PrimMonad m => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap, but this is not checked.
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Make a copy of a mutable array to a new mutable vector.
fromMutableArray :: PrimMonad m => MutableArray (PrimState m) a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Make a copy of a mutable vector into a new mutable array.
toMutableArray :: PrimMonad m => MVector (PrimState m) a -> m (MutableArray (PrimState m) a)

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type)

-- | State token type.
type family PrimState (m :: Type -> Type)

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Mutable.MVector a


-- | A library for boxed vectors (that is, polymorphic arrays capable of
--   holding any Haskell value). The vectors come in two flavours:
--   
--   <ul>
--   <li>mutable</li>
--   <li>immutable</li>
--   </ul>
--   
--   They support a rich interface of both list-like operations and bulk
--   array operations.
--   
--   For unboxed arrays, use <a>Data.Vector.Unboxed</a>.
module Data.Vector

-- | Boxed vectors, supporting efficient slicing.
data Vector a

-- | Mutable boxed vectors keyed on the monad they live in (<tt>IO</tt> or
--   <tt><tt>ST</tt> s</tt>).
data MVector s a

-- | <i>O(1)</i> Yield the length of the vector.
length :: Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty.
null :: Vector a -> Bool

-- | O(1) Indexing.
(!) :: Vector a -> Int -> a

-- | O(1) Safe indexing.
(!?) :: Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element.
head :: Vector a -> a

-- | <i>O(1)</i> Last element.
last :: Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking.
unsafeIndex :: Vector a -> Int -> a

-- | <i>O(1)</i> First element, without checking if the vector is empty.
unsafeHead :: Vector a -> a

-- | <i>O(1)</i> Last element, without checking if the vector is empty.
unsafeLast :: Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the element) is evaluated eagerly.
indexM :: Monad m => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad, without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: Monad m => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: Monad m => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements, in which case it
--   is returned unchanged.
take :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements, in
--   which case an empty vector is returned.
drop :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield the <a>head</a> and <a>tail</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
uncons :: Vector a -> Maybe (a, Vector a)

-- | <i>O(1)</i> Yield the <a>last</a> and <a>init</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
unsnoc :: Vector a -> Maybe (Vector a, a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements, but this is not checked.
unsafeSlice :: Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty, but this is not checked.
unsafeInit :: Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty, but this is not checked.
unsafeTail :: Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements, but this is not
--   checked.
unsafeTake :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements, but
--   this is not checked.
unsafeDrop :: Int -> Vector a -> Vector a

-- | <i>O(1)</i> The empty vector.
empty :: Vector a

-- | <i>O(1)</i> A vector with exactly one element.
singleton :: a -> Vector a

-- | <i>O(n)</i> A vector of the given length with the same value in each
--   position.
replicate :: Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
generate :: Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply the function &lt;math&gt; times to an initial value,
--   producing a vector of length &lt;math&gt;. The 0th element will
--   contain the initial value, which is why there is one less function
--   application than the number of elements in the produced vector.
--   
--   &lt;math&gt;
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.iterateN 0 undefined undefined :: V.Vector String
--   []
--   
--   &gt;&gt;&gt; V.iterateN 4 (\x -&gt; x &lt;&gt; x) "Hi"
--   ["Hi","HiHi","HiHiHiHi","HiHiHiHiHiHiHiHi"]
--   </pre>
iterateN :: Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: Monad m => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index.
generateM :: Monad m => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply the monadic function &lt;math&gt; times to an
--   initial value, producing a vector of length &lt;math&gt;. The 0th
--   element will contain the initial value, which is why there is one less
--   function application than the number of elements in the produced
--   vector.
--   
--   For a non-monadic version, see <a>iterateN</a>.
iterateNM :: Monad m => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: Traversable f => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <tt>Just</tt> the
--   next element and the new seed or <tt>Nothing</tt> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <tt>Just</tt> the next element and the new seed or
--   <tt>Nothing</tt> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields the next element and the new seed.
--   
--   <pre>
--   unfoldrExactN 3 (\n -&gt; (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrExactN :: Int -> (b -> (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrM :: Monad m => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrNM :: Monad m => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the monadic generator function to a seed. The
--   generator function yields the next element and the new seed.
unfoldrExactNM :: Monad m => Int -> (b -> m (a, b)) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in &lt;a,b,c&gt;
--   </pre>
constructN :: Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in &lt;c,b,a&gt;
--   </pre>
constructrN :: Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: Num a => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 2 5 = &lt;1,3,5,7,9&gt;
--   </pre>
enumFromStepN :: Num a => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromN</a> instead.
enumFromTo :: Enum a => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromStepN</a> instead.
enumFromThenTo :: Enum a => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element.
cons :: a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element.
snoc :: Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list.
concat :: [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument, but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: Vector a -> Vector (Int, a) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   The function <a>update</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>), but without bounds checking.
unsafeUpd :: Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update</a>, but without bounds checking.
unsafeUpdate :: Vector a -> Vector (Int, a) -> Vector a

-- | Same as <a>update_</a>, but without bounds checking.
unsafeUpdate_ :: Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.accum (+) (V.fromList [1000,2000,3000]) [(2,4),(1,6),(0,3),(1,10)]
--   [1003,2016,3004]
--   </pre>
accum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.accumulate (+) (V.fromList [1000,2000,3000]) (V.fromList [(2,4),(1,6),(0,3),(1,10)])
--   [1003,2016,3004]
--   </pre>
accumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   The function <a>accumulate</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a>, but without bounds checking.
unsafeAccum :: (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate</a>, but without bounds checking.
unsafeAccumulate :: (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | Same as <a>accumulate_</a>, but without bounds checking.
unsafeAccumulate_ :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector.
reverse :: Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt>, but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a>, but without bounds checking.
unsafeBackpermute :: Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation may be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise (see <a>New</a> for details).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Mutable as MV
--   
--   &gt;&gt;&gt; V.modify (\v -&gt; MV.write v 0 'x') $ V.replicate 4 'a'
--   "xaaa"
--   </pre>
modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: Vector a -> Vector (Int, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: Monad m => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: Monad m => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: Monad m => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: Monad m => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: Monad m => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: Monad m => Vector a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices, yielding a vector of results. Equivalent to
--   <tt><a>flip</a> <a>imapM</a></tt>.
iforM :: Monad m => Vector a -> (Int -> a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices and ignore the results. Equivalent to <tt><a>flip</a>
--   <a>imapM_</a></tt>.
iforM_ :: Monad m => Vector a -> (Int -> a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors.
zip :: Vector a -> Vector b -> Vector (a, b)

-- | Zip together three vectors into a vector of triples.
zip3 :: Vector a -> Vector b -> Vector c -> Vector (a, b, c)
zip4 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)
zip5 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)
zip6 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results.
zipWithM :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results.
izipWithM :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results.
zipWithM_ :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results.
izipWithM_ :: Monad m => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Unzip a vector of pairs.
unzip :: Vector (a, b) -> (Vector a, Vector b)
unzip3 :: Vector (a, b, c) -> (Vector a, Vector b, Vector c)
unzip4 :: Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
unzip5 :: Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)
unzip6 :: Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate.
filter :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate which
--   is applied to the values and their indices.
ifilter :: (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the monadic
--   predicate.
filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Drop repeated adjacent elements. The first element in each
--   group is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.uniq $ V.fromList [1,3,3,200,3]
--   [1,3,200,3]
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.uniq $ V.fromList [ Arg 1 'a', Arg 1 'b', Arg 1 'c']
--   [Arg 1 'a']
--   </pre>
uniq :: Eq a => Vector a -> Vector a

-- | <i>O(n)</i> Map the values and collect the <tt>Just</tt> results.
mapMaybe :: (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Map the indices/values and collect the <tt>Just</tt>
--   results.
imapMaybe :: (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and discard elements returning <tt>Nothing</tt>.
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and its index. Discard elements returning <tt>Nothing</tt>.
imapMaybeM :: Monad m => (Int -> a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Return a Vector of all the <tt>Just</tt> values.
catMaybes :: Vector (Maybe a) -> Vector a

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate. The current implementation is not copy-free, unless the
--   result vector is fused away.
takeWhile :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved, but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into two parts, the first one containing
--   the <tt><tt>Left</tt></tt> elements and the second containing the
--   <tt><tt>Right</tt></tt> elements. The relative order of the elements
--   is preserved.
partitionWith :: (a -> Either b c) -> Vector a -> (Vector b, Vector c)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split a vector into a list of slices, using a predicate
--   function.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements, as determined by
--   the equality predicate function.
--   
--   Does not fuse.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; import           Data.Char (isUpper)
--   
--   &gt;&gt;&gt; V.groupBy (\a b -&gt; isUpper a == isUpper b) (V.fromList "Mississippi River")
--   ["M","ississippi ","R","iver"]
--   </pre>
--   
--   See also <a>groupBy</a>, <a>group</a>.
groupBy :: (a -> a -> Bool) -> Vector a -> [Vector a]

-- | <i>O(n)</i> Split a vector into a list of slices of the input vector.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements.
--   
--   Does not fuse.
--   
--   This is the equivalent of 'groupBy (==)'.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.group (V.fromList "Mississippi")
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   See also <a>group</a>.
group :: Eq a => Vector a -> [Vector a]

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: Eq a => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: Eq a => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <tt>Just</tt> the first element matching the
--   predicate or <tt>Nothing</tt> if no such element exists.
find :: (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
findIndex :: (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the <i>last</i> element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
--   
--   Does not fuse.
findIndexR :: (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first occurrence of
--   the given element or <tt>Nothing</tt> if the vector does not contain
--   the element. This is a specialised version of <a>findIndex</a>.
elemIndex :: Eq a => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurrences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: Eq a => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold.
foldl :: (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold.
foldr :: (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold using a function applied to each element and its
--   index.
ifoldl :: (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator using a function applied
--   to each element and its index.
ifoldl' :: (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold using a function applied to each element and
--   its index.
ifoldr :: (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Map each element of the structure to a monoid and combine
--   the results. It uses the same implementation as the corresponding
--   method of the <tt>Foldable</tt> type class. Note that it's implemented
--   in terms of <a>foldr</a> and won't fuse with functions that traverse
--   the vector from left to right (<a>map</a>, <a>generate</a>, etc.).
foldMap :: Monoid m => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Like <a>foldMap</a>, but strict in the accumulator. It
--   uses the same implementation as the corresponding method of the
--   <tt>Foldable</tt> type class. Note that it's implemented in terms of
--   <a>foldl'</a>, so it fuses in most contexts.
foldMap' :: Monoid m => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.all even $ V.fromList [2, 4, 12]
--   True
--   
--   &gt;&gt;&gt; V.all even $ V.fromList [2, 4, 13]
--   False
--   
--   &gt;&gt;&gt; V.all even (V.empty :: V.Vector Int)
--   True
--   </pre>
all :: (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.any even $ V.fromList [1, 3, 7]
--   False
--   
--   &gt;&gt;&gt; V.any even $ V.fromList [3, 2, 13]
--   True
--   
--   &gt;&gt;&gt; V.any even (V.empty :: V.Vector Int)
--   False
--   </pre>
any :: (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.and $ V.fromList [True, False]
--   False
--   
--   &gt;&gt;&gt; V.and V.empty
--   True
--   </pre>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.or $ V.fromList [True, False]
--   True
--   
--   &gt;&gt;&gt; V.or V.empty
--   False
--   </pre>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.sum $ V.fromList [300,20,1]
--   321
--   
--   &gt;&gt;&gt; V.sum (V.empty :: V.Vector Int)
--   0
--   </pre>
sum :: Num a => Vector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.product $ V.fromList [1,2,3,4]
--   24
--   
--   &gt;&gt;&gt; V.product (V.empty :: V.Vector Int)
--   1
--   </pre>
product :: Num a => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [2, 1]
--   2
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [Arg 1 'a', Arg 2 'b']
--   Arg 2 'b'
--   
--   &gt;&gt;&gt; V.maximum $ V.fromList [Arg 1 'a', Arg 1 'b']
--   Arg 1 'a'
--   </pre>
maximum :: Ord a => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins. This behavior is different from
--   <a>maximumBy</a> which returns the last tie.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximumBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; V.maximumBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
maximumBy :: (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maximumOn fst $ V.fromList [(2,'a'), (1,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; V.maximumOn fst $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
maximumOn :: Ord b => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [2, 1]
--   1
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [Arg 2 'a', Arg 1 'b']
--   Arg 1 'b'
--   
--   &gt;&gt;&gt; V.minimum $ V.fromList [Arg 1 'a', Arg 1 'b']
--   Arg 1 'a'
--   </pre>
minimum :: Ord a => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimumBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; V.minimumBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
minimumBy :: (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minimumOn fst $ V.fromList [(2,'a'), (1,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; V.minimumOn fst $ V.fromList [(1,'a'), (1,'b')]
--   (1,'a')
--   </pre>
minimumOn :: Ord b => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: Ord a => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.minIndexBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   1
--   
--   &gt;&gt;&gt; V.minIndexBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
minIndexBy :: (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: Ord a => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.maxIndexBy (comparing fst) $ V.fromList [(2,'a'), (1,'b')]
--   0
--   
--   &gt;&gt;&gt; V.maxIndexBy (comparing fst) $ V.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
maxIndexBy :: (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold.
foldM :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: Monad m => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: Monad m => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result using a function
--   applied to each element and its index.
ifoldM_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result using a function applied to each element and its index.
ifoldM'_ :: Monad m => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result.
fold1M'_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()

-- | Evaluate each action and collect the results.
sequence :: Monad m => Vector (m a) -> m (Vector a)

-- | Evaluate each action and discard the results.
sequence_ :: Monad m => Vector (m a) -> m ()

-- | <i>O(n)</i> Left-to-right prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.prescanl (+) 0 (V.fromList [1,2,3,4])
--   [0,1,3,6]
--   </pre>
prescanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right prescan with strict accumulator.
prescanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan.
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.postscanl (+) 0 (V.fromList [1,2,3,4])
--   [1,3,6,10]
--   </pre>
postscanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan with strict accumulator.
postscanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan.
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl (+) 0 (V.fromList [1,2,3,4])
--   [0,1,3,6,10]
--   </pre>
scanl :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan with strict accumulator.
scanl' :: (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector.
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl1 min $ V.fromListN 5 [4,2,4,1,3]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; V.scanl1 max $ V.fromListN 5 [1,3,2,5,4]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; V.scanl1 min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanl1 :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector with a
--   strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanl1' min $ V.fromListN 5 [4,2,4,1,3]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; V.scanl1' max $ V.fromListN 5 [1,3,2,5,4]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; V.scanl1' min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanl1' :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector with its index.
iscanl :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector (strictly) with its
--   index.
iscanl' :: (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Right-to-left prescan.
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan.
postscanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan with strict accumulator.
postscanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan.
scanr :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
scanr' :: (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanr1 min $ V.fromListN 5 [3,1,4,2,4]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; V.scanr1 max $ V.fromListN 5 [4,5,2,3,1]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; V.scanr1 min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanr1 :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector with
--   a strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; V.scanr1' min $ V.fromListN 5 [3,1,4,2,4]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; V.scanr1' max $ V.fromListN 5 [4,5,2,3,1]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; V.scanr1' min (V.empty :: V.Vector Int)
--   []
--   </pre>
scanr1' :: (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index.
iscanr :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its
--   index.
iscanr' :: (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Check if two vectors are equal using the supplied equality
--   predicate.
eqBy :: (a -> b -> Bool) -> Vector a -> Vector b -> Bool

-- | <i>O(n)</i> Compare two vectors using the supplied comparison function
--   for vector elements. Comparison works the same as for lists.
--   
--   <pre>
--   cmpBy compare == compare
--   </pre>
cmpBy :: (a -> b -> Ordering) -> Vector a -> Vector b -> Ordering

-- | <i>O(n)</i> Convert a vector to a list.
toList :: Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. It's expected that the supplied list will be exactly
--   <tt>n</tt> elements long. As an optimization, this function allocates
--   a buffer for <tt>n</tt> elements, which could be used for DoS-attacks
--   by exhausting the memory if an attacker controls that parameter.
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
fromListN :: Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert a vector to an array.
toArray :: Vector a -> Array a

-- | <i>O(1)</i> Convert an array to a vector.
fromArray :: Array a -> Vector a

-- | <i>O(1)</i> Extract the underlying <a>Array</a>, offset where vector
--   starts and the total number of elements in the vector. Below property
--   always holds:
--   
--   <pre>
--   let (array, offset, len) = toArraySlice v
--   v === unsafeFromArraySlice len offset array
--   </pre>
toArraySlice :: Vector a -> (Array a, Int, Int)

-- | <i>O(1)</i> Convert an array slice to a vector. This function is very
--   unsafe, because constructing an invalid vector can yield almost all
--   other safe functions in this module unsafe. These are equivalent:
--   
--   <pre>
--   unsafeFromArraySlice len offset === unsafeTake len . unsafeDrop offset . fromArray
--   </pre>
unsafeFromArraySlice :: Array a -> Int -> Int -> Vector a

-- | <i>O(n)</i> Convert between different vector types.
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of an immutable vector.
thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. Note that this is a very dangerous function and
--   generally it's only safe to read from the resulting vector. In this
--   case, the immutable vector could be used safely as well.
--   
--   Problems with mutation happen because GHC has a lot of freedom to
--   introduce sharing. As a result mutable vectors produced by
--   <tt>unsafeThaw</tt> may or may not share the same underlying buffer.
--   For example:
--   
--   <pre>
--   foo = do
--     let vec = V.generate 10 id
--     mvec &lt;- V.unsafeThaw vec
--     do_something mvec
--   </pre>
--   
--   Here GHC could lift <tt>vec</tt> outside of foo which means that all
--   calls to <tt>do_something</tt> will use same buffer with possibly
--   disastrous results. Whether such aliasing happens or not depends on
--   the program in question, optimization levels, and GHC flags.
--   
--   All in all, attempts to modify a vector produced by
--   <tt>unsafeThaw</tt> fall out of domain of software engineering and
--   into realm of black magic, dark rituals, and unspeakable horrors. The
--   only advice that could be given is: "Don't attempt to mutate a vector
--   produced by <tt>unsafeThaw</tt> unless you know how to prevent GHC
--   from aliasing buffers accidentally. We don't."
unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Vector.Vector a)
instance Control.DeepSeq.NFData1 Data.Vector.Vector
instance GHC.Show.Show a => GHC.Show.Show (Data.Vector.Vector a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Vector.Vector a)
instance Data.Functor.Classes.Show1 Data.Vector.Vector
instance Data.Functor.Classes.Read1 Data.Vector.Vector
instance GHC.IsList.IsList (Data.Vector.Vector a)
instance Data.Data.Data a => Data.Data.Data (Data.Vector.Vector a)
instance Data.Vector.Generic.Base.Vector Data.Vector.Vector a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Vector.Vector a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Vector.Vector a)
instance Data.Functor.Classes.Eq1 Data.Vector.Vector
instance Data.Functor.Classes.Ord1 Data.Vector.Vector
instance GHC.Base.Semigroup (Data.Vector.Vector a)
instance GHC.Base.Monoid (Data.Vector.Vector a)
instance GHC.Base.Functor Data.Vector.Vector
instance GHC.Base.Monad Data.Vector.Vector
instance Control.Monad.Fail.MonadFail Data.Vector.Vector
instance GHC.Base.MonadPlus Data.Vector.Vector
instance Control.Monad.Zip.MonadZip Data.Vector.Vector
instance Control.Monad.Fix.MonadFix Data.Vector.Vector
instance GHC.Base.Applicative Data.Vector.Vector
instance GHC.Base.Alternative Data.Vector.Vector
instance Data.Foldable.Foldable Data.Vector.Vector
instance Data.Traversable.Traversable Data.Vector.Vector


-- | Mutable primitive vectors.
module Data.Vector.Primitive.Mutable

-- | Mutable vectors of primitive types.
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableByteArray s -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | Length of the mutable vector.
length :: Prim a => MVector s a -> Int

-- | Check whether the vector is empty.
null :: Prim a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it. The vector must
--   contain at least <tt>i+n</tt> elements.
slice :: Prim a => Int -> Int -> MVector s a -> MVector s a

-- | Drop the last element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
init :: Prim a => MVector s a -> MVector s a

-- | Drop the first element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
tail :: Prim a => MVector s a -> MVector s a

-- | Take the <tt>n</tt> first elements of the mutable vector without
--   making a copy. For negative <tt>n</tt>, the empty vector is returned.
--   If <tt>n</tt> is larger than the vector's length, the vector is
--   returned unchanged.
take :: Prim a => Int -> MVector s a -> MVector s a

-- | Drop the <tt>n</tt> first element of the mutable vector without making
--   a copy. For negative <tt>n</tt>, the vector is returned unchanged. If
--   <tt>n</tt> is larger than the vector's length, the empty vector is
--   returned.
drop :: Prim a => Int -> MVector s a -> MVector s a

-- | <i>O(1)</i> Split the mutable vector into the first <tt>n</tt>
--   elements and the remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Prim a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Prim a => Int -> Int -> MVector s a -> MVector s a

-- | Same as <a>init</a>, but doesn't do range checks.
unsafeInit :: Prim a => MVector s a -> MVector s a

-- | Same as <a>tail</a>, but doesn't do range checks.
unsafeTail :: Prim a => MVector s a -> MVector s a

-- | Unsafe variant of <a>take</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeTake :: Prim a => Int -> MVector s a -> MVector s a

-- | Unsafe variant of <a>drop</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeDrop :: Prim a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Prim a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Prim a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The vector content is
--   uninitialized, which means it is filled with whatever the underlying
--   memory buffer happens to contain.
unsafeNew :: (PrimMonad m, Prim a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Prim a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Prim a) => Int -> m a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   function to each index. Iteration starts at index 0.
generate :: (PrimMonad m, Prim a) => Int -> (Int -> a) -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   monadic function to each index. Iteration starts at index 0.
generateM :: (PrimMonad m, Prim a) => Int -> (Int -> m a) -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a primitive vector by the given number of elements. The number
--   must be non-negative. This has the same semantics as <a>grow</a> for
--   generic vectors.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive.Mutable as MVP
--   
--   &gt;&gt;&gt; mv &lt;- VP.thaw $ VP.fromList ([10, 20, 30] :: [Int])
--   
--   &gt;&gt;&gt; mv' &lt;- MVP.grow mv 2
--   </pre>
--   
--   Extra memory at the end of the newly allocated vector is initialized
--   to 0 bytes, which for <a>Prim</a> instances will usually correspond to
--   some default value for a particular type, e.g. <tt>0</tt> for
--   <tt>Int</tt>, <tt>NUL</tt> for <tt>Char</tt>, etc. However, if
--   <a>unsafeGrow</a> was used instead, this would not have been
--   guaranteed and some garbage would be there instead.
--   
--   <pre>
--   &gt;&gt;&gt; VP.freeze mv'
--   [10,20,30,0,0]
--   </pre>
--   
--   Having the extra space we can write new values in there:
--   
--   <pre>
--   &gt;&gt;&gt; MVP.write mv' 3 999
--   
--   &gt;&gt;&gt; VP.freeze mv'
--   [10,20,30,999,0]
--   </pre>
--   
--   It is important to note that the source mutable vector is not affected
--   when the newly allocated one is mutated.
--   
--   <pre>
--   &gt;&gt;&gt; MVP.write mv' 2 888
--   
--   &gt;&gt;&gt; VP.freeze mv'
--   [10,20,888,999,0]
--   
--   &gt;&gt;&gt; VP.freeze mv
--   [10,20,30]
--   </pre>
grow :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   non-negative, but this is not checked. This has the same semantics as
--   <a>unsafeGrow</a> for generic vectors.
unsafeGrow :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is a noop.
clear :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position. Will throw an exception if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive.Mutable as MVP
--   
--   &gt;&gt;&gt; v &lt;- MVP.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVP.read v 3
--   9
--   </pre>
read :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m a

-- | Yield the element at the given position. Returns <tt>Nothing</tt> if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive.Mutable as MVP
--   
--   &gt;&gt;&gt; v &lt;- MVP.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVP.readMaybe v 3
--   Just 9
--   
--   &gt;&gt;&gt; MVP.readMaybe v 13
--   Nothing
--   </pre>
readMaybe :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m (Maybe a)

-- | Replace the element at the given position.
write :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function.
modifyM :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
exchange :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function. No
--   bounds checks are performed.
unsafeModifyM :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> Int -> a -> m a

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results.
mapM_ :: (PrimMonad m, Prim a) => (a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results.
imapM_ :: (PrimMonad m, Prim a) => (Int -> a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results. It's the same as <tt>flip mapM_</tt>.
forM_ :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results. It's the same as <tt>flip
--   imapM_</tt>.
iforM_ :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> (Int -> a -> m b) -> m ()

-- | <i>O(n)</i> Pure left fold.
foldl :: (PrimMonad m, Prim a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator.
foldl' :: (PrimMonad m, Prim a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold.
foldM :: (PrimMonad m, Prim a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (PrimMonad m, Prim a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold.
foldr :: (PrimMonad m, Prim a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator.
foldr' :: (PrimMonad m, Prim a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold.
foldrM :: (PrimMonad m, Prim a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator.
foldrM' :: (PrimMonad m, Prim a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold using a function applied to each element
--   and its index.
ifoldl :: (PrimMonad m, Prim a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator using a function
--   applied to each element and its index.
ifoldl' :: (PrimMonad m, Prim a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (PrimMonad m, Prim a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (PrimMonad m, Prim a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold using a function applied to each element
--   and its index.
ifoldr :: (PrimMonad m, Prim a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: (PrimMonad m, Prim a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold using a function applied to each
--   element and its index.
ifoldrM :: (PrimMonad m, Prim a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator using a
--   function applied to each element and its index.
ifoldrM' :: (PrimMonad m, Prim a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | Compute the (lexicographically) next permutation of the given vector
--   in-place. Returns False when the input is the last permutation.
nextPermutation :: (PrimMonad m, Ord e, Prim e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap, but this is not checked.
unsafeCopy :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Prim a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | <i>O(1)</i> Unsafely coerce a mutable vector from one element type to
--   another, representationally equal type. The operation just changes the
--   type of the underlying pointer and does not modify the elements.
--   
--   Note that this function is unsafe. The <tt>Coercible</tt> constraint
--   guarantees that the element types are representationally equal. It
--   however cannot guarantee that their respective <a>Prim</a> instances
--   are compatible.
unsafeCoerceMVector :: Coercible a b => MVector s a -> MVector s b

-- | <i>O(1)</i> Unsafely cast a vector from one element type to another.
--   This operation just changes the type of the vector and does not modify
--   the elements.
--   
--   This function will throw an error if elements are of mismatching
--   sizes.
--   
--   | @since 0.13.0.0
unsafeCast :: forall a b s. (HasCallStack, Prim a, Prim b) => MVector s a -> MVector s b

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class () => Prim a

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type)

-- | State token type.
type family PrimState (m :: Type -> Type)

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
instance Control.DeepSeq.NFData (Data.Vector.Primitive.Mutable.MVector s a)
instance Control.DeepSeq.NFData1 (Data.Vector.Primitive.Mutable.MVector s)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Primitive.Mutable.MVector a


-- | Unboxed vectors of primitive types. The use of this module is not
--   recommended except in very special cases. Adaptive unboxed vectors
--   defined in <a>Data.Vector.Unboxed</a> are significantly more flexible
--   at no performance cost.
module Data.Vector.Primitive

-- | Unboxed vectors of primitive types.
data Vector a
Vector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !ByteArray -> Vector a

-- | Mutable vectors of primitive types.
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !MutableByteArray s -> MVector s a

-- | <i>O(1)</i> Yield the length of the vector.
length :: Prim a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty.
null :: Prim a => Vector a -> Bool

-- | O(1) Indexing.
(!) :: Prim a => Vector a -> Int -> a

-- | O(1) Safe indexing.
(!?) :: Prim a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element.
head :: Prim a => Vector a -> a

-- | <i>O(1)</i> Last element.
last :: Prim a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking.
unsafeIndex :: Prim a => Vector a -> Int -> a

-- | <i>O(1)</i> First element, without checking if the vector is empty.
unsafeHead :: Prim a => Vector a -> a

-- | <i>O(1)</i> Last element, without checking if the vector is empty.
unsafeLast :: Prim a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the element) is evaluated eagerly.
indexM :: (Prim a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad, without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Prim a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Prim a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Prim a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements, in which case it
--   is returned unchanged.
take :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements, in
--   which case an empty vector is returned.
drop :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Prim a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield the <a>head</a> and <a>tail</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
uncons :: Prim a => Vector a -> Maybe (a, Vector a)

-- | <i>O(1)</i> Yield the <a>last</a> and <a>init</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
unsnoc :: Prim a => Vector a -> Maybe (Vector a, a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements, but this is not checked.
unsafeSlice :: Prim a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty, but this is not checked.
unsafeInit :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty, but this is not checked.
unsafeTail :: Prim a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements, but this is not
--   checked.
unsafeTake :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements, but
--   this is not checked.
unsafeDrop :: Prim a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> The empty vector.
empty :: Prim a => Vector a

-- | <i>O(1)</i> A vector with exactly one element.
singleton :: Prim a => a -> Vector a

-- | <i>O(n)</i> A vector of the given length with the same value in each
--   position.
replicate :: Prim a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
generate :: Prim a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply the function &lt;math&gt; times to an initial value,
--   producing a vector of length &lt;math&gt;. The 0th element will
--   contain the initial value, which is why there is one less function
--   application than the number of elements in the produced vector.
--   
--   &lt;math&gt;
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.iterateN 0 undefined undefined :: VP.Vector Int
--   []
--   
--   &gt;&gt;&gt; VP.iterateN 26 succ 'a'
--   "abcdefghijklmnopqrstuvwxyz"
--   </pre>
iterateN :: Prim a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Prim a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index.
generateM :: (Monad m, Prim a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply the monadic function &lt;math&gt; times to an
--   initial value, producing a vector of length &lt;math&gt;. The 0th
--   element will contain the initial value, which is why there is one less
--   function application than the number of elements in the produced
--   vector.
--   
--   For a non-monadic version, see <a>iterateN</a>.
iterateNM :: (Monad m, Prim a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Prim a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Prim a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <tt>Just</tt> the
--   next element and the new seed or <tt>Nothing</tt> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Prim a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <tt>Just</tt> the next element and the new seed or
--   <tt>Nothing</tt> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Prim a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields the next element and the new seed.
--   
--   <pre>
--   unfoldrExactN 3 (\n -&gt; (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrExactN :: Prim a => Int -> (b -> (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrM :: (Monad m, Prim a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrNM :: (Monad m, Prim a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the monadic generator function to a seed. The
--   generator function yields the next element and the new seed.
unfoldrExactNM :: (Monad m, Prim a) => Int -> (b -> m (a, b)) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in &lt;a,b,c&gt;
--   </pre>
constructN :: Prim a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in &lt;c,b,a&gt;
--   </pre>
constructrN :: Prim a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Prim a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 2 5 = &lt;1,3,5,7,9&gt;
--   </pre>
enumFromStepN :: (Prim a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromN</a> instead.
enumFromTo :: (Prim a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Prim a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element.
cons :: Prim a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element.
snoc :: Prim a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: Prim a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list.
concat :: Prim a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument, but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Prim a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Prim a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
update_ :: Prim a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>), but without bounds checking.
unsafeUpd :: Prim a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update_</a>, but without bounds checking.
unsafeUpdate_ :: Prim a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.accum (+) (VP.fromList [1000,2000,3000 :: Int]) [(2,4),(1,6),(0,3),(1,10)]
--   [1003,2016,3004]
--   </pre>
accum :: Prim a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate_ :: (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a>, but without bounds checking.
unsafeAccum :: Prim a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate_</a>, but without bounds checking.
unsafeAccumulate_ :: (Prim a, Prim b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector.
reverse :: Prim a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt>, but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Prim a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a>, but without bounds checking.
unsafeBackpermute :: Prim a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation may be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise (see <a>New</a> for details).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive.Mutable as MVP
--   
--   &gt;&gt;&gt; VP.modify (\v -&gt; MVP.write v 0 'x') $ VP.replicate 4 'a'
--   "xaaa"
--   </pre>
modify :: Prim a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Map a function over a vector.
map :: (Prim a, Prim b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: (Prim a, Prim b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Prim a, Prim b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: (Monad m, Prim a, Prim b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: (Monad m, Prim a, Prim b) => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: (Monad m, Prim a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: (Monad m, Prim a) => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Prim a, Prim b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Prim a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices, yielding a vector of results. Equivalent to
--   <tt><tt>flip</tt> <a>imapM</a></tt>.
iforM :: (Monad m, Prim a, Prim b) => Vector a -> (Int -> a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices and ignore the results. Equivalent to <tt><tt>flip</tt>
--   <a>imapM_</a></tt>.
iforM_ :: (Monad m, Prim a) => Vector a -> (Int -> a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Prim a, Prim b, Prim c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Prim a, Prim b, Prim c, Prim d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Prim a, Prim b, Prim c, Prim d, Prim e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Prim a, Prim b, Prim c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Prim a, Prim b, Prim c, Prim d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Prim a, Prim b, Prim c, Prim d, Prim e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Prim a, Prim b, Prim c, Prim d, Prim e, Prim f, Prim g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results.
zipWithM :: (Monad m, Prim a, Prim b, Prim c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results.
izipWithM :: (Monad m, Prim a, Prim b, Prim c) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results.
zipWithM_ :: (Monad m, Prim a, Prim b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results.
izipWithM_ :: (Monad m, Prim a, Prim b) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate.
filter :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate which
--   is applied to the values and their indices.
ifilter :: Prim a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the monadic
--   predicate.
filterM :: (Monad m, Prim a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Drop repeated adjacent elements. The first element in each
--   group is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.uniq $ VP.fromList [1,3,3,200,3 :: Int]
--   [1,3,200,3]
--   </pre>
uniq :: (Prim a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Map the values and collect the <tt>Just</tt> results.
mapMaybe :: (Prim a, Prim b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Map the indices/values and collect the <tt>Just</tt>
--   results.
imapMaybe :: (Prim a, Prim b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and discard elements returning <tt>Nothing</tt>.
mapMaybeM :: (Monad m, Prim a, Prim b) => (a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and its index. Discard elements returning <tt>Nothing</tt>.
imapMaybeM :: (Monad m, Prim a, Prim b) => (Int -> a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate. The current implementation is not copy-free, unless the
--   result vector is fused away.
takeWhile :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Prim a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved, but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into two parts, the first one containing
--   the <tt><tt>Left</tt></tt> elements and the second containing the
--   <tt><tt>Right</tt></tt> elements. The relative order of the elements
--   is preserved.
partitionWith :: (Prim a, Prim b, Prim c) => (a -> Either b c) -> Vector a -> (Vector b, Vector c)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Prim a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split a vector into a list of slices, using a predicate
--   function.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements, as determined by
--   the equality predicate function.
--   
--   Does not fuse.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; import           Data.Char (isUpper)
--   
--   &gt;&gt;&gt; VP.groupBy (\a b -&gt; isUpper a == isUpper b) (VP.fromList "Mississippi River")
--   ["M","ississippi ","R","iver"]
--   </pre>
--   
--   See also <a>groupBy</a>, <a>group</a>.
groupBy :: Prim a => (a -> a -> Bool) -> Vector a -> [Vector a]

-- | <i>O(n)</i> Split a vector into a list of slices of the input vector.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements.
--   
--   Does not fuse.
--   
--   This is the equivalent of 'groupBy (==)'.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.group (VP.fromList "Mississippi")
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   See also <a>group</a>.
group :: (Prim a, Eq a) => Vector a -> [Vector a]

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: (Prim a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: (Prim a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <tt>Just</tt> the first element matching the
--   predicate or <tt>Nothing</tt> if no such element exists.
find :: Prim a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
findIndex :: Prim a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the <i>last</i> element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
--   
--   Does not fuse.
findIndexR :: Prim a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Prim a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first occurrence of
--   the given element or <tt>Nothing</tt> if the vector does not contain
--   the element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Prim a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurrences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Prim a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold.
foldl :: Prim b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: Prim b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold.
foldr :: Prim a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: Prim a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: Prim a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold using a function applied to each element and its
--   index.
ifoldl :: Prim b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator using a function applied
--   to each element and its index.
ifoldl' :: Prim b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold using a function applied to each element and
--   its index.
ifoldr :: Prim a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: Prim a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Map each element of the structure to a monoid and combine
--   the results. It uses the same implementation as the corresponding
--   method of the <tt>Foldable</tt> type cless. Note that it's implemented
--   in terms of <a>foldr</a> and won't fuse with functions that traverse
--   the vector from left to right (<a>map</a>, <a>generate</a>, etc.).
foldMap :: (Monoid m, Prim a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Like <a>foldMap</a>, but strict in the accumulator. It
--   uses the same implementation as the corresponding method of the
--   <tt>Foldable</tt> type class. Note that it's implemented in terms of
--   <a>foldl'</a>, so it fuses in most contexts.
foldMap' :: (Monoid m, Prim a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.all even $ VP.fromList [2, 4, 12 :: Int]
--   True
--   
--   &gt;&gt;&gt; VP.all even $ VP.fromList [2, 4, 13 :: Int]
--   False
--   
--   &gt;&gt;&gt; VP.all even (VP.empty :: VP.Vector Int)
--   True
--   </pre>
all :: Prim a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.any even $ VP.fromList [1, 3, 7 :: Int]
--   False
--   
--   &gt;&gt;&gt; VP.any even $ VP.fromList [3, 2, 13 :: Int]
--   True
--   
--   &gt;&gt;&gt; VP.any even (VP.empty :: VP.Vector Int)
--   False
--   </pre>
any :: Prim a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.sum $ VP.fromList [300,20,1 :: Int]
--   321
--   
--   &gt;&gt;&gt; VP.sum (VP.empty :: VP.Vector Int)
--   0
--   </pre>
sum :: (Prim a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.product $ VP.fromList [1,2,3,4 :: Int]
--   24
--   
--   &gt;&gt;&gt; VP.product (VP.empty :: VP.Vector Int)
--   1
--   </pre>
product :: (Prim a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.maximum $ VP.fromList [2, 1 :: Int]
--   2
--   </pre>
maximum :: (Prim a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins. This behavior is different from
--   <a>maximumBy</a> which returns the last tie.
maximumBy :: Prim a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
maximumOn :: (Ord b, Prim a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.minimum $ VP.fromList [2, 1 :: Int]
--   1
--   </pre>
minimum :: (Prim a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins.
minimumBy :: Prim a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
minimumOn :: (Ord b, Prim a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Prim a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Prim a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Prim a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty. In case of a tie, the first occurrence wins.
maxIndexBy :: Prim a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold.
foldM :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (Monad m, Prim b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (Monad m, Prim b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result using a function
--   applied to each element and its index.
ifoldM_ :: (Monad m, Prim b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: (Monad m, Prim b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result using a function applied to each element and its index.
ifoldM'_ :: (Monad m, Prim b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result.
fold1M'_ :: (Monad m, Prim a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Left-to-right prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.prescanl (+) 0 (VP.fromList [1,2,3,4 :: Int])
--   [0,1,3,6]
--   </pre>
prescanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right prescan with strict accumulator.
prescanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan.
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.postscanl (+) 0 (VP.fromList [1,2,3,4 :: Int])
--   [1,3,6,10]
--   </pre>
postscanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan with strict accumulator.
postscanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan.
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.scanl (+) 0 (VP.fromList [1,2,3,4 :: Int])
--   [0,1,3,6,10]
--   </pre>
scanl :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan with strict accumulator.
scanl' :: (Prim a, Prim b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector.
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.scanl1 min $ VP.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VP.scanl1 max $ VP.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VP.scanl1 min (VP.empty :: VP.Vector Int)
--   []
--   </pre>
scanl1 :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector with a
--   strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.scanl1' min $ VP.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VP.scanl1' max $ VP.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VP.scanl1' min (VP.empty :: VP.Vector Int)
--   []
--   </pre>
scanl1' :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector with its index.
iscanl :: (Prim a, Prim b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector (strictly) with its
--   index.
iscanl' :: (Prim a, Prim b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Right-to-left prescan.
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan.
postscanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan with strict accumulator.
postscanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan.
scanr :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
scanr' :: (Prim a, Prim b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.scanr1 min $ VP.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VP.scanr1 max $ VP.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VP.scanr1 min (VP.empty :: VP.Vector Int)
--   []
--   </pre>
scanr1 :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector with
--   a strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.scanr1' min $ VP.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VP.scanr1' max $ VP.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VP.scanr1' min (VP.empty :: VP.Vector Int)
--   []
--   </pre>
scanr1' :: Prim a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index.
iscanr :: (Prim a, Prim b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its
--   index.
iscanr' :: (Prim a, Prim b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Check if two vectors are equal using the supplied equality
--   predicate.
eqBy :: (Prim a, Prim b) => (a -> b -> Bool) -> Vector a -> Vector b -> Bool

-- | <i>O(n)</i> Compare two vectors using the supplied comparison function
--   for vector elements. Comparison works the same as for lists.
--   
--   <pre>
--   cmpBy compare == compare
--   </pre>
cmpBy :: (Prim a, Prim b) => (a -> b -> Ordering) -> Vector a -> Vector b -> Ordering

-- | <i>O(n)</i> Convert a vector to a list.
toList :: Prim a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: Prim a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. It's expected that the supplied list will be exactly
--   <tt>n</tt> elements long. As an optimization, this function allocates
--   a buffer for <tt>n</tt> elements, which could be used for DoS-attacks
--   by exhausting the memory if an attacker controls that parameter.
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive as VP
--   
--   &gt;&gt;&gt; VP.fromListN 3 [1,2,3,4,5 :: Int]
--   [1,2,3]
--   
--   &gt;&gt;&gt; VP.fromListN 3 [1 :: Int]
--   [1]
--   </pre>
fromListN :: Prim a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert between different vector types.
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(1)</i> Unsafely cast a vector from one element type to another.
--   This operation just changes the type of the vector and does not modify
--   the elements.
--   
--   This function will throw an error if elements are of mismatching
--   sizes.
--   
--   | @since 0.13.0.0
unsafeCast :: forall a b. (HasCallStack, Prim a, Prim b) => Vector a -> Vector b

-- | <i>O(1)</i> Unsafely coerce an immutable vector from one element type
--   to another, representationally equal type. The operation just changes
--   the type of the underlying pointer and does not modify the elements.
--   
--   This is marginally safer than <a>unsafeCast</a>, since this function
--   imposes an extra <a>Coercible</a> constraint. The constraint
--   guarantees that the element types are representationally equal. It
--   however cannot guarantee that their respective <a>Prim</a> instances
--   are compatible.
unsafeCoerceVector :: Coercible a b => Vector a -> Vector b

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of an immutable vector.
thaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. Note that this is a very dangerous function and
--   generally it's only safe to read from the resulting vector. In this
--   case, the immutable vector could be used safely as well.
--   
--   Problems with mutation happen because GHC has a lot of freedom to
--   introduce sharing. As a result mutable vectors produced by
--   <tt>unsafeThaw</tt> may or may not share the same underlying buffer.
--   For example:
--   
--   <pre>
--   foo = do
--     let vec = V.generate 10 id
--     mvec &lt;- V.unsafeThaw vec
--     do_something mvec
--   </pre>
--   
--   Here GHC could lift <tt>vec</tt> outside of foo which means that all
--   calls to <tt>do_something</tt> will use same buffer with possibly
--   disastrous results. Whether such aliasing happens or not depends on
--   the program in question, optimization levels, and GHC flags.
--   
--   All in all, attempts to modify a vector produced by
--   <tt>unsafeThaw</tt> fall out of domain of software engineering and
--   into realm of black magic, dark rituals, and unspeakable horrors. The
--   only advice that could be given is: "Don't attempt to mutate a vector
--   produced by <tt>unsafeThaw</tt> unless you know how to prevent GHC
--   from aliasing buffers accidentally. We don't."
unsafeThaw :: (Prim a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Prim a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | Class of types supporting primitive array operations. This includes
--   interfacing with GC-managed memory (functions suffixed with
--   <tt>ByteArray#</tt>) and interfacing with unmanaged memory (functions
--   suffixed with <tt>Addr#</tt>). Endianness is platform-dependent.
class () => Prim a
instance Control.DeepSeq.NFData (Data.Vector.Primitive.Vector a)
instance Control.DeepSeq.NFData1 Data.Vector.Primitive.Vector
instance (GHC.Show.Show a, Data.Primitive.Types.Prim a) => GHC.Show.Show (Data.Vector.Primitive.Vector a)
instance (GHC.Read.Read a, Data.Primitive.Types.Prim a) => GHC.Read.Read (Data.Vector.Primitive.Vector a)
instance (Data.Data.Data a, Data.Primitive.Types.Prim a) => Data.Data.Data (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => Data.Vector.Generic.Base.Vector Data.Vector.Primitive.Vector a
instance (Data.Primitive.Types.Prim a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Primitive.Vector a)
instance (Data.Primitive.Types.Prim a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.Base.Semigroup (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.Base.Monoid (Data.Vector.Primitive.Vector a)
instance Data.Primitive.Types.Prim a => GHC.IsList.IsList (Data.Vector.Primitive.Vector a)


-- | Mutable vectors based on Storable.
module Data.Vector.Storable.Mutable

-- | Mutable <a>Storable</a>-based vectors.
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !ForeignPtr a -> MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s

-- | Length of the mutable vector.
length :: Storable a => MVector s a -> Int

-- | Check whether the vector is empty.
null :: Storable a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it. The vector must
--   contain at least <tt>i+n</tt> elements.
slice :: Storable a => Int -> Int -> MVector s a -> MVector s a

-- | Drop the last element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
init :: Storable a => MVector s a -> MVector s a

-- | Drop the first element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
tail :: Storable a => MVector s a -> MVector s a

-- | Take the <tt>n</tt> first elements of the mutable vector without
--   making a copy. For negative <tt>n</tt>, the empty vector is returned.
--   If <tt>n</tt> is larger than the vector's length, the vector is
--   returned unchanged.
take :: Storable a => Int -> MVector s a -> MVector s a

-- | Drop the <tt>n</tt> first element of the mutable vector without making
--   a copy. For negative <tt>n</tt>, the vector is returned unchanged. If
--   <tt>n</tt> is larger than the vector's length, the empty vector is
--   returned.
drop :: Storable a => Int -> MVector s a -> MVector s a

-- | <i>O(1)</i> Split the mutable vector into the first <tt>n</tt>
--   elements and the remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Storable a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Storable a => Int -> Int -> MVector s a -> MVector s a

-- | Same as <a>init</a>, but doesn't do range checks.
unsafeInit :: Storable a => MVector s a -> MVector s a

-- | Same as <a>tail</a>, but doesn't do range checks.
unsafeTail :: Storable a => MVector s a -> MVector s a

-- | Unsafe variant of <a>take</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeTake :: Storable a => Int -> MVector s a -> MVector s a

-- | Unsafe variant of <a>drop</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeDrop :: Storable a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Storable a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The vector content is
--   uninitialized, which means it is filled with whatever the underlying
--   memory buffer happens to contain.
unsafeNew :: (PrimMonad m, Storable a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Storable a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Storable a) => Int -> m a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   function to each index. Iteration starts at index 0.
generate :: (PrimMonad m, Storable a) => Int -> (Int -> a) -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   monadic function to each index. Iteration starts at index 0.
generateM :: (PrimMonad m, Storable a) => Int -> (Int -> m a) -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow a storable vector by the given number of elements. The number
--   must be non-negative. This has the same semantics as <a>grow</a> for
--   generic vectors.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Storable.Mutable as MVS
--   
--   &gt;&gt;&gt; mv &lt;- VS.thaw $ VS.fromList ([10, 20, 30] :: [Int])
--   
--   &gt;&gt;&gt; mv' &lt;- MVS.grow mv 2
--   </pre>
--   
--   Extra memory at the end of the newly allocated vector is initialized
--   to 0 bytes, which for <a>Storable</a> instances will usually
--   correspond to some default value for a particular type, e.g.
--   <tt>0</tt> for <tt>Int</tt>, <tt>False</tt> for <tt>Bool</tt>, etc.
--   However, if <a>unsafeGrow</a> was used instead, this would not have
--   been guaranteed and some garbage would be there instead.
--   
--   <pre>
--   &gt;&gt;&gt; VS.freeze mv'
--   [10,20,30,0,0]
--   </pre>
--   
--   Having the extra space we can write new values in there:
--   
--   <pre>
--   &gt;&gt;&gt; MVS.write mv' 3 999
--   
--   &gt;&gt;&gt; VS.freeze mv'
--   [10,20,30,999,0]
--   </pre>
--   
--   It is important to note that the source mutable vector is not affected
--   when the newly allocated one is mutated.
--   
--   <pre>
--   &gt;&gt;&gt; MVS.write mv' 2 888
--   
--   &gt;&gt;&gt; VS.freeze mv'
--   [10,20,888,999,0]
--   
--   &gt;&gt;&gt; VS.freeze mv
--   [10,20,30]
--   </pre>
grow :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   non-negative, but this is not checked. This has the same semantics as
--   <a>unsafeGrow</a> for generic vectors.
unsafeGrow :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is a noop.
clear :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> m ()

-- | Yield the element at the given position. Will throw an exception if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable.Mutable as MVS
--   
--   &gt;&gt;&gt; v &lt;- MVS.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVS.read v 3
--   9
--   </pre>
read :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m a

-- | Yield the element at the given position. Returns <tt>Nothing</tt> if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable.Mutable as MVS
--   
--   &gt;&gt;&gt; v &lt;- MVS.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVS.readMaybe v 3
--   Just 9
--   
--   &gt;&gt;&gt; MVS.readMaybe v 13
--   Nothing
--   </pre>
readMaybe :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m (Maybe a)

-- | Replace the element at the given position.
write :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function.
modifyM :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
exchange :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function. No
--   bounds checks are performed.
unsafeModifyM :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> Int -> a -> m a

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results.
mapM_ :: (PrimMonad m, Storable a) => (a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results.
imapM_ :: (PrimMonad m, Storable a) => (Int -> a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results. It's the same as <tt>flip mapM_</tt>.
forM_ :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results. It's the same as <tt>flip
--   imapM_</tt>.
iforM_ :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> (Int -> a -> m b) -> m ()

-- | <i>O(n)</i> Pure left fold.
foldl :: (PrimMonad m, Storable a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator.
foldl' :: (PrimMonad m, Storable a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold.
foldM :: (PrimMonad m, Storable a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (PrimMonad m, Storable a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold.
foldr :: (PrimMonad m, Storable a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator.
foldr' :: (PrimMonad m, Storable a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold.
foldrM :: (PrimMonad m, Storable a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator.
foldrM' :: (PrimMonad m, Storable a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold using a function applied to each element
--   and its index.
ifoldl :: (PrimMonad m, Storable a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator using a function
--   applied to each element and its index.
ifoldl' :: (PrimMonad m, Storable a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (PrimMonad m, Storable a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (PrimMonad m, Storable a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold using a function applied to each element
--   and its index.
ifoldr :: (PrimMonad m, Storable a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: (PrimMonad m, Storable a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold using a function applied to each
--   element and its index.
ifoldrM :: (PrimMonad m, Storable a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator using a
--   function applied to each element and its index.
ifoldrM' :: (PrimMonad m, Storable a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | Compute the (lexicographically) next permutation of the given vector
--   in-place. Returns False when the input is the last permutation.
nextPermutation :: (PrimMonad m, Storable e, Ord e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap, but this is not checked.
unsafeCopy :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Storable a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | <i>O(1)</i> Unsafely cast a mutable vector from one element type to
--   another. The operation just changes the type of the underlying pointer
--   and does not modify the elements.
--   
--   The resulting vector contains as many elements as can fit into the
--   underlying memory block.
unsafeCast :: forall a b s. (Storable a, Storable b) => MVector s a -> MVector s b

-- | <i>O(1)</i> Unsafely coerce a mutable vector from one element type to
--   another, representationally equal type. The operation just changes the
--   type of the underlying pointer and does not modify the elements.
--   
--   This is marginally safer than <a>unsafeCast</a>, since this function
--   imposes an extra <a>Coercible</a> constraint. This function is still
--   not safe, however, since it cannot guarantee that the two types have
--   memory-compatible <a>Storable</a> instances.
unsafeCoerceMVector :: Coercible a b => MVector s a -> MVector s b

-- | <i>O(1)</i> Create a mutable vector from a <a>ForeignPtr</a> with an
--   offset and a length.
--   
--   Modifying data through the <a>ForeignPtr</a> afterwards is unsafe if
--   the vector could have been frozen before the modification.
--   
--   If your offset is 0, it is more efficient to use
--   <a>unsafeFromForeignPtr0</a>.
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> MVector s a

-- | <i>O(1)</i> Create a mutable vector from a <a>ForeignPtr</a> and a
--   length.
--   
--   It is assumed that the pointer points directly to the data (no
--   offset). Use <a>unsafeFromForeignPtr</a> if you need to specify an
--   offset.
--   
--   Modifying data through the <a>ForeignPtr</a> afterwards is unsafe if
--   the vector could have been frozen before the modification.
unsafeFromForeignPtr0 :: ForeignPtr a -> Int -> MVector s a

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with the
--   offset to the data and its length. Modifying the data through the
--   <a>ForeignPtr</a> is unsafe if the vector could have been frozen
--   before the modification.
unsafeToForeignPtr :: MVector s a -> (ForeignPtr a, Int, Int)

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with its
--   length.
--   
--   You can assume that the pointer points directly to the data (no
--   offset).
--   
--   Modifying the data through the <a>ForeignPtr</a> is unsafe if the
--   vector could have been frozen before the modification.
unsafeToForeignPtr0 :: MVector s a -> (ForeignPtr a, Int)

-- | Pass a pointer to the vector's data to the IO action. Modifying data
--   through the pointer is unsafe if the vector could have been frozen
--   before the modification.
unsafeWith :: Storable a => IOVector a -> (Ptr a -> IO b) -> IO b

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type)

-- | State token type.
type family PrimState (m :: Type -> Type)

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
instance Control.DeepSeq.NFData (Data.Vector.Storable.Mutable.MVector s a)
instance Control.DeepSeq.NFData1 (Data.Vector.Storable.Mutable.MVector s)
instance Foreign.Storable.Storable a => Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Storable.Mutable.MVector a


-- | <a>Storable</a>-based vectors.
module Data.Vector.Storable

-- | <a>Storable</a>-based vectors.
data Vector a

-- | Mutable <a>Storable</a>-based vectors.
data MVector s a
MVector :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !ForeignPtr a -> MVector s a

-- | <i>O(1)</i> Yield the length of the vector.
length :: Storable a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty.
null :: Storable a => Vector a -> Bool

-- | O(1) Indexing.
(!) :: Storable a => Vector a -> Int -> a

-- | O(1) Safe indexing.
(!?) :: Storable a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element.
head :: Storable a => Vector a -> a

-- | <i>O(1)</i> Last element.
last :: Storable a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking.
unsafeIndex :: Storable a => Vector a -> Int -> a

-- | <i>O(1)</i> First element, without checking if the vector is empty.
unsafeHead :: Storable a => Vector a -> a

-- | <i>O(1)</i> Last element, without checking if the vector is empty.
unsafeLast :: Storable a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the element) is evaluated eagerly.
indexM :: (Storable a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad, without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Storable a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Storable a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Storable a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements, in which case it
--   is returned unchanged.
take :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements, in
--   which case an empty vector is returned.
drop :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Storable a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield the <a>head</a> and <a>tail</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
uncons :: Storable a => Vector a -> Maybe (a, Vector a)

-- | <i>O(1)</i> Yield the <a>last</a> and <a>init</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
unsnoc :: Storable a => Vector a -> Maybe (Vector a, a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements, but this is not checked.
unsafeSlice :: Storable a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty, but this is not checked.
unsafeInit :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty, but this is not checked.
unsafeTail :: Storable a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements, but this is not
--   checked.
unsafeTake :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements, but
--   this is not checked.
unsafeDrop :: Storable a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> The empty vector.
empty :: Storable a => Vector a

-- | <i>O(1)</i> A vector with exactly one element.
singleton :: Storable a => a -> Vector a

-- | <i>O(n)</i> A vector of the given length with the same value in each
--   position.
replicate :: Storable a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
generate :: Storable a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply the function &lt;math&gt; times to an initial value,
--   producing a vector of length &lt;math&gt;. The 0th element will
--   contain the initial value, which is why there is one less function
--   application than the number of elements in the produced vector.
--   
--   &lt;math&gt;
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.iterateN 0 undefined undefined :: VS.Vector Int
--   []
--   
--   &gt;&gt;&gt; VS.iterateN 26 succ 'a'
--   "abcdefghijklmnopqrstuvwxyz"
--   </pre>
iterateN :: Storable a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Storable a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index.
generateM :: (Monad m, Storable a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply the monadic function &lt;math&gt; times to an
--   initial value, producing a vector of length &lt;math&gt;. The 0th
--   element will contain the initial value, which is why there is one less
--   function application than the number of elements in the produced
--   vector.
--   
--   For a non-monadic version, see <a>iterateN</a>.
iterateNM :: (Monad m, Storable a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Storable a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Storable a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <tt>Just</tt> the
--   next element and the new seed or <tt>Nothing</tt> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Storable a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <tt>Just</tt> the next element and the new seed or
--   <tt>Nothing</tt> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Storable a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields the next element and the new seed.
--   
--   <pre>
--   unfoldrExactN 3 (\n -&gt; (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrExactN :: Storable a => Int -> (b -> (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrM :: (Monad m, Storable a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrNM :: (Monad m, Storable a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the monadic generator function to a seed. The
--   generator function yields the next element and the new seed.
unfoldrExactNM :: (Monad m, Storable a) => Int -> (b -> m (a, b)) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in &lt;a,b,c&gt;
--   </pre>
constructN :: Storable a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in &lt;c,b,a&gt;
--   </pre>
constructrN :: Storable a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Storable a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 2 5 = &lt;1,3,5,7,9&gt;
--   </pre>
enumFromStepN :: (Storable a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromN</a> instead.
enumFromTo :: (Storable a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Storable a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element.
cons :: Storable a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element.
snoc :: Storable a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: Storable a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list.
concat :: Storable a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument, but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Storable a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Storable a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
update_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>), but without bounds checking.
unsafeUpd :: Storable a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update_</a>, but without bounds checking.
unsafeUpdate_ :: Storable a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.accum (+) (VS.fromList [1000,2000,3000 :: Int]) [(2,4),(1,6),(0,3),(1,10)]
--   [1003,2016,3004]
--   </pre>
accum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
accumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a>, but without bounds checking.
unsafeAccum :: Storable a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate_</a>, but without bounds checking.
unsafeAccumulate_ :: (Storable a, Storable b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector.
reverse :: Storable a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt>, but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Storable a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a>, but without bounds checking.
unsafeBackpermute :: Storable a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation may be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise (see <a>New</a> for details).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Storable.Mutable as MVS
--   
--   &gt;&gt;&gt; VS.modify (\v -&gt; MVS.write v 0 'x') $ VS.replicate 4 'a'
--   "xaaa"
--   </pre>
modify :: Storable a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Map a function over a vector.
map :: (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: (Storable a, Storable b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Storable a, Storable b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: (Monad m, Storable a, Storable b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: (Monad m, Storable a, Storable b) => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: (Monad m, Storable a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: (Monad m, Storable a) => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Storable a, Storable b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Storable a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices, yielding a vector of results. Equivalent to
--   <tt><tt>flip</tt> <a>imapM</a></tt>.
iforM :: (Monad m, Storable a, Storable b) => Vector a -> (Int -> a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices and ignore the results. Equivalent to <tt><tt>flip</tt>
--   <a>imapM_</a></tt>.
iforM_ :: (Monad m, Storable a) => Vector a -> (Int -> a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Storable a, Storable b, Storable c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Storable a, Storable b, Storable c, Storable d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Storable a, Storable b, Storable c, Storable d, Storable e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Storable a, Storable b, Storable c, Storable d, Storable e, Storable f, Storable g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results.
zipWithM :: (Monad m, Storable a, Storable b, Storable c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results.
izipWithM :: (Monad m, Storable a, Storable b, Storable c) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results.
zipWithM_ :: (Monad m, Storable a, Storable b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results.
izipWithM_ :: (Monad m, Storable a, Storable b) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate.
filter :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate which
--   is applied to the values and their indices.
ifilter :: Storable a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the monadic
--   predicate.
filterM :: (Monad m, Storable a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Drop repeated adjacent elements. The first element in each
--   group is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.uniq $ VS.fromList [1,3,3,200,3 :: Int]
--   [1,3,200,3]
--   </pre>
uniq :: (Storable a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Map the values and collect the <tt>Just</tt> results.
mapMaybe :: (Storable a, Storable b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Map the indices/values and collect the <tt>Just</tt>
--   results.
imapMaybe :: (Storable a, Storable b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and discard elements returning <tt>Nothing</tt>.
mapMaybeM :: (Monad m, Storable a, Storable b) => (a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and its index. Discard elements returning <tt>Nothing</tt>.
imapMaybeM :: (Monad m, Storable a, Storable b) => (Int -> a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate. The current implementation is not copy-free, unless the
--   result vector is fused away.
takeWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Storable a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved, but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into two parts, the first one containing
--   the <tt><tt>Left</tt></tt> elements and the second containing the
--   <tt><tt>Right</tt></tt> elements. The relative order of the elements
--   is preserved.
partitionWith :: (Storable a, Storable b, Storable c) => (a -> Either b c) -> Vector a -> (Vector b, Vector c)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Storable a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split a vector into a list of slices, using a predicate
--   function.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements, as determined by
--   the equality predicate function.
--   
--   Does not fuse.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; import           Data.Char (isUpper)
--   
--   &gt;&gt;&gt; VS.groupBy (\a b -&gt; isUpper a == isUpper b) (VS.fromList "Mississippi River")
--   ["M","ississippi ","R","iver"]
--   </pre>
--   
--   See also <a>groupBy</a>, <a>group</a>.
groupBy :: Storable a => (a -> a -> Bool) -> Vector a -> [Vector a]

-- | <i>O(n)</i> Split a vector into a list of slices of the input vector.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements.
--   
--   Does not fuse.
--   
--   This is the equivalent of 'groupBy (==)'.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.group (VS.fromList "Mississippi")
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   See also <a>group</a>.
group :: (Storable a, Eq a) => Vector a -> [Vector a]

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: (Storable a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: (Storable a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <tt>Just</tt> the first element matching the
--   predicate or <tt>Nothing</tt> if no such element exists.
find :: Storable a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
findIndex :: Storable a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the <i>last</i> element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
--   
--   Does not fuse.
findIndexR :: Storable a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Storable a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first occurrence of
--   the given element or <tt>Nothing</tt> if the vector does not contain
--   the element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Storable a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurrences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Storable a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold.
foldl :: Storable b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: Storable b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold.
foldr :: Storable a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: Storable a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: Storable a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold using a function applied to each element and its
--   index.
ifoldl :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator using a function applied
--   to each element and its index.
ifoldl' :: Storable b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold using a function applied to each element and
--   its index.
ifoldr :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: Storable a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Map each element of the structure to a monoid and combine
--   the results. It uses the same implementation as the corresponding
--   method of the <tt>Foldable</tt> type class. Note that it's implemented
--   in terms of <a>foldr</a> and won't fuse with functions that traverse
--   the vector from left to right (<a>map</a>, <a>generate</a>, etc.).
foldMap :: (Monoid m, Storable a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Like <a>foldMap</a>, but strict in the accumulator. It
--   uses the same implementation as the corresponding method of the
--   <tt>Foldable</tt> type class. Note that it's implemented in terms of
--   <a>foldl'</a>, so it fuses in most contexts.
foldMap' :: (Monoid m, Storable a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.all even $ VS.fromList [2, 4, 12 :: Int]
--   True
--   
--   &gt;&gt;&gt; VS.all even $ VS.fromList [2, 4, 13 :: Int]
--   False
--   
--   &gt;&gt;&gt; VS.all even (VS.empty :: VS.Vector Int)
--   True
--   </pre>
all :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.any even $ VS.fromList [1, 3, 7 :: Int]
--   False
--   
--   &gt;&gt;&gt; VS.any even $ VS.fromList [3, 2, 13 :: Int]
--   True
--   
--   &gt;&gt;&gt; VS.any even (VS.empty :: VS.Vector Int)
--   False
--   </pre>
any :: Storable a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.and $ VS.fromList [True, False]
--   False
--   
--   &gt;&gt;&gt; VS.and VS.empty
--   True
--   </pre>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.or $ VS.fromList [True, False]
--   True
--   
--   &gt;&gt;&gt; VS.or VS.empty
--   False
--   </pre>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.sum $ VS.fromList [300,20,1 :: Int]
--   321
--   
--   &gt;&gt;&gt; VS.sum (VS.empty :: VS.Vector Int)
--   0
--   </pre>
sum :: (Storable a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.product $ VS.fromList [1,2,3,4 :: Int]
--   24
--   
--   &gt;&gt;&gt; VS.product (VS.empty :: VS.Vector Int)
--   1
--   </pre>
product :: (Storable a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.maximum $ VS.fromList [2, 1 :: Int]
--   2
--   </pre>
maximum :: (Storable a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins. This behavior is different from
--   <a>maximumBy</a> which returns the last tie.
maximumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
maximumOn :: (Ord b, Storable a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.minimum $ VS.fromList [2, 1 :: Int]
--   1
--   </pre>
minimum :: (Storable a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins.
minimumBy :: Storable a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
minimumOn :: (Ord b, Storable a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Storable a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
minIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Storable a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty. In case of a tie, the first occurrence wins.
maxIndexBy :: Storable a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold.
foldM :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (Monad m, Storable b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (Monad m, Storable b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result using a function
--   applied to each element and its index.
ifoldM_ :: (Monad m, Storable b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: (Monad m, Storable b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result using a function applied to each element and its index.
ifoldM'_ :: (Monad m, Storable b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result.
fold1M'_ :: (Monad m, Storable a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Left-to-right prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.prescanl (+) 0 (VS.fromList [1,2,3,4 :: Int])
--   [0,1,3,6]
--   </pre>
prescanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right prescan with strict accumulator.
prescanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan.
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.postscanl (+) 0 (VS.fromList [1,2,3,4 :: Int])
--   [1,3,6,10]
--   </pre>
postscanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan with strict accumulator.
postscanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan.
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.scanl (+) 0 (VS.fromList [1,2,3,4 :: Int])
--   [0,1,3,6,10]
--   </pre>
scanl :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan with strict accumulator.
scanl' :: (Storable a, Storable b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector.
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.scanl1 min $ VS.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VS.scanl1 max $ VS.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VS.scanl1 min (VS.empty :: VS.Vector Int)
--   []
--   </pre>
scanl1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector with a
--   strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.scanl1' min $ VS.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VS.scanl1' max $ VS.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VS.scanl1' min (VS.empty :: VS.Vector Int)
--   []
--   </pre>
scanl1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector with its index.
iscanl :: (Storable a, Storable b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector (strictly) with its
--   index.
iscanl' :: (Storable a, Storable b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Right-to-left prescan.
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan.
postscanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan with strict accumulator.
postscanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan.
scanr :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
scanr' :: (Storable a, Storable b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.scanr1 min $ VS.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VS.scanr1 max $ VS.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VS.scanr1 min (VS.empty :: VS.Vector Int)
--   []
--   </pre>
scanr1 :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector with
--   a strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.scanr1' min $ VS.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VS.scanr1' max $ VS.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VS.scanr1' min (VS.empty :: VS.Vector Int)
--   []
--   </pre>
scanr1' :: Storable a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index.
iscanr :: (Storable a, Storable b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its
--   index.
iscanr' :: (Storable a, Storable b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Check if two vectors are equal using the supplied equality
--   predicate.
eqBy :: (Storable a, Storable b) => (a -> b -> Bool) -> Vector a -> Vector b -> Bool

-- | <i>O(n)</i> Compare two vectors using supplied the comparison function
--   for vector elements. Comparison works the same as for lists.
--   
--   <pre>
--   cmpBy compare == compare
--   </pre>
cmpBy :: (Storable a, Storable b) => (a -> b -> Ordering) -> Vector a -> Vector b -> Ordering

-- | Checks whether two values are the same vector: they have same length
--   and share the same buffer.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; let xs = VS.fromList [0/0::Double] in VS.isSameVector xs xs
--   True
--   </pre>
isSameVector :: Storable a => Vector a -> Vector a -> Bool

-- | <i>O(n)</i> Convert a vector to a list.
toList :: Storable a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: Storable a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. It's expected that the supplied list will be exactly
--   <tt>n</tt> elements long. As an optimization, this function allocates
--   a buffer for <tt>n</tt> elements, which could be used for DoS-attacks
--   by exhausting the memory if an attacker controls that parameter.
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Storable as VS
--   
--   &gt;&gt;&gt; VS.fromListN 3 [1,2,3,4,5 :: Int]
--   [1,2,3]
--   
--   &gt;&gt;&gt; VS.fromListN 3 [1 :: Int]
--   [1]
--   </pre>
fromListN :: Storable a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert between different vector types.
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(1)</i> Unsafely cast a vector from one element type to another.
--   This operation just changes the type of the underlying pointer and
--   does not modify the elements.
--   
--   The resulting vector contains as many elements as can fit into the
--   underlying memory block.
unsafeCast :: forall a b. (Storable a, Storable b) => Vector a -> Vector b

-- | <i>O(1)</i> Unsafely coerce a mutable vector from one element type to
--   another, representationally equal type. The operation just changes the
--   type of the underlying pointer and does not modify the elements.
--   
--   This is marginally safer than <a>unsafeCast</a>, since this function
--   imposes an extra <a>Coercible</a> constraint. This function is still
--   not safe, however, since it cannot guarantee that the two types have
--   memory-compatible <a>Storable</a> instances.
unsafeCoerceVector :: Coercible a b => Vector a -> Vector b

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of an immutable vector.
thaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. Note that this is a very dangerous function and
--   generally it's only safe to read from the resulting vector. In this
--   case, the immutable vector could be used safely as well.
--   
--   Problems with mutation happen because GHC has a lot of freedom to
--   introduce sharing. As a result mutable vectors produced by
--   <tt>unsafeThaw</tt> may or may not share the same underlying buffer.
--   For example:
--   
--   <pre>
--   foo = do
--     let vec = V.generate 10 id
--     mvec &lt;- V.unsafeThaw vec
--     do_something mvec
--   </pre>
--   
--   Here GHC could lift <tt>vec</tt> outside of foo which means that all
--   calls to <tt>do_something</tt> will use same buffer with possibly
--   disastrous results. Whether such aliasing happens or not depends on
--   the program in question, optimization levels, and GHC flags.
--   
--   All in all, attempts to modify a vector produced by
--   <tt>unsafeThaw</tt> fall out of domain of software engineering and
--   into realm of black magic, dark rituals, and unspeakable horrors. The
--   only advice that could be given is: "Don't attempt to mutate a vector
--   produced by <tt>unsafeThaw</tt> unless you know how to prevent GHC
--   from aliasing buffers accidentally. We don't."
unsafeThaw :: (Storable a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Storable a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Create a vector from a <a>ForeignPtr</a> with an offset
--   and a length.
--   
--   The data may not be modified through the pointer afterwards.
--   
--   If your offset is 0 it is more efficient to use
--   <a>unsafeFromForeignPtr0</a>.
unsafeFromForeignPtr :: Storable a => ForeignPtr a -> Int -> Int -> Vector a

-- | <i>O(1)</i> Create a vector from a <a>ForeignPtr</a> and a length.
--   
--   It is assumed the pointer points directly to the data (no offset). Use
--   <a>unsafeFromForeignPtr</a> if you need to specify an offset.
--   
--   The data may not be modified through the pointer afterwards.
unsafeFromForeignPtr0 :: ForeignPtr a -> Int -> Vector a

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with the
--   offset to the data and its length. The data may not be modified
--   through the <a>ForeignPtr</a>.
unsafeToForeignPtr :: Vector a -> (ForeignPtr a, Int, Int)

-- | <i>O(1)</i> Yield the underlying <a>ForeignPtr</a> together with its
--   length.
--   
--   You can assume that the pointer points directly to the data (no
--   offset).
--   
--   The data may not be modified through the <a>ForeignPtr</a>.
unsafeToForeignPtr0 :: Vector a -> (ForeignPtr a, Int)

-- | Pass a pointer to the vector's data to the IO action. The data may not
--   be modified through the 'Ptr.
unsafeWith :: Storable a => Vector a -> (Ptr a -> IO b) -> IO b

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class () => Storable a
instance Control.DeepSeq.NFData (Data.Vector.Storable.Vector a)
instance Control.DeepSeq.NFData1 Data.Vector.Storable.Vector
instance (GHC.Show.Show a, Foreign.Storable.Storable a) => GHC.Show.Show (Data.Vector.Storable.Vector a)
instance (GHC.Read.Read a, Foreign.Storable.Storable a) => GHC.Read.Read (Data.Vector.Storable.Vector a)
instance (Data.Data.Data a, Foreign.Storable.Storable a) => Data.Data.Data (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => Data.Vector.Generic.Base.Vector Data.Vector.Storable.Vector a
instance (Foreign.Storable.Storable a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Storable.Vector a)
instance (Foreign.Storable.Storable a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.Base.Semigroup (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.Base.Monoid (Data.Vector.Storable.Vector a)
instance Foreign.Storable.Storable a => GHC.IsList.IsList (Data.Vector.Storable.Vector a)


-- | Adaptive unboxed vectors. The implementation is based on type families
--   and picks an efficient, specialised representation for every element
--   type. For example, unboxed vectors of pairs are represented as pairs
--   of unboxed vectors.
--   
--   Implementing unboxed vectors for new data types can be very easy. Here
--   is how the library does this for <tt>Complex</tt> by simply wrapping
--   vectors of pairs.
--   
--   <pre>
--   newtype instance <a>MVector</a> s (<tt>Complex</tt> a) = MV_Complex (<a>MVector</a> s (a,a))
--   newtype instance <a>Vector</a>    (<tt>Complex</tt> a) = V_Complex  (<a>Vector</a>    (a,a))
--   
--   instance (<tt>RealFloat</tt> a, <a>Unbox</a> a) =&gt; <a>MVector</a> <a>MVector</a> (<tt>Complex</tt> a) where
--     {-# INLINE basicLength #-}
--     basicLength (MV_Complex v) = <a>basicLength</a> v
--     ...
--   
--   instance (<tt>RealFloat</tt> a, <a>Unbox</a> a) =&gt; Data.Vector.Generic.Vector <a>Vector</a> (<tt>Complex</tt> a) where
--     {-# INLINE basicLength #-}
--     basicLength (V_Complex v) = Data.Vector.Generic.basicLength v
--     ...
--   
--   instance (<tt>RealFloat</tt> a, <a>Unbox</a> a) =&gt; <a>Unbox</a> (<tt>Complex</tt> a)
--   </pre>
--   
--   For newtypes, defining instances is easier since one could use
--   <tt>GeneralizedNewtypeDeriving</tt> in order to derive instances for
--   <a>Vector</a> and <a>MVector</a>, since they're very cumbersome to
--   write by hand:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeFamilies -XStandaloneDeriving -XMultiParamTypeClasses -XGeneralizedNewtypeDeriving
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic         as VG
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic.Mutable as VGM
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed         as VU
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype Foo = Foo Int
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype instance VU.MVector s Foo = MV_Int (VU.MVector s Int)
--   
--   &gt;&gt;&gt; newtype instance VU.Vector    Foo = V_Int  (VU.Vector    Int)
--   
--   &gt;&gt;&gt; deriving instance VGM.MVector VU.MVector Foo
--   
--   &gt;&gt;&gt; deriving instance VG.Vector   VU.Vector  Foo
--   
--   &gt;&gt;&gt; instance VU.Unbox Foo
--   </pre>
module Data.Vector.Unboxed
data family Vector a
data family MVector s a
class (Vector Vector a, MVector MVector a) => Unbox a

-- | <i>O(1)</i> Yield the length of the vector.
length :: Unbox a => Vector a -> Int

-- | <i>O(1)</i> Test whether a vector is empty.
null :: Unbox a => Vector a -> Bool

-- | O(1) Indexing.
(!) :: Unbox a => Vector a -> Int -> a

-- | O(1) Safe indexing.
(!?) :: Unbox a => Vector a -> Int -> Maybe a

-- | <i>O(1)</i> First element.
head :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Last element.
last :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Unsafe indexing without bounds checking.
unsafeIndex :: Unbox a => Vector a -> Int -> a

-- | <i>O(1)</i> First element, without checking if the vector is empty.
unsafeHead :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Last element, without checking if the vector is empty.
unsafeLast :: Unbox a => Vector a -> a

-- | <i>O(1)</i> Indexing in a monad.
--   
--   The monad allows operations to be strict in the vector when necessary.
--   Suppose vector copying is implemented like this:
--   
--   <pre>
--   copy mv v = ... write mv i (v ! i) ...
--   </pre>
--   
--   For lazy vectors, <tt>v ! i</tt> would not be evaluated which means
--   that <tt>mv</tt> would unnecessarily retain a reference to <tt>v</tt>
--   in each element written.
--   
--   With <a>indexM</a>, copying can be implemented like this instead:
--   
--   <pre>
--   copy mv v = ... do
--                     x &lt;- indexM v i
--                     write mv i x
--   </pre>
--   
--   Here, no references to <tt>v</tt> are retained because indexing (but
--   <i>not</i> the element) is evaluated eagerly.
indexM :: (Unbox a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element of a vector in a monad. See <a>indexM</a>
--   for an explanation of why this is useful.
headM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element of a vector in a monad. See <a>indexM</a> for
--   an explanation of why this is useful.
lastM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Indexing in a monad, without bounds checks. See
--   <a>indexM</a> for an explanation of why this is useful.
unsafeIndexM :: (Unbox a, Monad m) => Vector a -> Int -> m a

-- | <i>O(1)</i> First element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeHeadM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Last element in a monad, without checking for empty
--   vectors. See <a>indexM</a> for an explanation of why this is useful.
unsafeLastM :: (Unbox a, Monad m) => Vector a -> m a

-- | <i>O(1)</i> Yield a slice of the vector without copying it. The vector
--   must contain at least <tt>i+n</tt> elements.
slice :: Unbox a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty.
init :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty.
tail :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield at the first <tt>n</tt> elements without copying.
--   The vector may contain less than <tt>n</tt> elements, in which case it
--   is returned unchanged.
take :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector may contain less than <tt>n</tt> elements, in
--   which case an empty vector is returned.
drop :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements paired with the
--   remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Unbox a => Int -> Vector a -> (Vector a, Vector a)

-- | <i>O(1)</i> Yield the <a>head</a> and <a>tail</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
uncons :: Unbox a => Vector a -> Maybe (a, Vector a)

-- | <i>O(1)</i> Yield the <a>last</a> and <a>init</a> of the vector, or
--   <tt>Nothing</tt> if the vector is empty.
unsnoc :: Unbox a => Vector a -> Maybe (Vector a, a)

-- | <i>O(1)</i> Yield a slice of the vector without copying. The vector
--   must contain at least <tt>i+n</tt> elements, but this is not checked.
unsafeSlice :: Unbox a => Int -> Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the last element without copying. The vector
--   may not be empty, but this is not checked.
unsafeInit :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first element without copying. The
--   vector may not be empty, but this is not checked.
unsafeTail :: Unbox a => Vector a -> Vector a

-- | <i>O(1)</i> Yield the first <tt>n</tt> elements without copying. The
--   vector must contain at least <tt>n</tt> elements, but this is not
--   checked.
unsafeTake :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> Yield all but the first <tt>n</tt> elements without
--   copying. The vector must contain at least <tt>n</tt> elements, but
--   this is not checked.
unsafeDrop :: Unbox a => Int -> Vector a -> Vector a

-- | <i>O(1)</i> The empty vector.
empty :: Unbox a => Vector a

-- | <i>O(1)</i> A vector with exactly one element.
singleton :: Unbox a => a -> Vector a

-- | <i>O(n)</i> A vector of the given length with the same value in each
--   position.
replicate :: Unbox a => Int -> a -> Vector a

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   function to each index.
generate :: Unbox a => Int -> (Int -> a) -> Vector a

-- | <i>O(n)</i> Apply the function &lt;math&gt; times to an initial value,
--   producing a vector of length &lt;math&gt;. The 0th element will
--   contain the initial value, which is why there is one less function
--   application than the number of elements in the produced vector.
--   
--   &lt;math&gt;
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.iterateN 0 undefined undefined :: VU.Vector Int
--   []
--   
--   &gt;&gt;&gt; VU.iterateN 3 (\(i, c) -&gt; (pred i, succ c)) (0 :: Int, 'a')
--   [(0,'a'),(-1,'b'),(-2,'c')]
--   </pre>
iterateN :: Unbox a => Int -> (a -> a) -> a -> Vector a

-- | <i>O(n)</i> Execute the monadic action the given number of times and
--   store the results in a vector.
replicateM :: (Monad m, Unbox a) => Int -> m a -> m (Vector a)

-- | <i>O(n)</i> Construct a vector of the given length by applying the
--   monadic action to each index.
generateM :: (Monad m, Unbox a) => Int -> (Int -> m a) -> m (Vector a)

-- | <i>O(n)</i> Apply the monadic function &lt;math&gt; times to an
--   initial value, producing a vector of length &lt;math&gt;. The 0th
--   element will contain the initial value, which is why there is one less
--   function application than the number of elements in the produced
--   vector.
--   
--   For a non-monadic version, see <a>iterateN</a>.
iterateNM :: (Monad m, Unbox a) => Int -> (a -> m a) -> a -> m (Vector a)

-- | Execute the monadic action and freeze the resulting vector.
--   
--   <pre>
--   create (do { v &lt;- new 2; write v 0 'a'; write v 1 'b'; return v }) = &lt;<tt>a</tt>,<tt>b</tt>&gt;
--   </pre>
create :: Unbox a => (forall s. ST s (MVector s a)) -> Vector a

-- | Execute the monadic action and freeze the resulting vectors.
createT :: (Traversable f, Unbox a) => (forall s. ST s (f (MVector s a))) -> f (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the generator
--   function to a seed. The generator function yields <tt>Just</tt> the
--   next element and the new seed or <tt>Nothing</tt> if there are no more
--   elements.
--   
--   <pre>
--   unfoldr (\n -&gt; if n == 0 then Nothing else Just (n,n-1)) 10
--    = &lt;10,9,8,7,6,5,4,3,2,1&gt;
--   </pre>
unfoldr :: Unbox a => (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with at most <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields <tt>Just</tt> the next element and the new seed or
--   <tt>Nothing</tt> if there are no more elements.
--   
--   <pre>
--   unfoldrN 3 (\n -&gt; Just (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrN :: Unbox a => Int -> (b -> Maybe (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the generator function to a seed. The generator
--   function yields the next element and the new seed.
--   
--   <pre>
--   unfoldrExactN 3 (\n -&gt; (n,n-1)) 10 = &lt;10,9,8&gt;
--   </pre>
unfoldrExactN :: Unbox a => Int -> (b -> (a, b)) -> b -> Vector a

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrM :: (Monad m, Unbox a) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector by repeatedly applying the monadic
--   generator function to a seed. The generator function yields
--   <tt>Just</tt> the next element and the new seed or <tt>Nothing</tt> if
--   there are no more elements.
unfoldrNM :: (Monad m, Unbox a) => Int -> (b -> m (Maybe (a, b))) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with exactly <tt>n</tt> elements by
--   repeatedly applying the monadic generator function to a seed. The
--   generator function yields the next element and the new seed.
unfoldrExactNM :: (Monad m, Unbox a) => Int -> (b -> m (a, b)) -> b -> m (Vector a)

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements by repeatedly
--   applying the generator function to the already constructed part of the
--   vector.
--   
--   <pre>
--   constructN 3 f = let a = f &lt;&gt; ; b = f &lt;a&gt; ; c = f &lt;a,b&gt; in &lt;a,b,c&gt;
--   </pre>
constructN :: Unbox a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Construct a vector with <tt>n</tt> elements from right to
--   left by repeatedly applying the generator function to the already
--   constructed part of the vector.
--   
--   <pre>
--   constructrN 3 f = let a = f &lt;&gt; ; b = f&lt;a&gt; ; c = f &lt;b,a&gt; in &lt;c,b,a&gt;
--   </pre>
constructrN :: Unbox a => Int -> (Vector a -> a) -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+1</tt> etc. This operation is usually more efficient
--   than <a>enumFromTo</a>.
--   
--   <pre>
--   enumFromN 5 3 = &lt;5,6,7&gt;
--   </pre>
enumFromN :: (Unbox a, Num a) => a -> Int -> Vector a

-- | <i>O(n)</i> Yield a vector of the given length, containing the values
--   <tt>x</tt>, <tt>x+y</tt>, <tt>x+y+y</tt> etc. This operations is
--   usually more efficient than <a>enumFromThenTo</a>.
--   
--   <pre>
--   enumFromStepN 1 2 5 = &lt;1,3,5,7,9&gt;
--   </pre>
enumFromStepN :: (Unbox a, Num a) => a -> a -> Int -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromN</a> instead.
enumFromTo :: (Unbox a, Enum a) => a -> a -> Vector a

-- | <i>O(n)</i> Enumerate values from <tt>x</tt> to <tt>y</tt> with a
--   specific step <tt>z</tt>.
--   
--   <i>WARNING:</i> This operation can be very inefficient. If possible,
--   use <a>enumFromStepN</a> instead.
enumFromThenTo :: (Unbox a, Enum a) => a -> a -> a -> Vector a

-- | <i>O(n)</i> Prepend an element.
cons :: Unbox a => a -> Vector a -> Vector a

-- | <i>O(n)</i> Append an element.
snoc :: Unbox a => Vector a -> a -> Vector a

-- | <i>O(m+n)</i> Concatenate two vectors.
(++) :: Unbox a => Vector a -> Vector a -> Vector a
infixr 5 ++

-- | <i>O(n)</i> Concatenate all vectors in the list.
concat :: Unbox a => [Vector a] -> Vector a

-- | <i>O(n)</i> Yield the argument, but force it not to retain any extra
--   memory, possibly by copying it.
--   
--   This is especially useful when dealing with slices. For example:
--   
--   <pre>
--   force (slice 0 2 &lt;huge vector&gt;)
--   </pre>
--   
--   Here, the slice retains a reference to the huge vector. Forcing it
--   creates a copy of just the elements that belong to the slice and
--   allows the huge vector to be garbage collected.
force :: Unbox a => Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the list of
--   idnex/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   &lt;5,9,2,7&gt; // [(2,1),(0,3),(2,8)] = &lt;3,9,8,7&gt;
--   </pre>
(//) :: Unbox a => Vector a -> [(Int, a)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,a)</tt> from the vector of
--   index/value pairs, replace the vector element at position <tt>i</tt>
--   by <tt>a</tt>.
--   
--   <pre>
--   update &lt;5,9,2,7&gt; &lt;(2,1),(0,3),(2,8)&gt; = &lt;3,9,8,7&gt;
--   </pre>
update :: Unbox a => Vector a -> Vector (Int, a) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>a</tt> from the value vector, replace
--   the element of the initial vector at position <tt>i</tt> by
--   <tt>a</tt>.
--   
--   <pre>
--   update_ &lt;5,9,2,7&gt;  &lt;2,0,2&gt; &lt;1,3,8&gt; = &lt;3,9,8,7&gt;
--   </pre>
--   
--   The function <a>update</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   update_ xs is ys = <a>update</a> xs (<a>zip</a> is ys)
--   </pre>
update_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a

-- | Same as (<a>//</a>), but without bounds checking.
unsafeUpd :: Unbox a => Vector a -> [(Int, a)] -> Vector a

-- | Same as <a>update</a>, but without bounds checking.
unsafeUpdate :: Unbox a => Vector a -> Vector (Int, a) -> Vector a

-- | Same as <a>update_</a>, but without bounds checking.
unsafeUpdate_ :: Unbox a => Vector a -> Vector Int -> Vector a -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the list, replace the
--   vector element <tt>a</tt> at position <tt>i</tt> by <tt>f a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.accum (+) (VU.fromList [1000,2000,3000 :: Int]) [(2,4),(1,6),(0,3),(1,10)]
--   [1003,2016,3004]
--   </pre>
accum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | <i>O(m+n)</i> For each pair <tt>(i,b)</tt> from the vector of pairs,
--   replace the vector element <tt>a</tt> at position <tt>i</tt> by <tt>f
--   a b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.accumulate (+) (VU.fromList [1000,2000,3000 :: Int]) (VU.fromList [(2,4),(1,6),(0,3),(1,10)])
--   [1003,2016,3004]
--   </pre>
accumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | <i>O(m+min(n1,n2))</i> For each index <tt>i</tt> from the index vector
--   and the corresponding value <tt>b</tt> from the the value vector,
--   replace the element of the initial vector at position <tt>i</tt> by
--   <tt>f a b</tt>.
--   
--   <pre>
--   accumulate_ (+) &lt;5,9,2&gt; &lt;2,1,0,1&gt; &lt;4,6,3,7&gt; = &lt;5+3, 9+6+7, 2+4&gt;
--   </pre>
--   
--   The function <a>accumulate</a> provides the same functionality and is
--   usually more convenient.
--   
--   <pre>
--   accumulate_ f as is bs = <a>accumulate</a> f as (<a>zip</a> is bs)
--   </pre>
accumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | Same as <a>accum</a>, but without bounds checking.
unsafeAccum :: Unbox a => (a -> b -> a) -> Vector a -> [(Int, b)] -> Vector a

-- | Same as <a>accumulate</a>, but without bounds checking.
unsafeAccumulate :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector (Int, b) -> Vector a

-- | Same as <a>accumulate_</a>, but without bounds checking.
unsafeAccumulate_ :: (Unbox a, Unbox b) => (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a

-- | <i>O(n)</i> Reverse a vector.
reverse :: Unbox a => Vector a -> Vector a

-- | <i>O(n)</i> Yield the vector obtained by replacing each element
--   <tt>i</tt> of the index vector by <tt>xs<a>!</a>i</tt>. This is
--   equivalent to <tt><a>map</a> (xs<a>!</a>) is</tt>, but is often much
--   more efficient.
--   
--   <pre>
--   backpermute &lt;a,b,c,d&gt; &lt;0,3,2,3,1,0&gt; = &lt;a,d,c,d,b,a&gt;
--   </pre>
backpermute :: Unbox a => Vector a -> Vector Int -> Vector a

-- | Same as <a>backpermute</a>, but without bounds checking.
unsafeBackpermute :: Unbox a => Vector a -> Vector Int -> Vector a

-- | Apply a destructive operation to a vector. The operation may be
--   performed in place if it is safe to do so and will modify a copy of
--   the vector otherwise (see <a>New</a> for details).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed.Mutable as MVU
--   
--   &gt;&gt;&gt; VU.modify (\v -&gt; MVU.write v 0 'x') $ VU.replicate 4 'a'
--   "xaaa"
--   </pre>
modify :: Unbox a => (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a

-- | <i>O(n)</i> Pair each element in a vector with its index.
indexed :: Unbox a => Vector a -> Vector (Int, a)

-- | <i>O(n)</i> Map a function over a vector.
map :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply a function to every element of a vector and its
--   index.
imap :: (Unbox a, Unbox b) => (Int -> a -> b) -> Vector a -> Vector b

-- | Map a function over a vector and concatenate the results.
concatMap :: (Unbox a, Unbox b) => (a -> Vector b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results.
mapM :: (Monad m, Unbox a, Unbox b) => (a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, yielding a vector of results.
imapM :: (Monad m, Unbox a, Unbox b) => (Int -> a -> m b) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results.
mapM_ :: (Monad m, Unbox a) => (a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of a vector and
--   its index, ignoring the results.
imapM_ :: (Monad m, Unbox a) => (Int -> a -> m b) -> Vector a -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector,
--   yielding a vector of results. Equivalent to <tt>flip <a>mapM</a></tt>.
forM :: (Monad m, Unbox a, Unbox b) => Vector a -> (a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of a vector and
--   ignore the results. Equivalent to <tt>flip <a>mapM_</a></tt>.
forM_ :: (Monad m, Unbox a) => Vector a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices, yielding a vector of results. Equivalent to
--   <tt><tt>flip</tt> <a>imapM</a></tt>.
iforM :: (Monad m, Unbox a, Unbox b) => Vector a -> (Int -> a -> m b) -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic action to all elements of the vector and
--   their indices and ignore the results. Equivalent to <tt><tt>flip</tt>
--   <a>imapM_</a></tt>.
iforM_ :: (Monad m, Unbox a) => Vector a -> (Int -> a -> m b) -> m ()

-- | <i>O(min(m,n))</i> Zip two vectors with the given function.
zipWith :: (Unbox a, Unbox b, Unbox c) => (a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors with the given function.
zipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
zipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
zipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
zipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(min(m,n))</i> Zip two vectors with a function that also takes the
--   elements' indices.
izipWith :: (Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c

-- | Zip three vectors and their indices with the given function.
izipWith3 :: (Unbox a, Unbox b, Unbox c, Unbox d) => (Int -> a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
izipWith4 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => (Int -> a -> b -> c -> d -> e) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
izipWith5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => (Int -> a -> b -> c -> d -> e -> f) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
izipWith6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f, Unbox g) => (Int -> a -> b -> c -> d -> e -> f -> g) -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector g

-- | <i>O(1)</i> Zip 2 vectors.
zip :: (Unbox a, Unbox b) => Vector a -> Vector b -> Vector (a, b)

-- | <i>O(1)</i> Zip 3 vectors.
zip3 :: (Unbox a, Unbox b, Unbox c) => Vector a -> Vector b -> Vector c -> Vector (a, b, c)

-- | <i>O(1)</i> Zip 4 vectors.
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector a -> Vector b -> Vector c -> Vector d -> Vector (a, b, c, d)

-- | <i>O(1)</i> Zip 5 vectors.
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector (a, b, c, d, e)

-- | <i>O(1)</i> Zip 6 vectors.
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f -> Vector (a, b, c, d, e, f)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   yield a vector of results.
zipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and yield a vector of results.
izipWithM :: (Monad m, Unbox a, Unbox b, Unbox c) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)

-- | <i>O(min(m,n))</i> Zip the two vectors with the monadic action and
--   ignore the results.
zipWithM_ :: (Monad m, Unbox a, Unbox b) => (a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(min(m,n))</i> Zip the two vectors with a monadic action that also
--   takes the element index and ignore the results.
izipWithM_ :: (Monad m, Unbox a, Unbox b) => (Int -> a -> b -> m c) -> Vector a -> Vector b -> m ()

-- | <i>O(1)</i> Unzip 2 vectors.
unzip :: (Unbox a, Unbox b) => Vector (a, b) -> (Vector a, Vector b)

-- | <i>O(1)</i> Unzip 3 vectors.
unzip3 :: (Unbox a, Unbox b, Unbox c) => Vector (a, b, c) -> (Vector a, Vector b, Vector c)

-- | <i>O(1)</i> Unzip 4 vectors.
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)

-- | <i>O(1)</i> Unzip 5 vectors.
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => Vector (a, b, c, d, e) -> (Vector a, Vector b, Vector c, Vector d, Vector e)

-- | <i>O(1)</i> Unzip 6 vectors.
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => Vector (a, b, c, d, e, f) -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate.
filter :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the predicate which
--   is applied to the values and their indices.
ifilter :: Unbox a => (Int -> a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop all elements that do not satisfy the monadic
--   predicate.
filterM :: (Monad m, Unbox a) => (a -> m Bool) -> Vector a -> m (Vector a)

-- | <i>O(n)</i> Drop repeated adjacent elements. The first element in each
--   group is returned.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.uniq $ VU.fromList [1,3,3,200,3 :: Int]
--   [1,3,200,3]
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; VU.uniq $ VU.fromList [ Arg 1 'a', Arg 1 'b', Arg (1 :: Int) 'c']
--   [Arg 1 'a']
--   </pre>
uniq :: (Unbox a, Eq a) => Vector a -> Vector a

-- | <i>O(n)</i> Map the values and collect the <tt>Just</tt> results.
mapMaybe :: (Unbox a, Unbox b) => (a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Map the indices/values and collect the <tt>Just</tt>
--   results.
imapMaybe :: (Unbox a, Unbox b) => (Int -> a -> Maybe b) -> Vector a -> Vector b

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and discard elements returning <tt>Nothing</tt>.
mapMaybeM :: (Monad m, Unbox a, Unbox b) => (a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Apply the monadic function to each element of the vector
--   and its index. Discard elements returning <tt>Nothing</tt>.
imapMaybeM :: (Monad m, Unbox a, Unbox b) => (Int -> a -> m (Maybe b)) -> Vector a -> m (Vector b)

-- | <i>O(n)</i> Yield the longest prefix of elements satisfying the
--   predicate. The current implementation is not copy-free, unless the
--   result vector is fused away.
takeWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Drop the longest prefix of elements that satisfy the
--   predicate without copying.
dropWhile :: Unbox a => (a -> Bool) -> Vector a -> Vector a

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The relative order of the elements is preserved at the
--   cost of a sometimes reduced performance compared to
--   <a>unstablePartition</a>.
partition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector in two parts, the first one containing
--   those elements that satisfy the predicate and the second one those
--   that don't. The order of the elements is not preserved, but the
--   operation is often faster than <a>partition</a>.
unstablePartition :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into two parts, the first one containing
--   the <tt><tt>Left</tt></tt> elements and the second containing the
--   <tt><tt>Right</tt></tt> elements. The relative order of the elements
--   is preserved.
partitionWith :: (Unbox a, Unbox b, Unbox c) => (a -> Either b c) -> Vector a -> (Vector b, Vector c)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   satisfy the predicate and the rest without copying.
span :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split the vector into the longest prefix of elements that
--   do not satisfy the predicate and the rest without copying.
break :: Unbox a => (a -> Bool) -> Vector a -> (Vector a, Vector a)

-- | <i>O(n)</i> Split a vector into a list of slices, using a predicate
--   function.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements, as determined by
--   the equality predicate function.
--   
--   Does not fuse.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; import           Data.Char (isUpper)
--   
--   &gt;&gt;&gt; VU.groupBy (\a b -&gt; isUpper a == isUpper b) (VU.fromList "Mississippi River")
--   ["M","ississippi ","R","iver"]
--   </pre>
--   
--   See also <a>groupBy</a>, <a>group</a>.
groupBy :: Unbox a => (a -> a -> Bool) -> Vector a -> [Vector a]

-- | <i>O(n)</i> Split a vector into a list of slices of the input vector.
--   
--   The concatenation of this list of slices is equal to the argument
--   vector, and each slice contains only equal elements.
--   
--   Does not fuse.
--   
--   This is the equivalent of 'groupBy (==)'.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.group (VU.fromList "Mississippi")
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   See also <a>group</a>.
group :: (Unbox a, Eq a) => Vector a -> [Vector a]

-- | <i>O(n)</i> Check if the vector contains an element.
elem :: (Unbox a, Eq a) => a -> Vector a -> Bool
infix 4 `elem`

-- | <i>O(n)</i> Check if the vector does not contain an element (inverse
--   of <a>elem</a>).
notElem :: (Unbox a, Eq a) => a -> Vector a -> Bool
infix 4 `notElem`

-- | <i>O(n)</i> Yield <tt>Just</tt> the first element matching the
--   predicate or <tt>Nothing</tt> if no such element exists.
find :: Unbox a => (a -> Bool) -> Vector a -> Maybe a

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
findIndex :: Unbox a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the <i>last</i> element
--   matching the predicate or <tt>Nothing</tt> if no such element exists.
--   
--   Does not fuse.
findIndexR :: Unbox a => (a -> Bool) -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of elements satisfying the predicate in
--   ascending order.
findIndices :: Unbox a => (a -> Bool) -> Vector a -> Vector Int

-- | <i>O(n)</i> Yield <tt>Just</tt> the index of the first occurrence of
--   the given element or <tt>Nothing</tt> if the vector does not contain
--   the element. This is a specialised version of <a>findIndex</a>.
elemIndex :: (Unbox a, Eq a) => a -> Vector a -> Maybe Int

-- | <i>O(n)</i> Yield the indices of all occurrences of the given element
--   in ascending order. This is a specialised version of
--   <a>findIndices</a>.
elemIndices :: (Unbox a, Eq a) => a -> Vector a -> Vector Int

-- | <i>O(n)</i> Left fold.
foldl :: Unbox b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors.
foldl1 :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold with strict accumulator.
foldl' :: Unbox b => (a -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold on non-empty vectors with strict accumulator.
foldl1' :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold.
foldr :: Unbox a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors.
foldr1 :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Right fold with a strict accumulator.
foldr' :: Unbox a => (a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold on non-empty vectors with strict accumulator.
foldr1' :: Unbox a => (a -> a -> a) -> Vector a -> a

-- | <i>O(n)</i> Left fold using a function applied to each element and its
--   index.
ifoldl :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Left fold with strict accumulator using a function applied
--   to each element and its index.
ifoldl' :: Unbox b => (a -> Int -> b -> a) -> a -> Vector b -> a

-- | <i>O(n)</i> Right fold using a function applied to each element and
--   its index.
ifoldr :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: Unbox a => (Int -> a -> b -> b) -> b -> Vector a -> b

-- | <i>O(n)</i> Map each element of the structure to a monoid and combine
--   the results. It uses the same implementation as the corresponding
--   method of the <tt>Foldable</tt> type cless. Note that it's implemented
--   in terms of <a>foldr</a> and won't fuse with functions that traverse
--   the vector from left to right (<a>map</a>, <a>generate</a>, etc.).
foldMap :: (Monoid m, Unbox a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Like <a>foldMap</a>, but strict in the accumulator. It
--   uses the same implementation as the corresponding method of the
--   <tt>Foldable</tt> type class. Note that it's implemented in terms of
--   <a>foldl'</a>, so it fuses in most contexts.
foldMap' :: (Monoid m, Unbox a) => (a -> m) -> Vector a -> m

-- | <i>O(n)</i> Check if all elements satisfy the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.all even $ VU.fromList [2, 4, 12 :: Int]
--   True
--   
--   &gt;&gt;&gt; VU.all even $ VU.fromList [2, 4, 13 :: Int]
--   False
--   
--   &gt;&gt;&gt; VU.all even (VU.empty :: VU.Vector Int)
--   True
--   </pre>
all :: Unbox a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if any element satisfies the predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.any even $ VU.fromList [1, 3, 7 :: Int]
--   False
--   
--   &gt;&gt;&gt; VU.any even $ VU.fromList [3, 2, 13 :: Int]
--   True
--   
--   &gt;&gt;&gt; VU.any even (VU.empty :: VU.Vector Int)
--   False
--   </pre>
any :: Unbox a => (a -> Bool) -> Vector a -> Bool

-- | <i>O(n)</i> Check if all elements are <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.and $ VU.fromList [True, False]
--   False
--   
--   &gt;&gt;&gt; VU.and VU.empty
--   True
--   </pre>
and :: Vector Bool -> Bool

-- | <i>O(n)</i> Check if any element is <tt>True</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.or $ VU.fromList [True, False]
--   True
--   
--   &gt;&gt;&gt; VU.or VU.empty
--   False
--   </pre>
or :: Vector Bool -> Bool

-- | <i>O(n)</i> Compute the sum of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.sum $ VU.fromList [300,20,1 :: Int]
--   321
--   
--   &gt;&gt;&gt; VU.sum (VU.empty :: VU.Vector Int)
--   0
--   </pre>
sum :: (Unbox a, Num a) => Vector a -> a

-- | <i>O(n)</i> Compute the product of the elements.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.product $ VU.fromList [1,2,3,4 :: Int]
--   24
--   
--   &gt;&gt;&gt; VU.product (VU.empty :: VU.Vector Int)
--   1
--   </pre>
product :: (Unbox a, Num a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.maximum $ VU.fromList [2, 1 :: Int]
--   2
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; VU.maximum $ VU.fromList [Arg 1 'a', Arg (2 :: Int) 'b']
--   Arg 2 'b'
--   
--   &gt;&gt;&gt; VU.maximum $ VU.fromList [Arg 1 'a', Arg (1 :: Int) 'b']
--   Arg 1 'a'
--   </pre>
maximum :: (Unbox a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins. This behavior is different from
--   <a>maximumBy</a> which returns the last tie.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.maximumBy (comparing fst) $ VU.fromList [(2,'a'), (1 :: Int,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; VU.maximumBy (comparing fst) $ VU.fromList [(1,'a'), (1 :: Int,'b')]
--   (1,'a')
--   </pre>
maximumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the maximum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.maximumOn fst $ VU.fromList [(2,'a'), (1 :: Int,'b')]
--   (2,'a')
--   
--   &gt;&gt;&gt; VU.maximumOn fst $ VU.fromList [(1,'a'), (1 :: Int,'b')]
--   (1,'a')
--   </pre>
maximumOn :: (Ord b, Unbox a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector. The vector may
--   not be empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.minimum $ VU.fromList [2, 1 :: Int]
--   1
--   
--   &gt;&gt;&gt; import Data.Semigroup
--   
--   &gt;&gt;&gt; VU.minimum $ VU.fromList [Arg 2 'a', Arg (1 :: Int) 'b']
--   Arg 1 'b'
--   
--   &gt;&gt;&gt; VU.minimum $ VU.fromList [Arg 1 'a', Arg (1 :: Int) 'b']
--   Arg 1 'a'
--   </pre>
minimum :: (Unbox a, Ord a) => Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty.
--   
--   <i>O(n)</i> Yield the minimum element of the vector according to the
--   given comparison function. The vector may not be empty. In case of a
--   tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.minimumBy (comparing fst) $ VU.fromList [(2,'a'), (1 :: Int,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; VU.minimumBy (comparing fst) $ VU.fromList [(1,'a'), (1 :: Int,'b')]
--   (1,'a')
--   </pre>
minimumBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> a

-- | <i>O(n)</i> Yield the minimum element of the vector by comparing the
--   results of a key function on each element. In case of a tie, the first
--   occurrence wins. The vector may not be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.minimumOn fst $ VU.fromList [(2,'a'), (1 :: Int,'b')]
--   (1,'b')
--   
--   &gt;&gt;&gt; VU.minimumOn fst $ VU.fromList [(1,'a'), (1 :: Int,'b')]
--   (1,'a')
--   </pre>
minimumOn :: (Ord b, Unbox a) => (a -> b) -> Vector a -> a

-- | <i>O(n)</i> Yield the index of the minimum element of the vector. The
--   vector may not be empty.
minIndex :: (Unbox a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the minimum element of the vector
--   according to the given comparison function. The vector may not be
--   empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.minIndexBy (comparing fst) $ VU.fromList [(2,'a'), (1,'b')]
--   1
--   
--   &gt;&gt;&gt; VU.minIndexBy (comparing fst) $ VU.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
minIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector. The
--   vector may not be empty.
maxIndex :: (Unbox a, Ord a) => Vector a -> Int

-- | <i>O(n)</i> Yield the index of the maximum element of the vector
--   according to the given comparison function. The vector may not be
--   empty. In case of a tie, the first occurrence wins.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ord
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.maxIndexBy (comparing fst) $ VU.fromList [(2,'a'), (1,'b')]
--   0
--   
--   &gt;&gt;&gt; VU.maxIndexBy (comparing fst) $ VU.fromList [(1,'a'), (1,'b')]
--   0
--   </pre>
maxIndexBy :: Unbox a => (a -> a -> Ordering) -> Vector a -> Int

-- | <i>O(n)</i> Monadic fold.
foldM :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors.
fold1M :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator.
fold1M' :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m a

-- | <i>O(n)</i> Monadic fold that discards the result.
foldM_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold that discards the result using a function
--   applied to each element and its index.
ifoldM_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result.
foldM'_ :: (Monad m, Unbox b) => (a -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold with strict accumulator that discards the
--   result using a function applied to each element and its index.
ifoldM'_ :: (Monad m, Unbox b) => (a -> Int -> b -> m a) -> a -> Vector b -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors that discards the
--   result.
fold1M_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Monadic fold over non-empty vectors with strict
--   accumulator that discards the result.
fold1M'_ :: (Monad m, Unbox a) => (a -> a -> m a) -> Vector a -> m ()

-- | <i>O(n)</i> Left-to-right prescan.
--   
--   <pre>
--   prescanl f z = <a>init</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as VU
--   
--   &gt;&gt;&gt; VU.prescanl (+) 0 (VU.fromList [1,2,3,4 :: Int])
--   [0,1,3,6]
--   </pre>
prescanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right prescan with strict accumulator.
prescanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan.
--   
--   <pre>
--   postscanl f z = <a>tail</a> . <a>scanl</a> f z
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.postscanl (+) 0 (VU.fromList [1,2,3,4 :: Int])
--   [1,3,6,10]
--   </pre>
postscanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right postscan with strict accumulator.
postscanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan.
--   
--   <pre>
--   scanl f z &lt;x1,...,xn&gt; = &lt;y1,...,y(n+1)&gt;
--     where y1 = z
--           yi = f y(i-1) x(i-1)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.scanl (+) 0 (VU.fromList [1,2,3,4 :: Int])
--   [0,1,3,6,10]
--   </pre>
scanl :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan with strict accumulator.
scanl' :: (Unbox a, Unbox b) => (a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector.
--   
--   <pre>
--   scanl f &lt;x1,...,xn&gt; = &lt;y1,...,yn&gt;
--     where y1 = x1
--           yi = f y(i-1) xi
--   </pre>
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.scanl1 min $ VU.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VU.scanl1 max $ VU.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VU.scanl1 min (VU.empty :: VU.Vector Int)
--   []
--   </pre>
scanl1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Initial-value free left-to-right scan over a vector with a
--   strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.scanl1' min $ VU.fromListN 5 [4,2,4,1,3 :: Int]
--   [4,2,2,1,1]
--   
--   &gt;&gt;&gt; VU.scanl1' max $ VU.fromListN 5 [1,3,2,5,4 :: Int]
--   [1,3,3,5,5]
--   
--   &gt;&gt;&gt; VU.scanl1' min (VU.empty :: VU.Vector Int)
--   []
--   </pre>
scanl1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector with its index.
iscanl :: (Unbox a, Unbox b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Left-to-right scan over a vector (strictly) with its
--   index.
iscanl' :: (Unbox a, Unbox b) => (Int -> a -> b -> a) -> a -> Vector b -> Vector a

-- | <i>O(n)</i> Right-to-left prescan.
--   
--   <pre>
--   prescanr f z = <a>reverse</a> . <a>prescanl</a> (flip f) z . <a>reverse</a>
--   </pre>
prescanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left prescan with strict accumulator.
prescanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan.
postscanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left postscan with strict accumulator.
postscanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan.
scanr :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan with strict accumulator.
scanr' :: (Unbox a, Unbox b) => (a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.scanr1 min $ VU.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VU.scanr1 max $ VU.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VU.scanr1 min (VU.empty :: VU.Vector Int)
--   []
--   </pre>
scanr1 :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left, initial-value free scan over a vector with
--   a strict accumulator.
--   
--   Note: Since 0.13, application of this to an empty vector no longer
--   results in an error; instead it produces an empty vector.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.scanr1' min $ VU.fromListN 5 [3,1,4,2,4 :: Int]
--   [1,1,2,2,4]
--   
--   &gt;&gt;&gt; VU.scanr1' max $ VU.fromListN 5 [4,5,2,3,1 :: Int]
--   [5,5,3,3,1]
--   
--   &gt;&gt;&gt; VU.scanr1' min (VU.empty :: VU.Vector Int)
--   []
--   </pre>
scanr1' :: Unbox a => (a -> a -> a) -> Vector a -> Vector a

-- | <i>O(n)</i> Right-to-left scan over a vector with its index.
iscanr :: (Unbox a, Unbox b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Right-to-left scan over a vector (strictly) with its
--   index.
--   
--   @sinqce 0.12.2.0
iscanr' :: (Unbox a, Unbox b) => (Int -> a -> b -> b) -> b -> Vector a -> Vector b

-- | <i>O(n)</i> Check if two vectors are equal using the supplied equality
--   predicate.
eqBy :: (Unbox a, Unbox b) => (a -> b -> Bool) -> Vector a -> Vector b -> Bool

-- | <i>O(n)</i> Compare two vectors using the supplied comparison function
--   for vector elements. Comparison works the same as for lists.
--   
--   <pre>
--   cmpBy compare == compare
--   </pre>
cmpBy :: (Unbox a, Unbox b) => (a -> b -> Ordering) -> Vector a -> Vector b -> Ordering

-- | <i>O(n)</i> Convert a vector to a list.
toList :: Unbox a => Vector a -> [a]

-- | <i>O(n)</i> Convert a list to a vector.
fromList :: Unbox a => [a] -> Vector a

-- | <i>O(n)</i> Convert the first <tt>n</tt> elements of a list to a
--   vector. It's expected that the supplied list will be exactly
--   <tt>n</tt> elements long. As an optimization, this function allocates
--   a buffer for <tt>n</tt> elements, which could be used for DoS-attacks
--   by exhausting the memory if an attacker controls that parameter.
--   
--   <pre>
--   fromListN n xs = <a>fromList</a> (<a>take</a> n xs)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; VU.fromListN 3 [1,2,3,4,5 :: Int]
--   [1,2,3]
--   
--   &gt;&gt;&gt; VU.fromListN 3 [1 :: Int]
--   [1]
--   </pre>
fromListN :: Unbox a => Int -> [a] -> Vector a

-- | <i>O(n)</i> Convert between different vector types.
convert :: (Vector v a, Vector w a) => v a -> w a

-- | <i>O(n)</i> Yield an immutable copy of the mutable vector.
freeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(n)</i> Yield a mutable copy of an immutable vector.
thaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length.
copy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | <i>O(1)</i> Unsafely convert a mutable vector to an immutable one
--   without copying. The mutable vector may not be used after this
--   operation.
unsafeFreeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)

-- | <i>O(1)</i> Unsafely convert an immutable vector to a mutable one
--   without copying. Note that this is a very dangerous function and
--   generally it's only safe to read from the resulting vector. In this
--   case, the immutable vector could be used safely as well.
--   
--   Problems with mutation happen because GHC has a lot of freedom to
--   introduce sharing. As a result mutable vectors produced by
--   <tt>unsafeThaw</tt> may or may not share the same underlying buffer.
--   For example:
--   
--   <pre>
--   foo = do
--     let vec = V.generate 10 id
--     mvec &lt;- V.unsafeThaw vec
--     do_something mvec
--   </pre>
--   
--   Here GHC could lift <tt>vec</tt> outside of foo which means that all
--   calls to <tt>do_something</tt> will use same buffer with possibly
--   disastrous results. Whether such aliasing happens or not depends on
--   the program in question, optimization levels, and GHC flags.
--   
--   All in all, attempts to modify a vector produced by
--   <tt>unsafeThaw</tt> fall out of domain of software engineering and
--   into realm of black magic, dark rituals, and unspeakable horrors. The
--   only advice that could be given is: "Don't attempt to mutate a vector
--   produced by <tt>unsafeThaw</tt> unless you know how to prevent GHC
--   from aliasing buffers accidentally. We don't."
unsafeThaw :: (Unbox a, PrimMonad m) => Vector a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Copy an immutable vector into a mutable one. The two
--   vectors must have the same length. This is not checked.
unsafeCopy :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> Vector a -> m ()

-- | Newtype wrapper which allows to derive unboxed vector in term of
--   primitive vectors using <tt>DerivingVia</tt> mechanism. This is mostly
--   used as illustration of use of <tt>DerivingVia</tt> for vector, see
--   examples below.
--   
--   First is rather straightforward: we define newtype and use GND to
--   derive <a>Prim</a> instance. Newtype instances should be defined
--   manually. Then we use deriving via to define necessary instances.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeFamilies -XStandaloneDeriving -XDerivingVia -XMultiParamTypeClasses
--   
--   &gt;&gt;&gt; -- Needed to derive Prim
--   
--   &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving -XDataKinds -XUnboxedTuples -XPolyKinds
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic         as VG
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic.Mutable as VGM
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive       as VP
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed         as VU
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype Foo = Foo Int deriving VP.Prim
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype instance VU.MVector s Foo = MV_Int (VP.MVector s Foo)
--   
--   &gt;&gt;&gt; newtype instance VU.Vector    Foo = V_Int  (VP.Vector    Foo)
--   
--   &gt;&gt;&gt; deriving via (VU.UnboxViaPrim Foo) instance VGM.MVector VU.MVector Foo
--   
--   &gt;&gt;&gt; deriving via (VU.UnboxViaPrim Foo) instance VG.Vector   VU.Vector  Foo
--   
--   &gt;&gt;&gt; instance VU.Unbox Foo
--   </pre>
--   
--   Second example is essentially same but with a twist. Instead of using
--   <tt>Prim</tt> instance of data type, we use underlying instance of
--   <tt>Int</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeFamilies -XStandaloneDeriving -XDerivingVia -XMultiParamTypeClasses
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic         as VG
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic.Mutable as VGM
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Primitive       as VP
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed         as VU
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype Foo = Foo Int
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype instance VU.MVector s Foo = MV_Int (VP.MVector s Int)
--   
--   &gt;&gt;&gt; newtype instance VU.Vector    Foo = V_Int  (VP.Vector    Int)
--   
--   &gt;&gt;&gt; deriving via (VU.UnboxViaPrim Int) instance VGM.MVector VU.MVector Foo
--   
--   &gt;&gt;&gt; deriving via (VU.UnboxViaPrim Int) instance VG.Vector   VU.Vector  Foo
--   
--   &gt;&gt;&gt; instance VU.Unbox Foo
--   </pre>
newtype UnboxViaPrim a
UnboxViaPrim :: a -> UnboxViaPrim a

-- | Newtype which allows to derive unbox instances for type <tt>a</tt>
--   which uses <tt>b</tt> as underlying representation (usually tuple).
--   Type <tt>a</tt> and its representation <tt>b</tt> are connected by
--   type class <a>IsoUnbox</a>. Here's example which uses explicit
--   <a>IsoUnbox</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeFamilies -XStandaloneDeriving -XDerivingVia
--   
--   &gt;&gt;&gt; :set -XMultiParamTypeClasses -XTypeOperators -XFlexibleInstances
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed         as VU
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed.Mutable as MVU
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic         as VG
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic.Mutable as VGM
--   
--   &gt;&gt;&gt; :{
--   data Foo a = Foo Int a
--     deriving Show
--   instance VU.IsoUnbox (Foo a) (Int,a) where
--     toURepr (Foo i a) = (i,a)
--     fromURepr (i,a) = Foo i a
--     {-# INLINE toURepr #-}
--     {-# INLINE fromURepr #-}
--   newtype instance VU.MVector s (Foo a) = MV_Foo (VU.MVector s (Int, a))
--   newtype instance VU.Vector    (Foo a) = V_Foo  (VU.Vector    (Int, a))
--   deriving via (Foo a `VU.As` (Int, a)) instance VU.Unbox a =&gt; VGM.MVector MVU.MVector (Foo a)
--   deriving via (Foo a `VU.As` (Int, a)) instance VU.Unbox a =&gt; VG.Vector   VU.Vector   (Foo a)
--   instance VU.Unbox a =&gt; VU.Unbox (Foo a)
--   :}
--   </pre>
--   
--   It's also possible to use generic-based instance for <a>IsoUnbox</a>
--   which should work for all product types.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XMultiParamTypeClasses -XTypeOperators -XFlexibleInstances -XDeriveGeneric
--   
--   &gt;&gt;&gt; :set -XDerivingVia
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed         as VU
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic         as VG
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Generic.Mutable as VGM
--   
--   &gt;&gt;&gt; :{
--   data Bar a = Bar Int a
--     deriving (Show,Generic)
--   instance VU.IsoUnbox (Bar a) (Int,a) where
--   newtype instance VU.MVector s (Bar a) = MV_Bar (VU.MVector s (Int, a))
--   newtype instance VU.Vector    (Bar a) = V_Bar  (VU.Vector    (Int, a))
--   deriving via (Bar a `VU.As` (Int, a)) instance VU.Unbox a =&gt; VGM.MVector VU.MVector (Bar a)
--   deriving via (Bar a `VU.As` (Int, a)) instance VU.Unbox a =&gt; VG.Vector  VU.Vector  (Bar a)
--   instance VU.Unbox a =&gt; VU.Unbox (Bar a)
--   :}
--   </pre>
newtype As (a :: Type) (b :: Type)
As :: a -> As (a :: Type) (b :: Type)

-- | Isomorphism between type <tt>a</tt> and its representation in unboxed
--   vector <tt>b</tt>. Default instance coerces between generic
--   representations of <tt>a</tt> and <tt>b</tt> which means they have
--   same shape and corresponding fields could be coerced to each other.
--   Note that this means it's possible to have fields that have different
--   types:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XMultiParamTypeClasses -XDeriveGeneric -XFlexibleInstances
--   
--   &gt;&gt;&gt; import GHC.Generics (Generic)
--   
--   &gt;&gt;&gt; import Data.Monoid
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; :{
--   data Foo a = Foo Int a
--     deriving (Show,Generic)
--   instance VU.IsoUnbox (Foo a) (Int, a)
--   instance VU.IsoUnbox (Foo a) (Sum Int, Product a)
--   :}
--   </pre>
class IsoUnbox a b

-- | Convert value into it representation in unboxed vector.
toURepr :: IsoUnbox a b => a -> b

-- | Convert value into it representation in unboxed vector.
toURepr :: (IsoUnbox a b, Generic a, Generic b, Coercible (Rep a ()) (Rep b ())) => a -> b

-- | Convert value representation in unboxed vector back to value.
fromURepr :: IsoUnbox a b => b -> a

-- | Convert value representation in unboxed vector back to value.
fromURepr :: (IsoUnbox a b, Generic a, Generic b, Coercible (Rep b ()) (Rep a ())) => b -> a
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Vector.Unboxed.Base.Vector a)
instance (Data.Vector.Unboxed.Base.Unbox a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Semigroup (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => GHC.Base.Monoid (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Show.Show a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Show.Show (Data.Vector.Unboxed.Base.Vector a)
instance (GHC.Read.Read a, Data.Vector.Unboxed.Base.Unbox a) => GHC.Read.Read (Data.Vector.Unboxed.Base.Vector a)
instance Data.Vector.Unboxed.Base.Unbox e => GHC.IsList.IsList (Data.Vector.Unboxed.Base.Vector e)


-- | Mutable adaptive unboxed vectors.
module Data.Vector.Unboxed.Mutable
data family MVector s a
type IOVector = MVector RealWorld
type STVector s = MVector s
class (Vector Vector a, MVector MVector a) => Unbox a

-- | Length of the mutable vector.
length :: Unbox a => MVector s a -> Int

-- | Check whether the vector is empty.
null :: Unbox a => MVector s a -> Bool

-- | Yield a part of the mutable vector without copying it. The vector must
--   contain at least <tt>i+n</tt> elements.
slice :: Unbox a => Int -> Int -> MVector s a -> MVector s a

-- | Drop the last element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
init :: Unbox a => MVector s a -> MVector s a

-- | Drop the first element of the mutable vector without making a copy. If
--   the vector is empty, an exception is thrown.
tail :: Unbox a => MVector s a -> MVector s a

-- | Take the <tt>n</tt> first elements of the mutable vector without
--   making a copy. For negative <tt>n</tt>, the empty vector is returned.
--   If <tt>n</tt> is larger than the vector's length, the vector is
--   returned unchanged.
take :: Unbox a => Int -> MVector s a -> MVector s a

-- | Drop the <tt>n</tt> first element of the mutable vector without making
--   a copy. For negative <tt>n</tt>, the vector is returned unchanged. If
--   <tt>n</tt> is larger than the vector's length, the empty vector is
--   returned.
drop :: Unbox a => Int -> MVector s a -> MVector s a

-- | <i>O(1)</i> Split the mutable vector into the first <tt>n</tt>
--   elements and the remainder, without copying.
--   
--   Note that <tt><a>splitAt</a> n v</tt> is equivalent to
--   <tt>(<a>take</a> n v, <a>drop</a> n v)</tt>, but slightly more
--   efficient.
splitAt :: Unbox a => Int -> MVector s a -> (MVector s a, MVector s a)

-- | Yield a part of the mutable vector without copying it. No bounds
--   checks are performed.
unsafeSlice :: Unbox a => Int -> Int -> MVector s a -> MVector s a

-- | Same as <a>init</a>, but doesn't do range checks.
unsafeInit :: Unbox a => MVector s a -> MVector s a

-- | Same as <a>tail</a>, but doesn't do range checks.
unsafeTail :: Unbox a => MVector s a -> MVector s a

-- | Unsafe variant of <a>take</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeTake :: Unbox a => Int -> MVector s a -> MVector s a

-- | Unsafe variant of <a>drop</a>. If <tt>n</tt> is out of range, it will
--   simply create an invalid slice that likely violate memory safety.
unsafeDrop :: Unbox a => Int -> MVector s a -> MVector s a

-- | Check whether two vectors overlap.
overlaps :: Unbox a => MVector s a -> MVector s a -> Bool

-- | Create a mutable vector of the given length.
new :: (PrimMonad m, Unbox a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length. The vector content is
--   uninitialized, which means it is filled with whatever the underlying
--   memory buffer happens to contain.
unsafeNew :: (PrimMonad m, Unbox a) => Int -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with an initial value.
replicate :: (PrimMonad m, Unbox a) => Int -> a -> m (MVector (PrimState m) a)

-- | Create a mutable vector of the given length (0 if the length is
--   negative) and fill it with values produced by repeatedly executing the
--   monadic action.
replicateM :: (PrimMonad m, Unbox a) => Int -> m a -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   function to each index. Iteration starts at index 0.
generate :: (PrimMonad m, Unbox a) => Int -> (Int -> a) -> m (MVector (PrimState m) a)

-- | <i>O(n)</i> Create a mutable vector of the given length (0 if the
--   length is negative) and fill it with the results of applying the
--   monadic function to each index. Iteration starts at index 0.
generateM :: (PrimMonad m, Unbox a) => Int -> (Int -> m a) -> m (MVector (PrimState m) a)

-- | Create a copy of a mutable vector.
clone :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Grow an unboxed vector by the given number of elements. The number
--   must be non-negative. It has the same semantics as <a>grow</a> for
--   generic vectors.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed as VU
--   
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed.Mutable as MVU
--   
--   &gt;&gt;&gt; mv &lt;- VU.thaw $ VU.fromList ([('a', 10), ('b', 20), ('c', 30)] :: [(Char, Int)])
--   
--   &gt;&gt;&gt; mv' &lt;- MVU.grow mv 2
--   </pre>
--   
--   Extra memory at the end of the newly allocated vector is initialized
--   to 0 bytes, which for <a>Unbox</a> instance will usually correspond to
--   some default value for a particular type, e.g. <tt>0</tt> for
--   <tt>Int</tt>, <tt>False</tt> for <tt>Bool</tt>, etc. However, if
--   <a>unsafeGrow</a> was used instead, this would not have been
--   guaranteed and some garbage would be there instead.
--   
--   <pre>
--   &gt;&gt;&gt; VU.freeze mv'
--   [('a',10),('b',20),('c',30),('\NUL',0),('\NUL',0)]
--   </pre>
--   
--   Having the extra space we can write new values in there:
--   
--   <pre>
--   &gt;&gt;&gt; MVU.write mv' 3 ('d', 999)
--   
--   &gt;&gt;&gt; VU.freeze mv'
--   [('a',10),('b',20),('c',30),('d',999),('\NUL',0)]
--   </pre>
--   
--   It is important to note that the source mutable vector is not affected
--   when the newly allocated one is mutated.
--   
--   <pre>
--   &gt;&gt;&gt; MVU.write mv' 2 ('X', 888)
--   
--   &gt;&gt;&gt; VU.freeze mv'
--   [('a',10),('b',20),('X',888),('d',999),('\NUL',0)]
--   
--   &gt;&gt;&gt; VU.freeze mv
--   [('a',10),('b',20),('c',30)]
--   </pre>
grow :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Grow a vector by the given number of elements. The number must be
--   non-negative, but this is not checked. This has the same semantics as
--   <a>unsafeGrow</a> for generic vectors.
unsafeGrow :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)

-- | Reset all elements of the vector to some undefined value, clearing all
--   references to external objects. This is usually a noop for unboxed
--   vectors.
clear :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> m ()

-- | <i>O(1)</i> Zip 2 vectors.
zip :: (Unbox a, Unbox b) => MVector s a -> MVector s b -> MVector s (a, b)

-- | <i>O(1)</i> Zip 3 vectors.
zip3 :: (Unbox a, Unbox b, Unbox c) => MVector s a -> MVector s b -> MVector s c -> MVector s (a, b, c)

-- | <i>O(1)</i> Zip 4 vectors.
zip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s (a, b, c, d)

-- | <i>O(1)</i> Zip 5 vectors.
zip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s (a, b, c, d, e)

-- | <i>O(1)</i> Zip 6 vectors.
zip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s a -> MVector s b -> MVector s c -> MVector s d -> MVector s e -> MVector s f -> MVector s (a, b, c, d, e, f)

-- | <i>O(1)</i> Unzip 2 vectors.
unzip :: (Unbox a, Unbox b) => MVector s (a, b) -> (MVector s a, MVector s b)

-- | <i>O(1)</i> Unzip 3 vectors.
unzip3 :: (Unbox a, Unbox b, Unbox c) => MVector s (a, b, c) -> (MVector s a, MVector s b, MVector s c)

-- | <i>O(1)</i> Unzip 4 vectors.
unzip4 :: (Unbox a, Unbox b, Unbox c, Unbox d) => MVector s (a, b, c, d) -> (MVector s a, MVector s b, MVector s c, MVector s d)

-- | <i>O(1)</i> Unzip 5 vectors.
unzip5 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e) => MVector s (a, b, c, d, e) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e)

-- | <i>O(1)</i> Unzip 6 vectors.
unzip6 :: (Unbox a, Unbox b, Unbox c, Unbox d, Unbox e, Unbox f) => MVector s (a, b, c, d, e, f) -> (MVector s a, MVector s b, MVector s c, MVector s d, MVector s e, MVector s f)

-- | Yield the element at the given position. Will throw an exception if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed.Mutable as MVU
--   
--   &gt;&gt;&gt; v &lt;- MVU.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVU.read v 3
--   9
--   </pre>
read :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m a

-- | Yield the element at the given position. Returns <tt>Nothing</tt> if
--   the index is out of range.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector.Unboxed.Mutable as MVU
--   
--   &gt;&gt;&gt; v &lt;- MVU.generate 10 (\x -&gt; x*x)
--   
--   &gt;&gt;&gt; MVU.readMaybe v 3
--   Just 9
--   
--   &gt;&gt;&gt; MVU.readMaybe v 13
--   Nothing
--   </pre>
readMaybe :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m (Maybe a)

-- | Replace the element at the given position.
write :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position.
modify :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function.
modifyM :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions.
swap :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
exchange :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m a

-- | Yield the element at the given position. No bounds checks are
--   performed.
unsafeRead :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> m a

-- | Replace the element at the given position. No bounds checks are
--   performed.
unsafeWrite :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m ()

-- | Modify the element at the given position. No bounds checks are
--   performed.
unsafeModify :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> a) -> Int -> m ()

-- | Modify the element at the given position using a monadic function. No
--   bounds checks are performed.
unsafeModifyM :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m a) -> Int -> m ()

-- | Swap the elements at the given positions. No bounds checks are
--   performed.
unsafeSwap :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> Int -> m ()

-- | Replace the element at the given position and return the old element.
--   No bounds checks are performed.
unsafeExchange :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> Int -> a -> m a

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results.
mapM_ :: (PrimMonad m, Unbox a) => (a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results.
imapM_ :: (PrimMonad m, Unbox a) => (Int -> a -> m b) -> MVector (PrimState m) a -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector,
--   discarding the results. It's the same as <tt>flip mapM_</tt>.
forM_ :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (a -> m b) -> m ()

-- | <i>O(n)</i> Apply the monadic action to every element of the vector
--   and its index, discarding the results. It's the same as <tt>flip
--   imapM_</tt>.
iforM_ :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> (Int -> a -> m b) -> m ()

-- | <i>O(n)</i> Pure left fold.
foldl :: (PrimMonad m, Unbox a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator.
foldl' :: (PrimMonad m, Unbox a) => (b -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold.
foldM :: (PrimMonad m, Unbox a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator.
foldM' :: (PrimMonad m, Unbox a) => (b -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold.
foldr :: (PrimMonad m, Unbox a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator.
foldr' :: (PrimMonad m, Unbox a) => (a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold.
foldrM :: (PrimMonad m, Unbox a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator.
foldrM' :: (PrimMonad m, Unbox a) => (a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold using a function applied to each element
--   and its index.
ifoldl :: (PrimMonad m, Unbox a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure left fold with strict accumulator using a function
--   applied to each element and its index.
ifoldl' :: (PrimMonad m, Unbox a) => (b -> Int -> a -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold using a function applied to each element and
--   its index.
ifoldM :: (PrimMonad m, Unbox a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic fold with strict accumulator using a function
--   applied to each element and its index.
ifoldM' :: (PrimMonad m, Unbox a) => (b -> Int -> a -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold using a function applied to each element
--   and its index.
ifoldr :: (PrimMonad m, Unbox a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Pure right fold with strict accumulator using a function
--   applied to each element and its index.
ifoldr' :: (PrimMonad m, Unbox a) => (Int -> a -> b -> b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold using a function applied to each
--   element and its index.
ifoldrM :: (PrimMonad m, Unbox a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | <i>O(n)</i> Monadic right fold with strict accumulator using a
--   function applied to each element and its index.
ifoldrM' :: (PrimMonad m, Unbox a) => (Int -> a -> b -> m b) -> b -> MVector (PrimState m) a -> m b

-- | Compute the (lexicographically) next permutation of the given vector
--   in-place. Returns False when the input is the last permutation.
nextPermutation :: (PrimMonad m, Ord e, Unbox e) => MVector (PrimState m) e -> m Bool

-- | Set all elements of the vector to the given value.
set :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap.
copy :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length.
--   
--   If the vectors do not overlap, then this is equivalent to <a>copy</a>.
--   Otherwise, the copying is performed as if the source vector were
--   copied to a temporary vector and then the temporary vector was copied
--   to the target vector.
move :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy a vector. The two vectors must have the same length and may not
--   overlap, but this is not checked.
unsafeCopy :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of a vector. The two vectors must have the same
--   length, but this is not checked.
--   
--   If the vectors do not overlap, then this is equivalent to
--   <a>unsafeCopy</a>. Otherwise, the copying is performed as if the
--   source vector were copied to a temporary vector and then the temporary
--   vector was copied to the target vector.
unsafeMove :: (PrimMonad m, Unbox a) => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type)

-- | State token type.
type family PrimState (m :: Type -> Type)

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld
