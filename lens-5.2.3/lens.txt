-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lenses, Folds and Traversals
--   
--   This package comes "Batteries Included" with many useful lenses for
--   the types commonly used from the Haskell Platform, and with tools for
--   automatically generating lenses and isomorphisms for user-supplied
--   data types.
--   
--   The combinators in <tt>Control.Lens</tt> provide a highly generic
--   toolbox for composing families of getters, folds, isomorphisms,
--   traversals, setters and lenses and their indexed variants.
--   
--   An overview, with a large number of examples can be found in the
--   <a>README</a>.
--   
--   An introductory video on the style of code used in this library by
--   Simon Peyton Jones is available from <a>Skills Matter</a>.
--   
--   A video on how to use lenses and how they are constructed is available
--   on <a>youtube</a>.
--   
--   Slides for that second talk can be obtained from <a>comonad.com</a>.
--   
--   More information on the care and feeding of lenses, including a brief
--   tutorial and motivation for their types can be found on the <a>lens
--   wiki</a>.
--   
--   A small game of <tt>pong</tt> and other more complex examples that
--   manage their state using lenses can be found in the <a>example
--   folder</a>.
--   
--   <i>Lenses, Folds and Traversals</i>
--   
--   With some signatures simplified, the core of the hierarchy of
--   lens-like constructions looks like:
--   
--   
--   <a>(Local Copy)</a>
--   
--   You can compose any two elements of the hierarchy above using
--   <tt>(.)</tt> from the <tt>Prelude</tt>, and you can use any element of
--   the hierarchy as any type it linked to above it.
--   
--   The result is their lowest upper bound in the hierarchy (or an error
--   if that bound doesn't exist).
--   
--   For instance:
--   
--   <ul>
--   <li>You can use any <a>Traversal</a> as a <a>Fold</a> or as a
--   <a>Setter</a>.</li>
--   <li>The composition of a <a>Traversal</a> and a <a>Getter</a> yields a
--   <a>Fold</a>.</li>
--   </ul>
--   
--   <i>Minimizing Dependencies</i>
--   
--   If you want to provide lenses and traversals for your own types in
--   your own libraries, then you can do so without incurring a dependency
--   on this (or any other) lens package at all.
--   
--   <i>e.g.</i> for a data type:
--   
--   <pre>
--   data Foo a = Foo Int Int a
--   </pre>
--   
--   You can define lenses such as
--   
--   <pre>
--   -- bar :: Lens' (Foo a) Int
--   bar :: Functor f =&gt; (Int -&gt; f Int) -&gt; Foo a -&gt; f (Foo a)
--   bar f (Foo a b c) = fmap (\a' -&gt; Foo a' b c) (f a)
--   </pre>
--   
--   <pre>
--   -- quux :: Lens (Foo a) (Foo b) a b
--   quux :: Functor f =&gt; (a -&gt; f b) -&gt; Foo a -&gt; f (Foo b)
--   quux f (Foo a b c) = fmap (Foo a b) (f c)
--   </pre>
--   
--   without the need to use any type that isn't already defined in the
--   <tt>Prelude</tt>.
--   
--   And you can define a traversal of multiple fields with
--   <a>Control.Applicative.Applicative</a>:
--   
--   <pre>
--   -- traverseBarAndBaz :: Traversal' (Foo a) Int
--   traverseBarAndBaz :: Applicative f =&gt; (Int -&gt; f Int) -&gt; Foo a -&gt; f (Foo a)
--   traverseBarAndBaz f (Foo a b c) = Foo &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; pure c
--   </pre>
--   
--   What is provided in this library is a number of stock lenses and
--   traversals for common haskell types, a wide array of combinators for
--   working them, and more exotic functionality, (<i>e.g.</i> getters,
--   setters, indexed folds, isomorphisms).
@package lens
@version 5.2.3


-- | In <a>Control.Lens.Wrapped</a>, we need to muck around with the
--   internals of the newtypes in <a>Foreign.C.Types</a>. Unfortunately,
--   the exact types used varies wildly from platform to platform, so
--   trying to manage the imports necessary to bring these types in scope
--   can be unwieldy.
--   
--   To make things easier, we use this module as a way to import
--   everything carte blanche that might be used internally in
--   <a>Foreign.C.Types</a>. For now, this consists of all the exports from
--   the <a>Data.Int</a> and <a>Data.Word</a> modules, as well as the
--   <a>Ptr</a> type.
module Control.Lens.Internal.CTypes

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class <a>Storable</a>
--   which provides the marshalling operations. However this is not
--   essential, and you can provide your own operations to access the
--   pointer. For example you might write small foreign functions to get or
--   set the fields of a C <tt>struct</tt>.
data () => Ptr a


-- | This module exists for the sole purpose of redefining the <a>head</a>
--   and <a>tail</a> functions (which are normally provided by the
--   <tt>Prelude</tt>) so that they can be used in the doctests of
--   <a>Lens</a>.
--   
--   The <a>head</a> and <a>tail</a> functions are partial, and as of GHC
--   9.8, there is a <tt>-Wx-partial</tt> warning (implied by
--   <tt>-Wall</tt>) that triggers any time you use either of these
--   functions. This is a fairly reasonable default in most settings, but
--   there are a handful of doctests in <a>Lens</a> that do in fact rely on
--   <a>head</a> and <a>tail</a> being partial functions. These doctests
--   demonstrate that various functions in <a>Lens</a> can recover from
--   exceptions that are thrown due to partiality (see, for instance, the
--   <tt>upon</tt> function).
--   
--   One possible workaround would be to disable <tt>-Wx-partial</tt>. We
--   don't want to disable the warning for <i>all</i> code in
--   <tt>lens</tt>, however—we only want to disable it for a particular
--   group of doctests. It is rather tricky to achieve this level of
--   granularity, unfortunately. This is because tools like
--   <tt>cabal-docspec</tt> rely on GHCi to work, and the statefulness of
--   GHCi's <tt>:set</tt> command means that disabling <tt>-Wx-partial</tt>
--   might leak into other modules' doctests, which we don't want.
--   
--   Instead, we opt to redefine our own versions of <a>head</a> and
--   <a>tail</a> here, which do not trigger any <tt>-Wx-partial</tt>
--   warnings, and use them in the <a>Lens</a> doctests. This has no impact
--   on anyone reading the doctests, as these functions will look
--   indistinguishable from the <a>head</a> and <a>tail</a> functions in
--   the <tt>Prelude</tt>. One consequence of this design is that we must
--   export the <a>Doctest</a> module, as GHCi (and therefore
--   <tt>cabal-docspec</tt>) won't be able to import it otherwise. Despite
--   this technical oddity, this module should be thought of as internal to
--   <tt>lens</tt>.
module Control.Lens.Internal.Doctest
head :: [a] -> a
tail :: [a] -> [a]


-- | This module includes orphan instances for <tt>(,)</tt>, <a>Either</a>
--   and <tt>Const</tt> that should be supplied by base. These have moved
--   to <tt>semigroupoids</tt> as of 4.2.
module Control.Lens.Internal.Instances


module Control.Lens.Internal.Iso

-- | This is used internally by the <a>Iso</a> code to provide efficient
--   access to the two functions that make up an isomorphism.
data Exchange a b s t
Exchange :: (s -> a) -> (b -> t) -> Exchange a b s t

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t
instance Control.Lens.Internal.Iso.Reversing [a]
instance Control.Lens.Internal.Iso.Reversing (GHC.Base.NonEmpty a)
instance Control.Lens.Internal.Iso.Reversing Data.ByteString.Internal.Type.ByteString
instance Control.Lens.Internal.Iso.Reversing Data.ByteString.Lazy.Internal.ByteString
instance Control.Lens.Internal.Iso.Reversing Data.Text.Internal.Text
instance Control.Lens.Internal.Iso.Reversing Data.Text.Internal.Lazy.Text
instance Control.Lens.Internal.Iso.Reversing (Data.Vector.Vector a)
instance Control.Lens.Internal.Iso.Reversing (Data.Sequence.Internal.Seq a)
instance Data.Primitive.Types.Prim a => Control.Lens.Internal.Iso.Reversing (Data.Vector.Primitive.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Control.Lens.Internal.Iso.Reversing (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Control.Lens.Internal.Iso.Reversing (Data.Vector.Storable.Vector a)
instance GHC.Base.Functor (Control.Lens.Internal.Iso.Exchange a b s)
instance Data.Profunctor.Unsafe.Profunctor (Control.Lens.Internal.Iso.Exchange a b)


-- | This module provides utility functions on lists used by the library
--   implementation.
module Control.Lens.Internal.List

-- | Return the the subset of given ordinals within a given bound and in
--   order of the first occurrence seen.
--   
--   Bound: <tt>0 &lt;= x &lt; l</tt>
--   
--   <pre>
--   &gt;&gt;&gt; ordinalNub 3 [-1,2,1,4,2,3]
--   [2,1]
--   </pre>
ordinalNub :: Int -> [Int] -> [Int]

-- | &lt;math&gt;. The <a>stripSuffix</a> function drops the given suffix
--   from a list. It returns <a>Nothing</a> if the list did not end with
--   the suffix given, or <a>Just</a> the list after the suffix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "bar" "foobar"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "bar" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]


-- | This module provides implementation details of the combinators in
--   <a>Control.Lens.Level</a>, which provides for the breadth-first
--   <a>Traversal</a> of an arbitrary <a>Traversal</a>.
module Control.Lens.Internal.Level

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a
Two :: {-# UNPACK #-} !Word -> !Level i a -> !Level i a -> Level i a
One :: i -> a -> Level i a
Zero :: Level i a

-- | This is an illegal <a>Monoid</a> used to construct a single
--   <a>Level</a>.
newtype Deepening i a
Deepening :: (forall r. Int -> (Level i a -> Bool -> r) -> r) -> Deepening i a
[runDeepening] :: Deepening i a -> forall r. Int -> (Level i a -> Bool -> r) -> r

-- | Generate the leaf of a given <a>Deepening</a> based on whether or not
--   we're at the correct depth.
deepening :: i -> a -> Deepening i a

-- | This is an illegal <a>Applicative</a> used to replace the contents of
--   a list of consecutive <a>Level</a> values representing each layer of a
--   structure into the original shape that they were derived from.
--   
--   Attempting to <tt>Flow</tt> something back into a shape other than the
--   one it was taken from will fail.
newtype Flows i b a
Flows :: ([Level i b] -> a) -> Flows i b a
[runFlows] :: Flows i b a -> [Level i b] -> a
instance (GHC.Read.Read i, GHC.Read.Read a) => GHC.Read.Read (Control.Lens.Internal.Level.Level i a)
instance (GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (Control.Lens.Internal.Level.Level i a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord a) => GHC.Classes.Ord (Control.Lens.Internal.Level.Level i a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq a) => GHC.Classes.Eq (Control.Lens.Internal.Level.Level i a)
instance GHC.Base.Functor (Control.Lens.Internal.Level.Flows i b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Level.Flows i b)
instance GHC.Base.Applicative (Control.Lens.Internal.Level.Flows i b)
instance GHC.Base.Semigroup (Control.Lens.Internal.Level.Deepening i a)
instance GHC.Base.Monoid (Control.Lens.Internal.Level.Deepening i a)
instance GHC.Base.Functor (Control.Lens.Internal.Level.Level i)
instance Data.Foldable.Foldable (Control.Lens.Internal.Level.Level i)
instance Data.Traversable.Traversable (Control.Lens.Internal.Level.Level i)
instance WithIndex.FunctorWithIndex i (Control.Lens.Internal.Level.Level i)
instance WithIndex.FoldableWithIndex i (Control.Lens.Internal.Level.Level i)
instance WithIndex.TraversableWithIndex i (Control.Lens.Internal.Level.Level i)


-- | Internal implementation details for <a>Indexed</a> lens-likes
module Control.Lens.Internal.Indexed

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
[runIndexed] :: Indexed i a b -> i -> a -> b

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p) => Conjoined p

-- | <a>Conjoined</a> is strong enough to let us distribute every
--   <a>Conjoined</a> <a>Profunctor</a> over every Haskell <a>Functor</a>.
--   This is effectively a generalization of <a>fmap</a>.
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)

-- | This permits us to make a decision at an outermost point about whether
--   or not we use an index.
--   
--   Ideally any use of this function should be done in such a way so that
--   you compute the same answer, but this cannot be enforced at the type
--   level.
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i p

-- | Build a function from an <a>indexed</a> function.
indexed :: Indexable i p => p a b -> i -> a -> b

-- | <a>Applicative</a> composition of <tt><a>State</a> <a>Int</a></tt>
--   with a <a>Functor</a>, used by <a>indexed</a>.
newtype Indexing f a
Indexing :: (Int -> (Int, f a)) -> Indexing f a
[runIndexing] :: Indexing f a -> Int -> (Int, f a)

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | <a>Applicative</a> composition of <tt><a>State</a> <a>Int64</a></tt>
--   with a <a>Functor</a>, used by <a>indexed64</a>.
newtype Indexing64 f a
Indexing64 :: (Int64 -> (Int64, f a)) -> Indexing64 f a
[runIndexing64] :: Indexing64 f a -> Int64 -> (Int64, f a)

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex
--   [(0,10),(1,20),(2,30)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex . alongside negated (re _Show)
--   [(0,"10"),(-1,"20"),(-2,"30")]
--   </pre>
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Lens.Internal.Indexed.Indexing64 f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Indexed.Indexing64 f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Lens.Internal.Indexed.Indexing64 f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Indexed.Indexing64 f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Lens.Internal.Indexed.Indexing f)
instance Data.Functor.Bind.Class.Apply f => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Indexed.Indexing f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.Lens.Internal.Indexed.Indexing f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Indexed.Indexing f)
instance GHC.Base.Semigroup (f a) => GHC.Base.Semigroup (Control.Lens.Internal.Indexed.Indexing f a)
instance GHC.Base.Monoid (f a) => GHC.Base.Monoid (Control.Lens.Internal.Indexed.Indexing f a)
instance GHC.Base.Functor (Control.Lens.Internal.Indexed.Indexed i a)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Indexed.Indexed i a)
instance GHC.Base.Applicative (Control.Lens.Internal.Indexed.Indexed i a)
instance Data.Functor.Bind.Class.Bind (Control.Lens.Internal.Indexed.Indexed i a)
instance GHC.Base.Monad (Control.Lens.Internal.Indexed.Indexed i a)
instance Control.Monad.Fix.MonadFix (Control.Lens.Internal.Indexed.Indexed i a)
instance Data.Profunctor.Unsafe.Profunctor (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Closed.Closed (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Strong.Costrong (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Sieve.Sieve (Control.Lens.Internal.Indexed.Indexed i) ((->) i)
instance Data.Profunctor.Rep.Representable (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Sieve.Cosieve (Control.Lens.Internal.Indexed.Indexed i) ((,) i)
instance Data.Profunctor.Rep.Corepresentable (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Choice.Choice (Control.Lens.Internal.Indexed.Indexed i)
instance Data.Profunctor.Strong.Strong (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Category.Category (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Arrow.Arrow (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Arrow.ArrowChoice (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Arrow.ArrowApply (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Arrow.ArrowLoop (Control.Lens.Internal.Indexed.Indexed i)
instance Control.Lens.Internal.Indexed.Conjoined (Control.Lens.Internal.Indexed.Indexed i)
instance (i GHC.Types.~ j) => Control.Lens.Internal.Indexed.Indexable i (Control.Lens.Internal.Indexed.Indexed j)
instance Control.Lens.Internal.Indexed.Indexable i (->)
instance Control.Lens.Internal.Indexed.Conjoined (->)


module Control.Lens.Internal.Getter

-- | The <a>mempty</a> equivalent for a <a>Contravariant</a>
--   <a>Applicative</a> <a>Functor</a>.
noEffect :: (Contravariant f, Applicative f) => f a
newtype AlongsideLeft f b a
AlongsideLeft :: f (a, b) -> AlongsideLeft f b a
[getAlongsideLeft] :: AlongsideLeft f b a -> f (a, b)
newtype AlongsideRight f a b
AlongsideRight :: f (a, b) -> AlongsideRight f a b
[getAlongsideRight] :: AlongsideRight f a b -> f (a, b)
instance GHC.Show.Show (f (a, b)) => GHC.Show.Show (Control.Lens.Internal.Getter.AlongsideLeft f b a)
instance GHC.Read.Read (f (a, b)) => GHC.Read.Read (Control.Lens.Internal.Getter.AlongsideLeft f b a)
instance GHC.Show.Show (f (a, b)) => GHC.Show.Show (Control.Lens.Internal.Getter.AlongsideRight f a b)
instance GHC.Read.Read (f (a, b)) => GHC.Read.Read (Control.Lens.Internal.Getter.AlongsideRight f a b)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Lens.Internal.Getter.AlongsideRight f a)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Getter.AlongsideRight f a)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Lens.Internal.Getter.AlongsideRight f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Lens.Internal.Getter.AlongsideRight f a)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Lens.Internal.Getter.AlongsideRight f a)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Lens.Internal.Getter.AlongsideRight f a)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Control.Lens.Internal.Getter.AlongsideRight f)
instance Data.Foldable.Foldable f => Data.Bifoldable.Bifoldable (Control.Lens.Internal.Getter.AlongsideRight f)
instance Data.Traversable.Traversable f => Data.Bitraversable.Bitraversable (Control.Lens.Internal.Getter.AlongsideRight f)
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance Data.Semigroup.Traversable.Class.Traversable1 f => Data.Semigroup.Traversable.Class.Traversable1 (Control.Lens.Internal.Getter.AlongsideLeft f b)
instance GHC.Base.Functor f => Data.Bifunctor.Bifunctor (Control.Lens.Internal.Getter.AlongsideLeft f)
instance Data.Foldable.Foldable f => Data.Bifoldable.Bifoldable (Control.Lens.Internal.Getter.AlongsideLeft f)
instance Data.Traversable.Traversable f => Data.Bitraversable.Bitraversable (Control.Lens.Internal.Getter.AlongsideLeft f)


module Control.Lens.Internal.Fold

-- | A <a>Monoid</a> for a <a>Contravariant</a> <a>Applicative</a>.
newtype Folding f a
Folding :: f a -> Folding f a
[getFolding] :: Folding f a -> f a

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
newtype Traversed a f
Traversed :: f a -> Traversed a f
[getTraversed] :: Traversed a f -> f a

-- | Used internally by <a>traverse1Of_</a> and the like.
newtype TraversedF a f
TraversedF :: f a -> TraversedF a f
[getTraversedF] :: TraversedF a f -> f a

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
--   
--   See 4.16 Changelog entry for the explanation of "why not Apply f
--   =&gt;"?
newtype Sequenced a m
Sequenced :: m a -> Sequenced a m
[getSequenced] :: Sequenced a m -> m a

-- | Used for <a>firstOf</a>.
data Leftmost a
LPure :: Leftmost a
LLeaf :: a -> Leftmost a
LStep :: Leftmost a -> Leftmost a

-- | Extract the <a>Leftmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getLeftmost :: Leftmost a -> Maybe a

-- | Used for <a>lastOf</a>.
data Rightmost a
RPure :: Rightmost a
RLeaf :: a -> Rightmost a
RStep :: Rightmost a -> Rightmost a

-- | Extract the <a>Rightmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getRightmost :: Rightmost a -> Maybe a
data () => ReifiedMonoid a
ReifiedMonoid :: (a -> a -> a) -> a -> ReifiedMonoid a
[reifiedMappend] :: ReifiedMonoid a -> a -> a -> a
[reifiedMempty] :: ReifiedMonoid a -> a
newtype NonEmptyDList a
NonEmptyDList :: ([a] -> NonEmpty a) -> NonEmptyDList a
[getNonEmptyDList] :: NonEmptyDList a -> [a] -> NonEmpty a
instance GHC.Base.Semigroup (Control.Lens.Internal.Fold.Rightmost a)
instance GHC.Base.Monoid (Control.Lens.Internal.Fold.Rightmost a)
instance GHC.Base.Semigroup (Control.Lens.Internal.Fold.Leftmost a)
instance GHC.Base.Monoid (Control.Lens.Internal.Fold.Leftmost a)
instance GHC.Base.Semigroup (Control.Lens.Internal.Fold.NonEmptyDList a)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Control.Lens.Internal.Fold.Sequenced a m)
instance GHC.Base.Monad m => GHC.Base.Monoid (Control.Lens.Internal.Fold.Sequenced a m)
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Control.Lens.Internal.Fold.TraversedF a f)
instance (Data.Functor.Bind.Class.Apply f, GHC.Base.Applicative f) => GHC.Base.Monoid (Control.Lens.Internal.Fold.TraversedF a f)
instance GHC.Base.Applicative f => GHC.Base.Semigroup (Control.Lens.Internal.Fold.Traversed a f)
instance GHC.Base.Applicative f => GHC.Base.Monoid (Control.Lens.Internal.Fold.Traversed a f)
instance (Data.Functor.Contravariant.Contravariant f, GHC.Base.Applicative f) => GHC.Base.Semigroup (Control.Lens.Internal.Fold.Folding f a)
instance (Data.Functor.Contravariant.Contravariant f, GHC.Base.Applicative f) => GHC.Base.Monoid (Control.Lens.Internal.Fold.Folding f a)


module Control.Lens.Internal.Context

-- | This is a Bob Atkey -style 2-argument indexed functor.
--   
--   It exists as a superclass for <a>IndexedComonad</a> and expresses the
--   functoriality of an <a>IndexedComonad</a> in its third argument.
class IndexedFunctor w
ifmap :: IndexedFunctor w => (s -> t) -> w a b s -> w a b t

-- | This is a Bob Atkey -style 2-argument indexed comonad.
--   
--   It exists as a superclass for <a>IndexedComonad</a> and expresses the
--   functoriality of an <a>IndexedComonad</a> in its third argument.
--   
--   The notion of indexed monads is covered in more depth in Bob Atkey's
--   "Parameterized Notions of Computation"
--   <a>http://bentnib.org/paramnotions-jfp.pdf</a> and that construction
--   is dualized here.
class IndexedFunctor w => IndexedComonad w

-- | extract from an indexed comonadic value when the indices match.
iextract :: IndexedComonad w => w a a t -> t

-- | duplicate an indexed comonadic value splitting the index.
iduplicate :: IndexedComonad w => w a c t -> w a b (w b c t)

-- | extend a indexed comonadic computation splitting the index.
iextend :: IndexedComonad w => (w b c t -> r) -> w a c t -> w a b r

-- | This is an indexed analogue to <a>ComonadStore</a> for when you are
--   working with an <a>IndexedComonad</a>.
class IndexedComonad w => IndexedComonadStore w

-- | This is the generalization of <a>pos</a> to an indexed comonad store.
ipos :: IndexedComonadStore w => w a c t -> a

-- | This is the generalization of <a>peek</a> to an indexed comonad store.
ipeek :: IndexedComonadStore w => c -> w a c t -> t

-- | This is the generalization of <a>peeks</a> to an indexed comonad
--   store.
ipeeks :: IndexedComonadStore w => (a -> c) -> w a c t -> t

-- | This is the generalization of <a>seek</a> to an indexed comonad store.
iseek :: IndexedComonadStore w => b -> w a c t -> w b c t

-- | This is the generalization of <a>seeks</a> to an indexed comonad
--   store.
iseeks :: IndexedComonadStore w => (a -> b) -> w a c t -> w b c t

-- | This is the generalization of <a>experiment</a> to an indexed comonad
--   store.
iexperiment :: (IndexedComonadStore w, Functor f) => (b -> f c) -> w b c t -> f t

-- | We can always forget the rest of the structure of <tt>w</tt> and
--   obtain a simpler indexed comonad store model called <a>Context</a>.
context :: IndexedComonadStore w => w a b t -> Context a b t

-- | This is used internally to construct a <a>Bazaar</a>, <a>Context</a>
--   or <a>Pretext</a> from a singleton value.
class Corepresentable p => Sellable p w | w -> p
sell :: Sellable p w => p a (w a b b)

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>cloneLens</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | This is a generalized form of <a>Context</a> that can be repeatedly
--   cloned with less impact on its performance, and which permits the use
--   of an arbitrary <a>Conjoined</a> <a>Profunctor</a>
newtype Pretext p a b t
Pretext :: (forall f. Functor f => p a (f b) -> f t) -> Pretext p a b t
[runPretext] :: Pretext p a b t -> forall f. Functor f => p a (f b) -> f t

-- | <pre>
--   type <a>Pretext'</a> p a s = <a>Pretext</a> p a a s
--   </pre>
type Pretext' p a = Pretext p a a

-- | This is a generalized form of <a>Context</a> that can be repeatedly
--   cloned with less impact on its performance, and which permits the use
--   of an arbitrary <a>Conjoined</a> <a>Profunctor</a>.
--   
--   The extra phantom <a>Functor</a> is used to let us lie and claim
--   <a>Getter</a>-compatibility under limited circumstances. This is used
--   internally to permit a number of combinators to gracefully degrade
--   when applied to a <a>Fold</a> or <a>Getter</a>.
newtype PretextT p (g :: Type -> Type) a b t
PretextT :: (forall f. Functor f => p a (f b) -> f t) -> PretextT p (g :: Type -> Type) a b t
[runPretextT] :: PretextT p (g :: Type -> Type) a b t -> forall f. Functor f => p a (f b) -> f t

-- | <pre>
--   type <a>PretextT'</a> p g a s = <a>PretextT</a> p g a a s
--   </pre>
type PretextT' p g a = PretextT p g a a
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Context.PretextT p g)
instance GHC.Base.Functor (Control.Lens.Internal.Context.PretextT p g a b)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Context.PretextT p g)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Context.PretextT p g a b)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonadStore (Control.Lens.Internal.Context.PretextT p g)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Store.Class.ComonadStore a (Control.Lens.Internal.Context.PretextT p g a b)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Context.PretextT p g)
instance (Data.Profunctor.Unsafe.Profunctor p, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Context.PretextT p g a b)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Context.Pretext p)
instance GHC.Base.Functor (Control.Lens.Internal.Context.Pretext p a b)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Context.Pretext p)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Context.Pretext p a b)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonadStore (Control.Lens.Internal.Context.Pretext p)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Store.Class.ComonadStore a (Control.Lens.Internal.Context.Pretext p a b)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Context.Pretext p)
instance Control.Lens.Internal.Context.IndexedComonadStore Control.Lens.Internal.Context.Context
instance (a GHC.Types.~ b) => Control.Comonad.Store.Class.ComonadStore a (Control.Lens.Internal.Context.Context a b)
instance Control.Lens.Internal.Context.IndexedFunctor Control.Lens.Internal.Context.Context
instance Control.Lens.Internal.Context.IndexedComonad Control.Lens.Internal.Context.Context
instance GHC.Base.Functor (Control.Lens.Internal.Context.Context a b)
instance (a GHC.Types.~ b) => Control.Comonad.Comonad (Control.Lens.Internal.Context.Context a b)
instance Control.Lens.Internal.Context.Sellable (->) Control.Lens.Internal.Context.Context


module Control.Lens.Internal.Bazaar

-- | This class is used to run the various <a>Bazaar</a> variants used in
--   this library.
class Profunctor p => Bizarre p w | w -> p
bazaar :: (Bizarre p w, Applicative f) => p a (f b) -> w a b t -> f t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
[runBazaar] :: Bazaar p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' p a = Bazaar p a a

-- | <a>BazaarT</a> is like <a>Bazaar</a>, except that it provides a
--   questionable <a>Contravariant</a> instance To protect this instance it
--   relies on the soundness of another <a>Contravariant</a> type, and
--   usage conventions.
--   
--   For example. This lets us write a suitably polymorphic and lazy
--   <a>taking</a>, but there must be a better way!
newtype BazaarT p (g :: Type -> Type) a b t
BazaarT :: (forall f. Applicative f => p a (f b) -> f t) -> BazaarT p (g :: Type -> Type) a b t
[runBazaarT] :: BazaarT p (g :: Type -> Type) a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>BazaarT'</a> p g a t = <a>BazaarT</a> p g a a t
--   </pre>
type BazaarT' p g a = BazaarT p g a a
class Profunctor p => Bizarre1 p w | w -> p
bazaar1 :: (Bizarre1 p w, Apply f) => p a (f b) -> w a b t -> f t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
[runBazaar1] :: Bazaar1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' p a = Bazaar1 p a a

-- | <a>BazaarT1</a> is like <a>Bazaar1</a>, except that it provides a
--   questionable <a>Contravariant</a> instance To protect this instance it
--   relies on the soundness of another <a>Contravariant</a> type, and
--   usage conventions.
--   
--   For example. This lets us write a suitably polymorphic and lazy
--   <a>taking</a>, but there must be a better way!
newtype BazaarT1 p (g :: Type -> Type) a b t
BazaarT1 :: (forall f. Apply f => p a (f b) -> f t) -> BazaarT1 p (g :: Type -> Type) a b t
[runBazaarT1] :: BazaarT1 p (g :: Type -> Type) a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>BazaarT1'</a> p g a t = <a>BazaarT1</a> p g a a t
--   </pre>
type BazaarT1' p g a = BazaarT1 p g a a
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Bazaar.BazaarT1 p g)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Bazaar.BazaarT1 p g)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Bazaar.BazaarT1 p g)
instance Data.Profunctor.Unsafe.Profunctor p => Control.Lens.Internal.Bazaar.Bizarre1 p (Control.Lens.Internal.Bazaar.BazaarT1 p g)
instance GHC.Base.Functor (Control.Lens.Internal.Bazaar.BazaarT1 p g a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Bazaar.BazaarT1 p g a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Bazaar.BazaarT1 p g a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.ComonadApply (Control.Lens.Internal.Bazaar.BazaarT1 p g a b)
instance (Data.Profunctor.Unsafe.Profunctor p, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Bazaar.BazaarT1 p g a b)
instance Data.Functor.Contravariant.Contravariant g => GHC.Base.Semigroup (Control.Lens.Internal.Bazaar.BazaarT1 p g a b t)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Bazaar.Bazaar1 p)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Bazaar.Bazaar1 p)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Bazaar.Bazaar1 p)
instance Data.Profunctor.Unsafe.Profunctor p => Control.Lens.Internal.Bazaar.Bizarre1 p (Control.Lens.Internal.Bazaar.Bazaar1 p)
instance GHC.Base.Functor (Control.Lens.Internal.Bazaar.Bazaar1 p a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Bazaar.Bazaar1 p a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Bazaar.Bazaar1 p a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.ComonadApply (Control.Lens.Internal.Bazaar.Bazaar1 p a b)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Bazaar.BazaarT p g)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Bazaar.BazaarT p g)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Bazaar.BazaarT p g)
instance Data.Profunctor.Unsafe.Profunctor p => Control.Lens.Internal.Bazaar.Bizarre p (Control.Lens.Internal.Bazaar.BazaarT p g)
instance GHC.Base.Functor (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance GHC.Base.Applicative (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.ComonadApply (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance (Data.Profunctor.Unsafe.Profunctor p, Data.Functor.Contravariant.Contravariant g) => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Bazaar.BazaarT p g a b)
instance Data.Functor.Contravariant.Contravariant g => GHC.Base.Semigroup (Control.Lens.Internal.Bazaar.BazaarT p g a b t)
instance Data.Functor.Contravariant.Contravariant g => GHC.Base.Monoid (Control.Lens.Internal.Bazaar.BazaarT p g a b t)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Bazaar.Bazaar p)
instance Control.Lens.Internal.Indexed.Conjoined p => Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Bazaar.Bazaar p)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Context.Sellable p (Control.Lens.Internal.Bazaar.Bazaar p)
instance Data.Profunctor.Unsafe.Profunctor p => Control.Lens.Internal.Bazaar.Bizarre p (Control.Lens.Internal.Bazaar.Bazaar p)
instance GHC.Base.Functor (Control.Lens.Internal.Bazaar.Bazaar p a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Bazaar.Bazaar p a b)
instance GHC.Base.Applicative (Control.Lens.Internal.Bazaar.Bazaar p a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.Comonad (Control.Lens.Internal.Bazaar.Bazaar p a b)
instance (a GHC.Types.~ b, Control.Lens.Internal.Indexed.Conjoined p) => Control.Comonad.ComonadApply (Control.Lens.Internal.Bazaar.Bazaar p a b)


module Control.Lens.Internal.Magma

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a
[MagmaAp] :: Magma i (x -> y) b a -> Magma i x b a -> Magma i y b a
[MagmaPure] :: x -> Magma i x b a
[MagmaFmap] :: (x -> y) -> Magma i x b a -> Magma i y b a
[Magma] :: i -> a -> Magma i b b a

-- | Run a <a>Magma</a> where all the individual leaves have been converted
--   to the expected type
runMagma :: Magma i t a a -> t

-- | This is a a non-reassociating initially encoded version of
--   <a>Bazaar</a>.
newtype Molten i a b t
Molten :: Magma i t b a -> Molten i a b t
[runMolten] :: Molten i a b t -> Magma i t b a

-- | This is used to generate an indexed magma from an unindexed source
--   
--   By constructing it this way we avoid infinite reassociations in sums
--   where possible.
data Mafic a b t
Mafic :: Int -> (Int -> Magma Int t b a) -> Mafic a b t

-- | Generate a <a>Magma</a> using from a prefix sum.
runMafic :: Mafic a b t -> Magma Int t b a

-- | This is used to generate an indexed magma from an unindexed source
--   
--   By constructing it this way we avoid infinite reassociations where
--   possible.
--   
--   In <tt><a>TakingWhile</a> p g a b t</tt>, <tt>g</tt> has a
--   <tt>nominal</tt> role to avoid exposing an illegal _|_ via
--   <a>Contravariant</a>, while the remaining arguments are degraded to a
--   <tt>nominal</tt> role by the invariants of <a>Magma</a>
data TakingWhile p (g :: Type -> Type) a b t
TakingWhile :: Bool -> t -> (Bool -> Magma () t b (Corep p a)) -> TakingWhile p (g :: Type -> Type) a b t

-- | Generate a <a>Magma</a> with leaves only while the predicate holds
--   from left to right.
runTakingWhile :: TakingWhile p f a b t -> Magma () t b (Corep p a)
instance GHC.Base.Functor (Control.Lens.Internal.Magma.TakingWhile p f a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Magma.TakingWhile p f a b)
instance GHC.Base.Applicative (Control.Lens.Internal.Magma.TakingWhile p f a b)
instance Data.Profunctor.Rep.Corepresentable p => Control.Lens.Internal.Bazaar.Bizarre p (Control.Lens.Internal.Magma.TakingWhile p g)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Magma.TakingWhile p f a b)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Magma.TakingWhile p f)
instance GHC.Base.Functor (Control.Lens.Internal.Magma.Mafic a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Magma.Mafic a b)
instance GHC.Base.Applicative (Control.Lens.Internal.Magma.Mafic a b)
instance Control.Lens.Internal.Context.Sellable (->) Control.Lens.Internal.Magma.Mafic
instance Control.Lens.Internal.Bazaar.Bizarre (Control.Lens.Internal.Indexed.Indexed GHC.Types.Int) Control.Lens.Internal.Magma.Mafic
instance Control.Lens.Internal.Context.IndexedFunctor Control.Lens.Internal.Magma.Mafic
instance GHC.Base.Functor (Control.Lens.Internal.Magma.Molten i a b)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Magma.Molten i a b)
instance GHC.Base.Applicative (Control.Lens.Internal.Magma.Molten i a b)
instance Control.Lens.Internal.Context.Sellable (Control.Lens.Internal.Indexed.Indexed i) (Control.Lens.Internal.Magma.Molten i)
instance Control.Lens.Internal.Bazaar.Bizarre (Control.Lens.Internal.Indexed.Indexed i) (Control.Lens.Internal.Magma.Molten i)
instance Control.Lens.Internal.Context.IndexedFunctor (Control.Lens.Internal.Magma.Molten i)
instance Control.Lens.Internal.Context.IndexedComonad (Control.Lens.Internal.Magma.Molten i)
instance (a GHC.Types.~ b) => Control.Comonad.Comonad (Control.Lens.Internal.Magma.Molten i a b)
instance GHC.Base.Functor (Control.Lens.Internal.Magma.Magma i t b)
instance Data.Foldable.Foldable (Control.Lens.Internal.Magma.Magma i t b)
instance Data.Traversable.Traversable (Control.Lens.Internal.Magma.Magma i t b)
instance WithIndex.FunctorWithIndex i (Control.Lens.Internal.Magma.Magma i t b)
instance WithIndex.FoldableWithIndex i (Control.Lens.Internal.Magma.Magma i t b)
instance WithIndex.TraversableWithIndex i (Control.Lens.Internal.Magma.Magma i t b)
instance (GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (Control.Lens.Internal.Magma.Magma i t b a)


module Control.Lens.Internal.Prism

-- | This type is used internally by the <a>Prism</a> code to provide
--   efficient access to the two parts of a <tt>Prism</tt>.
data Market a b s t
Market :: (b -> t) -> (s -> Either t a) -> Market a b s t

-- | <pre>
--   type <a>Market'</a> a s t = <a>Market</a> a a s t
--   </pre>
type Market' a = Market a a
instance GHC.Base.Functor (Control.Lens.Internal.Prism.Market a b s)
instance Data.Profunctor.Unsafe.Profunctor (Control.Lens.Internal.Prism.Market a b)
instance Data.Profunctor.Choice.Choice (Control.Lens.Internal.Prism.Market a b)

module Control.Lens.Internal.Profunctor
newtype WrappedPafb f p a b
WrapPafb :: p a (f b) -> WrappedPafb f p a b
[unwrapPafb] :: WrappedPafb f p a b -> p a (f b)
instance (GHC.Base.Functor f, Data.Profunctor.Unsafe.Profunctor p) => Data.Profunctor.Unsafe.Profunctor (Control.Lens.Internal.Profunctor.WrappedPafb f p)
instance (GHC.Base.Applicative f, Data.Profunctor.Choice.Choice p) => Data.Profunctor.Choice.Choice (Control.Lens.Internal.Profunctor.WrappedPafb f p)


module Control.Lens.Internal.Review

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable p

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
instance (Data.Profunctor.Unsafe.Profunctor p, Data.Bifunctor.Bifunctor p) => Control.Lens.Internal.Review.Reviewable p


module Control.Lens.Internal.Setter

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable f
untainted :: Settable f => f a -> a
untaintedDot :: (Settable f, Profunctor p) => p a (f b) -> p a b
taintedDot :: (Settable f, Profunctor p) => p a b -> p a (f b)
instance Control.Lens.Internal.Setter.Settable Data.Functor.Identity.Identity
instance Control.Lens.Internal.Setter.Settable f => Control.Lens.Internal.Setter.Settable (Control.Applicative.Backwards.Backwards f)
instance (Control.Lens.Internal.Setter.Settable f, Control.Lens.Internal.Setter.Settable g) => Control.Lens.Internal.Setter.Settable (Data.Functor.Compose.Compose f g)


module Control.Lens.Internal.Zoom

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>StateT</a>.
newtype Focusing m s a
Focusing :: m (s, a) -> Focusing m s a
[unfocusing] :: Focusing m s a -> m (s, a)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>RWST</a>.
newtype FocusingWith w m s a
FocusingWith :: m (s, a, w) -> FocusingWith w m s a
[unfocusingWith] :: FocusingWith w m s a -> m (s, a, w)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>WriterT</a>.
newtype FocusingPlus w k s a
FocusingPlus :: k (s, w) a -> FocusingPlus w k s a
[unfocusingPlus] :: FocusingPlus w k s a -> k (s, w) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>MaybeT</a> or <a>ListT</a>.
newtype FocusingOn f k s a
FocusingOn :: k (f s) a -> FocusingOn f k s a
[unfocusingOn] :: FocusingOn f k s a -> k (f s) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingMay k s a
FocusingMay :: k (May s) a -> FocusingMay k s a
[unfocusingMay] :: FocusingMay k s a -> k (May s) a

-- | Make a <a>Monoid</a> out of <a>Maybe</a> for error handling.
newtype May a
May :: Maybe a -> May a
[getMay] :: May a -> Maybe a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingErr e k s a
FocusingErr :: k (Err e s) a -> FocusingErr e k s a
[unfocusingErr] :: FocusingErr e k s a -> k (Err e s) a

-- | Make a <a>Monoid</a> out of <a>Either</a> for error handling.
newtype Err e a
Err :: Either e a -> Err e a
[getErr] :: Err e a -> Either e a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>FreeT</a>
newtype FocusingFree f m k s a
FocusingFree :: k (Freed f m s) a -> FocusingFree f m k s a
[unfocusingFree] :: FocusingFree f m k s a -> k (Freed f m s) a

-- | Make a <a>Monoid</a> out of <a>FreeF</a> for result collection.
newtype Freed f m a
Freed :: FreeF f a (FreeT f m a) -> Freed f m a
[getFreed] :: Freed f m a -> FreeF f a (FreeT f m a)

-- | Wrap a monadic effect with a phantom type argument.
newtype Effect m r a
Effect :: m r -> Effect m r a
[getEffect] :: Effect m r a -> m r

-- | Wrap a monadic effect with a phantom type argument. Used when
--   magnifying <a>RWST</a>.
newtype EffectRWS w st m s a
EffectRWS :: (st -> m (s, st, w)) -> EffectRWS w st m s a
[getEffectRWS] :: EffectRWS w st m s a -> st -> m (s, st, w)
instance GHC.Base.Functor (Control.Lens.Internal.Zoom.EffectRWS w st m s)
instance (GHC.Base.Semigroup s, GHC.Base.Semigroup w, Data.Functor.Bind.Class.Bind m) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.EffectRWS w st m s)
instance (GHC.Base.Monoid s, GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.EffectRWS w st m s)
instance Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Zoom.EffectRWS w st m s)
instance GHC.Base.Functor (Control.Lens.Internal.Zoom.Effect m r)
instance Data.Functor.Contravariant.Contravariant (Control.Lens.Internal.Zoom.Effect m r)
instance (GHC.Base.Monad m, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Control.Lens.Internal.Zoom.Effect m r a)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Monoid (Control.Lens.Internal.Zoom.Effect m r a)
instance (Data.Functor.Bind.Class.Apply m, GHC.Base.Semigroup r) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.Effect m r)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.Effect m r)
instance GHC.Base.Functor (k (Control.Lens.Internal.Zoom.Freed f m s)) => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingFree f m k s)
instance Data.Functor.Bind.Class.Apply (k (Control.Lens.Internal.Zoom.Freed f m s)) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingFree f m k s)
instance GHC.Base.Applicative (k (Control.Lens.Internal.Zoom.Freed f m s)) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingFree f m k s)
instance (GHC.Base.Applicative f, GHC.Base.Semigroup a, GHC.Base.Monad m) => GHC.Base.Semigroup (Control.Lens.Internal.Zoom.Freed f m a)
instance (GHC.Base.Applicative f, GHC.Base.Monoid a, GHC.Base.Monad m) => GHC.Base.Monoid (Control.Lens.Internal.Zoom.Freed f m a)
instance GHC.Base.Functor (k (Control.Lens.Internal.Zoom.Err e s)) => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingErr e k s)
instance Data.Functor.Bind.Class.Apply (k (Control.Lens.Internal.Zoom.Err e s)) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingErr e k s)
instance GHC.Base.Applicative (k (Control.Lens.Internal.Zoom.Err e s)) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingErr e k s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Control.Lens.Internal.Zoom.Err e a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Control.Lens.Internal.Zoom.Err e a)
instance GHC.Base.Functor (k (Control.Lens.Internal.Zoom.May s)) => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingMay k s)
instance Data.Functor.Bind.Class.Apply (k (Control.Lens.Internal.Zoom.May s)) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingMay k s)
instance GHC.Base.Applicative (k (Control.Lens.Internal.Zoom.May s)) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingMay k s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Control.Lens.Internal.Zoom.May a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Control.Lens.Internal.Zoom.May a)
instance GHC.Base.Functor (k (f s)) => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingOn f k s)
instance Data.Functor.Bind.Class.Apply (k (f s)) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingOn f k s)
instance GHC.Base.Applicative (k (f s)) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingOn f k s)
instance GHC.Base.Functor (k (s, w)) => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingPlus w k s)
instance Data.Functor.Bind.Class.Apply (k (s, w)) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingPlus w k s)
instance GHC.Base.Applicative (k (s, w)) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingPlus w k s)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Lens.Internal.Zoom.FocusingWith w m s)
instance (GHC.Base.Monad m, GHC.Base.Semigroup s, GHC.Base.Semigroup w) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.FocusingWith w m s)
instance (GHC.Base.Monad m, GHC.Base.Monoid s, GHC.Base.Monoid w) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.FocusingWith w m s)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Lens.Internal.Zoom.Focusing m s)
instance (GHC.Base.Monad m, GHC.Base.Semigroup s) => Data.Functor.Bind.Class.Apply (Control.Lens.Internal.Zoom.Focusing m s)
instance (GHC.Base.Monad m, GHC.Base.Monoid s) => GHC.Base.Applicative (Control.Lens.Internal.Zoom.Focusing m s)


-- | These are some of the explicit <a>Functor</a> instances that leak into
--   the type signatures of <tt>Control.Lens</tt>. You shouldn't need to
--   import this module directly for most use-cases.
module Control.Lens.Internal


-- | This module exports the majority of the types that need to appear in
--   user signatures or in documentation when talking about lenses. The
--   remaining types for consuming lenses are distributed across various
--   modules in the hierarchy.
module Control.Lens.Type

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall k3 (p :: k1 -> k3 -> Type) (f :: k2 -> k3). p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' s a = Equality s s a a

-- | Composable <a>asTypeOf</a>. Useful for constraining excess
--   polymorphism, <tt>foo . (id :: As Int) . bar</tt>.
type As a = Equality' a a

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<a>.</a>) and <a>id</a>.
--   
--   Since every <a>Iso</a> is both a valid <a>Lens</a> and a valid
--   <a>Prism</a>, the laws for those types imply the following laws for an
--   <a>Iso</a> <tt>f</tt>:
--   
--   <pre>
--   f <a>.</a> <a>from</a> f ≡ <a>id</a>
--   <a>from</a> f <a>.</a> f ≡ <a>id</a>
--   </pre>
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are three laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b) ≡ <a>Just</a> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   <pre>
--   <a>preview</a> l s ≡ <a>Just</a> a ⟹ <a>review</a> l a ≡ s
--   </pre>
--   
--   Third, if you get non-match <tt>t</tt>, you can convert it result back
--   to <tt>s</tt>:
--   
--   <pre>
--   <a>matching</a> l s ≡ <a>Left</a> t ⟹ <a>matching</a> l t ≡ <a>Left</a> s
--   </pre>
--   
--   The first two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <a>&lt;=</a> 1
--   </pre>
--   
--   It may help to think of this as an <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <a>Integer</a>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <a>Integer</a>, and provide you with tools to check if an
--   <a>Integer</a> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <a>Integer</a> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <a>toInteger</a> <a>$</a> \ i -&gt;
--      if i <a>&lt;</a> 0
--      then <a>Left</a> i
--      else <a>Right</a> (<a>fromInteger</a> i)
--   </pre>
--   
--   Now we can ask if an <a>Integer</a> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <a>Integer</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the <a>Left</a>
--   half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | This is a limited form of a <a>Prism</a> that can only be used for
--   <tt>re</tt> operations.
--   
--   Like with a <a>Getter</a>, there are no laws to state for a
--   <a>Review</a>.
--   
--   You can generate a <a>Review</a> by using <tt>unto</tt>. You can also
--   use any <a>Prism</a> or <a>Iso</a> directly as a <a>Review</a>.
type Review t b = forall p f. (Choice p, Bifunctor p, Settable f) => Optic' p f t b

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged Identity t b

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)  ≡ v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s  ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s) ≡ <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s) ≡ <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (l f) <a>.</a> l g ≡ <a>getCompose</a> <a>.</a> l (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<a>.</a>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (t f) <a>.</a> t g ≡ <a>getCompose</a> <a>.</a> t (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | A <a>Traversal</a> which targets at least one element.
--   
--   Note that since <a>Apply</a> is not a superclass of
--   <a>Applicative</a>, a <a>Traversal1</a> cannot always be used in place
--   of a <a>Traversal</a>. In such circumstances <a>cloneTraversal</a>
--   will convert a <a>Traversal1</a> into a <a>Traversal</a>.
type Traversal1 s t a b = forall f. Apply f => (a -> f b) -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a) ≡ <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <a>id</a> ≡ <a>id</a>
--   <a>over</a> l f <a>.</a> <a>over</a> l g ≡ <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l f <a>.</a> <a>untainted</a> <a>.</a> l g ≡ l (f <a>.</a> <a>untainted</a> <a>.</a> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<a>.</a>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s

-- | A relevant Fold (aka <a>Fold1</a>) has one or more targets.
type Fold1 s a = forall f. (Contravariant f, Apply f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall p f. (Indexable i p, Apply f) => p a (f b) -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall f p. (Indexable i p, Settable f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall p f. (Indexable i p, Contravariant f, Functor f) => p a (f a) -> s -> f s

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall p f. (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s
type IndexedFold1 i s a = forall p f. (Indexable i p, Contravariant f, Apply f) => p a (f a) -> s -> f s

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingLens s t a b = forall p f. (Conjoined p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingLens'</a> = <a>Simple</a> <a>IndexPreservingLens</a>
--   </pre>
type IndexPreservingLens' s a = IndexPreservingLens s s a a

-- | An <a>IndexPreservingTraversal</a> leaves any index it is composed
--   with alone.
type IndexPreservingTraversal s t a b = forall p f. (Conjoined p, Applicative f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingTraversal'</a> = <a>Simple</a> <a>IndexPreservingTraversal</a>
--   </pre>
type IndexPreservingTraversal' s a = IndexPreservingTraversal s s a a
type IndexPreservingTraversal1 s t a b = forall p f. (Conjoined p, Apply f) => p a (f b) -> p s (f t)
type IndexPreservingTraversal1' s a = IndexPreservingTraversal1 s s a a

-- | An <a>IndexPreservingSetter</a> can be composed with a
--   <a>IndexedSetter</a>, <a>IndexedTraversal</a> or <a>IndexedLens</a>
--   and leaves the index intact, yielding an <a>IndexedSetter</a>.
type IndexPreservingSetter s t a b = forall p f. (Conjoined p, Settable f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <tt>IndexedPreservingSetter'</tt> i = <a>Simple</a> <tt>IndexedPreservingSetter</tt>
--   </pre>
type IndexPreservingSetter' s a = IndexPreservingSetter s s a a

-- | An <a>IndexPreservingGetter</a> can be used as a <a>Getter</a>, but
--   when composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a>, <a>IndexedFold</a> or
--   <a>IndexedGetter</a> respectively.
type IndexPreservingGetter s a = forall p f. (Conjoined p, Contravariant f, Functor f) => p a (f a) -> p s (f s)

-- | An <a>IndexPreservingFold</a> can be used as a <a>Fold</a>, but when
--   composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a> respectively.
type IndexPreservingFold s a = forall p f. (Conjoined p, Contravariant f, Applicative f) => p a (f a) -> p s (f s)
type IndexPreservingFold1 s a = forall p f. (Conjoined p, Contravariant f, Apply f) => p a (f a) -> p s (f s)

-- | A <a>Simple</a> <a>Lens</a>, <a>Simple</a> <a>Traversal</a>, ... can
--   be used instead of a <a>Lens</a>,<a>Traversal</a>, ... whenever the
--   type variables don't change upon setting a value.
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Simple</a> <a>Lens</a> (<a>Complex</a> a) a
--   <a>traversed</a> :: <a>Simple</a> (<a>IndexedTraversal</a> <a>Int</a>) [a] a
--   </pre>
--   
--   Note: To use this alias in your own code with <tt><a>LensLike</a>
--   f</tt> or <a>Setter</a>, you may have to turn on
--   <tt>LiberalTypeSynonyms</tt>.
--   
--   This is commonly abbreviated as a "prime" marker, <i>e.g.</i>
--   <a>Lens'</a> = <a>Simple</a> <a>Lens</a>.
type Simple f s a = f s s a a

-- | Many combinators that accept a <a>Lens</a> can also accept a
--   <a>Traversal</a> in limited situations.
--   
--   They do so by specializing the type of <a>Functor</a> that they
--   require of the caller.
--   
--   If a function accepts a <tt><a>LensLike</a> f s t a b</tt> for some
--   <a>Functor</a> <tt>f</tt>, then they may be passed a <a>Lens</a>.
--   
--   Further, if <tt>f</tt> is an <a>Applicative</a>, they may also be
--   passed a <a>Traversal</a>.
type LensLike f s t a b = (a -> f b) -> s -> f t

-- | <pre>
--   type <a>LensLike'</a> f = <a>Simple</a> (<a>LensLike</a> f)
--   </pre>
type LensLike' f s a = LensLike f s s a a

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
type Over p f s t a b = p a (f b) -> s -> f t

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
--   
--   <pre>
--   type <a>Over'</a> p f = <a>Simple</a> (<a>Over</a> p f)
--   </pre>
type Over' p f s a = Over p f s s a a

-- | Convenient alias for constructing indexed lenses and their ilk.
type IndexedLensLike i f s t a b = forall p. Indexable i p => p a (f b) -> s -> f t

-- | Convenient alias for constructing simple indexed lenses and their ilk.
type IndexedLensLike' i f s a = IndexedLensLike i f s s a a

-- | <pre>
--   type <a>LensLike</a> f s t a b = <a>Optical</a> (-&gt;) (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Over</a> p f s t a b = <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Optic</a> p f s t a b = <a>Optical</a> p p f s t a b
--   </pre>
type Optical p q f s t a b = p a (f b) -> q s (f t)

-- | <pre>
--   type <a>Optical'</a> p q f s a = <a>Simple</a> (<a>Optical</a> p q f) s a
--   </pre>
type Optical' p q f s a = Optical p q f s s a a

-- | A valid <a>Optic</a> <tt>l</tt> should satisfy the laws:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l (<tt>Procompose</tt> f g) = <tt>Procompose</tt> (l f) (l g)
--   </pre>
--   
--   This gives rise to the laws for <a>Equality</a>, <a>Iso</a>,
--   <a>Prism</a>, <a>Lens</a>, <a>Traversal</a>, <a>Traversal1</a>,
--   <a>Setter</a>, <a>Fold</a>, <a>Fold1</a>, and <a>Getter</a> as well
--   along with their index-preserving variants.
--   
--   <pre>
--   type <a>LensLike</a> f s t a b = <a>Optic</a> (-&gt;) f s t a b
--   </pre>
type Optic p f s t a b = p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Optic'</a> p f s a = <a>Simple</a> (<a>Optic</a> p f) s a
--   </pre>
type Optic' p f s a = Optic p f s s a a


-- | A <tt><a>Setter</a> s t a b</tt> is a generalization of <a>fmap</a>
--   from <a>Functor</a>. It allows you to map into a structure and change
--   out the contents, but it isn't strong enough to allow you to enumerate
--   those contents. Starting with <tt><a>fmap</a> :: <a>Functor</a> f
--   =&gt; (a -&gt; b) -&gt; f a -&gt; f b</tt> we monomorphize the type to
--   obtain <tt>(a -&gt; b) -&gt; s -&gt; t</tt> and then decorate it with
--   <a>Identity</a> to obtain:
--   
--   <pre>
--   type <a>Setter</a> s t a b = (a -&gt; <a>Identity</a> b) -&gt; s -&gt; <a>Identity</a> t
--   </pre>
--   
--   Every <a>Traversal</a> is a valid <a>Setter</a>, since <a>Identity</a>
--   is <a>Applicative</a>.
--   
--   Everything you can do with a <a>Functor</a>, you can do with a
--   <a>Setter</a>. There are combinators that generalize <a>fmap</a> and
--   (<a>&lt;$</a>).
module Control.Lens.Setter

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a) ≡ <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <a>id</a> ≡ <a>id</a>
--   <a>over</a> l f <a>.</a> <a>over</a> l g ≡ <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l f <a>.</a> <a>untainted</a> <a>.</a> l g ≡ l (f <a>.</a> <a>untainted</a> <a>.</a> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<a>.</a>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall f p. (Indexable i p, Settable f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | Running a <a>Setter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | This is a useful alias for use when consuming a <a>Setter'</a>.
--   
--   Most user code will never have to use this type.
--   
--   <pre>
--   type <a>ASetter'</a> = <a>Simple</a> <a>ASetter</a>
--   </pre>
type ASetter' s a = ASetter s s a a

-- | Running an <a>IndexedSetter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type AnIndexedSetter i s t a b = Indexed i a (Identity b) -> s -> Identity t

-- | <pre>
--   type <a>AnIndexedSetter'</a> i = <a>Simple</a> (<a>AnIndexedSetter</a> i)
--   </pre>
type AnIndexedSetter' i s a = AnIndexedSetter i s s a a

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter</a> and <a>AnIndexedSetter</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting p s t a b = p a (Identity b) -> s -> Identity t

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter'</a> and <a>AnIndexedSetter'</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting' p s a = Setting p s s a a

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | Build an index-preserving <a>Setter</a> from a map-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>setting</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>setting</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>sets</a> is that it takes a "semantic editor
--   combinator" and transforms it into a <a>Setter</a>.
--   
--   <pre>
--   <a>setting</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b

-- | Restore <a>ASetter</a> to a full <a>Setter</a>.
cloneSetter :: ASetter s t a b -> Setter s t a b

-- | Build an <a>IndexPreservingSetter</a> from any <a>Setter</a>.
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b

-- | Clone an <a>IndexedSetter</a>.
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | This <a>Setter</a> can be used to map over all of the values in a
--   <a>Functor</a>.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (+1) [1,2,3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped x [a,b,c]
--   [x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[a,b],[c]] &amp; mapped.mapped +~ x
--   [[a + x,b + x],[c + x]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (mapped._2) length [("hello","world"),("leaders","!!!")]
--   [("hello",5),("leaders",3)]
--   </pre>
--   
--   <pre>
--   <a>mapped</a> :: <a>Functor</a> f =&gt; <a>Setter</a> (f a) (f b) a b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>fmap</a></tt>.
mapped :: Functor f => Setter (f a) (f b) a b

-- | This <tt>setter</tt> can be used to modify all of the values in a
--   <a>Monad</a>.
--   
--   You sometimes have to use this rather than <a>mapped</a> -- due to
--   temporary insanity <a>Functor</a> was not a superclass of <a>Monad</a>
--   until GHC 7.10.
--   
--   <pre>
--   <a>liftM</a> ≡ <a>over</a> <a>lifted</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over lifted f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set lifted b (Just a)
--   Just b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>liftM</a></tt>.
lifted :: Monad m => Setter (m a) (m b) a b

-- | This <a>Setter</a> can be used to map over all of the inputs to a
--   <a>Contravariant</a>.
--   
--   <pre>
--   <a>contramap</a> ≡ <a>over</a> <a>contramapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getPredicate (over contramapped (*2) (Predicate even)) 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOp (over contramapped (*5) (Op show)) 100
--   "500"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Prelude.map ($ 1) $ over (mapped . _Unwrapping' Op . contramapped) (*12) [(*2),(+1),(^3)]
--   [24,13,1728]
--   </pre>
contramapped :: Contravariant f => Setter (f b) (f a) a b

-- | This <a>Setter</a> can be used to map over the input of a
--   <a>Profunctor</a>.
--   
--   The most common <a>Profunctor</a> to use this with is
--   <tt>(-&gt;)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) g x
--   g (f x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ show) length [1,2,3]
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) h x y
--   h (f x) y
--   </pre>
--   
--   Map over the argument of the result of a function -- i.e., its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped.argument %~ f) h x y
--   h x (f y)
--   </pre>
--   
--   <pre>
--   <a>argument</a> :: <a>Setter</a> (b -&gt; r) (a -&gt; r) a b
--   </pre>
argument :: Profunctor p => Setter (p b r) (p a r) a b

-- | Modify the target of a <a>Lens</a> or all the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a function.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   <a>sets</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>sets</a> ≡ <a>id</a>
--   </pre>
--   
--   Given any valid <a>Setter</a> <tt>l</tt>, you can also rely on the
--   law:
--   
--   <pre>
--   <a>over</a> l f <a>.</a> <a>over</a> l g = <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]
--   True
--   </pre>
--   
--   Another way to view <a>over</a> is to say that it transforms a
--   <a>Setter</a> into a "semantic editor combinator".
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (Just a)
--   Just (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (*10) [1,2,3]
--   [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 show (10,20)
--   ("10",20)
--   </pre>
--   
--   <pre>
--   <a>over</a> :: <a>Setter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   <a>over</a> :: <a>ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   <pre>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 "hello" (1,())
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped () [1,2,3,4]
--   [(),(),(),()]
--   </pre>
--   
--   Note: Attempting to <a>set</a> a <a>Fold</a> or <a>Getter</a> will
--   fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set</a> :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Increment the target(s) of a numerically valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 +~ c
--   (a + c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both +~ c
--   (a + c,b + c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 +~ 1
--   (1,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(a,b),(c,d)] &amp; traverse.both +~ e
--   [(a + e,b + e),(c + e,d + e)]
--   </pre>
--   
--   <pre>
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(+~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 +~

-- | Decrement the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 -~ c
--   (a - c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both -~ c
--   (a - c,b - c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 -~ 2 $ (1,2)
--   (-1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapped.mapped -~ 1 $ [[4,5],[6,7]]
--   [[3,4],[5,6]]
--   </pre>
--   
--   <pre>
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(-~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 -~

-- | Multiply the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 *~ c
--   (a * c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both *~ c
--   (a * c,b * c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 *~ 4
--   (1,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 24 &amp; mapped *~ 2
--   Just 48
--   </pre>
--   
--   <pre>
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(*~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 *~

-- | Divide the target(s) of a numerically valued <a>Lens</a>, <a>Iso</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 //~ c
--   (a / c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both //~ c
--   (a / c,b / c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 //~ 2
--   ("Hawaii",5.0)
--   </pre>
--   
--   <pre>
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
infixr 4 //~

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,3) &amp; _2 ^~ 2
--   (1,9)
--   </pre>
--   
--   <pre>
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^~

-- | Raise the target(s) of a fractionally valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 ^^~ (-1)
--   (1,0.5)
--   </pre>
--   
--   <pre>
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^^~

-- | Raise the target(s) of a floating-point valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an arbitrary power.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 **~ c
--   (a**c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both **~ c
--   (a**c,b**c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 **~ 10 $ (3,2)
--   (3,1024.0)
--   </pre>
--   
--   <pre>
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
infixr 4 **~

-- | Logically <a>||</a> the target(s) of a <a>Bool</a>-valued <a>Lens</a>
--   or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ True $ (False,True)
--   (True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ False $ (False,True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   (<a>||~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 ||~

-- | Modify the target of a <a>Semigroup</a> value by using
--   <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
infixr 4 <>~

-- | Logically <a>&amp;&amp;</a> the target(s) of a <a>Bool</a>-valued
--   <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ True $ (False, True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ False $ (False, True)
--   (False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 &&~

-- | Set with pass-through.
--   
--   This is mostly present for consistency, but may be useful for chaining
--   assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.~</a> t</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;.~ c
--   (c,(c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("good","morning","vietnam") &amp; _3 &lt;.~ "world"
--   ("world",("good","morning","world"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,Map.fromList [("goodnight","gracie")]) &amp; _2.at "hello" &lt;.~ Just "world"
--   (Just "world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
infixr 4 <.~

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t ≡ <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <a>?~</a> can be used type-changily:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', ('b', 'c')) &amp; _2.both ?~ 'x'
--   ('a',(Just 'x',Just 'x'))
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Set to <a>Just</a> a value with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?~</a> d</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   ("world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
infixr 4 <?~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an alias for (<a>.=</a>).
--   
--   <pre>
--   &gt;&gt;&gt; execState (do assign _1 c; assign _2 d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
assign :: MonadState s m => ASetter s s a b -> b -> m ()

-- | This is an alias for (<a>%=</a>).
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
infix 4 .=

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by adding a value.
--   
--   Example:
--   
--   <pre>
--   <tt>fresh</tt> :: <a>MonadState</a> <a>Int</a> m =&gt; m <a>Int</a>
--   <tt>fresh</tt> = do
--     <a>id</a> <a>+=</a> 1
--     <a>use</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 += c; _2 += d) (a,b)
--   (a + c,b + d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],"hello")
--   (fromList [(1,10),(2,100)],"hello")
--   </pre>
--   
--   <pre>
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 +=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by subtracting a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 -= c; _2 -= d) (a,b)
--   (a - c,b - d)
--   </pre>
--   
--   <pre>
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 -=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by multiplying by value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 *= c; _2 *= d) (a,b)
--   (a * c,b * d)
--   </pre>
--   
--   <pre>
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 *=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by dividing by a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 //= c; _2 //= d) (a,b)
--   (a / c,b / d)
--   </pre>
--   
--   <pre>
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
infix 4 //=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^^=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an arbitrary power
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 **= c; _2 **= d) (a,b)
--   (a**c,b**d)
--   </pre>
--   
--   <pre>
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
infix 4 **=

-- | Modify the target(s) of a <a>Lens'</a>, 'Iso, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>||</a> with a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)
--   (True,True,True,False)
--   </pre>
--   
--   <pre>
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 ||=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by using <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &lt;&gt;= Sum c; _2 &lt;&gt;= Product d) (Sum a,Product b)
--   (Sum {getSum = a + c},Product {getProduct = b * d})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;&gt;= "!!!") ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Setter'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(<>=) :: (MonadState s m, Semigroup a) => ASetter' s a -> a -> m ()
infix 4 <>=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>&amp;&amp;</a> with a
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &amp;&amp;= True; _2 &amp;&amp;= False; _3 &amp;&amp;= True; _4 &amp;&amp;= False) (True,True,False,False)
--   (True,False,False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 &&=

-- | Set with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>_2</a> <a>&lt;.=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; b -&gt; m b
--   </pre>
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
infix 4 <.=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do at 1 ?= a; at 2 ?= b) Map.empty
--   fromList [(1,a),(2,b)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ?= b; _2 ?= c) (Just a, Nothing)
--   (Just b,Just c)
--   </pre>
--   
--   <pre>
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s (<a>Maybe</a> a)       -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s (<a>Maybe</a> a)      -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s (<a>Maybe</a> a) -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s (<a>Maybe</a> a)    -&gt; a -&gt; m ()
--   </pre>
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
infix 4 ?=

-- | Set <a>Just</a> a value with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>at</a> "foo" <a>&lt;?=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a (<a>Maybe</a> b)    -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a (<a>Maybe</a> b)       -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a (<a>Maybe</a> b)      -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a (<a>Maybe</a> b) -&gt; b -&gt; m b
--   </pre>
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
infix 4 <?=

-- | Run a monadic action, and set all of the targets of a <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to its result.
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; m b -&gt; m ()
--   </pre>
--   
--   As a reasonable mnemonic, this lets you store the result of a monadic
--   action in a <a>Lens</a> rather than in a local variable.
--   
--   <pre>
--   do foo &lt;- bar
--      ...
--   </pre>
--   
--   will store the result in a variable, while
--   
--   <pre>
--   do foo <a>&lt;~</a> bar
--      ...
--   </pre>
--   
--   will store the result in a <a>Lens</a>, <a>Setter</a>, or
--   <a>Traversal</a>.
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
infixr 2 <~

-- | Write to a fragment of a larger <tt>Writer</tt> format.
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a>.
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a> with access to the index
--   of an <a>IndexedSetter</a>.
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>.
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>, with
--   access to the index of an <a>IndexedSetter</a>.
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a

-- | Modify the value of the <tt>Reader</tt> environment associated with
--   the target of a <a>Setter</a>, <a>Lens</a>, or <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l <a>id</a> a ≡ a
--   <a>locally</a> l f <a>.</a> locally l g ≡ <a>locally</a> l (f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,1) &amp; locally _1 (+1) (uncurry (+))
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "," &amp; locally ($) ("Hello" &lt;&gt;) (&lt;&gt; " world!")
--   "Hello, world!"
--   </pre>
--   
--   <pre>
--   locally :: MonadReader s m =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Setter</a> s s a b    -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r

-- | This is a generalization of <a>locally</a> that allows one to make
--   indexed <a>local</a> changes to a <tt>Reader</tt> environment
--   associated with the target of a <a>Setter</a>, <a>Lens</a>, or
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l f ≡ <a>ilocally</a> l f . const
--   <a>ilocally</a> l f ≡ <a>locally</a> l f . <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   ilocally :: MonadReader s m =&gt; <a>IndexedLens</a> s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedTraversal</a> s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedSetter</a> s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter'</a> or <a>Traversal</a> with a constant value, without
--   changing its type.
--   
--   This is a type restricted version of <a>set</a>, which retains the
--   type of the original.
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped x [a,b,c,d]
--   [x,x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' _2 "hello" (1,"world")
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped 0 [1,2,3,4]
--   [0,0,0,0]
--   </pre>
--   
--   Note: Attempting to adjust <a>set'</a> a <a>Fold</a> or <a>Getter</a>
--   will fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set'</a> :: <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
set' :: ASetter' s a -> a -> s -> s

-- | Map with index. (Deprecated alias for <a>iover</a>).
--   
--   When you do not need access to the index, then <a>mapOf</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>mapOf</a> l ≡ <a>imapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapOf</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>

-- | <i>Deprecated: Use <a>iover</a></i>
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Map with index. This is an alias for <a>imapOf</a>.
--   
--   When you do not need access to the index, then <a>over</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>over</a> l ≡ <a>iover</a> l <a>.</a> <a>const</a>
--   <a>iover</a> l ≡ <a>over</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>iover</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Set with index. Equivalent to <a>iover</a> with the current value
--   ignored.
--   
--   When you do not need access to the index, then <a>set</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>set</a> l ≡ <a>iset</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iset</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t

-- | This is an alias for (<a>%@=</a>).
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()

-- | Build an <a>IndexedSetter</a> from an <a>imap</a>-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>isets</a> <a>.</a> <a>iover</a> ≡ <a>id</a>
--   <a>iover</a> <a>.</a> <a>isets</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>isets</a> is that it takes a "semantic editor
--   combinator" which has been modified to carry an index and transforms
--   it into a <a>IndexedSetter</a>.
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b

-- | Adjust every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>%@~</a>) ≡ <a>iover</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>%~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%~</a> f ≡ l <a>%@~</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
infixr 4 %@~

-- | Replace every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>.@~</a>) ≡ <a>iset</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>.~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.~</a> b ≡ l <a>.@~</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
infixr 4 .@~

-- | Adjust every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>%=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%=</a> f ≡ l <a>%@=</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   </pre>
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
infix 4 %@=

-- | Replace every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>.=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.=</a> b ≡ l <a>.@=</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; m ()
--   </pre>
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
infix 4 .@=

-- | Run an arrow command and use the output to set all the targets of a
--   <a>Lens</a>, <a>Setter</a> or <a>Traversal</a> to the result.
--   
--   <a>assignA</a> can be used very similarly to (<a>&lt;~</a>), except
--   that the type of the object being modified can change; for example:
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
--   
--   <pre>
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Iso</a> s t a b       -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Lens</a> s t a b      -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Traversal</a> s t a b -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Setter</a> s t a b    -&gt; p s b -&gt; p s t
--   </pre>
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable f

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | <a>mapOf</a> is a deprecated alias for <a>over</a>.

-- | <i>Deprecated: Use <a>over</a></i>
mapOf :: ASetter s t a b -> (a -> b) -> s -> t


-- | A <tt><a>Lens</a> s t a b</tt> is a purely functional reference.
--   
--   While a <a>Traversal</a> could be used for <a>Getting</a> like a valid
--   <a>Fold</a>, it wasn't a valid <a>Getter</a> as a <a>Getter</a> can't
--   require an <a>Applicative</a> constraint.
--   
--   <a>Functor</a>, however, is a constraint on both.
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   Every <a>Lens</a> is a valid <a>Setter</a>.
--   
--   Every <a>Lens</a> can be used for <a>Getting</a> like a <a>Fold</a>
--   that doesn't use the <a>Applicative</a> or <a>Contravariant</a>.
--   
--   Every <a>Lens</a> is a valid <a>Traversal</a> that only uses the
--   <a>Functor</a> part of the <a>Applicative</a> it is supplied.
--   
--   Every <a>Lens</a> can be used for <a>Getting</a> like a valid
--   <a>Getter</a>.
--   
--   Since every <a>Lens</a> can be used for <a>Getting</a> like a valid
--   <a>Getter</a> it follows that it must view exactly one element in the
--   structure.
--   
--   The <a>Lens</a> laws follow from this property and the desire for it
--   to act like a <a>Traversable</a> when used as a <a>Traversal</a>.
--   
--   In the examples below, <tt>getter</tt> and <tt>setter</tt> are
--   supplied as example getters and setters, and are not actual functions
--   supplied by this package.
module Control.Lens.Lens

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)  ≡ v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s  ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s) ≡ <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s) ≡ <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (l f) <a>.</a> l g ≡ <a>getCompose</a> <a>.</a> l (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Lens</a>.
--   
--   This type can also be used when you need to store a <a>Lens</a> in a
--   container, since it is rank-1. You can turn them back into a
--   <a>Lens</a> with <a>cloneLens</a>, or use it directly with combinators
--   like <a>storing</a> and (<a>^#</a>).
type ALens s t a b = LensLike (Pretext (->) a b) s t a b

-- | <pre>
--   type <a>ALens'</a> = <a>Simple</a> <a>ALens</a>
--   </pre>
type ALens' s a = ALens s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedLens</a>
type AnIndexedLens i s t a b = Optical (Indexed i) (->) (Pretext (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedLens'</a> = <a>Simple</a> (<a>AnIndexedLens</a> i)
--   </pre>
type AnIndexedLens' i s a = AnIndexedLens i s s a a

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Build an <a>IndexedLens</a> from a <a>Getter</a> and a <a>Setter</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b

-- | Build an index-preserving <a>Lens</a> from a <a>Getter</a> and a
--   <a>Setter</a>.
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b

-- | Obtain a getter and a setter from a lens, reversing <a>lens</a>.
withLens :: forall s t a b rep (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r

-- | (<a>%%~</a>) can be used in one of two scenarios:
--   
--   When applied to a <a>Lens</a>, it can edit the target of the
--   <a>Lens</a> in a structure, extracting a functorial result.
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting an applicative summary of its actions.
--   
--   <pre>
--   &gt;&gt;&gt; [66,97,116,109,97,110] &amp; each %%~ \a -&gt; ("na", chr a)
--   ("nananananana","Batman")
--   </pre>
--   
--   For all that the definition of this combinator is just:
--   
--   <pre>
--   (<a>%%~</a>) ≡ <a>id</a>
--   </pre>
--   
--   It may be beneficial to think about it as if it had these even more
--   restricted types, however:
--   
--   <pre>
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting a supplemental monoidal summary of its actions,
--   by choosing <tt>f = ((,) m)</tt>
--   
--   <pre>
--   (<a>%%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) :: <a>Monoid</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; (m, b)) -&gt; s -&gt; (m, t)
--   </pre>
(%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
infixr 4 %%~

-- | Modify the target of a <a>Lens</a> in the current state returning some
--   extra information of type <tt>r</tt> or modify all targets of a
--   <a>Traversal</a> in the current state, extracting extra information of
--   type <tt>r</tt> and return a monoidal summary of the changes.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 %%= \x -&gt; (f x, g x)) (a,b)
--   (f a,(g a,b))
--   </pre>
--   
--   <pre>
--   (<a>%%=</a>) ≡ (<a>state</a> <a>.</a>)
--   </pre>
--   
--   It may be useful to think of (<a>%%=</a>), instead, as having either
--   of the following more restricted type signatures:
--   
--   <pre>
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; (r, b)) -&gt; m r
--   </pre>
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
infix 4 %%=

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary of the supplementary results and the answer.
--   
--   <pre>
--   (<a>%%@~</a>) ≡ <a>withIndex</a>
--   </pre>
--   
--   <pre>
--   (<a>%%@~</a>) :: <a>Functor</a> f =&gt; <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%@~</a>) :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   In particular, it is often useful to think of this function as having
--   one of these even more restricted type signatures:
--   
--   <pre>
--   (<a>%%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%@~</a>) :: <a>Monoid</a> r =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   </pre>
(%%@~) :: Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
infixr 4 %%@~

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   supplementary results.
--   
--   <pre>
--   l <a>%%@=</a> f ≡ <a>state</a> (l <a>%%@~</a> f)
--   </pre>
--   
--   <pre>
--   (<a>%%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   (<a>%%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   </pre>
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
infix 4 %%@=

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary along with the answer.
--   
--   <pre>
--   l <a>&lt;%~</a> f ≡ l <a>&lt;%@~</a> <a>const</a> f
--   </pre>
--   
--   When you do not need access to the index then (<a>&lt;%~</a>) is more
--   liberal in what it can accept.
--   
--   If you do not need the intermediate result, you can use (<a>%@~</a>)
--   or even (<a>%~</a>).
--   
--   <pre>
--   (<a>&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%@~</a>) :: <a>Monoid</a> b =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
infixr 4 <%@~

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   intermediate results.
--   
--   <pre>
--   (<a>&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   (<a>&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   </pre>
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
infix 4 <%@=

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> and return a
--   monoidal summary of the old values along with the answer.
--   
--   <pre>
--   (<a>&lt;&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%@~</a>) :: <a>Monoid</a> a =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
infixr 4 <<%@~

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> within the
--   current state, and return a monoidal summary of the old values.
--   
--   <pre>
--   (<a>&lt;&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   (<a>&lt;&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   </pre>
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
infix 4 <<%@=

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | This is convenient to <a>flip</a> argument order of composite
--   functions defined as:
--   
--   <pre>
--   fab ?? a = fmap ($ a) fab
--   </pre>
--   
--   For the <a>Functor</a> instance <tt>f = ((-&gt;) r)</tt> you can
--   reason about this function as if the definition was <tt>(<a>??</a>) ≡
--   <a>flip</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (h ?? x) a
--   h a x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState ?? [] $ modify (1:)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _2 ?? ("hello","world") $ length
--   ("hello",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over ?? length ?? ("hello","world") $ _2
--   ("hello",5)
--   </pre>
(??) :: Functor f => f (a -> b) -> a -> f b
infixl 1 ??

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40
--   (30,40)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s
infixl 1 &~

-- | Merge two lenses, getters, setters, folds or traversals.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>choosing</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s' a     -&gt; <a>Getter</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Fold</a> s a       -&gt; <a>Fold</a> s' a       -&gt; <a>Fold</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s' a      -&gt; <a>Lens'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> s' a -&gt; <a>Traversal'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> s' a    -&gt; <a>Setter'</a> (<a>Either</a> s s') a
--   </pre>
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b

-- | This is a <a>Lens</a> that updates either side of an <a>Either</a>,
--   where both sides have the same type.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello"^.chosen
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a &amp; chosen *~ b
--   Right (a * b)
--   </pre>
--   
--   <pre>
--   <a>chosen</a> :: <a>Lens</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   <a>chosen</a> f (<a>Left</a> a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>chosen</a> f (<a>Right</a> a) = <a>Right</a> <a>&lt;$&gt;</a> f a
--   </pre>
chosen :: IndexPreservingLens (Either a a) (Either b b) a b

-- | <a>alongside</a> makes a <a>Lens</a> from two other lenses or a
--   <a>Getter</a> from two other getters by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b)^.alongside chosen chosen
--   (a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b) &amp; alongside chosen chosen .~ (c,d)
--   (Left c,Right d)
--   </pre>
--   
--   <pre>
--   <a>alongside</a> :: <a>Lens</a>   s t a b -&gt; <a>Lens</a>   s' t' a' b' -&gt; <a>Lens</a>   (s,s') (t,t') (a,a') (b,b')
--   <a>alongside</a> :: <a>Getter</a> s   a   -&gt; <a>Getter</a> s'    a'    -&gt; <a>Getter</a> (s,s')        (a,a')
--   </pre>
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')

-- | Lift a <a>Lens</a> so it can run under a function (or other
--   corepresentable profunctor).
--   
--   <pre>
--   <a>inside</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> (e -&gt; s) (e -&gt; t) (e -&gt; a) (e -&gt; b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; (x-1,x+1)) ^. inside _1 $ 5
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runState (modify (1:) &gt;&gt; modify (2:)) ^. (inside _2) $ []
--   [2,1]
--   </pre>
inside :: Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)

-- | Modify the target of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>%~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) :: <a>Monoid</a> b =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <%~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the addition, (<a>+~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <+~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the subtraction, (<a>-~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <-~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the multiplication, (<a>*~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <*~

-- | Divide the target of a fractionally valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the division, (<a>//~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <//~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^~

-- | Raise the target of a fractionally valued <a>Lens</a> to an
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^^~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <**~

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>||~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <||~

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;~</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <&&~

-- | (<a>&lt;&gt;</a>) a <a>Semigroup</a> value onto the end of the target
--   of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;~</a>)
--   is more flexible.
(<<>~) :: Semigroup m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
infixr 4 <<>~

-- | Modify the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>%~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
infixr 4 <<%~

-- | Replace the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>.~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.~</a>) ::             <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) ::             <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
infixr 4 <<.~

-- | Replace the target of a <a>Lens</a> with a <a>Just</a> value, but
--   return the old value.
--   
--   If you do not need the old value (<a>?~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;&lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   (Nothing,(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
infixr 4 <<?~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>+~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;+~ c
--   (a,(a + c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;+~ c
--   (b,(a,b + c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<+~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;-~ c
--   (a,(a - c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;-~ c
--   (b,(a,b - c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<-~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;*~ c
--   (a,(a * c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;*~ c
--   (b,(a,b * c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<*~

-- | Divide the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>//~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;//~ c
--   (a,(a / c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 &lt;&lt;//~ 2
--   (10.0,("Hawaii",5.0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<//~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^~

-- | Raise the target of a fractionally valued <a>Lens</a> to an integral
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; S -&gt; (a, s)
--   </pre>
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^^~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the old value.
--   
--   When you do not need the old value, (<a>**~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;**~ c
--   (a,(a**c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;**~ c
--   (b,(a,b**c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<**~

-- | Logically <a>||</a> the target of a <a>Bool</a>-valued <a>Lens</a> and
--   return the old value.
--   
--   When you do not need the old value, (<a>||~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;||~ True
--   (False,(True,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;||~ False
--   (True,("hello",True))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<||~

-- | Logically <a>&amp;&amp;</a> the target of a <a>Bool</a>-valued
--   <a>Lens</a> and return the old value.
--   
--   When you do not need the old value, (<a>&amp;&amp;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;&amp;&amp;~ True
--   (False,(False,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;&amp;&amp;~ False
--   (True,("hello",False))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   </pre>
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<&&~

-- | Modify the target of a monoidally valued <a>Lens</a> by using
--   (<a>&lt;&gt;</a>) a new value and return the old value.
--   
--   When you do not need the old value, (<a>&lt;&gt;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&lt;&lt;&gt;~ Sum c
--   (Sum {getSum = a},(Sum {getSum = a + c},b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;&lt;&gt;~ ", 007" $ ("James", "Bond")
--   ("Bond",("James","Bond, 007"))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Semigroup</a> r =&gt; <a>Lens'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Semigroup</a> r =&gt; <a>Iso'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   </pre>
(<<<>~) :: Semigroup r => LensLike' ((,) r) s r -> r -> s -> (r, s)
infixr 4 <<<>~

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the result.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the intermediate results.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
infix 4 <%=

-- | Add to the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the addition, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <+=

-- | Subtract from the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the subtraction, (<a>-=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <-=

-- | Multiply the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the multiplication, (<a>*=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <*=

-- | Divide the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the division, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <//=

-- | Raise the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to a non-negative <a>Integral</a> power and
--   return the result.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^=

-- | Raise the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an <a>Integral</a> power and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Iso'</a> s a  -&gt; e -&gt; m a
--   </pre>
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^^=

-- | Raise the target of a floating-point valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <**=

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <||=

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <&&=

-- | (<a>&lt;&gt;</a>) a <a>Semigroup</a> value onto the end of the target
--   of a <a>Lens</a> into your <tt>Monad'</tt>s state and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
(<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<>=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m =&gt; <a>LensLike</a> ((,)a) s s a b -&gt; (a -&gt; b) -&gt; m a
--   </pre>
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
infix 4 <<%=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with a user supplied value and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>.=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
infix 4 <<.=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with <a>Just</a> a user supplied value and return the <i>old</i> value
--   that was replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>?=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s t a (Maybe b)      -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s t a (Maybe b)       -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a (Maybe b) -&gt; b -&gt; m a
--   </pre>
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
infix 4 <<?=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   adding a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<+=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   subtracting a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>-=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<-=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   multipling a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>*=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<*=

-- | Modify the target of a <a>Lens</a> into your <a>Monad</a>s state by
--   dividing by a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<//=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by a non-negative power and return the <i>old</i> value
--   that was replaced.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an integral power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^^=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an arbitrary power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<**=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>||</a> with a value and return the <i>old</i>
--   value that was replaced.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<||=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>&amp;&amp;</a> with a value and return the
--   <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<&&=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   using (<a>&lt;&gt;</a>) and return the <i>old</i> value that was
--   replaced.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> r) =&gt; <a>Lens'</a> s r -&gt; r -&gt; m r
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> r) =&gt; <a>Iso'</a> s r -&gt; r -&gt; m r
--   </pre>
(<<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<<>=

-- | Run a monadic action, and set the target of <a>Lens</a> to its result.
--   
--   <pre>
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b   -&gt; m b -&gt; m b
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b  -&gt; m b -&gt; m b
--   </pre>
--   
--   NB: This is limited to taking an actual <a>Lens</a> than admitting a
--   <a>Traversal</a> because there are potential loss of state issues
--   otherwise.
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
infixr 2 <<~

-- | Cloning a <a>Lens</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Traversal</a> and can be used as a way
--   to pass around lenses that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let example l x = set (cloneLens l) (x^.cloneLens l + 1) x in example _2 ("hello",1,"you")
--   ("hello",2,"you")
--   </pre>
cloneLens :: ALens s t a b -> Lens s t a b

-- | Clone a <a>Lens</a> as an <tt>IndexedPreservingLens</tt> that just
--   passes through whatever index is on any <a>IndexedLens</a>,
--   <a>IndexedFold</a>, <a>IndexedGetter</a> or <a>IndexedTraversal</a> it
--   is composed with.
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b

-- | Clone an <a>IndexedLens</a> as an <a>IndexedLens</a> with the same
--   index.
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b

-- | <a>over</a> for Arrows.
--   
--   Unlike <a>over</a>, <a>overA</a> can't accept a simple <a>Setter</a>,
--   but requires a full lens, or close enough.
--   
--   <pre>
--   &gt;&gt;&gt; overA _1 ((+1) *** (+2)) ((1,2),6)
--   ((2,4),6)
--   </pre>
--   
--   <pre>
--   overA :: Arrow ar =&gt; Lens s t a b -&gt; ar a b -&gt; ar s t
--   </pre>
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t

-- | A version of <a>set</a> that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; storing _2 "world" ("hello","there")
--   ("hello","world")
--   </pre>
storing :: ALens s t a b -> b -> s -> t

-- | A version of (<a>^.</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^#_2
--   "world"
--   </pre>
(^#) :: s -> ALens s t a b -> a
infixl 8 ^#

-- | A version of (<a>.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 #~ "world"
--   ("hello","world")
--   </pre>
(#~) :: ALens s t a b -> b -> s -> t
infixr 4 #~

-- | A version of (<a>%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%~ length
--   ("hello",5)
--   </pre>
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
infixr 4 #%~

-- | A version of (<a>%%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%%~ \x -&gt; (length x, x ++ "!")
--   (5,("hello","world!"))
--   </pre>
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
infixr 4 #%%~

-- | A version of (<a>&lt;.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 &lt;#~ "world"
--   ("world",("hello","world"))
--   </pre>
(<#~) :: ALens s t a b -> b -> s -> (b, t)
infixr 4 <#~

-- | A version of (<a>&lt;%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 &lt;#%~ length
--   (5,("hello",5))
--   </pre>
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <#%~

-- | A version of (<a>.=</a>) that works on <a>ALens</a>.
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
infix 4 #=

-- | A version of (<a>%=</a>) that works on <a>ALens</a>.
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
infix 4 #%=

-- | A version of (<a>%%=</a>) that works on <a>ALens</a>.
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
infix 4 #%%=

-- | A version of (<a>&lt;.=</a>) that works on <a>ALens</a>.
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
infix 4 <#=

-- | A version of (<a>&lt;%=</a>) that works on <a>ALens</a>.
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
infix 4 <#%=

-- | There is a field for every type in the <a>Void</a>. Very zen.
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; mapped.devoid +~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; mapped.devoid %~ abs
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>devoid</a> :: <a>Lens'</a> <a>Void</a> a
--   </pre>
devoid :: Over p f Void Void a b

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.united
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; united .~ ()
--   "hello"
--   </pre>
united :: Lens' a ()

-- | A <a>Lens</a> focusing on the first element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; head1 +~ 10
--   12 :| [3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Identity True ^. head1
--   True
--   </pre>
head1 :: Traversable1 t => Lens' (t a) a

-- | A <a>Lens</a> focusing on the last element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; last1 +~ 10
--   2 :| [3,14]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Node 'a' [Node 'b' [], Node 'c' []] ^. last1
--   'c'
--   </pre>
last1 :: Traversable1 t => Lens' (t a) a

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>cloneLens</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | This <a>Lens</a> lets you <tt>view</tt> the current <tt>pos</tt> of
--   any indexed store comonad and <tt>seek</tt> to a new position. This
--   reduces the API for working these instances to a single <a>Lens</a>.
--   
--   <pre>
--   <a>ipos</a> w ≡ w <a>^.</a> <a>locus</a>
--   <a>iseek</a> s w ≡ w <a>&amp;</a> <a>locus</a> <a>.~</a> s
--   <a>iseeks</a> f w ≡ w <a>&amp;</a> <a>locus</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   <a>locus</a> :: <a>Lens'</a> (<a>Context'</a> a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>Pretext'</a> p a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>PretextT'</a> p g a s) a
--   </pre>
locus :: IndexedComonadStore p => Lens (p a c s) (p b c s) a b

-- | Fuse a composition of lenses using <a>Yoneda</a> to provide
--   <a>fmap</a> fusion.
--   
--   In general, given a pair of lenses <tt>foo</tt> and <tt>bar</tt>
--   
--   <pre>
--   fusing (foo.bar) = foo.bar
--   </pre>
--   
--   however, <tt>foo</tt> and <tt>bar</tt> are either going to <a>fmap</a>
--   internally or they are trivial.
--   
--   <a>fusing</a> exploits the <a>Yoneda</a> lemma to merge these separate
--   uses into a single <a>fmap</a>.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Lens</a> <tt>foo.bar</tt> in
--   the above description is recursive or complex enough to prevent
--   inlining.
--   
--   <pre>
--   <a>fusing</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> s t a b
--   </pre>
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Lens.Lens.First1 f)
instance GHC.Base.Functor f => Data.Functor.Bind.Class.Apply (Control.Lens.Lens.First1 f)


module Control.Lens.Tuple

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: (Field1 s t a b, Generic s, Generic t, GIxed N0 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: (Field2 s t a b, Generic s, Generic t, GIxed N1 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 3rd field of a tuple.
_3 :: Field3 s t a b => Lens s t a b

-- | Access the 3rd field of a tuple.
_3 :: (Field3 s t a b, Generic s, Generic t, GIxed N2 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 4th field of a tuple.
_4 :: Field4 s t a b => Lens s t a b

-- | Access the 4th field of a tuple.
_4 :: (Field4 s t a b, Generic s, Generic t, GIxed N3 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 5th field of a tuple.
_5 :: Field5 s t a b => Lens s t a b

-- | Access the 5th field of a tuple.
_5 :: (Field5 s t a b, Generic s, Generic t, GIxed N4 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 6th field of a tuple.
_6 :: Field6 s t a b => Lens s t a b

-- | Access the 6th field of a tuple.
_6 :: (Field6 s t a b, Generic s, Generic t, GIxed N5 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 7th field of a tuple.
_7 :: Field7 s t a b => Lens s t a b

-- | Access the 7th field of a tuple.
_7 :: (Field7 s t a b, Generic s, Generic t, GIxed N6 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 8th field of a tuple.
_8 :: Field8 s t a b => Lens s t a b

-- | Access the 8th field of a tuple.
_8 :: (Field8 s t a b, Generic s, Generic t, GIxed N7 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 9th field of a tuple.
_9 :: Field9 s t a b => Lens s t a b

-- | Access the 9th field of a tuple.
_9 :: (Field9 s t a b, Generic s, Generic t, GIxed N8 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 10th field of a tuple.
class Field10 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 10th field of a tuple.
_10 :: Field10 s t a b => Lens s t a b

-- | Access the 10th field of a tuple.
_10 :: (Field10 s t a b, Generic s, Generic t, GIxed N9 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 11th field of a tuple.
class Field11 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 11th field of a tuple.
_11 :: Field11 s t a b => Lens s t a b

-- | Access the 11th field of a tuple.
_11 :: (Field11 s t a b, Generic s, Generic t, GIxed N10 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 12th field of a tuple.
class Field12 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 12th field of a tuple.
_12 :: Field12 s t a b => Lens s t a b

-- | Access the 12th field of a tuple.
_12 :: (Field12 s t a b, Generic s, Generic t, GIxed N11 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 13th field of a tuple.
class Field13 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 13th field of a tuple.
_13 :: Field13 s t a b => Lens s t a b

-- | Access the 13th field of a tuple.
_13 :: (Field13 s t a b, Generic s, Generic t, GIxed N12 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 14th field of a tuple.
class Field14 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 14th field of a tuple.
_14 :: Field14 s t a b => Lens s t a b

-- | Access the 14th field of a tuple.
_14 :: (Field14 s t a b, Generic s, Generic t, GIxed N13 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 15th field of a tuple.
class Field15 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 15th field of a tuple.
_15 :: Field15 s t a b => Lens s t a b

-- | Access the 15th field of a tuple.
_15 :: (Field15 s t a b, Generic s, Generic t, GIxed N14 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 16th field of a tuple.
class Field16 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 16th field of a tuple.
_16 :: Field16 s t a b => Lens s t a b

-- | Access the 16th field of a tuple.
_16 :: (Field16 s t a b, Generic s, Generic t, GIxed N15 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 17th field of a tuple.
class Field17 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 17th field of a tuple.
_17 :: Field17 s t a b => Lens s t a b

-- | Access the 17th field of a tuple.
_17 :: (Field17 s t a b, Generic s, Generic t, GIxed N16 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 18th field of a tuple.
class Field18 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 18th field of a tuple.
_18 :: Field18 s t a b => Lens s t a b

-- | Access the 18th field of a tuple.
_18 :: (Field18 s t a b, Generic s, Generic t, GIxed N17 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 19th field of a tuple.
class Field19 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 19th field of a tuple.
_19 :: Field19 s t a b => Lens s t a b

-- | Access the 19th field of a tuple.
_19 :: (Field19 s t a b, Generic s, Generic t, GIxed N18 (Rep s) (Rep t) a b) => Lens s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b

-- | Strict version of <a>_10</a>
_10' :: Field10 s t a b => Lens s t a b

-- | Strict version of <a>_11</a>
_11' :: Field11 s t a b => Lens s t a b

-- | Strict version of <a>_12</a>
_12' :: Field12 s t a b => Lens s t a b

-- | Strict version of <a>_13</a>
_13' :: Field13 s t a b => Lens s t a b

-- | Strict version of <a>_14</a>
_14' :: Field14 s t a b => Lens s t a b

-- | Strict version of <a>_15</a>
_15' :: Field15 s t a b => Lens s t a b

-- | Strict version of <a>_16</a>
_16' :: Field16 s t a b => Lens s t a b

-- | Strict version of <a>_17</a>
_17' :: Field17 s t a b => Lens s t a b

-- | Strict version of <a>_18</a>
_18' :: Field18 s t a b => Lens s t a b

-- | Strict version of <a>_19</a>
_19' :: Field19 s t a b => Lens s t a b
instance Control.Lens.Tuple.Field19 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s') s s'
instance Control.Lens.Tuple.Field18 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r') r r'
instance Control.Lens.Tuple.Field18 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r', s) r r'
instance Control.Lens.Tuple.Field17 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q') q q'
instance Control.Lens.Tuple.Field17 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q', r) q q'
instance Control.Lens.Tuple.Field17 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q', r, s) q q'
instance Control.Lens.Tuple.Field16 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p') p p'
instance Control.Lens.Tuple.Field16 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p', q) p p'
instance Control.Lens.Tuple.Field16 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p', q, r) p p'
instance Control.Lens.Tuple.Field16 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p', q, r, s) p p'
instance Control.Lens.Tuple.Field15 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o') o o'
instance Control.Lens.Tuple.Field15 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o', p) o o'
instance Control.Lens.Tuple.Field15 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o', p, q) o o'
instance Control.Lens.Tuple.Field15 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o', p, q, r) o o'
instance Control.Lens.Tuple.Field15 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o', p, q, r, s) o o'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n') n n'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n', o) n n'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n', o, p) n n'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n', o, p, q) n n'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n', o, p, q, r) n n'
instance Control.Lens.Tuple.Field14 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m, n', o, p, q, r, s) n n'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h, i, j, kk, l, m') m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n) m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n, o) m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n, o, p) m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n, o, p, q) m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n, o, p, q, r) m m'
instance Control.Lens.Tuple.Field13 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l, m', n, o, p, q, r, s) m m'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g, h, i, j, kk, l') l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h, i, j, kk, l', m) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n, o) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n, o, p) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n, o, p, q) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n, o, p, q, r) l l'
instance Control.Lens.Tuple.Field12 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk, l', m, n, o, p, q, r, s) l l'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f, g, h, i, j, kk') kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g, h, i, j, kk', l) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h, i, j, kk', l, m) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n, o) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n, o, p) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n, o, p, q) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n, o, p, q, r) kk kk'
instance Control.Lens.Tuple.Field11 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j, kk', l, m, n, o, p, q, r, s) kk kk'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e, f, g, h, i, j') j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f, g, h, i, j', kk) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g, h, i, j', kk, l) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h, i, j', kk, l, m) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n, o) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n, o, p) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n, o, p, q) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n, o, p, q, r) j j'
instance Control.Lens.Tuple.Field10 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i, j', kk, l, m, n, o, p, q, r, s) j j'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h, i') i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e, f, g, h, i', j) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f, g, h, i', j, kk) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g, h, i', j, kk, l) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h, i', j, kk, l, m) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n, o) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n, o, p) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n, o, p, q) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n, o, p, q, r) i i'
instance Control.Lens.Tuple.Field9 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h, i', j, kk, l, m, n, o, p, q, r, s) i i'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g, h') h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h', i) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e, f, g, h', i, j) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f, g, h', i, j, kk) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g, h', i, j, kk, l) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g, h', i, j, kk, l, m) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n, o) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n, o, p) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n, o, p, q) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n, o, p, q, r) h h'
instance Control.Lens.Tuple.Field8 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g, h', i, j, kk, l, m, n, o, p, q, r, s) h h'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g) (a, b, c, d, e, f, g') g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g', h) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g', h, i) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e, f, g', h, i, j) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f, g', h, i, j, kk) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f, g', h, i, j, kk, l) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f, g', h, i, j, kk, l, m) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n, o) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n, o, p) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n, o, p, q) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n, o, p, q, r) g g'
instance Control.Lens.Tuple.Field7 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f, g', h, i, j, kk, l, m, n, o, p, q, r, s) g g'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f) (a, b, c, d, e, f') f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g) (a, b, c, d, e, f', g) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f', g, h) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f', g, h, i) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e, f', g, h, i, j) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e, f', g, h, i, j, kk) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e, f', g, h, i, j, kk, l) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e, f', g, h, i, j, kk, l, m) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n, o) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n, o, p) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n, o, p, q) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n, o, p, q, r) f f'
instance Control.Lens.Tuple.Field6 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e, f', g, h, i, j, kk, l, m, n, o, p, q, r, s) f f'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e) (a, b, c, d, e') e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f) (a, b, c, d, e', f) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g) (a, b, c, d, e', f, g) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h) (a, b, c, d, e', f, g, h) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e', f, g, h, i) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d, e', f, g, h, i, j) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d, e', f, g, h, i, j, kk) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d, e', f, g, h, i, j, kk, l) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d, e', f, g, h, i, j, kk, l, m) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n, o) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n, o, p) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n, o, p, q) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n, o, p, q, r) e e'
instance Control.Lens.Tuple.Field5 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d, e', f, g, h, i, j, kk, l, m, n, o, p, q, r, s) e e'
instance Control.Lens.Tuple.Field4 (a, b, c, d) (a, b, c, d') d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f) (a, b, c, d', e, f) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g) (a, b, c, d', e, f, g) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h) (a, b, c, d', e, f, g, h) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i) (a, b, c, d', e, f, g, h, i) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j) (a, b, c, d', e, f, g, h, i, j) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c, d', e, f, g, h, i, j, kk) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c, d', e, f, g, h, i, j, kk, l) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c, d', e, f, g, h, i, j, kk, l, m) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n, o) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n, o, p) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n, o, p, q) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n, o, p, q, r) d d'
instance Control.Lens.Tuple.Field4 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c, d', e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) d d'
instance Control.Lens.Tuple.Field3 (a, b, c) (a, b, c') c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d) (a, b, c', d) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f) (a, b, c', d, e, f) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g) (a, b, c', d, e, f, g) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h) (a, b, c', d, e, f, g, h) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i) (a, b, c', d, e, f, g, h, i) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j) (a, b, c', d, e, f, g, h, i, j) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk) (a, b, c', d, e, f, g, h, i, j, kk) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b, c', d, e, f, g, h, i, j, kk, l) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b, c', d, e, f, g, h, i, j, kk, l, m) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n, o) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n, o, p) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n, o, p, q) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) c c'
instance Control.Lens.Tuple.Field3 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b, c', d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) c c'
instance forall k (f :: k -> *) (g :: k -> *) (a :: k) (g' :: k -> *). Control.Lens.Tuple.Field2 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f g' a) (g a) (g' a)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k) (g' :: k -> *). Control.Lens.Tuple.Field2 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f g' p) (g p) (g' p)
instance Control.Lens.Tuple.Field2 (Data.Strict.Tuple.Pair a b) (Data.Strict.Tuple.Pair a b') b b'
instance Control.Lens.Tuple.Field2 (a, b) (a, b') b b'
instance Control.Lens.Tuple.Field2 (a, b, c) (a, b', c) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d) (a, b', c, d) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f) (a, b', c, d, e, f) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g) (a, b', c, d, e, f, g) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h) (a, b', c, d, e, f, g, h) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i) (a, b', c, d, e, f, g, h, i) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j) (a, b', c, d, e, f, g, h, i, j) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk) (a, b', c, d, e, f, g, h, i, j, kk) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l) (a, b', c, d, e, f, g, h, i, j, kk, l) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a, b', c, d, e, f, g, h, i, j, kk, l, m) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n, o) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n, o, p) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) b b'
instance Control.Lens.Tuple.Field2 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a, b', c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) b b'
instance Control.Lens.Tuple.Field1 (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance forall k (f :: k -> *) (g :: k -> *) (a :: k) (f' :: k -> *). Control.Lens.Tuple.Field1 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f' g a) (f a) (f' a)
instance forall k (f :: k -> *) (g :: k -> *) (p :: k) (f' :: k -> *). Control.Lens.Tuple.Field1 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f' g p) (f p) (f' p)
instance Control.Lens.Tuple.Field1 (Data.Strict.Tuple.Pair a b) (Data.Strict.Tuple.Pair a' b) a a'
instance Control.Lens.Tuple.Field1 (a, b) (a', b) a a'
instance Control.Lens.Tuple.Field1 (a, b, c) (a', b, c) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d) (a', b, c, d) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f) (a', b, c, d, e, f) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g) (a', b, c, d, e, f, g) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h) (a', b, c, d, e, f, g, h) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i) (a', b, c, d, e, f, g, h, i) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j) (a', b, c, d, e, f, g, h, i, j) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk) (a', b, c, d, e, f, g, h, i, j, kk) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l) (a', b, c, d, e, f, g, h, i, j, kk, l) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m) (a', b, c, d, e, f, g, h, i, j, kk, l, m) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n, o) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r) a a'
instance Control.Lens.Tuple.Field1 (a, b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) (a', b, c, d, e, f, g, h, i, j, kk, l, m, n, o, p, q, r, s) a a'
instance Control.Lens.Tuple.GIxed Control.Lens.Tuple.N0 (GHC.Generics.K1 i a) (GHC.Generics.K1 i b) a b
instance (p GHC.Types.~ Control.Lens.Tuple.GT (Control.Lens.Tuple.GSize s) n, p GHC.Types.~ Control.Lens.Tuple.GT (Control.Lens.Tuple.GSize t) n, Control.Lens.Tuple.GIxed' p n s s' t t' a b) => Control.Lens.Tuple.GIxed n (s GHC.Generics.:*: s') (t GHC.Generics.:*: t') a b
instance (Control.Lens.Tuple.GT (Control.Lens.Tuple.GSize s) n GHC.Types.~ Control.Lens.Tuple.T, Control.Lens.Tuple.GT (Control.Lens.Tuple.GSize t) n GHC.Types.~ Control.Lens.Tuple.T, Control.Lens.Tuple.GIxed n s t a b) => Control.Lens.Tuple.GIxed' Control.Lens.Tuple.T n s s' t s' a b
instance (Control.Lens.Tuple.GT (Control.Lens.Tuple.GSize s) n GHC.Types.~ Control.Lens.Tuple.F, n' GHC.Types.~ Control.Lens.Tuple.Subtract (Control.Lens.Tuple.GSize s) n, Control.Lens.Tuple.GIxed n' s' t' a b) => Control.Lens.Tuple.GIxed' Control.Lens.Tuple.F n s s' s t' a b
instance forall k1 k2 (n :: k1) (s :: k2 -> *) (t :: k2 -> *) a b i (c :: GHC.Generics.Meta). Control.Lens.Tuple.GIxed n s t a b => Control.Lens.Tuple.GIxed n (GHC.Generics.M1 i c s) (GHC.Generics.M1 i c t) a b


-- | A <tt><a>Getter</a> s a</tt> is just any function <tt>(s -&gt;
--   a)</tt>, which we've flipped into continuation passing style, <tt>(a
--   -&gt; r) -&gt; s -&gt; r</tt> and decorated with <a>Const</a> to
--   obtain:
--   
--   <pre>
--   type <a>Getting</a> r s a = (a -&gt; <a>Const</a> r a) -&gt; s -&gt; <a>Const</a> r s
--   </pre>
--   
--   If we restrict access to knowledge about the type <tt>r</tt>, we could
--   get:
--   
--   <pre>
--   type <a>Getter</a> s a = forall r. <a>Getting</a> r s a
--   </pre>
--   
--   However, for <a>Getter</a> (but not for <a>Getting</a>) we actually
--   permit any functor <tt>f</tt> which is an instance of both
--   <a>Functor</a> and <a>Contravariant</a>:
--   
--   <pre>
--   type <a>Getter</a> s a = forall f. (<a>Contravariant</a> f, <a>Functor</a> f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
--   </pre>
--   
--   Everything you can do with a function, you can do with a
--   <a>Getter</a>, but note that because of the continuation passing style
--   (<a>.</a>) composes them in the opposite order.
--   
--   Since it is only a function, every <a>Getter</a> obviously only
--   retrieves a single value for a given input.
--   
--   A common question is whether you can combine multiple <a>Getter</a>s
--   to retrieve multiple values. Recall that all <a>Getter</a>s are
--   <a>Fold</a>s and that we have a <tt><a>Monoid</a> m =&gt;
--   <a>Applicative</a> (<a>Const</a> m)</tt> instance to play with.
--   Knowing this, we can use <tt><a>&lt;&gt;</a></tt> to glue <a>Fold</a>s
--   together:
--   
--   <pre>
--   &gt;&gt;&gt; (1, 2, 3, 4, 5) ^.. (_2 &lt;&gt; _3 &lt;&gt; _5)
--   [2,3,5]
--   </pre>
module Control.Lens.Getter

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall p f. (Indexable i p, Contravariant f, Functor f) => p a (f a) -> s -> f s

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | Used to consume an <a>IndexedFold</a>.
type IndexedGetting i m s a = Indexed i a (Const m a) -> s -> Const m s

-- | This is a convenient alias used when consuming (indexed) getters and
--   (indexed) folds in a highly general fashion.
type Accessing p m s a = p a (Const m a) -> s -> Const m s

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | <pre>
--   <a>ito</a> :: (s -&gt; (i, a)) -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a

-- | Build an constant-valued (index-preserving) <a>Getter</a> from an
--   arbitrary Haskell value.
--   
--   <pre>
--   <a>like</a> a <a>.</a> <a>like</a> b ≡ <a>like</a> b
--   a <a>^.</a> <a>like</a> b ≡ b
--   a <a>^.</a> <a>like</a> b ≡ a <a>^.</a> <a>to</a> (<a>const</a> b)
--   </pre>
--   
--   This can be useful as a second case <tt>failing</tt> a <a>Fold</a>
--   e.g. <tt>foo <tt>failing</tt> <a>like</a> 0</tt>
--   
--   <pre>
--   <a>like</a> :: a -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a

-- | <pre>
--   <a>ilike</a> :: i -&gt; a -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | View a function of the value pointed to by a <a>Getter</a> or
--   <a>Lens</a> or the result of folding over the result of mapping the
--   targets of a <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>views</a> l f ≡ <a>view</a> (l <a>.</a> <a>to</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views (to f) g a
--   g (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views _2 length (1,"hello")
--   5
--   </pre>
--   
--   As <a>views</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>views</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m) -&gt; s -&gt; m
--   <a>views</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m) -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m =&gt; <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
views :: MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) (a,b)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ("hello","world")
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s r       -&gt; m r
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s r -&gt; m r
--   </pre>
use :: MonadState s m => Getting a s a -> m a

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (uses _1 length) ("hello","world")
--   5
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m =&gt; <a>Getting</a> r s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
uses :: MonadState s m => LensLike' (Const r) s a -> (a -> r) -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Fold</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Traversal'</a> w u -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Prism'</a> w u     -&gt; m a -&gt; m (a, u)
--   </pre>
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Fold</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Traversal'</a> w u -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Prism'</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)

-- | View the index and value of an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>.
--   
--   This is the same operation as <a>iview</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   (<a>^@.</a>) :: s -&gt; <a>IndexedGetter</a> i s a -&gt; (i, a)
--   (<a>^@.</a>) :: s -&gt; <a>IndexedLens'</a> i s a  -&gt; (i, a)
--   </pre>
--   
--   The result probably doesn't have much meaning when applied to an
--   <a>IndexedFold</a>.
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
infixl 8 ^@.

-- | View the index and value of an <a>IndexedGetter</a> into the current
--   environment as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | View a function of the index and value of an <a>IndexedGetter</a> into
--   the current environment.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
--   
--   <pre>
--   <a>iviews</a> ≡ <a>ifoldMapOf</a>
--   </pre>
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | Use the index and value of an <a>IndexedGetter</a> into the current
--   state as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | Use a function of the index and value of an <a>IndexedGetter</a> into
--   the current state.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> i w u     -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> i w u      -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedFold</a> i w u       -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedTraversal'</a> i w u -&gt; m a -&gt; m (a, (i, u))
--   </pre>
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> w u     -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> w u      -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedFold</a> w u       -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedTraversal'</a> w u -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap :: (a' -&gt; a) -&gt; (Predicate a -&gt; Predicate a')
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class () => Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a' -> a) -> f a -> f a'

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | Coerce a <a>Getter</a>-compatible <a>Optical</a> to an
--   <a>Optical'</a>. This is useful when using a <a>Traversal</a> that is
--   not simple as a <a>Getter</a> or a <a>Fold</a>.
--   
--   <pre>
--   <a>getting</a> :: <a>Traversal</a> s t a b          -&gt; <a>Fold</a> s a
--   <a>getting</a> :: <a>Lens</a> s t a b               -&gt; <a>Getter</a> s a
--   <a>getting</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedFold</a> i s a
--   <a>getting</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedGetter</a> i s a
--   </pre>
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a

-- | The <a>Const</a> functor.
newtype () => Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a


-- | A <a>Review</a> is a type-restricted form of a <a>Prism</a> that can
--   only be used for writing back via <a>re</a>, <a>review</a>,
--   <a>reuse</a>.
module Control.Lens.Review

-- | This is a limited form of a <a>Prism</a> that can only be used for
--   <tt>re</tt> operations.
--   
--   Like with a <a>Getter</a>, there are no laws to state for a
--   <a>Review</a>.
--   
--   You can generate a <a>Review</a> by using <tt>unto</tt>. You can also
--   use any <a>Prism</a> or <a>Iso</a> directly as a <a>Review</a>.
type Review t b = forall p f. (Choice p, Bifunctor p, Settable f) => Optic' p f t b

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged Identity t b

-- | An analogue of <a>to</a> for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> :: (b -&gt; t) -&gt; <tt>Review'</tt> t b
--   </pre>
--   
--   <pre>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | Turn a <a>Prism</a> or <a>Iso</a> around to build a <a>Getter</a>.
--   
--   If you have an <a>Iso</a>, <a>from</a> is a more powerful version of
--   this function that will return an <a>Iso</a> instead of a mere
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^.re _Left
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 ^.re (_Left.unto succ)
--   Left 7
--   </pre>
--   
--   <pre>
--   <a>review</a>  ≡ <a>view</a>  <a>.</a> <a>re</a>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reuse</a>   ≡ <a>use</a>   <a>.</a> <a>re</a>
--   <a>reuses</a>  ≡ <a>uses</a>  <a>.</a> <a>re</a>
--   </pre>
--   
--   <pre>
--   <a>re</a> :: <a>Prism</a> s t a b -&gt; <a>Getter</a> b t
--   <a>re</a> :: <a>Iso</a> s t a b   -&gt; <a>Getter</a> b t
--   </pre>
re :: AReview t b -> Getter b t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>review</a> ≡ <a>view</a> <a>.</a> <a>re</a>
--   <a>review</a> . <a>unto</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "mustard"
--   Left "mustard"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review (unto succ) 5
--   6
--   </pre>
--   
--   Usually <a>review</a> is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>Iso'</a> s a   -&gt; a -&gt; s
--   <a>review</a> :: <a>Prism'</a> s a -&gt; a -&gt; s
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   </pre>
review :: MonadReader b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way, applying a function.
--   
--   <pre>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reviews</a> (<a>unto</a> f) g ≡ g <a>.</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews _Left isRight "mustard"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews (unto succ) (*2) 3
--   8
--   </pre>
--   
--   Usually this function is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; a -&gt; r
--   <a>reviews</a> :: <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>reuse</a> ≡ <a>use</a> <a>.</a> <a>re</a>
--   <a>reuse</a> <a>.</a> <a>unto</a> ≡ <a>gets</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse _Left) 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse (unto succ)) 5
--   6
--   </pre>
--   
--   <pre>
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   </pre>
reuse :: MonadState b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> the current state through it the other way, applying a
--   function.
--   
--   <pre>
--   <a>reuses</a> ≡ <a>uses</a> <a>.</a> <a>re</a>
--   <a>reuses</a> (<a>unto</a> f) g ≡ <a>gets</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuses _Left isLeft) (5 :: Int)
--   True
--   </pre>
--   
--   <pre>
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x ≡ f x
--   l # x ≡ x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class forall a. () => Functor p a => Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable p

-- | Coerce a polymorphic <a>Prism</a> to a <a>Review</a>.
--   
--   <pre>
--   <a>reviewing</a> :: <a>Iso</a> s t a b -&gt; <a>Review</a> t b
--   <a>reviewing</a> :: <a>Prism</a> s t a b -&gt; <a>Review</a> t b
--   </pre>
reviewing :: (Bifunctor p, Functor f) => Optic Tagged Identity s t a b -> Optic' p f t b


module Control.Lens.Prism

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are three laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b) ≡ <a>Just</a> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   <pre>
--   <a>preview</a> l s ≡ <a>Just</a> a ⟹ <a>review</a> l a ≡ s
--   </pre>
--   
--   Third, if you get non-match <tt>t</tt>, you can convert it result back
--   to <tt>s</tt>:
--   
--   <pre>
--   <a>matching</a> l s ≡ <a>Left</a> t ⟹ <a>matching</a> l t ≡ <a>Left</a> s
--   </pre>
--   
--   The first two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <a>&lt;=</a> 1
--   </pre>
--   
--   It may help to think of this as an <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <a>Integer</a>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <a>Integer</a>, and provide you with tools to check if an
--   <a>Integer</a> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <a>Integer</a> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <a>toInteger</a> <a>$</a> \ i -&gt;
--      if i <a>&lt;</a> 0
--      then <a>Left</a> i
--      else <a>Right</a> (<a>fromInteger</a> i)
--   </pre>
--   
--   Now we can ask if an <a>Integer</a> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <a>Integer</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the <a>Left</a>
--   half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Prism</a>.
type APrism s t a b = Market a b a (Identity b) -> Market a b s (Identity t)

-- | <pre>
--   type APrism' = <a>Simple</a> <a>APrism</a>
--   </pre>
type APrism' s a = APrism s s a a

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | Convert <a>APrism</a> to the pair of functions that characterize it.
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | Clone a <a>Prism</a> so that you can reuse the same monomorphically
--   typed <a>Prism</a> for different purposes.
--   
--   See <a>cloneLens</a> and <a>cloneTraversal</a> for examples of why you
--   might want to do this.
clonePrism :: APrism s t a b -> Prism s t a b

-- | Use a <a>Prism</a> as a kind of first-class pattern.
--   
--   <pre>
--   <a>outside</a> :: <a>Prism</a> s t a b -&gt; <a>Lens</a> (t -&gt; r) (s -&gt; r) (b -&gt; r) (a -&gt; r)
--   </pre>
outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | <tt>lift</tt> a <a>Prism</a> through a <a>Traversable</a> functor,
--   giving a Prism that matches only if all the elements of the container
--   match the <a>Prism</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [Left 1, Right "foo", Left 4, Right "woot"]^..below _Right
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [Right "hail hydra!", Right "foo", Right "blah", Right "woot"]^..below _Right
--   [["hail hydra!","foo","blah","woot"]]
--   </pre>
below :: Traversable f => APrism' s a -> Prism' (f s) (f a)

-- | Check to see if this <a>Prism</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Left 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty []
--   False
--   </pre>
--   
--   <pre>
--   <a>isn't</a> = <a>not</a> . <a>is</a>
--   <a>isn't</a> = <tt>hasn't</tt>
--   </pre>
isn't :: APrism s t a b -> s -> Bool

-- | Retrieve the value targeted by a <a>Prism</a> or return the original
--   value while allowing the type to change if it does not match.
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Just 12)
--   Right 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Nothing :: Maybe Int) :: Either (Maybe Bool) Int
--   Left Nothing
--   </pre>
matching :: APrism s t a b -> s -> Either t a

-- | Like <a>matching</a>, but also works for combinations of <a>Lens</a>
--   and <a>Prism</a>s, and also <a>Traversal</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; matching' (_2 . _Just) ('x', Just True)
--   Right True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' (_2 . _Just) ('x', Nothing :: Maybe Int) :: Either (Char, Maybe Bool) Int
--   Left ('x',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' traverse "" :: Either [Int] Char
--   Left []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' traverse "xyz" :: Either [Int] Char
--   Right 'x'
--   </pre>
matching' :: LensLike (Either a) s t a b -> s -> Either t a

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Left 2)
--   Left 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Right 2)
--   Right 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 42 ^._Left :: String
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Left
--   "hello"
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
_Left :: Prism (Either a c) (Either b c) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Left 2)
--   Left 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Right 2)
--   Right 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello" ^._Right
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Right :: [Double]
--   []
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Right # 5
--   Right 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Right
--   Right 5
--   </pre>
_Right :: Prism (Either c a) (Either c b) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a> ≡ m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | This <a>Prism</a> provides the <a>Traversal</a> of a <a>Nothing</a> in
--   a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Nothing
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just () ^? _Nothing
--   Nothing
--   </pre>
--   
--   But you can turn it around and use it to construct <a>Nothing</a> as
--   well:
--   
--   <pre>
--   &gt;&gt;&gt; _Nothing # ()
--   Nothing
--   </pre>
_Nothing :: Prism' (Maybe a) ()

-- | <a>Void</a> is a logically uninhabited data type.
--   
--   This is a <a>Prism</a> that will always fail to match.
_Void :: Prism s s a Void

-- | This is an improper prism for text formatting based on <a>Read</a> and
--   <a>Show</a>.
--   
--   This <a>Prism</a> is "improper" in the sense that it normalizes the
--   text formatting, but round tripping is idempotent given sane
--   <a>Read</a>/<a>Show</a> instances.
--   
--   <pre>
--   &gt;&gt;&gt; _Show # 2
--   "2"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "EQ" ^? _Show :: Maybe Ordering
--   Just EQ
--   </pre>
--   
--   <pre>
--   <a>_Show</a> ≡ <a>prism'</a> <a>show</a> <tt>readMaybe</tt>
--   </pre>
_Show :: (Read a, Show a) => Prism' String a

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing, an example where the value is the empty
--   list and the predicate checks that a list is empty (same as
--   <a>_Empty</a> with the <a>AsEmpty</a> list instance):
--   
--   <pre>
--   &gt;&gt;&gt; nearly [] null # ()
--   []
--   
--   &gt;&gt;&gt; [1,2,3,4] ^? nearly [] null
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>nearly</a> [] <a>null</a> :: <a>Prism'</a> [a] ()
--   </pre>
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x ≡ a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()
class Prefixed t

-- | A <a>Prism</a> stripping a prefix from a sequence when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Prefixed t => t -> Prism' t t
class Suffixed t

-- | A <a>Prism</a> stripping a suffix from a sequence when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Suffixed t => t -> Prism' t t

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice (p :: Type -> Type -> Type)

-- | Laws:
--   
--   <pre>
--   <a>left'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>right'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Left</a> ≡ <a>lmap</a> <a>Left</a> <a>.</a> <a>left'</a>
--   <a>lmap</a> (<a>right</a> f) <a>.</a> <a>left'</a> ≡ <a>rmap</a> (<a>right</a> f) <a>.</a> <a>left'</a>
--   <a>left'</a> <a>.</a> <a>left'</a> ≡ <a>dimap</a> assocE unassocE <a>.</a> <a>left'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
left' :: Choice p => p a b -> p (Either a c) (Either b c)

-- | Laws:
--   
--   <pre>
--   <a>right'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>left'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Right</a> ≡ <a>lmap</a> <a>Right</a> <a>.</a> <a>right'</a>
--   <a>lmap</a> (<a>left</a> f) <a>.</a> <a>right'</a> ≡ <a>rmap</a> (<a>left</a> f) <a>.</a> <a>right'</a>
--   <a>right'</a> <a>.</a> <a>right'</a> ≡ <a>dimap</a> unassocE assocE <a>.</a> <a>right'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
right' :: Choice p => p a b -> p (Either c a) (Either c b)
instance GHC.Classes.Eq a => Control.Lens.Prism.Suffixed [a]
instance Control.Lens.Prism.Suffixed Data.Text.Internal.Text
instance Control.Lens.Prism.Suffixed Data.Text.Internal.Lazy.Text
instance Control.Lens.Prism.Suffixed Data.ByteString.Internal.Type.ByteString
instance Control.Lens.Prism.Suffixed Data.ByteString.Lazy.Internal.ByteString
instance GHC.Classes.Eq a => Control.Lens.Prism.Prefixed [a]
instance Control.Lens.Prism.Prefixed Data.Text.Internal.Text
instance Control.Lens.Prism.Prefixed Data.Text.Internal.Lazy.Text
instance Control.Lens.Prism.Prefixed Data.ByteString.Internal.Type.ByteString
instance Control.Lens.Prism.Prefixed Data.ByteString.Lazy.Internal.ByteString


-- | A <tt><a>Fold</a> s a</tt> is a generalization of something
--   <a>Foldable</a>. It allows you to extract multiple results from a
--   container. A <a>Foldable</a> container can be characterized by the
--   behavior of <tt><a>foldMap</a> :: (<a>Foldable</a> t, <a>Monoid</a> m)
--   =&gt; (a -&gt; m) -&gt; t a -&gt; m</tt>. Since we want to be able to
--   work with monomorphic containers, we could generalize this signature
--   to <tt>forall m. <a>Monoid</a> m =&gt; (a -&gt; m) -&gt; s -&gt;
--   m</tt>, and then decorate it with <a>Const</a> to obtain
--   
--   <pre>
--   type <a>Fold</a> s a = forall m. <a>Monoid</a> m =&gt; <a>Getting</a> m s a
--   </pre>
--   
--   Every <a>Getter</a> is a valid <a>Fold</a> that simply doesn't use the
--   <a>Monoid</a> it is passed.
--   
--   In practice the type we use is slightly more complicated to allow for
--   better error messages and for it to be transformed by certain
--   <a>Applicative</a> transformers.
--   
--   Everything you can do with a <a>Foldable</a> container, you can with
--   with a <a>Fold</a> and there are combinators that generalize the usual
--   <a>Foldable</a> operations here.
module Control.Lens.Fold

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall p f. (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..id
--   [[[1,2],[3]]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse
--   [[1,2],[3]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs ≡ xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>a</a> :: s -&gt; <a>Fold</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Lens'</a> s a      -&gt; <a>a</a> :: s -&gt; <a>Iso'</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Traversal'</a> s a -&gt; <a>a</a> :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees. This is because <a>^?</a> works by using the
--   <a>First</a> monoid, which can occasionally cause space leaks.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   This operator works as an infix version of <a>preview</a>.
--   
--   <pre>
--   (<a>^?</a>) ≡ <a>flip</a> <a>preview</a>
--   </pre>
--   
--   It may be helpful to think of <a>^?</a> as having one of the following
--   more specialized types:
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a
infixl 8 ^?

-- | Perform an *UNSAFE* <a>head</a> of a <a>Fold</a> or <a>Traversal</a>
--   assuming that it is there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   (<a>^?!</a>) :: s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Fold</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; a
--   </pre>
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
infixl 8 ^?!

-- | This converts a <a>Fold</a> to a <a>IndexPreservingGetter</a> that
--   returns the first element, if it exists, as a <a>Maybe</a>.
--   
--   <pre>
--   <a>pre</a> :: <a>Getter</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Fold</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Traversal'</a> s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Lens'</a> s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Iso'</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Prism'</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   </pre>
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)

-- | This converts an <a>IndexedFold</a> to an <a>IndexPreservingGetter</a>
--   that returns the first index and element, if they exist, as a
--   <a>Maybe</a>.
--   
--   <pre>
--   <a>ipre</a> :: <a>IndexedGetter</a> i s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedFold</a> i s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedTraversal'</a> i s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedLens'</a> i s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   </pre>
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>). See
--   also <a>firstOf</a> and <a>^?</a>, which are similar with some subtle
--   differences (explained below).
--   
--   <pre>
--   <a>listToMaybe</a> <a>.</a> <tt>toList</tt> ≡ <a>preview</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>preview</a> = <a>view</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   Unlike <a>^?</a>, this function uses a <a>MonadReader</a> to read the
--   value to be focused in on. This allows one to pass the value as the
--   last argument by using the <a>MonadReader</a> instance for <tt>(-&gt;)
--   s</tt> However, it may also be used as part of some deeply nested
--   transformer stack.
--   
--   <a>preview</a> uses a monoidal value to obtain the result. This means
--   that it generally has good performance, but can occasionally cause
--   space leaks or even stack overflows on some data types. There is
--   another function, <a>firstOf</a>, which avoids these issues at the
--   cost of a slight constant performance cost and a little less
--   flexibility.
--   
--   It may be helpful to think of <a>preview</a> as having one of the
--   following more specialized types:
--   
--   <pre>
--   <a>preview</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>).
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>). See also (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreview</a> = <a>view</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreview</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; <a>Maybe</a> (i, a)
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or <a>Just</a> the
--   result from an <a>IndexedGetter</a> or <a>IndexedLens</a>). See also
--   (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreviews</a> = <a>views</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreviews</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>) into
--   the current state.
--   
--   <pre>
--   <a>preuse</a> = <a>use</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>) into the current state.
--   
--   <pre>
--   <a>preuses</a> = <a>uses</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> (or <a>Just</a> the index and result from
--   an <a>IndexedGetter</a> or <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuse</a> = <a>use</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or a function of
--   <a>Just</a> the index and result from an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuses</a> = <a>uses</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Getting All s a -> s -> Bool

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding reverse
--   [4,3,2,1]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b

-- | Obtain a <a>Fold</a> by lifting <a>foldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..foldring foldr
--   [1,2,3,4]
--   </pre>
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b

-- | Obtain <tt>FoldWithIndex</tt> by lifting <a>ifoldr</a> like function.
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
--   
--   <pre>
--   &gt;&gt;&gt; Just 3^..folded
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing^..folded
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)]^..folded.both
--   [1,2,3,4]
--   </pre>
folded :: Foldable f => IndexedFold Int (f a) a

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
folded64 :: Foldable f => IndexedFold Int64 (f a) a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a> ≡ <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10^..unfolded (\b -&gt; if b == 0 then Nothing else Just (b, b-1))
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (b -> Maybe (a, b)) -> Fold b a

-- | <tt>x <a>^.</a> <a>iterated</a> f</tt> returns an infinite
--   <a>Fold1</a> of repeated applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   <a>toListOf</a> (<a>iterated</a> f) a ≡ <a>iterate</a> f a
--   </pre>
--   
--   <pre>
--   <a>iterated</a> :: (a -&gt; a) -&gt; <a>Fold1</a> a a
--   </pre>
iterated :: Apply f => (a -> a) -> LensLike' f a a

-- | Obtain a <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that fails the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | Obtain a potentially empty <a>IndexedTraversal</a> by taking the first
--   element from another, potentially empty <a>Fold</a> and using it as an
--   index.
--   
--   The resulting optic can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   <pre>
--   &gt;&gt;&gt; [(Just 2, 3), (Nothing, 4)] &amp; mapped . filteredBy (_1 . _Just) &lt;. _2 %@~ (*) :: [(Maybe Int, Int)]
--   [(Just 2,6),(Nothing,4)]
--   </pre>
--   
--   <pre>
--   <a>filteredBy</a> :: <a>Fold</a> a i -&gt; <a>IndexedTraversal'</a> i a a
--   </pre>
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a

-- | This allows you to <a>traverse</a> the elements of a pretty much any
--   <a>LensLike</a> construction in the opposite order.
--   
--   This will preserve indexes on <a>Indexed</a> types and will give you
--   the elements of a (finite) <a>Fold</a> or <a>Traversal</a> in the
--   opposite order.
--   
--   This has no practical impact on a <a>Getter</a>, <a>Setter</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <i>NB:</i> To write back through an <a>Iso</a>, you want to use
--   <a>from</a>. Similarly, to write back through an <a>Prism</a>, you
--   want to use <a>re</a>.
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b

-- | Form a <a>Fold1</a> by repeating the input forever.
--   
--   <pre>
--   <a>repeat</a> ≡ <a>toListOf</a> <a>repeated</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ 5^..taking 20 repeated
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   <a>repeated</a> :: <a>Fold1</a> a a
--   </pre>
repeated :: Apply f => LensLike' f a a

-- | A <a>Fold</a> that replicates its input <tt>n</tt> times.
--   
--   <pre>
--   <a>replicate</a> n ≡ <a>toListOf</a> (<a>replicated</a> n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^..replicated 20
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
replicated :: Int -> Fold a a

-- | Transform a non-empty <a>Fold</a> into a <a>Fold1</a> that loops over
--   its elements over and over.
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1,2,3]^..taking 7 (cycled traverse)
--   [1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   <a>cycled</a> :: <a>Fold1</a> s a -&gt; <a>Fold1</a> s a
--   </pre>
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b

-- | Obtain a <a>Fold</a> by taking elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>takeWhile</a> p ≡ <a>toListOf</a> (<a>takingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ toListOf (takingWhile (&lt;=3) folded) [1..]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   <i>Note:</i> When applied to a <a>Traversal</a>, <a>takingWhile</a>
--   yields something that can be used as if it were a <a>Traversal</a>,
--   but which is not a <a>Traversal</a> per the laws, unless you are
--   careful to ensure that you do not invalidate the predicate when
--   writing back through it.
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a

-- | Obtain a <a>Fold</a> by dropping elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>dropWhile</a> p ≡ <a>toListOf</a> (<a>droppingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1..6]
--   [4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1,6,1]
--   [6,1]
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a                -- see notes
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingTraversal'</a> s a    -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingLens'</a> s a         -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingFold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s a
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Many uses of this combinator will yield something that meets the
--   types, but not the laws of a valid <a>Traversal</a> or
--   <a>IndexedTraversal</a>. The <a>Traversal</a> and
--   <a>IndexedTraversal</a> laws are only satisfied if the new values you
--   assign to the first target also does not pass the predicate! Otherwise
--   subsequent traversals will visit fewer elements and <a>Traversal</a>
--   fusion is not sound.
--   
--   So for any traversal <tt>t</tt> and predicate <tt>p</tt>,
--   <tt><a>droppingWhile</a> p t</tt> may not be lawful, but
--   <tt>(<a>dropping</a> 1 . <a>droppingWhile</a> p) t</tt> is. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; let l  :: Traversal' [Int] Int; l  = droppingWhile (&lt;= 1) traverse
--   
--   &gt;&gt;&gt; let l' :: Traversal' [Int] Int; l' = dropping 1 l
--   </pre>
--   
--   <tt>l</tt> is not a lawful setter because <tt><a>over</a> l f .
--   <a>over</a> l g ≢ <a>over</a> l (f . g)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 0 &amp; l .~ 4
--   [1,0,0]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 4
--   [1,4,4]
--   </pre>
--   
--   <tt>l'</tt> on the other hand behaves lawfully:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 0 &amp; l' .~ 4
--   [1,2,4]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 4
--   [1,2,4]
--   </pre>
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | A <a>Fold</a> over the individual <a>words</a> of a <a>String</a>.
--   
--   <pre>
--   <a>worded</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>worded</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   whitespace characters while traversing, and if your original
--   <a>String</a> contains only isolated space characters (and no other
--   characters that count as space, such as non-breaking spaces).
worded :: Applicative f => IndexedLensLike' Int f String String

-- | A <a>Fold</a> over the individual <a>lines</a> of a <a>String</a>.
--   
--   <pre>
--   <a>lined</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>lined</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   newline characters while traversing, and if your original
--   <a>String</a> contains only isolated newline characters.
lined :: Applicative f => IndexedLensLike' Int f String String

-- | Map each part of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> to a monoid and combine
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMapOf (folded . both . _Just) Sum [(Just 21, Just 21)]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>foldMap</a> = <a>foldMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ≡ <a>views</a>
--   <a>ifoldMapOf</a> l = <a>foldMapOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ::                <a>Getter</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Fold</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Fold1</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Lens'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Iso'</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Traversal'</a> s a  -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Traversal1'</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Prism'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> :: <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
foldMapOf :: Getting r s a -> (a -> r) -> s -> r

-- | Combine the elements of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> using a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (folded.folded) [[Sum 1,Sum 4],[Sum 8, Sum 8],[Sum 21]]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>fold</a> = <a>foldOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ::             <a>Getter</a> s m     -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Lens'</a> s m      -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Iso'</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Prism'</a> s m     -&gt; s -&gt; m
--   </pre>
foldOf :: Getting a s a -> s -> a

-- | Right-associative fold of parts of a structure that are viewed through
--   a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>foldrOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> l ≡ <a>foldrOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getting</a> (<a>Endo</a> r) s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>foldlOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Prism'</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Extract a list of the targets of a <a>Fold</a>. See also (<a>^..</a>).
--   
--   <pre>
--   <a>toList</a> ≡ <a>toListOf</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
toListOf :: Getting (Endo [a]) s a -> s -> [a]

-- | Extract a <a>NonEmpty</a> of the targets of <a>Fold1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmptyOf both1 ("hello", "world")
--   "hello" :| ["world"]
--   </pre>
--   
--   <pre>
--   <a>toNonEmptyOf</a> :: <a>Getter</a> s a      -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Fold1</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Lens'</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Iso'</a> s a        -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; NonEmpty a
--   </pre>
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a

-- | Calls <a>pure</a> on the target of a <a>Lens</a>, <a>Getter</a>, or
--   <a>Iso</a>.
--   
--   Calls <a>pure</a> on the targets of a <a>Traversal</a>, <a>Fold</a>,
--   or <a>Prism</a>, and combines them with <a>&lt;|&gt;</a> (or
--   <a>empty</a> if none). Intuitively, it collects targets into an
--   <a>Alternative</a> until the container fills up or it runs out of
--   targets, whichever comes first.
--   
--   Generalizes <a>toListOf</a> and <a>(^?)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; altOf both ("hello", "world") :: [String]
--   ["hello","world"]
--   
--   &gt;&gt;&gt; altOf both ("hello", "world") :: Maybe String
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>altOf</a> :: Applicative f =&gt; <a>Lens'</a> s a      -&gt; s -&gt; f a
--   <a>altOf</a> :: Applicative f =&gt; <a>Getter</a> s a     -&gt; s -&gt; f a
--   <a>altOf</a> :: Applicative f =&gt; <a>Iso'</a> s a       -&gt; s -&gt; f a
--   
--   <a>altOf</a> :: Alternative f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; f a
--   <a>altOf</a> :: Alternative f =&gt; <a>Fold</a> s a       -&gt; s -&gt; f a
--   <a>altOf</a> :: Alternative f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; f a
--   </pre>
altOf :: Applicative f => Getting (Alt f a) s a -> s -> f a

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a> ≡ <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l ≡ <a>anyOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> only if no targets of a <a>Fold</a> satisfy a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; noneOf each (is _Nothing) (Just 3, Just 4, Just 5)
--   True
--   
--   &gt;&gt;&gt; noneOf (folded.folded) (&lt;10) [[13,99,20],[3,71,42]]
--   False
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> l = <a>noneOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>noneOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
noneOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf both (True,False)
--   False
--   
--   &gt;&gt;&gt; andOf both (True,True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a> ≡ <a>andOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>andOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
andOf :: Getting All s Bool -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf both (True,False)
--   True
--   
--   &gt;&gt;&gt; orOf both (False,False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a> ≡ <a>orOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>orOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
orOf :: Getting Any s Bool -> s -> Bool

-- | Calculate the <tt>Product</tt> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf both (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a> ≡ <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <tt>Product</tt> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Calculate the <tt>Sum</tt> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf both (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded.both) [(1,2),(3,4)]
--   10
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; sumOf biplate [(1::Int,[]),(2,[(3::Int,4::Int)])] :: Int
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a> ≡ <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <tt>Sum</tt> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>sumOf</a> <tt>_1</tt> :: <a>Num</a> a =&gt; (a, b) -&gt; a
--   <a>sumOf</a> (<a>folded</a> <a>.</a> <a>_1</a>) :: (<a>Foldable</a> f, <a>Num</a> a) =&gt; f (a, b) -&gt; a
--   </pre>
--   
--   <pre>
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>traverseOf</a> do not construct a new structure.
--   <a>traverseOf_</a> generalizes <a>traverse_</a> to work over any
--   <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>traverseOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>traverseOf_</a>
--   requires an <a>Applicative</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a> ≡ <a>traverseOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf_</a> <tt>_2</tt> :: <a>Functor</a> f =&gt; (c -&gt; f r) -&gt; (d, c) -&gt; f ()
--   <a>traverseOf_</a> <a>_Left</a> :: <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a>Either</a> a c -&gt; f ()
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> l ≡ <a>traverseOf_</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   The rather specific signature of <a>traverseOf_</a> allows it to be
--   used as if the signature was any of:
--   
--   <pre>
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>forOf</a> do not construct a new structure. <a>forOf_</a>
--   generalizes <a>for_</a> to work over any <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>forOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>forOf_</a> requires
--   an <a>Applicative</a>.
--   
--   <pre>
--   <tt>for_</tt> ≡ <a>forOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; forOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   The rather specific signature of <a>forOf_</a> allows it to be used as
--   if the signature was any of:
--   
--   <pre>
--   <a>iforOf_</a> l s ≡ <a>forOf_</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()

-- | Evaluate each action in observed by a <a>Fold</a> on a structure from
--   left to right, ignoring the results.
--   
--   <pre>
--   <tt>sequenceA_</tt> ≡ <a>sequenceAOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f ()
--   </pre>
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold1</a>, computing an
--   <a>Apply</a> based answer.
--   
--   As long as you have <a>Applicative</a> or <a>Functor</a> effect you
--   are better using <a>traverseOf_</a>. The <a>traverse1Of_</a> is useful
--   only when you have genuine <a>Apply</a> effect.
--   
--   <pre>
--   &gt;&gt;&gt; traverse1Of_ both1 (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ]) ("abc", "bcd")
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>traverse1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()

-- | See <a>forOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for1Of_ both1 ("abc", "bcd") (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ])
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>for1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()

-- | See <a>sequenceAOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   <a>sequence1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s (f a) -&gt; s -&gt; f ()
--   </pre>
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()

-- | Map each target of a <a>Fold</a> on a structure to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>mapM_</a> ≡ <a>mapMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()

-- | <a>forMOf_</a> is <a>mapMOf_</a> with two of its arguments flipped.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>forM_</a> ≡ <a>forMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   </pre>
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()

-- | Evaluate each monadic action referenced by a <a>Fold</a> on the
--   structure from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequence_</a> ≡ <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m ()
--   </pre>
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <tt>asum</tt> ≡ <a>asumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f a
--   </pre>
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a> ≡ <a>msumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m a
--   </pre>
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a

-- | Map a function over all the targets of a <a>Fold</a> of a container
--   and concatenate the resulting lists.
--   
--   <pre>
--   &gt;&gt;&gt; concatMapOf both (\x -&gt; [x, x + 1]) (1,3)
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   <a>concatMap</a> ≡ <a>concatMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>concatMapOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a> ≡ <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf both "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a> ≡ <a>elemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a> ≡ <a>notElemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a> ≡ <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf traverse [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (traverse.traverse) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> (<a>folded</a> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a) -&gt; <a>Int</a>
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Int</a>
--   </pre>
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has no
--   targets in the given container.
--   
--   Note: <a>nullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>False</a>.
--   
--   <pre>
--   <a>null</a> ≡ <a>nullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <a>null</a> check of
--   many containers.
--   
--   <pre>
--   &gt;&gt;&gt; nullOf _1 (1,2)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf ignored ()
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf traverse []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf (element 20) [1..10]
--   True
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
nullOf :: Getting All s a -> s -> Bool

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has any
--   targets in the given container.
--   
--   A more "conversational" alias for this combinator is <a>has</a>.
--   
--   Note: <a>notNullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>True</a>.
--   
--   <pre>
--   <a>not</a> <a>.</a> <a>null</a> ≡ <a>notNullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <tt><a>not</a> <a>.</a>
--   <a>null</a></tt> check of many containers.
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf _1 (1,2)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf traverse [1..10]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf folded []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf (element 20) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notNullOf :: Getting Any s a -> s -> Bool

-- | Retrieve the <a>First</a> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><a>preview</a></tt> or <tt>^?'</tt> and gives you back access to
--   the outermost <a>Just</a> constructor more quickly, but does so in a
--   way that builds an intermediate structure, and thus may have worse
--   constant factors. This also means that it can not be used in any
--   <a>MonadReader</a>, but must instead have <tt>s</tt> passed as its
--   last argument, unlike <a>preview</a>.
--   
--   Note: this could been named <tt>headOf</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; firstOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf both (1,2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>firstOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a

-- | Retrieve the <a>First</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first1Of both1 (1,2)
--   1
--   </pre>
--   
--   <i>Note:</i> this is different from <a>^.</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 ([1,2] :| [[3,4],[5,6]])
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ([1,2] :| [[3,4],[5,6]]) ^. traverse1
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   <a>first1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
first1Of :: Getting (First a) s a -> s -> a

-- | Retrieve the <tt>Last</tt> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><tt>ala</tt> <tt>Last</tt> <a>.</a> <a>foldMapOf</a></tt> and
--   gives you back access to the outermost <a>Just</a> constructor more
--   quickly, but may have worse constant factors.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf both (1,2)
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>lastOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a

-- | Retrieve the <a>Last</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or retrieve the result from a <a>Getter</a> or <a>Lens</a>.o
--   
--   <pre>
--   &gt;&gt;&gt; last1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last1Of both1 (1,2)
--   2
--   </pre>
--   
--   <pre>
--   <a>last1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
last1Of :: Getting (Last a) s a -> s -> a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <tt>maximum</tt> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <tt>getMax</tt>
--   (<a>foldMapOf</a> l <tt>Max</tt>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the maximum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximum1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <tt>minimum</tt> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <tt>getMin</tt>
--   (<a>foldMapOf</a> l <tt>Min</tt>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the minimum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>maximumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a> or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <tt>minimumBy</tt> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>minimumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | The <a>findOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>find</a> ≡ <a>findOf</a> <a>folded</a>
--   <a>ifindOf</a> l ≡ <a>findOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findOf</a> :: <a>Getting</a> (<a>Endo</a> (<a>Maybe</a> a)) s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> l p = <a>foldrOf</a> l (a y -&gt; if p a then <a>Just</a> a else y) <a>Nothing</a>
--   </pre>
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a

-- | The <a>findMOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a monadic predicate and
--   a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Getter</a> s a)     -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Fold</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Iso'</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Lens'</a> s a)      -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Traversal'</a> s a) -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   <a>ifindMOf</a> l ≡ <a>findMOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findMOf</a> :: Monad m =&gt; <a>Getting</a> (<a>Endo</a> (m (<a>Maybe</a> a))) s a -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> l p = <a>foldrOf</a> l (a y -&gt; p a &gt;&gt;= x -&gt; if x then return (<a>Just</a> a) else y) $ return <a>Nothing</a>
--   </pre>
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)

-- | Strictly fold right over the elements of a structure.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>foldrOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r

-- | Fold over the elements of a structure, associating to the left, but
--   strictly.
--   
--   <pre>
--   <a>foldl'</a> ≡ <a>foldlOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf'</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | A variant of <a>foldrOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldr1</a> ≡ <a>foldr1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> l f ≡ <a>foldl1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldl1</a> ≡ <a>foldl1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldrOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldr1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldl1Of'</a> l f ≡ <a>foldl1'</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldl1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
--   
--   <pre>
--   <a>foldrM</a> ≡ <a>foldrMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
--   
--   <pre>
--   <a>foldlM</a> ≡ <a>foldlMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r

-- | The <a>lookupOf</a> function takes a <a>Fold</a> (or <a>Getter</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, etc.), a key, and a
--   structure containing key/value pairs. It returns the first value
--   corresponding to the given key. This function generalizes
--   <a>lookup</a> to work on an arbitrary <a>Fold</a> instead of lists.
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 4 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf each 2 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'a'
--   </pre>
--   
--   <pre>
--   <a>lookupOf</a> :: <a>Eq</a> k =&gt; <a>Fold</a> s (k,v) -&gt; k -&gt; s -&gt; <a>Maybe</a> v
--   </pre>
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v

-- | An infix version of <a>itoListOf</a>.
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
infixl 8 ^@..

-- | Perform a safe <a>head</a> (with index) of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> or retrieve <a>Just</a> the index and result
--   from an <a>IndexedGetter</a> or <a>IndexedLens</a>.
--   
--   When using a <a>IndexedTraversal</a> as a partial <a>IndexedLens</a>,
--   or an <a>IndexedFold</a> as a partial <a>IndexedGetter</a> this can be
--   a convenient way to extract the optional value.
--   
--   <pre>
--   (<a>^@?</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; <a>Maybe</a> (i, a)
--   </pre>
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
infixl 8 ^@?

-- | Perform an *UNSAFE* <a>head</a> (with index) of an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> assuming that it is there.
--   
--   <pre>
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; (i, a)
--   </pre>
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
infixl 8 ^@?!

-- | Fold an <a>IndexedFold</a> or <a>IndexedTraversal</a> by mapping
--   indices and values to an arbitrary <a>Monoid</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMapOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMapOf</a> l ≡ <a>ifoldMapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldMapOf</a> ::             <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> ::             <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   </pre>
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m

-- | Right-associative fold of parts of a structure that are viewed through
--   an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldrOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf</a> l ≡ <a>ifoldrOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access
--   to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldlOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf</a> l ≡ <a>ifoldlOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Return whether or not any element viewed through an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> satisfy a predicate, with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> l ≡ <a>ianyOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> l ≡ <a>iallOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not none of the elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> l ≡ <a>inoneOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverseOf_</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>traverseOf_</a> l ≡ <a>itraverseOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforOf_</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forOf_</a> l a ≡ <a>iforOf_</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   </pre>
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapMOf_</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforMOf_</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   </pre>
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()

-- | Concatenate the results of a function of the elements of an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you don't need access to the index then <a>concatMapOf</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>concatMapOf</a> l ≡ <a>iconcatMapOf</a> l <a>.</a> <a>const</a>
--   <a>iconcatMapOf</a> ≡ <a>ifoldMapOf</a>
--   </pre>
--   
--   <pre>
--   <a>iconcatMapOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]

-- | The <a>ifindOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a predicate that is also supplied the index,
--   a structure and returns the left-most element of the structure
--   matching the predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findOf</a> l ≡ <a>ifindOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a

-- | The <a>ifindMOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a monadic predicate that is also supplied the
--   index, a structure and returns in the monad the left-most element of
--   the structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findMOf</a> l ≡ <a>ifindMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)

-- | <i>Strictly</i> fold right over the elements of a structure with an
--   index.
--   
--   When you don't need access to the index then <a>foldrOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf'</a> l ≡ <a>ifoldrOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf'</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf'</a> l ≡ <a>ifoldlOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf'</a> :: <a>IndexedGetter</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedFold</a> i s a         -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedLens'</a> i s a        -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedTraversal'</a> i s a   -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrMOf</a> l ≡ <a>ifoldrMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlMOf</a> l ≡ <a>ifoldlMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toListOf</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>map</a> <a>snd</a> <a>.</a> <a>itoListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>itoListOf</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [(i,a)]
--   </pre>
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which is equal to a given value.
--   
--   <pre>
--   <a>elemIndex</a> ≡ <a>elemIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which are equal to a given value.
--   
--   <pre>
--   <a>elemIndices</a> ≡ <a>elemIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; [i]
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; [i]
--   </pre>
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which satisfies a predicate.
--   
--   <pre>
--   <a>findIndex</a> ≡ <a>findIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndexOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   <a>findIndexOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which satisfy a predicate.
--   
--   <pre>
--   <a>findIndices</a> ≡ <a>findIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndicesOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   <a>findIndicesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   </pre>
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]

-- | Filter an <a>IndexedFold</a> or <a>IndexedGetter</a>, obtaining an
--   <a>IndexedFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,0,0,5,5,5]^..traversed.ifiltered (\i a -&gt; i &lt;= a)
--   [0,5,5,5]
--   </pre>
--   
--   Compose with <a>ifiltered</a> to filter another <a>IndexedLens</a>,
--   <tt>IndexedIso</tt>, <a>IndexedGetter</a>, <a>IndexedFold</a> (or
--   <a>IndexedTraversal</a>) with access to both the value and the index.
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a

-- | Obtain an <a>IndexedFold</a> by taking elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Applying <a>itakingWhile</a> to an <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> will still allow you to use it as a
--   pseudo-<a>IndexedTraversal</a>, but if you change the value of any
--   target to one where the predicate returns <a>False</a>, then you will
--   break the <a>Traversal</a> laws and <a>Traversal</a> fusion will no
--   longer be sound.
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s))) s a -> Optical' p q f s a

-- | Obtain an <a>IndexedFold</a> by dropping elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: As with <a>droppingWhile</a> applying <a>idroppingWhile</a> to
--   an <a>IndexedLens</a> or <a>IndexedTraversal</a> will still allow you
--   to use it as a pseudo-<a>IndexedTraversal</a>, but if you change the
--   value of the first target to one where the predicate returns
--   <a>True</a>, then you will break the <a>Traversal</a> laws and
--   <a>Traversal</a> fusion will no longer be sound.
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | Used for <a>firstOf</a>.
data Leftmost a

-- | Used for <a>lastOf</a>.
data Rightmost a

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
data Traversed a f

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
--   
--   See 4.16 Changelog entry for the explanation of "why not Apply f
--   =&gt;"?
data Sequenced a m

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <tt>fold</tt> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldBy</a> <a>mappend</a> <a>mempty</a> ≡ <tt>fold</tt>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldBy (++) [] ["hello","world"]
--   "helloworld"
--   </pre>
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldByOf</a> <a>folded</a> ≡ <a>foldBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldByOf both (++) [] ("hello","world")
--   "helloworld"
--   </pre>
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <a>foldMap</a> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldMapBy</a> <a>mappend</a> <a>mempty</a> ≡ <a>foldMap</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapBy (+) 0 length ["hello","world"]
--   10
--   </pre>
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldMapBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldMapByOf</a> <a>folded</a> ≡ <a>foldMapBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapByOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapByOf both (+) 0 length ("hello","world")
--   10
--   </pre>
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r


-- | A <tt><a>Traversal</a> s t a b</tt> is a generalization of
--   <a>traverse</a> from <a>Traversable</a>. It allows you to
--   <a>traverse</a> over a structure and change out its contents with
--   monadic or <a>Applicative</a> side-effects. Starting from
--   
--   <pre>
--   <a>traverse</a> :: (<a>Traversable</a> t, <a>Applicative</a> f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
--   </pre>
--   
--   we monomorphize the contents and result to obtain
--   
--   <pre>
--   type <a>Traversal</a> s t a b = forall f. <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   A <a>Traversal</a> can be used as a <a>Fold</a>. Any <a>Traversal</a>
--   can be used for <a>Getting</a> like a <a>Fold</a>, because given a
--   <a>Monoid</a> <tt>m</tt>, we have an <a>Applicative</a> for
--   <tt>(<a>Const</a> m)</tt>. Everything you know how to do with a
--   <a>Traversable</a> container, you can with a <a>Traversal</a>, and
--   here we provide combinators that generalize the usual
--   <a>Traversable</a> operations.
module Control.Lens.Traversal

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<a>.</a>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (t f) <a>.</a> t g ≡ <a>getCompose</a> <a>.</a> t (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | A <a>Traversal</a> which targets at least one element.
--   
--   Note that since <a>Apply</a> is not a superclass of
--   <a>Applicative</a>, a <a>Traversal1</a> cannot always be used in place
--   of a <a>Traversal</a>. In such circumstances <a>cloneTraversal</a>
--   will convert a <a>Traversal1</a> into a <a>Traversal</a>.
type Traversal1 s t a b = forall f. Apply f => (a -> f b) -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall p f. (Indexable i p, Apply f) => p a (f b) -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal</a>.
type ATraversal s t a b = LensLike (Bazaar (->) a b) s t a b

-- | <pre>
--   type <a>ATraversal'</a> = <a>Simple</a> <a>ATraversal</a>
--   </pre>
type ATraversal' s a = ATraversal s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal1</a>.
type ATraversal1 s t a b = LensLike (Bazaar1 (->) a b) s t a b

-- | <pre>
--   type <a>ATraversal1'</a> = <a>Simple</a> <a>ATraversal1</a>
--   </pre>
type ATraversal1' s a = ATraversal1 s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal</a>.
type AnIndexedTraversal i s t a b = Over (Indexed i) (Bazaar (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal'</a> = <a>Simple</a> (<a>AnIndexedTraversal</a> i)
--   </pre>
type AnIndexedTraversal' i s a = AnIndexedTraversal i s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal1</a>.
type AnIndexedTraversal1 i s t a b = Over (Indexed i) (Bazaar1 (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal1'</a> = <a>Simple</a> (<a>AnIndexedTraversal1</a> i)
--   </pre>
type AnIndexedTraversal1' i s a = AnIndexedTraversal1 i s s a a

-- | When you see this as an argument to a function, it expects
--   
--   <ul>
--   <li>to be indexed if <tt>p</tt> is an instance of <a>Indexed</a>
--   i,</li>
--   <li>to be unindexed if <tt>p</tt> is <tt>(-&gt;)</tt>,</li>
--   <li>a <a>Traversal</a> if <tt>f</tt> is <a>Applicative</a>,</li>
--   <li>a <a>Getter</a> if <tt>f</tt> is only a <a>Functor</a> and
--   <a>Contravariant</a>,</li>
--   <li>a <a>Lens</a> if <tt>f</tt> is only a <a>Functor</a>,</li>
--   <li>a <a>Fold</a> if <tt>f</tt> is <a>Applicative</a> and
--   <a>Contravariant</a>.</li>
--   </ul>
type Traversing p f s t a b = Over p (BazaarT p f a b) s t a b

-- | <pre>
--   type <a>Traversing'</a> f = <a>Simple</a> (<a>Traversing</a> f)
--   </pre>
type Traversing' p f s a = Traversing p f s s a a
type Traversing1 p f s t a b = Over p (BazaarT1 p f a b) s t a b
type Traversing1' p f s a = Traversing1 p f s s a a

-- | Build a <a>Traversal</a> by providing a function which specifies the
--   elements you wish to focus.
--   
--   The caller provides a function of type:
--   
--   <pre>
--   Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   Which is a higher order function which accepts a "focusing function"
--   and applies it to all desired focuses within <tt>s</tt>, then
--   constructs a <tt>t</tt> using the Applicative instance of <tt>f</tt>.
--   
--   Only elements which are "focused" using the focusing function will be
--   targeted by the resulting traversal.
--   
--   For example, we can explicitly write a traversal which targets the
--   first and third elements of a tuple like this:
--   
--   <pre>
--   firstAndThird :: Traversal (a, x, a) (b, x, b) a b
--   firstAndThird = traversal go
--     where
--       go :: Applicative f =&gt; (a -&gt; f b) -&gt; (a, x, a) -&gt; f (b, x, b)
--       go focus (a, x, a') = liftA3 (,,) (focus a) (pure x) (focus a')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,"two",3) &amp; firstAndThird *~ 10
--   (10,"two",30)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over firstAndThird length ("one",2,"three")
--   (3,2,5)
--   </pre>
--   
--   We can re-use existing <a>Traversal</a>s when writing new ones by
--   passing our focusing function along to them. This example re-uses
--   <a>traverse</a> to focus all elements in a list which is embedded in a
--   tuple. This traversal could also be written simply as <tt>_2 .
--   traverse</tt>.
--   
--   <pre>
--   selectNested :: Traversal (x, [a]) (x, [b]) a b
--   selectNested = traversal go
--     where
--       go :: Applicative f =&gt; (a -&gt; f b) -&gt; (x, [a]) -&gt; f (x, [b])
--       go focus (x, as) = liftA2 (,) (pure x) (traverse focus as)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; selectNested .~ "hello" $ (1,[2,3,4,5])
--   (1,["hello","hello","hello","hello"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,[2,3,4,5]) &amp; selectNested *~ 3
--   (1,[6,9,12,15])
--   </pre>
--   
--   Note that the <a>traversal</a> function actually just returns the same
--   function you pass to it. The function it accepts is in fact a valid
--   traversal all on its own! The use of <a>traversal</a> does nothing
--   except verify that the function it is passed matches the signature of
--   a valid traversal. One could remove the <tt>traversal</tt> combinator
--   from either of the last two examples and use the definition of
--   <tt>go</tt> directly with no change in behaviour.
--   
--   This function exists for consistency with the <a>lens</a>,
--   <tt>prism</tt> and <tt>iso</tt> constructors as well as to serve as a
--   touchpoint for beginners who wish to construct their own traversals
--   but are uncertain how to do so.
traversal :: ((a -> f b) -> s -> f t) -> LensLike f s t a b

-- | Map each element of a structure targeted by a <a>Lens</a> or
--   <a>Traversal</a>, evaluate these actions from left to right, and
--   collect the results.
--   
--   This function is only provided for consistency, <a>id</a> is strictly
--   more general.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf each print (1,2,3)
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> ≡ <a>id</a>
--   <a>itraverseOf</a> l ≡ <a>traverseOf</a> l <a>.</a> <a>Indexed</a>
--   <a>itraverseOf</a> <tt>itraversed</tt> ≡ <tt>itraverse</tt>
--   </pre>
--   
--   This yields the obvious law:
--   
--   <pre>
--   <a>traverse</a> ≡ <a>traverseOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Iso</a> s t a b        -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Lens</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Apply</a> f       =&gt; <a>Traversal1</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b  -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t

-- | A version of <a>traverseOf</a> with the arguments flipped, such that:
--   
--   <pre>
--   &gt;&gt;&gt; forOf each (1,2,3) print
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   This function is only provided for consistency, <a>flip</a> is
--   strictly more general.
--   
--   <pre>
--   <a>forOf</a> ≡ <a>flip</a>
--   <a>forOf</a> ≡ <a>flip</a> . <a>traverseOf</a>
--   </pre>
--   
--   <pre>
--   <tt>for</tt> ≡ <a>forOf</a> <a>traverse</a>
--   <a>ifor</a> l s ≡ <tt>for</tt> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   </pre>
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf both ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequenceA</a> ≡ <a>sequenceAOf</a> <a>traverse</a> ≡ <a>traverse</a> <a>id</a>
--   <a>sequenceAOf</a> l ≡ <a>traverseOf</a> l <a>id</a> ≡ l <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t (f b) b       -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t (f b) b      -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t (f b) b -&gt; s -&gt; f t
--   </pre>
sequenceAOf :: LensLike f s t (f b) b -> s -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf both (\x -&gt; [x, x + 1]) (1,3)
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>mapM</a> ≡ <a>mapMOf</a> <a>traverse</a>
--   <a>imapMOf</a> l ≡ <tt>forM</tt> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t

-- | <a>forMOf</a> is a flipped version of <a>mapMOf</a>, consistent with
--   the definition of <tt>forM</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf both (1,3) $ \x -&gt; [x, x + 1]
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <tt>forM</tt> ≡ <a>forMOf</a> <a>traverse</a>
--   <a>forMOf</a> l ≡ <a>flip</a> (<a>mapMOf</a> l)
--   <a>iforMOf</a> l s ≡ <tt>forM</tt> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   </pre>
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t

-- | Sequence the (monadic) effects targeted by a <a>Lens</a> in a
--   container from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4],[5,6])
--   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a> ≡ <a>sequenceOf</a> <a>traverse</a>
--   <a>sequenceOf</a> l ≡ <a>mapMOf</a> l <a>id</a>
--   <a>sequenceOf</a> l ≡ <a>unwrapMonad</a> <a>.</a> l <a>WrapMonad</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t (m b) b       -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t (m b) b      -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t (m b) b -&gt; s -&gt; m t
--   </pre>
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traverse [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a> ≡ <a>transposeOf</a> <a>traverse</a>
--   </pre>
--   
--   Since every <a>Lens</a> is a <a>Traversal</a>, we can use this as a
--   form of monadic strength as well:
--   
--   <pre>
--   <a>transposeOf</a> <a>_2</a> :: (b, [a]) -&gt; [(b, a)]
--   </pre>
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <tt>mapAccumL</tt> ≡ <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>LensLike</a> (<a>State</a> acc) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> l f acc0 s = <a>swap</a> (<a>runState</a> (l (a -&gt; <a>state</a> (acc -&gt; <a>swap</a> (f acc a))) s) acc0)
--   </pre>
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <tt>mapAccumR</tt> ≡ <a>mapAccumROf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>LensLike</a> (<a>Backwards</a> (<a>State</a> acc)) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanr1</a> ≡ <a>scanr1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanr1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanl1</a> ≡ <a>scanl1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanl1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t

-- | Try to map a function over this <a>Traversal</a>, failing if the
--   <a>Traversal</a> has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2] :: Maybe [Int]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4) :: Maybe (Either Int Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4) :: Maybe (Either Int Int)
--   Just (Right 8)
--   </pre>
--   
--   <pre>
--   <a>failover</a> :: Alternative m =&gt; Traversal s t a b -&gt; (a -&gt; b) -&gt; s -&gt; m t
--   </pre>
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t

-- | Try to map a function which uses the index over this
--   <a>IndexedTraversal</a>, failing if the <a>IndexedTraversal</a> has no
--   targets.
--   
--   <pre>
--   <a>ifailover</a> :: Alternative m =&gt; IndexedTraversal i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; m t
--   </pre>
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t

-- | A <a>Traversal</a> is completely characterized by its behavior on a
--   <a>Bazaar</a>.
--   
--   Cloning a <a>Traversal</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Fold</a> and can be used as a way to
--   pass around traversals that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Traversal</a> (or <a>Lens</a>). To
--   clone a <a>Lens</a> as such, use <a>cloneLens</a>.
--   
--   Note: It is usually better to use <a>ReifiedTraversal</a> and
--   <a>runTraversal</a> than to <a>cloneTraversal</a>. The former can
--   execute at full speed, while the latter needs to round trip through
--   the <a>Bazaar</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let foo l a = (view (getting (cloneTraversal l)) a, set (cloneTraversal l) 10 a)
--   
--   &gt;&gt;&gt; foo both ("hello","world")
--   ("helloworld",(10,10))
--   </pre>
--   
--   <pre>
--   <a>cloneTraversal</a> :: <a>LensLike</a> (<a>Bazaar</a> (-&gt;) a b) s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
cloneTraversal :: ATraversal s t a b -> Traversal s t a b

-- | Clone a <a>Traversal</a> yielding an <a>IndexPreservingTraversal</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b

-- | Clone an <a>IndexedTraversal</a> yielding an <a>IndexedTraversal</a>
--   with the same index.
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | A <a>Traversal1</a> is completely characterized by its behavior on a
--   <a>Bazaar1</a>.
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b

-- | Clone a <a>Traversal1</a> yielding an <a>IndexPreservingTraversal1</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b

-- | Clone an <a>IndexedTraversal1</a> yielding an <a>IndexedTraversal1</a>
--   with the same index.
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a> that
--   resembles an early version of the <a>uniplate</a> (or <a>biplate</a>)
--   type.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y,z]
--   (x,y,z)
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [w,x,y,z]
--   (w,x,y)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y]
--   (x,y,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('b', 'a', 'd', 'c') &amp; partsOf each %~ sort
--   ('a','b','c','d')
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>.
--   
--   <pre>
--   <a>partsOf</a> :: <a>Iso'</a> s a       -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Traversal'</a> s a -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Fold</a> s a       -&gt; <a>Getter</a> s [a]
--   <a>partsOf</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s [a]
--   </pre>
partsOf :: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]

-- | A type-restricted version of <a>partsOf</a> that can only be used with
--   a <a>Traversal</a>.
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]

-- | <a>unsafePartsOf</a> turns a <a>Traversal</a> into a <a>uniplate</a>
--   (or <a>biplate</a>) family.
--   
--   If you do not need the types of <tt>s</tt> and <tt>t</tt> to be
--   different, it is recommended that you use <a>partsOf</a>.
--   
--   It is generally safer to traverse with the <a>Bazaar</a> rather than
--   use this combinator. However, it is sometimes convenient.
--   
--   This is unsafe because if you don't supply at least as many
--   <tt>b</tt>'s as you were given <tt>a</tt>'s, then the reconstruction
--   of <tt>t</tt> <i>will</i> result in an error!
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>
--   (and becomes safe).
--   
--   <pre>
--   <a>unsafePartsOf</a> :: <a>Iso</a> s t a b       -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Lens</a> s t a b      -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Traversal</a> s t a b -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Fold</a> s a          -&gt; <a>Getter</a> s [a]
--   <a>unsafePartsOf</a> :: <a>Getter</a> s a        -&gt; <a>Getter</a> s [a]
--   </pre>
unsafePartsOf :: Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]

-- | The one-level version of <a>contextsOf</a>. This extracts a list of
--   the immediate children according to a given <a>Traversal</a> as
--   editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren l x = <a>toListOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holesOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holesOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holesOf</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   <a>holesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   </pre>
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | The non-empty version of <a>holesOf</a>. This extract a non-empty list
--   of immediate children according to a given <a>Traversal1</a> as
--   editable contexts.
--   
--   <pre>
--   &gt;&gt;&gt; let head1 f s = runPretext (NonEmpty.head $ holes1Of traversed1 s) f
--   
--   &gt;&gt;&gt; ('a' :| "bc") ^. head1
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a' :| "bc") &amp; head1 %~ toUpper
--   'A' :| "bc"
--   </pre>
--   
--   <pre>
--   <a>holes1Of</a> :: <a>Iso'</a> s a                 -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Lens'</a> s a                -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Traversal1'</a> s a          -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>IndexedLens'</a> i s a       -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   <a>holes1Of</a> :: <a>IndexedTraversal1'</a> i s a -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   </pre>
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)

-- | This converts a <a>Traversal</a> that you "know" will target one or
--   more elements to a <a>Lens</a>. It can also be used to transform a
--   non-empty <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   supplied <a>Traversal</a> returns no results.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. singular _head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "singular: empty traversal") &lt;- try (evaluate ([] ^. singular _head)) :: IO (Either ErrorCall ())
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^. singular _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^. singular (ix 7)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; singular traverse .~ 0
--   []
--   </pre>
--   
--   <pre>
--   <a>singular</a> :: <a>Traversal</a> s t a a          -&gt; <a>Lens</a> s t a a
--   <a>singular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>singular</a> :: <a>IndexedTraversal</a> i s t a a -&gt; <a>IndexedLens</a> i s t a a
--   <a>singular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a

-- | This converts a <a>Traversal</a> that you "know" will target only one
--   element to a <a>Lens</a>. It can also be used to transform a
--   <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   <a>Traversal</a> targets nothing or more than one element.
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "unsafeSingular: empty traversal") &lt;- try (evaluate ([] &amp; unsafeSingular traverse .~ 0)) :: IO (Either ErrorCall [Integer])
--   </pre>
--   
--   <pre>
--   <a>unsafeSingular</a> :: <a>Traversal</a> s t a b          -&gt; <a>Lens</a> s t a b
--   <a>unsafeSingular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>unsafeSingular</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedLens</a> i s t a b
--   <a>unsafeSingular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
class (Foldable1 t, Traversable t) => Traversable1 (t :: Type -> Type)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   Usually that type will be a pair. Use <a>each</a> to traverse the
--   elements of arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both *~ 10
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.both
--   "helloworld"
--   </pre>
--   
--   <pre>
--   <a>both</a> :: <a>Traversal</a> (a, a)       (b, b)       a b
--   <a>both</a> :: <a>Traversal</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both :: Bitraversable r => Traversal (r a a) (r b b) a b

-- | Traverse both parts of a <a>Bitraversable1</a> container with matching
--   types.
--   
--   Usually that type will be a pair.
--   
--   <pre>
--   <a>both1</a> :: <a>Traversal1</a> (a, a)       (b, b)       a b
--   <a>both1</a> :: <a>Traversal1</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both1 :: Bitraversable1 r => Traversal1 (r a a) (r b b) a b

-- | Apply a different <a>Traversal</a> or <a>Fold</a> to each side of a
--   <a>Bitraversable</a> container.
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (r s s') (r t t') a b
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Lens</a> s t a b                     -&gt; <a>Lens</a> s' t' a b                     -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Fold</a> s a                         -&gt; <a>Fold</a> s' a                          -&gt; <a>Fold</a> (s,s') a
--   <a>beside</a> :: <a>Getter</a> s a                       -&gt; <a>Getter</a> s' a                        -&gt; <a>Fold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedLens</a> i s t a b            -&gt; <a>IndexedLens</a> i s' t' a b            -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s' a                 -&gt; <a>IndexedFold</a> i (s,s') a
--   <a>beside</a> :: <a>IndexedGetter</a> i s a              -&gt; <a>IndexedGetter</a> i s' a               -&gt; <a>IndexedFold</a> i (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingLens</a> s t a b      -&gt; <a>IndexPreservingLens</a> s' t' a b      -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s' a           -&gt; <a>IndexPreservingFold</a> (s,s') a
--   <a>beside</a> :: <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingGetter</a> s' a         -&gt; <a>IndexPreservingFold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",["world","!!!"])^..beside id traverse
--   ["hello","world","!!!"]
--   </pre>
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b

-- | Visit the first <i>n</i> targets of a <a>Traversal</a>, <a>Fold</a>,
--   <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("hello","world"),("!!!","!!!")]^.. taking 2 (traverse.both)
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1..] ^.. taking 3 traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (taking 5 traverse) succ "hello world"
--   "ifmmp world"
--   </pre>
--   
--   <pre>
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a

-- | Visit all but the first <i>n</i> targets of a <a>Traversal</a>,
--   <a>Fold</a>, <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") ^? dropping 1 both
--   Just "world"
--   </pre>
--   
--   Dropping works on infinite traversals as well:
--   
--   <pre>
--   &gt;&gt;&gt; [1..] ^? dropping 1 folded
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a

-- | Try the first <a>Traversal</a> (or <a>Fold</a>), falling back on the
--   second <a>Traversal</a> (or <a>Fold</a>) if it returns no entries.
--   
--   This is only a valid <a>Traversal</a> if the second <a>Traversal</a>
--   is disjoint from the result of the first or returns exactly the same
--   results. These conditions are trivially met when given a <a>Lens</a>,
--   <a>Iso</a>, <a>Getter</a>, <a>Prism</a> or "affine" Traversal -- one
--   that has 0 or 1 target.
--   
--   Mutatis mutandis for <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 1) (ix 2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 42) (ix 2)
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>failing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Prism</a> s t a b     -&gt; <a>Prism</a> s t a b     -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Fold</a> s a          -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>Lens</a> s t a b      -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Iso</a> s t a b       -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Equality</a> s t a b  -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Getter</a> s a        -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   If both of the inputs are indexed, the result is also indexed, so you
--   can apply this to a pair of indexed traversals or indexed folds,
--   obtaining an indexed traversal or indexed fold.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedGetter</a> i s a        -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
infixl 5 `failing`

-- | Try the second traversal. If it returns no entries, try again with all
--   entries from the first traversal, recursively.
--   
--   <pre>
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>Fold</a> s a                   -&gt; <a>Fold</a> s a
--   <a>deepOf</a> :: <a>Traversal'</a> s s    -&gt; <a>Traversal'</a> s a             -&gt; <a>Traversal'</a> s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>Traversal</a> s t a b          -&gt; <a>Traversal</a> s t a b
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   </pre>
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b

-- | This is the trivial empty <a>Traversal</a>.
--   
--   <pre>
--   <a>ignored</a> :: <a>IndexedTraversal</a> i s s a b
--   </pre>
--   
--   <pre>
--   <a>ignored</a> ≡ <a>const</a> <a>pure</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: Applicative f => pafb -> s -> f s

-- | Allows <a>IndexedTraversal</a> the value at the smallest index.
class Ord k => TraverseMin k m | m -> k

-- | <a>IndexedTraversal</a> of the element with the smallest index.
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v

-- | Allows <a>IndexedTraversal</a> of the value at the largest index.
class Ord k => TraverseMax k m | m -> k

-- | <a>IndexedTraversal</a> of the element at the largest index.
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Traverse any <a>Traversable1</a> container. This is an
--   <a>IndexedTraversal1</a> that is indexed by ordinal position.
traversed1 :: Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed64 :: Traversable f => IndexedTraversal Int64 (f a) (f b) a b

-- | Traverse the <i>nth</i> <a>elementOf</a> a <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a> if it exists.
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] &amp; elementOf (traverse.traverse) 1 .~ 5
--   [[1],[5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] ^? elementOf (folded.folded) 1
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ ['a'..] ^?! elementOf folded 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ take 10 $ elementOf traverse 3 .~ 16 $ [0..]
--   [0,1,2,16,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   <a>elementOf</a> :: <a>Traversal'</a> s a -&gt; <a>Int</a> -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementOf</a> :: <a>Fold</a> s a       -&gt; <a>Int</a> -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a> ≡ <a>elementOf</a> <a>traverse</a>
--   </pre>
element :: Traversable t => Int -> IndexedTraversal' Int (t a) a

-- | Traverse (or fold) selected elements of a <a>Traversal</a> (or
--   <a>Fold</a>) where their ordinal positions match a predicate.
--   
--   <pre>
--   <a>elementsOf</a> :: <a>Traversal'</a> s a -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementsOf</a> :: <a>Fold</a> s a       -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementsOf :: Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a> ≡ <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its index.
ipartsOf :: forall i p f s t a. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]

-- | A type-restricted version of <a>ipartsOf</a> that can only be used
--   with an <a>IndexedTraversal</a>.
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]

-- | An indexed version of <a>unsafePartsOf</a> that receives the entire
--   list of indices as its index.
iunsafePartsOf :: forall i p f s t a b. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]

-- | Traversal with an index.
--   
--   <i>NB:</i> When you don't need access to the index then you can just
--   apply your <a>IndexedTraversal</a> directly as a function!
--   
--   <pre>
--   <a>itraverseOf</a> ≡ <a>withIndex</a>
--   <a>traverseOf</a> l = <a>itraverseOf</a> l <a>.</a> <a>const</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <a>forOf</a> l a ≡ <a>iforOf</a> l a <a>.</a> <a>const</a>
--   <a>iforOf</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   </pre>
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position.
--   
--   When you don't need access to the index <a>mapMOf</a> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <a>mapMOf</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a>       i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a>  i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <tt>Bind</tt>  m =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position (and the arguments flipped).
--   
--   <pre>
--   <a>forMOf</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   <a>iforMOf</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a> i s t a b      -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   </pre>
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> l ≡ <a>imapAccumROf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumROf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumROf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> l ≡ <a>imapAccumLOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumLOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumLOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Traverse a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>traverse</a> where the <a>Applicative</a> instance can be manually
--   specified.
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)

-- | Traverse a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>traverseByOf</a> <a>traverse</a> ≡ <a>traverseBy</a>
--   </pre>
traverseByOf :: Traversal s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t

-- | Sequence a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>sequence</a> where the <a>Applicative</a> instance can be manually
--   specified.
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)

-- | Sequence a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>sequenceByOf</a> <a>traverse</a> ≡ <a>sequenceBy</a>
--   </pre>
sequenceByOf :: Traversal s t (f b) b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> s -> f t

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
[runBazaar] :: Bazaar p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' p a = Bazaar p a a

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
[runBazaar1] :: Bazaar1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' p a = Bazaar1 p a a

-- | This <a>Traversal</a> allows you to <a>traverse</a> the individual
--   stores in a <a>Bazaar</a>.
loci :: Traversal (Bazaar (->) a c s) (Bazaar (->) b c s) a b

-- | This <a>IndexedTraversal</a> allows you to <a>traverse</a> the
--   individual stores in a <a>Bazaar</a> with access to their indices.
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b

-- | <a>Fuse</a> a <a>Traversal</a> by reassociating all of the
--   <tt>(<a>&lt;*&gt;</a>)</tt> operations to the left and fusing all of
--   the <a>fmap</a> calls into one. This is particularly useful when
--   constructing a <a>Traversal</a> using operations from
--   <a>GHC.Generics</a>.
--   
--   Given a pair of <a>Traversal</a>s <tt>foo</tt> and <tt>bar</tt>,
--   
--   <pre>
--   <a>confusing</a> (foo.bar) = foo.bar
--   </pre>
--   
--   However, <tt>foo</tt> and <tt>bar</tt> are each going to use the
--   <a>Applicative</a> they are given.
--   
--   <a>confusing</a> exploits the <a>Yoneda</a> lemma to merge their
--   separate uses of <a>fmap</a> into a single <a>fmap</a>. and it further
--   exploits an interesting property of the right Kan lift (or
--   <a>Curried</a>) to left associate all of the uses of
--   <tt>(<a>&lt;*&gt;</a>)</tt> to make it possible to fuse together more
--   fmaps.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Traversal</a>
--   <tt>foo.bar</tt> in the above description is recursive or complex
--   enough to prevent inlining.
--   
--   <a>fusing</a> is a version of this combinator suitable for fusing
--   lenses.
--   
--   <pre>
--   <a>confusing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
instance Control.Lens.Traversal.TraverseMax GHC.Types.Int Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMax k (Data.Map.Internal.Map k)
instance Control.Lens.Traversal.TraverseMin GHC.Types.Int Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Control.Lens.Traversal.TraverseMin k (Data.Map.Internal.Map k)
instance GHC.Base.Functor (Control.Lens.Traversal.Holes t m)
instance GHC.Base.Semigroup m => Data.Functor.Bind.Class.Apply (Control.Lens.Traversal.Holes t m)
instance GHC.Base.Monoid m => GHC.Base.Applicative (Control.Lens.Traversal.Holes t m)


-- | This module provides combinators for breadth-first searching within
--   arbitrary traversals.
module Control.Lens.Level

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual <a>levels</a> of any other <a>Traversal</a> or <a>Fold</a>
--   via iterative deepening depth-first search. The levels are returned to
--   you in a compressed format.
--   
--   This can permit us to extract the <a>levels</a> directly:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse)
--   [Zero,Zero,One () 'h',Two 0 (One () 'e') (One () 'w'),Two 0 (One () 'l') (One () 'o'),Two 0 (One () 'l') (One () 'r'),Two 0 (One () 'o') (One () 'l'),One () 'd']
--   </pre>
--   
--   But we can also traverse them in turn:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse).traverse
--   "hewlolrold"
--   </pre>
--   
--   We can use this to traverse to a fixed depth in the tree of
--   (<a>&lt;*&gt;</a>) used in the <a>Traversal</a>:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse)).traverse %~ toUpper
--   ["HEllo","World"]
--   </pre>
--   
--   Or we can use it to traverse the first <tt>n</tt> elements in found in
--   that <a>Traversal</a> regardless of the depth at which they were
--   found.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse).traverse) %~ toUpper
--   ["HELlo","World"]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the <a>levels</a> which is indexed
--   by the depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..levels (traverse.traverse) &lt;. traverse
--   [(2,'d'),(3,'o'),(3,'c'),(4,'g'),(4,'a'),(5,'t')]
--   </pre>
--   
--   <pre>
--   <a>levels</a> :: <a>Traversal</a> s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> () a) (<a>Level</a> () b)
--   <a>levels</a> :: <a>Fold</a> s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> () a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
levels :: Applicative f => Traversing (->) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual levels of any other <a>Traversal</a> or <a>Fold</a> via
--   iterative deepening depth-first search. The levels are returned to you
--   in a compressed format.
--   
--   This is similar to <a>levels</a>, but retains the index of the
--   original <a>IndexedTraversal</a>, so you can access it when traversing
--   the levels later on.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed).itraversed
--   [((0,0),'d'),((0,1),'o'),((1,0),'c'),((0,2),'g'),((1,1),'a'),((1,2),'t')]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the levels which is indexed by the
--   depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed)&lt;.&gt;itraversed
--   [((2,(0,0)),'d'),((3,(0,1)),'o'),((3,(1,0)),'c'),((4,(0,2)),'g'),((4,(1,1)),'a'),((5,(1,2)),'t')]
--   </pre>
--   
--   <pre>
--   <a>ilevels</a> :: <a>IndexedTraversal</a> i s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> i a) (<a>Level</a> i b)
--   <a>ilevels</a> :: <a>IndexedFold</a> i s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> i a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
ilevels :: Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)


module Control.Lens.Reified

-- | Reify a <a>Lens</a> so it can be stored safely in a container.
newtype ReifiedLens s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
[runLens] :: ReifiedLens s t a b -> Lens s t a b

-- | <pre>
--   type <a>ReifiedLens'</a> = <a>Simple</a> <a>ReifiedLens</a>
--   </pre>
type ReifiedLens' s a = ReifiedLens s s a a

-- | Reify an <a>IndexedLens</a> so it can be stored safely in a container.
newtype ReifiedIndexedLens i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
[runIndexedLens] :: ReifiedIndexedLens i s t a b -> IndexedLens i s t a b

-- | <pre>
--   type <a>ReifiedIndexedLens'</a> i = <a>Simple</a> (<a>ReifiedIndexedLens</a> i)
--   </pre>
type ReifiedIndexedLens' i s a = ReifiedIndexedLens i s s a a

-- | Reify an <a>IndexedTraversal</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedTraversal i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
[runIndexedTraversal] :: ReifiedIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | <pre>
--   type <a>ReifiedIndexedTraversal'</a> i = <a>Simple</a> (<a>ReifiedIndexedTraversal</a> i)
--   </pre>
type ReifiedIndexedTraversal' i s a = ReifiedIndexedTraversal i s s a a

-- | A form of <a>Traversal</a> that can be stored monomorphically in a
--   container.
newtype ReifiedTraversal s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
[runTraversal] :: ReifiedTraversal s t a b -> Traversal s t a b

-- | <pre>
--   type <a>ReifiedTraversal'</a> = <a>Simple</a> <a>ReifiedTraversal</a>
--   </pre>
type ReifiedTraversal' s a = ReifiedTraversal s s a a

-- | Reify a <a>Getter</a> so it can be stored safely in a container.
--   
--   This can also be useful when combining getters in novel ways, as
--   <a>ReifiedGetter</a> is isomorphic to <tt>(-&gt;)</tt> and provides
--   similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world","!!!")^.runGetter ((,) &lt;$&gt; Getter _2 &lt;*&gt; Getter (_1.to length))
--   ("world",5)
--   </pre>
newtype ReifiedGetter s a
Getter :: Getter s a -> ReifiedGetter s a
[runGetter] :: ReifiedGetter s a -> Getter s a

-- | Reify an <a>IndexedGetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedGetter i s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
[runIndexedGetter] :: ReifiedIndexedGetter i s a -> IndexedGetter i s a

-- | Reify a <a>Fold</a> so it can be stored safely in a container.
--   
--   This can also be useful for creatively combining folds as
--   <tt><a>ReifiedFold</a> s</tt> is isomorphic to <tt>ReaderT s []</tt>
--   and provides similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^..runFold ((,) &lt;$&gt; Fold _2 &lt;*&gt; Fold both)
--   [("world","hello"),("world","world")]
--   </pre>
newtype ReifiedFold s a
Fold :: Fold s a -> ReifiedFold s a
[runFold] :: ReifiedFold s a -> Fold s a
newtype ReifiedIndexedFold i s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
[runIndexedFold] :: ReifiedIndexedFold i s a -> IndexedFold i s a

-- | Reify a <a>Setter</a> so it can be stored safely in a container.
newtype ReifiedSetter s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
[runSetter] :: ReifiedSetter s t a b -> Setter s t a b

-- | <pre>
--   type <a>ReifiedSetter'</a> = <a>Simple</a> <a>ReifiedSetter</a>
--   </pre>
type ReifiedSetter' s a = ReifiedSetter s s a a

-- | Reify an <a>IndexedSetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedSetter i s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
[runIndexedSetter] :: ReifiedIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | <pre>
--   type <a>ReifiedIndexedSetter'</a> i = <a>Simple</a> (<a>ReifiedIndexedSetter</a> i)
--   </pre>
type ReifiedIndexedSetter' i s a = ReifiedIndexedSetter i s s a a

-- | Reify an <a>Iso</a> so it can be stored safely in a container.
newtype ReifiedIso s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
[runIso] :: ReifiedIso s t a b -> Iso s t a b

-- | <pre>
--   type <a>ReifiedIso'</a> = <a>Simple</a> <a>ReifiedIso</a>
--   </pre>
type ReifiedIso' s a = ReifiedIso s s a a

-- | Reify a <a>Prism</a> so it can be stored safely in a container.
newtype ReifiedPrism s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
[runPrism] :: ReifiedPrism s t a b -> Prism s t a b

-- | <pre>
--   type <a>ReifiedPrism'</a> = <a>Simple</a> <a>ReifiedPrism</a>
--   </pre>
type ReifiedPrism' s a = ReifiedPrism s s a a
instance GHC.Base.Semigroup (Control.Lens.Reified.ReifiedIndexedFold i s a)
instance GHC.Base.Monoid (Control.Lens.Reified.ReifiedIndexedFold i s a)
instance Data.Functor.Alt.Alt (Control.Lens.Reified.ReifiedIndexedFold i s)
instance Data.Functor.Plus.Plus (Control.Lens.Reified.ReifiedIndexedFold i s)
instance GHC.Base.Functor (Control.Lens.Reified.ReifiedIndexedFold i s)
instance Data.Profunctor.Unsafe.Profunctor (Control.Lens.Reified.ReifiedIndexedFold i)
instance Data.Profunctor.Sieve.Sieve (Control.Lens.Reified.ReifiedIndexedFold i) (Data.Functor.Compose.Compose [] ((,) i))
instance Data.Profunctor.Rep.Representable (Control.Lens.Reified.ReifiedIndexedFold i)
instance Data.Profunctor.Strong.Strong (Control.Lens.Reified.ReifiedIndexedFold i)
instance Data.Profunctor.Unsafe.Profunctor Control.Lens.Reified.ReifiedFold
instance Data.Profunctor.Sieve.Sieve Control.Lens.Reified.ReifiedFold []
instance Data.Profunctor.Rep.Representable Control.Lens.Reified.ReifiedFold
instance Data.Profunctor.Strong.Strong Control.Lens.Reified.ReifiedFold
instance Data.Profunctor.Choice.Choice Control.Lens.Reified.ReifiedFold
instance Control.Category.Category Control.Lens.Reified.ReifiedFold
instance Control.Arrow.Arrow Control.Lens.Reified.ReifiedFold
instance Control.Arrow.ArrowChoice Control.Lens.Reified.ReifiedFold
instance Control.Arrow.ArrowApply Control.Lens.Reified.ReifiedFold
instance GHC.Base.Functor (Control.Lens.Reified.ReifiedFold s)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Reified.ReifiedFold s)
instance GHC.Base.Applicative (Control.Lens.Reified.ReifiedFold s)
instance GHC.Base.Alternative (Control.Lens.Reified.ReifiedFold s)
instance Data.Functor.Bind.Class.Bind (Control.Lens.Reified.ReifiedFold s)
instance GHC.Base.Monad (Control.Lens.Reified.ReifiedFold s)
instance GHC.Base.MonadPlus (Control.Lens.Reified.ReifiedFold s)
instance Control.Monad.Reader.Class.MonadReader s (Control.Lens.Reified.ReifiedFold s)
instance GHC.Base.Semigroup (Control.Lens.Reified.ReifiedFold s a)
instance GHC.Base.Monoid (Control.Lens.Reified.ReifiedFold s a)
instance Data.Functor.Alt.Alt (Control.Lens.Reified.ReifiedFold s)
instance Data.Functor.Plus.Plus (Control.Lens.Reified.ReifiedFold s)
instance Data.Profunctor.Unsafe.Profunctor (Control.Lens.Reified.ReifiedIndexedGetter i)
instance Data.Profunctor.Sieve.Sieve (Control.Lens.Reified.ReifiedIndexedGetter i) ((,) i)
instance Data.Profunctor.Rep.Representable (Control.Lens.Reified.ReifiedIndexedGetter i)
instance Data.Profunctor.Strong.Strong (Control.Lens.Reified.ReifiedIndexedGetter i)
instance GHC.Base.Functor (Control.Lens.Reified.ReifiedIndexedGetter i s)
instance GHC.Base.Semigroup i => Data.Functor.Bind.Class.Apply (Control.Lens.Reified.ReifiedIndexedGetter i s)
instance Data.Distributive.Distributive (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Functor (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Semigroup s => Data.Functor.Extend.Extend (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Monoid s => Control.Comonad.Comonad (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Monoid s => Control.Comonad.ComonadApply (Control.Lens.Reified.ReifiedGetter s)
instance Data.Functor.Bind.Class.Apply (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Applicative (Control.Lens.Reified.ReifiedGetter s)
instance Data.Functor.Bind.Class.Bind (Control.Lens.Reified.ReifiedGetter s)
instance GHC.Base.Monad (Control.Lens.Reified.ReifiedGetter s)
instance Control.Monad.Reader.Class.MonadReader s (Control.Lens.Reified.ReifiedGetter s)
instance Data.Profunctor.Unsafe.Profunctor Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Closed.Closed Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Sieve.Cosieve Control.Lens.Reified.ReifiedGetter Data.Functor.Identity.Identity
instance Data.Profunctor.Rep.Corepresentable Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Sieve.Sieve Control.Lens.Reified.ReifiedGetter Data.Functor.Identity.Identity
instance Data.Profunctor.Rep.Representable Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Strong.Costrong Control.Lens.Reified.ReifiedGetter
instance Control.Lens.Internal.Indexed.Conjoined Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Strong.Strong Control.Lens.Reified.ReifiedGetter
instance Data.Profunctor.Choice.Choice Control.Lens.Reified.ReifiedGetter
instance Control.Category.Category Control.Lens.Reified.ReifiedGetter
instance Control.Arrow.Arrow Control.Lens.Reified.ReifiedGetter
instance Control.Arrow.ArrowApply Control.Lens.Reified.ReifiedGetter
instance Control.Arrow.ArrowChoice Control.Lens.Reified.ReifiedGetter
instance Control.Arrow.ArrowLoop Control.Lens.Reified.ReifiedGetter


-- | This module uses dirty tricks to generate a <a>Handler</a> from an
--   arbitrary <a>Fold</a>.
module Control.Lens.Internal.Exception

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: Type -> Type) (h :: Type -> Type) | h -> e m

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really).
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler</a> <a>_AssertionFailed</a> (s -&gt; <a>print</a> <a>$</a> "Assertion Failed\n" <a>++</a> s)
--               , <a>handler</a> <a>_ErrorCall</a> (s -&gt; <a>print</a> <a>$</a> "Error\n" <a>++</a> s)
--               ]
--   </pre>
--   
--   This works ith both the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Fold</a>       e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Prism'</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Lens'</a>      e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Traversal'</a> e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   </pre>
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really). that ignores its input
--   and just recovers with the stated monadic action.
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler_</a> <a>_NonTermination</a> (<a>return</a> "looped")
--               , <a>handler_</a> <a>_StackOverflow</a> (<a>return</a> "overflow")
--               ]
--   </pre>
--   
--   This works with the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Fold</a>       e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Prism'</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Lens'</a>      e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Traversal'</a> e a -&gt; m r -&gt; <a>Handler</a> e m r
--   </pre>
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | There was an <a>Exception</a> caused by abusing the internals of a
--   <a>Handler</a>.
data HandlingException
HandlingException :: HandlingException
instance GHC.Show.Show Control.Lens.Internal.Exception.HandlingException
instance forall k a (s :: k) (m :: * -> *). GHC.Show.Show (Control.Lens.Internal.Exception.Handling a s m)
instance (Data.Reflection.Reifies s (GHC.Exception.Type.SomeException -> GHC.Maybe.Maybe a), Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable m) => GHC.Exception.Type.Exception (Control.Lens.Internal.Exception.Handling a s m)
instance GHC.Exception.Type.Exception Control.Lens.Internal.Exception.HandlingException
instance Control.Lens.Internal.Exception.Handleable GHC.Exception.Type.SomeException GHC.Types.IO Control.Exception.Handler
instance Data.Typeable.Internal.Typeable m => Control.Lens.Internal.Exception.Handleable GHC.Exception.Type.SomeException m (Control.Monad.Catch.Handler m)


-- | (The classes in here need to be defined together for
--   <tt>DefaultSignatures</tt> to work.)
module Control.Lens.Indexed

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i p

-- | Build a function from an <a>indexed</a> function.
indexed :: Indexable i p => p a b -> i -> a -> b

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p) => Conjoined p

-- | <a>Conjoined</a> is strong enough to let us distribute every
--   <a>Conjoined</a> <a>Profunctor</a> over every Haskell <a>Functor</a>.
--   This is effectively a generalization of <a>fmap</a>.
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)

-- | This permits us to make a decision at an outermost point about whether
--   or not we use an index.
--   
--   Ideally any use of this function should be done in such a way so that
--   you compute the same answer, but this cannot be enforced at the type
--   level.
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
[runIndexed] :: Indexed i a b -> i -> a -> b

-- | Compose an <a>Indexed</a> function with a non-indexed function.
--   
--   Mnemonically, the <tt>&lt;</tt> points to the indexing we want to
--   preserve.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.itraversed).withIndex
--   [(1,"one,ten"),(1,"one,twenty"),(2,"two,thirty"),(2,"two,forty")]
--   </pre>
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
infixr 9 <.

-- | Composition of <a>Indexed</a> functions.
--   
--   Mnemonically, the <tt>&lt;</tt> and <tt>&gt;</tt> points to the fact
--   that we want to preserve the indices.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.&gt;itraversed).withIndex
--   [((1,10),"one,ten"),((1,20),"one,twenty"),((2,30),"two,thirty"),((2,40),"two,forty")]
--   </pre>
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
infixr 9 <.>

-- | Compose a non-indexed function with an <a>Indexed</a> function.
--   
--   Mnemonically, the <tt>&gt;</tt> points to the indexing we want to
--   preserve.
--   
--   This is the same as <tt>(<a>.</a>)</tt>.
--   
--   <tt>f <a>.</a> g</tt> (and <tt>f <a>.&gt;</a> g</tt>) gives you the
--   index of <tt>g</tt> unless <tt>g</tt> is index-preserving, like a
--   <a>Prism</a>, <a>Iso</a> or <a>Equality</a>, in which case it'll pass
--   through the index of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed.&gt;itraversed).withIndex
--   [(10,"one,ten"),(20,"one,twenty"),(30,"two,thirty"),(40,"two,forty")]
--   </pre>
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
infixr 9 .>

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>id</a>.
--   
--   Note: When used to modify the value, this can break the index
--   requirements assumed by <a>indices</a> and similar, so this is only
--   properly an <a>IndexedGetter</a>, but it can be used as more.
--   
--   <pre>
--   <a>selfIndex</a> :: <a>IndexedGetter</a> a a b
--   </pre>
selfIndex :: Indexable a p => p a fb -> a -> fb

-- | Remap the index.
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r

-- | Composition of <a>Indexed</a> functions with a user supplied function
--   for combining indices.
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | The <a>IndexedSetter</a> for a <a>FunctorWithIndex</a>.
--   
--   If you don't need access to the index, then <a>mapped</a> is more
--   flexible in what it accepts.
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | The <a>IndexedFold</a> of a <a>FoldableWithIndex</a> container.
--   
--   <tt><a>ifolded</a> <a>.</a> <a>asIndex</a></tt> is a fold over the
--   keys of a <a>FoldableWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Map.fromList [(2, "hello"), (1, "world")]^..ifolded.asIndex
--   [1,2]
--   </pre>
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a

-- | Return whether or not any element in a container satisfies a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>any</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>any</a> ≡ <a>iany</a> <a>.</a> <tt>const</tt>
--   </pre>
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not all elements in a container satisfy a predicate,
--   with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <tt>all</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>all</tt> ≡ <a>iall</a> <a>.</a> <tt>const</tt>
--   </pre>
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not none of the elements in a container satisfy a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>none</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>none</a> ≡ <a>inone</a> <a>.</a> <tt>const</tt>
--   <a>inone</a> f ≡ <a>not</a> <a>.</a> <a>iany</a> f
--   </pre>
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Determines whether no elements of the structure satisfy the predicate.
--   
--   <pre>
--   <a>none</a> f ≡ <a>not</a> <a>.</a> <a>any</a> f
--   </pre>
none :: Foldable f => (a -> Bool) -> f a -> Bool

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <tt>traverse_</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>traverse_</tt> l = <a>itraverse</a> <a>.</a> <tt>const</tt>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <tt>for_</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>for_</tt> a ≡ <a>ifor_</a> a <a>.</a> <tt>const</tt>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>mapM_</tt> ≡ <tt>imapM</tt> <a>.</a> <tt>const</tt>
--   </pre>
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforM_</a> ≡ <a>flip</a> <a>imapM_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forM_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forM_</a> a ≡ <tt>iforM</tt> a <a>.</a> <tt>const</tt>
--   </pre>
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()

-- | Concatenate the results of a function of the elements of an indexed
--   container with access to the index.
--   
--   When you don't need access to the index then <tt>concatMap</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>concatMap</tt> ≡ <a>iconcatMap</a> <a>.</a> <tt>const</tt>
--   <a>iconcatMap</a> ≡ <a>ifoldMap</a>
--   </pre>
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]

-- | Searches a container with a predicate that is also supplied the index,
--   returning the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <tt>find</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>find</tt> ≡ <a>ifind</a> <a>.</a> <tt>const</tt>
--   </pre>
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <tt>foldrM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldrM</tt> ≡ <a>ifoldrM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <tt>foldlM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldlM</tt> ≡ <a>ifoldlM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <tt>toList</tt> is more flexible in what it accepts.
--   
--   <pre>
--   <tt>toList</tt> ≡ <a>map</a> <tt>snd</tt> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex
--   [(0,10),(1,20),(2,30)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex . alongside negated (re _Show)
--   [(0,"10"),(-1,"20"),(-2,"30")]
--   </pre>
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on a predicate on
--   the indices.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^..traversed.indices even
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traversed.indices (&gt;0)) Prelude.reverse $ ["He","was","stressed","o_O"]
--   ["He","saw","desserts","O_o"]
--   </pre>
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on an index.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^?traversed.index 2
--   Just "world"
--   </pre>
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | The <a>IndexedTraversal</a> of a <a>TraversableWithIndex</a>
--   container.
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <tt>.</tt> <tt>const</tt>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access the
--   index.
--   
--   When you don't need access to the index <tt>mapM</tt> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <tt>mapM</tt> ≡ <a>imapM</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access its
--   position (and the arguments flipped).
--   
--   <pre>
--   <tt>forM</tt> a ≡ <a>iforM</a> a <tt>.</tt> <tt>const</tt>
--   <a>iforM</a> ≡ <a>flip</a> <a>imapM</a>
--   </pre>
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)

-- | Generalizes <a>mapAccumR</a> to add access to the index.
--   
--   <a>imapAccumR</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>imapAccumR</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Generalizes <a>mapAccumL</a> to add access to the index.
--   
--   <a>imapAccumL</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>imapAccumL</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
itraverseBy :: TraversableWithIndex i t => (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t


-- | This module spends a lot of time fiddling around with
--   <a>ByteString</a> internals to work around
--   <a>http://hackage.haskell.org/trac/ghc/ticket/7556</a> on older
--   Haskell Platforms and to improve constant and asymptotic factors in
--   our performance.
module Control.Lens.Internal.ByteString

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves.
traversedStrictTree :: IndexedTraversal' Int ByteString Word8

-- | Traverse a strict <a>ByteString</a> in a relatively balanced fashion,
--   as a balanced tree with biased runs of elements at the leaves,
--   pretending the bytes are chars.
traversedStrictTree8 :: IndexedTraversal' Int ByteString Char

-- | An <a>IndexedTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a>
traversedLazy :: IndexedTraversal' Int64 ByteString Word8

-- | An <a>IndexedTraversal</a> of the individual bytes in a lazy
--   <a>ByteString</a> pretending the bytes are chars.
traversedLazy8 :: IndexedTraversal' Int64 ByteString Char


module Control.Lens.Equality

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall k3 (p :: k1 -> k3 -> Type) (f :: k2 -> k3). p a (f b) -> p s (f t)

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' s a = Equality s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Equality</a>.
type AnEquality s t a b = Identical a (Proxy b) a (Proxy b) -> Identical a (Proxy b) s (Proxy t)

-- | A <a>Simple</a> <a>AnEquality</a>.
type AnEquality' s a = AnEquality s s a a

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | Extract a witness of type <a>Equality</a>.
runEq :: AnEquality s t a b -> Identical s t a b

-- | Substituting types with <a>Equality</a>.
substEq :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r

-- | We can use <a>Equality</a> to do substitution into anything.
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (f :: k1 -> Type). AnEquality s t a b -> f s -> f a

-- | <a>Equality</a> is symmetric.
fromEq :: AnEquality s t a b -> Equality b a t s

-- | This is an adverb that can be used to modify many other <a>Lens</a>
--   combinators to make them require simple lenses, simple traversals,
--   simple prisms or simple isos as input.
simply :: forall p f s a rep (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: Equality' a a

-- | Construct an <a>Equality</a> from explicit equality evidence.
equality :: (s :~: a) -> (b :~: t) -> Equality s t a b

-- | A <a>Simple</a> version of <a>equality</a>
equality' :: (a :~: b) -> Equality' a b

-- | A version of <a>substEq</a> that provides explicit, rather than
--   implicit, equality evidence.
withEquality :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r

-- | The opposite of working <a>overEquality</a> is working
--   <a>underEquality</a>.
underEquality :: AnEquality s t a b -> p t s -> p b a

-- | Recover a "profunctor lens" form of equality. Reverses
--   <a>fromLeibniz</a>.
overEquality :: AnEquality s t a b -> p a b -> p s t

-- | Convert a "profunctor lens" form of equality to an equality. Reverses
--   <a>overEquality</a>.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz :: (forall p. p a b -&gt; p s t) -&gt; Equality s t a b
--   </pre>
fromLeibniz :: (Identical a b a b -> Identical a b s t) -> Equality s t a b

-- | Convert Leibniz equality to equality. Reverses <a>mapEq</a> in
--   <a>Simple</a> cases.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz' :: (forall f. f s -&gt; f a) -&gt; Equality' s a
--   </pre>
fromLeibniz' :: ((s :~: s) -> s :~: a) -> Equality' s a
cloneEquality :: AnEquality s t a b -> Equality s t a b

-- | Provides witness that <tt>(s ~ a, b ~ t)</tt> holds.
data Identical a b s t
[Identical] :: Identical a b a b


module Control.Lens.Iso

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<a>.</a>) and <a>id</a>.
--   
--   Since every <a>Iso</a> is both a valid <a>Lens</a> and a valid
--   <a>Prism</a>, the laws for those types imply the following laws for an
--   <a>Iso</a> <tt>f</tt>:
--   
--   <pre>
--   f <a>.</a> <a>from</a> f ≡ <a>id</a>
--   <a>from</a> f <a>.</a> f ≡ <a>id</a>
--   </pre>
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Iso</a>.
type AnIso s t a b = Exchange a b a (Identity b) -> Exchange a b s (Identity t)

-- | A <a>Simple</a> <a>AnIso</a>.
type AnIso' s a = AnIso s s a a

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g) ≡ f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g)) ≡ g
--   <a>over</a> (<a>iso</a> f g) h ≡ g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h ≡ f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Invert an isomorphism.
--   
--   <pre>
--   <a>from</a> (<a>from</a> l) ≡ l
--   </pre>
from :: AnIso s t a b -> Iso b a t s

-- | Convert from <a>AnIso</a> back to any <a>Iso</a>.
--   
--   This is useful when you need to store an isomorphism as a data type
--   inside a container and later reconstitute it as an overloaded
--   function.
--   
--   See <a>cloneLens</a> or <a>cloneTraversal</a> for more information on
--   why you might want to do this.
cloneIso :: AnIso s t a b -> Iso s t a b

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: forall s t a b rep (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Based on <a>ala</a> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler type:
--   
--   <pre>
--   au :: AnIso s t a b -&gt; ((b -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; a
--   </pre>
--   
--   <pre>
--   au = xplat . from
--   </pre>
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a

-- | Based on <tt>ala'</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   For a version you pass the name of the <tt>newtype</tt> constructor
--   to, see <a>alaf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; auf (_Wrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   Mnemonically, the German <i>auf</i> plays a similar role to <i>à
--   la</i>, and the combinator is <a>au</a> with an extra function
--   argument:
--   
--   <pre>
--   <a>auf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; b) -&gt; e -&gt; a
--   </pre>
--   
--   but the signature is general.
--   
--   Note: The direction of the <a>Iso</a> required for this function
--   changed in <tt>lens</tt> 4.18 to match up with the behavior of
--   <a>au</a>. For the old behavior use <a>xplatf</a> or for a version
--   that is compatible across both old and new versions of <tt>lens</tt>
--   you can just use <a>coerce</a>!
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a

-- | <tt><a>xplat</a> = <a>au</a> . <a>from</a></tt> but with a nicer
--   signature.
xplat :: Optic (Costar ((->) s)) g s t a b -> ((s -> a) -> g b) -> g t

-- | <tt><a>xplatf</a> = <a>auf</a> . <a>from</a></tt> but with a nicer
--   signature.
--   
--   <pre>
--   &gt;&gt;&gt; xplatf (_Unwrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   <pre>
--   <a>xplatf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; a) -&gt; e -&gt; b) -&gt; (r -&gt; s) -&gt; e -&gt; t
--   </pre>
xplatf :: Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a> ≡ <a>over</a> <a>.</a> <a>from</a>
--   </pre>
--   
--   <pre>
--   <a>under</a> :: <a>Iso</a> s t a b -&gt; (t -&gt; s) -&gt; b -&gt; a
--   </pre>
under :: AnIso s t a b -> (t -> s) -> b -> a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: Equality' a a

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" . non' _Empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . non' _Empty . at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: APrism' a () -> Iso' (Maybe a) a

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . anon Map.empty Map.null . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . anon Map.empty Map.null . at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | This isomorphism can be used to convert to or from an instance of
--   <a>Enum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; LT^.from enum
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 97^.enum :: Char
--   'a'
--   </pre>
--   
--   Note: this is only an isomorphism from the numeric range actually used
--   and it is a bit of a pleasant fiction, since there are questionable
--   <a>Enum</a> instances for <a>Double</a>, and <a>Float</a> that exist
--   solely for <tt>[1.0 .. 4.0]</tt> sugar and the instances for those and
--   <a>Integer</a> don't cover all values in their range.
enum :: Enum a => Iso' Int a

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (fst^.curried) 3 4
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>from</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((+)^.uncurried) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; ((,)^.flipped) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | <pre>
--   <a>swapped</a> <a>.</a> <a>swapped</a> ≡ <a>id</a>
--   <a>first</a> f <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>second</a> f
--   <a>second</a> g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>first</a> g
--   <a>bimap</a> f g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>bimap</a> g f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^.swapped
--   (2,1)
--   </pre>
swapped :: Swap p => Iso (p a b) (p c d) (p b a) (p d c)
pattern Swapped :: Swap p => p b a -> p a b

-- | An <a>Iso</a> between the lazy variant of a structure and its strict
--   counterpart.
--   
--   <pre>
--   <a>strict</a> = <a>from</a> <a>lazy</a>
--   </pre>
strict :: Strict lazy strict => Iso' lazy strict

-- | An <a>Iso</a> between the strict variant of a structure and its lazy
--   counterpart.
--   
--   <pre>
--   <a>lazy</a> = <a>from</a> <a>strict</a>
--   </pre>
lazy :: Strict lazy strict => Iso' strict lazy
pattern Strict :: Strict s t => t -> s
pattern Lazy :: Strict t s => t -> s

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t

-- | An <a>Iso</a> between a list, <tt>ByteString</tt>, <tt>Text</tt>
--   fragment, etc. and its reversal.
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. reversed
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; reversed %~ ('d':)
--   "lived"
--   </pre>
reversed :: Reversing a => Iso' a a
pattern Reversed :: Reversing t => t -> t

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a> ≡ <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a
pattern List :: IsList l => [Item l] -> l

-- | This isomorphism can be used to inspect a <a>Traversal</a> to see how
--   it associates the structure and it can also be used to bake the
--   <a>Traversal</a> into a <a>Magma</a> so that you can traverse over it
--   multiple times.
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)

-- | This isomorphism can be used to inspect an <a>IndexedTraversal</a> to
--   see how it associates the structure and it can also be used to bake
--   the <a>IndexedTraversal</a> into a <a>Magma</a> so that you can
--   traverse over it multiple times with access to the original indices.
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a

-- | Lift an <a>Iso</a> into a <a>Contravariant</a> functor.
--   
--   <pre>
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (f a) (f b) (f s) (f t)
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (f a) (f s)
--   </pre>
contramapping :: Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class () => Profunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d

-- | Map the first argument contravariantly.
--   
--   <pre>
--   <a>lmap</a> f ≡ <a>dimap</a> f <a>id</a>
--   </pre>
lmap :: Profunctor p => (a -> b) -> p b c -> p a c

-- | Map the second argument covariantly.
--   
--   <pre>
--   <a>rmap</a> ≡ <a>dimap</a> <a>id</a>
--   </pre>
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | Lift two <a>Iso</a>s into both arguments of a <a>Profunctor</a>
--   simultaneously.
--   
--   <pre>
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p a s') (p b t') (p s a') (p t b')
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p a s') (p s a')
--   </pre>
dimapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')

-- | Lift an <a>Iso</a> contravariantly into the left argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p a x) (p b y) (p s x) (p t y)
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p a x) (p s x)
--   </pre>
lmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)

-- | Lift an <a>Iso</a> covariantly into the right argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
rmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Bifunctor</a>.
--   
--   <pre>
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p s s') (p t t') (p a a') (p b b')
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p s s') (p a a')
--   </pre>
bimapping :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')

-- | Lift an <a>Iso</a> into the first argument of a <a>Bifunctor</a>.
--   
--   <pre>
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p s x) (p t y) (p a x) (p b y)
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p s x) (p a x)
--   </pre>
firsting :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)

-- | Lift an <a>Iso</a> into the second argument of a <a>Bifunctor</a>.
--   This is essentially the same as <a>mapping</a>, but it takes a
--   'Bifunctor p' constraint instead of a 'Functor (p a)' one.
--   
--   <pre>
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
seconding :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)

-- | Data types that are representationally equal are isomorphic.
--   
--   This is only available on GHC 7.8+
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b


module Control.Lens.Empty
class AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()
pattern Empty :: AsEmpty s => s
instance Control.Lens.Empty.AsEmpty GHC.Types.Ordering
instance Control.Lens.Empty.AsEmpty ()
instance Control.Lens.Empty.AsEmpty Data.Semigroup.Internal.Any
instance Control.Lens.Empty.AsEmpty Data.Semigroup.Internal.All
instance Control.Lens.Empty.AsEmpty GHC.Event.Internal.Types.Event
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Control.Lens.Empty.AsEmpty (Data.Semigroup.Internal.Product a)
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Control.Lens.Empty.AsEmpty (Data.Semigroup.Internal.Sum a)
instance Control.Lens.Empty.AsEmpty (GHC.Maybe.Maybe a)
instance Control.Lens.Empty.AsEmpty (Data.Monoid.Last a)
instance Control.Lens.Empty.AsEmpty (Data.Monoid.First a)
instance Control.Lens.Empty.AsEmpty a => Control.Lens.Empty.AsEmpty (Data.Semigroup.Internal.Dual a)
instance (Control.Lens.Empty.AsEmpty a, Control.Lens.Empty.AsEmpty b) => Control.Lens.Empty.AsEmpty (a, b)
instance (Control.Lens.Empty.AsEmpty a, Control.Lens.Empty.AsEmpty b, Control.Lens.Empty.AsEmpty c) => Control.Lens.Empty.AsEmpty (a, b, c)
instance Control.Lens.Empty.AsEmpty [a]
instance Control.Lens.Empty.AsEmpty (Control.Applicative.ZipList a)
instance Control.Lens.Empty.AsEmpty (Data.Map.Internal.Map k a)
instance Control.Lens.Empty.AsEmpty (Data.HashMap.Internal.HashMap k a)
instance Control.Lens.Empty.AsEmpty (Data.IntMap.Internal.IntMap a)
instance Control.Lens.Empty.AsEmpty (Data.Set.Internal.Set a)
instance Control.Lens.Empty.AsEmpty (Data.HashSet.Internal.HashSet a)
instance Control.Lens.Empty.AsEmpty Data.IntSet.Internal.IntSet
instance Control.Lens.Empty.AsEmpty (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Control.Lens.Empty.AsEmpty (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Control.Lens.Empty.AsEmpty (Data.Vector.Storable.Vector a)
instance Control.Lens.Empty.AsEmpty (Data.Sequence.Internal.Seq a)
instance Control.Lens.Empty.AsEmpty Data.ByteString.Internal.Type.ByteString
instance Control.Lens.Empty.AsEmpty Data.ByteString.Lazy.Internal.ByteString
instance Control.Lens.Empty.AsEmpty Data.Text.Internal.Text
instance Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text


module Control.Lens.Cons

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (a, <a>Vector</a> a) (b, <a>Vector</a> b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>Text</a> (<a>Char</a>, <a>Text</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>ByteString</a> (<a>Word8</a>, <a>ByteString</a>)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList []
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList [b, c]
--   fromList [a,b,c]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons a []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [])
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [b, c])
--   fromList [a,b,c]
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [a, b, c]
--   Just (a,[b,c])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | A <a>Traversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head .~ d
--   [d,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head %~ f
--   [f a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ f
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?!_head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
--   
--   This isn't limited to lists.
--   
--   For instance you can also <a>traverse</a> the head of a <a>Seq</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; _head %~ f
--   fromList [f a,b,c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   <a>_head</a> :: <a>Traversal'</a> [a] a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_head :: Cons s s a a => Traversal' s a

-- | A <a>Traversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _tail .~ [c,d,e]
--   [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d,e] &amp; _tail.traverse %~ f
--   [a,f b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?_tail
--   Just [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?!_tail
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._tail
--   "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._tail
--   ""
--   </pre>
--   
--   This isn't limited to lists. For instance you can also <a>traverse</a>
--   the tail of a <a>Seq</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b] &amp; _tail .~ Seq.fromList [c,d,e]
--   fromList [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^? _tail
--   Just (fromList [b,c])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _tail
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>_tail</a> :: <a>Traversal'</a> [a] [a]
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_tail :: Cons s s a a => Traversal' s s
pattern (:<) :: Cons b b a a => a -> b -> b
infixr 5 :<

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Snoc</a> :: <a>Prism</a> [a] [b] ([a], a) ([b], b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (<a>Seq</a> a, a) (<a>Seq</a> b, b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (<a>Vector</a> a, a) (<a>Vector</a> b, b)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>String</a> (<a>String</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>Text</a> (<a>Text</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>ByteString</a> (<a>ByteString</a>, <a>Word8</a>)
--   </pre>
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] |&gt; a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [b, c] |&gt; a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LazyT.pack "hello" |&gt; '!'
--   "hello!"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList []) a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList [b, c]) a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (LazyT.pack "hello") '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "hello!")
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [b,c,a])
--   Just (fromList [b,c],a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [])
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | A <a>Traversal</a> reading and replacing all but the a last element of
--   a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d]^?_init
--   Just [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _init .~ [c,d,e]
--   [c,d,e,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d] &amp; _init.traverse %~ f
--   [f a,f b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?_init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^?!_init
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._init
--   "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._init
--   ""
--   </pre>
--   
--   <pre>
--   <a>_init</a> :: <a>Traversal'</a> [a] [a]
--   <a>_init</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_init</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_init :: Snoc s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList "abcde" &amp; _last .~ 'Q') == Vector.fromList "abcdQ"
--   True
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a
pattern (:>) :: Snoc a a b b => a -> b -> a
infixl 5 :>
instance Control.Lens.Cons.Snoc [a] [b] a b
instance Control.Lens.Cons.Snoc (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Control.Lens.Cons.Snoc (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Control.Lens.Cons.Snoc (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Control.Lens.Cons.Snoc (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Control.Lens.Cons.Snoc (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Control.Lens.Cons.Snoc (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance Control.Lens.Cons.Snoc Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Control.Lens.Cons.Snoc Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Control.Lens.Cons.Snoc Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Control.Lens.Cons.Snoc Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char
instance Control.Lens.Cons.Cons [a] [b] a b
instance Control.Lens.Cons.Cons (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Control.Lens.Cons.Cons (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Control.Lens.Cons.Cons Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Control.Lens.Cons.Cons Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 GHC.Word.Word8
instance Control.Lens.Cons.Cons Data.Text.Internal.Text Data.Text.Internal.Text GHC.Types.Char GHC.Types.Char
instance Control.Lens.Cons.Cons Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text GHC.Types.Char GHC.Types.Char
instance Control.Lens.Cons.Cons (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Control.Lens.Cons.Cons (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Control.Lens.Cons.Cons (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Control.Lens.Cons.Cons (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b


-- | This module is designed to be imported qualified.
module Control.Lens.Internal.Deque

-- | A Banker's deque based on Chris Okasaki's "Purely Functional Data
--   Structures"
data Deque a
BD :: !Int -> [a] -> !Int -> [a] -> Deque a

-- | <i>O(1)</i>. Calculate the size of a <a>Deque</a>
--   
--   <pre>
--   &gt;&gt;&gt; size (fromList [1,4,6])
--   3
--   </pre>
size :: Deque a -> Int

-- | <i>O(n)</i> amortized. Construct a <a>Deque</a> from a list of values.
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2]
--   BD 1 [1] 1 [2]
--   </pre>
fromList :: [a] -> Deque a

-- | <i>O(1)</i>. Determine if a <a>Deque</a> is <a>empty</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Control.Lens.Internal.Deque.null empty
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Control.Lens.Internal.Deque.null (singleton 1)
--   False
--   </pre>
null :: Deque a -> Bool

-- | <i>O(1)</i>. Generate a singleton <a>Deque</a>
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   BD 1 [1] 0 []
--   </pre>
singleton :: a -> Deque a
instance GHC.Show.Show a => GHC.Show.Show (Control.Lens.Internal.Deque.Deque a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Lens.Internal.Deque.Deque a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Lens.Internal.Deque.Deque a)
instance GHC.Base.Functor Control.Lens.Internal.Deque.Deque
instance WithIndex.FunctorWithIndex GHC.Types.Int Control.Lens.Internal.Deque.Deque
instance Data.Functor.Bind.Class.Apply Control.Lens.Internal.Deque.Deque
instance GHC.Base.Applicative Control.Lens.Internal.Deque.Deque
instance Data.Functor.Alt.Alt Control.Lens.Internal.Deque.Deque
instance Data.Functor.Plus.Plus Control.Lens.Internal.Deque.Deque
instance GHC.Base.Alternative Control.Lens.Internal.Deque.Deque
instance Control.Lens.Internal.Iso.Reversing (Control.Lens.Internal.Deque.Deque a)
instance Data.Functor.Bind.Class.Bind Control.Lens.Internal.Deque.Deque
instance GHC.Base.Monad Control.Lens.Internal.Deque.Deque
instance GHC.Base.MonadPlus Control.Lens.Internal.Deque.Deque
instance Data.Foldable.Foldable Control.Lens.Internal.Deque.Deque
instance WithIndex.FoldableWithIndex GHC.Types.Int Control.Lens.Internal.Deque.Deque
instance Data.Traversable.Traversable Control.Lens.Internal.Deque.Deque
instance WithIndex.TraversableWithIndex GHC.Types.Int Control.Lens.Internal.Deque.Deque
instance GHC.Base.Semigroup (Control.Lens.Internal.Deque.Deque a)
instance GHC.Base.Monoid (Control.Lens.Internal.Deque.Deque a)
instance Control.Lens.Cons.Cons (Control.Lens.Internal.Deque.Deque a) (Control.Lens.Internal.Deque.Deque b) a b
instance Control.Lens.Cons.Snoc (Control.Lens.Internal.Deque.Deque a) (Control.Lens.Internal.Deque.Deque b) a b


-- | The <a>Wrapped</a> class provides similar functionality as
--   <tt>Control.Newtype</tt>, from the <tt>newtype</tt> package, but in a
--   more convenient and efficient form.
--   
--   There are a few functions from <tt>newtype</tt> that are not provided
--   here, because they can be done with the <a>Iso</a> directly:
--   
--   <pre>
--   Control.Newtype.over <a>Sum</a> f ≡ <a>_Unwrapping</a> <a>Sum</a> <a>%~</a> f
--   Control.Newtype.under <a>Sum</a> f ≡ <a>_Wrapping</a> <a>Sum</a> <a>%~</a> f
--   Control.Newtype.overF <a>Sum</a> f ≡ <a>mapping</a> (<a>_Unwrapping</a> <a>Sum</a>) <a>%~</a> f
--   Control.Newtype.underF <a>Sum</a> f ≡ <a>mapping</a> (<a>_Wrapping</a> <a>Sum</a>) <a>%~</a> f
--   </pre>
--   
--   <a>under</a> can also be used with <a>_Unwrapping</a> to provide the
--   equivalent of <tt>Control.Newtype.under</tt>. Also, most use cases
--   don't need full polymorphism, so only the single constructor
--   <a>_Wrapping</a> functions would be needed.
--   
--   These equivalences aren't 100% honest, because <tt>newtype</tt>'s
--   operators need to rely on two <tt>Newtype</tt> constraints. This means
--   that the wrapper used for the output is not necessarily the same as
--   the input.
module Control.Lens.Wrapped

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type Unwrapped s :: Type;
    type Unwrapped s = GUnwrapped (Rep s);
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: (Wrapped s, Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s
class Wrapped s => Rewrapped (s :: Type) (t :: Type)
class (Rewrapped s t, Rewrapped t s) => Rewrapping s t

-- | Work under a newtype wrapper.
--   
--   <pre>
--   &gt;&gt;&gt; Const "hello" &amp; _Wrapped %~ Prelude.length &amp; getConst
--   5
--   </pre>
--   
--   <pre>
--   <a>_Wrapped</a>   ≡ <a>from</a> <a>_Unwrapped</a>
--   <a>_Unwrapped</a> ≡ <a>from</a> <a>_Wrapped</a>
--   </pre>
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)

-- | This is a convenient version of <a>_Unwrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s

-- | Given the constructor for a <a>Wrapped</a> type, return a
--   deconstructor that is its inverse.
--   
--   Assuming the <a>Wrapped</a> instance is legal, these laws hold:
--   
--   <pre>
--   <a>op</a> f <a>.</a> f ≡ <a>id</a>
--   f <a>.</a> <a>op</a> f ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Identity (Identity 4)
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Const (Const "hello")
--   "hello"
--   </pre>
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s

-- | This combinator is based on <tt>ala</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [False,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [True,False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Product foldMap [1,2,3,4]
--   24
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler, type.
--   
--   <pre>
--   ala :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((Unwrapped t -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; Unwrapped s
--   </pre>
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)

-- | This combinator is based on <tt>ala'</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   alaf :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; Unwrapped t) -&gt; e -&gt; Unwrapped s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; alaf Sum foldMap Prelude.length ["hello","world"]
--   10
--   </pre>
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t

-- | Implement the <a>_Wrapped</a> operation for a type using its
--   <a>Generic</a> instance.
_GWrapped' :: (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
instance (Control.Lens.Wrapped.Rewrapped s t, Control.Lens.Wrapped.Rewrapped t s) => Control.Lens.Wrapped.Rewrapping s t
instance (t GHC.Types.~ Data.Semigroup.Internal.All) => Control.Lens.Wrapped.Rewrapped Data.Semigroup.Internal.All t
instance (t GHC.Types.~ Data.Semigroup.Internal.Any) => Control.Lens.Wrapped.Rewrapped Data.Semigroup.Internal.Any t
instance (t GHC.Types.~ Data.Semigroup.Internal.Sum b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Internal.Sum a) t
instance (t GHC.Types.~ Data.Semigroup.Internal.Product b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Internal.Product a) t
instance (t GHC.Types.~ Control.Arrow.Kleisli m' a' b') => Control.Lens.Wrapped.Rewrapped (Control.Arrow.Kleisli m a b) t
instance (t GHC.Types.~ Control.Applicative.WrappedMonad m' a') => Control.Lens.Wrapped.Rewrapped (Control.Applicative.WrappedMonad m a) t
instance (t GHC.Types.~ Control.Applicative.WrappedArrow a' b' c') => Control.Lens.Wrapped.Rewrapped (Control.Applicative.WrappedArrow a b c) t
instance (t GHC.Types.~ Control.Applicative.ZipList b) => Control.Lens.Wrapped.Rewrapped (Control.Applicative.ZipList a) t
instance (t GHC.Types.~ GHC.Base.NonEmpty b) => Control.Lens.Wrapped.Rewrapped (GHC.Base.NonEmpty a) t
instance forall k1 k2 t a' (x' :: k1) a (x :: k2). (t GHC.Types.~ Data.Functor.Const.Const a' x') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Const.Const a x) t
instance (t GHC.Types.~ Data.Semigroup.Internal.Dual b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Internal.Dual a) t
instance (t GHC.Types.~ Data.Semigroup.Internal.Endo b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Internal.Endo a) t
instance (t GHC.Types.~ Data.Monoid.First b) => Control.Lens.Wrapped.Rewrapped (Data.Monoid.First a) t
instance (t GHC.Types.~ Data.Monoid.Last b) => Control.Lens.Wrapped.Rewrapped (Data.Monoid.Last a) t
instance forall k1 k2 t (g :: k1 -> *) (b :: k1) (f :: k2 -> *) (a :: k2). (t GHC.Types.~ Data.Semigroup.Internal.Alt g b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Internal.Alt f a) t
instance forall k1 k2 t (g :: k1 -> *) (b :: k1) (f :: k2 -> *) (a :: k2). (t GHC.Types.~ Data.Monoid.Ap g b) => Control.Lens.Wrapped.Rewrapped (Data.Monoid.Ap f a) t
instance (t GHC.Types.~ Control.Arrow.ArrowMonad m' a') => Control.Lens.Wrapped.Rewrapped (Control.Arrow.ArrowMonad m a) t
instance (t GHC.Types.~ Data.Ord.Down b) => Control.Lens.Wrapped.Rewrapped (Data.Ord.Down a) t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Error.Errno t
instance forall k1 k2 t (g :: k1 -> *) (b :: k1) (f :: k2 -> *) (a :: k2). (t GHC.Types.~ Control.Applicative.Backwards.Backwards g b) => Control.Lens.Wrapped.Rewrapped (Control.Applicative.Backwards.Backwards f a) t
instance forall k2 k3 k4 k5 t (f' :: k2 -> *) (g' :: k3 -> k2) (a' :: k3) (f :: k4 -> *) (g :: k5 -> k4) (a :: k5). (t GHC.Types.~ Data.Functor.Compose.Compose f' g' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Compose.Compose f g a) t
instance forall k1 k2 t a' (b' :: k1) a (b :: k2). (t GHC.Types.~ Data.Functor.Constant.Constant a' b') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Constant.Constant a b) t
instance forall k1 k2 t (r' :: k1) (m' :: k1 -> *) a' (r :: k2) (m :: k2 -> *) a. (t GHC.Types.~ Control.Monad.Trans.Cont.ContT r' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Cont.ContT r m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Except.ExceptT e' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Except.ExceptT e m a) t
instance (t GHC.Types.~ Data.Functor.Identity.Identity b) => Control.Lens.Wrapped.Rewrapped (Data.Functor.Identity.Identity a) t
instance forall k1 k2 t (n :: k1 -> *) (b :: k1) (m :: k2 -> *) (a :: k2). (t GHC.Types.~ Control.Monad.Trans.Identity.IdentityT n b) => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Identity.IdentityT m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Maybe.MaybeT n b) => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Maybe.MaybeT m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Reader.ReaderT s n b) => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Reader.ReaderT r m a) t
instance forall k1 k2 t (g :: k1 -> *) (b :: k1) (f :: k2 -> *) (a :: k2). (t GHC.Types.~ Data.Functor.Reverse.Reverse g b) => Control.Lens.Wrapped.Rewrapped (Data.Functor.Reverse.Reverse f a) t
instance (t GHC.Types.~ Control.Monad.Trans.RWS.Lazy.RWST r' w' s' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.RWS.Lazy.RWST r w s m a) t
instance (t GHC.Types.~ Control.Monad.Trans.RWS.Strict.RWST r' w' s' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.RWS.Strict.RWST r w s m a) t
instance (t GHC.Types.~ Control.Monad.Trans.State.Lazy.StateT s' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.State.Lazy.StateT s m a) t
instance (t GHC.Types.~ Control.Monad.Trans.State.Strict.StateT s' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.State.Strict.StateT s m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Writer.Lazy.WriterT w' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Writer.Lazy.WriterT w m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Writer.Strict.WriterT w' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Writer.Strict.WriterT w m a) t
instance forall k4 k5 k6 k7 k8 k9 k10 k11 t (p' :: k4 -> k5 -> *) (f' :: k6 -> k4) (g' :: k7 -> k5) (a' :: k6) (b' :: k7) (p :: k8 -> k9 -> *) (f :: k10 -> k8) (g :: k11 -> k9) (a :: k10) (b :: k11). (t GHC.Types.~ Data.Bifunctor.Biff.Biff p' f' g' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Biff.Biff p f g a b) t
instance forall k2 k3 k4 k5 t (f' :: k2 -> *) (a' :: k2) (b' :: k3) (f :: k4 -> *) (a :: k4) (b :: k5). (t GHC.Types.~ Data.Bifunctor.Clown.Clown f' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Clown.Clown f a b) t
instance forall k1 k2 t (p' :: * -> k1 -> *) (a' :: k1) (p :: * -> k2 -> *) (a :: k2). (t GHC.Types.~ Data.Bifunctor.Fix.Fix p' a') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Fix.Fix p a) t
instance forall k2 k3 k4 k5 t (p' :: k2 -> k3 -> *) (a' :: k3) (b' :: k2) (p :: k4 -> k5 -> *) (a :: k5) (b :: k4). (t GHC.Types.~ Data.Bifunctor.Flip.Flip p' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Flip.Flip p a b) t
instance forall k1 k2 t (p' :: k1 -> k1 -> *) (a' :: k1) (p :: k2 -> k2 -> *) (a :: k2). (t GHC.Types.~ Data.Bifunctor.Join.Join p' a') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Join.Join p a) t
instance forall k2 k3 k4 k5 t (g' :: k2 -> *) (a' :: k3) (b' :: k2) (g :: k4 -> *) (a :: k5) (b :: k4). (t GHC.Types.~ Data.Bifunctor.Joker.Joker g' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Joker.Joker g a b) t
instance forall k4 k5 k6 k7 k8 k9 t (f' :: k4 -> *) (p' :: k5 -> k6 -> k4) (a' :: k5) (b' :: k6) (f :: k7 -> *) (p :: k8 -> k9 -> k7) (a :: k8) (b :: k9). (t GHC.Types.~ Data.Bifunctor.Tannen.Tannen f' p' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Tannen.Tannen f p a b) t
instance forall k2 k3 k4 k5 t (p' :: k2 -> k3 -> *) (a' :: k2) (b' :: k3) (p :: k4 -> k5 -> *) (a :: k4) (b :: k5). (t GHC.Types.~ Data.Bifunctor.Wrapped.WrappedBifunctor p' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Bifunctor.Wrapped.WrappedBifunctor p a b) t
instance (t GHC.Types.~ Control.Comonad.Trans.Traced.TracedT m' w' a') => Control.Lens.Wrapped.Rewrapped (Control.Comonad.Trans.Traced.TracedT m w a) t
instance (t GHC.Types.~ Control.Monad.Catch.Pure.CatchT m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Catch.Pure.CatchT m a) t
instance (t GHC.Types.~ Control.Alternative.Free.Alt f' a') => Control.Lens.Wrapped.Rewrapped (Control.Alternative.Free.Alt f a) t
instance (t GHC.Types.~ Control.Applicative.Trans.Free.ApT f' g' a') => Control.Lens.Wrapped.Rewrapped (Control.Applicative.Trans.Free.ApT f g a) t
instance (t GHC.Types.~ Control.Comonad.Trans.Cofree.CofreeT f' w' a') => Control.Lens.Wrapped.Rewrapped (Control.Comonad.Trans.Cofree.CofreeT f w a) t
instance (t GHC.Types.~ Control.Comonad.Trans.Coiter.CoiterT w' a') => Control.Lens.Wrapped.Rewrapped (Control.Comonad.Trans.Coiter.CoiterT w a) t
instance (t GHC.Types.~ Control.Monad.Trans.Free.FreeT f' m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Free.FreeT f m a) t
instance (t GHC.Types.~ Control.Monad.Trans.Iter.IterT m' a') => Control.Lens.Wrapped.Rewrapped (Control.Monad.Trans.Iter.IterT m a) t
instance (t GHC.Types.~ Data.HashMap.Internal.HashMap k' a', Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Control.Lens.Wrapped.Rewrapped (Data.HashMap.Internal.HashMap k a) t
instance (t GHC.Types.~ Data.HashSet.Internal.HashSet a', Data.Hashable.Class.Hashable a, GHC.Classes.Eq a) => Control.Lens.Wrapped.Rewrapped (Data.HashSet.Internal.HashSet a) t
instance (t GHC.Types.~ Data.IntMap.Internal.IntMap a') => Control.Lens.Wrapped.Rewrapped (Data.IntMap.Internal.IntMap a) t
instance (t GHC.Types.~ Data.IntSet.Internal.IntSet) => Control.Lens.Wrapped.Rewrapped Data.IntSet.Internal.IntSet t
instance (t GHC.Types.~ Data.Map.Internal.Map k' a', GHC.Classes.Ord k) => Control.Lens.Wrapped.Rewrapped (Data.Map.Internal.Map k a) t
instance (t GHC.Types.~ Data.Set.Internal.Set a', GHC.Classes.Ord a) => Control.Lens.Wrapped.Rewrapped (Data.Set.Internal.Set a) t
instance (t GHC.Types.~ Data.Sequence.Internal.Seq a') => Control.Lens.Wrapped.Rewrapped (Data.Sequence.Internal.Seq a) t
instance forall k1 k2 t (f' :: k1 -> *) d' (c' :: k1) (f :: k2 -> *) d (c :: k2). (t GHC.Types.~ Data.Profunctor.Types.Star f' d' c') => Control.Lens.Wrapped.Rewrapped (Data.Profunctor.Types.Star f d c) t
instance forall k1 k2 t (f' :: k1 -> *) (d' :: k1) c' (f :: k2 -> *) (d :: k2) c. (t GHC.Types.~ Data.Profunctor.Types.Costar f' d' c') => Control.Lens.Wrapped.Rewrapped (Data.Profunctor.Types.Costar f d c) t
instance forall k2 k3 k4 k5 t (p' :: k2 -> k3 -> *) (a' :: k2) (b' :: k3) (p :: k4 -> k5 -> *) (a :: k4) (b :: k5). (t GHC.Types.~ Data.Profunctor.Types.WrappedArrow p' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Profunctor.Types.WrappedArrow p a b) t
instance forall k1 k2 t r' a' (b' :: k1) r a (b :: k2). (t GHC.Types.~ Data.Profunctor.Types.Forget r' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Profunctor.Types.Forget r a b) t
instance forall k4 k5 k6 k7 k8 k9 t (f' :: k4 -> *) (p' :: k5 -> k6 -> k4) (a' :: k5) (b' :: k6) (f :: k7 -> *) (p :: k8 -> k9 -> k7) (a :: k8) (b :: k9). (t GHC.Types.~ Data.Profunctor.Cayley.Cayley f' p' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Profunctor.Cayley.Cayley f p a b) t
instance (t GHC.Types.~ Data.Vector.Vector a') => Control.Lens.Wrapped.Rewrapped (Data.Vector.Vector a) t
instance (Data.Primitive.Types.Prim a, t GHC.Types.~ Data.Vector.Primitive.Vector a') => Control.Lens.Wrapped.Rewrapped (Data.Vector.Primitive.Vector a) t
instance (Data.Vector.Unboxed.Base.Unbox a, t GHC.Types.~ Data.Vector.Unboxed.Base.Vector a') => Control.Lens.Wrapped.Rewrapped (Data.Vector.Unboxed.Base.Vector a) t
instance (Foreign.Storable.Storable a, t GHC.Types.~ Data.Vector.Storable.Vector a') => Control.Lens.Wrapped.Rewrapped (Data.Vector.Storable.Vector a) t
instance (t GHC.Types.~ Data.Functor.Bind.Class.WrappedApplicative f' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Bind.Class.WrappedApplicative f a) t
instance (t GHC.Types.~ Data.Functor.Bind.Class.MaybeApply f' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Bind.Class.MaybeApply f a) t
instance forall k2 k3 k4 k5 t (k' :: k2 -> k3 -> *) (a' :: k2) (b' :: k3) (k6 :: k4 -> k5 -> *) (a :: k4) (b :: k5). (t GHC.Types.~ Data.Semigroupoid.WrappedCategory k' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Semigroupoid.WrappedCategory k6 a b) t
instance forall k2 k3 k4 k5 t m' (a' :: k2) (b' :: k3) m (a :: k4) (b :: k5). (t GHC.Types.~ Data.Semigroupoid.Semi m' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Semigroupoid.Semi m a b) t
instance forall k2 k3 k4 k5 t (k' :: k2 -> k3 -> *) (a' :: k3) (b' :: k2) (k6 :: k4 -> k5 -> *) (a :: k5) (b :: k4). (t GHC.Types.~ Data.Semigroupoid.Dual.Dual k' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Semigroupoid.Dual.Dual k6 a b) t
instance (t GHC.Types.~ Data.Semigroupoid.Static.Static f' a' b') => Control.Lens.Wrapped.Rewrapped (Data.Semigroupoid.Static.Static f a b) t
instance (t GHC.Types.~ Data.Semigroup.Min b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Min a) t
instance (t GHC.Types.~ Data.Semigroup.Max b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Max a) t
instance (t GHC.Types.~ Data.Semigroup.First b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.First a) t
instance (t GHC.Types.~ Data.Semigroup.Last b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.Last a) t
instance (t GHC.Types.~ Data.Semigroup.WrappedMonoid b) => Control.Lens.Wrapped.Rewrapped (Data.Semigroup.WrappedMonoid a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Predicate b) => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Predicate a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Comparison b) => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Comparison a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Equivalence b) => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Equivalence a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Op a' b') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Op a b) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Compose.Compose f' g' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Compose.Compose f g a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Compose.ComposeFC f' g' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Compose.ComposeFC f g a) t
instance (t GHC.Types.~ Data.Functor.Contravariant.Compose.ComposeCF f' g' a') => Control.Lens.Wrapped.Rewrapped (Data.Functor.Contravariant.Compose.ComposeCF f g a) t
instance forall k1 k2 t (s' :: k1) a' (s :: k2) a. (t GHC.Types.~ Data.Tagged.Tagged s' a') => Control.Lens.Wrapped.Rewrapped (Data.Tagged.Tagged s a) t
instance (t GHC.Types.~ GHC.IO.Exception.AssertionFailed) => Control.Lens.Wrapped.Rewrapped GHC.IO.Exception.AssertionFailed t
instance (t GHC.Types.~ Control.Exception.Base.NoMethodError) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.NoMethodError t
instance (t GHC.Types.~ Control.Exception.Base.PatternMatchFail) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.PatternMatchFail t
instance (t GHC.Types.~ Control.Exception.Base.RecConError) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.RecConError t
instance (t GHC.Types.~ Control.Exception.Base.RecSelError) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.RecSelError t
instance (t GHC.Types.~ Control.Exception.Base.RecUpdError) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.RecUpdError t
instance (t GHC.Types.~ GHC.Exception.ErrorCall) => Control.Lens.Wrapped.Rewrapped GHC.Exception.ErrorCall t
instance (t GHC.Types.~ Control.Exception.Base.TypeError) => Control.Lens.Wrapped.Rewrapped Control.Exception.Base.TypeError t
instance (t GHC.Types.~ GHC.IO.Exception.CompactionFailed) => Control.Lens.Wrapped.Rewrapped GHC.IO.Exception.CompactionFailed t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CChar t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CSChar t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUChar t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CShort t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUShort t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CInt t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUInt t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CLong t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CULong t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CLLong t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CULLong t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CFloat t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CDouble t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CPtrdiff t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CSize t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CWchar t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CSigAtomic t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CClock t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CTime t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUSeconds t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CSUSeconds t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CIntPtr t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUIntPtr t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CIntMax t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CUIntMax t
instance (t GHC.Types.~ GHC.Generics.Par1 p') => Control.Lens.Wrapped.Rewrapped (GHC.Generics.Par1 p) t
instance forall k1 k2 t (f' :: k1 -> *) (p' :: k1) (f :: k2 -> *) (p :: k2). (t GHC.Types.~ GHC.Generics.Rec1 f' p') => Control.Lens.Wrapped.Rewrapped (GHC.Generics.Rec1 f p) t
instance forall k1 k2 t i' c' (p' :: k1) i c (p :: k2). (t GHC.Types.~ GHC.Generics.K1 i' c' p') => Control.Lens.Wrapped.Rewrapped (GHC.Generics.K1 i c p) t
instance forall k1 k2 t i' (c' :: GHC.Generics.Meta) (f' :: k1 -> *) (p' :: k1) i (c :: GHC.Generics.Meta) (f :: k2 -> *) (p :: k2). (t GHC.Types.~ GHC.Generics.M1 i' c' f' p') => Control.Lens.Wrapped.Rewrapped (GHC.Generics.M1 i c f p) t
instance forall k4 k5 k6 k7 t (f' :: k4 -> *) (g' :: k5 -> k4) (p' :: k5) (f :: k6 -> *) (g :: k7 -> k6) (p :: k7). (t GHC.Types.~ (GHC.Generics.:.:) f' g' p') => Control.Lens.Wrapped.Rewrapped ((GHC.Generics.:.:) f g p) t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CDev t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CIno t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CMode t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.COff t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CPid t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CSsize t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CGid t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CNlink t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CUid t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CCc t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CSpeed t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CTcflag t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CRLim t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.Fd t
instance Control.Lens.Wrapped.Rewrapped Foreign.C.Types.CBool t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CBlkSize t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CBlkCnt t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CClockId t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CFsBlkCnt t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CFsFilCnt t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CId t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CKey t
instance Control.Lens.Wrapped.Rewrapped System.Posix.Types.CTimer t
instance Control.Lens.Wrapped.Wrapped Data.Semigroup.Internal.All
instance Control.Lens.Wrapped.Wrapped Data.Semigroup.Internal.Any
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Internal.Sum a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Internal.Product a)
instance Control.Lens.Wrapped.Wrapped (Control.Arrow.Kleisli m a b)
instance Control.Lens.Wrapped.Wrapped (Control.Applicative.WrappedMonad m a)
instance Control.Lens.Wrapped.Wrapped (Control.Applicative.WrappedArrow a b c)
instance Control.Lens.Wrapped.Wrapped (Control.Applicative.ZipList a)
instance Control.Lens.Wrapped.Wrapped (GHC.Base.NonEmpty a)
instance forall k a (x :: k). Control.Lens.Wrapped.Wrapped (Data.Functor.Const.Const a x)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Internal.Dual a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Internal.Endo a)
instance Control.Lens.Wrapped.Wrapped (Data.Monoid.First a)
instance Control.Lens.Wrapped.Wrapped (Data.Monoid.Last a)
instance forall k (f :: k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Data.Semigroup.Internal.Alt f a)
instance forall k (f :: k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Data.Monoid.Ap f a)
instance Control.Lens.Wrapped.Wrapped (Control.Arrow.ArrowMonad m a)
instance Control.Lens.Wrapped.Wrapped (Data.Ord.Down a)
instance Control.Lens.Wrapped.Wrapped Foreign.C.Error.Errno
instance forall k (f :: k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Control.Applicative.Backwards.Backwards f a)
instance forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). Control.Lens.Wrapped.Wrapped (Data.Functor.Compose.Compose f g a)
instance forall k a (b :: k). Control.Lens.Wrapped.Wrapped (Data.Functor.Constant.Constant a b)
instance forall k (r :: k) (m :: k -> *) a. Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Cont.ContT r m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Except.ExceptT e m a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Identity.Identity a)
instance forall k (m :: k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Identity.IdentityT m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Maybe.MaybeT m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Reader.ReaderT r m a)
instance forall k (f :: k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Data.Functor.Reverse.Reverse f a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.State.Lazy.StateT s m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.State.Strict.StateT s m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance forall k k1 k2 k3 (p :: k -> k1 -> *) (f :: k2 -> k) (g :: k3 -> k1) (a :: k2) (b :: k3). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Biff.Biff p f g a b)
instance forall k k1 (f :: k -> *) (a :: k) (b :: k1). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Clown.Clown f a b)
instance forall k (p :: * -> k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Fix.Fix p a)
instance forall k k1 (p :: k -> k1 -> *) (a :: k1) (b :: k). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Flip.Flip p a b)
instance forall k (p :: k -> k -> *) (a :: k). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Join.Join p a)
instance forall k k1 (g :: k -> *) (a :: k1) (b :: k). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Joker.Joker g a b)
instance forall k k1 k2 (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Tannen.Tannen f p a b)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). Control.Lens.Wrapped.Wrapped (Data.Bifunctor.Wrapped.WrappedBifunctor p a b)
instance Control.Lens.Wrapped.Wrapped (Control.Comonad.Trans.Traced.TracedT m w a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Catch.Pure.CatchT m a)
instance Control.Lens.Wrapped.Wrapped (Control.Alternative.Free.Alt f a)
instance Control.Lens.Wrapped.Wrapped (Control.Applicative.Trans.Free.ApT f g a)
instance Control.Lens.Wrapped.Wrapped (Control.Comonad.Trans.Cofree.CofreeT f w a)
instance Control.Lens.Wrapped.Wrapped (Control.Comonad.Trans.Coiter.CoiterT w a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Free.FreeT f m a)
instance Control.Lens.Wrapped.Wrapped (Control.Monad.Trans.Iter.IterT m a)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Control.Lens.Wrapped.Wrapped (Data.HashMap.Internal.HashMap k a)
instance (Data.Hashable.Class.Hashable a, GHC.Classes.Eq a) => Control.Lens.Wrapped.Wrapped (Data.HashSet.Internal.HashSet a)
instance Control.Lens.Wrapped.Wrapped (Data.IntMap.Internal.IntMap a)
instance Control.Lens.Wrapped.Wrapped Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord k => Control.Lens.Wrapped.Wrapped (Data.Map.Internal.Map k a)
instance GHC.Classes.Ord a => Control.Lens.Wrapped.Wrapped (Data.Set.Internal.Set a)
instance Control.Lens.Wrapped.Wrapped (Data.Sequence.Internal.Seq a)
instance forall k (f :: k -> *) d (c :: k). Control.Lens.Wrapped.Wrapped (Data.Profunctor.Types.Star f d c)
instance forall k (f :: k -> *) (d :: k) c. Control.Lens.Wrapped.Wrapped (Data.Profunctor.Types.Costar f d c)
instance forall k k1 (p :: k -> k1 -> *) (a :: k) (b :: k1). Control.Lens.Wrapped.Wrapped (Data.Profunctor.Types.WrappedArrow p a b)
instance forall k r a (b :: k). Control.Lens.Wrapped.Wrapped (Data.Profunctor.Types.Forget r a b)
instance forall k k1 k2 (f :: k -> *) (p :: k1 -> k2 -> k) (a :: k1) (b :: k2). Control.Lens.Wrapped.Wrapped (Data.Profunctor.Cayley.Cayley f p a b)
instance Control.Lens.Wrapped.Wrapped (Data.Vector.Vector a)
instance Data.Primitive.Types.Prim a => Control.Lens.Wrapped.Wrapped (Data.Vector.Primitive.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Control.Lens.Wrapped.Wrapped (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Control.Lens.Wrapped.Wrapped (Data.Vector.Storable.Vector a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Bind.Class.WrappedApplicative f a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Bind.Class.MaybeApply f a)
instance forall k1 k2 (k3 :: k1 -> k2 -> *) (a :: k1) (b :: k2). Control.Lens.Wrapped.Wrapped (Data.Semigroupoid.WrappedCategory k3 a b)
instance forall k k1 m (a :: k) (b :: k1). Control.Lens.Wrapped.Wrapped (Data.Semigroupoid.Semi m a b)
instance forall k1 k2 (k3 :: k1 -> k2 -> *) (a :: k2) (b :: k1). Control.Lens.Wrapped.Wrapped (Data.Semigroupoid.Dual.Dual k3 a b)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroupoid.Static.Static f a b)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Min a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Max a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.First a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.Last a)
instance Control.Lens.Wrapped.Wrapped (Data.Semigroup.WrappedMonoid a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Predicate a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Comparison a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Equivalence a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Op a b)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Compose.Compose f g a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Compose.ComposeFC f g a)
instance Control.Lens.Wrapped.Wrapped (Data.Functor.Contravariant.Compose.ComposeCF f g a)
instance forall k (s :: k) a. Control.Lens.Wrapped.Wrapped (Data.Tagged.Tagged s a)
instance Control.Lens.Wrapped.Wrapped GHC.IO.Exception.AssertionFailed
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.NoMethodError
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.PatternMatchFail
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.RecConError
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.RecSelError
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.RecUpdError
instance Control.Lens.Wrapped.Wrapped GHC.Exception.ErrorCall
instance Control.Lens.Wrapped.Wrapped Control.Exception.Base.TypeError
instance Control.Lens.Wrapped.Wrapped GHC.IO.Exception.CompactionFailed
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CChar
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CSChar
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUChar
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CShort
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUShort
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CInt
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUInt
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CLong
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CULong
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CLLong
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CULLong
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CFloat
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CDouble
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CPtrdiff
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CSize
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CWchar
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CSigAtomic
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CClock
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CTime
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUSeconds
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CSUSeconds
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CIntPtr
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUIntPtr
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CIntMax
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CUIntMax
instance Control.Lens.Wrapped.Wrapped (GHC.Generics.Par1 p)
instance forall k (f :: k -> *) (p :: k). Control.Lens.Wrapped.Wrapped (GHC.Generics.Rec1 f p)
instance forall k i c (p :: k). Control.Lens.Wrapped.Wrapped (GHC.Generics.K1 i c p)
instance forall k i (c :: GHC.Generics.Meta) (f :: k -> *) (p :: k). Control.Lens.Wrapped.Wrapped (GHC.Generics.M1 i c f p)
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). Control.Lens.Wrapped.Wrapped ((GHC.Generics.:.:) f g p)
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CDev
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CIno
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CMode
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.COff
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CPid
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CSsize
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CGid
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CNlink
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CUid
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CCc
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CSpeed
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CTcflag
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CRLim
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.Fd
instance Control.Lens.Wrapped.Wrapped Foreign.C.Types.CBool
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CBlkSize
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CBlkCnt
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CClockId
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CFsBlkCnt
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CFsFilCnt
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CId
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CKey
instance Control.Lens.Wrapped.Wrapped System.Posix.Types.CTimer


module Control.Lens.Internal.TH
type TyVarBndrVis = TyVarBndr_ ()

-- | Peel off a kind signature from a Type (if it has one).
unSigT :: Type -> Type
composeValName :: Name
idValName :: Name
fmapValName :: Name
pureValName :: Name
apValName :: Name

-- | Template Haskell wants type variables declared in a forall, so we find
--   all free type variables in a given type and declare them.
quantifyType :: Cxt -> Type -> Type

-- | Apply arguments to a type constructor
appsT :: TypeQ -> [TypeQ] -> TypeQ

-- | Apply arguments to a function
appsE1 :: ExpQ -> [ExpQ] -> ExpQ

-- | Construct a tuple type given a list of types.
toTupleT :: [TypeQ] -> TypeQ

-- | Construct a tuple value given a list of expressions.
toTupleE :: [ExpQ] -> ExpQ

-- | Construct a tuple pattern given a list of patterns.
toTupleP :: [PatQ] -> PatQ

-- | Apply arguments to a type constructor.
conAppsT :: Name -> [Type] -> Type

-- | Generate many new names from a given base name.
newNames :: String -> Int -> Q [Name]

-- | Decompose an applied type into its individual components. For example,
--   this:
--   
--   <pre>
--   Either Int Char
--   </pre>
--   
--   would be unfolded to this:
--   
--   <pre>
--   (<a>ConT</a> ''Either, [<a>ConT</a> ''Int, <a>ConT</a> ''Char])
--   </pre>
--   
--   This function ignores explicit parentheses and visible kind
--   applications.
unfoldType :: Type -> (Type, [Type])
datatypeTypeKinded :: DatatypeInfo -> Type

-- | In an effort to prevent users from having to enable KindSignatures
--   every time that they use lens' TH functionality, we strip off reified
--   kind annotations from when:
--   
--   <ol>
--   <li>The kind of a type does not contain any kind variables. If it
--   *does* contain kind variables, we want to preserve them so that we can
--   generate type signatures that preserve the dependency order of kind
--   and type variables. (The data types in test/T917.hs contain examples
--   where this is important.) This will require enabling <a>PolyKinds</a>,
--   but since <a>PolyKinds</a> implies <a>KindSignatures</a>, we can at
--   least accomplish two things at once.</li>
--   <li>The data type is not an instance of a data family. We make an
--   exception for data family instances, since the presence or absence of
--   a kind annotation can be the difference between typechecking or not.
--   (See T917DataFam in tests/T917.hs for an example.) Moreover, the
--   <a>TypeFamilies</a> extension implies <a>KindSignatures</a>.</li>
--   </ol>
dropSigsIfNonDataFam :: DatatypeInfo -> [Type] -> [Type]
isDataFamily :: DatatypeVariant -> Bool

-- | This function works like <a>quantifyType</a> except that it takes a
--   list of variables to exclude from quantification.
quantifyType' :: Set Name -> Cxt -> Type -> Type

-- | Convert a <a>TyVarBndr</a> into its corresponding <a>Type</a>.
tvbToType :: TyVarBndr_ flag -> Type
bndrReq :: ()
traversalTypeName :: Name
traversal'TypeName :: Name
lensTypeName :: Name
lens'TypeName :: Name
isoTypeName :: Name
iso'TypeName :: Name
getterTypeName :: Name
foldTypeName :: Name
prismTypeName :: Name
prism'TypeName :: Name
reviewTypeName :: Name
wrappedTypeName :: Name
unwrappedTypeName :: Name
rewrappedTypeName :: Name
_wrapped'ValName :: Name
isoValName :: Name
prismValName :: Name
untoValName :: Name
phantomValName :: Name
phantom2 :: (Functor f, Contravariant f) => f a -> f b
rightDataName :: Name
leftDataName :: Name
inlinePragma :: Name -> [DecQ]


module Control.Lens.Zoom

-- | This type family is used by <a>Magnify</a> to describe the common
--   effect type.
type family Magnified (m :: Type -> Type) :: Type -> Type -> Type

-- | This class allows us to use <a>magnify</a> part of the environment,
--   changing the environment supplied by many different <a>Monad</a>
--   transformers. Unlike <a>zoom</a> this can change the environment of a
--   deeply nested <a>Monad</a> transformer.
--   
--   Also, unlike <a>zoom</a>, this can be used with any valid
--   <a>Getter</a>, but cannot be used with a <a>Traversal</a> or
--   <a>Fold</a>.
class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m

-- | Run a monadic action in a larger environment than it was defined in,
--   using a <a>Getter</a>.
--   
--   This acts like <a>local</a>, but can in many cases change the type of
--   the environment as well.
--   
--   This is commonly used to lift actions in a simpler <a>Reader</a>
--   <a>Monad</a> into a <a>Monad</a> with a larger environment type.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with an environment in it:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; magnify _2 (+1)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2) $ magnify _1 Reader.ask
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2,[10..20]) $ magnify (_3._tail) Reader.ask
--   [11,12,13,14,15,16,17,18,19,20]
--   </pre>
--   
--   The type can be read as
--   
--   <pre>
--   magnify :: LensLike' (Magnified m c) a b -&gt; m c -&gt; n c
--   </pre>
--   
--   but the higher-rank constraints make it easier to apply
--   <tt>magnify</tt> to a <a>Getter</a> in highly-polymorphic code.
--   
--   <pre>
--   <a>magnify</a> :: <a>Getter</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>magnify</a> :: <a>Monoid</a> r =&gt; <a>Fold</a> s a   -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>magnify</a> :: <a>Monoid</a> w                 =&gt; <a>Getter</a> s t -&gt; <a>RWS</a> t w st c -&gt; <a>RWS</a> s w st c
--   <a>magnify</a> :: (<a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Fold</a> s a   -&gt; <a>RWS</a> a w st c -&gt; <a>RWS</a> s w st c
--   ...
--   </pre>
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
infixr 2 `magnify`

-- | This class allows us to use <a>zoom</a> in, changing the <a>State</a>
--   supplied by many different <a>Monad</a> transformers, potentially
--   quite deep in a <a>Monad</a> transformer stack.
class (MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m

-- | Run a monadic action in a larger <a>State</a> than it was defined in,
--   using a <a>Lens'</a> or <a>Traversal'</a>.
--   
--   This is commonly used to lift actions in a simpler <a>State</a>
--   <a>Monad</a> into a <a>State</a> <a>Monad</a> with a larger
--   <a>State</a> type.
--   
--   When applied to a <a>Traversal'</a> over multiple values, the actions
--   for each target are executed sequentially and the results are
--   aggregated.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with a <a>State</a> in it!
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom _1 $ use id
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState (a,b) $ zoom _1 $ id .= c
--   (c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState [(a,b),(c,d)] $ zoom traverse $ _2 %= f
--   [(a,f b),(c,f d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.runState [(a,b),(c,d)] $ zoom traverse $ _2 &lt;%= f
--   (f b &lt;&gt; f d &lt;&gt; mempty,[(a,f b),(c,f d)])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom both (use id)
--   a &lt;&gt; b
--   </pre>
--   
--   <pre>
--   <a>zoom</a> :: <a>Monad</a> m             =&gt; <a>Lens'</a> s t      -&gt; <a>StateT</a> t m a -&gt; <a>StateT</a> s m a
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>StateT</a> t m c -&gt; <a>StateT</a> s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w)             =&gt; <a>Lens'</a> s t      -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <tt>Error</tt> e)  =&gt; <a>Lens'</a> s t      -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w t m) c -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w s m) c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c, <tt>Error</tt> e) =&gt; <a>Traversal'</a> s t -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w t m) c -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w s m) c
--   ...
--   </pre>
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
infixr 2 `zoom`

-- | This type family is used by <a>Zoom</a> to describe the common effect
--   type.
type family Zoomed (m :: Type -> Type) :: Type -> Type -> Type
instance GHC.Base.Monad m => Control.Lens.Zoom.Magnify (Control.Monad.Trans.Reader.ReaderT b m) (Control.Monad.Trans.Reader.ReaderT a m) b a
instance Control.Lens.Zoom.Magnify ((->) b) ((->) a) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Lens.Zoom.Magnify (Control.Monad.Trans.RWS.Strict.RWST b w s m) (Control.Monad.Trans.RWS.Strict.RWST a w s m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Control.Lens.Zoom.Magnify (Control.Monad.Trans.RWS.Lazy.RWST b w s m) (Control.Monad.Trans.RWS.Lazy.RWST a w s m) b a
instance Control.Lens.Zoom.Magnify m n b a => Control.Lens.Zoom.Magnify (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) b a
instance GHC.Base.Monad z => Control.Lens.Zoom.Zoom (Control.Monad.Trans.State.Strict.StateT s z) (Control.Monad.Trans.State.Strict.StateT t z) s t
instance GHC.Base.Monad z => Control.Lens.Zoom.Zoom (Control.Monad.Trans.State.Lazy.StateT s z) (Control.Monad.Trans.State.Lazy.StateT t z) s t
instance Control.Lens.Zoom.Zoom m n s t => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Reader.ReaderT e m) (Control.Monad.Trans.Reader.ReaderT e n) s t
instance Control.Lens.Zoom.Zoom m n s t => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad z) => Control.Lens.Zoom.Zoom (Control.Monad.Trans.RWS.Strict.RWST r w s z) (Control.Monad.Trans.RWS.Strict.RWST r w t z) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad z) => Control.Lens.Zoom.Zoom (Control.Monad.Trans.RWS.Lazy.RWST r w s z) (Control.Monad.Trans.RWS.Lazy.RWST r w t z) s t
instance (GHC.Base.Monoid w, Control.Lens.Zoom.Zoom m n s t) => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Writer.Strict.WriterT w m) (Control.Monad.Trans.Writer.Strict.WriterT w n) s t
instance (GHC.Base.Monoid w, Control.Lens.Zoom.Zoom m n s t) => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Writer.Lazy.WriterT w m) (Control.Monad.Trans.Writer.Lazy.WriterT w n) s t
instance Control.Lens.Zoom.Zoom m n s t => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Maybe.MaybeT m) (Control.Monad.Trans.Maybe.MaybeT n) s t
instance Control.Lens.Zoom.Zoom m n s t => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Except.ExceptT e m) (Control.Monad.Trans.Except.ExceptT e n) s t
instance (GHC.Base.Functor f, Control.Lens.Zoom.Zoom m n s t) => Control.Lens.Zoom.Zoom (Control.Monad.Trans.Free.FreeT f m) (Control.Monad.Trans.Free.FreeT f n) s t


-- | Smart and naïve generic traversals given <a>Data</a> instances.
--   
--   <a>template</a>, <a>uniplate</a>, and <a>biplate</a> each build up
--   information about what types can be contained within another type to
--   speed up <a>Traversal</a>.
module Data.Data.Lens

-- | Find every occurrence of a given type <tt>a</tt> recursively that
--   doesn't require passing through something of type <tt>a</tt> using
--   <a>Data</a>, while avoiding traversal of areas that cannot contain a
--   value of type <tt>a</tt>.
--   
--   This is <a>uniplate</a> with a more liberal signature.
template :: forall s a. (Data s, Typeable a) => Traversal' s a

-- | Naïve <a>Traversal</a> using <a>Data</a>. This does not attempt to
--   optimize the traversal.
--   
--   This is primarily useful when the children are immediately obvious,
--   and for benchmarking.
tinplate :: (Data s, Typeable a) => Traversal' s a

-- | Find descendants of type <tt>a</tt> non-transitively, while avoiding
--   computation of areas that cannot contain values of type <tt>a</tt>
--   using <a>Data</a>.
--   
--   <a>uniplate</a> is a useful default definition for <a>plate</a>
uniplate :: Data a => Traversal' a a

-- | <a>biplate</a> performs like <a>template</a>, except when <tt>s ~
--   a</tt>, it returns itself and nothing else.
biplate :: forall s a. (Data s, Typeable a) => Traversal' s a

-- | This automatically constructs a <a>Traversal'</a> from an function.
--   
--   <pre>
--   &gt;&gt;&gt; (2,4) &amp; upon fst *~ 5
--   (10,4)
--   </pre>
--   
--   There are however, caveats on how this function can be used!
--   
--   First, the user supplied function must access only one field of the
--   specified type. That is to say the target must be a single element
--   that would be visited by <tt><tt>holesOnOf</tt> <a>template</a>
--   <a>uniplate</a></tt>
--   
--   Note: this even permits a number of functions to be used directly.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon head .~ 0
--   [0,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon last .~ 5
--   [1,2,3,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] ^? upon tail
--   Just [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? upon tail
--   Nothing
--   </pre>
--   
--   Accessing parents on the way down to children is okay:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; upon (tail.tail) .~ [10,20]
--   [1,2,10,20]
--   </pre>
--   
--   Second, the structure must not contain strict or unboxed fields of the
--   same type that will be visited by <a>Data</a>
--   
--   <pre>
--   <a>upon</a> :: (<a>Data</a> s, <a>Data</a> a) =&gt; (s -&gt; a) -&gt; <a>IndexedTraversal'</a> [Int] s a
--   </pre>
upon :: forall p f s a. (Indexable [Int] p, Applicative f, Data s, Data a) => (s -> a) -> p a (f a) -> s -> f s

-- | The design of <a>onceUpon'</a> doesn't allow it to search inside of
--   values of type <tt>a</tt> for other values of type <tt>a</tt>.
--   <a>upon'</a> provides this additional recursion.
--   
--   Like <a>onceUpon'</a>, <a>upon'</a> trusts the user supplied function
--   more than <a>upon</a> using it directly as the accessor. This enables
--   reading from the resulting <a>Lens</a> to be considerably faster at
--   the risk of generating an illegal lens.
--   
--   <pre>
--   &gt;&gt;&gt; upon' (tail.tail) .~ [10,20] $ [1,2,3,4]
--   [1,2,10,20]
--   </pre>
upon' :: forall s a. (Data s, Data a) => (s -> a) -> IndexedLens' [Int] s a

-- | This automatically constructs a <a>Traversal'</a> from a field
--   accessor.
--   
--   The index of the <a>Traversal</a> can be used as an offset into
--   <tt><a>elementOf</a> (<a>indexing</a> <a>template</a>)</tt> or into
--   the list returned by <tt><a>holesOf</a> <a>template</a></tt>.
--   
--   The design of <a>onceUpon</a> doesn't allow it to search inside of
--   values of type <tt>a</tt> for other values of type <tt>a</tt>.
--   <a>upon</a> provides this additional recursion, but at the expense of
--   performance.
--   
--   <pre>
--   &gt;&gt;&gt; onceUpon (tail.tail) .~ [10,20] $ [1,2,3,4] -- BAD
--   [1,10,20]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; upon (tail.tail) .~ [10,20] $ [1,2,3,4] -- GOOD
--   [1,2,10,20]
--   </pre>
--   
--   When in doubt, use <a>upon</a> instead.
onceUpon :: forall s a. (Data s, Typeable a) => (s -> a) -> IndexedTraversal' Int s a

-- | This more trusting version of <a>upon</a> uses your function directly
--   as the getter for a <a>Lens</a>.
--   
--   This means that reading from <a>upon'</a> is considerably faster than
--   <a>upon</a>.
--   
--   However, you pay for faster access in two ways:
--   
--   <ol>
--   <li>When passed an illegal field accessor, <a>upon'</a> will give you
--   a <a>Lens</a> that quietly violates the laws, unlike <a>upon</a>,
--   which will give you a legal <a>Traversal</a> that avoids modifying the
--   target.</li>
--   <li>Modifying with the lens is slightly slower, since it has to go
--   back and calculate the index after the fact.</li>
--   </ol>
--   
--   When given a legal field accessor, the index of the <a>Lens</a> can be
--   used as an offset into <tt><a>elementOf</a> (<a>indexed</a>
--   <a>template</a>)</tt> or into the list returned by <tt><a>holesOf</a>
--   <a>template</a></tt>.
--   
--   When in doubt, use <a>upon'</a> instead.
onceUpon' :: forall s a. (Data s, Typeable a) => (s -> a) -> IndexedLens' Int s a

-- | A generic applicative transformation that maps over the immediate
--   subterms.
--   
--   <a>gtraverse</a> is to <a>traverse</a> what <a>gmapM</a> is to
--   <a>mapM</a>
--   
--   This really belongs in <tt>Data.Data</tt>.
gtraverse :: (Applicative f, Data a) => (forall d. Data d => d -> f d) -> a -> f a
instance GHC.Show.Show (Data.Data.Lens.FieldException a)
instance Data.Typeable.Internal.Typeable a => GHC.Exception.Type.Exception (Data.Data.Lens.FieldException a)


-- | The name "plate" stems originally from "boilerplate", which was the
--   term used by the "Scrap Your Boilerplate" papers, and later inherited
--   by Neil Mitchell's "Uniplate".
--   
--   <a>https://www.cs.york.ac.uk/fp/darcs/uniplate/uniplate.htm</a>
--   
--   The combinators in here are designed to be compatible with and subsume
--   the <tt>uniplate</tt> API with the notion of a <a>Traversal</a>
--   replacing a <a>uniplate</a> or <a>biplate</a>.
--   
--   By implementing these combinators in terms of <a>plate</a> instead of
--   <a>uniplate</a> additional type safety is gained, as the user is no
--   longer responsible for maintaining invariants such as the number of
--   children they received.
--   
--   Note: The <tt>Biplate</tt> is <i>deliberately</i> excluded from the
--   API here, with the intention that you replace them with either
--   explicit traversals, or by using the <tt>On</tt> variants of the
--   combinators below with <a>biplate</a> from <tt>Data.Data.Lens</tt>. As
--   a design, it forced the user into too many situations where they had
--   to choose between correctness and ease of use, and it was brittle in
--   the face of competing imports.
--   
--   The sensible use of these combinators makes some simple assumptions.
--   Notably, any of the <tt>On</tt> combinators are expecting a
--   <a>Traversal</a>, <a>Setter</a> or <a>Fold</a> to play the role of the
--   <a>biplate</a> combinator, and so when the types of the contents and
--   the container match, they should be the <a>id</a> <a>Traversal</a>,
--   <a>Setter</a> or <a>Fold</a>.
--   
--   It is often beneficial to use the combinators in this module with the
--   combinators from <tt>Data.Data.Lens</tt> or <tt>GHC.Generics.Lens</tt>
--   to make it easier to automatically derive definitions for
--   <a>plate</a>, or to derive custom traversals.
module Control.Lens.Plated

-- | A <a>Plated</a> type is one where we know how to extract its immediate
--   self-similar children.
--   
--   <i>Example 1</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Expr
--     = Val <a>Int</a>
--     | Neg Expr
--     | Add Expr Expr
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> f (Neg e) = Neg <a>&lt;$&gt;</a> f e
--     <a>plate</a> f (Add a b) = Add <a>&lt;$&gt;</a> f a <a>&lt;*&gt;</a> f b
--     <a>plate</a> _ a = <a>pure</a> a
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   <i>Example 2</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Tree a
--     = Bin (Tree a) (Tree a)
--     | Tip a
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> (Tree a) where
--     <a>plate</a> f (Bin l r) = Bin <a>&lt;$&gt;</a> f l <a>&lt;*&gt;</a> f r
--     <a>plate</a> _ t = <a>pure</a> t
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Data</a> a =&gt; <a>Plated</a> (Tree a) where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   Note the big distinction between these two implementations.
--   
--   The former will only treat children directly in this tree as
--   descendents, the latter will treat trees contained in the values under
--   the tips also as descendants!
--   
--   When in doubt, pick a <a>Traversal</a> and just use the various
--   <tt>...Of</tt> combinators rather than pollute <a>Plated</a> with
--   orphan instances!
--   
--   If you want to find something unplated and non-recursive with
--   <a>biplate</a> use the <tt>...OnOf</tt> variant with <a>ignored</a>,
--   though those usecases are much better served in most cases by using
--   the existing <a>Lens</a> combinators! e.g.
--   
--   <pre>
--   <a>toListOf</a> <a>biplate</a> ≡ <a>universeOnOf</a> <a>biplate</a> <a>ignored</a>
--   </pre>
--   
--   This same ability to explicitly pass the <a>Traversal</a> in question
--   is why there is no analogue to uniplate's <tt>Biplate</tt>.
--   
--   Moreover, since we can allow custom traversals, we implement
--   reasonable defaults for polymorphic data types, that only
--   <a>traverse</a> into themselves, and <i>not</i> their polymorphic
--   arguments.
class Plated a

-- | <a>Traversal</a> of the immediate children of this structure.
--   
--   If you're using GHC 7.2 or newer and your type has a <a>Data</a>
--   instance, <a>plate</a> will default to <a>uniplate</a> and you can
--   choose to not override it with your own definition.
plate :: Plated a => Traversal' a a

-- | <a>Traversal</a> of the immediate children of this structure.
--   
--   If you're using GHC 7.2 or newer and your type has a <a>Data</a>
--   instance, <a>plate</a> will default to <a>uniplate</a> and you can
--   choose to not override it with your own definition.
plate :: (Plated a, Data a) => Traversal' a a

-- | Extract the immediate descendants of a <a>Plated</a> container.
--   
--   <pre>
--   <a>children</a> ≡ <a>toListOf</a> <a>plate</a>
--   </pre>
children :: Plated a => a -> [a]

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universe</a> (<a>rewrite</a> r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
rewrite :: Plated a => (a -> Maybe a) -> a -> a

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewriteOf l r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universeOf</a> l (<a>rewriteOf</a> l r x))
--   </pre>
--   
--   Usually <a>transformOf</a> is more appropriate, but <a>rewriteOf</a>
--   can give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
--   
--   <pre>
--   <a>rewriteOf</a> :: <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   </pre>
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b

-- | Rewrite recursively over part of a larger structure.
--   
--   <pre>
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>ASetter'</a> s a   -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t

-- | Rewrite recursively over part of a larger structure using a specified
--   <a>Setter</a>.
--   
--   <pre>
--   <a>rewriteOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t

-- | Rewrite by applying a monadic rule everywhere you can. Ensures that
--   the rule cannot be applied anywhere in the result.
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a

-- | Rewrite by applying a monadic rule everywhere you recursing with a
--   user-specified <a>Traversal</a>. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>. Ensures that the rule
--   cannot be applied anywhere in the result.
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>, using a user-specified
--   <a>Traversal</a> for recursion. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t

-- | Retrieve all of the transitive descendants of a <a>Plated</a>
--   container, including itself.
universe :: Plated a => a -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including
--   itself.
--   
--   <pre>
--   <a>universeOf</a> :: <a>Fold</a> a a -&gt; a -&gt; [a]
--   </pre>
universeOf :: Getting (Endo [a]) a a -> a -> [a]

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container retrieve them and all of their descendants, recursively.
universeOn :: Plated a => Getting (Endo [a]) s a -> s -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including itself
--   that lie in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>universeOnOf</a> l <a>ignored</a>
--   </pre>
universeOnOf :: Getting (Endo [a]) s a -> Getting (Endo [a]) a a -> s -> [a]

-- | Fold over all transitive descendants of a <a>Plated</a> container,
--   including itself.
cosmos :: Plated a => Fold a a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself.
--   
--   <pre>
--   <a>cosmosOf</a> :: <a>Fold</a> a a -&gt; <a>Fold</a> a a
--   </pre>
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container fold them and all of their descendants, recursively.
--   
--   <pre>
--   <a>cosmosOn</a> :: <a>Plated</a> a =&gt; <a>Fold</a> s a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself that lie
--   in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>cosmosOnOf</a> :: <a>Fold</a> s a -&gt; <a>Fold</a> a a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = <a>transform</a> $ \x -&gt; case x of
--     Neg (Lit i) -&gt; Lit (<a>negate</a> i)
--     _           -&gt; x
--   </pre>
transform :: Plated a => (a -> a) -> a -> a

-- | Transform every element by recursively applying a given <a>Setter</a>
--   in a bottom-up manner.
--   
--   <pre>
--   <a>transformOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; a -&gt; a
--   <a>transformOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; a -&gt; a
--   </pre>
transformOf :: ASetter a b a b -> (b -> b) -> a -> b

-- | Transform every element in the tree in a bottom-up manner over a
--   region indicated by a <a>Setter</a>.
--   
--   <pre>
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t

-- | Transform every element in a region indicated by a <a>Setter</a> by
--   recursively applying another <a>Setter</a> in a bottom-up manner.
--   
--   <pre>
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t

-- | Transform every element in the tree, in a bottom-up manner,
--   monadically.
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a

-- | Transform every element in a tree using a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; a -&gt; m a
--   </pre>
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b

-- | Transform every element in the tree in a region indicated by a
--   supplied <a>Traversal</a>, in a bottom-up manner, monadically.
--   
--   <pre>
--   <a>transformMOn</a> :: (<a>Monad</a> m, <a>Plated</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t

-- | Transform every element in a tree that lies in a region indicated by a
--   supplied <a>Traversal</a>, walking with a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOnOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively.
--   
--   <pre>
--   propUniverse x = <a>universe</a> x <a>==</a> <a>map</a> <a>pos</a> (<a>contexts</a> x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contexts</a> x]
--   </pre>
--   
--   <pre>
--   <a>contexts</a> ≡ <a>contextsOf</a> <a>plate</a>
--   </pre>
contexts :: Plated a => a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively, using a user-specified <a>Traversal</a> to
--   walk each layer.
--   
--   <pre>
--   propUniverse l x = <a>universeOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>contextsOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contextsOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>contextsOf</a> :: <a>Traversal'</a> a a -&gt; a -&gt; [<a>Context</a> a a a]
--   </pre>
contextsOf :: ATraversal' a a -> a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using <a>plate</a>.
--   
--   <pre>
--   <a>contextsOn</a> b ≡ <a>contextsOnOf</a> b <a>plate</a>
--   </pre>
--   
--   <pre>
--   <a>contextsOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using another user-supplied
--   <a>Traversal</a> to walk each layer.
--   
--   <pre>
--   <a>contextsOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]

-- | The one-level version of <a>context</a>. This extracts a list of the
--   immediate children as editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren x = <a>children</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holes</a> l x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holes</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holes</a> = <a>holesOf</a> <a>plate</a>
--   </pre>
holes :: Plated a => a -> [Pretext (->) a a a]

-- | An alias for <a>holesOf</a>, provided for consistency with the other
--   combinators.
--   
--   <pre>
--   <a>holesOn</a> ≡ <a>holesOf</a>
--   </pre>
--   
--   <pre>
--   <a>holesOn</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOn</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | Extract one level of <a>holes</a> from a container in a region
--   specified by one <a>Traversal</a>, using another.
--   
--   <pre>
--   <a>holesOnOf</a> b l ≡ <a>holesOf</a> (b <a>.</a> l)
--   </pre>
--   
--   <pre>
--   <a>holesOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>IndexedLens'</a> i a a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>IndexedTraversal'</a> i a a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>para</a> ≡ <a>paraOf</a> <a>plate</a>
--   </pre>
para :: Plated a => (a -> [r] -> r) -> a -> r

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>paraOf</a> :: <a>Fold</a> a a -&gt; (a -&gt; [r] -&gt; r) -&gt; a -&gt; r
--   </pre>
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r

-- | Compose through a plate
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
infixr 9 ...

-- | Try to apply a traversal to all transitive descendants of a
--   <a>Plated</a> container, but do not recurse through matching
--   descendants.
--   
--   <pre>
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Fold</a> s a                 -&gt; <a>Fold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedFold</a> s a          -&gt; <a>IndexedFold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Traversal</a> s s a b        -&gt; <a>Traversal</a> s s a b
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedTraversal</a> s s a b -&gt; <a>IndexedTraversal</a> s s a b
--   </pre>
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b

-- | Fold the immediate children of a <a>Plated</a> container.
--   
--   <pre>
--   <a>composOpFold</a> z c f = <a>foldrOf</a> <a>plate</a> (c <a>.</a> f) z
--   </pre>
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b

-- | The original <tt>uniplate</tt> combinator, implemented in terms of
--   <a>Plated</a> as a <a>Lens</a>.
--   
--   <pre>
--   <a>parts</a> ≡ <a>partsOf</a> <a>plate</a>
--   </pre>
--   
--   The resulting <a>Lens</a> is safer to use as it ignores
--   'over-application' and deals gracefully with under-application, but it
--   is only a proper <a>Lens</a> if you don't change the list
--   <a>length</a>!
parts :: Plated a => Lens' a [a]

-- | Implement <a>plate</a> operation for a type using its <a>Generic</a>
--   instance.
--   
--   Note: the behavior may be different than with <a>uniplate</a> in some
--   special cases. <a>gplate</a> doesn't look through other types in a
--   group of mutually recursive types.
--   
--   For example consider mutually recursive even and odd natural numbers:
--   
--   <pre>
--   &gt;&gt;&gt; data Even = Z | E Odd deriving (Show, Generic, Data); data Odd = O Even deriving (Show, Generic, Data)
--   </pre>
--   
--   Then <a>uniplate</a>, which is based on <a>Data</a>, finds all even
--   numbers less or equal than four:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Data.Lens (uniplate)
--   
--   &gt;&gt;&gt; universeOf uniplate (E (O (E (O Z))))
--   [E (O (E (O Z))),E (O Z),Z]
--   </pre>
--   
--   but <a>gplate</a> doesn't see through <tt>Odd</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universeOf gplate (E (O (E (O Z))))
--   [E (O (E (O Z)))]
--   </pre>
--   
--   If using <a>Data</a> is not an option, you can still write the
--   traversal manually. It is sometimes useful to use helper traversals
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let oddeven :: Traversal' Odd Even
--       oddeven f (O n) = O &lt;$&gt; f n
--       evenplate :: Traversal' Even Even
--       evenplate f Z     = pure Z
--       evenplate f (E n) = E &lt;$&gt; oddeven f n
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; universeOf evenplate (E (O (E (O Z))))
--   [E (O (E (O Z))),E (O Z),Z]
--   </pre>
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a

-- | Implement <a>plate</a> operation for a type using its <a>Generic1</a>
--   instance.
gplate1 :: (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)
class GPlated a g
class GPlated1 f g
instance forall k (f :: k -> *) (g :: k -> *) i (c :: GHC.Generics.Meta). Control.Lens.Plated.GPlated1 f g => Control.Lens.Plated.GPlated1 f (GHC.Generics.M1 i c g)
instance forall k (f :: k -> *) (g :: k -> *) (h :: k -> *). (Control.Lens.Plated.GPlated1 f g, Control.Lens.Plated.GPlated1 f h) => Control.Lens.Plated.GPlated1 f (g GHC.Generics.:+: h)
instance forall k (f :: k -> *) (g :: k -> *) (h :: k -> *). (Control.Lens.Plated.GPlated1 f g, Control.Lens.Plated.GPlated1 f h) => Control.Lens.Plated.GPlated1 f (g GHC.Generics.:*: h)
instance forall k (f :: k -> *) i a. Control.Lens.Plated.GPlated1 f (GHC.Generics.K1 i a)
instance Control.Lens.Plated.GPlated1 f GHC.Generics.Par1
instance forall k (f :: k -> *). Control.Lens.Plated.GPlated1 f GHC.Generics.U1
instance forall k (f :: k -> *). Control.Lens.Plated.GPlated1 f GHC.Generics.V1
instance forall k (f :: k -> *). Control.Lens.Plated.GPlated1 f (GHC.Generics.Rec1 f)
instance forall k (f :: k -> *) (g :: k -> *). Control.Lens.Plated.GPlated1 f (GHC.Generics.Rec1 g)
instance forall k1 (t :: * -> *) (f :: k1 -> *) (g :: k1 -> *). (Data.Traversable.Traversable t, Control.Lens.Plated.GPlated1 f g) => Control.Lens.Plated.GPlated1 f (t GHC.Generics.:.: g)
instance forall k (f :: k -> *) a. Control.Lens.Plated.GPlated1 f (GHC.Generics.URec a)
instance forall k a (f :: k -> *) i (c :: GHC.Generics.Meta). Control.Lens.Plated.GPlated a f => Control.Lens.Plated.GPlated a (GHC.Generics.M1 i c f)
instance forall k a (f :: k -> *) (g :: k -> *). (Control.Lens.Plated.GPlated a f, Control.Lens.Plated.GPlated a g) => Control.Lens.Plated.GPlated a (f GHC.Generics.:+: g)
instance forall k a (f :: k -> *) (g :: k -> *). (Control.Lens.Plated.GPlated a f, Control.Lens.Plated.GPlated a g) => Control.Lens.Plated.GPlated a (f GHC.Generics.:*: g)
instance Control.Lens.Plated.GPlated a (GHC.Generics.K1 i a)
instance Control.Lens.Plated.GPlated a (GHC.Generics.K1 i b)
instance Control.Lens.Plated.GPlated a GHC.Generics.U1
instance Control.Lens.Plated.GPlated a GHC.Generics.V1
instance Control.Lens.Plated.GPlated a (GHC.Generics.URec b)
instance Control.Lens.Plated.Plated [a]
instance Data.Traversable.Traversable f => Control.Lens.Plated.Plated (Control.Monad.Free.Free f a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable m) => Control.Lens.Plated.Plated (Control.Monad.Trans.Free.FreeT f m a)
instance Data.Traversable.Traversable f => Control.Lens.Plated.Plated (Control.Monad.Free.Church.F f a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable w) => Control.Lens.Plated.Plated (Control.Comonad.Trans.Cofree.CofreeT f w a)
instance Data.Traversable.Traversable f => Control.Lens.Plated.Plated (Control.Comonad.Cofree.Cofree f a)
instance Control.Lens.Plated.Plated (Data.Tree.Tree a)
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Exp
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Dec
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Con
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Type
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Stmt
instance Control.Lens.Plated.Plated Language.Haskell.TH.Syntax.Pat


module Data.HashSet.Lens

-- | This <a>Setter</a> can be used to change the type of a <a>HashSet</a>
--   by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <tt>Set</tt>,
--   but you can manipulate it by reading using <a>folded</a> and
--   reindexing it via <a>setmapped</a>.
setmapped :: (Eq j, Hashable j) => IndexPreservingSetter (HashSet i) (HashSet j) i j

-- | Construct a set from a <a>Getter</a>, <a>Fold</a>, <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: (<a>Eq</a> a, <a>Hashable</a> a) =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: <a>Hashable</a> a         =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>HashSet</a> a
--   <a>setOf</a> :: (<a>Eq</a> a, <a>Hashable</a> a) =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>HashSet</a> a
--   </pre>
setOf :: Hashable a => Getting (HashSet a) s a -> s -> HashSet a

-- | An <a>Iso</a> between a <a>HashSet</a> and a <a>HashMap</a> with unit
--   values. &lt;math&gt;.
hashMap :: Iso' (HashSet a) (HashMap a ())


-- | Traversals for manipulating parts of a list.
--   
--   Additional optics for manipulating lists are present more generically
--   in this package.
--   
--   The <a>Ixed</a> class allows traversing the element at a specific list
--   index.
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 4
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 4 .~ 2
--   [0,1,2,3,2,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 14
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 14 .~ 2
--   [0,1,2,3,4,5]
--   </pre>
--   
--   The <a>Cons</a> and <a>AsEmpty</a> classes provide <a>Prism</a>s for
--   list constructors.
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^? _Cons
--   Just (1,[2,3,4,5,6,7,8,9,10])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Cons
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Empty
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Cons # (1, _Empty # ()) :: [Int]
--   [1]
--   </pre>
--   
--   Additionally, <a>Snoc</a> provides a <a>Prism</a> for accessing the
--   end of a list. Note that this <a>Prism</a> always will need to
--   traverse the whole list.
--   
--   <pre>
--   &gt;&gt;&gt; [1..5] ^? _Snoc
--   Just ([1,2,3,4],5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Snoc # ([1,2],5)
--   [1,2,5]
--   </pre>
--   
--   An instance of <a>Plated</a> allows for finding locations in the list
--   where a traversal matches.
--   
--   <pre>
--   &gt;&gt;&gt; [Nothing, Just 7, Just 3, Nothing] &amp; deep (ix 0 . _Just) +~ 10
--   [Nothing,Just 17,Just 3,Nothing]
--   </pre>
--   
--   An instance of <a>Reversing</a> provides an <a>Iso</a> between a list
--   and its reverse.
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; reversed %~ ('d':)
--   "lived"
--   </pre>
--   
--   It's possible to work under a prefix or suffix of a list using
--   <a>Prefixed</a> and <a>Suffixed</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
--   
--   At present, <a>Data.List.Lens</a> re-exports <a>Prefixed</a> and
--   <a>Suffixed</a> for backwards compatibility, as <a>prefixed</a> and
--   <a>suffixed</a> used to be top-level functions defined in this module.
--   This may change in a future major release of <tt>lens</tt>.
--   
--   Finally, it's possible to traverse, fold over, and map over
--   index-value pairs thanks to instances of <a>TraversableWithIndex</a>,
--   <a>FoldableWithIndex</a>, and <a>FunctorWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; imap (,) "Hello"
--   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap replicate "Hello"
--   "ellllloooo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverse_ (curry print) "Hello"
--   (0,'H')
--   (1,'e')
--   (2,'l')
--   (3,'l')
--   (4,'o')
--   </pre>
module Data.List.Lens
class Prefixed t

-- | A <a>Prism</a> stripping a prefix from a sequence when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Prefixed t => t -> Prism' t t
class Suffixed t

-- | A <a>Prism</a> stripping a suffix from a sequence when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Suffixed t => t -> Prism' t t

-- | &lt;math&gt;. The <a>stripSuffix</a> function drops the given suffix
--   from a list. It returns <a>Nothing</a> if the list did not end with
--   the suffix given, or <a>Just</a> the list after the suffix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "bar" "foobar"
--   Just "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "bar" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripSuffix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]


-- | One of most commonly-asked questions about this package is whether it
--   provides lenses for working with <a>Map</a>. It does, but their uses
--   are perhaps obscured by their genericity. This module exists to
--   provide documentation for them.
--   
--   <a>Map</a> is an instance of <a>At</a>, so we have a lenses on values
--   at keys:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1, "world")] ^.at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 .~ Just "world" $ Map.empty
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 0 ?~ "hello" $ Map.empty
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in a
--   <a>Map</a>, thanks to its <a>TraversableWithIndex</a>,
--   <a>FoldableWithIndex</a>, and <a>FunctorWithIndex</a> instances.
--   
--   <pre>
--   &gt;&gt;&gt; imap const $ Map.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap (\i _ -&gt; Sum i) $ Map.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverse_ (curry print) $ Map.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoList $ Map.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; ix 2 %~ ("New " ++) $ Map.fromList [(2, "Earth")]
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) $ Map.empty
--   Nothing
--   </pre>
--   
--   Additionally, <a>Map</a> has <a>TraverseMin</a> and <a>TraverseMax</a>
--   instances, which let us traverse over the value at the least and
--   greatest keys, respectively.
--   
--   <pre>
--   &gt;&gt;&gt; preview traverseMin $ Map.fromList [(5, "Saturn"), (6, "Uranus")]
--   Just "Saturn"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview traverseMax $ Map.fromList [(5, "Saturn"), (6, "Uranus")]
--   Just "Uranus"
--   </pre>
module Data.Map.Lens

-- | Construct a map from a <tt>IndexedGetter</tt>, <a>IndexedFold</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a>
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurrences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf folded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded . ifolded) [('a',"alpha"),('b', "beta")]
--   fromList [('a',"alpha"),('b',"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded &lt;.&gt; folded) ["foo", "bar"]
--   fromList [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded $ Map.fromList [('a', "hello"), ('b', "world")]
--   fromList [('a',"hello"),('b',"world")]
--   </pre>
--   
--   <pre>
--   <a>toMapOf</a> ::          <tt>IndexedGetter</tt> i s a     -&gt; s -&gt; <a>Map</a> i a
--   <a>toMapOf</a> :: <a>Ord</a> i =&gt; <tt>IndexedFold</tt> i s a       -&gt; s -&gt; <a>Map</a> i a
--   <a>toMapOf</a> ::          <tt>IndexedLens'</tt> i s a      -&gt; s -&gt; <a>Map</a> i a
--   <a>toMapOf</a> :: <a>Ord</a> i =&gt; <tt>IndexedTraversal'</tt> i s a -&gt; s -&gt; <a>Map</a> i a
--   </pre>
toMapOf :: IndexedGetting i (Map i a) s a -> s -> Map i a


module Data.Set.Lens

-- | This <a>Setter</a> can be used to change the type of a <a>Set</a> by
--   mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <a>Set</a>, but
--   you can manipulate it by reading using <a>folded</a> and reindexing it
--   via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (Set.fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Ord j => IndexPreservingSetter (Set i) (Set j) i j

-- | Construct a set from a <a>Getter</a>, <a>Fold</a>, <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>setOf</a> ::          <a>Getter</a> s a     -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> ::          <a>Iso'</a> s a       -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> ::          <a>Lens'</a> s a      -&gt; s -&gt; <a>Set</a> a
--   <a>setOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Set</a> a
--   </pre>
setOf :: Getting (Set a) s a -> s -> Set a


module Data.Text.Lazy.Lens

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>from</a> <a>packed</a>
--   <a>packed</a> ≡ <a>from</a> <a>unpacked</a>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.unpacked -- :: String
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>from</a> <a>unpacked</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>from</a> <a>packed</a>
--   </pre>
unpacked :: Iso' Text String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>(<a>#</a>)</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" -- :: Text
--   "hello"
--   </pre>
_Text :: Iso' Text String

-- | Traverse the individual characters in a <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='c') "chello"
--   True
--   </pre>
--   
--   <pre>
--   <a>text</a> = <a>unpacked</a> . <a>traversed</a>
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <tt>each</tt>.
--   
--   <pre>
--   <a>text</a> ≡ <tt>each</tt>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
text :: IndexedTraversal' Int Text Char

-- | Convert between lazy <a>Text</a> and <a>Builder</a> .
--   
--   <pre>
--   <tt>fromLazyText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   <tt>toLazyText</tt> x ≡ x <a>^.</a> <a>from</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Encode/Decode a lazy <a>Text</a> to/from lazy <a>ByteString</a>, via
--   UTF-8.
--   
--   Note: This function does not decode lazily, as it must consume the
--   entire input before deciding whether or not it fails.
--   
--   <pre>
--   &gt;&gt;&gt; ByteString.unpack (utf8 # "☃")
--   [226,152,131]
--   </pre>
utf8 :: Prism' ByteString Text
pattern Text :: String -> Text


module Data.Text.Strict.Lens

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packed -- :: Text
--   "hello"
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>from</a> <a>packed</a>
--   <a>packed</a> ≡ <a>from</a> <a>unpacked</a>
--   <a>packed</a> ≡ <a>iso</a> <tt>pack</tt> <tt>unpack</tt>
--   </pre>
packed :: Iso' String Text

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   lazy <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.unpacked -- :: String
--   "hello"
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>from</a> <a>unpacked</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <a>unpacked</a> ≡ <a>iso</a> <tt>unpack</tt> <tt>pack</tt>
--   </pre>
unpacked :: Iso' Text String

-- | Convert between strict <a>Text</a> and <a>Builder</a> .
--   
--   <pre>
--   <tt>fromText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   <a>toStrict</a> (<tt>toLazyText</tt> x) ≡ x <a>^.</a> <a>from</a> <a>builder</a>
--   </pre>
builder :: Iso' Text Builder

-- | Traverse the individual characters in strict <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf text (=='o') "hello"
--   True
--   </pre>
--   
--   When the type is unambiguous, you can also use the more general
--   <tt>each</tt>.
--   
--   <pre>
--   <a>text</a> ≡ <a>unpacked</a> . <a>traversed</a>
--   <a>text</a> ≡ <tt>each</tt>
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
text :: IndexedTraversal' Int Text Char

-- | Encode/Decode a strict <a>Text</a> to/from strict <a>ByteString</a>,
--   via UTF-8.
--   
--   <pre>
--   &gt;&gt;&gt; utf8 # "☃"
--   "\226\152\131"
--   </pre>
utf8 :: Prism' ByteString Text

-- | This is an alias for <a>unpacked</a> that makes it more obvious how to
--   use it with <a>#</a>
--   
--   <pre>
--   &gt; _Text # "hello" -- :: Text
--   </pre>
--   
--   "hello"
_Text :: Iso' Text String
pattern Text :: String -> Text


module Data.Text.Lens

-- | Traversals for strict or lazy <a>Text</a>
class IsText t

-- | This isomorphism can be used to <tt>pack</tt> (or <tt>unpack</tt>)
--   strict or lazy <a>Text</a>.
--   
--   <pre>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>packed</a>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>from</a> <a>packed</a>
--   <a>packed</a> ≡ <a>from</a> <a>unpacked</a>
--   </pre>
packed :: IsText t => Iso' String t

-- | Convert between strict or lazy <a>Text</a> and a <a>Builder</a>.
--   
--   <pre>
--   <tt>fromText</tt> x ≡ x <a>^.</a> <a>builder</a>
--   </pre>
builder :: IsText t => Iso' t Builder

-- | Traverse the individual characters in strict or lazy <a>Text</a>.
--   
--   <pre>
--   <a>text</a> = <a>unpacked</a> . <a>traversed</a>
--   </pre>
text :: IsText t => IndexedTraversal' Int t Char

-- | This isomorphism can be used to <tt>unpack</tt> (or <tt>pack</tt>)
--   both strict or lazy <a>Text</a>.
--   
--   <pre>
--   <tt>unpack</tt> x ≡ x <a>^.</a> <a>unpacked</a>
--   <tt>pack</tt> x ≡ x <a>^.</a> <a>from</a> <a>unpacked</a>
--   </pre>
--   
--   This <a>Iso</a> is provided for notational convenience rather than out
--   of great need, since
--   
--   <pre>
--   <a>unpacked</a> ≡ <a>from</a> <a>packed</a>
--   </pre>
unpacked :: IsText t => Iso' t String

-- | This is an alias for <a>unpacked</a> that makes it clearer how to use
--   it with <tt>(<a>#</a>)</tt>.
--   
--   <pre>
--   <a>_Text</a> = <a>from</a> <a>packed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Text # "hello" :: Strict.Text
--   "hello"
--   </pre>
_Text :: IsText t => Iso' t String
pattern Text :: IsText s => String -> s
instance Data.Text.Lens.IsText GHC.Base.String
instance Data.Text.Lens.IsText Data.Text.Internal.Text
instance Data.Text.Lens.IsText Data.Text.Internal.Lazy.Text


-- | This module provides lenses and traversals for working with generic
--   vectors.
module Data.Vector.Generic.Lens

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (toVectorOf both (8,15) :: Vector.Vector Int) == Vector.fromList [8,15]
--   True
--   </pre>
toVectorOf :: Vector v a => Getting (Endo [a]) s a -> s -> v a

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: Vector v a => Iso' (v a) (v a)

-- | Convert a list to a <a>Vector</a> (or back.)
--   
--   <pre>
--   &gt;&gt;&gt; ([1,2,3] ^. vector :: Vector.Vector Int) == Vector.fromList [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. from vector
--   [0,8,15]
--   </pre>
vector :: (Vector v a, Vector v b) => Iso [a] [b] (v a) (v b)

-- | Convert a <a>Vector</a> to a finite <a>Bundle</a> (or back.)
asStream :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)

-- | Convert a <a>Vector</a> to a finite <a>Bundle</a> from right to left
--   (or back.)
asStreamR :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)

-- | Convert a <a>Vector</a> back and forth to an initializer that when run
--   produces a copy of the <a>Vector</a>.
cloned :: Vector v a => Iso' (v a) (New v a)

-- | Different vector implementations are isomorphic to each other.
converted :: (Vector v a, Vector w a, Vector v b, Vector w b) => Iso (v a) (v b) (w a) (w b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5 == Vector.fromList [3,4,5,6,7]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList [1..10] &amp; sliced 2 5 . mapped .~ 0) == Vector.fromList [1,2,0,0,0,0,0,8,9,10]
--   True
--   </pre>
sliced :: Vector v a => Int -> Int -> Lens' (v a) (v a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: Vector v a => [Int] -> IndexedTraversal' Int (v a) a

-- | Like <tt>ix</tt> but polymorphic in the vector type.
vectorIx :: Vector v a => Int -> Traversal' (v a) a

-- | Indexed vector traversal for a generic vector.
vectorTraverse :: (Vector v a, Vector w b) => IndexedTraversal Int (v a) (w b) a b


module Control.Lens.Each

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   Notably, when applied to a tuple, this generalizes <a>both</a> to
--   arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; each *~ 10
--   (10,20,30)
--   </pre>
--   
--   It can also be used on monomorphic containers like <a>Text</a> or
--   <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over each Char.toUpper ("hello"^.Text.packed)
--   "HELLO"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; each.each %~ Char.toUpper
--   ("HELLO","WORLD")
--   </pre>
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s
each :: Each s t a b => Traversal s t a b
each :: (Each s t a b, Traversable g, s ~ g a, t ~ g b) => Traversal s t a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (a, a') (b, b') a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, b GHC.Types.~ b2, b GHC.Types.~ b3) => Control.Lens.Each.Each (a, a2, a3) (b, b2, b3) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4) => Control.Lens.Each.Each (a, a2, a3, a4) (b, b2, b3, b4) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5) => Control.Lens.Each.Each (a, a2, a3, a4, a5) (b, b2, b3, b4, b5) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6) => Control.Lens.Each.Each (a, a2, a3, a4, a5, a6) (b, b2, b3, b4, b5, b6) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7) => Control.Lens.Each.Each (a, a2, a3, a4, a5, a6, a7) (b, b2, b3, b4, b5, b6, b7) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7, b GHC.Types.~ b8) => Control.Lens.Each.Each (a, a2, a3, a4, a5, a6, a7, a8) (b, b2, b3, b4, b5, b6, b7, b8) a b
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8, a GHC.Types.~ a9, b GHC.Types.~ b2, b GHC.Types.~ b3, b GHC.Types.~ b4, b GHC.Types.~ b5, b GHC.Types.~ b6, b GHC.Types.~ b7, b GHC.Types.~ b8, b GHC.Types.~ b9) => Control.Lens.Each.Each (a, a2, a3, a4, a5, a6, a7, a8, a9) (b, b2, b3, b4, b5, b6, b7, b8, b9) a b
instance Control.Lens.Each.Each (Data.Complex.Complex a) (Data.Complex.Complex b) a b
instance (c GHC.Types.~ d) => Control.Lens.Each.Each (Data.Map.Internal.Map c a) (Data.Map.Internal.Map d b) a b
instance Control.Lens.Each.Each (Data.IntMap.Internal.IntMap a) (Data.IntMap.Internal.IntMap b) a b
instance (c GHC.Types.~ d) => Control.Lens.Each.Each (Data.HashMap.Internal.HashMap c a) (Data.HashMap.Internal.HashMap d b) a b
instance Control.Lens.Each.Each [a] [b] a b
instance Control.Lens.Each.Each (GHC.Base.NonEmpty a) (GHC.Base.NonEmpty b) a b
instance Control.Lens.Each.Each (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance Control.Lens.Each.Each (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe b) a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (Data.Either.Either a a') (Data.Either.Either b b') a b
instance Control.Lens.Each.Each (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Control.Lens.Each.Each (Data.Tree.Tree a) (Data.Tree.Tree b) a b
instance Control.Lens.Each.Each (Data.Vector.Vector a) (Data.Vector.Vector b) a b
instance (Data.Primitive.Types.Prim a, Data.Primitive.Types.Prim b) => Control.Lens.Each.Each (Data.Vector.Primitive.Vector a) (Data.Vector.Primitive.Vector b) a b
instance (Foreign.Storable.Storable a, Foreign.Storable.Storable b) => Control.Lens.Each.Each (Data.Vector.Storable.Vector a) (Data.Vector.Storable.Vector b) a b
instance (Data.Vector.Unboxed.Base.Unbox a, Data.Vector.Unboxed.Base.Unbox b) => Control.Lens.Each.Each (Data.Vector.Unboxed.Base.Vector a) (Data.Vector.Unboxed.Base.Vector b) a b
instance (a GHC.Types.~ GHC.Types.Char, b GHC.Types.~ GHC.Types.Char) => Control.Lens.Each.Each Data.Text.Internal.Text Data.Text.Internal.Text a b
instance (a GHC.Types.~ GHC.Types.Char, b GHC.Types.~ GHC.Types.Char) => Control.Lens.Each.Each Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text a b
instance (a GHC.Types.~ GHC.Word.Word8, b GHC.Types.~ GHC.Word.Word8) => Control.Lens.Each.Each Data.ByteString.Internal.Type.ByteString Data.ByteString.Internal.Type.ByteString a b
instance (a GHC.Types.~ GHC.Word.Word8, b GHC.Types.~ GHC.Word.Word8) => Control.Lens.Each.Each Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Lazy.Internal.ByteString a b
instance (GHC.Ix.Ix i, i GHC.Types.~ j) => Control.Lens.Each.Each (GHC.Arr.Array i a) (GHC.Arr.Array j b) a b
instance (GHC.Ix.Ix i, Data.Array.Base.IArray Data.Array.Base.UArray a, Data.Array.Base.IArray Data.Array.Base.UArray b, i GHC.Types.~ j) => Control.Lens.Each.Each (Data.Array.Base.UArray i a) (Data.Array.Base.UArray j b) a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (Data.Strict.Either.Either a a') (Data.Strict.Either.Either b b') a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (Data.Strict.Tuple.Pair a a') (Data.Strict.Tuple.Pair b b') a b
instance Control.Lens.Each.Each (Data.Strict.Maybe.Maybe a) (Data.Strict.Maybe.Maybe b) a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (Data.Strict.These.These a a') (Data.Strict.These.These b b') a b
instance (a GHC.Types.~ a', b GHC.Types.~ b') => Control.Lens.Each.Each (Data.These.These a a') (Data.These.These b b') a b


module Control.Lens.At

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>.</a> <a>traverse</a>
--   </pre>
class Ixed m => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^.at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <a>Array</a>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k .~ Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | An indexed version of <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^@. iat 1
--   (1,Just "world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 1 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 2 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList []
--   </pre>
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
type family Index (s :: Type) :: Type

-- | This provides a common notion of a value at an index that is shared by
--   both <a>Ixed</a> and <a>At</a>.
type family IxValue (m :: Type) :: Type

-- | Provides a simple <a>Traversal</a> lets you <a>traverse</a> the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class Ixed m

-- | <i>NB:</i> Setting the value of this <a>Traversal</a> will only set
--   the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 %~ f
--   fromList [a,b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 .~ e
--   fromList [a,b,e,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? ix 2
--   Just c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Traversal' m (IxValue m)

-- | <i>NB:</i> Setting the value of this <a>Traversal</a> will only set
--   the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 %~ f
--   fromList [a,b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 .~ e
--   fromList [a,b,e,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? ix 2
--   Just c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? ix 2
--   Nothing
--   </pre>
ix :: (Ixed m, At m) => Index m -> Traversal' m (IxValue m)

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> Traversal' m (IxValue m)

-- | An indexed version of <a>ix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 %@~ f'
--   fromList [a,b,f' 2 c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 .@~ h
--   fromList [a,b,h 2,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^@? iix 2
--   Just (2,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^@? iix 2
--   Nothing
--   </pre>
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>.
class Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool

-- | An indexed version of <a>contains</a>.
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 3
--   (3,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 5
--   (5,False)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if odd i then not x else x
--   fromList [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if even i then not x else x
--   fromList [1,2,3,4]
--   </pre>
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool
instance GHC.Classes.Eq e => Control.Lens.At.Ixed (e -> a)
instance Control.Lens.At.Ixed (GHC.Maybe.Maybe a)
instance Control.Lens.At.Ixed [a]
instance Control.Lens.At.Ixed (GHC.Base.NonEmpty a)
instance Control.Lens.At.Ixed (Data.Functor.Identity.Identity a)
instance Control.Lens.At.Ixed (Data.Tree.Tree a)
instance Control.Lens.At.Ixed (Data.Sequence.Internal.Seq a)
instance Control.Lens.At.Ixed (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Control.Lens.At.Ixed (Data.Map.Internal.Map k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.Ixed (Data.HashMap.Internal.HashMap k a)
instance GHC.Classes.Ord k => Control.Lens.At.Ixed (Data.Set.Internal.Set k)
instance Control.Lens.At.Ixed Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.Ixed (Data.HashSet.Internal.HashSet k)
instance GHC.Ix.Ix i => Control.Lens.At.Ixed (GHC.Arr.Array i e)
instance (Data.Array.Base.IArray Data.Array.Base.UArray e, GHC.Ix.Ix i) => Control.Lens.At.Ixed (Data.Array.Base.UArray i e)
instance Control.Lens.At.Ixed (Data.Vector.Vector a)
instance Data.Primitive.Types.Prim a => Control.Lens.At.Ixed (Data.Vector.Primitive.Vector a)
instance Foreign.Storable.Storable a => Control.Lens.At.Ixed (Data.Vector.Storable.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Control.Lens.At.Ixed (Data.Vector.Unboxed.Base.Vector a)
instance Control.Lens.At.Ixed Data.Text.Internal.Text
instance Control.Lens.At.Ixed Data.Text.Internal.Lazy.Text
instance Control.Lens.At.Ixed Data.ByteString.Internal.Type.ByteString
instance Control.Lens.At.Ixed Data.ByteString.Lazy.Internal.ByteString
instance Control.Lens.At.At (GHC.Maybe.Maybe a)
instance Control.Lens.At.At (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Control.Lens.At.At (Data.Map.Internal.Map k a)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.At (Data.HashMap.Internal.HashMap k a)
instance Control.Lens.At.At Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord k => Control.Lens.At.At (Data.Set.Internal.Set k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Control.Lens.At.At (Data.HashSet.Internal.HashSet k)
instance (a GHC.Types.~ a2) => Control.Lens.At.Ixed (a, a2)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3) => Control.Lens.At.Ixed (a, a2, a3)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4) => Control.Lens.At.Ixed (a, a2, a3, a4)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5) => Control.Lens.At.Ixed (a, a2, a3, a4, a5)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6) => Control.Lens.At.Ixed (a, a2, a3, a4, a5, a6)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7) => Control.Lens.At.Ixed (a, a2, a3, a4, a5, a6, a7)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8) => Control.Lens.At.Ixed (a, a2, a3, a4, a5, a6, a7, a8)
instance (a GHC.Types.~ a2, a GHC.Types.~ a3, a GHC.Types.~ a4, a GHC.Types.~ a5, a GHC.Types.~ a6, a GHC.Types.~ a7, a GHC.Types.~ a8, a GHC.Types.~ a9) => Control.Lens.At.Ixed (a, a2, a3, a4, a5, a6, a7, a8, a9)
instance Control.Lens.At.Contains Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord a => Control.Lens.At.Contains (Data.Set.Internal.Set a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Control.Lens.At.Contains (Data.HashSet.Internal.HashSet a)


-- | Lenses, Prisms, and Traversals for working with Template Haskell.
--   
--   Beware that the API offered in this module is subject to change, as it
--   mirrors the API exposed by the <tt>template-haskell</tt> package,
--   which frequently changes between different releases of GHC. An effort
--   is made to identify the functions in this module which have different
--   type signatures when compiled with different versions of
--   <tt>template-haskell</tt>.
module Language.Haskell.TH.Lens

-- | Has a <a>Name</a>
class HasName t

-- | Extract (or modify) the <a>Name</a> of something
name :: HasName t => Lens' t Name

-- | Contains some amount of <a>Type</a>s inside
class HasTypes t

-- | Traverse all the types
types :: HasTypes t => Traversal' t Type

-- | Provides for the extraction of free type variables, and alpha
--   renaming.
class HasTypeVars t

-- | When performing substitution into this traversal you're not allowed to
--   substitute in a name that is bound internally or you'll violate the
--   <a>Traversal</a> laws, when in doubt generate your names with
--   <a>newName</a>.
typeVarsEx :: HasTypeVars t => Set Name -> Traversal' t Name

-- | Provides substitution for types
class SubstType t

-- | Perform substitution for types
substType :: SubstType t => Map Name Type -> t -> t

-- | Traverse <i>free</i> type variables
typeVars :: HasTypeVars t => Traversal' t Name

-- | Substitute using a map of names in for <i>free</i> type variables
substTypeVars :: HasTypeVars t => Map Name Name -> t -> t

-- | Provides a <a>Traversal</a> of the types of each field of a
--   constructor.
conFields :: Traversal' Con BangType

-- | <a>Traversal</a> of the types of the <i>named</i> fields of a
--   constructor.
conNamedFields :: Traversal' Con VarBangType
locFileName :: Lens' Loc String
locPackage :: Lens' Loc String
locModule :: Lens' Loc String
locStart :: Lens' Loc CharPos
locEnd :: Lens' Loc CharPos
funDepInputs :: Lens' FunDep [Name]
funDepOutputs :: Lens' FunDep [Name]
matchPattern :: Lens' Match Pat
matchBody :: Lens' Match Body
matchDeclarations :: Lens' Match [Dec]
fixityPrecedence :: Lens' Fixity Int
fixityDirection :: Lens' Fixity FixityDirection
clausePattern :: Lens' Clause [Pat]
clauseBody :: Lens' Clause Body
clauseDecs :: Lens' Clause [Dec]
fieldExpName :: Lens' FieldExp Name
fieldExpExpression :: Lens' FieldExp Exp
fieldPatName :: Lens' FieldPat Name
fieldPatPattern :: Lens' FieldPat Pat
tySynEqnLHS :: Lens' TySynEqn Type
tySynEqnPatterns :: Lens' TySynEqn [Type]
tySynEqnResult :: Lens' TySynEqn Type
injectivityAnnOutput :: Lens' InjectivityAnn Name
injectivityAnnInputs :: Lens' InjectivityAnn [Name]
typeFamilyHeadName :: Lens' TypeFamilyHead Name
typeFamilyHeadTyVarBndrs :: Lens' TypeFamilyHead [TyVarBndrVis]
typeFamilyHeadResultSig :: Lens' TypeFamilyHead FamilyResultSig
typeFamilyHeadInjectivityAnn :: Lens' TypeFamilyHead (Maybe InjectivityAnn)
bangSourceUnpackedness :: Lens' Bang SourceUnpackedness
bangSourceStrictness :: Lens' Bang SourceStrictness
derivClauseStrategy :: Lens' DerivClause (Maybe DerivStrategy)
derivClauseCxt :: Lens' DerivClause Cxt
_ClassI :: Prism' Info (Dec, [InstanceDec])
_ClassOpI :: Prism' Info (Name, Type, ParentName)
_TyConI :: Prism' Info Dec
_FamilyI :: Prism' Info (Dec, [InstanceDec])
_PrimTyConI :: Prism' Info (Name, Arity, Unlifted)
_DataConI :: Prism' Info (Name, Type, ParentName)
_VarI :: Prism' Info (Name, Type, Maybe Dec)
_TyVarI :: Prism' Info (Name, Type)
_PatSynI :: Prism' Info (Name, PatSynType)
_FunD :: Prism' Dec (Name, [Clause])
_ValD :: Prism' Dec (Pat, Body, [Dec])

-- | <pre>
--   _DataD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>TyVarBndrUnit</a>], <a>Maybe</a> <a>Kind</a>, [<a>Con</a>], [<a>DerivClause</a>]) -- template-haskell-2.12+
--   _DataD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],          <a>Maybe</a> <a>Kind</a>, [<a>Con</a>], <a>Cxt</a>)           -- Earlier versions
--   </pre>
_DataD :: DataPrism' [TyVarBndrVis] [Con]

-- | <pre>
--   _NewtypeD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>TyVarBndrUnit</a>], <a>Maybe</a> <a>Kind</a>, <a>Con</a>, [<a>DerivClause</a>]) -- template-haskell-2.12+
--   _NewtypeD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],          <a>Maybe</a> <a>Kind</a>, <a>Con</a>, <a>Cxt</a>)           -- Earlier versions
--   </pre>
_NewtypeD :: DataPrism' [TyVarBndrVis] Con
_TySynD :: Prism' Dec (Name, [TyVarBndrVis], Type)
_ClassD :: Prism' Dec (Cxt, Name, [TyVarBndrVis], [FunDep], [Dec])
_InstanceD :: Prism' Dec (Maybe Overlap, Cxt, Type, [Dec])
_SigD :: Prism' Dec (Name, Type)
_ForeignD :: Prism' Dec Foreign
_InfixD :: Prism' Dec (Fixity, Name)
_PragmaD :: Prism' Dec Pragma

-- | <pre>
--   _DataInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Maybe</a> [<a>TyVarBndrUnit</a>], <a>Type</a>, <a>Maybe</a> <a>Kind</a>, [<a>Con</a>], [<a>DerivClause</a>]) -- template-haskell-2.15+
--   _DataInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],                <a>Maybe</a> <a>Kind</a>, [<a>Con</a>], [<a>DerivClause</a>]) -- template-haskell-2.12 through 2.14
--   _DataInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],                <a>Maybe</a> <a>Kind</a>, [<a>Con</a>], <a>Cxt</a>)           -- Earlier versions
--   </pre>
_DataInstD :: Prism' Dec (Cxt, Maybe [TyVarBndrUnit], Type, Maybe Kind, [Con], [DerivClause])

-- | <pre>
--   _NewtypeInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Maybe</a> [<a>TyVarBndrUnit</a>], <a>Type</a>, <a>Maybe</a> <a>Kind</a>, <a>Con</a>, [<a>DerivClause</a>]) -- template-haskell-2.15+
--   _NewtypeInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],                <a>Maybe</a> <a>Kind</a>, <a>Con</a>, [<a>DerivClause</a>]) -- template-haskell-2.12 through 2.14
--   _NewtypeInstD :: <a>Prism'</a> <a>Dec</a> (<a>Cxt</a>, <a>Name</a>, [<a>Type</a>],                <a>Maybe</a> <a>Kind</a>, <a>Con</a>, <a>Cxt</a>)           -- Earlier versions
--   </pre>
_NewtypeInstD :: Prism' Dec (Cxt, Maybe [TyVarBndrUnit], Type, Maybe Kind, Con, [DerivClause])

-- | <pre>
--   _TySynInstD :: <a>Prism'</a> <a>Dec</a> <a>TySynEqn</a>             -- template-haskell-2.15+
--   _TySynInstD :: <a>Prism'</a> <a>Dec</a> (<a>Name</a>, <a>TySynEqn</a>)     -- template-haskell-2.9 through 2.14
--   _TySynInstD :: <a>Prism'</a> <a>Dec</a> (<a>Name</a>, [<a>Type</a>], <a>Type</a>) -- Earlier versions
--   </pre>
_TySynInstD :: Prism' Dec TySynEqn
_ClosedTypeFamilyD :: Prism' Dec (TypeFamilyHead, [TySynEqn])
_RoleAnnotD :: Prism' Dec (Name, [Role])

-- | <pre>
--   _StandaloneDerivD :: <a>Prism'</a> <a>Dec</a> (<a>Maybe</a> <a>DerivStrategy</a>, <a>Cxt</a>, <a>Type</a>) -- template-haskell-2.12+
--   _StandaloneDerivD :: <a>Prism'</a> <a>Dec</a>                      (<a>Cxt</a>, <a>Type</a>) -- Earlier versions
--   </pre>
_StandaloneDerivD :: Prism' Dec (Maybe DerivStrategy, Cxt, Type)
_DefaultSigD :: Prism' Dec (Name, Type)
_DataFamilyD :: Prism' Dec (Name, [TyVarBndrVis], Maybe Kind)
_OpenTypeFamilyD :: Prism' Dec TypeFamilyHead
_PatSynD :: Prism' Dec (Name, PatSynArgs, PatSynDir, Pat)
_PatSynSigD :: Prism' Dec (Name, PatSynType)
_ImplicitParamBindD :: Prism' Dec (String, Exp)
_DefaultD :: Prism' Dec [Type]
_TypeDataD :: Prism' Dec (Name, [TyVarBndrVis], Maybe Kind, [Con])
_Unidir :: Prism' PatSynDir ()
_ImplBidir :: Prism' PatSynDir ()
_ExplBidir :: Prism' PatSynDir [Clause]
_PrefixPatSyn :: Prism' PatSynArgs [Name]
_InfixPatSyn :: Prism' PatSynArgs (Name, Name)
_RecordPatSyn :: Prism' PatSynArgs [Name]
_NormalC :: Prism' Con (Name, [BangType])
_RecC :: Prism' Con (Name, [VarBangType])
_InfixC :: Prism' Con (BangType, Name, BangType)
_ForallC :: Prism' Con ([TyVarBndrSpec], Cxt, Con)
_GadtC :: Prism' Con ([Name], [BangType], Type)
_RecGadtC :: Prism' Con ([Name], [VarBangType], Type)
_Overlappable :: Prism' Overlap ()
_Overlapping :: Prism' Overlap ()
_Overlaps :: Prism' Overlap ()
_Incoherent :: Prism' Overlap ()
_NoSourceUnpackedness :: Prism' SourceUnpackedness ()
_SourceNoUnpack :: Prism' SourceUnpackedness ()
_SourceUnpack :: Prism' SourceUnpackedness ()
_NoSourceStrictness :: Prism' SourceStrictness ()
_SourceLazy :: Prism' SourceStrictness ()
_SourceStrict :: Prism' SourceStrictness ()
_DecidedLazy :: Prism' DecidedStrictness ()
_DecidedStrict :: Prism' DecidedStrictness ()
_DecidedUnpack :: Prism' DecidedStrictness ()
_ImportF :: Prism' Foreign (Callconv, Safety, String, Name, Type)
_ExportF :: Prism' Foreign (Callconv, String, Name, Type)
_CCall :: Prism' Callconv ()
_StdCall :: Prism' Callconv ()
_CApi :: Prism' Callconv ()
_Prim :: Prism' Callconv ()
_JavaScript :: Prism' Callconv ()
_Unsafe :: Prism' Safety ()
_Safe :: Prism' Safety ()
_Interruptible :: Prism' Safety ()
_InlineP :: Prism' Pragma (Name, Inline, RuleMatch, Phases)
_SpecialiseP :: Prism' Pragma (Name, Type, Maybe Inline, Phases)
_SpecialiseInstP :: Prism' Pragma Type

-- | <pre>
--   _RuleP :: <a>Prism'</a> <a>Pragma</a> (<a>String</a>, <a>Maybe</a> [<a>TyVarBndrUnit</a>], [<a>RuleBndr</a>], <a>Exp</a>, <a>Exp</a>, <a>Phases</a>) -- template-haskell-2.15+
--   _RuleP :: <a>Prism'</a> <a>Pragma</a> (<a>String</a>,                        [<a>RuleBndr</a>], <a>Exp</a>, <a>Exp</a>, <a>Phases</a>) -- Earlier versions
--   </pre>
_RuleP :: Prism' Pragma (String, Maybe [TyVarBndrUnit], [RuleBndr], Exp, Exp, Phases)
_AnnP :: Prism' Pragma (AnnTarget, Exp)
_LineP :: Prism' Pragma (Int, String)
_CompleteP :: Prism' Pragma ([Name], Maybe Name)
_OpaqueP :: Prism' Pragma Name
_NoInline :: Prism' Inline ()
_Inline :: Prism' Inline ()
_Inlinable :: Prism' Inline ()
_ConLike :: Prism' RuleMatch ()
_FunLike :: Prism' RuleMatch ()
_AllPhases :: Prism' Phases ()
_FromPhase :: Prism' Phases Int
_BeforePhase :: Prism' Phases Int
_RuleVar :: Prism' RuleBndr Name
_TypedRuleVar :: Prism' RuleBndr (Name, Type)
_ModuleAnnotation :: Prism' AnnTarget ()
_TypeAnnotation :: Prism' AnnTarget Name
_ValueAnnotation :: Prism' AnnTarget Name
_FunDep :: Iso' FunDep ([Name], [Name])
_InfixL :: Prism' FixityDirection ()
_InfixR :: Prism' FixityDirection ()
_InfixN :: Prism' FixityDirection ()
_VarE :: Prism' Exp Name
_ConE :: Prism' Exp Name
_LitE :: Prism' Exp Lit
_AppE :: Prism' Exp (Exp, Exp)
_AppTypeE :: Prism' Exp (Exp, Type)
_InfixE :: Prism' Exp (Maybe Exp, Exp, Maybe Exp)
_UInfixE :: Prism' Exp (Exp, Exp, Exp)
_ParensE :: Prism' Exp Exp
_LamE :: Prism' Exp ([Pat], Exp)
_LamCaseE :: Prism' Exp [Match]

-- | <pre>
--   _TupE :: <a>Prism'</a> <a>Exp</a> [<a>Maybe</a> <a>Exp</a>] -- template-haskell-2.16+
--   _TupE :: <a>Prism'</a> <a>Exp</a> [<a>Exp</a>]       -- Earlier versions
--   </pre>
_TupE :: Prism' Exp [Maybe Exp]

-- | <pre>
--   _UnboxedTupE :: <a>Prism'</a> <a>Exp</a> [<a>Maybe</a> <a>Exp</a>] -- template-haskell-2.16+
--   _UnboxedTupE :: <a>Prism'</a> <a>Exp</a> [<a>Exp</a>]       -- Earlier versions
--   </pre>
_UnboxedTupE :: Prism' Exp [Maybe Exp]
_UnboxedSumE :: Prism' Exp (Exp, SumAlt, SumArity)
_CondE :: Prism' Exp (Exp, Exp, Exp)
_MultiIfE :: Prism' Exp [(Guard, Exp)]
_LetE :: Prism' Exp ([Dec], Exp)
_CaseE :: Prism' Exp (Exp, [Match])

-- | <pre>
--   _DoE :: <a>Prism'</a> <a>Exp</a> (<a>Maybe</a> <a>ModName</a>, [<a>Stmt</a>]) -- template-haskell-2.17+
--   _DoE :: <a>Prism'</a> <a>Exp</a> [<a>Stmt</a>]                  -- Earlier versions
--   </pre>
_DoE :: Prism' Exp (Maybe ModName, [Stmt])
_CompE :: Prism' Exp [Stmt]
_ArithSeqE :: Prism' Exp Range
_ListE :: Prism' Exp [Exp]
_SigE :: Prism' Exp (Exp, Type)
_RecConE :: Prism' Exp (Name, [FieldExp])
_RecUpdE :: Prism' Exp (Exp, [FieldExp])
_StaticE :: Prism' Exp Exp
_UnboundVarE :: Prism' Exp Name
_LabelE :: Prism' Exp String

-- | <pre>
--   _MDoE :: <a>Prism'</a> <a>Exp</a> (<a>Maybe</a> <a>ModName</a>, [<a>Stmt</a>]) -- template-haskell-2.17+
--   _MDoE :: <a>Prism'</a> <a>Exp</a> [<a>Stmt</a>]                  -- Earlier versions
--   </pre>
_MDoE :: Prism' Exp (Maybe ModName, [Stmt])
_ImplicitParamVarE :: Prism' Exp String
_GetFieldE :: Prism' Exp (Exp, String)
_ProjectionE :: Prism' Exp (NonEmpty String)
_LamCasesE :: Prism' Exp [Clause]
_GuardedB :: Prism' Body [(Guard, Exp)]
_NormalB :: Prism' Body Exp
_NormalG :: Prism' Guard Exp
_PatG :: Prism' Guard [Stmt]
_BindS :: Prism' Stmt (Pat, Exp)
_LetS :: Prism' Stmt [Dec]
_NoBindS :: Prism' Stmt Exp
_ParS :: Prism' Stmt [[Stmt]]
_RecS :: Prism' Stmt [Stmt]
_FromR :: Prism' Range Exp
_FromThenR :: Prism' Range (Exp, Exp)
_FromToR :: Prism' Range (Exp, Exp)
_FromThenToR :: Prism' Range (Exp, Exp, Exp)
_CharL :: Prism' Lit Char
_StringL :: Prism' Lit String
_IntegerL :: Prism' Lit Integer
_RationalL :: Prism' Lit Rational
_IntPrimL :: Prism' Lit Integer
_WordPrimL :: Prism' Lit Integer
_FloatPrimL :: Prism' Lit Rational
_DoublePrimL :: Prism' Lit Rational
_StringPrimL :: Prism' Lit [Word8]
_CharPrimL :: Prism' Lit Char
_BytesPrimL :: Prism' Lit Bytes
_LitP :: Prism' Pat Lit
_VarP :: Prism' Pat Name
_TupP :: Prism' Pat [Pat]
_UnboxedTupP :: Prism' Pat [Pat]
_UnboxedSumP :: Prism' Pat (Pat, SumAlt, SumArity)

-- | <pre>
--   _ConP :: <a>Prism'</a> <a>Pat</a> (<a>Name</a>, [<a>Type</a>], [<a>Pat</a>]) -- template-haskell-2.18+
--   _ConP :: <a>Prism'</a> <a>Pat</a> (<a>Name</a>,         [<a>Pat</a>]) -- Earlier versions
--   </pre>
_ConP :: Prism' Pat (Name, [Type], [Pat])
_InfixP :: Prism' Pat (Pat, Name, Pat)
_UInfixP :: Prism' Pat (Pat, Name, Pat)
_ParensP :: Prism' Pat Pat
_TildeP :: Prism' Pat Pat
_BangP :: Prism' Pat Pat
_AsP :: Prism' Pat (Name, Pat)
_WildP :: Prism' Pat ()
_RecP :: Prism' Pat (Name, [FieldPat])
_ListP :: Prism' Pat [Pat]
_SigP :: Prism' Pat (Pat, Type)
_ViewP :: Prism' Pat (Exp, Pat)
_ForallT :: Prism' Type ([TyVarBndrSpec], Cxt, Type)
_AppT :: Prism' Type (Type, Type)
_SigT :: Prism' Type (Type, Kind)
_VarT :: Prism' Type Name
_ConT :: Prism' Type Name
_PromotedT :: Prism' Type Name
_TupleT :: Prism' Type Int
_UnboxedTupleT :: Prism' Type Int
_UnboxedSumT :: Prism' Type SumArity
_ArrowT :: Prism' Type ()
_EqualityT :: Prism' Type ()
_ListT :: Prism' Type ()
_PromotedTupleT :: Prism' Type Int
_PromotedNilT :: Prism' Type ()
_PromotedConsT :: Prism' Type ()
_StarT :: Prism' Type ()
_ConstraintT :: Prism' Type ()
_LitT :: Prism' Type TyLit
_InfixT :: Prism' Type (Type, Name, Type)
_UInfixT :: Prism' Type (Type, Name, Type)
_ParensT :: Prism' Type Type
_WildCardT :: Prism' Type ()
_AppKindT :: Prism' Type (Type, Kind)
_ImplicitParamT :: Prism' Type (String, Type)
_ForallVisT :: Prism' Type ([TyVarBndrUnit], Type)
_MulArrowT :: Prism' Type ()
_PromotedInfixT :: Prism' Type (Type, Name, Type)
_PromotedUInfixT :: Prism' Type (Type, Name, Type)
_SpecifiedSpec :: Prism' Specificity ()
_InferredSpec :: Prism' Specificity ()

-- | <pre>
--   _PlainTV :: <a>Prism'</a> (<a>TyVarBndr</a> flag) (<a>Name</a>, flag) -- template-haskell-2.17+
--   _PlainTV :: <a>Prism'</a>  <a>TyVarBndr</a>        <a>Name</a>        -- Earlier versions
--   </pre>
_PlainTV :: Prism' (TyVarBndr flag) (Name, flag)

-- | <pre>
--   _KindedTV :: <a>Prism'</a> (<a>TyVarBndr</a> flag) (<a>Name</a>, flag, <a>Kind</a>) -- template-haskell-2.17+
--   _KindedTV :: <a>Prism'</a>  <a>TyVarBndr</a>       (<a>Name</a>,       <a>Kind</a>) -- Earlier versions
--   </pre>
_KindedTV :: Prism' (TyVarBndr flag) (Name, flag, Kind)
_NoSig :: Prism' FamilyResultSig ()
_KindSig :: Prism' FamilyResultSig Kind
_TyVarSig :: Prism' FamilyResultSig TyVarBndrUnit
_NumTyLit :: Prism' TyLit Integer
_StrTyLit :: Prism' TyLit String
_CharTyLit :: Prism' TyLit Char
_NominalR :: Prism' Role ()
_RepresentationalR :: Prism' Role ()
_PhantomR :: Prism' Role ()
_InferR :: Prism' Role ()
_StockStrategy :: Prism' DerivStrategy ()
_AnyclassStrategy :: Prism' DerivStrategy ()
_NewtypeStrategy :: Prism' DerivStrategy ()
instance Language.Haskell.TH.Lens.SubstType Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Lens.SubstType t => Language.Haskell.TH.Lens.SubstType [t]
instance Language.Haskell.TH.Lens.HasTypeVars (Language.Haskell.TH.Datatype.TyVarBndr.TyVarBndr_ flag)
instance Language.Haskell.TH.Lens.HasTypeVars Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Lens.HasTypeVars Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Lens.HasTypeVars Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Lens.HasTypeVars t => Language.Haskell.TH.Lens.HasTypeVars [t]
instance Language.Haskell.TH.Lens.HasTypeVars t => Language.Haskell.TH.Lens.HasTypeVars (GHC.Maybe.Maybe t)
instance Language.Haskell.TH.Lens.HasTypes Language.Haskell.TH.Syntax.Type
instance Language.Haskell.TH.Lens.HasTypes Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Lens.HasTypes Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Lens.HasTypes Language.Haskell.TH.Syntax.TySynEqn
instance Language.Haskell.TH.Lens.HasTypes t => Language.Haskell.TH.Lens.HasTypes [t]
instance Language.Haskell.TH.Lens.HasName (Language.Haskell.TH.Datatype.TyVarBndr.TyVarBndr_ flag)
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.Con
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.Foreign
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.RuleBndr
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.TypeFamilyHead
instance Language.Haskell.TH.Lens.HasName Language.Haskell.TH.Syntax.InjectivityAnn


module Control.Lens.Internal.PrismTH

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
--   
--   In the event that the name of a data type is also the name of one of
--   its constructors, the name of the <tt>Prism</tt> generated for the
--   data type will be prefixed with an extra <tt>_</tt> (if the data type
--   name is prefix) or <tt>.</tt> (if the name is infix) to disambiguate
--   it from the <tt>Prism</tt> for the corresponding constructor. For
--   example, this code:
--   
--   <pre>
--   data Quux = Quux Int | Fred Bool
--   makeClassyPrisms ''Quux
--   </pre>
--   
--   will create:
--   
--   <pre>
--   class AsQuux s where
--     __Quux :: Prism' s Quux -- Data type prism
--     _Quux :: Prism' s Int   -- Constructor prism
--     _Fred :: Prism' s Bool
--   
--     _Quux = __Quux . _Quux
--     _Fred = __Quux . _Fred
--   
--   instance AsQuux Quux
--   </pre>
makeClassyPrisms :: Name -> DecsQ

-- | Generate prisms for the given <a>Dec</a>
makeDecPrisms :: Bool -> Dec -> DecsQ
instance GHC.Classes.Eq Control.Lens.Internal.PrismTH.NCon
instance Language.Haskell.TH.Lens.HasTypeVars Control.Lens.Internal.PrismTH.NCon


module Control.Lens.Internal.FieldTH

-- | Rules to construct lenses for data fields.
data LensRules
LensRules :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> FieldNamer -> ClassyNamer -> LensRules
[_simpleLenses] :: LensRules -> Bool
[_generateSigs] :: LensRules -> Bool
[_generateClasses] :: LensRules -> Bool
[_allowIsos] :: LensRules -> Bool

-- | Allow Lens<i>Traversal (otherwise Getter</i>Fold)
[_allowUpdates] :: LensRules -> Bool
[_lazyPatterns] :: LensRules -> Bool
[_recordSyntax] :: LensRules -> Bool

-- | Type Name -&gt; Field Names -&gt; Target Field Name -&gt; Definition
--   Names
[_fieldToDef] :: LensRules -> FieldNamer
[_classyLenses] :: LensRules -> ClassyNamer

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of all fields (including the field being named) in the data type. [Name] -> -- | Name of the field being named. Name -> -- | Name(s) of the lens functions. If empty, no lens is created for that field. [DefName]

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definition name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of the class and the main method it generates, respectively. Maybe (Name, Name)

-- | Compute the field optics for the type identified by the given type
--   name. Lenses will be computed when possible, Traversals otherwise.
makeFieldOptics :: LensRules -> Name -> DecsQ
makeFieldOpticsForDec :: LensRules -> Dec -> DecsQ
makeFieldOpticsForDec' :: LensRules -> Dec -> HasFieldClasses [Dec]

-- | Tracks the field class <a>Name</a>s that have been created so far. We
--   consult these so that we may avoid creating duplicate classes.
type HasFieldClasses = StateT (Set Name) Q
instance GHC.Classes.Ord Control.Lens.Internal.FieldTH.DefName
instance GHC.Classes.Eq Control.Lens.Internal.FieldTH.DefName
instance GHC.Show.Show Control.Lens.Internal.FieldTH.DefName


module Control.Lens.TH

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | Derive lenses and traversals, specifying explicit pairings of
--   <tt>(fieldName, lensName)</tt>.
--   
--   If you map multiple names to the same label, and it is present in the
--   same constructor then this will generate a <a>Traversal</a>.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeLensesFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeLensesFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeLensesFor :: [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Foo = Foo { _fooX, _fooY :: <a>Int</a> }
--   <a>makeClassy</a> ''Foo
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--     fooX :: <a>Lens'</a> t <a>Int</a>
--     fooX = foo . go where go f (Foo x y) = (\x' -&gt; Foo x' y) &lt;$&gt; f x
--     fooY :: <a>Lens'</a> t <a>Int</a>
--     fooY = foo . go where go f (Foo x y) = (\y' -&gt; Foo x y') &lt;$&gt; f y
--   instance HasFoo Foo where
--     foo = id
--   </pre>
--   
--   <pre>
--   <a>makeClassy</a> = <a>makeLensesWith</a> <a>classyRules</a>
--   </pre>
makeClassy :: Name -> DecsQ

-- | Derive lenses and traversals, using a named wrapper class, and
--   specifying explicit pairings of <tt>(fieldName, traversalName)</tt>.
--   
--   Example usage:
--   
--   <pre>
--   <a>makeClassyFor</a> "HasFoo" "foo" [("_foo", "fooLens"), ("bar", "lbar")] ''Foo
--   </pre>
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments. Works the same as <a>makeClassy</a> except that
--   (a) it expects that record field names do not begin with an
--   underscore, (b) all record fields are made into lenses, and (c) the
--   resulting lens is prefixed with an underscore.
makeClassy_ :: Name -> DecsQ

-- | Generate overloaded field accessors.
--   
--   <i>e.g</i>
--   
--   <pre>
--   data Foo a = Foo { _fooX :: <a>Int</a>, _fooY :: a }
--   newtype Bar = Bar { _barX :: <a>Char</a> }
--   makeFields ''Foo
--   makeFields ''Bar
--   </pre>
--   
--   will create
--   
--   <pre>
--   _fooXLens :: Lens' (Foo a) Int
--   _fooYLens :: Lens (Foo a) (Foo b) a b
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   instance HasX (Foo a) Int where
--     x = _fooXLens
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   instance HasY (Foo a) a where
--     y = _fooYLens
--   _barXLens :: Iso' Bar Char
--   instance HasX Bar Char where
--     x = _barXLens
--   </pre>
--   
--   For details, see <a>camelCaseFields</a>.
--   
--   <pre>
--   makeFields = <a>makeLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
makeFields :: Name -> DecsQ

-- | Generate overloaded field accessors based on field names which are
--   only prefixed with an underscore (e.g. <tt>_name</tt>), not
--   additionally with the type name (e.g. <tt>_fooName</tt>).
--   
--   This might be the desired behaviour in case the
--   <tt>DuplicateRecordFields</tt> language extension is used in order to
--   get rid of the necessity to prefix each field name with the type name.
--   
--   As an example:
--   
--   <pre>
--   data Foo a  = Foo { _x :: <a>Int</a>, _y :: a }
--   newtype Bar = Bar { _x :: <a>Char</a> }
--   makeFieldsNoPrefix ''Foo
--   makeFieldsNoPrefix ''Bar
--   </pre>
--   
--   will create classes
--   
--   <pre>
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   </pre>
--   
--   together with instances
--   
--   <pre>
--   instance HasX (Foo a) Int
--   instance HasY (Foo a) a where
--   instance HasX Bar Char where
--   </pre>
--   
--   For details, see <a>classUnderscoreNoPrefixFields</a>.
--   
--   <pre>
--   makeFieldsNoPrefix = <a>makeLensesWith</a> <a>classUnderscoreNoPrefixFields</a>
--   </pre>
makeFieldsNoPrefix :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
--   
--   In the event that the name of a data type is also the name of one of
--   its constructors, the name of the <tt>Prism</tt> generated for the
--   data type will be prefixed with an extra <tt>_</tt> (if the data type
--   name is prefix) or <tt>.</tt> (if the name is infix) to disambiguate
--   it from the <tt>Prism</tt> for the corresponding constructor. For
--   example, this code:
--   
--   <pre>
--   data Quux = Quux Int | Fred Bool
--   makeClassyPrisms ''Quux
--   </pre>
--   
--   will create:
--   
--   <pre>
--   class AsQuux s where
--     __Quux :: Prism' s Quux -- Data type prism
--     _Quux :: Prism' s Int   -- Constructor prism
--     _Fred :: Prism' s Bool
--   
--     _Quux = __Quux . _Quux
--     _Fred = __Quux . _Fred
--   
--   instance AsQuux Quux
--   </pre>
makeClassyPrisms :: Name -> DecsQ

-- | Build <tt>Wrapped</tt> instance for a given newtype
makeWrapped :: Name -> DecsQ

-- | Make lenses for all records in the given declaration quote. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   fooX, fooY :: <a>Lens'</a> Foo Int
--   </pre>
declareLenses :: DecsQ -> DecsQ

-- | Similar to <a>makeLensesFor</a>, but takes a declaration quote.
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ

-- | For each record in the declaration quote, make lenses and traversals
--   for it, and create a class when the type has no arguments. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareClassy [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--   instance HasFoo Foo where foo = <a>id</a>
--   fooX, fooY :: HasFoo t =&gt; <a>Lens'</a> t <a>Int</a>
--   </pre>
declareClassy :: DecsQ -> DecsQ

-- | Similar to <a>makeClassyFor</a>, but takes a declaration quote.
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ

-- | <pre>
--   declareFields = <a>declareLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
declareFields :: DecsQ -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of each data type.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declarePrisms [d|
--     data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }
--   _Lit :: <tt>Prism'</tt> Exp Int
--   _Var :: <tt>Prism'</tt> Exp String
--   _Lambda :: <tt>Prism'</tt> Exp (String, Exp)
--   </pre>
declarePrisms :: DecsQ -> DecsQ

-- | Build <a>Wrapped</a> instance for each newtype.
declareWrapped :: DecsQ -> DecsQ

-- | Build lenses with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ

-- | Declare lenses for each records in the given declarations, using the
--   specified <a>LensRules</a>. Any record syntax in the input will be
--   stripped off.
declareLensesWith :: LensRules -> DecsQ -> DecsQ

-- | Rules to construct lenses for data fields.
data LensRules

-- | Rules for making fairly simple partial lenses, ignoring the special
--   cases for isomorphisms and traversals, and not making any classes. It
--   uses <a>underscoreNoPrefixNamer</a>.
lensRules :: LensRules

-- | Construct a <a>LensRules</a> value for generating top-level
--   definitions using the given map from field names to definition names.
lensRulesFor :: [(String, String)] -> LensRules

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a>.
classyRules :: LensRules

-- | A <a>LensRules</a> used by <a>makeClassy_</a>.
classyRules_ :: LensRules
defaultFieldRules :: LensRules

-- | Field rules for fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   <b>Note</b>: The <tt>prefix</tt> must be the same as the typename
--   (with the first letter lowercased). This is a change from lens
--   versions before lens 4.5. If you want the old behaviour, use
--   <a>makeLensesWith</a> <a>abbreviatedFields</a>
camelCaseFields :: LensRules

-- | Field rules for fields in the form <tt> _fieldname </tt> (the leading
--   underscore is mandatory).
--   
--   <b>Note</b>: The primary difference to <a>camelCaseFields</a> is that
--   for <tt>classUnderscoreNoPrefixFields</tt> the field names are not
--   expected to be prefixed with the type name. This might be the desired
--   behaviour when the <tt>DuplicateRecordFields</tt> extension is
--   enabled.
classUnderscoreNoPrefixFields :: LensRules

-- | Field rules for fields in the form <tt> _prefix_fieldname </tt>
underscoreFields :: LensRules

-- | Field rules fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   Note that <tt>prefix</tt> may be any string of characters that are not
--   uppercase letters. (In particular, it may be arbitrary string of
--   lowercase letters and numbers) This is the behavior that
--   <a>defaultFieldRules</a> had in lens 4.4 and earlier.
abbreviatedFields :: LensRules

-- | <a>Lens'</a> to access the convention for naming fields in our
--   <a>LensRules</a>.
lensField :: Lens' LensRules FieldNamer

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of all fields (including the field being named) in the data type. [Name] -> -- | Name of the field being named. Name -> -- | Name(s) of the lens functions. If empty, no lens is created for that field. [DefName]

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definition name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | <a>Lens'</a> to access the option for naming "classy" lenses.
lensClass :: Lens' LensRules ClassyNamer

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of the class and the main method it generates, respectively. Maybe (Name, Name)

-- | Generate "simple" optics even when type-changing optics are possible.
--   (e.g. <a>Lens'</a> instead of <a>Lens</a>)
simpleLenses :: Lens' LensRules Bool

-- | Create the class if the constructor is <a>Simple</a> and the
--   <a>lensClass</a> rule matches.
createClass :: Lens' LensRules Bool

-- | Indicate whether or not to supply the signatures for the generated
--   lenses.
--   
--   Disabling this can be useful if you want to provide a more restricted
--   type signature or if you want to supply hand-written haddocks.
generateSignatures :: Lens' LensRules Bool

-- | Generate "updateable" optics when <a>True</a>. When <a>False</a>,
--   <a>Fold</a>s will be generated instead of <a>Traversal</a>s and
--   <a>Getter</a>s will be generated instead of <a>Lens</a>es. This mode
--   is intended to be used for types with invariants which must be
--   maintained by "smart" constructors.
generateUpdateableOptics :: Lens' LensRules Bool

-- | Generate optics using lazy pattern matches. This can allow fields of
--   an undefined value to be initialized with lenses:
--   
--   <pre>
--   data Foo = Foo {_x :: Int, _y :: Bool}
--     deriving Show
--   
--   <a>makeLensesWith</a> (<a>lensRules</a> &amp; <a>generateLazyPatterns</a> .~ True) ''Foo
--   </pre>
--   
--   <pre>
--   &gt; undefined &amp; x .~ 8 &amp; y .~ True
--   Foo {_x = 8, _y = True}
--   </pre>
--   
--   The downside of this flag is that it can lead to space-leaks and
--   code-size/compile-time increases when generated for large records. By
--   default this flag is turned off, and strict optics are generated.
--   
--   When using lazy optics the strict optic can be recovered by composing
--   with <a>$!</a>:
--   
--   <pre>
--   strictOptic = ($!) . lazyOptic
--   </pre>
generateLazyPatterns :: Lens' LensRules Bool
generateRecordSyntax :: Lens' LensRules Bool

-- | A <a>FieldNamer</a> that strips the _ off of the field name,
--   lowercases the name, and skips the field if it doesn't start with an
--   '_'.
underscoreNoPrefixNamer :: FieldNamer

-- | Create a <a>FieldNamer</a> from explicit pairings of <tt>(fieldName,
--   lensName)</tt>.
lookingupNamer :: [(String, String)] -> FieldNamer

-- | Create a <a>FieldNamer</a> from a mapping function. If the function
--   returns <tt>[]</tt>, it creates no lens for the field.
mappingNamer :: (String -> [String]) -> FieldNamer

-- | A <a>FieldNamer</a> for <a>camelCaseFields</a>.
camelCaseNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>classUnderscoreNoPrefixFields</a>.
classUnderscoreNoPrefixNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>underscoreFields</a>.
underscoreNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>abbreviatedFields</a>.
abbreviatedNamer :: FieldNamer


-- | You can derive lenses automatically for many data types:
--   
--   <pre>
--   import Control.Lens
--   
--   data FooBar a
--     = Foo { _x :: [<a>Int</a>], _y :: a }
--     | Bar { _x :: [<a>Int</a>] }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   This defines the following lenses:
--   
--   <pre>
--   x :: <a>Lens'</a> (FooBar a) [<a>Int</a>]
--   y :: <a>Traversal</a> (FooBar a) (FooBar b) a b
--   </pre>
--   
--   You can then access the value of <tt>_x</tt> with (<a>^.</a>), the
--   value of <tt>_y</tt> – with (<a>^?</a>) or (<a>^?!</a>) (since it can
--   fail), set the values with (<a>.~</a>), modify them with (<a>%~</a>),
--   and use almost any other combinator that is re-exported here on those
--   fields.
--   
--   The combinators here have unusually specific type signatures, so for
--   particularly tricky ones, the simpler type signatures you might want
--   to pretend the combinators have are specified as well.
--   
--   More information on how to use lenses is available on the lens wiki:
--   
--   <a>http://github.com/ekmett/lens/wiki</a>
--   
module Control.Lens


-- | You can use hiding or imports to mitigate this to an extent, and the
--   following imports, represent a fair compromise for user code:
--   
--   <pre>
--   import Control.Lens hiding (Rep)
--   import GHC.Generics hiding (from, to)
--   </pre>
--   
--   You can use <a>generic</a> to replace <a>from</a> and <a>to</a> from
--   <tt>GHC.Generics</tt>, and probably won't be explicitly referencing
--   <a>Rep</a> from <tt>Control.Lens</tt> in code that uses generics.
--   
--   This module provides compatibility with older GHC versions by using
--   the <a>generic-deriving</a> package.
module GHC.Generics.Lens

-- | Convert from the data type to its representation (or back)
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.generic.from generic :: String
--   "hello"
--   </pre>
generic :: (Generic a, Generic b) => Iso a b (Rep a g) (Rep b h)

-- | Convert from the data type to its representation (or back)
generic1 :: (Generic1 f, Generic1 g) => Iso (f a) (g b) (Rep1 f a) (Rep1 g b)
_V1 :: Over p f (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism' ((f :+: g) a) (f a)

-- | You can access fields of `data (f :*: g) p` by using its <a>Field1</a>
--   and <a>Field2</a> instances.
_R1 :: Prism' ((f :+: g) a) (g a)
_UAddr :: Iso (UAddr p) (UAddr q) (Ptr c) (Ptr d)
_UChar :: Iso (UChar p) (UChar q) Char Char
_UDouble :: Iso (UDouble p) (UDouble q) Double Double
_UFloat :: Iso (UFloat p) (UFloat q) Float Float
_UInt :: Iso (UInt p) (UInt q) Int Int
_UWord :: Iso (UWord p) (UWord q) Word Word


-- | This module provides lenses and traversals for working with generic
--   vectors.
module Data.Vector.Lens

-- | Similar to <a>toListOf</a>, but returning a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toVectorOf both (8,15) == Vector.fromList [8,15]
--   True
--   </pre>
toVectorOf :: Getting (Endo [a]) s a -> s -> Vector a

-- | Convert a list to a <a>Vector</a> (or back)
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector == Vector.fromList [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. vector . from vector
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [0,8,15] ^. from vector . vector == Vector.fromList [0,8,15]
--   True
--   </pre>
vector :: Iso [a] [b] (Vector a) (Vector b)

-- | Convert a <a>Vector</a> to a version that doesn't retain any extra
--   memory.
forced :: Iso (Vector a) (Vector b) (Vector a) (Vector b)

-- | <tt>sliced i n</tt> provides a <a>Lens</a> that edits the <tt>n</tt>
--   elements starting at index <tt>i</tt> from a <a>Lens</a>.
--   
--   This is only a valid <a>Lens</a> if you do not change the length of
--   the resulting <a>Vector</a>.
--   
--   Attempting to return a longer or shorter vector will result in
--   violations of the <a>Lens</a> laws.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList [1..10] ^. sliced 2 5 == Vector.fromList [3,4,5,6,7]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList [1..10] &amp; sliced 2 5 . mapped .~ 0) == Vector.fromList [1,2,0,0,0,0,0,8,9,10]
--   True
--   </pre>
sliced :: Int -> Int -> Lens' (Vector a) (Vector a)

-- | This <a>Traversal</a> will ignore any duplicates in the supplied list
--   of indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]
--   [4,8,6,12,20,22]
--   </pre>
ordinals :: [Int] -> IndexedTraversal' Int (Vector a) a


module Data.Typeable.Lens

-- | A <a>Traversal'</a> for working with a <a>cast</a> of a
--   <a>Typeable</a> value.
_cast :: (Typeable s, Typeable a) => Traversal' s a

-- | A <a>Traversal'</a> for working with a <a>gcast</a> of a
--   <a>Typeable</a> value.
_gcast :: (Typeable s, Typeable a) => Traversal' (c s) (c a)


module Data.Tree.Lens

-- | A <a>Lens</a> that focuses on the root of a <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; view root $ Node 42 []
--   42
--   </pre>
root :: Lens' (Tree a) a

-- | A <a>Lens</a> returning the direct descendants of the root of a
--   <a>Tree</a>
--   
--   <pre>
--   <a>view</a> <a>branches</a> ≡ <a>subForest</a>
--   </pre>
branches :: Lens' (Tree a) [Tree a]


module Data.Sequence.Lens

-- | A <a>Seq</a> is isomorphic to a <a>ViewL</a>
--   
--   <pre>
--   <a>viewl</a> m ≡ m <a>^.</a> <a>viewL</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^. viewL
--   a :&lt; fromList [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewL
--   EmptyL
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyL ^. from viewL
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewL $ a Seq.:&lt; Seq.fromList [b,c]
--   fromList [a,b,c]
--   </pre>
viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)

-- | A <a>Seq</a> is isomorphic to a <a>ViewR</a>
--   
--   <pre>
--   <a>viewr</a> m ≡ m <a>^.</a> <a>viewR</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^. viewR
--   fromList [a,b] :&gt; c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewR
--   EmptyR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyR ^. from viewR
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewR $ Seq.fromList [a,b] Seq.:&gt; c
--   fromList [a,b,c]
--   </pre>
viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)

-- | Traverse all the elements numbered from <tt>i</tt> to <tt>j</tt> of a
--   <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] &amp; sliced 1 3 %~ f
--   fromList [a,f b,f c,d,e]
--   </pre>
sliced :: Int -> Int -> IndexedTraversal' Int (Seq a) a

-- | Traverse the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] ^.. slicedTo 2
--   [a,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] &amp; slicedTo 2 %~ f
--   fromList [f a,f b,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] &amp; slicedTo 10 .~ x
--   fromList [x,x,x,x,x]
--   </pre>
slicedTo :: Int -> IndexedTraversal' Int (Seq a) a

-- | Traverse all but the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] ^.. slicedFrom 2
--   [c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] &amp; slicedFrom 2 %~ f
--   fromList [a,b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d,e] &amp; slicedFrom 10 .~ x
--   fromList [a,b,c,d,e]
--   </pre>
slicedFrom :: Int -> IndexedTraversal' Int (Seq a) a

-- | Construct a <a>Seq</a> from a <a>Getter</a>, <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; seqOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; seqOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>seqOf</a> :: <a>Getter</a> s a    -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Fold</a> s a      -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Seq</a> a
--   <a>seqOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Seq</a> a
--   </pre>
seqOf :: Getting (Seq a) s a -> s -> Seq a


module Data.IntSet.Lens

-- | IntSet isn't Foldable, but this <a>Fold</a> can be used to access the
--   members of an <a>IntSet</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf members $ setOf folded [1,2,3,4]
--   10
--   </pre>
members :: Fold IntSet Int

-- | This <a>Setter</a> can be used to change the contents of an
--   <a>IntSet</a> by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for an <a>IntSet</a>,
--   because the number of elements might change but you can manipulate it
--   by reading using <a>folded</a> and reindexing it via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (IntSet.fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: IndexPreservingSetter' IntSet Int

-- | Construct an <a>IntSet</a> from a <a>Getter</a>, <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a> or <a>Iso</a>.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded [1,2,3,4]
--   fromList [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded._2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>setOf</a> :: <a>Getter</a> s <a>Int</a>     -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Fold</a> s <a>Int</a>       -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Iso'</a> s <a>Int</a>       -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Lens'</a> s <a>Int</a>      -&gt; s -&gt; <a>IntSet</a>
--   <a>setOf</a> :: <a>Traversal'</a> s <a>Int</a> -&gt; s -&gt; <a>IntSet</a>
--   </pre>
setOf :: Getting IntSet s Int -> s -> IntSet


-- | Lenses and traversals for complex numbers
module Data.Complex.Lens

-- | Access the <a>realPart</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (a :+ b)^._realPart
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a :+ b &amp; _realPart *~ 2
--   a * 2 :+ b
--   </pre>
--   
--   <pre>
--   <a>_realPart</a> :: <a>Functor</a> f =&gt; (a -&gt; f a) -&gt; <a>Complex</a> a -&gt; f (<a>Complex</a> a)
--   </pre>
_realPart :: Lens' (Complex a) a

-- | Access the <a>imagPart</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (a :+ b)^._imagPart
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a :+ b &amp; _imagPart *~ 2
--   a :+ b * 2
--   </pre>
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Functor</a> f =&gt; (a -&gt; f a) -&gt; <a>Complex</a> a -&gt; f (<a>Complex</a> a)
--   </pre>
_imagPart :: Lens' (Complex a) a

-- | This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a <a>polar</a> value with 0
--   <a>magnitude</a> and non-zero <a>phase</a> as the <a>phase</a>
--   information is lost, or with a negative <a>magnitude</a> which flips
--   the <a>phase</a> and retains a positive <a>magnitude</a>. So don't do
--   that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
_polar :: RealFloat a => Iso' (Complex a) (a, a)

-- | Access the <a>magnitude</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (10.0 :+ 20.0) &amp; _magnitude *~ 2
--   20.0 :+ 40.0
--   </pre>
--   
--   This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a negative <a>magnitude</a>. This flips
--   the <a>phase</a> and retains a positive <a>magnitude</a>. So don't do
--   that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
--   
--   Setting the <a>magnitude</a> of a zero <a>Complex</a> number assumes
--   the <a>phase</a> is 0.
_magnitude :: RealFloat a => Lens' (Complex a) a

-- | Access the <a>phase</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (mkPolar 10 (2-pi) &amp; _phase +~ pi &amp; view _phase) ≈ 2
--   True
--   </pre>
--   
--   This isn't <i>quite</i> a legal <a>Lens</a>. Notably the
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l b a) = b
--   </pre>
--   
--   law is violated when you set a <a>phase</a> outside the range
--   <tt>(-<a>pi</a>, <a>pi</a>]</tt>. The phase is always in that range
--   when queried. So don't do that!
--   
--   Otherwise, this is a perfectly cromulent <a>Lens</a>.
_phase :: RealFloat a => Lens' (Complex a) a

-- | Access the <a>conjugate</a> of a <a>Complex</a> number.
--   
--   <pre>
--   &gt;&gt;&gt; (2.0 :+ 3.0) &amp; _conjugate . _imagPart -~ 1
--   2.0 :+ 4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (mkPolar 10.0 2.0 ^. _conjugate . _phase) ≈ (-2.0)
--   True
--   </pre>
_conjugate :: RealFloat a => Iso' (Complex a) (Complex a)
pattern Polar :: RealFloat a => a -> a -> Complex a
pattern Real :: (Eq a, Num a) => a -> Complex a
pattern Imaginary :: (Eq a, Num a) => a -> Complex a
pattern Conjugate :: Num a => Complex a -> Complex a


module Data.ByteString.Strict.Lens

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>
--   
--   <pre>
--   <a>packedBytes</a> ≡ <a>from</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes
--   "hello"
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse each <a>Word8</a> in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IndexedTraversal' Int ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a> ≡ <a>from</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.each.re (base 16 . enum).to (\x -&gt; if Prelude.length x == 1 then '0':x else x)
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes.unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks the <a>ByteString</a> in a tree-like
--   fashion enable zippers to seek to locations in logarithmic time and
--   accelerating many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>.</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') "hello"
--   True
--   </pre>
chars :: IndexedTraversal' Int ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: String -> ByteString


-- | Lazy <a>ByteString</a> lenses.
module Data.ByteString.Lazy.Lens

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a
--   <a>ByteString</a>.
--   
--   <pre>
--   <a>packedBytes</a> ≡ <a>from</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes == Char8.pack "hello"
--   True
--   </pre>
packedBytes :: Iso' [Word8] ByteString

-- | <a>unpack</a> (or <a>pack</a>) a <a>ByteString</a> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.unpackedBytes
--   [104,101,108,108,111]
--   </pre>
unpackedBytes :: Iso' ByteString [Word8]

-- | Traverse the individual bytes in a <a>ByteString</a>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf bytes (== 0x80) (Char8.pack "hello")
--   False
--   </pre>
--   
--   Note that when just using this as a <a>Setter</a>, <tt><a>setting</a>
--   <a>map</a></tt> can be more efficient.
bytes :: IndexedTraversal' Int64 ByteString Word8

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a
--   <a>ByteString</a>.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>packedChars</a> ≡ <a>from</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.packedChars.each.re (base 16 . enum).to (\x -&gt; if Prelude.length x == 1 then '0':x else x)
--   "68656c6c6f"
--   </pre>
packedChars :: Iso' String ByteString

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a
--   <a>ByteString</a>
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [104,101,108,108,111]^.packedBytes.unpackedChars
--   "hello"
--   </pre>
unpackedChars :: Iso' ByteString String

-- | Traverse the individual bytes in a <a>ByteString</a> as characters.
--   
--   When writing back to the <a>ByteString</a> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks each strict <a>ByteString</a> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to:
--   
--   <pre>
--   <a>chars</a> = <a>unpackedChars</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; anyOf chars (== 'h') "hello"
--   True
--   </pre>
chars :: IndexedTraversal' Int64 ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: String -> ByteString


module Data.ByteString.Lens

-- | Traversals for ByteStrings.
class IsByteString t

-- | <a>pack</a> (or <a>unpack</a>) a list of bytes into a strict or lazy
--   <tt>ByteString</tt>.
--   
--   <pre>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedBytes</a>
--   <a>packedBytes</a> ≡ <a>from</a> <a>unpackedBytes</a>
--   </pre>
packedBytes :: IsByteString t => Iso' [Word8] t

-- | <a>pack</a> (or <a>unpack</a>) a list of characters into a strict or
--   lazy <tt>ByteString</tt>.
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>pack</a> x ≡ x <a>^.</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>from</a> <a>packedChars</a>
--   <a>packedChars</a> ≡ <a>from</a> <a>unpackedChars</a>
--   </pre>
packedChars :: IsByteString t => Iso' String t

-- | Traverse each <a>Word8</a> in a strict or lazy <tt>ByteString</tt>
--   
--   This <a>Traversal</a> walks each strict <tt>ByteString</tt> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>bytes</a> ≡ <a>unpackedBytes</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>bytes</a> (<a>==</a> 0x80) :: <tt>ByteString</tt> -&gt; <a>Bool</a>
--   </pre>
bytes :: IsByteString t => IndexedTraversal' Int t Word8

-- | Traverse the individual bytes in a strict or lazy <tt>ByteString</tt>
--   as characters.
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   This <a>Traversal</a> walks each strict <tt>ByteString</tt> chunk in a
--   tree-like fashion enable zippers to seek to locations more quickly and
--   accelerate many monoidal queries, but up to associativity (and
--   constant factors) it is equivalent to the much slower:
--   
--   <pre>
--   <a>chars</a> ≡ <a>unpackedChars</a> <a>.</a> <a>traversed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>chars</a> (<a>==</a> 'c') :: <tt>ByteString</tt> -&gt; <a>Bool</a>
--   </pre>
chars :: IsByteString t => IndexedTraversal' Int t Char

-- | <a>unpack</a> (or <a>pack</a>) a <tt>ByteString</tt> into a list of
--   bytes
--   
--   <pre>
--   <a>unpackedBytes</a> ≡ <a>from</a> <a>packedBytes</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedBytes</a>
--   <a>pack</a> x ≡  x <a>^.</a> <a>from</a> <a>unpackedBytes</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   <a>unpackedBytes</a> :: <a>Iso'</a> <a>ByteString</a> [<a>Word8</a>]
--   </pre>
unpackedBytes :: IsByteString t => Iso' t [Word8]

-- | <a>unpack</a> (or <a>pack</a>) a list of characters into a strict (or
--   lazy) <tt>ByteString</tt>
--   
--   When writing back to the <tt>ByteString</tt> it is assumed that every
--   <a>Char</a> lies between <tt>'x00'</tt> and <tt>'xff'</tt>.
--   
--   <pre>
--   <a>unpackedChars</a> ≡ <a>from</a> <a>packedChars</a>
--   <a>unpack</a> x ≡ x <a>^.</a> <a>unpackedChars</a>
--   <a>pack</a> x ≡ x <a>^.</a> <a>from</a> <a>unpackedChars</a>
--   </pre>
--   
--   <pre>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   <a>unpackedChars</a> :: <a>Iso'</a> <a>ByteString</a> <a>String</a>
--   </pre>
unpackedChars :: IsByteString t => Iso' t String
pattern Bytes :: IsByteString s => [Word8] -> s
pattern Chars :: IsByteString s => String -> s
instance Data.ByteString.Lens.IsByteString Data.ByteString.Internal.Type.ByteString
instance Data.ByteString.Lens.IsByteString Data.ByteString.Lazy.Internal.ByteString


module Data.Bits.Lens

-- | Bitwise <a>.|.</a> the target(s) of a <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .|.~ 6 $ ("hello",3)
--   ("hello",7)
--   </pre>
--   
--   <pre>
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>.|.~</a>) :: (<a>Monoid</a> a, <a>Bits</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(.|.~) :: Bits a => ASetter s t a a -> a -> s -> t
infixr 4 .|.~

-- | Bitwise <a>.&amp;.</a> the target(s) of a <a>Lens</a> or
--   <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .&amp;.~ 7 $ ("hello",254)
--   ("hello",6)
--   </pre>
--   
--   <pre>
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>.&amp;.~</a>) :: (<a>Monoid</a> a, <a>Bits</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(.&.~) :: Bits a => ASetter s t a a -> a -> s -> t
infixr 4 .&.~

-- | Bitwise <a>.|.</a> the target(s) of a <a>Lens</a> (or
--   <a>Traversal</a>), returning the result (or a monoidal summary of all
--   of the results).
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;.|.~ 6 $ ("hello",3)
--   (7,("hello",7))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.|.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.|.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<.|.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <.|.~

-- | Bitwise <a>.&amp;.</a> the target(s) of a <a>Lens</a> or
--   <a>Traversal</a>, returning the result (or a monoidal summary of all
--   of the results).
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;.&amp;.~ 7 $ ("hello",254)
--   (6,("hello",6))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Iso</a>       s t a a -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.&amp;.~</a>) :: <a>Bits</a> a             =&gt; <a>Lens</a>      s t a a -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;.&amp;.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<.&.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <.&.~

-- | Bitwise <a>.|.</a> the target(s) of a <a>Lens</a> or <a>Traversal</a>,
--   and return the original value, or a monoidal summary of the original
--   values.
--   
--   When you do not need the old value, (<a>.|.~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;.|.~ 6 $ ("hello", 3)
--   (3,("hello",7))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;.|.~</a>) ::  <a>Bits</a> a            =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.|.~</a>) ::  <a>Bits</a> a            =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.|.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<<.|.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)
infixr 4 <<.|.~

-- | Bitwise <a>.&amp;.</a> the target(s) of a <a>Lens</a> or
--   <a>Traversal</a>, and return the original value, or a monoidal summary
--   of the original values.
--   
--   When you do not need the old value, (<a>.&amp;.~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;.&amp;.~ 7 $ ("hello", 254)
--   (254,("hello",6))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;.&amp;.~</a>) ::  <a>Bits</a> a            =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.&amp;.~</a>) ::  <a>Bits</a> a            =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.&amp;.~</a>) :: (<a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; (a, t)
--   </pre>
(<<.&.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)
infixr 4 <<.&.~

-- | Modify the target(s) of a <a>Lens'</a>, <a>Setter</a> or
--   <a>Traversal</a> by computing its bitwise <a>.|.</a> with another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .|.= 15; _2 .|.= 3) (7,7)
--   (15,7)
--   </pre>
--   
--   <pre>
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(.|.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()
infix 4 .|.=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by computing its bitwise <a>.&amp;.</a> with another
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .&amp;.= 15; _2 .&amp;.= 3) (7,7)
--   (7,3)
--   </pre>
--   
--   <pre>
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(.&.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()
infix 4 .&.=

-- | Modify the target(s) of a <a>Lens'</a>, (or <a>Traversal</a>) by
--   computing its bitwise <a>.|.</a> with another value, returning the
--   result (or a monoidal summary of all of the results traversed).
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;.|.= 7) (28,0)
--   (31,(31,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <.|.=

-- | Modify the target(s) of a <a>Lens'</a> (or <a>Traversal'</a>) by
--   computing its bitwise <a>.&amp;.</a> with another value, returning the
--   result (or a monoidal summary of all of the results traversed).
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;.&amp;.= 15) (31,0)
--   (15,(15,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <.&.=

-- | Modify the target(s) of a <a>Lens'</a>, (or <a>Traversal'</a>) by
--   computing its bitwise <a>.|.</a> with another value, returning the
--   original value (or a monoidal summary of all the original values).
--   
--   When you do not need the old value, (<a>.|.=</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;&lt;.|.= 7) (28,0)
--   (28,(31,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.|.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<.|.=

-- | Modify the target(s) of a <a>Lens'</a>, (or <a>Traversal'</a>) by
--   computing its bitwise <a>.&amp;.</a> with another value, returning the
--   original value (or a monoidal summary of all the original values).
--   
--   When you do not need the old value, (<a>.&amp;.=</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;&lt;.&amp;.= 15) (31,0)
--   (31,(15,0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a)           =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.&amp;.=</a>) :: (<a>MonadState</a> s m, <a>Bits</a> a, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<.&.=

-- | This <a>Lens</a> can be used to access the value of the nth bit in a
--   number.
--   
--   <tt><a>bitAt</a> n</tt> is only a legal <a>Lens</a> into <tt>b</tt> if
--   <tt>0 <a>&lt;=</a> n <a>&lt;</a> <a>bitSize</a> (<a>undefined</a> ::
--   b)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 16^.bitAt 4
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 15^.bitAt 4
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 15 &amp; bitAt 4 .~ True
--   31
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 16 &amp; bitAt 4 .~ False
--   0
--   </pre>
bitAt :: Bits b => Int -> IndexedLens' Int b Bool

-- | Traverse over all bits in a numeric type.
--   
--   The bit position is available as the index.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf bits (5 :: Word8)
--   [True,False,True,False,False,False,False,False]
--   </pre>
--   
--   If you supply this an <a>Integer</a>, the result will be an infinite
--   <a>Traversal</a>, which can be productively consumed, but not
--   reassembled.
bits :: (Num b, Bits b) => IndexedTraversal' Int b Bool

-- | Get the nth byte, counting from the low end.
--   
--   <tt><a>byteAt</a> n</tt> is a legal <a>Lens</a> into <tt>b</tt> iff
--   <tt>0 <a>&lt;=</a> n <a>&lt;</a> <a>div</a> (<a>bitSize</a>
--   (<a>undefined</a> :: b)) 8</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (0xff00 :: Word16)^.byteAt 0
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0xff00 :: Word16)^.byteAt 1
--   255
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; byteAt 1 .~ 0 $ 0xff00 :: Word16
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; byteAt 0 .~ 0xff $ 0 :: Word16
--   255
--   </pre>
byteAt :: (Integral b, Bits b) => Int -> IndexedLens' Int b Word8

-- | Traverse over all the bytes in an integral type, from the low end.
--   
--   The byte position is available as the index.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf bytewise (1312301580 :: Word32)
--   [12,34,56,78]
--   </pre>
--   
--   If you supply this an <a>Integer</a>, the result will be an infinite
--   <a>Traversal</a>, which can be productively consumed, but not
--   reassembled.
--   
--   Why isn't this function called <tt>bytes</tt> to match <a>bits</a>?
--   Alas, there is already a function by that name in
--   <a>Data.ByteString.Lens</a>.
bytewise :: (Integral b, Bits b) => IndexedTraversal' Int b Word8


module Data.Array.Lens

-- | This <a>Setter</a> can be used to derive a new <a>IArray</a> from an
--   old <a>IArray</a> by applying a function to each of the indices to
--   look it up in the old <a>IArray</a>.
--   
--   This is a <i>contravariant</i> <a>Setter</a>.
--   
--   <pre>
--   <a>ixmap</a> ≡ <a>over</a> <a>.</a> <a>ixmapped</a>
--   <a>ixmapped</a> ≡ <a>setting</a> <a>.</a> <a>ixmap</a>
--   <a>over</a> (<a>ixmapped</a> b) f arr <a>!</a> i ≡ arr <a>!</a> f i
--   <a>bounds</a> (<a>over</a> (<a>ixmapped</a> b) f arr) ≡ b
--   </pre>
ixmapped :: (IArray a e, Ix i, Ix j) => (i, i) -> IndexPreservingSetter (a j e) (a i e) i j


-- | A <a>Fold</a> can be used to take the role of <a>Foldable</a> in
--   <tt>Control.Seq</tt>.
module Control.Seq.Lens

-- | Evaluate the elements targeted by a <a>Lens</a>, <a>Traversal</a>,
--   <a>Iso</a>, <a>Getter</a> or <a>Fold</a> according to the given
--   strategy.
--   
--   <pre>
--   <a>seqFoldable</a> = <a>seqOf</a> <a>folded</a>
--   </pre>
seqOf :: Getting (Endo [a]) s a -> Strategy a -> Strategy s


-- | A <a>Lens</a> or <a>Traversal</a> can be used to take the role of
--   <a>Traversable</a> in <tt>Control.Parallel.Strategies</tt>, enabling
--   those combinators to work with monomorphic containers.
module Control.Parallel.Strategies.Lens

-- | Evaluate the targets of a <a>Lens</a> or <a>Traversal</a> into a data
--   structure according to the given <a>Strategy</a>.
--   
--   <pre>
--   <a>evalTraversable</a> = <a>evalOf</a> <a>traverse</a> = <a>traverse</a>
--   <a>evalOf</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>evalOf</a> :: <a>Lens'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>evalOf</a> :: <a>Traversal'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>evalOf</a> :: (a -&gt; <a>Eval</a> a) -&gt; s -&gt; <a>Eval</a> s) -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   </pre>
evalOf :: LensLike' Eval s a -> Strategy a -> Strategy s

-- | Evaluate the targets of a <a>Lens</a> or <a>Traversal</a> according
--   into a data structure according to a given <a>Strategy</a> in
--   parallel.
--   
--   <pre>
--   <a>parTraversable</a> = <a>parOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>parOf</a> :: <a>Lens'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>parOf</a> :: <a>Traversal'</a> s a -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   <a>parOf</a> :: ((a -&gt; <a>Eval</a> a) -&gt; s -&gt; <a>Eval</a> s) -&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> s
--   </pre>
parOf :: LensLike' Eval s a -> Strategy a -> Strategy s

-- | Transform a <a>Lens</a>, <a>Fold</a>, <a>Getter</a>, <a>Setter</a> or
--   <a>Traversal</a> to first evaluates its argument according to a given
--   <a>Strategy</a> <i>before</i> proceeding.
--   
--   <pre>
--   <a>after</a> <a>rdeepseq</a> <a>traverse</a> :: <a>Traversable</a> t =&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> [a]
--   </pre>
after :: Strategy s -> LensLike f s t a b -> LensLike f s t a b

-- | Transform a <a>Lens</a>, <a>Fold</a>, <a>Getter</a>, <a>Setter</a> or
--   <a>Traversal</a> to evaluate its argument according to a given
--   <a>Strategy</a> <i>in parallel with</i> evaluating.
--   
--   <pre>
--   <a>throughout</a> <a>rdeepseq</a> <a>traverse</a> :: <a>Traversable</a> t =&gt; <a>Strategy</a> a -&gt; <a>Strategy</a> [a]
--   </pre>
throughout :: Strategy s -> LensLike f s t a b -> LensLike f s t a b


module Control.Monad.Error.Lens

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>, really).
--   
--   <pre>
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a    -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadError e m => Getting (First a) e a -> m r -> (a -> m r) -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particularly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a    -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r

-- | A version of <a>catching</a> with the arguments swapped around; useful
--   in situations where the code for the handler is shorter.
--   
--   <pre>
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a    -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   </pre>
handling :: MonadError e m => Getting (First a) e a -> (a -> m r) -> m r -> m r

-- | A version of <a>catching_</a> with the arguments swapped around;
--   useful in situations where the code for the handler is shorter.
--   
--   <pre>
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a    -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a      -&gt; m r -&gt; m r -&gt; m r
--   </pre>
handling_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r

-- | <a>trying</a> takes a <a>Prism</a> (or any <a>Getter</a>) to select
--   which exceptions are caught If the exception does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e a     -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Lens'</a> e a      -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Traversal'</a> e a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e a       -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Getter</a> e a    -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadError</a> e m =&gt; <a>Fold</a> e a      -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadError e m => Getting (First a) e a -> m r -> m (Either a r)

-- | This function exists to remedy a gap between the functionality of
--   <tt>Control.Exception</tt> and <tt>Control.Monad.Error</tt>.
--   <tt>Control.Exception</tt> supplies <a>catches</a> and a notion of
--   <a>Handler</a>, which we duplicate here in a form suitable for working
--   with any <a>MonadError</a> instance.
--   
--   Sometimes you want to catch two different sorts of error. You could do
--   something like
--   
--   <pre>
--   f = <a>handling</a> _Foo handleFoo (<a>handling</a> _Bar handleBar expr)
--   </pre>
--   
--   However, there are a couple of problems with this approach. The first
--   is that having two exception handlers is inefficient. However, the
--   more serious issue is that the second exception handler will catch
--   exceptions in the first, e.g. in the example above, if
--   <tt>handleFoo</tt> uses <a>throwError</a> then the second exception
--   handler will catch it.
--   
--   Instead, we provide a function <a>catches</a>, which would be used
--   thus:
--   
--   <pre>
--   f = <a>catches</a> expr [ <a>handler</a> _Foo handleFoo
--                    , <a>handler</a> _Bar handleBar
--                    ]
--   </pre>
catches :: MonadError e m => m a -> [Handler e m a] -> m a

-- | You need this when using <a>catches</a>.
data Handler e m r
Handler :: (e -> Maybe a) -> (a -> m r) -> Handler e m r

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: Type -> Type) (h :: Type -> Type) | h -> e m

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really).
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler</a> <a>_AssertionFailed</a> (s -&gt; <a>print</a> <a>$</a> "Assertion Failed\n" <a>++</a> s)
--               , <a>handler</a> <a>_ErrorCall</a> (s -&gt; <a>print</a> <a>$</a> "Error\n" <a>++</a> s)
--               ]
--   </pre>
--   
--   This works ith both the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Fold</a>       e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Prism'</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Lens'</a>      e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Traversal'</a> e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   </pre>
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really). that ignores its input
--   and just recovers with the stated monadic action.
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler_</a> <a>_NonTermination</a> (<a>return</a> "looped")
--               , <a>handler_</a> <a>_StackOverflow</a> (<a>return</a> "overflow")
--               ]
--   </pre>
--   
--   This works with the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Fold</a>       e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Prism'</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Lens'</a>      e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Traversal'</a> e a -&gt; m r -&gt; <a>Handler</a> e m r
--   </pre>
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | Throw an exception described by a <a>Prism</a>.
--   
--   <pre>
--   <a>throwing</a> l ≡ <a>reviews</a> l <a>throwError</a>
--   </pre>
--   
--   <pre>
--   <a>throwing</a> :: <a>MonadError</a> e m =&gt; <a>Prism'</a> e t -&gt; t -&gt; a
--   <a>throwing</a> :: <a>MonadError</a> e m =&gt; <a>Iso'</a> e t   -&gt; t -&gt; a
--   </pre>
throwing :: MonadError e m => AReview e t -> t -> m x

-- | Similar to <a>throwing</a> but specialised for the common case of
--   error constructors with no arguments.
--   
--   <pre>
--   data MyError = Foo | Bar
--   makePrisms ''MyError
--   <a>throwing_</a> _Foo :: <a>MonadError</a> MyError m =&gt; m a
--   </pre>
throwing_ :: MonadError e m => AReview e () -> m x
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Error.Lens.Handler e m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Control.Monad.Error.Lens.Handler e m a)
instance GHC.Base.Monad m => Data.Functor.Alt.Alt (Control.Monad.Error.Lens.Handler e m)
instance GHC.Base.Monad m => Data.Functor.Plus.Plus (Control.Monad.Error.Lens.Handler e m)
instance GHC.Base.Monad m => GHC.Base.Monoid (Control.Monad.Error.Lens.Handler e m a)
instance Control.Lens.Internal.Exception.Handleable e m (Control.Monad.Error.Lens.Handler e m)


-- | One commonly asked question is: can we combine two lenses,
--   <tt><a>Lens'</a> a b</tt> and <tt><a>Lens'</a> a c</tt> into
--   <tt><a>Lens'</a> a (b, c)</tt>. This is fair thing to ask, but such
--   operation is unsound in general. See <a>lensProduct</a>.
module Control.Lens.Unsound

-- | A lens product. There is no law-abiding way to do this in general.
--   Result is only a valid <a>Lens</a> if the input lenses project
--   disjoint parts of the structure <tt>s</tt>. Otherwise "you get what
--   you put in" law
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s) ≡ v
--   </pre>
--   
--   is violated by
--   
--   <pre>
--   &gt;&gt;&gt; let badLens :: Lens' (Int, Char) (Int, Int); badLens = lensProduct _1 _1
--   
--   &gt;&gt;&gt; view badLens (set badLens (1,2) (3,'x'))
--   (2,2)
--   </pre>
--   
--   but we should get <tt>(1,2)</tt>.
--   
--   Are you looking for <a>alongside</a>?
lensProduct :: ALens' s a -> ALens' s b -> Lens' s (a, b)

-- | A dual of <a>lensProduct</a>: a prism sum.
--   
--   The law
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b) ≡ <a>Just</a> b
--   </pre>
--   
--   breaks with
--   
--   <pre>
--   &gt;&gt;&gt; let badPrism :: Prism' (Maybe Char) (Either Char Char); badPrism = prismSum _Just _Just
--   
--   &gt;&gt;&gt; preview badPrism (review badPrism (Right 'x'))
--   Just (Left 'x')
--   </pre>
--   
--   We put in <a>Right</a> value, but get back <a>Left</a>.
--   
--   Are you looking for <a>without</a>?
prismSum :: APrism s t a b -> APrism s t c d -> Prism s t (Either a c) (Either b d)

-- | A generalization of <a>mappend</a>ing folds: A union of disjoint
--   traversals.
--   
--   Traversing the same entry twice is illegal.
--   
--   Are you looking for <a>failing</a>?
adjoin :: Traversal' s a -> Traversal' s a -> Traversal' s a


-- | This module provides conversion functions between the optics defined
--   in this library and <a>Profunctor</a>-based optics.
--   
--   The goal of these functions is to provide an interoperability layer
--   between the two styles of optics, and not to reimplement all the
--   library in terms of <a>Profunctor</a> optics.
module Control.Lens.Profunctor

-- | Profunctor optic.
type OpticP p s t a b = p a b -> p s t

-- | Converts a <a>Lens</a> to a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>fromLens</a> :: <a>Lens</a> s t a b -&gt; LensP s t a b
--   </pre>
fromLens :: Strong p => LensLike (Context a b) s t a b -> OpticP p s t a b

-- | Converts a <a>Iso</a> to a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>fromIso</a> :: <a>Iso</a> s t a b -&gt; IsoP s t a b
--   </pre>
fromIso :: Profunctor p => Optic p Identity s t a b -> OpticP p s t a b

-- | Converts a <a>Prism</a> to a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>fromPrism</a> :: <a>Prism</a> s t a b -&gt; PrismP s t a b
--   </pre>
fromPrism :: Choice p => Optic p Identity s t a b -> OpticP p s t a b

-- | Converts a <a>Setter</a> to a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>fromSetter</a> :: <a>Setter</a> s t a b -&gt; SetterP s t a b
--   </pre>
fromSetter :: Mapping p => ASetter s t a b -> OpticP p s t a b

-- | Converts a <a>Traversal</a> to a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>fromTraversal</a> :: <a>Traversal</a> s t a b -&gt; TraversalP s t a b
--   </pre>
fromTraversal :: Traversing p => ATraversal s t a b -> OpticP p s t a b

-- | Obtain a <a>Lens</a> from a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>toLens</a> :: LensP s t a b -&gt; <a>Lens</a> s t a b
--   </pre>
toLens :: Functor f => OpticP (Star f) s t a b -> LensLike f s t a b

-- | Obtain a <a>Iso</a> from a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>toIso</a> :: IsoP s t a b -&gt; <a>Iso</a> s t a b
--   </pre>
toIso :: (Profunctor p, Functor f) => OpticP (WrappedPafb f p) s t a b -> Optic p f s t a b

-- | Obtain a <a>Prism</a> from a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>toPrism</a> :: PrismP s t a b -&gt; <a>Prism</a> s t a b
--   </pre>
toPrism :: (Choice p, Applicative f) => OpticP (WrappedPafb f p) s t a b -> Optic p f s t a b

-- | Obtain a <a>Setter</a> from a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>toSetter</a> :: SetterP s t a b -&gt; <a>Setter</a> s t a b
--   </pre>
toSetter :: Settable f => OpticP (Star f) s t a b -> LensLike f s t a b

-- | Obtain a <a>Traversal</a> from a <a>Profunctor</a>-based one.
--   
--   <pre>
--   <a>toTraversal</a> :: TraversalP s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
toTraversal :: Applicative f => OpticP (Star f) s t a b -> LensLike f s t a b


-- | This module exists for users who like to work with qualified imports
--   but want access to the operators from Lens.
--   
--   <pre>
--   import qualified Control.Lens as L
--   import Control.Lens.Operators
--   </pre>
module Control.Lens.Operators

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList []
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a &lt;| Seq.fromList [b, c]
--   fromList [a,b,c]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] |&gt; a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [b, c] |&gt; a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; LazyT.pack "hello" |&gt; '!'
--   "hello!"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | A convenient infix (flipped) version of <a>toListOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [[1,2],[3]]^..id
--   [[[1,2],[3]]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse
--   [[1,2],[3]]
--   
--   &gt;&gt;&gt; [[1,2],[3]]^..traverse.traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^..both
--   [1,2]
--   </pre>
--   
--   <pre>
--   <a>toList</a> xs ≡ xs <a>^..</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
--   
--   <pre>
--   (<a>^..</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>a</a> :: s -&gt; <a>Fold</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Lens'</a> s a      -&gt; <a>a</a> :: s -&gt; <a>Iso'</a> s a       -&gt; <a>a</a> :: s -&gt; <a>Traversal'</a> s a -&gt; <a>a</a> :: s -&gt; <a>Prism'</a> s a     -&gt; [a]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]
infixl 8 ^..

-- | Perform a safe <a>head</a> of a <a>Fold</a> or <a>Traversal</a> or
--   retrieve <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   When using a <a>Traversal</a> as a partial <a>Lens</a>, or a
--   <a>Fold</a> as a partial <a>Getter</a> this can be a convenient way to
--   extract the optional value.
--   
--   Note: if you get stack overflows due to this, you may want to use
--   <a>firstOf</a> instead, which can deal more gracefully with heavily
--   left-biased trees. This is because <a>^?</a> works by using the
--   <a>First</a> monoid, which can occasionally cause space leaks.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?_Left
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 4 ^?_Left
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 3
--   Just 'l'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^? ix 20
--   Nothing
--   </pre>
--   
--   This operator works as an infix version of <a>preview</a>.
--   
--   <pre>
--   (<a>^?</a>) ≡ <a>flip</a> <a>preview</a>
--   </pre>
--   
--   It may be helpful to think of <a>^?</a> as having one of the following
--   more specialized types:
--   
--   <pre>
--   (<a>^?</a>) :: s -&gt; <a>Getter</a> s a     -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Fold</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; <a>Maybe</a> a
--   (<a>^?</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; <a>Maybe</a> a
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a
infixl 8 ^?

-- | Perform an *UNSAFE* <a>head</a> of a <a>Fold</a> or <a>Traversal</a>
--   assuming that it is there.
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^?! _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "world" ^?! ix 3
--   'l'
--   </pre>
--   
--   <pre>
--   (<a>^?!</a>) :: s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Fold</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^?!</a>) :: s -&gt; <a>Traversal'</a> s a -&gt; a
--   </pre>
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
infixl 8 ^?!

-- | An infix version of <a>itoListOf</a>.
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
infixl 8 ^@..

-- | Perform a safe <a>head</a> (with index) of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> or retrieve <a>Just</a> the index and result
--   from an <a>IndexedGetter</a> or <a>IndexedLens</a>.
--   
--   When using a <a>IndexedTraversal</a> as a partial <a>IndexedLens</a>,
--   or an <a>IndexedFold</a> as a partial <a>IndexedGetter</a> this can be
--   a convenient way to extract the optional value.
--   
--   <pre>
--   (<a>^@?</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; <a>Maybe</a> (i, a)
--   (<a>^@?</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; <a>Maybe</a> (i, a)
--   </pre>
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
infixl 8 ^@?

-- | Perform an *UNSAFE* <a>head</a> (with index) of an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> assuming that it is there.
--   
--   <pre>
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedGetter</a> i s a     -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedFold</a> i s a       -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedLens'</a> i s a      -&gt; (i, a)
--   (<a>^@?!</a>) :: s -&gt; <a>IndexedTraversal'</a> i s a -&gt; (i, a)
--   </pre>
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
infixl 8 ^@?!

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | View the index and value of an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>.
--   
--   This is the same operation as <a>iview</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   (<a>^@.</a>) :: s -&gt; <a>IndexedGetter</a> i s a -&gt; (i, a)
--   (<a>^@.</a>) :: s -&gt; <a>IndexedLens'</a> i s a  -&gt; (i, a)
--   </pre>
--   
--   The result probably doesn't have much meaning when applied to an
--   <a>IndexedFold</a>.
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
infixl 8 ^@.

-- | Compose an <a>Indexed</a> function with a non-indexed function.
--   
--   Mnemonically, the <tt>&lt;</tt> points to the indexing we want to
--   preserve.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.itraversed).withIndex
--   [(1,"one,ten"),(1,"one,twenty"),(2,"two,thirty"),(2,"two,forty")]
--   </pre>
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
infixr 9 <.

-- | Compose a non-indexed function with an <a>Indexed</a> function.
--   
--   Mnemonically, the <tt>&gt;</tt> points to the indexing we want to
--   preserve.
--   
--   This is the same as <tt>(<a>.</a>)</tt>.
--   
--   <tt>f <a>.</a> g</tt> (and <tt>f <a>.&gt;</a> g</tt>) gives you the
--   index of <tt>g</tt> unless <tt>g</tt> is index-preserving, like a
--   <a>Prism</a>, <a>Iso</a> or <a>Equality</a>, in which case it'll pass
--   through the index of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed.&gt;itraversed).withIndex
--   [(10,"one,ten"),(20,"one,twenty"),(30,"two,thirty"),(40,"two,forty")]
--   </pre>
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
infixr 9 .>

-- | Composition of <a>Indexed</a> functions.
--   
--   Mnemonically, the <tt>&lt;</tt> and <tt>&gt;</tt> points to the fact
--   that we want to preserve the indices.
--   
--   <pre>
--   &gt;&gt;&gt; let nestedMap = (fmap Map.fromList . Map.fromList) [(1, [(10, "one,ten"), (20, "one,twenty")]), (2, [(30, "two,thirty"), (40,"two,forty")])]
--   
--   &gt;&gt;&gt; nestedMap^..(itraversed&lt;.&gt;itraversed).withIndex
--   [((1,10),"one,ten"),((1,20),"one,twenty"),((2,30),"two,thirty"),((2,40),"two,forty")]
--   </pre>
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
infixr 9 <.>

-- | (<a>%%~</a>) can be used in one of two scenarios:
--   
--   When applied to a <a>Lens</a>, it can edit the target of the
--   <a>Lens</a> in a structure, extracting a functorial result.
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting an applicative summary of its actions.
--   
--   <pre>
--   &gt;&gt;&gt; [66,97,116,109,97,110] &amp; each %%~ \a -&gt; ("na", chr a)
--   ("nananananana","Batman")
--   </pre>
--   
--   For all that the definition of this combinator is just:
--   
--   <pre>
--   (<a>%%~</a>) ≡ <a>id</a>
--   </pre>
--   
--   It may be beneficial to think about it as if it had these even more
--   restricted types, however:
--   
--   <pre>
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Iso</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Functor</a> f =&gt;     <a>Lens</a> s t a b      -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%~</a>) :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   When applied to a <a>Traversal</a>, it can edit the targets of the
--   traversals, extracting a supplemental monoidal summary of its actions,
--   by choosing <tt>f = ((,) m)</tt>
--   
--   <pre>
--   (<a>%%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%~</a>) :: <a>Monoid</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; (m, b)) -&gt; s -&gt; (m, t)
--   </pre>
(%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
infixr 4 %%~

-- | Modify the target of a <a>Lens</a> in the current state returning some
--   extra information of type <tt>r</tt> or modify all targets of a
--   <a>Traversal</a> in the current state, extracting extra information of
--   type <tt>r</tt> and return a monoidal summary of the changes.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 %%= \x -&gt; (f x, g x)) (a,b)
--   (f a,(g a,b))
--   </pre>
--   
--   <pre>
--   (<a>%%=</a>) ≡ (<a>state</a> <a>.</a>)
--   </pre>
--   
--   It may be useful to think of (<a>%%=</a>), instead, as having either
--   of the following more restricted type signatures:
--   
--   <pre>
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; (r, b)) -&gt; m r
--   (<a>%%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; (r, b)) -&gt; m r
--   </pre>
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
infix 4 %%=

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40
--   (30,40)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s
infixl 1 &~

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | This is convenient to <a>flip</a> argument order of composite
--   functions defined as:
--   
--   <pre>
--   fab ?? a = fmap ($ a) fab
--   </pre>
--   
--   For the <a>Functor</a> instance <tt>f = ((-&gt;) r)</tt> you can
--   reason about this function as if the definition was <tt>(<a>??</a>) ≡
--   <a>flip</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (h ?? x) a
--   h a x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState ?? [] $ modify (1:)
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _2 ?? ("hello","world") $ length
--   ("hello",5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over ?? length ?? ("hello","world") $ _2
--   ("hello",5)
--   </pre>
(??) :: Functor f => f (a -> b) -> a -> f b
infixl 1 ??

-- | Modify the target of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>%~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%~</a>) :: <a>Monoid</a> b =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <%~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the addition, (<a>+~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <+~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the subtraction, (<a>-~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <-~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the multiplication, (<a>*~</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <*~

-- | Divide the target of a fractionally valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the division, (<a>//~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a>  s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <//~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^~

-- | Raise the target of a fractionally valued <a>Lens</a> to an
--   <a>Integral</a> power and return the result.
--   
--   When you do not need the result of the operation, (<a>^^~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
infixr 4 <^^~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a  -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
infixr 4 <**~

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>||~</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <||~

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> and return
--   the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;~</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
infixr 4 <&&~

-- | Modify the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>%~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%~</a>) ::             <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) ::             <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
infixr 4 <<%~

-- | Replace the target of a <a>Lens</a>, but return the old value.
--   
--   When you do not need the old value, (<a>.~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.~</a>) ::             <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) ::             <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;.~</a>) :: <a>Monoid</a> a =&gt; <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
infixr 4 <<.~

-- | Replace the target of a <a>Lens</a> with a <a>Just</a> value, but
--   return the old value.
--   
--   If you do not need the old value (<a>?~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;&lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   (Nothing,(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (a, t)
--   </pre>
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
infixr 4 <<?~

-- | Increment the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>+~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;+~ c
--   (a,(a + c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;+~ c
--   (b,(a,b + c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<+~

-- | Decrement the target of a numerically valued <a>Lens</a> and return
--   the old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;-~ c
--   (a,(a - c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;-~ c
--   (b,(a,b - c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<-~

-- | Multiply the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>-~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;*~ c
--   (a,(a * c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;*~ c
--   (b,(a,b * c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<*~

-- | Divide the target of a numerically valued <a>Lens</a> and return the
--   old value.
--   
--   When you do not need the old value, (<a>//~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;//~ c
--   (a,(a / c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 &lt;&lt;//~ 2
--   (10.0,("Hawaii",5.0))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;//~</a>) :: Fractional a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<//~

-- | Raise the target of a numerically valued <a>Lens</a> to a non-negative
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   </pre>
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^~

-- | Raise the target of a fractionally valued <a>Lens</a> to an integral
--   power and return the old value.
--   
--   When you do not need the old value, (<a>^^~</a>) is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; S -&gt; (a, s)
--   </pre>
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
infixr 4 <<^^~

-- | Raise the target of a floating-point valued <a>Lens</a> to an
--   arbitrary power and return the old value.
--   
--   When you do not need the old value, (<a>**~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;&lt;**~ c
--   (a,(a**c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _2 &lt;&lt;**~ c
--   (b,(a,b**c))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   (<a>&lt;&lt;**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a -&gt; a -&gt; s -&gt; (a, s)
--   </pre>
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
infixr 4 <<**~

-- | Logically <a>||</a> the target of a <a>Bool</a>-valued <a>Lens</a> and
--   return the old value.
--   
--   When you do not need the old value, (<a>||~</a>) is more flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;||~ True
--   (False,(True,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;||~ False
--   (True,("hello",True))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;||~</a>) :: <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   (<a>&lt;&lt;||~</a>) :: <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; (<a>Bool</a>, s)
--   </pre>
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<||~

-- | Logically <a>&amp;&amp;</a> the target of a <a>Bool</a>-valued
--   <a>Lens</a> and return the old value.
--   
--   When you do not need the old value, (<a>&amp;&amp;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (False,6) &amp; _1 &lt;&lt;&amp;&amp;~ True
--   (False,(False,6))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",True) &amp; _2 &lt;&lt;&amp;&amp;~ False
--   (True,("hello",False))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Lens'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   (<a>&lt;&lt;&amp;&amp;~</a>) :: <a>Iso'</a> s Bool -&gt; Bool -&gt; s -&gt; (Bool, s)
--   </pre>
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
infixr 4 <<&&~

-- | Modify the target of a monoidally valued <a>Lens</a> by using
--   (<a>&lt;&gt;</a>) a new value and return the old value.
--   
--   When you do not need the old value, (<a>&lt;&gt;~</a>) is more
--   flexible.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&lt;&lt;&gt;~ Sum c
--   (Sum {getSum = a},(Sum {getSum = a + c},b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 &lt;&lt;&lt;&gt;~ ", 007" $ ("James", "Bond")
--   ("Bond",("James","Bond, 007"))
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Semigroup</a> r =&gt; <a>Lens'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   (<a>&lt;&lt;&lt;&gt;~</a>) :: <a>Semigroup</a> r =&gt; <a>Iso'</a> s r -&gt; r -&gt; s -&gt; (r, s)
--   </pre>
(<<<>~) :: Semigroup r => LensLike' ((,) r) s r -> r -> s -> (r, s)
infixr 4 <<<>~

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the result.
--   
--   When applied to a <a>Traversal</a>, it this will return a monoidal
--   summary of all of the intermediate results.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
infix 4 <%=

-- | Add to the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the addition, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <+=

-- | Subtract from the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the subtraction, (<a>-=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <-=

-- | Multiply the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the multiplication, (<a>*=</a>) is
--   more flexible.
--   
--   <pre>
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <*=

-- | Divide the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the division, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <//=

-- | Raise the target of a numerically valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to a non-negative <a>Integral</a> power and
--   return the result.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^=

-- | Raise the target of a fractionally valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an <a>Integral</a> power and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> b, <a>Integral</a> e) =&gt; <a>Iso'</a> s a  -&gt; e -&gt; m a
--   </pre>
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <^^=

-- | Raise the target of a floating-point valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state to an arbitrary power and return the result.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <**=

-- | Logically <a>||</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <||=

-- | Logically <a>&amp;&amp;</a> a Boolean valued <a>Lens</a> into your
--   <tt>Monad'</tt>s state and return the result.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>  -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <&&=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   a user supplied function and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>%=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m a
--   (<a>&lt;&lt;%=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m a
--   </pre>
--   
--   <pre>
--   (<a>&lt;&lt;%=</a>) :: <a>MonadState</a> s m =&gt; <a>LensLike</a> ((,)a) s s a b -&gt; (a -&gt; b) -&gt; m a
--   </pre>
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
infix 4 <<%=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with a user supplied value and return the <i>old</i> value that was
--   replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>.=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m a
--   (<a>&lt;&lt;.=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
infix 4 <<.=

-- | Replace the target of a <a>Lens</a> into your <tt>Monad'</tt>s state
--   with <a>Just</a> a user supplied value and return the <i>old</i> value
--   that was replaced.
--   
--   When applied to a <a>Traversal</a>, this will return a monoidal
--   summary of all of the old values present.
--   
--   When you do not need the result of the operation, (<a>?=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Lens</a> s t a (Maybe b)      -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: <a>MonadState</a> s m             =&gt; <a>Iso</a> s t a (Maybe b)       -&gt; b -&gt; m a
--   (<a>&lt;&lt;?=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal</a> s t a (Maybe b) -&gt; b -&gt; m a
--   </pre>
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
infix 4 <<?=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   adding a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>+=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<+=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   subtracting a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>-=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<-=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   multipling a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>*=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<*=

-- | Modify the target of a <a>Lens</a> into your <a>Monad</a>s state by
--   dividing by a value and return the <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>//=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<//=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by a non-negative power and return the <i>old</i> value
--   that was replaced.
--   
--   When you do not need the result of the operation, (<a>^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an integral power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>^^=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a -&gt; e -&gt; m a
--   (<a>&lt;&lt;^^=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a -&gt; e -&gt; m a
--   </pre>
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
infix 4 <<^^=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   raising it by an arbitrary power and return the <i>old</i> value that
--   was replaced.
--   
--   When you do not need the result of the operation, (<a>**=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m a
--   (<a>&lt;&lt;**=</a>) :: (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m a
--   </pre>
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
infix 4 <<**=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>||</a> with a value and return the <i>old</i>
--   value that was replaced.
--   
--   When you do not need the result of the operation, (<a>||=</a>) is more
--   flexible.
--   
--   <pre>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<||=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   taking its logical <a>&amp;&amp;</a> with a value and return the
--   <i>old</i> value that was replaced.
--   
--   When you do not need the result of the operation, (<a>&amp;&amp;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   (<a>&lt;&lt;&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m <a>Bool</a>
--   </pre>
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
infix 4 <<&&=

-- | Modify the target of a <a>Lens</a> into your <tt>Monad'</tt>s state by
--   using (<a>&lt;&gt;</a>) and return the <i>old</i> value that was
--   replaced.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
--   
--   <pre>
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> r) =&gt; <a>Lens'</a> s r -&gt; r -&gt; m r
--   (<a>&lt;&lt;&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> r) =&gt; <a>Iso'</a> s r -&gt; r -&gt; m r
--   </pre>
(<<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<<>=

-- | Run a monadic action, and set the target of <a>Lens</a> to its result.
--   
--   <pre>
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b   -&gt; m b -&gt; m b
--   (<a>&lt;&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b  -&gt; m b -&gt; m b
--   </pre>
--   
--   NB: This is limited to taking an actual <a>Lens</a> than admitting a
--   <a>Traversal</a> because there are potential loss of state issues
--   otherwise.
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
infixr 2 <<~

-- | (<a>&lt;&gt;</a>) a <a>Semigroup</a> value onto the end of the target
--   of a <a>Lens</a> and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;~</a>)
--   is more flexible.
(<<>~) :: Semigroup m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
infixr 4 <<>~

-- | (<a>&lt;&gt;</a>) a <a>Semigroup</a> value onto the end of the target
--   of a <a>Lens</a> into your <tt>Monad'</tt>s state and return the
--   result.
--   
--   When you do not need the result of the operation, (<a>&lt;&gt;=</a>)
--   is more flexible.
(<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
infix 4 <<>=

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary along with the answer.
--   
--   <pre>
--   l <a>&lt;%~</a> f ≡ l <a>&lt;%@~</a> <a>const</a> f
--   </pre>
--   
--   When you do not need access to the index then (<a>&lt;%~</a>) is more
--   liberal in what it can accept.
--   
--   If you do not need the intermediate result, you can use (<a>%@~</a>)
--   or even (<a>%~</a>).
--   
--   <pre>
--   (<a>&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   (<a>&lt;%@~</a>) :: <a>Monoid</a> b =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (b, t)
--   </pre>
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
infixr 4 <%@~

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> and return a
--   monoidal summary of the old values along with the answer.
--   
--   <pre>
--   (<a>&lt;&lt;%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   (<a>&lt;&lt;%@~</a>) :: <a>Monoid</a> a =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; (a, t)
--   </pre>
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
infixr 4 <<%@~

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a> and
--   return a monoidal summary of the supplementary results and the answer.
--   
--   <pre>
--   (<a>%%@~</a>) ≡ <a>withIndex</a>
--   </pre>
--   
--   <pre>
--   (<a>%%@~</a>) :: <a>Functor</a> f =&gt; <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   (<a>%%@~</a>) :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   In particular, it is often useful to think of this function as having
--   one of these even more restricted type signatures:
--   
--   <pre>
--   (<a>%%@~</a>) ::             <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   (<a>%%@~</a>) :: <a>Monoid</a> r =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; (r, t)
--   </pre>
(%%@~) :: Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
infixr 4 %%@~

-- | Adjust the target of an <a>IndexedLens</a> returning a supplementary
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   supplementary results.
--   
--   <pre>
--   l <a>%%@=</a> f ≡ <a>state</a> (l <a>%%@~</a> f)
--   </pre>
--   
--   <pre>
--   (<a>%%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   (<a>%%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; (r, b)) -&gt; s -&gt; m r
--   </pre>
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
infix 4 %%@=

-- | Adjust the target of an <a>IndexedLens</a> returning the intermediate
--   result, or adjust all of the targets of an <a>IndexedTraversal</a>
--   within the current state, and return a monoidal summary of the
--   intermediate results.
--   
--   <pre>
--   (<a>&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   (<a>&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m b
--   </pre>
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
infix 4 <%@=

-- | Adjust the target of an <a>IndexedLens</a> returning the old value, or
--   adjust all of the targets of an <a>IndexedTraversal</a> within the
--   current state, and return a monoidal summary of the old values.
--   
--   <pre>
--   (<a>&lt;&lt;%@=</a>) :: <a>MonadState</a> s m                 =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   (<a>&lt;&lt;%@=</a>) :: (<a>MonadState</a> s m, <a>Monoid</a> b) =&gt; <a>IndexedTraversal</a> i s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m a
--   </pre>
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
infix 4 <<%@=

-- | A version of (<a>^.</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^#_2
--   "world"
--   </pre>
(^#) :: s -> ALens s t a b -> a
infixl 8 ^#

-- | A version of (<a>.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 #~ "world"
--   ("hello","world")
--   </pre>
(#~) :: ALens s t a b -> b -> s -> t
infixr 4 #~

-- | A version of (<a>%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%~ length
--   ("hello",5)
--   </pre>
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
infixr 4 #%~

-- | A version of (<a>%%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 #%%~ \x -&gt; (length x, x ++ "!")
--   (5,("hello","world!"))
--   </pre>
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
infixr 4 #%%~

-- | A version of (<a>.=</a>) that works on <a>ALens</a>.
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
infix 4 #=

-- | A version of (<a>%=</a>) that works on <a>ALens</a>.
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
infix 4 #%=

-- | A version of (<a>&lt;%~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; _2 &lt;#%~ length
--   (5,("hello",5))
--   </pre>
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
infixr 4 <#%~

-- | A version of (<a>&lt;%=</a>) that works on <a>ALens</a>.
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
infix 4 <#%=

-- | A version of (<a>%%=</a>) that works on <a>ALens</a>.
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
infix 4 #%%=

-- | A version of (<a>&lt;.~</a>) that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","there") &amp; _2 &lt;#~ "world"
--   ("world",("hello","world"))
--   </pre>
(<#~) :: ALens s t a b -> b -> s -> (b, t)
infixr 4 <#~

-- | A version of (<a>&lt;.=</a>) that works on <a>ALens</a>.
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
infix 4 <#=

-- | Compose through a plate
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
infixr 9 ...

-- | An infix alias for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> f # x ≡ f x
--   l # x ≡ x <a>^.</a> <a>re</a> l
--   </pre>
--   
--   This is commonly used when using a <a>Prism</a> as a smart
--   constructor.
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 4
--   Left 4
--   </pre>
--   
--   But it can be used for any <a>Prism</a>
--   
--   <pre>
--   &gt;&gt;&gt; base 16 # 123
--   "7b"
--   </pre>
--   
--   <pre>
--   (#) :: <a>Iso'</a>      s a -&gt; a -&gt; s
--   (#) :: <a>Prism'</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Review</a>    s a -&gt; a -&gt; s
--   (#) :: <a>Equality'</a> s a -&gt; a -&gt; s
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Set the target of a <a>Lens</a>, <a>Traversal</a> or <a>Setter</a> to
--   <a>Just</a> a value.
--   
--   <pre>
--   l <a>?~</a> t ≡ <a>set</a> l (<a>Just</a> t)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; id ?~ a
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ x
--   fromList [(3,x)]
--   </pre>
--   
--   <a>?~</a> can be used type-changily:
--   
--   <pre>
--   &gt;&gt;&gt; ('a', ('b', 'c')) &amp; _2.both ?~ 'x'
--   ('a',(Just 'x',Just 'x'))
--   </pre>
--   
--   <pre>
--   (<a>?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; t
--   (<a>?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; t
--   </pre>
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Set with pass-through.
--   
--   This is mostly present for consistency, but may be useful for chaining
--   assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.~</a> t</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 &lt;.~ c
--   (c,(c,b))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("good","morning","vietnam") &amp; _3 &lt;.~ "world"
--   ("world",("good","morning","world"))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,Map.fromList [("goodnight","gracie")]) &amp; _2.at "hello" &lt;.~ Just "world"
--   (Just "world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
infixr 4 <.~

-- | Set to <a>Just</a> a value with pass-through.
--   
--   This is mostly present for consistency, but may be useful for for
--   chaining assignments.
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?~</a> d</tt> directly is a good idea.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map as Map
--   
--   &gt;&gt;&gt; _2.at "hello" &lt;?~ "world" $ (42,Map.fromList [("goodnight","gracie")])
--   ("world",(42,fromList [("goodnight","gracie"),("hello","world")]))
--   </pre>
--   
--   <pre>
--   (<a>&lt;?~</a>) :: <a>Setter</a> s t a (<a>Maybe</a> b)    -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Iso</a> s t a (<a>Maybe</a> b)       -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Lens</a> s t a (<a>Maybe</a> b)      -&gt; b -&gt; s -&gt; (b, t)
--   (<a>&lt;?~</a>) :: <a>Traversal</a> s t a (<a>Maybe</a> b) -&gt; b -&gt; s -&gt; (b, t)
--   </pre>
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
infixr 4 <?~

-- | Increment the target(s) of a numerically valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 +~ c
--   (a + c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both +~ c
--   (a + c,b + c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 +~ 1
--   (1,3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(a,b),(c,d)] &amp; traverse.both +~ e
--   [(a + e,b + e),(c + e,d + e)]
--   </pre>
--   
--   <pre>
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>+~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(+~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 +~

-- | Multiply the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 *~ c
--   (a * c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both *~ c
--   (a * c,b * c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 *~ 4
--   (1,8)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just 24 &amp; mapped *~ 2
--   Just 48
--   </pre>
--   
--   <pre>
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>*~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(*~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 *~

-- | Decrement the target(s) of a numerically valued <a>Lens</a>,
--   <a>Iso</a>, <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 -~ c
--   (a - c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both -~ c
--   (a - c,b - c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 -~ 2 $ (1,2)
--   (-1,2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapped.mapped -~ 1 $ [[4,5],[6,7]]
--   [[3,4],[5,6]]
--   </pre>
--   
--   <pre>
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>-~</a>) :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(-~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 -~

-- | Divide the target(s) of a numerically valued <a>Lens</a>, <a>Iso</a>,
--   <a>Setter</a> or <a>Traversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 //~ c
--   (a / c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both //~ c
--   (a / c,b / c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("Hawaii",10) &amp; _2 //~ 2
--   ("Hawaii",5.0)
--   </pre>
--   
--   <pre>
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>//~</a>) :: <a>Fractional</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
infixr 4 //~

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,3) &amp; _2 ^~ 2
--   (1,9)
--   </pre>
--   
--   <pre>
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^~</a>) :: (<a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^~

-- | Raise the target(s) of a fractionally valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _2 ^^~ (-1)
--   (1,0.5)
--   </pre>
--   
--   <pre>
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; s -&gt; s
--   (<a>^^~</a>) :: (<a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; s -&gt; s
--   </pre>
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
infixr 4 ^^~

-- | Raise the target(s) of a floating-point valued <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to an arbitrary power.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; _1 **~ c
--   (a**c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both **~ c
--   (a**c,b**c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 **~ 10 $ (3,2)
--   (3,1024.0)
--   </pre>
--   
--   <pre>
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   (<a>**~</a>) :: <a>Floating</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
infixr 4 **~

-- | Logically <a>||</a> the target(s) of a <a>Bool</a>-valued <a>Lens</a>
--   or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ True $ (False,True)
--   (True,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both ||~ False $ (False,True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   (<a>||~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>||~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 ||~

-- | Logically <a>&amp;&amp;</a> the target(s) of a <a>Bool</a>-valued
--   <a>Lens</a> or <a>Setter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ True $ (False, True)
--   (False,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &amp;&amp;~ False $ (False, True)
--   (False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;~</a>) :: <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; s -&gt; s
--   (<a>&amp;&amp;~</a>) :: <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; s -&gt; s
--   </pre>
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 &&~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
infix 4 .=

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with
--   <a>Just</a> a new value, irrespective of the old.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do at 1 ?= a; at 2 ?= b) Map.empty
--   fromList [(1,a),(2,b)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ?= b; _2 ?= c) (Just a, Nothing)
--   (Just b,Just c)
--   </pre>
--   
--   <pre>
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s (<a>Maybe</a> a)       -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s (<a>Maybe</a> a)      -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s (<a>Maybe</a> a) -&gt; a -&gt; m ()
--   (<a>?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s (<a>Maybe</a> a)    -&gt; a -&gt; m ()
--   </pre>
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
infix 4 ?=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by adding a value.
--   
--   Example:
--   
--   <pre>
--   <tt>fresh</tt> :: <a>MonadState</a> <a>Int</a> m =&gt; m <a>Int</a>
--   <tt>fresh</tt> = do
--     <a>id</a> <a>+=</a> 1
--     <a>use</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 += c; _2 += d) (a,b)
--   (a + c,b + d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],"hello")
--   (fromList [(1,10),(2,100)],"hello")
--   </pre>
--   
--   <pre>
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>+=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 +=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by subtracting a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 -= c; _2 -= d) (a,b)
--   (a - c,b - d)
--   </pre>
--   
--   <pre>
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>-=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 -=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by multiplying by value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 *= c; _2 *= d) (a,b)
--   (a * c,b * d)
--   </pre>
--   
--   <pre>
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>*=</a>) :: (<a>MonadState</a> s m, <a>Num</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
infix 4 *=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by dividing by a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 //= c; _2 //= d) (a,b)
--   (a / c,b / d)
--   </pre>
--   
--   <pre>
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>//=</a>) :: (<a>MonadState</a> s m, <a>Fractional</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
infix 4 //=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to a non-negative integral power.
--   
--   <pre>
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^=</a>) ::  (<a>MonadState</a> s m, <a>Num</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an integral power.
--   
--   <pre>
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Setter'</a> s a    -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Iso'</a> s a       -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Lens'</a> s a      -&gt; e -&gt; m ()
--   (<a>^^=</a>) ::  (<a>MonadState</a> s m, <a>Fractional</a> a, <a>Integral</a> e) =&gt; <a>Traversal'</a> s a -&gt; e -&gt; m ()
--   </pre>
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
infix 4 ^^=

-- | Raise the target(s) of a numerically valued <a>Lens</a>, <a>Setter</a>
--   or <a>Traversal</a> to an arbitrary power
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 **= c; _2 **= d) (a,b)
--   (a**c,b**d)
--   </pre>
--   
--   <pre>
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>**=</a>) ::  (<a>MonadState</a> s m, <a>Floating</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
infix 4 **=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>&amp;&amp;</a> with a
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &amp;&amp;= True; _2 &amp;&amp;= False; _3 &amp;&amp;= True; _4 &amp;&amp;= False) (True,True,False,False)
--   (True,False,False,False)
--   </pre>
--   
--   <pre>
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>&amp;&amp;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 &&=

-- | Modify the target(s) of a <a>Lens'</a>, 'Iso, <a>Setter</a> or
--   <a>Traversal</a> by taking their logical <a>||</a> with a value.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)
--   (True,True,True,False)
--   </pre>
--   
--   <pre>
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>Bool</a>    -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>Bool</a>       -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>Bool</a>      -&gt; <a>Bool</a> -&gt; m ()
--   (<a>||=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>Bool</a> -&gt; <a>Bool</a> -&gt; m ()
--   </pre>
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
infix 4 ||=

-- | Run a monadic action, and set all of the targets of a <a>Lens</a>,
--   <a>Setter</a> or <a>Traversal</a> to its result.
--   
--   <pre>
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; m b -&gt; m ()
--   (<a>&lt;~</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; m b -&gt; m ()
--   </pre>
--   
--   As a reasonable mnemonic, this lets you store the result of a monadic
--   action in a <a>Lens</a> rather than in a local variable.
--   
--   <pre>
--   do foo &lt;- bar
--      ...
--   </pre>
--   
--   will store the result in a variable, while
--   
--   <pre>
--   do foo <a>&lt;~</a> bar
--      ...
--   </pre>
--   
--   will store the result in a <a>Lens</a>, <a>Setter</a>, or
--   <a>Traversal</a>.
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
infixr 2 <~

-- | Set with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>_2</a> <a>&lt;.=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>.=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a b    -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a b       -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a b      -&gt; b -&gt; m b
--   (<a>&lt;.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a b -&gt; b -&gt; m b
--   </pre>
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
infix 4 <.=

-- | Set <a>Just</a> a value with pass-through
--   
--   This is useful for chaining assignment without round-tripping through
--   your <a>Monad</a> stack.
--   
--   <pre>
--   do x &lt;- <a>at</a> "foo" <a>&lt;?=</a> ninety_nine_bottles_of_beer_on_the_wall
--   </pre>
--   
--   If you do not need a copy of the intermediate result, then using <tt>l
--   <a>?=</a> d</tt> will avoid unused binding warnings.
--   
--   <pre>
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter</a> s s a (<a>Maybe</a> b)    -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso</a> s s a (<a>Maybe</a> b)       -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens</a> s s a (<a>Maybe</a> b)      -&gt; b -&gt; m b
--   (<a>&lt;?=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal</a> s s a (<a>Maybe</a> b) -&gt; b -&gt; m b
--   </pre>
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
infix 4 <?=

-- | Modify the target of a <a>Semigroup</a> value by using
--   <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,b) &amp; _1 &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Sum a,Sum b) &amp; both &lt;&gt;~ Sum c
--   (Sum {getSum = a + c},Sum {getSum = b + c})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;&gt;~ "!!!" $ ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Setter</a> s t a a    -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Iso</a> s t a a       -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Lens</a> s t a a      -&gt; a -&gt; s -&gt; t
--   (<a>&lt;&gt;~</a>) :: <a>Semigroup</a> a =&gt; <a>Traversal</a> s t a a -&gt; a -&gt; s -&gt; t
--   </pre>
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
infixr 4 <>~

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso</a>, <a>Setter</a> or
--   <a>Traversal</a> by using <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 &lt;&gt;= Sum c; _2 &lt;&gt;= Product d) (Sum a,Product b)
--   (Sum {getSum = a + c},Product {getProduct = b * d})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;&gt;= "!!!") ("hello","world")
--   ("hello!!!","world!!!")
--   </pre>
--   
--   <pre>
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Setter'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Iso'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Lens'</a> s a -&gt; a -&gt; m ()
--   (<a>&lt;&gt;=</a>) :: (<a>MonadState</a> s m, <a>Semigroup</a> a) =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   </pre>
(<>=) :: (MonadState s m, Semigroup a) => ASetter' s a -> a -> m ()
infix 4 <>=

-- | Replace every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>.@~</a>) ≡ <a>iset</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>.~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.~</a> b ≡ l <a>.@~</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   (<a>.@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
infixr 4 .@~

-- | Replace every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>.=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>.=</a> b ≡ l <a>.@=</a> <a>const</a> b
--   </pre>
--   
--   <pre>
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; b) -&gt; m ()
--   (<a>.@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; m ()
--   </pre>
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
infix 4 .@=

-- | Adjust every target of an <a>IndexedSetter</a>, <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> with access to the index.
--   
--   <pre>
--   (<a>%@~</a>) ≡ <a>iover</a>
--   </pre>
--   
--   When you do not need access to the index then (<a>%~</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%~</a> f ≡ l <a>%@~</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@~</a>) :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   (<a>%@~</a>) :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
infixr 4 %@~

-- | Adjust every target in the current state of an <a>IndexedSetter</a>,
--   <a>IndexedLens</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you do not need access to the index then (<a>%=</a>) is more
--   liberal in what it can accept.
--   
--   <pre>
--   l <a>%=</a> f ≡ l <a>%@=</a> <a>const</a> f
--   </pre>
--   
--   <pre>
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedSetter</a> i s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedLens</a> i s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   (<a>%@=</a>) :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; m ()
--   </pre>
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
infix 4 %@=


-- | A few extra names that didn't make it into Control.Lens.
module Control.Lens.Extras

-- | Check to see if this <a>Prism</a> matches.
--   
--   <pre>
--   &gt;&gt;&gt; is _Left (Right 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; is hex "3f79"
--   True
--   </pre>
is :: APrism s t a b -> s -> Bool


-- | This lets the subset of users who vociferously disagree about the full
--   scope and set of operators that should be exported from lens to not
--   have to look at any operator with which they disagree.
--   
--   <pre>
--   import Control.Lens.Combinators
--   </pre>
module Control.Lens.Combinators

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap :: (a' -&gt; a) -&gt; (Predicate a -&gt; Predicate a')
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class () => Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a' -> a) -> f a -> f a'

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>. A partially applied
--   <a>Bifunctor</a> must be a <a>Functor</a> and the <a>second</a> method
--   must agree with <a>fmap</a>. From this it follows that:
--   
--   <pre>
--   <a>second</a> <a>id</a> = <a>id</a>
--   </pre>
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   Since 4.18.0.0 <a>Functor</a> is a superclass of 'Bifunctor.
class forall a. () => Functor p a => Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:

-- | The <a>Const</a> functor.
newtype () => Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | Every <a>IndexedTraversal</a> is a valid <a>Traversal</a> or
--   <a>IndexedFold</a>.
--   
--   The <a>Indexed</a> constraint is used to allow an
--   <a>IndexedTraversal</a> to be used directly as a <a>Traversal</a>.
--   
--   The <a>Traversal</a> laws are still required to hold.
--   
--   In addition, the index <tt>i</tt> should satisfy the requirement that
--   it stays unchanged even when modifying the value <tt>a</tt>, otherwise
--   traversals like <tt>indices</tt> break the <a>Traversal</a> laws.
type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) => p a (f b) -> s -> f t

-- | A <a>Traversable</a> with an additional index.
--   
--   An instance must satisfy a (modified) form of the <a>Traversable</a>
--   laws:
--   
--   <pre>
--   <a>itraverse</a> (<tt>const</tt> <a>Identity</a>) ≡ <a>Identity</a>
--   <a>fmap</a> (<a>itraverse</a> f) <a>.</a> <a>itraverse</a> g ≡ <a>getCompose</a> <a>.</a> <a>itraverse</a> (\i -&gt; <a>Compose</a> <a>.</a> <a>fmap</a> (f i) <a>.</a> g i)
--   </pre>
class (FunctorWithIndex i t, FoldableWithIndex i t, Traversable t) => TraversableWithIndex i (t :: Type -> Type) | t -> i

-- | Traverse an indexed container.
--   
--   <pre>
--   <a>itraverse</a> ≡ <tt>itraverseOf</tt> <tt>itraversed</tt>
--   </pre>
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | A container that supports folding with an additional index.
class Foldable f => FoldableWithIndex i (f :: Type -> Type) | f -> i

-- | Fold a container by mapping value to an arbitrary <a>Monoid</a> with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMap</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap</a> ≡ <a>ifoldMap</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | A variant of <a>ifoldMap</a> that is strict in the accumulator.
--   
--   When you don't need access to the index then <a>foldMap'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMap'</a> ≡ <a>ifoldMap'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m

-- | Right-associative fold of an indexed container with access to the
--   index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>ifoldr</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Left-associative fold of an indexed container with access to the index
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldl</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>ifoldl</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | <i>Strictly</i> fold right over the elements of a structure with
--   access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldr'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>ifoldr'</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldl'</a> l ≡ <a>ifoldl'</a> l <a>.</a> <tt>const</tt>
--   </pre>
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | A <a>Functor</a> with an additional index.
--   
--   Instances must satisfy a modified form of the <a>Functor</a> laws:
--   
--   <pre>
--   <a>imap</a> f <a>.</a> <a>imap</a> g ≡ <a>imap</a> (\i -&gt; f i <a>.</a> g i)
--   <a>imap</a> (\_ a -&gt; a) ≡ <a>id</a>
--   </pre>
class Functor f => FunctorWithIndex i (f :: Type -> Type) | f -> i

-- | Map with access to the index.
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b

-- | Used internally by <a>mapM_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
--   
--   See 4.16 Changelog entry for the explanation of "why not Apply f
--   =&gt;"?
data Sequenced a m

-- | Used internally by <a>traverseOf_</a> and the like.
--   
--   The argument <tt>a</tt> of the result should not be used!
data Traversed a f

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class () => Profunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d

-- | Map the first argument contravariantly.
--   
--   <pre>
--   <a>lmap</a> f ≡ <a>dimap</a> f <a>id</a>
--   </pre>
lmap :: Profunctor p => (a -> b) -> p b c -> p a c

-- | Map the second argument covariantly.
--   
--   <pre>
--   <a>rmap</a> ≡ <a>dimap</a> <a>id</a>
--   </pre>
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | The generalization of <a>Costar</a> of <a>Functor</a> that is strong
--   with respect to <a>Either</a>.
--   
--   Note: This is also a notion of strength, except with regards to
--   another monoidal structure that we can choose to equip Hask with: the
--   cocartesian coproduct.
class Profunctor p => Choice (p :: Type -> Type -> Type)

-- | Laws:
--   
--   <pre>
--   <a>left'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>right'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Left</a> ≡ <a>lmap</a> <a>Left</a> <a>.</a> <a>left'</a>
--   <a>lmap</a> (<a>right</a> f) <a>.</a> <a>left'</a> ≡ <a>rmap</a> (<a>right</a> f) <a>.</a> <a>left'</a>
--   <a>left'</a> <a>.</a> <a>left'</a> ≡ <a>dimap</a> assocE unassocE <a>.</a> <a>left'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
left' :: Choice p => p a b -> p (Either a c) (Either b c)

-- | Laws:
--   
--   <pre>
--   <a>right'</a> ≡ <a>dimap</a> swapE swapE <a>.</a> <a>left'</a> where
--     swapE :: <a>Either</a> a b -&gt; <a>Either</a> b a
--     swapE = <a>either</a> <a>Right</a> <a>Left</a>
--   <a>rmap</a> <a>Right</a> ≡ <a>lmap</a> <a>Right</a> <a>.</a> <a>right'</a>
--   <a>lmap</a> (<a>left</a> f) <a>.</a> <a>right'</a> ≡ <a>rmap</a> (<a>left</a> f) <a>.</a> <a>right'</a>
--   <a>right'</a> <a>.</a> <a>right'</a> ≡ <a>dimap</a> unassocE assocE <a>.</a> <a>right'</a> where
--     assocE :: <a>Either</a> (<a>Either</a> a b) c -&gt; <a>Either</a> a (<a>Either</a> b c)
--     assocE (<a>Left</a> (<a>Left</a> a)) = <a>Left</a> a
--     assocE (<a>Left</a> (<a>Right</a> b)) = <a>Right</a> (<a>Left</a> b)
--     assocE (<a>Right</a> c) = <a>Right</a> (<a>Right</a> c)
--     unassocE :: <a>Either</a> a (<a>Either</a> b c) -&gt; <a>Either</a> (<a>Either</a> a b) c
--     unassocE (<a>Left</a> a) = <a>Left</a> (<a>Left</a> a)
--     unassocE (<a>Right</a> (<a>Left</a> b)) = <a>Left</a> (<a>Right</a> b)
--     unassocE (<a>Right</a> (<a>Right</a> c)) = <a>Right</a> c
--   </pre>
right' :: Choice p => p a b -> p (Either c a) (Either c b)

-- | When you see this as an argument to a function, it expects
--   
--   <ul>
--   <li>to be indexed if <tt>p</tt> is an instance of <a>Indexed</a>
--   i,</li>
--   <li>to be unindexed if <tt>p</tt> is <tt>(-&gt;)</tt>,</li>
--   <li>a <a>Traversal</a> if <tt>f</tt> is <a>Applicative</a>,</li>
--   <li>a <a>Getter</a> if <tt>f</tt> is only a <a>Functor</a> and
--   <a>Contravariant</a>,</li>
--   <li>a <a>Lens</a> if <tt>f</tt> is only a <a>Functor</a>,</li>
--   <li>a <a>Fold</a> if <tt>f</tt> is <a>Applicative</a> and
--   <a>Contravariant</a>.</li>
--   </ul>
type Traversing p f s t a b = Over p (BazaarT p f a b) s t a b

-- | Isomorphism families can be composed with another <a>Lens</a> using
--   (<a>.</a>) and <a>id</a>.
--   
--   Since every <a>Iso</a> is both a valid <a>Lens</a> and a valid
--   <a>Prism</a>, the laws for those types imply the following laws for an
--   <a>Iso</a> <tt>f</tt>:
--   
--   <pre>
--   f <a>.</a> <a>from</a> f ≡ <a>id</a>
--   <a>from</a> f <a>.</a> f ≡ <a>id</a>
--   </pre>
--   
--   Note: Composition with an <a>Iso</a> is index- and measure-
--   preserving.
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
class (Foldable1 t, Traversable t) => Traversable1 (t :: Type -> Type)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)

-- | Composable <a>asTypeOf</a>. Useful for constraining excess
--   polymorphism, <tt>foo . (id :: As Int) . bar</tt>.
type As a = Equality' a a

-- | A <a>Lens</a> is actually a lens family as described in
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   With great power comes great responsibility and a <a>Lens</a> is
--   subject to the three common sense <a>Lens</a> laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>view</a> l (<a>set</a> l v s)  ≡ v
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>set</a> l (<a>view</a> l s) s  ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>set</a> l v' (<a>set</a> l v s) ≡ <a>set</a> l v' s
--   </pre>
--   
--   These laws are strong enough that the 4 type parameters of a
--   <a>Lens</a> cannot vary fully independently. For more on how they
--   interact, read the "Why is it a Lens Family?" section of
--   <a>http://comonad.com/reader/2012/mirrored-lenses/</a>.
--   
--   There are some emergent properties of these laws:
--   
--   1) <tt><a>set</a> l s</tt> must be injective for every <tt>s</tt> This
--   is a consequence of law #1
--   
--   2) <tt><a>set</a> l</tt> must be surjective, because of law #2, which
--   indicates that it is possible to obtain any <tt>v</tt> from some
--   <tt>s</tt> such that <tt><a>set</a> s v = s</tt>
--   
--   3) Given just the first two laws you can prove a weaker form of law #3
--   where the values <tt>v</tt> that you are setting match:
--   
--   <pre>
--   <a>set</a> l v (<a>set</a> l v s) ≡ <a>set</a> l v s
--   </pre>
--   
--   Every <a>Lens</a> can be used directly as a <a>Setter</a> or
--   <a>Traversal</a>.
--   
--   You can also use a <a>Lens</a> for <a>Getting</a> as if it were a
--   <a>Fold</a> or <a>Getter</a>.
--   
--   Since every <a>Lens</a> is a valid <a>Traversal</a>, the
--   <a>Traversal</a> laws are required of any <a>Lens</a> you create:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (l f) <a>.</a> l g ≡ <a>getCompose</a> <a>.</a> l (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   type <a>Lens</a> s t a b = forall f. <a>Functor</a> f =&gt; <a>LensLike</a> f s t a b
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>.</a> <a>traverse</a>
--   </pre>
class Ixed m => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^.at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <a>Array</a>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (a, <a>Vector</a> a) (b, <a>Vector</a> b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>Text</a> (<a>Char</a>, <a>Text</a>)
--   <a>_Cons</a> :: <a>Prism'</a> <a>ByteString</a> (<a>Word8</a>, <a>ByteString</a>)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   Notably, when applied to a tuple, this generalizes <a>both</a> to
--   arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3) &amp; each *~ 10
--   (10,20,30)
--   </pre>
--   
--   It can also be used on monomorphic containers like <a>Text</a> or
--   <a>ByteString</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over each Char.toUpper ("hello"^.Text.packed)
--   "HELLO"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") &amp; each.each %~ Char.toUpper
--   ("HELLO","WORLD")
--   </pre>
class Each s t a b | s -> a, t -> b, s b -> t, t a -> s
each :: Each s t a b => Traversal s t a b
each :: (Each s t a b, Traversable g, s ~ g a, t ~ g b) => Traversal s t a b

-- | A witness that <tt>(a ~ s, b ~ t)</tt>.
--   
--   Note: Composition with an <a>Equality</a> is index-preserving.
type Equality (s :: k1) (t :: k2) (a :: k1) (b :: k2) = forall k3 (p :: k1 -> k3 -> Type) (f :: k2 -> k3). p a (f b) -> p s (f t)

-- | A <a>Fold</a> describes how to retrieve multiple values in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   A <tt><a>Fold</a> s a</tt> provides a structure with operations very
--   similar to those of the <a>Foldable</a> typeclass, see
--   <a>foldMapOf</a> and the other <a>Fold</a> combinators.
--   
--   By convention, if there exists a <tt>foo</tt> method that expects a
--   <tt><a>Foldable</a> (f a)</tt>, then there should be a <tt>fooOf</tt>
--   method that takes a <tt><a>Fold</a> s a</tt> and a value of type
--   <tt>s</tt>.
--   
--   A <a>Getter</a> is a legal <a>Fold</a> that just ignores the supplied
--   <a>Monoid</a>.
--   
--   Unlike a <a>Traversal</a> a <a>Fold</a> is read-only. Since a
--   <a>Fold</a> cannot be used to write back there are no <a>Lens</a> laws
--   that apply.
type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s

-- | A function with access to a index. This constructor may be useful when
--   you need to store an <a>Indexable</a> in a container to avoid
--   <tt>ImpredicativeTypes</tt>.
--   
--   <pre>
--   index :: Indexed i a b -&gt; i -&gt; a -&gt; b
--   </pre>
newtype Indexed i a b
Indexed :: (i -> a -> b) -> Indexed i a b
[runIndexed] :: Indexed i a b -> i -> a -> b

-- | This data type represents a path-compressed copy of one level of a
--   source data structure. We can safely use path-compression because we
--   know the depth of the tree.
--   
--   Path compression is performed by viewing a <a>Level</a> as a PATRICIA
--   trie of the paths into the structure to leaves at a given depth,
--   similar in many ways to a <a>IntMap</a>, but unlike a regular PATRICIA
--   trie we do not need to store the mask bits merely the depth of the
--   fork.
--   
--   One invariant of this structure is that underneath a <a>Two</a> node
--   you will not find any <a>Zero</a> nodes, so <a>Zero</a> can only occur
--   at the root.
data Level i a

-- | A <a>Plated</a> type is one where we know how to extract its immediate
--   self-similar children.
--   
--   <i>Example 1</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Expr
--     = Val <a>Int</a>
--     | Neg Expr
--     | Add Expr Expr
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> f (Neg e) = Neg <a>&lt;$&gt;</a> f e
--     <a>plate</a> f (Add a b) = Add <a>&lt;$&gt;</a> f a <a>&lt;*&gt;</a> f b
--     <a>plate</a> _ a = <a>pure</a> a
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Plated</a> Expr where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   <i>Example 2</i>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Lens
--   import Control.Lens.Plated
--   import Data.Data
--   import Data.Data.Lens (<a>uniplate</a>)
--   </pre>
--   
--   <pre>
--   data Tree a
--     = Bin (Tree a) (Tree a)
--     | Tip a
--     deriving (<a>Eq</a>,<a>Ord</a>,<a>Show</a>,<a>Read</a>,<a>Data</a>)
--   </pre>
--   
--   <pre>
--   instance <a>Plated</a> (Tree a) where
--     <a>plate</a> f (Bin l r) = Bin <a>&lt;$&gt;</a> f l <a>&lt;*&gt;</a> f r
--     <a>plate</a> _ t = <a>pure</a> t
--   </pre>
--   
--   <i>or</i>
--   
--   <pre>
--   instance <a>Data</a> a =&gt; <a>Plated</a> (Tree a) where
--     <a>plate</a> = <a>uniplate</a>
--   </pre>
--   
--   Note the big distinction between these two implementations.
--   
--   The former will only treat children directly in this tree as
--   descendents, the latter will treat trees contained in the values under
--   the tips also as descendants!
--   
--   When in doubt, pick a <a>Traversal</a> and just use the various
--   <tt>...Of</tt> combinators rather than pollute <a>Plated</a> with
--   orphan instances!
--   
--   If you want to find something unplated and non-recursive with
--   <a>biplate</a> use the <tt>...OnOf</tt> variant with <a>ignored</a>,
--   though those usecases are much better served in most cases by using
--   the existing <a>Lens</a> combinators! e.g.
--   
--   <pre>
--   <a>toListOf</a> <a>biplate</a> ≡ <a>universeOnOf</a> <a>biplate</a> <a>ignored</a>
--   </pre>
--   
--   This same ability to explicitly pass the <a>Traversal</a> in question
--   is why there is no analogue to uniplate's <tt>Biplate</tt>.
--   
--   Moreover, since we can allow custom traversals, we implement
--   reasonable defaults for polymorphic data types, that only
--   <a>traverse</a> into themselves, and <i>not</i> their polymorphic
--   arguments.
class Plated a

-- | <a>Traversal</a> of the immediate children of this structure.
--   
--   If you're using GHC 7.2 or newer and your type has a <a>Data</a>
--   instance, <a>plate</a> will default to <a>uniplate</a> and you can
--   choose to not override it with your own definition.
plate :: Plated a => Traversal' a a

-- | <a>Traversal</a> of the immediate children of this structure.
--   
--   If you're using GHC 7.2 or newer and your type has a <a>Data</a>
--   instance, <a>plate</a> will default to <a>uniplate</a> and you can
--   choose to not override it with your own definition.
plate :: (Plated a, Data a) => Traversal' a a

-- | A <a>Prism</a> <tt>l</tt> is a <a>Traversal</a> that can also be
--   turned around with <a>re</a> to obtain a <a>Getter</a> in the opposite
--   direction.
--   
--   There are three laws that a <a>Prism</a> should satisfy:
--   
--   First, if I <a>re</a> or <a>review</a> a value with a <a>Prism</a> and
--   then <a>preview</a> or use (<a>^?</a>), I will get it back:
--   
--   <pre>
--   <a>preview</a> l (<a>review</a> l b) ≡ <a>Just</a> b
--   </pre>
--   
--   Second, if you can extract a value <tt>a</tt> using a <a>Prism</a>
--   <tt>l</tt> from a value <tt>s</tt>, then the value <tt>s</tt> is
--   completely described by <tt>l</tt> and <tt>a</tt>:
--   
--   <pre>
--   <a>preview</a> l s ≡ <a>Just</a> a ⟹ <a>review</a> l a ≡ s
--   </pre>
--   
--   Third, if you get non-match <tt>t</tt>, you can convert it result back
--   to <tt>s</tt>:
--   
--   <pre>
--   <a>matching</a> l s ≡ <a>Left</a> t ⟹ <a>matching</a> l t ≡ <a>Left</a> s
--   </pre>
--   
--   The first two laws imply that the <a>Traversal</a> laws hold for every
--   <a>Prism</a> and that we <a>traverse</a> at most 1 element:
--   
--   <pre>
--   <a>lengthOf</a> l x <a>&lt;=</a> 1
--   </pre>
--   
--   It may help to think of this as an <a>Iso</a> that can be partial in
--   one direction.
--   
--   Every <a>Prism</a> is a valid <a>Traversal</a>.
--   
--   Every <a>Iso</a> is a valid <a>Prism</a>.
--   
--   For example, you might have a <tt><a>Prism'</a> <a>Integer</a>
--   <a>Natural</a></tt> allows you to always go from a <a>Natural</a> to
--   an <a>Integer</a>, and provide you with tools to check if an
--   <a>Integer</a> is a <a>Natural</a> and/or to edit one if it is.
--   
--   <pre>
--   <tt>nat</tt> :: <a>Prism'</a> <a>Integer</a> <a>Natural</a>
--   <tt>nat</tt> = <a>prism</a> <a>toInteger</a> <a>$</a> \ i -&gt;
--      if i <a>&lt;</a> 0
--      then <a>Left</a> i
--      else <a>Right</a> (<a>fromInteger</a> i)
--   </pre>
--   
--   Now we can ask if an <a>Integer</a> is a <a>Natural</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5^?nat
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (-5)^?nat
--   Nothing
--   </pre>
--   
--   We can update the ones that are:
--   
--   <pre>
--   &gt;&gt;&gt; (-3,4) &amp; both.nat *~ 2
--   (-3,8)
--   </pre>
--   
--   And we can then convert from a <a>Natural</a> to an <a>Integer</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^. re nat -- :: Natural
--   5
--   </pre>
--   
--   Similarly we can use a <a>Prism</a> to <a>traverse</a> the <a>Left</a>
--   half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" &amp; _Left %~ length
--   Left 5
--   </pre>
--   
--   or to construct an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
--   
--   such that if you query it with the <a>Prism</a>, you will get your
--   original input back.
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left ^? _Left
--   Just 5
--   </pre>
--   
--   Another interesting way to think of a <a>Prism</a> is as the
--   categorical dual of a <a>Lens</a> -- a co-<a>Lens</a>, so to speak.
--   This is what permits the construction of <a>outside</a>.
--   
--   Note: Composition with a <a>Prism</a> is index-preserving.
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)

-- | This is a limited form of a <a>Prism</a> that can only be used for
--   <tt>re</tt> operations.
--   
--   Like with a <a>Getter</a>, there are no laws to state for a
--   <a>Review</a>.
--   
--   You can generate a <a>Review</a> by using <tt>unto</tt>. You can also
--   use any <a>Prism</a> or <a>Iso</a> directly as a <a>Review</a>.
type Review t b = forall p f. (Choice p, Bifunctor p, Settable f) => Optic' p f t b

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a) ≡ <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <a>id</a> ≡ <a>id</a>
--   <a>over</a> l f <a>.</a> <a>over</a> l g ≡ <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l f <a>.</a> <a>untainted</a> <a>.</a> l g ≡ l (f <a>.</a> <a>untainted</a> <a>.</a> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<a>.</a>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall f. Settable f => (a -> f b) -> s -> f t

-- | A <a>Traversal</a> can be used directly as a <a>Setter</a> or a
--   <a>Fold</a> (but not as a <a>Lens</a>) and provides the ability to
--   both read and update multiple fields, subject to some relatively weak
--   <a>Traversal</a> laws.
--   
--   These have also been known as multilenses, but they have the signature
--   and spirit of
--   
--   <pre>
--   <a>traverse</a> :: <a>Traversable</a> f =&gt; <a>Traversal</a> (f a) (f b) a b
--   </pre>
--   
--   and the more evocative name suggests their application.
--   
--   Most of the time the <a>Traversal</a> you will want to use is just
--   <a>traverse</a>, but you can also pass any <a>Lens</a> or <a>Iso</a>
--   as a <a>Traversal</a>, and composition of a <a>Traversal</a> (or
--   <a>Lens</a> or <a>Iso</a>) with a <a>Traversal</a> (or <a>Lens</a> or
--   <a>Iso</a>) using (<a>.</a>) forms a valid <a>Traversal</a>.
--   
--   The laws for a <a>Traversal</a> <tt>t</tt> follow from the laws for
--   <a>Traversable</a> as stated in "The Essence of the Iterator Pattern".
--   
--   <pre>
--   t <a>pure</a> ≡ <a>pure</a>
--   <a>fmap</a> (t f) <a>.</a> t g ≡ <a>getCompose</a> <a>.</a> t (<a>Compose</a> <a>.</a> <a>fmap</a> f <a>.</a> g)
--   </pre>
--   
--   One consequence of this requirement is that a <a>Traversal</a> needs
--   to leave the same number of elements as a candidate for subsequent
--   <a>Traversal</a> that it started with. Another testament to the
--   strength of these laws is that the caveat expressed in section 5.5 of
--   the "Essence of the Iterator Pattern" about exotic <a>Traversable</a>
--   instances that <a>traverse</a> the same entry multiple times was
--   actually already ruled out by the second law in that same paper!
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type Unwrapped s :: Type;
    type Unwrapped s = GUnwrapped (Rep s);
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: (Wrapped s, Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)

-- | This class allows us to use <a>zoom</a> in, changing the <a>State</a>
--   supplied by many different <a>Monad</a> transformers, potentially
--   quite deep in a <a>Monad</a> transformer stack.
class (MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m

-- | Run a monadic action in a larger <a>State</a> than it was defined in,
--   using a <a>Lens'</a> or <a>Traversal'</a>.
--   
--   This is commonly used to lift actions in a simpler <a>State</a>
--   <a>Monad</a> into a <a>State</a> <a>Monad</a> with a larger
--   <a>State</a> type.
--   
--   When applied to a <a>Traversal'</a> over multiple values, the actions
--   for each target are executed sequentially and the results are
--   aggregated.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with a <a>State</a> in it!
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom _1 $ use id
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState (a,b) $ zoom _1 $ id .= c
--   (c,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.execState [(a,b),(c,d)] $ zoom traverse $ _2 %= f
--   [(a,f b),(c,f d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.runState [(a,b),(c,d)] $ zoom traverse $ _2 &lt;%= f
--   (f b &lt;&gt; f d &lt;&gt; mempty,[(a,f b),(c,f d)])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip State.evalState (a,b) $ zoom both (use id)
--   a &lt;&gt; b
--   </pre>
--   
--   <pre>
--   <a>zoom</a> :: <a>Monad</a> m             =&gt; <a>Lens'</a> s t      -&gt; <a>StateT</a> t m a -&gt; <a>StateT</a> s m a
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>StateT</a> t m c -&gt; <a>StateT</a> s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w)             =&gt; <a>Lens'</a> s t      -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Traversal'</a> s t -&gt; <a>RWST</a> r w t m c -&gt; <a>RWST</a> r w s m c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <tt>Error</tt> e)  =&gt; <a>Lens'</a> s t      -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w t m) c -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w s m) c
--   <a>zoom</a> :: (<a>Monad</a> m, <a>Monoid</a> w, <a>Monoid</a> c, <tt>Error</tt> e) =&gt; <a>Traversal'</a> s t -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w t m) c -&gt; <tt>ErrorT</tt> e (<a>RWST</a> r w s m) c
--   ...
--   </pre>
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
infixr 2 `zoom`
type family Index (s :: Type) :: Type

-- | This provides a common notion of a value at an index that is shared by
--   both <a>Ixed</a> and <a>At</a>.
type family IxValue (m :: Type) :: Type

-- | Provides a simple <a>Traversal</a> lets you <a>traverse</a> the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class Ixed m

-- | <i>NB:</i> Setting the value of this <a>Traversal</a> will only set
--   the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 %~ f
--   fromList [a,b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 .~ e
--   fromList [a,b,e,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? ix 2
--   Just c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Traversal' m (IxValue m)

-- | <i>NB:</i> Setting the value of this <a>Traversal</a> will only set
--   the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 %~ f
--   fromList [a,b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; ix 2 .~ e
--   fromList [a,b,e,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? ix 2
--   Just c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? ix 2
--   Nothing
--   </pre>
ix :: (Ixed m, At m) => Index m -> Traversal' m (IxValue m)

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>.
class Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Snoc</a> :: <a>Prism</a> [a] [b] ([a], a) ([b], b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (<a>Seq</a> a, a) (<a>Seq</a> b, b)
--   <a>_Snoc</a> :: <a>Prism</a> (<a>Vector</a> a) (<a>Vector</a> b) (<a>Vector</a> a, a) (<a>Vector</a> b, b)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>String</a> (<a>String</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>Text</a> (<a>Text</a>, <a>Char</a>)
--   <a>_Snoc</a> :: <a>Prism'</a> <a>ByteString</a> (<a>ByteString</a>, <a>Word8</a>)
--   </pre>
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)
class AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()

-- | A <a>Simple</a> <a>Equality</a>.
type Equality' s a = Equality s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Equality</a>.
type AnEquality s t a b = Identical a (Proxy b) a (Proxy b) -> Identical a (Proxy b) s (Proxy t)

-- | A <a>Simple</a> <a>AnEquality</a>.
type AnEquality' s a = AnEquality s s a a

-- | Provides witness that <tt>(s ~ a, b ~ t)</tt> holds.
data Identical a b s t
[Identical] :: Identical a b a b

-- | Every <a>IndexedFold</a> is a valid <a>Fold</a> and can be used for
--   <a>Getting</a>.
type IndexedFold i s a = forall p f. (Indexable i p, Contravariant f, Applicative f) => p a (f a) -> s -> f s

-- | Used for <a>firstOf</a>.
data Leftmost a

-- | Used for <a>lastOf</a>.
data Rightmost a

-- | This provides a way to peek at the internal structure of a
--   <a>Traversal</a> or <a>IndexedTraversal</a>
data Magma i t b a

-- | Every <a>IndexedGetter</a> is a valid <a>IndexedFold</a> and can be
--   used for <a>Getting</a> like a <a>Getter</a>.
type IndexedGetter i s a = forall p f. (Indexable i p, Contravariant f, Functor f) => p a (f a) -> s -> f s

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | Used to consume an <a>IndexedFold</a>.
type IndexedGetting i m s a = Indexed i a (Const m a) -> s -> Const m s

-- | This is a convenient alias used when consuming (indexed) getters and
--   (indexed) folds in a highly general fashion.
type Accessing p m s a = p a (Const m a) -> s -> Const m s

-- | This class permits overloading of function application for things that
--   also admit a notion of a key or index.
class Conjoined p => Indexable i p

-- | Build a function from an <a>indexed</a> function.
indexed :: Indexable i p => p a b -> i -> a -> b

-- | This is a <a>Profunctor</a> that is both <a>Corepresentable</a> by
--   <tt>f</tt> and <a>Representable</a> by <tt>g</tt> such that <tt>f</tt>
--   is left adjoint to <tt>g</tt>. From this you can derive a lot of
--   structure due to the preservation of limits and colimits.
class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), Costrong p, ArrowLoop p, ArrowApply p, ArrowChoice p, Closed p) => Conjoined p

-- | <a>Conjoined</a> is strong enough to let us distribute every
--   <a>Conjoined</a> <a>Profunctor</a> over every Haskell <a>Functor</a>.
--   This is effectively a generalization of <a>fmap</a>.
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)

-- | This permits us to make a decision at an outermost point about whether
--   or not we use an index.
--   
--   Ideally any use of this function should be done in such a way so that
--   you compute the same answer, but this cannot be enforced at the type
--   level.
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar</a> a b t</tt>
--   holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar</a> holds many stores and you can easily add
--   more.
--   
--   This is a final encoding of <a>Bazaar</a>.
newtype Bazaar p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
[runBazaar] :: Bazaar p a b t -> forall f. Applicative f => p a (f b) -> f t

-- | The indexed store can be used to characterize a <a>Lens</a> and is
--   used by <a>cloneLens</a>.
--   
--   <tt><a>Context</a> a b t</tt> is isomorphic to <tt>newtype
--   <a>Context</a> a b t = <a>Context</a> { runContext :: forall f.
--   <a>Functor</a> f =&gt; (a -&gt; f b) -&gt; f t }</tt>, and to
--   <tt>exists s. (s, <a>Lens</a> s t a b)</tt>.
--   
--   A <a>Context</a> is like a <a>Lens</a> that has already been applied
--   to a some structure.
data Context a b t
Context :: (b -> t) -> a -> Context a b t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar'</a> p a t = <a>Bazaar</a> p a a t
--   </pre>
type Bazaar' p a = Bazaar p a a

-- | This is used to characterize a <a>Traversal</a>.
--   
--   a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad,
--   or an indexed <tt>FunList</tt>.
--   
--   <a>http://twanvl.nl/blog/haskell/non-regular1</a>
--   
--   A <a>Bazaar1</a> is like a <a>Traversal</a> that has already been
--   applied to some structure.
--   
--   Where a <tt><a>Context</a> a b t</tt> holds an <tt>a</tt> and a
--   function from <tt>b</tt> to <tt>t</tt>, a <tt><a>Bazaar1</a> a b
--   t</tt> holds <tt>N</tt> <tt>a</tt>s and a function from <tt>N</tt>
--   <tt>b</tt>s to <tt>t</tt>, (where <tt>N</tt> might be infinite).
--   
--   Mnemonically, a <a>Bazaar1</a> holds many stores and you can easily
--   add more.
--   
--   This is a final encoding of <a>Bazaar1</a>.
newtype Bazaar1 p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
[runBazaar1] :: Bazaar1 p a b t -> forall f. Apply f => p a (f b) -> f t

-- | This alias is helpful when it comes to reducing repetition in type
--   signatures.
--   
--   <pre>
--   type <a>Bazaar1'</a> p a t = <a>Bazaar1</a> p a a t
--   </pre>
type Bazaar1' p a = Bazaar1 p a a

-- | <pre>
--   type <a>Context'</a> a s = <a>Context</a> a a s
--   </pre>
type Context' a = Context a a

-- | Rules to construct lenses for data fields.
data LensRules

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of all fields (including the field being named) in the data type. [Name] -> -- | Name of the field being named. Name -> -- | Name(s) of the lens functions. If empty, no lens is created for that field. [DefName]

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definition name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of the class and the main method it generates, respectively. Maybe (Name, Name)

-- | This class provides a generalized notion of list reversal extended to
--   other containers.
class Reversing t
reversing :: Reversing t => t -> t

-- | This class is provided mostly for backwards compatibility with lens
--   3.8, but it can also shorten type signatures.
class (Profunctor p, Bifunctor p) => Reviewable p

-- | Anything <a>Settable</a> must be isomorphic to the <a>Identity</a>
--   <a>Functor</a>.
class (Applicative f, Distributive f, Traversable f) => Settable f

-- | <pre>
--   type <a>Iso'</a> = <a>Simple</a> <a>Iso</a>
--   </pre>
type Iso' s a = Iso s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>Iso</a>.
type AnIso s t a b = Exchange a b a (Identity b) -> Exchange a b s (Identity t)

-- | A <a>Simple</a> <a>AnIso</a>.
type AnIso' s a = AnIso s s a a

-- | <pre>
--   type <a>Lens'</a> = <a>Simple</a> <a>Lens</a>
--   </pre>
type Lens' s a = Lens s s a a

-- | Every <a>IndexedLens</a> is a valid <a>Lens</a> and a valid
--   <a>IndexedTraversal</a>.
type IndexedLens i s t a b = forall f p. (Indexable i p, Functor f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedLens'</a> i = <a>Simple</a> (<a>IndexedLens</a> i)
--   </pre>
type IndexedLens' i s a = IndexedLens i s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Lens</a>.
--   
--   This type can also be used when you need to store a <a>Lens</a> in a
--   container, since it is rank-1. You can turn them back into a
--   <a>Lens</a> with <a>cloneLens</a>, or use it directly with combinators
--   like <a>storing</a> and (<a>^#</a>).
type ALens s t a b = LensLike (Pretext (->) a b) s t a b

-- | <pre>
--   type <a>ALens'</a> = <a>Simple</a> <a>ALens</a>
--   </pre>
type ALens' s a = ALens s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedLens</a>
type AnIndexedLens i s t a b = Optical (Indexed i) (->) (Pretext (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedLens'</a> = <a>Simple</a> (<a>AnIndexedLens</a> i)
--   </pre>
type AnIndexedLens' i s a = AnIndexedLens i s s a a
class GPlated a g
class GPlated1 f g

-- | A <a>Simple</a> <a>Prism</a>.
type Prism' s a = Prism s s a a

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Prism</a>.
type APrism s t a b = Market a b a (Identity b) -> Market a b s (Identity t)

-- | <pre>
--   type APrism' = <a>Simple</a> <a>APrism</a>
--   </pre>
type APrism' s a = APrism s s a a
class Prefixed t

-- | A <a>Prism</a> stripping a prefix from a sequence when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Prefixed t => t -> Prism' t t
class Suffixed t

-- | A <a>Prism</a> stripping a suffix from a sequence when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Suffixed t => t -> Prism' t t

-- | A valid <a>Optic</a> <tt>l</tt> should satisfy the laws:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l (<tt>Procompose</tt> f g) = <tt>Procompose</tt> (l f) (l g)
--   </pre>
--   
--   This gives rise to the laws for <a>Equality</a>, <a>Iso</a>,
--   <a>Prism</a>, <a>Lens</a>, <a>Traversal</a>, <a>Traversal1</a>,
--   <a>Setter</a>, <a>Fold</a>, <a>Fold1</a>, and <a>Getter</a> as well
--   along with their index-preserving variants.
--   
--   <pre>
--   type <a>LensLike</a> f s t a b = <a>Optic</a> (-&gt;) f s t a b
--   </pre>
type Optic p f s t a b = p a (f b) -> p s (f t)

-- | Many combinators that accept a <a>Lens</a> can also accept a
--   <a>Traversal</a> in limited situations.
--   
--   They do so by specializing the type of <a>Functor</a> that they
--   require of the caller.
--   
--   If a function accepts a <tt><a>LensLike</a> f s t a b</tt> for some
--   <a>Functor</a> <tt>f</tt>, then they may be passed a <a>Lens</a>.
--   
--   Further, if <tt>f</tt> is an <a>Applicative</a>, they may also be
--   passed a <a>Traversal</a>.
type LensLike f s t a b = (a -> f b) -> s -> f t

-- | Running a <a>Setter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal</a>.
type ATraversal s t a b = LensLike (Bazaar (->) a b) s t a b

-- | Reify a <a>Lens</a> so it can be stored safely in a container.
newtype ReifiedLens s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
[runLens] :: ReifiedLens s t a b -> Lens s t a b

-- | If you see this in a signature for a function, the function is
--   expecting a <a>Review</a> (in practice, this usually means a
--   <a>Prism</a>).
type AReview t b = Optic' Tagged Identity t b

-- | A <a>Setter'</a> is just a <a>Setter</a> that doesn't change the
--   types.
--   
--   These are particularly common when talking about monomorphic
--   containers. <i>e.g.</i>
--   
--   <pre>
--   <tt>sets</tt> Data.Text.map :: <a>Setter'</a> <a>Text</a> <a>Char</a>
--   </pre>
--   
--   <pre>
--   type <a>Setter'</a> = <a>Simple</a> <a>Setter</a>
--   </pre>
type Setter' s a = Setter s s a a

-- | Every <a>IndexedSetter</a> is a valid <a>Setter</a>.
--   
--   The <a>Setter</a> laws are still required to hold.
type IndexedSetter i s t a b = forall f p. (Indexable i p, Settable f) => p a (f b) -> s -> f t

-- | <pre>
--   type <a>IndexedSetter'</a> i = <a>Simple</a> (<a>IndexedSetter</a> i)
--   </pre>
type IndexedSetter' i s a = IndexedSetter i s s a a

-- | This is a useful alias for use when consuming a <a>Setter'</a>.
--   
--   Most user code will never have to use this type.
--   
--   <pre>
--   type <a>ASetter'</a> = <a>Simple</a> <a>ASetter</a>
--   </pre>
type ASetter' s a = ASetter s s a a

-- | Running an <a>IndexedSetter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type AnIndexedSetter i s t a b = Indexed i a (Identity b) -> s -> Identity t

-- | <pre>
--   type <a>AnIndexedSetter'</a> i = <a>Simple</a> (<a>AnIndexedSetter</a> i)
--   </pre>
type AnIndexedSetter' i s a = AnIndexedSetter i s s a a

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter</a> and <a>AnIndexedSetter</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting p s t a b = p a (Identity b) -> s -> Identity t

-- | This is a convenient alias when defining highly polymorphic code that
--   takes both <a>ASetter'</a> and <a>AnIndexedSetter'</a> as appropriate.
--   If a function takes this it is expecting one of those two things based
--   on context.
type Setting' p s a = Setting p s s a a

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | A <a>Traversal</a> which targets at least one element.
--   
--   Note that since <a>Apply</a> is not a superclass of
--   <a>Applicative</a>, a <a>Traversal1</a> cannot always be used in place
--   of a <a>Traversal</a>. In such circumstances <a>cloneTraversal</a>
--   will convert a <a>Traversal1</a> into a <a>Traversal</a>.
type Traversal1 s t a b = forall f. Apply f => (a -> f b) -> s -> f t
type Traversal1' s a = Traversal1 s s a a

-- | <pre>
--   type <a>IndexedTraversal'</a> i = <a>Simple</a> (<a>IndexedTraversal</a> i)
--   </pre>
type IndexedTraversal' i s a = IndexedTraversal i s s a a
type IndexedTraversal1 i s t a b = forall p f. (Indexable i p, Apply f) => p a (f b) -> s -> f t
type IndexedTraversal1' i s a = IndexedTraversal1 i s s a a

-- | <pre>
--   type <a>ATraversal'</a> = <a>Simple</a> <a>ATraversal</a>
--   </pre>
type ATraversal' s a = ATraversal s s a a

-- | When you see this as an argument to a function, it expects a
--   <a>Traversal1</a>.
type ATraversal1 s t a b = LensLike (Bazaar1 (->) a b) s t a b

-- | <pre>
--   type <a>ATraversal1'</a> = <a>Simple</a> <a>ATraversal1</a>
--   </pre>
type ATraversal1' s a = ATraversal1 s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal</a>.
type AnIndexedTraversal i s t a b = Over (Indexed i) (Bazaar (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal'</a> = <a>Simple</a> (<a>AnIndexedTraversal</a> i)
--   </pre>
type AnIndexedTraversal' i s a = AnIndexedTraversal i s s a a

-- | When you see this as an argument to a function, it expects an
--   <a>IndexedTraversal1</a>.
type AnIndexedTraversal1 i s t a b = Over (Indexed i) (Bazaar1 (Indexed i) a b) s t a b

-- | <pre>
--   type <a>AnIndexedTraversal1'</a> = <a>Simple</a> (<a>AnIndexedTraversal1</a> i)
--   </pre>
type AnIndexedTraversal1' i s a = AnIndexedTraversal1 i s s a a

-- | <pre>
--   type <a>Traversing'</a> f = <a>Simple</a> (<a>Traversing</a> f)
--   </pre>
type Traversing' p f s a = Traversing p f s s a a
type Traversing1 p f s t a b = Over p (BazaarT1 p f a b) s t a b
type Traversing1' p f s a = Traversing1 p f s s a a

-- | Allows <a>IndexedTraversal</a> the value at the smallest index.
class Ord k => TraverseMin k m | m -> k

-- | <a>IndexedTraversal</a> of the element with the smallest index.
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v

-- | Allows <a>IndexedTraversal</a> of the value at the largest index.
class Ord k => TraverseMax k m | m -> k

-- | <a>IndexedTraversal</a> of the element at the largest index.
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: (Field1 s t a b, Generic s, Generic t, GIxed N0 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: (Field2 s t a b, Generic s, Generic t, GIxed N1 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 3rd field of a tuple.
_3 :: Field3 s t a b => Lens s t a b

-- | Access the 3rd field of a tuple.
_3 :: (Field3 s t a b, Generic s, Generic t, GIxed N2 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 4th field of a tuple.
_4 :: Field4 s t a b => Lens s t a b

-- | Access the 4th field of a tuple.
_4 :: (Field4 s t a b, Generic s, Generic t, GIxed N3 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 5th field of a tuple.
_5 :: Field5 s t a b => Lens s t a b

-- | Access the 5th field of a tuple.
_5 :: (Field5 s t a b, Generic s, Generic t, GIxed N4 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 6th field of a tuple.
_6 :: Field6 s t a b => Lens s t a b

-- | Access the 6th field of a tuple.
_6 :: (Field6 s t a b, Generic s, Generic t, GIxed N5 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 7th field of a tuple.
_7 :: Field7 s t a b => Lens s t a b

-- | Access the 7th field of a tuple.
_7 :: (Field7 s t a b, Generic s, Generic t, GIxed N6 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 8th field of a tuple.
_8 :: Field8 s t a b => Lens s t a b

-- | Access the 8th field of a tuple.
_8 :: (Field8 s t a b, Generic s, Generic t, GIxed N7 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 9th field of a tuple.
_9 :: Field9 s t a b => Lens s t a b

-- | Access the 9th field of a tuple.
_9 :: (Field9 s t a b, Generic s, Generic t, GIxed N8 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 10th field of a tuple.
class Field10 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 10th field of a tuple.
_10 :: Field10 s t a b => Lens s t a b

-- | Access the 10th field of a tuple.
_10 :: (Field10 s t a b, Generic s, Generic t, GIxed N9 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 11th field of a tuple.
class Field11 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 11th field of a tuple.
_11 :: Field11 s t a b => Lens s t a b

-- | Access the 11th field of a tuple.
_11 :: (Field11 s t a b, Generic s, Generic t, GIxed N10 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 12th field of a tuple.
class Field12 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 12th field of a tuple.
_12 :: Field12 s t a b => Lens s t a b

-- | Access the 12th field of a tuple.
_12 :: (Field12 s t a b, Generic s, Generic t, GIxed N11 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 13th field of a tuple.
class Field13 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 13th field of a tuple.
_13 :: Field13 s t a b => Lens s t a b

-- | Access the 13th field of a tuple.
_13 :: (Field13 s t a b, Generic s, Generic t, GIxed N12 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 14th field of a tuple.
class Field14 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 14th field of a tuple.
_14 :: Field14 s t a b => Lens s t a b

-- | Access the 14th field of a tuple.
_14 :: (Field14 s t a b, Generic s, Generic t, GIxed N13 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 15th field of a tuple.
class Field15 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 15th field of a tuple.
_15 :: Field15 s t a b => Lens s t a b

-- | Access the 15th field of a tuple.
_15 :: (Field15 s t a b, Generic s, Generic t, GIxed N14 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 16th field of a tuple.
class Field16 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 16th field of a tuple.
_16 :: Field16 s t a b => Lens s t a b

-- | Access the 16th field of a tuple.
_16 :: (Field16 s t a b, Generic s, Generic t, GIxed N15 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 17th field of a tuple.
class Field17 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 17th field of a tuple.
_17 :: Field17 s t a b => Lens s t a b

-- | Access the 17th field of a tuple.
_17 :: (Field17 s t a b, Generic s, Generic t, GIxed N16 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 18th field of a tuple.
class Field18 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 18th field of a tuple.
_18 :: Field18 s t a b => Lens s t a b

-- | Access the 18th field of a tuple.
_18 :: (Field18 s t a b, Generic s, Generic t, GIxed N17 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 19th field of a tuple.
class Field19 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 19th field of a tuple.
_19 :: Field19 s t a b => Lens s t a b

-- | Access the 19th field of a tuple.
_19 :: (Field19 s t a b, Generic s, Generic t, GIxed N18 (Rep s) (Rep t) a b) => Lens s t a b

-- | A relevant Fold (aka <a>Fold1</a>) has one or more targets.
type Fold1 s a = forall f. (Contravariant f, Apply f) => (a -> f a) -> s -> f s
type IndexedFold1 i s a = forall p f. (Indexable i p, Contravariant f, Apply f) => p a (f a) -> s -> f s

-- | An <a>IndexPreservingLens</a> leaves any index it is composed with
--   alone.
type IndexPreservingLens s t a b = forall p f. (Conjoined p, Functor f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingLens'</a> = <a>Simple</a> <a>IndexPreservingLens</a>
--   </pre>
type IndexPreservingLens' s a = IndexPreservingLens s s a a

-- | An <a>IndexPreservingTraversal</a> leaves any index it is composed
--   with alone.
type IndexPreservingTraversal s t a b = forall p f. (Conjoined p, Applicative f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <a>IndexPreservingTraversal'</a> = <a>Simple</a> <a>IndexPreservingTraversal</a>
--   </pre>
type IndexPreservingTraversal' s a = IndexPreservingTraversal s s a a
type IndexPreservingTraversal1 s t a b = forall p f. (Conjoined p, Apply f) => p a (f b) -> p s (f t)
type IndexPreservingTraversal1' s a = IndexPreservingTraversal1 s s a a

-- | An <a>IndexPreservingSetter</a> can be composed with a
--   <a>IndexedSetter</a>, <a>IndexedTraversal</a> or <a>IndexedLens</a>
--   and leaves the index intact, yielding an <a>IndexedSetter</a>.
type IndexPreservingSetter s t a b = forall p f. (Conjoined p, Settable f) => p a (f b) -> p s (f t)

-- | <pre>
--   type <tt>IndexedPreservingSetter'</tt> i = <a>Simple</a> <tt>IndexedPreservingSetter</tt>
--   </pre>
type IndexPreservingSetter' s a = IndexPreservingSetter s s a a

-- | An <a>IndexPreservingGetter</a> can be used as a <a>Getter</a>, but
--   when composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a>, <a>IndexedFold</a> or
--   <a>IndexedGetter</a> respectively.
type IndexPreservingGetter s a = forall p f. (Conjoined p, Contravariant f, Functor f) => p a (f a) -> p s (f s)

-- | An <a>IndexPreservingFold</a> can be used as a <a>Fold</a>, but when
--   composed with an <a>IndexedTraversal</a>, <a>IndexedFold</a>, or
--   <a>IndexedLens</a> yields an <a>IndexedFold</a> respectively.
type IndexPreservingFold s a = forall p f. (Conjoined p, Contravariant f, Applicative f) => p a (f a) -> p s (f s)
type IndexPreservingFold1 s a = forall p f. (Conjoined p, Contravariant f, Apply f) => p a (f a) -> p s (f s)

-- | A <a>Simple</a> <a>Lens</a>, <a>Simple</a> <a>Traversal</a>, ... can
--   be used instead of a <a>Lens</a>,<a>Traversal</a>, ... whenever the
--   type variables don't change upon setting a value.
--   
--   <pre>
--   <a>_imagPart</a> :: <a>Simple</a> <a>Lens</a> (<a>Complex</a> a) a
--   <a>traversed</a> :: <a>Simple</a> (<a>IndexedTraversal</a> <a>Int</a>) [a] a
--   </pre>
--   
--   Note: To use this alias in your own code with <tt><a>LensLike</a>
--   f</tt> or <a>Setter</a>, you may have to turn on
--   <tt>LiberalTypeSynonyms</tt>.
--   
--   This is commonly abbreviated as a "prime" marker, <i>e.g.</i>
--   <a>Lens'</a> = <a>Simple</a> <a>Lens</a>.
type Simple f s a = f s s a a

-- | <pre>
--   type <a>LensLike'</a> f = <a>Simple</a> (<a>LensLike</a> f)
--   </pre>
type LensLike' f s a = LensLike f s s a a

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
type Over p f s t a b = p a (f b) -> s -> f t

-- | This is a convenient alias for use when you need to consume either
--   indexed or non-indexed lens-likes based on context.
--   
--   <pre>
--   type <a>Over'</a> p f = <a>Simple</a> (<a>Over</a> p f)
--   </pre>
type Over' p f s a = Over p f s s a a

-- | Convenient alias for constructing indexed lenses and their ilk.
type IndexedLensLike i f s t a b = forall p. Indexable i p => p a (f b) -> s -> f t

-- | Convenient alias for constructing simple indexed lenses and their ilk.
type IndexedLensLike' i f s a = IndexedLensLike i f s s a a

-- | <pre>
--   type <a>LensLike</a> f s t a b = <a>Optical</a> (-&gt;) (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Over</a> p f s t a b = <a>Optical</a> p (-&gt;) f s t a b
--   </pre>
--   
--   <pre>
--   type <a>Optic</a> p f s t a b = <a>Optical</a> p p f s t a b
--   </pre>
type Optical p q f s t a b = p a (f b) -> q s (f t)

-- | <pre>
--   type <a>Optical'</a> p q f s a = <a>Simple</a> (<a>Optical</a> p q f) s a
--   </pre>
type Optical' p q f s a = Optical p q f s s a a

-- | <pre>
--   type <a>Optic'</a> p f s a = <a>Simple</a> (<a>Optic</a> p f) s a
--   </pre>
type Optic' p f s a = Optic p f s s a a
class Wrapped s => Rewrapped (s :: Type) (t :: Type)
class (Rewrapped s t, Rewrapped t s) => Rewrapping s t

-- | This type family is used by <a>Magnify</a> to describe the common
--   effect type.
type family Magnified (m :: Type -> Type) :: Type -> Type -> Type

-- | This class allows us to use <a>magnify</a> part of the environment,
--   changing the environment supplied by many different <a>Monad</a>
--   transformers. Unlike <a>zoom</a> this can change the environment of a
--   deeply nested <a>Monad</a> transformer.
--   
--   Also, unlike <a>zoom</a>, this can be used with any valid
--   <a>Getter</a>, but cannot be used with a <a>Traversal</a> or
--   <a>Fold</a>.
class (Magnified m ~ Magnified n, MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m

-- | Run a monadic action in a larger environment than it was defined in,
--   using a <a>Getter</a>.
--   
--   This acts like <a>local</a>, but can in many cases change the type of
--   the environment as well.
--   
--   This is commonly used to lift actions in a simpler <a>Reader</a>
--   <a>Monad</a> into a <a>Monad</a> with a larger environment type.
--   
--   This can be used to edit pretty much any <a>Monad</a> transformer
--   stack with an environment in it:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; magnify _2 (+1)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2) $ magnify _1 Reader.ask
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip Reader.runReader (1,2,[10..20]) $ magnify (_3._tail) Reader.ask
--   [11,12,13,14,15,16,17,18,19,20]
--   </pre>
--   
--   The type can be read as
--   
--   <pre>
--   magnify :: LensLike' (Magnified m c) a b -&gt; m c -&gt; n c
--   </pre>
--   
--   but the higher-rank constraints make it easier to apply
--   <tt>magnify</tt> to a <a>Getter</a> in highly-polymorphic code.
--   
--   <pre>
--   <a>magnify</a> :: <a>Getter</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>magnify</a> :: <a>Monoid</a> r =&gt; <a>Fold</a> s a   -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>magnify</a> :: <a>Monoid</a> w                 =&gt; <a>Getter</a> s t -&gt; <a>RWS</a> t w st c -&gt; <a>RWS</a> s w st c
--   <a>magnify</a> :: (<a>Monoid</a> w, <a>Monoid</a> c) =&gt; <a>Fold</a> s a   -&gt; <a>RWS</a> a w st c -&gt; <a>RWS</a> s w st c
--   ...
--   </pre>
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
infixr 2 `magnify`

-- | This type family is used by <a>Zoom</a> to describe the common effect
--   type.
type family Zoomed (m :: Type -> Type) :: Type -> Type -> Type

-- | A form of <a>Traversal</a> that can be stored monomorphically in a
--   container.
newtype ReifiedTraversal s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
[runTraversal] :: ReifiedTraversal s t a b -> Traversal s t a b

-- | <pre>
--   type <a>ReifiedLens'</a> = <a>Simple</a> <a>ReifiedLens</a>
--   </pre>
type ReifiedLens' s a = ReifiedLens s s a a

-- | Reify an <a>IndexedLens</a> so it can be stored safely in a container.
newtype ReifiedIndexedLens i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
[runIndexedLens] :: ReifiedIndexedLens i s t a b -> IndexedLens i s t a b

-- | <pre>
--   type <a>ReifiedIndexedLens'</a> i = <a>Simple</a> (<a>ReifiedIndexedLens</a> i)
--   </pre>
type ReifiedIndexedLens' i s a = ReifiedIndexedLens i s s a a

-- | Reify an <a>IndexedTraversal</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedTraversal i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
[runIndexedTraversal] :: ReifiedIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | <pre>
--   type <a>ReifiedIndexedTraversal'</a> i = <a>Simple</a> (<a>ReifiedIndexedTraversal</a> i)
--   </pre>
type ReifiedIndexedTraversal' i s a = ReifiedIndexedTraversal i s s a a

-- | <pre>
--   type <a>ReifiedTraversal'</a> = <a>Simple</a> <a>ReifiedTraversal</a>
--   </pre>
type ReifiedTraversal' s a = ReifiedTraversal s s a a

-- | Reify a <a>Getter</a> so it can be stored safely in a container.
--   
--   This can also be useful when combining getters in novel ways, as
--   <a>ReifiedGetter</a> is isomorphic to <tt>(-&gt;)</tt> and provides
--   similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world","!!!")^.runGetter ((,) &lt;$&gt; Getter _2 &lt;*&gt; Getter (_1.to length))
--   ("world",5)
--   </pre>
newtype ReifiedGetter s a
Getter :: Getter s a -> ReifiedGetter s a
[runGetter] :: ReifiedGetter s a -> Getter s a

-- | Reify an <a>IndexedGetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedGetter i s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
[runIndexedGetter] :: ReifiedIndexedGetter i s a -> IndexedGetter i s a

-- | Reify a <a>Fold</a> so it can be stored safely in a container.
--   
--   This can also be useful for creatively combining folds as
--   <tt><a>ReifiedFold</a> s</tt> is isomorphic to <tt>ReaderT s []</tt>
--   and provides similar instances.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^..runFold ((,) &lt;$&gt; Fold _2 &lt;*&gt; Fold both)
--   [("world","hello"),("world","world")]
--   </pre>
newtype ReifiedFold s a
Fold :: Fold s a -> ReifiedFold s a
[runFold] :: ReifiedFold s a -> Fold s a
newtype ReifiedIndexedFold i s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
[runIndexedFold] :: ReifiedIndexedFold i s a -> IndexedFold i s a

-- | Reify a <a>Setter</a> so it can be stored safely in a container.
newtype ReifiedSetter s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
[runSetter] :: ReifiedSetter s t a b -> Setter s t a b

-- | <pre>
--   type <a>ReifiedSetter'</a> = <a>Simple</a> <a>ReifiedSetter</a>
--   </pre>
type ReifiedSetter' s a = ReifiedSetter s s a a

-- | Reify an <a>IndexedSetter</a> so it can be stored safely in a
--   container.
newtype ReifiedIndexedSetter i s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
[runIndexedSetter] :: ReifiedIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | <pre>
--   type <a>ReifiedIndexedSetter'</a> i = <a>Simple</a> (<a>ReifiedIndexedSetter</a> i)
--   </pre>
type ReifiedIndexedSetter' i s a = ReifiedIndexedSetter i s s a a

-- | Reify an <a>Iso</a> so it can be stored safely in a container.
newtype ReifiedIso s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
[runIso] :: ReifiedIso s t a b -> Iso s t a b

-- | <pre>
--   type <a>ReifiedIso'</a> = <a>Simple</a> <a>ReifiedIso</a>
--   </pre>
type ReifiedIso' s a = ReifiedIso s s a a

-- | Reify a <a>Prism</a> so it can be stored safely in a container.
newtype ReifiedPrism s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
[runPrism] :: ReifiedPrism s t a b -> Prism s t a b

-- | <pre>
--   type <a>ReifiedPrism'</a> = <a>Simple</a> <a>ReifiedPrism</a>
--   </pre>
type ReifiedPrism' s a = ReifiedPrism s s a a
pattern List :: IsList l => [Item l] -> l
pattern Empty :: AsEmpty s => s
pattern Strict :: Strict s t => t -> s
pattern Lazy :: Strict t s => t -> s
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
pattern Swapped :: Swap p => p b a -> p a b
pattern Reversed :: Reversing t => t -> t
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t

-- | An <a>Iso</a> between the lazy variant of a structure and its strict
--   counterpart.
--   
--   <pre>
--   <a>strict</a> = <a>from</a> <a>lazy</a>
--   </pre>
strict :: Strict lazy strict => Iso' lazy strict

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on an index.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^?traversed.index 2
--   Just "world"
--   </pre>
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a

-- | This allows you to filter an <a>IndexedFold</a>, <a>IndexedGetter</a>,
--   <a>IndexedTraversal</a> or <a>IndexedLens</a> based on a predicate on
--   the indices.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","the","world","!!!"]^..traversed.indices even
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traversed.indices (&gt;0)) Prelude.reverse $ ["He","was","stressed","o_O"]
--   ["He","saw","desserts","O_o"]
--   </pre>
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a

-- | An <a>Iso</a> between the strict variant of a structure and its lazy
--   counterpart.
--   
--   <pre>
--   <a>lazy</a> = <a>from</a> <a>strict</a>
--   </pre>
lazy :: Strict lazy strict => Iso' strict lazy

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [a, b, c]
--   Just (a,[b,c])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | Invert an isomorphism.
--   
--   <pre>
--   <a>from</a> (<a>from</a> l) ≡ l
--   </pre>
from :: AnIso s t a b -> Iso b a t s

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons a []
--   [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a [b, c]
--   [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [])
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons a (Seq.fromList [b, c])
--   fromList [a,b,c]
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList []) a
--   fromList [a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (Seq.fromList [b, c]) a
--   fromList [b,c,a]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; snoc (LazyT.pack "hello") '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "hello!")
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (LazyT.pack "")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [b,c,a])
--   Just (fromList [b,c],a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc (Seq.fromList [])
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual <a>levels</a> of any other <a>Traversal</a> or <a>Fold</a>
--   via iterative deepening depth-first search. The levels are returned to
--   you in a compressed format.
--   
--   This can permit us to extract the <a>levels</a> directly:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse)
--   [Zero,Zero,One () 'h',Two 0 (One () 'e') (One () 'w'),Two 0 (One () 'l') (One () 'o'),Two 0 (One () 'l') (One () 'r'),Two 0 (One () 'o') (One () 'l'),One () 'd']
--   </pre>
--   
--   But we can also traverse them in turn:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"]^..levels (traverse.traverse).traverse
--   "hewlolrold"
--   </pre>
--   
--   We can use this to traverse to a fixed depth in the tree of
--   (<a>&lt;*&gt;</a>) used in the <a>Traversal</a>:
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse)).traverse %~ toUpper
--   ["HEllo","World"]
--   </pre>
--   
--   Or we can use it to traverse the first <tt>n</tt> elements in found in
--   that <a>Traversal</a> regardless of the depth at which they were
--   found.
--   
--   <pre>
--   &gt;&gt;&gt; ["hello","world"] &amp; taking 4 (levels (traverse.traverse).traverse) %~ toUpper
--   ["HELlo","World"]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the <a>levels</a> which is indexed
--   by the depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..levels (traverse.traverse) &lt;. traverse
--   [(2,'d'),(3,'o'),(3,'c'),(4,'g'),(4,'a'),(5,'t')]
--   </pre>
--   
--   <pre>
--   <a>levels</a> :: <a>Traversal</a> s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> () a) (<a>Level</a> () b)
--   <a>levels</a> :: <a>Fold</a> s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> () a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
levels :: Applicative f => Traversing (->) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)

-- | This is a <a>Lens</a> that updates either side of an <a>Either</a>,
--   where both sides have the same type.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a^.chosen
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello"^.chosen
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right a &amp; chosen *~ b
--   Right (a * b)
--   </pre>
--   
--   <pre>
--   <a>chosen</a> :: <a>Lens</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   <a>chosen</a> f (<a>Left</a> a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>chosen</a> f (<a>Right</a> a) = <a>Right</a> <a>&lt;$&gt;</a> f a
--   </pre>
chosen :: IndexPreservingLens (Either a a) (Either b b) a b

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>traverseOf</a> do not construct a new structure.
--   <a>traverseOf_</a> generalizes <a>traverse_</a> to work over any
--   <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>traverseOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>traverseOf_</a>
--   requires an <a>Applicative</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a> ≡ <a>traverseOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf_</a> <tt>_2</tt> :: <a>Functor</a> f =&gt; (c -&gt; f r) -&gt; (d, c) -&gt; f ()
--   <a>traverseOf_</a> <a>_Left</a> :: <a>Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a>Either</a> a c -&gt; f ()
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> l ≡ <a>traverseOf_</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   The rather specific signature of <a>traverseOf_</a> allows it to be
--   used as if the signature was any of:
--   
--   <pre>
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   <a>traverseOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()

-- | Fold over the elements of a structure, associating to the left, but
--   strictly.
--   
--   <pre>
--   <a>foldl'</a> ≡ <a>foldlOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf'</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf'</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Map each target of a <a>Fold</a> on a structure to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf_ both putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>mapM_</a> ≡ <a>mapMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   <a>mapMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; (a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <tt>for</tt> a ≡ <a>ifor</a> a <tt>.</tt> <tt>const</tt>
--   <a>ifor</a> ≡ <a>flip</a> <a>itraverse</a>
--   </pre>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access the
--   index.
--   
--   When you don't need access to the index <tt>mapM</tt> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <tt>mapM</tt> ≡ <a>imapM</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results, with access its
--   position (and the arguments flipped).
--   
--   <pre>
--   <tt>forM</tt> a ≡ <a>iforM</a> a <tt>.</tt> <tt>const</tt>
--   <a>iforM</a> ≡ <a>flip</a> <a>imapM</a>
--   </pre>
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)

-- | Generalizes <a>mapAccumR</a> to add access to the index.
--   
--   <a>imapAccumR</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>imapAccumR</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Generalizes <a>mapAccumL</a> to add access to the index.
--   
--   <a>imapAccumL</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>imapAccumL</a> <tt>.</tt> <tt>const</tt>
--   </pre>
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | Return whether or not any element in a container satisfies a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>any</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>any</a> ≡ <a>iany</a> <a>.</a> <tt>const</tt>
--   </pre>
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not all elements in a container satisfy a predicate,
--   with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <tt>all</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>all</tt> ≡ <a>iall</a> <a>.</a> <tt>const</tt>
--   </pre>
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Return whether or not none of the elements in a container satisfy a
--   predicate, with access to the index <tt>i</tt>.
--   
--   When you don't need access to the index then <a>none</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>none</a> ≡ <a>inone</a> <a>.</a> <tt>const</tt>
--   <a>inone</a> f ≡ <a>not</a> <a>.</a> <a>iany</a> f
--   </pre>
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool

-- | Determines whether no elements of the structure satisfy the predicate.
--   
--   <pre>
--   <a>none</a> f ≡ <a>not</a> <a>.</a> <a>any</a> f
--   </pre>
none :: Foldable f => (a -> Bool) -> f a -> Bool

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <tt>traverse_</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>traverse_</tt> l = <a>itraverse</a> <a>.</a> <tt>const</tt>
--   </pre>
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Traverse elements with access to the index <tt>i</tt>, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>ifor_</a> ≡ <a>flip</a> <a>itraverse_</a>
--   </pre>
--   
--   When you don't need access to the index then <tt>for_</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>for_</tt> a ≡ <a>ifor_</a> a <a>.</a> <tt>const</tt>
--   </pre>
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>mapM_</tt> ≡ <tt>imapM</tt> <a>.</a> <tt>const</tt>
--   </pre>
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()

-- | Run monadic actions for each target of an <tt>IndexedFold</tt> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforM_</a> ≡ <a>flip</a> <a>imapM_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forM_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forM_</a> a ≡ <tt>iforM</tt> a <a>.</a> <tt>const</tt>
--   </pre>
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()

-- | Concatenate the results of a function of the elements of an indexed
--   container with access to the index.
--   
--   When you don't need access to the index then <tt>concatMap</tt> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <tt>concatMap</tt> ≡ <a>iconcatMap</a> <a>.</a> <tt>const</tt>
--   <a>iconcatMap</a> ≡ <a>ifoldMap</a>
--   </pre>
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]

-- | Searches a container with a predicate that is also supplied the index,
--   returning the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <tt>find</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>find</tt> ≡ <a>ifind</a> <a>.</a> <tt>const</tt>
--   </pre>
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <tt>foldrM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldrM</tt> ≡ <a>ifoldrM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <tt>foldlM</tt> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <tt>foldlM</tt> ≡ <a>ifoldlM</a> <a>.</a> <tt>const</tt>
--   </pre>
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <tt>toList</tt> is more flexible in what it accepts.
--   
--   <pre>
--   <tt>toList</tt> ≡ <a>map</a> <tt>snd</tt> <a>.</a> <a>itoList</a>
--   </pre>
itoList :: FoldableWithIndex i f => f a -> [(i, a)]

-- | <pre>
--   <a>swapped</a> <a>.</a> <a>swapped</a> ≡ <a>id</a>
--   <a>first</a> f <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>second</a> f
--   <a>second</a> g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>first</a> g
--   <a>bimap</a> f g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>bimap</a> g f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^.swapped
--   (2,1)
--   </pre>
swapped :: Swap p => Iso (p a b) (p c d) (p b a) (p d c)

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <tt>fold</tt> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldBy</a> <a>mappend</a> <a>mempty</a> ≡ <tt>fold</tt>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldBy (++) [] ["hello","world"]
--   "helloworld"
--   </pre>
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a

-- | Fold a value using its <a>Foldable</a> instance using explicitly
--   provided <a>Monoid</a> operations. This is like <a>foldMap</a> where
--   the <a>Monoid</a> instance can be manually specified.
--   
--   <pre>
--   <a>foldMapBy</a> <a>mappend</a> <a>mempty</a> ≡ <a>foldMap</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapBy (+) 0 length ["hello","world"]
--   10
--   </pre>
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r

-- | Traverse a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>traverse</a> where the <a>Applicative</a> instance can be manually
--   specified.
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)

-- | Sequence a container using its <a>Traversable</a> instance using
--   explicitly provided <a>Applicative</a> operations. This is like
--   <a>sequence</a> where the <a>Applicative</a> instance can be manually
--   specified.
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)

-- | Modify the target of a <a>Lens</a> or all the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a function.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   <a>sets</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>sets</a> ≡ <a>id</a>
--   </pre>
--   
--   Given any valid <a>Setter</a> <tt>l</tt>, you can also rely on the
--   law:
--   
--   <pre>
--   <a>over</a> l f <a>.</a> <a>over</a> l g = <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]
--   True
--   </pre>
--   
--   Another way to view <a>over</a> is to say that it transforms a
--   <a>Setter</a> into a "semantic editor combinator".
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (Just a)
--   Just (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (*10) [1,2,3]
--   [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 show (10,20)
--   ("10",20)
--   </pre>
--   
--   <pre>
--   <a>over</a> :: <a>Setter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   <a>over</a> :: <a>ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a> ≡ <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a

-- | Transform every element in the tree, in a bottom-up manner.
--   
--   For example, replacing negative literals with literals:
--   
--   <pre>
--   negLits = <a>transform</a> $ \x -&gt; case x of
--     Neg (Lit i) -&gt; Lit (<a>negate</a> i)
--     _           -&gt; x
--   </pre>
transform :: Plated a => (a -> a) -> a -> a

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   <pre>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 "hello" (1,())
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped () [1,2,3,4]
--   [(),(),(),()]
--   </pre>
--   
--   Note: Attempting to <a>set</a> a <a>Fold</a> or <a>Getter</a> will
--   fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set</a> :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k .~ Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | An indexed version of <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^@. iat 1
--   (1,Just "world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 1 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iat 2 %@~ (\i x -&gt; if odd i then Just "hello" else Nothing) $ Map.empty
--   fromList []
--   </pre>
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> Traversal' m (IxValue m)

-- | An indexed version of <a>ix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 %@~ f'
--   fromList [a,b,f' 2 c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; iix 2 .@~ h
--   fromList [a,b,h 2,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^@? iix 2
--   Just (2,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^@? iix 2
--   Nothing
--   </pre>
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)

-- | An indexed version of <a>contains</a>.
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 3
--   (3,True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^@. icontains 5
--   (5,False)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if odd i then not x else x
--   fromList [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; icontains 3 %@~ \i x -&gt; if even i then not x else x
--   fromList [1,2,3,4]
--   </pre>
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool

-- | A <a>Traversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head .~ d
--   [d,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _head %~ f
--   [f a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ f
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?!_head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
--   
--   This isn't limited to lists.
--   
--   For instance you can also <a>traverse</a> the head of a <a>Seq</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] &amp; _head %~ f
--   fromList [f a,b,c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c,d] ^? _head
--   Just a
--   </pre>
--   
--   <pre>
--   <a>_head</a> :: <a>Traversal'</a> [a] a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_head</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_head :: Cons s s a a => Traversal' s a

-- | A <a>Traversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _tail .~ [c,d,e]
--   [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d,e] &amp; _tail.traverse %~ f
--   [a,f b,f c,f d,f e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?_tail
--   Just [b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?!_tail
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._tail
--   "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._tail
--   ""
--   </pre>
--   
--   This isn't limited to lists. For instance you can also <a>traverse</a>
--   the tail of a <a>Seq</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b] &amp; _tail .~ Seq.fromList [c,d,e]
--   fromList [a,c,d,e]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [a,b,c] ^? _tail
--   Just (fromList [b,c])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [] ^? _tail
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>_tail</a> :: <a>Traversal'</a> [a] [a]
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_tail</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_tail :: Cons s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and replacing all but the a last element of
--   a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d]^?_init
--   Just [a,b,c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b] &amp; _init .~ [c,d,e]
--   [c,d,e,b]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [a,b]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c,d] &amp; _init.traverse %~ f
--   [f a,f b,f c,d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3]^?_init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^?!_init
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^._init
--   "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ""^._init
--   ""
--   </pre>
--   
--   <pre>
--   <a>_init</a> :: <a>Traversal'</a> [a] [a]
--   <a>_init</a> :: <a>Traversal'</a> (<a>Seq</a> a) (<a>Seq</a> a)
--   <a>_init</a> :: <a>Traversal'</a> (<a>Vector</a> a) (<a>Vector</a> a)
--   </pre>
_init :: Snoc s s a a => Traversal' s s

-- | A <a>Traversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c]^?!_last
--   c
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; []^?_last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [a,b,c] &amp; _last %~ f
--   [a,b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2]^?_last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
--   
--   This <a>Traversal</a> is not limited to lists, however. We can also
--   work with other containers, such as a <a>Vector</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Vector.fromList "abcde" ^? _last
--   Just 'e'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Vector.empty ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Vector.fromList "abcde" &amp; _last .~ 'Q') == Vector.fromList "abcdQ"
--   True
--   </pre>
--   
--   <pre>
--   <a>_last</a> :: <a>Traversal'</a> [a] a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Seq</a> a) a
--   <a>_last</a> :: <a>Traversal'</a> (<a>Vector</a> a) a
--   </pre>
_last :: Snoc s s a a => Traversal' s a

-- | This is an adverb that can be used to modify many other <a>Lens</a>
--   combinators to make them require simple lenses, simple traversals,
--   simple prisms or simple isos as input.
simply :: forall p f s a rep (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r

-- | Extract a witness of type <a>Equality</a>.
runEq :: AnEquality s t a b -> Identical s t a b

-- | Substituting types with <a>Equality</a>.
substEq :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r

-- | We can use <a>Equality</a> to do substitution into anything.
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (f :: k1 -> Type). AnEquality s t a b -> f s -> f a

-- | <a>Equality</a> is symmetric.
fromEq :: AnEquality s t a b -> Equality b a t s

-- | Composition with this isomorphism is occasionally useful when your
--   <a>Lens</a>, <a>Traversal</a> or <a>Iso</a> has a constraint on an
--   unused argument to force that argument to agree with the type of a
--   used argument and avoid <tt>ScopedTypeVariables</tt> or other
--   ugliness.
simple :: Equality' a a

-- | Construct an <a>Equality</a> from explicit equality evidence.
equality :: (s :~: a) -> (b :~: t) -> Equality s t a b

-- | A <a>Simple</a> version of <a>equality</a>
equality' :: (a :~: b) -> Equality' a b

-- | A version of <a>substEq</a> that provides explicit, rather than
--   implicit, equality evidence.
withEquality :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r

-- | The opposite of working <a>overEquality</a> is working
--   <a>underEquality</a>.
underEquality :: AnEquality s t a b -> p t s -> p b a

-- | Recover a "profunctor lens" form of equality. Reverses
--   <a>fromLeibniz</a>.
overEquality :: AnEquality s t a b -> p a b -> p s t

-- | Convert a "profunctor lens" form of equality to an equality. Reverses
--   <a>overEquality</a>.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz :: (forall p. p a b -&gt; p s t) -&gt; Equality s t a b
--   </pre>
fromLeibniz :: (Identical a b a b -> Identical a b s t) -> Equality s t a b

-- | Convert Leibniz equality to equality. Reverses <a>mapEq</a> in
--   <a>Simple</a> cases.
--   
--   The type should be understood as
--   
--   <pre>
--   fromLeibniz' :: (forall f. f s -&gt; f a) -&gt; Equality' s a
--   </pre>
fromLeibniz' :: ((s :~: s) -> s :~: a) -> Equality' s a
cloneEquality :: AnEquality s t a b -> Equality s t a b

-- | This converts a <a>Fold</a> to a <a>IndexPreservingGetter</a> that
--   returns the first element, if it exists, as a <a>Maybe</a>.
--   
--   <pre>
--   <a>pre</a> :: <a>Getter</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Fold</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Traversal'</a> s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Lens'</a> s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Iso'</a> s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   <a>pre</a> :: <a>Prism'</a> s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> a)
--   </pre>
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)

-- | This converts an <a>IndexedFold</a> to an <a>IndexPreservingGetter</a>
--   that returns the first index and element, if they exist, as a
--   <a>Maybe</a>.
--   
--   <pre>
--   <a>ipre</a> :: <a>IndexedGetter</a> i s a     -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedFold</a> i s a       -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedTraversal'</a> i s a -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   <a>ipre</a> :: <a>IndexedLens'</a> i s a      -&gt; <a>IndexPreservingGetter</a> s (<a>Maybe</a> (i, a))
--   </pre>
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>). See
--   also <a>firstOf</a> and <a>^?</a>, which are similar with some subtle
--   differences (explained below).
--   
--   <pre>
--   <a>listToMaybe</a> <a>.</a> <tt>toList</tt> ≡ <a>preview</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>preview</a> = <a>view</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   Unlike <a>^?</a>, this function uses a <a>MonadReader</a> to read the
--   value to be focused in on. This allows one to pass the value as the
--   last argument by using the <a>MonadReader</a> instance for <tt>(-&gt;)
--   s</tt> However, it may also be used as part of some deeply nested
--   transformer stack.
--   
--   <a>preview</a> uses a monoidal value to obtain the result. This means
--   that it generally has good performance, but can occasionally cause
--   space leaks or even stack overflows on some data types. There is
--   another function, <a>firstOf</a>, which avoids these issues at the
--   cost of a slight constant performance cost and a little less
--   flexibility.
--   
--   It may be helpful to think of <a>preview</a> as having one of the
--   following more specialized types:
--   
--   <pre>
--   <a>preview</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>preview</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preview</a> :: <a>MonadReader</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>).
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>). See also (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreview</a> = <a>view</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreview</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; <a>Maybe</a> (i, a)
--   <a>ipreview</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; <a>Maybe</a> (i, a)
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreview</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or <a>Just</a> the
--   result from an <a>IndexedGetter</a> or <a>IndexedLens</a>). See also
--   (<a>^@?</a>).
--   
--   <pre>
--   <a>ipreviews</a> = <a>views</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   This is usually applied in the <a>Reader</a> <a>Monad</a> <tt>(-&gt;)
--   s</tt>.
--   
--   <pre>
--   <a>ipreviews</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   <a>ipreviews</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; s -&gt; <a>Maybe</a> r
--   </pre>
--   
--   However, it may be useful to think of its full generality when working
--   with a <a>Monad</a> transformer stack:
--   
--   <pre>
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreviews</a> :: <a>MonadReader</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Retrieve the first value targeted by a <a>Fold</a> or <a>Traversal</a>
--   (or <a>Just</a> the result from a <a>Getter</a> or <a>Lens</a>) into
--   the current state.
--   
--   <pre>
--   <a>preuse</a> = <a>use</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; m (<a>Maybe</a> a)
--   <a>preuse</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; m (<a>Maybe</a> a)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | Retrieve a function of the first value targeted by a <a>Fold</a> or
--   <a>Traversal</a> (or <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>) into the current state.
--   
--   <pre>
--   <a>preuses</a> = <a>uses</a> <a>.</a> <a>pre</a>
--   </pre>
--   
--   <pre>
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>preuses</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)

-- | Retrieve the first index and value targeted by an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> (or <a>Just</a> the index and result from
--   an <a>IndexedGetter</a> or <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuse</a> = <a>use</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; m (<a>Maybe</a> (i, a))
--   <a>ipreuse</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; m (<a>Maybe</a> (i, a))
--   </pre>
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))

-- | Retrieve a function of the first index and value targeted by an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> (or a function of
--   <a>Just</a> the index and result from an <a>IndexedGetter</a> or
--   <a>IndexedLens</a>) into the current state.
--   
--   <pre>
--   <a>ipreuses</a> = <a>uses</a> <a>.</a> <a>ipre</a>
--   </pre>
--   
--   <pre>
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   <a>ipreuses</a> :: <a>MonadState</a> s m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r) -&gt; m (<a>Maybe</a> r)
--   </pre>
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> matches 1 or more
--   entries.
--   
--   <pre>
--   &gt;&gt;&gt; has (element 0) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>has</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>has</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Getting All s a -> s -> Bool

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..folding reverse
--   [4,3,2,1]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b

-- | Obtain a <a>Fold</a> by lifting <a>foldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4]^..foldring foldr
--   [1,2,3,4]
--   </pre>
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b

-- | Obtain <tt>FoldWithIndex</tt> by lifting <a>ifoldr</a> like function.
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
--   
--   <pre>
--   &gt;&gt;&gt; Just 3^..folded
--   [3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing^..folded
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)]^..folded.both
--   [1,2,3,4]
--   </pre>
folded :: Foldable f => IndexedFold Int (f a) a

-- | Obtain a <a>Fold</a> from any <a>Foldable</a> indexed by ordinal
--   position.
folded64 :: Foldable f => IndexedFold Int64 (f a) a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a> ≡ <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 10^..unfolded (\b -&gt; if b == 0 then Nothing else Just (b, b-1))
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (b -> Maybe (a, b)) -> Fold b a

-- | <tt>x <a>^.</a> <a>iterated</a> f</tt> returns an infinite
--   <a>Fold1</a> of repeated applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   <a>toListOf</a> (<a>iterated</a> f) a ≡ <a>iterate</a> f a
--   </pre>
--   
--   <pre>
--   <a>iterated</a> :: (a -&gt; a) -&gt; <a>Fold1</a> a a
--   </pre>
iterated :: Apply f => (a -> a) -> LensLike' f a a

-- | Obtain a <a>Fold</a> that can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   Note: This is <i>not</i> a legal <a>Traversal</a>, unless you are very
--   careful not to invalidate the predicate on the target.
--   
--   Note: This is also <i>not</i> a legal <a>Prism</a>, unless you are
--   very careful not to inject a value that fails the predicate.
--   
--   As a counter example, consider that given <tt>evens = <a>filtered</a>
--   <a>even</a></tt> the second <a>Traversal</a> law is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   <pre>
--   &gt;&gt;&gt; [1..10]^..folded.filtered even
--   [2,4,6,8,10]
--   </pre>
--   
--   This will preserve an index if it is present.
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a

-- | Obtain a potentially empty <a>IndexedTraversal</a> by taking the first
--   element from another, potentially empty <a>Fold</a> and using it as an
--   index.
--   
--   The resulting optic can be composed with to filter another
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a>, <a>Fold</a> (or
--   <a>Traversal</a>).
--   
--   <pre>
--   &gt;&gt;&gt; [(Just 2, 3), (Nothing, 4)] &amp; mapped . filteredBy (_1 . _Just) &lt;. _2 %@~ (*) :: [(Maybe Int, Int)]
--   [(Just 2,6),(Nothing,4)]
--   </pre>
--   
--   <pre>
--   <a>filteredBy</a> :: <a>Fold</a> a i -&gt; <a>IndexedTraversal'</a> i a a
--   </pre>
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a

-- | This allows you to <a>traverse</a> the elements of a pretty much any
--   <a>LensLike</a> construction in the opposite order.
--   
--   This will preserve indexes on <a>Indexed</a> types and will give you
--   the elements of a (finite) <a>Fold</a> or <a>Traversal</a> in the
--   opposite order.
--   
--   This has no practical impact on a <a>Getter</a>, <a>Setter</a>,
--   <a>Lens</a> or <a>Iso</a>.
--   
--   <i>NB:</i> To write back through an <a>Iso</a>, you want to use
--   <a>from</a>. Similarly, to write back through an <a>Prism</a>, you
--   want to use <a>re</a>.
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b

-- | Form a <a>Fold1</a> by repeating the input forever.
--   
--   <pre>
--   <a>repeat</a> ≡ <a>toListOf</a> <a>repeated</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ 5^..taking 20 repeated
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
--   
--   <pre>
--   <a>repeated</a> :: <a>Fold1</a> a a
--   </pre>
repeated :: Apply f => LensLike' f a a

-- | A <a>Fold</a> that replicates its input <tt>n</tt> times.
--   
--   <pre>
--   <a>replicate</a> n ≡ <a>toListOf</a> (<a>replicated</a> n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^..replicated 20
--   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
--   </pre>
replicated :: Int -> Fold a a

-- | Transform a non-empty <a>Fold</a> into a <a>Fold1</a> that loops over
--   its elements over and over.
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1,2,3]^..taking 7 (cycled traverse)
--   [1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   <a>cycled</a> :: <a>Fold1</a> s a -&gt; <a>Fold1</a> s a
--   </pre>
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b

-- | Obtain a <a>Fold</a> by taking elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>takeWhile</a> p ≡ <a>toListOf</a> (<a>takingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ toListOf (takingWhile (&lt;=3) folded) [1..]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a -- * See note below
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   <a>takingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   <i>Note:</i> When applied to a <a>Traversal</a>, <a>takingWhile</a>
--   yields something that can be used as if it were a <a>Traversal</a>,
--   but which is not a <a>Traversal</a> per the laws, unless you are
--   careful to ensure that you do not invalidate the predicate when
--   writing back through it.
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a

-- | Obtain a <a>Fold</a> by dropping elements from another <a>Fold</a>,
--   <a>Lens</a>, <a>Iso</a>, <a>Getter</a> or <a>Traversal</a> while a
--   predicate holds.
--   
--   <pre>
--   <a>dropWhile</a> p ≡ <a>toListOf</a> (<a>droppingWhile</a> p <a>folded</a>)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1..6]
--   [4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (droppingWhile (&lt;=3) folded) [1,6,1]
--   [6,1]
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Traversal'</a> s a                   -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Lens'</a> s a                        -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Prism'</a> s a                       -&gt; <a>Fold</a> s a                -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>Iso'</a> s a                         -&gt; <a>Fold</a> s a                -- see notes
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingTraversal'</a> s a    -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingLens'</a> s a         -&gt; <a>IndexPreservingFold</a> s a -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingFold</a> s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s a
--   </pre>
--   
--   <pre>
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedFold</a> i s a       -- see notes
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>droppingWhile</a> :: (a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Many uses of this combinator will yield something that meets the
--   types, but not the laws of a valid <a>Traversal</a> or
--   <a>IndexedTraversal</a>. The <a>Traversal</a> and
--   <a>IndexedTraversal</a> laws are only satisfied if the new values you
--   assign to the first target also does not pass the predicate! Otherwise
--   subsequent traversals will visit fewer elements and <a>Traversal</a>
--   fusion is not sound.
--   
--   So for any traversal <tt>t</tt> and predicate <tt>p</tt>,
--   <tt><a>droppingWhile</a> p t</tt> may not be lawful, but
--   <tt>(<a>dropping</a> 1 . <a>droppingWhile</a> p) t</tt> is. For
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; let l  :: Traversal' [Int] Int; l  = droppingWhile (&lt;= 1) traverse
--   
--   &gt;&gt;&gt; let l' :: Traversal' [Int] Int; l' = dropping 1 l
--   </pre>
--   
--   <tt>l</tt> is not a lawful setter because <tt><a>over</a> l f .
--   <a>over</a> l g ≢ <a>over</a> l (f . g)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 0 &amp; l .~ 4
--   [1,0,0]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l .~ 4
--   [1,4,4]
--   </pre>
--   
--   <tt>l'</tt> on the other hand behaves lawfully:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 0 &amp; l' .~ 4
--   [1,2,4]
--   
--   &gt;&gt;&gt; [1,2,3] &amp; l' .~ 4
--   [1,2,4]
--   </pre>
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | A <a>Fold</a> over the individual <a>words</a> of a <a>String</a>.
--   
--   <pre>
--   <a>worded</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>worded</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>worded</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   whitespace characters while traversing, and if your original
--   <a>String</a> contains only isolated space characters (and no other
--   characters that count as space, such as non-breaking spaces).
worded :: Applicative f => IndexedLensLike' Int f String String

-- | A <a>Fold</a> over the individual <a>lines</a> of a <a>String</a>.
--   
--   <pre>
--   <a>lined</a> :: <a>Fold</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>Traversal'</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   <pre>
--   <a>lined</a> :: <a>IndexedFold</a> <a>Int</a> <a>String</a> <a>String</a>
--   <a>lined</a> :: <a>IndexedTraversal'</a> <a>Int</a> <a>String</a> <a>String</a>
--   </pre>
--   
--   Note: This function type-checks as a <a>Traversal</a> but it doesn't
--   satisfy the laws. It's only valid to use it when you don't insert any
--   newline characters while traversing, and if your original
--   <a>String</a> contains only isolated newline characters.
lined :: Applicative f => IndexedLensLike' Int f String String

-- | Map each part of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> to a monoid and combine
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMapOf (folded . both . _Just) Sum [(Just 21, Just 21)]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>foldMap</a> = <a>foldMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ≡ <a>views</a>
--   <a>ifoldMapOf</a> l = <a>foldMapOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> ::                <a>Getter</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Fold</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Fold1</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Lens'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> ::                <a>Iso'</a> s a        -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Traversal'</a> s a  -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Semigroup</a> r =&gt; <a>Traversal1'</a> s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapOf</a> :: <a>Monoid</a> r    =&gt; <a>Prism'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>foldMapOf</a> :: <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
foldMapOf :: Getting r s a -> (a -> r) -> s -> r

-- | Combine the elements of a structure viewed through a <a>Lens</a>,
--   <a>Getter</a>, <a>Fold</a> or <a>Traversal</a> using a monoid.
--   
--   <pre>
--   &gt;&gt;&gt; foldOf (folded.folded) [[Sum 1,Sum 4],[Sum 8, Sum 8],[Sum 21]]
--   Sum {getSum = 42}
--   </pre>
--   
--   <pre>
--   <a>fold</a> = <a>foldOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>foldOf</a> ::             <a>Getter</a> s m     -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Lens'</a> s m      -&gt; s -&gt; m
--   <a>foldOf</a> ::             <a>Iso'</a> s m       -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   <a>foldOf</a> :: <a>Monoid</a> m =&gt; <a>Prism'</a> s m     -&gt; s -&gt; m
--   </pre>
foldOf :: Getting a s a -> s -> a

-- | Right-associative fold of parts of a structure that are viewed through
--   a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldr</a> ≡ <a>foldrOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> l ≡ <a>foldrOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf</a> :: <a>Getting</a> (<a>Endo</a> r) s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through a <a>Lens</a>, <a>Getter</a>, <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>foldl</a> ≡ <a>foldlOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldlOf</a> :: <a>Prism'</a> s a     -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r

-- | Extract a list of the targets of a <a>Fold</a>. See also (<a>^..</a>).
--   
--   <pre>
--   <a>toList</a> ≡ <a>toListOf</a> <a>folded</a>
--   (<a>^..</a>) ≡ <a>flip</a> <a>toListOf</a>
--   </pre>
toListOf :: Getting (Endo [a]) s a -> s -> [a]

-- | Extract a <a>NonEmpty</a> of the targets of <a>Fold1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmptyOf both1 ("hello", "world")
--   "hello" :| ["world"]
--   </pre>
--   
--   <pre>
--   <a>toNonEmptyOf</a> :: <a>Getter</a> s a      -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Fold1</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Lens'</a> s a       -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Iso'</a> s a        -&gt; s -&gt; NonEmpty a
--   <a>toNonEmptyOf</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; NonEmpty a
--   </pre>
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a

-- | Calls <a>pure</a> on the target of a <a>Lens</a>, <a>Getter</a>, or
--   <a>Iso</a>.
--   
--   Calls <a>pure</a> on the targets of a <a>Traversal</a>, <a>Fold</a>,
--   or <a>Prism</a>, and combines them with <a>&lt;|&gt;</a> (or
--   <a>empty</a> if none). Intuitively, it collects targets into an
--   <a>Alternative</a> until the container fills up or it runs out of
--   targets, whichever comes first.
--   
--   Generalizes <a>toListOf</a> and <a>(^?)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; altOf both ("hello", "world") :: [String]
--   ["hello","world"]
--   
--   &gt;&gt;&gt; altOf both ("hello", "world") :: Maybe String
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>altOf</a> :: Applicative f =&gt; <a>Lens'</a> s a      -&gt; s -&gt; f a
--   <a>altOf</a> :: Applicative f =&gt; <a>Getter</a> s a     -&gt; s -&gt; f a
--   <a>altOf</a> :: Applicative f =&gt; <a>Iso'</a> s a       -&gt; s -&gt; f a
--   
--   <a>altOf</a> :: Alternative f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; f a
--   <a>altOf</a> :: Alternative f =&gt; <a>Fold</a> s a       -&gt; s -&gt; f a
--   <a>altOf</a> :: Alternative f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; f a
--   </pre>
altOf :: Applicative f => Getting (Alt f a) s a -> s -> f a

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf both (=='x') ('x','y')
--   True
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; anyOf biplate (== "world") (((),2::Int),"hello",("world",11::Int))
--   True
--   </pre>
--   
--   <pre>
--   <a>any</a> ≡ <a>anyOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> l ≡ <a>anyOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>anyOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf both (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> l = <a>allOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>allOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>allOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> only if no targets of a <a>Fold</a> satisfy a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; noneOf each (is _Nothing) (Just 3, Just 4, Just 5)
--   True
--   
--   &gt;&gt;&gt; noneOf (folded.folded) (&lt;10) [[13,99,20],[3,71,42]]
--   False
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> l = <a>noneOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>noneOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>noneOf</a> :: <a>Prism'</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
noneOf :: Getting Any s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf both (True,False)
--   False
--   
--   &gt;&gt;&gt; andOf both (True,True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a> ≡ <a>andOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>andOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>andOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
andOf :: Getting All s Bool -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf both (True,False)
--   True
--   
--   &gt;&gt;&gt; orOf both (False,False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a> ≡ <a>orOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>orOf</a> :: <a>Getter</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Fold</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Lens'</a> s <a>Bool</a>      -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Iso'</a> s <a>Bool</a>       -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Traversal'</a> s <a>Bool</a> -&gt; s -&gt; <a>Bool</a>
--   <a>orOf</a> :: <a>Prism'</a> s <a>Bool</a>     -&gt; s -&gt; <a>Bool</a>
--   </pre>
orOf :: Getting Any s Bool -> s -> Bool

-- | Calculate the <tt>Product</tt> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf both (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a> ≡ <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <tt>Product</tt> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>productOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Calculate the <tt>Sum</tt> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf both (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded.both) [(1,2),(3,4)]
--   10
--   
--   &gt;&gt;&gt; import Data.Data.Lens
--   
--   &gt;&gt;&gt; sumOf biplate [(1::Int,[]),(2,[(3::Int,4::Int)])] :: Int
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a> ≡ <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt><tt>ala</tt> <tt>Sum</tt> <a>.</a>
--   <a>foldMapOf</a></tt>
--   
--   <pre>
--   <a>sumOf</a> <tt>_1</tt> :: <a>Num</a> a =&gt; (a, b) -&gt; a
--   <a>sumOf</a> (<a>folded</a> <a>.</a> <a>_1</a>) :: (<a>Foldable</a> f, <a>Num</a> a) =&gt; f (a, b) -&gt; a
--   </pre>
--   
--   <pre>
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; a
--   <a>sumOf</a> :: <a>Num</a> a =&gt; <a>Prism'</a> s a     -&gt; s -&gt; a
--   </pre>
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a

-- | Traverse over all of the targets of a <a>Fold</a> (or <a>Getter</a>),
--   computing an <a>Applicative</a> (or <a>Functor</a>)-based answer, but
--   unlike <a>forOf</a> do not construct a new structure. <a>forOf_</a>
--   generalizes <a>for_</a> to work over any <a>Fold</a>.
--   
--   When passed a <a>Getter</a>, <a>forOf_</a> can work over any
--   <a>Functor</a>, but when passed a <a>Fold</a>, <a>forOf_</a> requires
--   an <a>Applicative</a>.
--   
--   <pre>
--   <tt>for_</tt> ≡ <a>forOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; forOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   The rather specific signature of <a>forOf_</a> allows it to be used as
--   if the signature was any of:
--   
--   <pre>
--   <a>iforOf_</a> l s ≡ <a>forOf_</a> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   <a>forOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()

-- | Evaluate each action in observed by a <a>Fold</a> on a structure from
--   left to right, ignoring the results.
--   
--   <pre>
--   <tt>sequenceA_</tt> ≡ <a>sequenceAOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Functor</a> f     =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f ()
--   <a>sequenceAOf_</a> :: <a>Applicative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f ()
--   </pre>
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold1</a>, computing an
--   <a>Apply</a> based answer.
--   
--   As long as you have <a>Applicative</a> or <a>Functor</a> effect you
--   are better using <a>traverseOf_</a>. The <a>traverse1Of_</a> is useful
--   only when you have genuine <a>Apply</a> effect.
--   
--   <pre>
--   &gt;&gt;&gt; traverse1Of_ both1 (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ]) ("abc", "bcd")
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>traverse1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()

-- | See <a>forOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for1Of_ both1 ("abc", "bcd") (\ks -&gt; Map.fromList [ (k, ()) | k &lt;- ks ])
--   fromList [('b',()),('c',())]
--   </pre>
--   
--   <pre>
--   <a>for1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()
--   </pre>
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()

-- | See <a>sequenceAOf_</a> and <a>traverse1Of_</a>.
--   
--   <pre>
--   <a>sequence1Of_</a> :: <a>Apply</a> f =&gt; <a>Fold1</a> s (f a) -&gt; s -&gt; f ()
--   </pre>
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()

-- | <a>forMOf_</a> is <a>mapMOf_</a> with two of its arguments flipped.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf_ both ("hello","world") putStrLn
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>forM_</a> ≡ <a>forMOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   <a>forMOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s a     -&gt; s -&gt; (a -&gt; m r) -&gt; m ()
--   </pre>
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()

-- | Evaluate each monadic action referenced by a <a>Fold</a> on the
--   structure from left to right, and ignore the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ both (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>sequence_</a> ≡ <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m ()
--   <a>sequenceOf_</a> :: <a>Monad</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m ()
--   </pre>
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <tt>asum</tt> ≡ <a>asumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Getter</a> s (f a)     -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Fold</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Lens'</a> s (f a)      -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Iso'</a> s (f a)       -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Traversal'</a> s (f a) -&gt; s -&gt; f a
--   <a>asumOf</a> :: <a>Alternative</a> f =&gt; <a>Prism'</a> s (f a)     -&gt; s -&gt; f a
--   </pre>
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a

-- | The sum of a collection of actions, generalizing <a>concatOf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf both ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a> ≡ <a>msumOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Getter</a> s (m a)     -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Fold</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Lens'</a> s (m a)      -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Iso'</a> s (m a)       -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Traversal'</a> s (m a) -&gt; s -&gt; m a
--   <a>msumOf</a> :: <a>MonadPlus</a> m =&gt; <a>Prism'</a> s (m a)     -&gt; s -&gt; m a
--   </pre>
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a

-- | Map a function over all the targets of a <a>Fold</a> of a container
--   and concatenate the resulting lists.
--   
--   <pre>
--   &gt;&gt;&gt; concatMapOf both (\x -&gt; [x, x + 1]) (1,3)
--   [1,2,3,4]
--   </pre>
--   
--   <pre>
--   <a>concatMap</a> ≡ <a>concatMapOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>concatMapOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>concatMapOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]

-- | Concatenate all of the lists targeted by a <a>Fold</a> into a longer
--   list.
--   
--   <pre>
--   &gt;&gt;&gt; concatOf both ("pan","ama")
--   "panama"
--   </pre>
--   
--   <pre>
--   <a>concat</a> ≡ <a>concatOf</a> <a>folded</a>
--   <a>concatOf</a> ≡ <a>view</a>
--   </pre>
--   
--   <pre>
--   <a>concatOf</a> :: <a>Getter</a> s [r]     -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Fold</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Iso'</a> s [r]       -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Lens'</a> s [r]      -&gt; s -&gt; [r]
--   <a>concatOf</a> :: <a>Traversal'</a> s [r] -&gt; s -&gt; [r]
--   </pre>
concatOf :: Getting [r] s [r] -> s -> [r]

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf both "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a> ≡ <a>elemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>elemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a> ≡ <a>notElemOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Getter</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Fold</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; <a>Bool</a>
--   <a>notElemOf</a> :: <a>Eq</a> a =&gt; <a>Prism'</a> s a     -&gt; a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a> ≡ <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf traverse [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (traverse.traverse) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> (<a>folded</a> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a) -&gt; <a>Int</a>
--   </pre>
--   
--   <pre>
--   <a>lengthOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Int</a>
--   <a>lengthOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Int</a>
--   </pre>
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has no
--   targets in the given container.
--   
--   Note: <a>nullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>False</a>.
--   
--   <pre>
--   <a>null</a> ≡ <a>nullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <a>null</a> check of
--   many containers.
--   
--   <pre>
--   &gt;&gt;&gt; nullOf _1 (1,2)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf ignored ()
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf traverse []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; nullOf (element 20) [1..10]
--   True
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>nullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>nullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
nullOf :: Getting All s a -> s -> Bool

-- | Returns <a>True</a> if this <a>Fold</a> or <a>Traversal</a> has any
--   targets in the given container.
--   
--   A more "conversational" alias for this combinator is <a>has</a>.
--   
--   Note: <a>notNullOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> should always return <a>True</a>.
--   
--   <pre>
--   <a>not</a> <a>.</a> <a>null</a> ≡ <a>notNullOf</a> <a>folded</a>
--   </pre>
--   
--   This may be rather inefficient compared to the <tt><a>not</a> <a>.</a>
--   <a>null</a></tt> check of many containers.
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf _1 (1,2)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf traverse [1..10]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf folded []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notNullOf (element 20) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> (<a>folded</a> <a>.</a> <tt>_1</tt> <a>.</a> <a>folded</a>) :: (<a>Foldable</a> f, <a>Foldable</a> g) =&gt; f (g a, b) -&gt; <a>Bool</a>
--   </pre>
--   
--   <pre>
--   <a>notNullOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Bool</a>
--   <a>notNullOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Bool</a>
--   </pre>
notNullOf :: Getting Any s a -> s -> Bool

-- | Retrieve the <a>First</a> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><a>preview</a></tt> or <tt>^?'</tt> and gives you back access to
--   the outermost <a>Just</a> constructor more quickly, but does so in a
--   way that builds an intermediate structure, and thus may have worse
--   constant factors. This also means that it can not be used in any
--   <a>MonadReader</a>, but must instead have <tt>s</tt> passed as its
--   last argument, unlike <a>preview</a>.
--   
--   Note: this could been named <tt>headOf</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; firstOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf both (1,2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; firstOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>firstOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>firstOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a

-- | Retrieve the <a>First</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or the result from a <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first1Of both1 (1,2)
--   1
--   </pre>
--   
--   <i>Note:</i> this is different from <a>^.</a>.
--   
--   <pre>
--   &gt;&gt;&gt; first1Of traverse1 ([1,2] :| [[3,4],[5,6]])
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ([1,2] :| [[3,4],[5,6]]) ^. traverse1
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   <a>first1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>first1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
first1Of :: Getting (First a) s a -> s -> a

-- | Retrieve the <tt>Last</tt> entry of a <a>Fold</a> or <a>Traversal</a>
--   or retrieve <a>Just</a> the result from a <a>Getter</a> or
--   <a>Lens</a>.
--   
--   The answer is computed in a manner that leaks space less than
--   <tt><tt>ala</tt> <tt>Last</tt> <a>.</a> <a>foldMapOf</a></tt> and
--   gives you back access to the outermost <a>Just</a> constructor more
--   quickly, but may have worse constant factors.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf both (1,2)
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf ignored ()
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>lastOf</a> :: <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>lastOf</a> :: <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a

-- | Retrieve the <a>Last</a> entry of a <a>Fold1</a> or <a>Traversal1</a>
--   or retrieve the result from a <a>Getter</a> or <a>Lens</a>.o
--   
--   <pre>
--   &gt;&gt;&gt; last1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last1Of both1 (1,2)
--   2
--   </pre>
--   
--   <pre>
--   <a>last1Of</a> :: <a>Getter</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Fold1</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Lens'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Iso'</a> s a        -&gt; s -&gt; <a>Maybe</a> a
--   <a>last1Of</a> :: <a>Traversal1'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
last1Of :: Getting (Last a) s a -> s -> a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <tt>maximum</tt> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <tt>getMax</tt>
--   (<a>foldMapOf</a> l <tt>Max</tt>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the maximum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximum1Of traverse1 (1 :| [2..10])
--   10
--   </pre>
--   
--   <pre>
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>maximum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> or
--   <a>Traversal</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf traverse []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded.filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <tt>minimum</tt> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt><a>rmap</a> <tt>getMin</tt>
--   (<a>foldMapOf</a> l <tt>Min</tt>)</tt> has lazier semantics but could
--   leak memory.
--   
--   <pre>
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a     -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Fold</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a       -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a      -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumOf</a> :: <a>Ord</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a

-- | Obtain the minimum element targeted by a <a>Fold1</a> or
--   <a>Traversal1</a>.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1Of traverse1 (1 :| [2..10])
--   1
--   </pre>
--   
--   <pre>
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Getter</a> s a      -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Fold1</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Iso'</a> s a        -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Lens'</a> s a       -&gt; s -&gt; a
--   <a>minimum1Of</a> :: <a>Ord</a> a =&gt; <a>Traversal1'</a> s a -&gt; s -&gt; a
--   </pre>
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>maximumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>maximumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a> or <a>Getter</a> according
--   to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf traverse (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <tt>minimumBy</tt> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
--   
--   <pre>
--   <a>minimumByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>minimumByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; <a>Ordering</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | The <a>findOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
--   
--   <pre>
--   <a>find</a> ≡ <a>findOf</a> <a>folded</a>
--   <a>ifindOf</a> l ≡ <a>findOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findOf</a> :: <a>Getting</a> (<a>Endo</a> (<a>Maybe</a> a)) s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>findOf</a> l p = <a>foldrOf</a> l (a y -&gt; if p a then <a>Just</a> a else y) <a>Nothing</a>
--   </pre>
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a

-- | The <a>findMOf</a> function takes a <a>Lens</a> (or <a>Getter</a>,
--   <a>Iso</a>, <a>Fold</a>, or <a>Traversal</a>), a monadic predicate and
--   a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each ( \x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Getter</a> s a)     -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Fold</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Iso'</a> s a)       -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Lens'</a> s a)      -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> :: (<a>Monad</a> m, <a>Traversal'</a> s a) -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   <a>ifindMOf</a> l ≡ <a>findMOf</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   A simpler version that didn't permit indexing, would be:
--   
--   <pre>
--   <a>findMOf</a> :: Monad m =&gt; <a>Getting</a> (<a>Endo</a> (m (<a>Maybe</a> a))) s a -&gt; (a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>findMOf</a> l p = <a>foldrOf</a> l (a y -&gt; p a &gt;&gt;= x -&gt; if x then return (<a>Just</a> a) else y) $ return <a>Nothing</a>
--   </pre>
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)

-- | Strictly fold right over the elements of a structure.
--   
--   <pre>
--   <a>foldr'</a> ≡ <a>foldrOf'</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrOf'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>foldrOf'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r

-- | A variant of <a>foldrOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldr1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldr1</a> ≡ <a>foldr1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldr1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf</a> that has no base case and thus may only be
--   applied to lenses and structures such that the <a>Lens</a> views at
--   least one element of the structure.
--   
--   <pre>
--   &gt;&gt;&gt; foldl1Of each (+) (1,2,3,4)
--   10
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> l f ≡ <a>foldl1</a> f <a>.</a> <a>toListOf</a> l
--   <a>foldl1</a> ≡ <a>foldl1Of</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldl1Of</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldrOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldr1Of</a> l f ≡ <a>foldr1</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldr1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldr1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a

-- | A variant of <a>foldlOf'</a> that has no base case and thus may only
--   be applied to folds and structures such that the fold views at least
--   one element of the structure.
--   
--   <pre>
--   <a>foldl1Of'</a> l f ≡ <a>foldl1'</a> f <a>.</a> <a>toListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>foldl1Of'</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   <a>foldl1Of'</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; a
--   </pre>
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
--   
--   <pre>
--   <a>foldrM</a> ≡ <a>foldrMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldrMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
--   
--   <pre>
--   <a>foldlM</a> ≡ <a>foldlMOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Getter</a> s a     -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Fold</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Iso'</a> s a       -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Lens'</a> s a      -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>foldlMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; (r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r

-- | The <a>lookupOf</a> function takes a <a>Fold</a> (or <a>Getter</a>,
--   <a>Traversal</a>, <a>Lens</a>, <a>Iso</a>, etc.), a key, and a
--   structure containing key/value pairs. It returns the first value
--   corresponding to the given key. This function generalizes
--   <a>lookup</a> to work on an arbitrary <a>Fold</a> instead of lists.
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 4 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf each 2 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'a'
--   </pre>
--   
--   <pre>
--   <a>lookupOf</a> :: <a>Eq</a> k =&gt; <a>Fold</a> s (k,v) -&gt; k -&gt; s -&gt; <a>Maybe</a> v
--   </pre>
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v

-- | Fold an <a>IndexedFold</a> or <a>IndexedTraversal</a> by mapping
--   indices and values to an arbitrary <a>Monoid</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldMapOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldMapOf</a> l ≡ <a>ifoldMapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldMapOf</a> ::             <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> ::             <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   <a>ifoldMapOf</a> :: <a>Monoid</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m) -&gt; s -&gt; m
--   </pre>
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m

-- | Right-associative fold of parts of a structure that are viewed through
--   an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldrOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf</a> l ≡ <a>ifoldrOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Left-associative fold of the parts of a structure that are viewed
--   through an <a>IndexedFold</a> or <a>IndexedTraversal</a> with access
--   to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>foldlOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf</a> l ≡ <a>ifoldlOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Return whether or not any element viewed through an <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> satisfy a predicate, with access to the
--   <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> l ≡ <a>ianyOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ianyOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>ianyOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> l ≡ <a>iallOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iallOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>iallOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not none of the elements viewed through an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> satisfy a predicate,
--   with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> l ≡ <a>inoneOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>inoneOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   <a>inoneOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Bool</a>
--   </pre>
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the <tt>i</tt>, discarding the
--   results.
--   
--   When you don't need access to the index then <a>traverseOf_</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>traverseOf_</a> l ≡ <a>itraverseOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   <a>itraverseOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; f r) -&gt; s -&gt; f ()
--   </pre>
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()

-- | Traverse the targets of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforOf_</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forOf_</a> l a ≡ <a>iforOf_</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   <a>iforOf_</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; f r) -&gt; f ()
--   </pre>
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results.
--   
--   When you don't need access to the index then <a>mapMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>mapMOf_</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   <a>imapMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m r) -&gt; s -&gt; m ()
--   </pre>
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()

-- | Run monadic actions for each target of an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> with access to the index, discarding the
--   results (with the arguments flipped).
--   
--   <pre>
--   <a>iforMOf_</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf_</a>
--   </pre>
--   
--   When you don't need access to the index then <a>forMOf_</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>forMOf_</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   <a>iforMOf_</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; s -&gt; (i -&gt; a -&gt; m r) -&gt; m ()
--   </pre>
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()

-- | Concatenate the results of a function of the elements of an
--   <a>IndexedFold</a> or <a>IndexedTraversal</a> with access to the
--   index.
--   
--   When you don't need access to the index then <a>concatMapOf</a> is
--   more flexible in what it accepts.
--   
--   <pre>
--   <a>concatMapOf</a> l ≡ <a>iconcatMapOf</a> l <a>.</a> <a>const</a>
--   <a>iconcatMapOf</a> ≡ <a>ifoldMapOf</a>
--   </pre>
--   
--   <pre>
--   <a>iconcatMapOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   <a>iconcatMapOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; [r]) -&gt; s -&gt; [r]
--   </pre>
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]

-- | The <a>ifindOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a predicate that is also supplied the index,
--   a structure and returns the left-most element of the structure
--   matching the predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findOf</a> l ≡ <a>ifindOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindOf</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   <a>ifindOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> a
--   </pre>
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a

-- | The <a>ifindMOf</a> function takes an <a>IndexedFold</a> or
--   <a>IndexedTraversal</a>, a monadic predicate that is also supplied the
--   index, a structure and returns in the monad the left-most element of
--   the structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>findMOf</a> l ≡ <a>ifindMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   <a>ifindMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; m <a>Bool</a>) -&gt; s -&gt; m (<a>Maybe</a> a)
--   </pre>
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)

-- | <i>Strictly</i> fold right over the elements of a structure with an
--   index.
--   
--   When you don't need access to the index then <a>foldrOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrOf'</a> l ≡ <a>ifoldrOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrOf'</a> :: <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldrOf'</a> :: <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold over the elements of a structure with an index, associating to
--   the left, but <i>strictly</i>.
--   
--   When you don't need access to the index then <a>foldlOf'</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlOf'</a> l ≡ <a>ifoldlOf'</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlOf'</a> :: <a>IndexedGetter</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedFold</a> i s a         -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedLens'</a> i s a        -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   <a>ifoldlOf'</a> :: <a>IndexedTraversal'</a> i s a   -&gt; (i -&gt; r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
--   </pre>
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Monadic fold right over the elements of a structure with an index.
--   
--   When you don't need access to the index then <a>foldrMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldrMOf</a> l ≡ <a>ifoldrMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldrMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; a -&gt; r -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r

-- | Monadic fold over the elements of a structure with an index,
--   associating to the left.
--   
--   When you don't need access to the index then <a>foldlMOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>foldlMOf</a> l ≡ <a>ifoldlMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedGetter</a> i s a     -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedFold</a> i s a       -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens'</a> i s a      -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   <a>ifoldlMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal'</a> i s a -&gt; (i -&gt; r -&gt; a -&gt; m r) -&gt; r -&gt; s -&gt; m r
--   </pre>
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r

-- | Extract the key-value pairs from a structure.
--   
--   When you don't need access to the indices in the result, then
--   <a>toListOf</a> is more flexible in what it accepts.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>map</a> <a>snd</a> <a>.</a> <a>itoListOf</a> l
--   </pre>
--   
--   <pre>
--   <a>itoListOf</a> :: <a>IndexedGetter</a> i s a     -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedFold</a> i s a       -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [(i,a)]
--   <a>itoListOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [(i,a)]
--   </pre>
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which is equal to a given value.
--   
--   <pre>
--   <a>elemIndex</a> ≡ <a>elemIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   <a>elemIndexOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which are equal to a given value.
--   
--   <pre>
--   <a>elemIndices</a> ≡ <a>elemIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedFold</a> i s a       -&gt; a -&gt; s -&gt; [i]
--   <a>elemIndicesOf</a> :: <a>Eq</a> a =&gt; <a>IndexedTraversal'</a> i s a -&gt; a -&gt; s -&gt; [i]
--   </pre>
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]

-- | Retrieve the index of the first value targeted by a <a>IndexedFold</a>
--   or <a>IndexedTraversal</a> which satisfies a predicate.
--   
--   <pre>
--   <a>findIndex</a> ≡ <a>findIndexOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndexOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   <a>findIndexOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; <a>Maybe</a> i
--   </pre>
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i

-- | Retrieve the indices of the values targeted by a <a>IndexedFold</a> or
--   <a>IndexedTraversal</a> which satisfy a predicate.
--   
--   <pre>
--   <a>findIndices</a> ≡ <a>findIndicesOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   <a>findIndicesOf</a> :: <a>IndexedFold</a> i s a       -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   <a>findIndicesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; (a -&gt; <a>Bool</a>) -&gt; s -&gt; [i]
--   </pre>
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]

-- | Filter an <a>IndexedFold</a> or <a>IndexedGetter</a>, obtaining an
--   <a>IndexedFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,0,0,5,5,5]^..traversed.ifiltered (\i a -&gt; i &lt;= a)
--   [0,5,5,5]
--   </pre>
--   
--   Compose with <a>ifiltered</a> to filter another <a>IndexedLens</a>,
--   <tt>IndexedIso</tt>, <a>IndexedGetter</a>, <a>IndexedFold</a> (or
--   <a>IndexedTraversal</a>) with access to both the value and the index.
--   
--   Note: As with <a>filtered</a>, this is <i>not</i> a legal
--   <a>IndexedTraversal</a>, unless you are very careful not to invalidate
--   the predicate on the target!
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a

-- | Obtain an <a>IndexedFold</a> by taking elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a
--   <a>itakingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: Applying <a>itakingWhile</a> to an <a>IndexedLens</a> or
--   <a>IndexedTraversal</a> will still allow you to use it as a
--   pseudo-<a>IndexedTraversal</a>, but if you change the value of any
--   target to one where the predicate returns <a>False</a>, then you will
--   break the <a>Traversal</a> laws and <a>Traversal</a> fusion will no
--   longer be sound.
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s))) s a -> Optical' p q f s a

-- | Obtain an <a>IndexedFold</a> by dropping elements from another
--   <a>IndexedFold</a>, <a>IndexedLens</a>, <a>IndexedGetter</a> or
--   <a>IndexedTraversal</a> while a predicate holds.
--   
--   <pre>
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> i s a    -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedLens'</a> i s a         -&gt; <a>IndexedFold</a> i s a -- see notes
--   <a>idroppingWhile</a> :: (i -&gt; a -&gt; <a>Bool</a>) -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   Note: As with <a>droppingWhile</a> applying <a>idroppingWhile</a> to
--   an <a>IndexedLens</a> or <a>IndexedTraversal</a> will still allow you
--   to use it as a pseudo-<a>IndexedTraversal</a>, but if you change the
--   value of the first target to one where the predicate returns
--   <a>True</a>, then you will break the <a>Traversal</a> laws and
--   <a>Traversal</a> fusion will no longer be sound.
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldByOf</a> <a>folded</a> ≡ <a>foldBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldByOf</a> :: <a>Getter</a> s a     -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Fold</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Lens'</a> s a      -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Traversal'</a> s a -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   <a>foldByOf</a> :: <a>Iso'</a> s a       -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldByOf both (++) [] ("hello","world")
--   "helloworld"
--   </pre>
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a

-- | Fold a value using a specified <a>Fold</a> and <a>Monoid</a>
--   operations. This is like <a>foldMapBy</a> where the <a>Foldable</a>
--   instance can be manually specified.
--   
--   <pre>
--   <a>foldMapByOf</a> <a>folded</a> ≡ <a>foldMapBy</a>
--   </pre>
--   
--   <pre>
--   <a>foldMapByOf</a> :: <a>Getter</a> s a     -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Fold</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Traversal'</a> s a -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Lens'</a> s a      -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>foldMapByOf</a> :: <a>Iso'</a> s a       -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMapByOf both (+) 0 length ("hello","world")
--   10
--   </pre>
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r

-- | <pre>
--   <a>ito</a> :: (s -&gt; (i, a)) -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a

-- | Build an constant-valued (index-preserving) <a>Getter</a> from an
--   arbitrary Haskell value.
--   
--   <pre>
--   <a>like</a> a <a>.</a> <a>like</a> b ≡ <a>like</a> b
--   a <a>^.</a> <a>like</a> b ≡ b
--   a <a>^.</a> <a>like</a> b ≡ a <a>^.</a> <a>to</a> (<a>const</a> b)
--   </pre>
--   
--   This can be useful as a second case <tt>failing</tt> a <a>Fold</a>
--   e.g. <tt>foo <tt>failing</tt> <a>like</a> 0</tt>
--   
--   <pre>
--   <a>like</a> :: a -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a

-- | <pre>
--   <a>ilike</a> :: i -&gt; a -&gt; <a>IndexedGetter</a> i s a
--   </pre>
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | View a function of the value pointed to by a <a>Getter</a> or
--   <a>Lens</a> or the result of folding over the result of mapping the
--   targets of a <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>views</a> l f ≡ <a>view</a> (l <a>.</a> <a>to</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views (to f) g a
--   g (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views _2 length (1,"hello")
--   5
--   </pre>
--   
--   As <a>views</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>views</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m) -&gt; s -&gt; m
--   <a>views</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m) -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m =&gt; <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
views :: MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) (a,b)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ("hello","world")
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s r       -&gt; m r
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s r -&gt; m r
--   </pre>
use :: MonadState s m => Getting a s a -> m a

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (uses _1 length) ("hello","world")
--   5
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m =&gt; <a>Getting</a> r s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
uses :: MonadState s m => LensLike' (Const r) s a -> (a -> r) -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Fold</a> w u       -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Traversal'</a> w u -&gt; m a -&gt; m (a, u)
--   <a>listening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>Prism'</a> w u     -&gt; m a -&gt; m (a, u)
--   </pre>
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Getter</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Lens'</a> w u      -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>Iso'</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Fold</a> w u       -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Traversal'</a> w u -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>listenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>Prism'</a> w u     -&gt; (u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)

-- | View the index and value of an <a>IndexedGetter</a> into the current
--   environment as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | View a function of the index and value of an <a>IndexedGetter</a> into
--   the current environment.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
--   
--   <pre>
--   <a>iviews</a> ≡ <a>ifoldMapOf</a>
--   </pre>
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | Use the index and value of an <a>IndexedGetter</a> into the current
--   state as a pair.
--   
--   When applied to an <a>IndexedFold</a> the result will most likely be a
--   nonsensical monoidal summary of the indices tupled with a monoidal
--   summary of the values and probably not whatever it is you wanted.
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)

-- | Use a function of the index and value of an <a>IndexedGetter</a> into
--   the current state.
--   
--   When applied to an <a>IndexedFold</a> the result will be a monoidal
--   summary instead of a single answer.
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> i w u     -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> i w u      -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedFold</a> i w u       -&gt; m a -&gt; m (a, (i, u))
--   <a>ilistening</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> u) =&gt; <a>IndexedTraversal'</a> i w u -&gt; m a -&gt; m (a, (i, u))
--   </pre>
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))

-- | This is a generalized form of <a>listen</a> that only extracts the
--   portion of the log that is focused on by a <a>Getter</a>. If given a
--   <a>Fold</a> or a <a>Traversal</a> then a monoidal summary of the parts
--   of the log that are visited will be returned.
--   
--   <pre>
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedGetter</a> w u     -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: <a>MonadWriter</a> w m             =&gt; <a>IndexedLens'</a> w u      -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedFold</a> w u       -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   <a>ilistenings</a> :: (<a>MonadWriter</a> w m, <a>Monoid</a> v) =&gt; <a>IndexedTraversal'</a> w u -&gt; (i -&gt; u -&gt; v) -&gt; m a -&gt; m (a, v)
--   </pre>
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)

-- | Coerce a <a>Getter</a>-compatible <a>Optical</a> to an
--   <a>Optical'</a>. This is useful when using a <a>Traversal</a> that is
--   not simple as a <a>Getter</a> or a <a>Fold</a>.
--   
--   <pre>
--   <a>getting</a> :: <a>Traversal</a> s t a b          -&gt; <a>Fold</a> s a
--   <a>getting</a> :: <a>Lens</a> s t a b               -&gt; <a>Getter</a> s a
--   <a>getting</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedFold</a> i s a
--   <a>getting</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedGetter</a> i s a
--   </pre>
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>id</a>.
--   
--   Note: When used to modify the value, this can break the index
--   requirements assumed by <a>indices</a> and similar, so this is only
--   properly an <a>IndexedGetter</a>, but it can be used as more.
--   
--   <pre>
--   <a>selfIndex</a> :: <a>IndexedGetter</a> a a b
--   </pre>
selfIndex :: Indexable a p => p a fb -> a -> fb

-- | Remap the index.
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r

-- | Composition of <a>Indexed</a> functions with a user supplied function
--   for combining indices.
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   <pre>
--   <a>indexing</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int</a>  s t a b
--   <a>indexing</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int</a> s t a b
--   <a>indexing</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   <a>indexing</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing</a> :: <a>Indexable</a> <a>Int</a> p =&gt; <a>LensLike</a> (<a>Indexing</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t

-- | Transform a <a>Traversal</a> into an <a>IndexedTraversal</a> or a
--   <a>Fold</a> into an <a>IndexedFold</a>, etc.
--   
--   This combinator is like <a>indexing</a> except that it handles large
--   traversals and folds gracefully.
--   
--   <pre>
--   <a>indexing64</a> :: <a>Traversal</a> s t a b -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Prism</a> s t a b     -&gt; <a>IndexedTraversal</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Lens</a> s t a b      -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Iso</a> s t a b       -&gt; <a>IndexedLens</a> <a>Int64</a> s t a b
--   <a>indexing64</a> :: <a>Fold</a> s a          -&gt; <a>IndexedFold</a> <a>Int64</a> s a
--   <a>indexing64</a> :: <a>Getter</a> s a        -&gt; <a>IndexedGetter</a> <a>Int64</a> s a
--   </pre>
--   
--   <pre>
--   <a>indexing64</a> :: <a>Indexable</a> <a>Int64</a> p =&gt; <a>LensLike</a> (<a>Indexing64</a> f) s t a b -&gt; <a>Over</a> p f s t a b
--   </pre>
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t

-- | The <a>IndexedSetter</a> for a <a>FunctorWithIndex</a>.
--   
--   If you don't need access to the index, then <a>mapped</a> is more
--   flexible in what it accepts.
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b

-- | The <a>IndexedFold</a> of a <a>FoldableWithIndex</a> container.
--   
--   <tt><a>ifolded</a> <a>.</a> <a>asIndex</a></tt> is a fold over the
--   keys of a <a>FoldableWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Map.fromList [(2, "hello"), (1, "world")]^..ifolded.asIndex
--   [1,2]
--   </pre>
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a

-- | Fold a container with indices returning both the indices and the
--   values.
--   
--   The result is only valid to compose in a <tt>Traversal</tt>, if you
--   don't edit the index as edits to the index have no effect.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex
--   [(0,10),(1,20),(2,30)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [10, 20, 30] ^.. ifolded . withIndex . alongside negated (re _Show)
--   [(0,"10"),(-1,"20"),(-2,"30")]
--   </pre>
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)

-- | When composed with an <tt>IndexedFold</tt> or
--   <tt>IndexedTraversal</tt> this yields an (<a>Indexed</a>)
--   <tt>Fold</tt> of the indices.
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)

-- | The <a>IndexedTraversal</a> of a <a>TraversableWithIndex</a>
--   container.
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
itraverseBy :: TraversableWithIndex i t => (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t

-- | Generate a <tt>Prism</tt> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <tt>Prism</tt> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz . _Foo
--     _Bar = _FooBarBaz . _Bar
--     _Baz = _FooBarBaz . _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
--   
--   In the event that the name of a data type is also the name of one of
--   its constructors, the name of the <tt>Prism</tt> generated for the
--   data type will be prefixed with an extra <tt>_</tt> (if the data type
--   name is prefix) or <tt>.</tt> (if the name is infix) to disambiguate
--   it from the <tt>Prism</tt> for the corresponding constructor. For
--   example, this code:
--   
--   <pre>
--   data Quux = Quux Int | Fred Bool
--   makeClassyPrisms ''Quux
--   </pre>
--   
--   will create:
--   
--   <pre>
--   class AsQuux s where
--     __Quux :: Prism' s Quux -- Data type prism
--     _Quux :: Prism' s Int   -- Constructor prism
--     _Fred :: Prism' s Bool
--   
--     _Quux = __Quux . _Quux
--     _Fred = __Quux . _Fred
--   
--   instance AsQuux Quux
--   </pre>
makeClassyPrisms :: Name -> DecsQ

-- | This is a profunctor used internally to implement <a>Review</a>
--   
--   It plays a role similar to that of <a>Accessor</a> or <tt>Const</tt>
--   do for <a>Control.Lens.Getter</a>
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b

-- | Build a simple isomorphism from a pair of inverse functions.
--   
--   <pre>
--   <a>view</a> (<a>iso</a> f g) ≡ f
--   <a>view</a> (<a>from</a> (<a>iso</a> f g)) ≡ g
--   <a>over</a> (<a>iso</a> f g) h ≡ g <a>.</a> h <a>.</a> f
--   <a>over</a> (<a>from</a> (<a>iso</a> f g)) h ≡ f <a>.</a> h <a>.</a> g
--   </pre>
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Convert from <a>AnIso</a> back to any <a>Iso</a>.
--   
--   This is useful when you need to store an isomorphism as a data type
--   inside a container and later reconstitute it as an overloaded
--   function.
--   
--   See <a>cloneLens</a> or <a>cloneTraversal</a> for more information on
--   why you might want to do this.
cloneIso :: AnIso s t a b -> Iso s t a b

-- | Extract the two functions, one from <tt>s -&gt; a</tt> and one from
--   <tt>b -&gt; t</tt> that characterize an <a>Iso</a>.
withIso :: forall s t a b rep (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Based on <a>ala</a> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler type:
--   
--   <pre>
--   au :: AnIso s t a b -&gt; ((b -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; a
--   </pre>
--   
--   <pre>
--   au = xplat . from
--   </pre>
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a

-- | Based on <tt>ala'</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   For a version you pass the name of the <tt>newtype</tt> constructor
--   to, see <a>alaf</a>.
--   
--   <pre>
--   &gt;&gt;&gt; auf (_Wrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   Mnemonically, the German <i>auf</i> plays a similar role to <i>à
--   la</i>, and the combinator is <a>au</a> with an extra function
--   argument:
--   
--   <pre>
--   <a>auf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; b) -&gt; e -&gt; a
--   </pre>
--   
--   but the signature is general.
--   
--   Note: The direction of the <a>Iso</a> required for this function
--   changed in <tt>lens</tt> 4.18 to match up with the behavior of
--   <a>au</a>. For the old behavior use <a>xplatf</a> or for a version
--   that is compatible across both old and new versions of <tt>lens</tt>
--   you can just use <a>coerce</a>!
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a

-- | <tt><a>xplat</a> = <a>au</a> . <a>from</a></tt> but with a nicer
--   signature.
xplat :: Optic (Costar ((->) s)) g s t a b -> ((s -> a) -> g b) -> g t

-- | <tt><a>xplatf</a> = <a>auf</a> . <a>from</a></tt> but with a nicer
--   signature.
--   
--   <pre>
--   &gt;&gt;&gt; xplatf (_Unwrapping Sum) (foldMapOf both) Prelude.length ("hello","world")
--   10
--   </pre>
--   
--   <pre>
--   <a>xplatf</a> :: <a>Iso</a> s t a b -&gt; ((r -&gt; a) -&gt; e -&gt; b) -&gt; (r -&gt; s) -&gt; e -&gt; t
--   </pre>
xplatf :: Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a> ≡ <a>over</a> <a>.</a> <a>from</a>
--   </pre>
--   
--   <pre>
--   <a>under</a> :: <a>Iso</a> s t a b -&gt; (t -&gt; s) -&gt; b -&gt; a
--   </pre>
under :: AnIso s t a b -> (t -> s) -> b -> a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 +~ 2
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" . non 0 -~ 1
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" . non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" . non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . non Map.empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . non Map.empty . at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" . non' _Empty . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . non' _Empty . at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: APrism' a () -> Iso' (Maybe a) a

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" . anon Map.empty Map.null . at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",Map.fromList [("world","!!!")])] &amp; at "hello" . anon Map.empty Map.null . at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | This isomorphism can be used to convert to or from an instance of
--   <a>Enum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; LT^.from enum
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 97^.enum :: Char
--   'a'
--   </pre>
--   
--   Note: this is only an isomorphism from the numeric range actually used
--   and it is a bit of a pleasant fiction, since there are questionable
--   <a>Enum</a> instances for <a>Double</a>, and <a>Float</a> that exist
--   solely for <tt>[1.0 .. 4.0]</tt> sugar and the instances for those and
--   <a>Integer</a> don't cover all values in their range.
enum :: Enum a => Iso' Int a

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (fst^.curried) 3 4
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>from</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ((+)^.uncurried) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; ((,)^.flipped) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | An <a>Iso</a> between a list, <tt>ByteString</tt>, <tt>Text</tt>
--   fragment, etc. and its reversal.
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. reversed
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; reversed %~ ('d':)
--   "lived"
--   </pre>
reversed :: Reversing a => Iso' a a

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a> ≡ <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a

-- | This isomorphism can be used to inspect a <a>Traversal</a> to see how
--   it associates the structure and it can also be used to bake the
--   <a>Traversal</a> into a <a>Magma</a> so that you can traverse over it
--   multiple times.
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)

-- | This isomorphism can be used to inspect an <a>IndexedTraversal</a> to
--   see how it associates the structure and it can also be used to bake
--   the <a>IndexedTraversal</a> into a <a>Magma</a> so that you can
--   traverse over it multiple times with access to the original indices.
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)

-- | Lift an <a>Iso</a> into a <a>Contravariant</a> functor.
--   
--   <pre>
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (f a) (f b) (f s) (f t)
--   contramapping :: <a>Contravariant</a> f =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (f a) (f s)
--   </pre>
contramapping :: Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Profunctor</a>
--   simultaneously.
--   
--   <pre>
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p a s') (p b t') (p s a') (p t b')
--   dimapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p a s') (p s a')
--   </pre>
dimapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')

-- | Lift an <a>Iso</a> contravariantly into the left argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p a x) (p b y) (p s x) (p t y)
--   lmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p a x) (p s x)
--   </pre>
lmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)

-- | Lift an <a>Iso</a> covariantly into the right argument of a
--   <a>Profunctor</a>.
--   
--   <pre>
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   rmapping :: <a>Profunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
rmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)

-- | Lift two <a>Iso</a>s into both arguments of a <a>Bifunctor</a>.
--   
--   <pre>
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> s' t' a' b' -&gt; <a>Iso</a> (p s s') (p t t') (p a a') (p b b')
--   bimapping :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> s' a' -&gt; <a>Iso'</a> (p s s') (p a a')
--   </pre>
bimapping :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')

-- | Lift an <a>Iso</a> into the first argument of a <a>Bifunctor</a>.
--   
--   <pre>
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p s x) (p t y) (p a x) (p b y)
--   firsting :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p s x) (p a x)
--   </pre>
firsting :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)

-- | Lift an <a>Iso</a> into the second argument of a <a>Bifunctor</a>.
--   This is essentially the same as <a>mapping</a>, but it takes a
--   'Bifunctor p' constraint instead of a 'Functor (p a)' one.
--   
--   <pre>
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso</a> s t a b -&gt; <a>Iso</a> (p x s) (p y t) (p x a) (p y b)
--   seconding :: <a>Bifunctor</a> p =&gt; <a>Iso'</a> s a -&gt; <a>Iso'</a> (p x s) (p x a)
--   </pre>
seconding :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)

-- | Data types that are representationally equal are isomorphic.
--   
--   This is only available on GHC 7.8+
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b

-- | Build a <a>Lens</a> from a getter and a setter.
--   
--   <pre>
--   <a>lens</a> :: <a>Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s ^. lens getter setter
--   getter s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter .~ b
--   setter s b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s &amp; lens getter setter %~ f
--   setter s (f (getter s))
--   </pre>
--   
--   <pre>
--   <a>lens</a> :: (s -&gt; a) -&gt; (s -&gt; a -&gt; s) -&gt; <a>Lens'</a> s a
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Build an <a>IndexedLens</a> from a <a>Getter</a> and a <a>Setter</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b

-- | Build an index-preserving <a>Lens</a> from a <a>Getter</a> and a
--   <a>Setter</a>.
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b

-- | Obtain a getter and a setter from a lens, reversing <a>lens</a>.
withLens :: forall s t a b rep (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r

-- | Merge two lenses, getters, setters, folds or traversals.
--   
--   <pre>
--   <a>chosen</a> ≡ <a>choosing</a> <a>id</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>choosing</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s' a     -&gt; <a>Getter</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Fold</a> s a       -&gt; <a>Fold</a> s' a       -&gt; <a>Fold</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s' a      -&gt; <a>Lens'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> s' a -&gt; <a>Traversal'</a> (<a>Either</a> s s') a
--   <a>choosing</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> s' a    -&gt; <a>Setter'</a> (<a>Either</a> s s') a
--   </pre>
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b

-- | <a>alongside</a> makes a <a>Lens</a> from two other lenses or a
--   <a>Getter</a> from two other getters by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b)^.alongside chosen chosen
--   (a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left a, Right b) &amp; alongside chosen chosen .~ (c,d)
--   (Left c,Right d)
--   </pre>
--   
--   <pre>
--   <a>alongside</a> :: <a>Lens</a>   s t a b -&gt; <a>Lens</a>   s' t' a' b' -&gt; <a>Lens</a>   (s,s') (t,t') (a,a') (b,b')
--   <a>alongside</a> :: <a>Getter</a> s   a   -&gt; <a>Getter</a> s'    a'    -&gt; <a>Getter</a> (s,s')        (a,a')
--   </pre>
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')

-- | Lift a <a>Lens</a> so it can run under a function (or other
--   corepresentable profunctor).
--   
--   <pre>
--   <a>inside</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> (e -&gt; s) (e -&gt; t) (e -&gt; a) (e -&gt; b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (\x -&gt; (x-1,x+1)) ^. inside _1 $ 5
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runState (modify (1:) &gt;&gt; modify (2:)) ^. (inside _2) $ []
--   [2,1]
--   </pre>
inside :: Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)

-- | Cloning a <a>Lens</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Traversal</a> and can be used as a way
--   to pass around lenses that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let example l x = set (cloneLens l) (x^.cloneLens l + 1) x in example _2 ("hello",1,"you")
--   ("hello",2,"you")
--   </pre>
cloneLens :: ALens s t a b -> Lens s t a b

-- | Clone a <a>Lens</a> as an <tt>IndexedPreservingLens</tt> that just
--   passes through whatever index is on any <a>IndexedLens</a>,
--   <a>IndexedFold</a>, <a>IndexedGetter</a> or <a>IndexedTraversal</a> it
--   is composed with.
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b

-- | Clone an <a>IndexedLens</a> as an <a>IndexedLens</a> with the same
--   index.
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b

-- | <a>over</a> for Arrows.
--   
--   Unlike <a>over</a>, <a>overA</a> can't accept a simple <a>Setter</a>,
--   but requires a full lens, or close enough.
--   
--   <pre>
--   &gt;&gt;&gt; overA _1 ((+1) *** (+2)) ((1,2),6)
--   ((2,4),6)
--   </pre>
--   
--   <pre>
--   overA :: Arrow ar =&gt; Lens s t a b -&gt; ar a b -&gt; ar s t
--   </pre>
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t

-- | A version of <a>set</a> that works on <a>ALens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; storing _2 "world" ("hello","there")
--   ("hello","world")
--   </pre>
storing :: ALens s t a b -> b -> s -> t

-- | There is a field for every type in the <a>Void</a>. Very zen.
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; mapped.devoid +~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; mapped.devoid %~ abs
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>devoid</a> :: <a>Lens'</a> <a>Void</a> a
--   </pre>
devoid :: Over p f Void Void a b

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; "hello"^.united
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" &amp; united .~ ()
--   "hello"
--   </pre>
united :: Lens' a ()

-- | A <a>Lens</a> focusing on the first element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; head1 +~ 10
--   12 :| [3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Identity True ^. head1
--   True
--   </pre>
head1 :: Traversable1 t => Lens' (t a) a

-- | A <a>Lens</a> focusing on the last element of a <a>Traversable1</a>
--   container.
--   
--   <pre>
--   &gt;&gt;&gt; 2 :| [3, 4] &amp; last1 +~ 10
--   2 :| [3,14]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Node 'a' [Node 'b' [], Node 'c' []] ^. last1
--   'c'
--   </pre>
last1 :: Traversable1 t => Lens' (t a) a

-- | This <a>Lens</a> lets you <tt>view</tt> the current <tt>pos</tt> of
--   any indexed store comonad and <tt>seek</tt> to a new position. This
--   reduces the API for working these instances to a single <a>Lens</a>.
--   
--   <pre>
--   <a>ipos</a> w ≡ w <a>^.</a> <a>locus</a>
--   <a>iseek</a> s w ≡ w <a>&amp;</a> <a>locus</a> <a>.~</a> s
--   <a>iseeks</a> f w ≡ w <a>&amp;</a> <a>locus</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   <a>locus</a> :: <a>Lens'</a> (<a>Context'</a> a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>Pretext'</a> p a s) a
--   <a>locus</a> :: <a>Conjoined</a> p =&gt; <a>Lens'</a> (<a>PretextT'</a> p g a s) a
--   </pre>
locus :: IndexedComonadStore p => Lens (p a c s) (p b c s) a b

-- | Fuse a composition of lenses using <a>Yoneda</a> to provide
--   <a>fmap</a> fusion.
--   
--   In general, given a pair of lenses <tt>foo</tt> and <tt>bar</tt>
--   
--   <pre>
--   fusing (foo.bar) = foo.bar
--   </pre>
--   
--   however, <tt>foo</tt> and <tt>bar</tt> are either going to <a>fmap</a>
--   internally or they are trivial.
--   
--   <a>fusing</a> exploits the <a>Yoneda</a> lemma to merge these separate
--   uses into a single <a>fmap</a>.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Lens</a> <tt>foo.bar</tt> in
--   the above description is recursive or complex enough to prevent
--   inlining.
--   
--   <pre>
--   <a>fusing</a> :: <a>Lens</a> s t a b -&gt; <a>Lens</a> s t a b
--   </pre>
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b

-- | This provides a breadth-first <a>Traversal</a> or <a>Fold</a> of the
--   individual levels of any other <a>Traversal</a> or <a>Fold</a> via
--   iterative deepening depth-first search. The levels are returned to you
--   in a compressed format.
--   
--   This is similar to <a>levels</a>, but retains the index of the
--   original <a>IndexedTraversal</a>, so you can access it when traversing
--   the levels later on.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed).itraversed
--   [((0,0),'d'),((0,1),'o'),((1,0),'c'),((0,2),'g'),((1,1),'a'),((1,2),'t')]
--   </pre>
--   
--   The resulting <a>Traversal</a> of the levels which is indexed by the
--   depth of each <a>Level</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ["dog","cat"]^@..ilevels (traversed&lt;.&gt;traversed)&lt;.&gt;itraversed
--   [((2,(0,0)),'d'),((3,(0,1)),'o'),((3,(1,0)),'c'),((4,(0,2)),'g'),((4,(1,1)),'a'),((5,(1,2)),'t')]
--   </pre>
--   
--   <pre>
--   <a>ilevels</a> :: <a>IndexedTraversal</a> i s t a b      -&gt; <a>IndexedTraversal</a> <a>Int</a> s t (<a>Level</a> i a) (<a>Level</a> i b)
--   <a>ilevels</a> :: <a>IndexedFold</a> i s a               -&gt; <a>IndexedFold</a> <a>Int</a> s (<a>Level</a> i a)
--   </pre>
--   
--   <i>Note:</i> Internally this is implemented by using an illegal
--   <a>Applicative</a>, as it extracts information in an order that
--   violates the <a>Applicative</a> laws.
ilevels :: Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)

-- | Extract the immediate descendants of a <a>Plated</a> container.
--   
--   <pre>
--   <a>children</a> ≡ <a>toListOf</a> <a>plate</a>
--   </pre>
children :: Plated a => a -> [a]

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewrite r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universe</a> (<a>rewrite</a> r x))
--   </pre>
--   
--   Usually <a>transform</a> is more appropriate, but <a>rewrite</a> can
--   give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
rewrite :: Plated a => (a -> Maybe a) -> a -> a

-- | Rewrite by applying a rule everywhere you can. Ensures that the rule
--   cannot be applied anywhere in the result:
--   
--   <pre>
--   propRewriteOf l r x = <a>all</a> (<a>isNothing</a> <a>.</a> r) (<a>universeOf</a> l (<a>rewriteOf</a> l r x))
--   </pre>
--   
--   Usually <a>transformOf</a> is more appropriate, but <a>rewriteOf</a>
--   can give better compositionality. Given two single transformations
--   <tt>f</tt> and <tt>g</tt>, you can construct <tt>\a -&gt; f a
--   <a>&lt;|&gt;</a> g a</tt> which performs both rewrites until a fixed
--   point.
--   
--   <pre>
--   <a>rewriteOf</a> :: <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   <a>rewriteOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; a -&gt; a
--   </pre>
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b

-- | Rewrite recursively over part of a larger structure.
--   
--   <pre>
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOn</a> :: <a>Plated</a> a =&gt; <a>ASetter'</a> s a   -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t

-- | Rewrite recursively over part of a larger structure using a specified
--   <a>Setter</a>.
--   
--   <pre>
--   <a>rewriteOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a       -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a      -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   <a>rewriteOnOf</a> :: <a>Setter'</a> s a    -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; <a>Maybe</a> a) -&gt; s -&gt; s
--   </pre>
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t

-- | Rewrite by applying a monadic rule everywhere you can. Ensures that
--   the rule cannot be applied anywhere in the result.
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a

-- | Rewrite by applying a monadic rule everywhere you recursing with a
--   user-specified <a>Traversal</a>. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>. Ensures that the rule
--   cannot be applied anywhere in the result.
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t

-- | Rewrite by applying a monadic rule everywhere inside of a structure
--   located by a user-specified <a>Traversal</a>, using a user-specified
--   <a>Traversal</a> for recursion. Ensures that the rule cannot be
--   applied anywhere in the result.
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t

-- | Retrieve all of the transitive descendants of a <a>Plated</a>
--   container, including itself.
universe :: Plated a => a -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including
--   itself.
--   
--   <pre>
--   <a>universeOf</a> :: <a>Fold</a> a a -&gt; a -&gt; [a]
--   </pre>
universeOf :: Getting (Endo [a]) a a -> a -> [a]

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container retrieve them and all of their descendants, recursively.
universeOn :: Plated a => Getting (Endo [a]) s a -> s -> [a]

-- | Given a <a>Fold</a> that knows how to locate immediate children,
--   retrieve all of the transitive descendants of a node, including itself
--   that lie in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>toListOf</a> l ≡ <a>universeOnOf</a> l <a>ignored</a>
--   </pre>
universeOnOf :: Getting (Endo [a]) s a -> Getting (Endo [a]) a a -> s -> [a]

-- | Fold over all transitive descendants of a <a>Plated</a> container,
--   including itself.
cosmos :: Plated a => Fold a a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself.
--   
--   <pre>
--   <a>cosmosOf</a> :: <a>Fold</a> a a -&gt; <a>Fold</a> a a
--   </pre>
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a

-- | Given a <a>Fold</a> that knows how to find <a>Plated</a> parts of a
--   container fold them and all of their descendants, recursively.
--   
--   <pre>
--   <a>cosmosOn</a> :: <a>Plated</a> a =&gt; <a>Fold</a> s a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a

-- | Given a <a>Fold</a> that knows how to locate immediate children, fold
--   all of the transitive descendants of a node, including itself that lie
--   in a region indicated by another <a>Fold</a>.
--   
--   <pre>
--   <a>cosmosOnOf</a> :: <a>Fold</a> s a -&gt; <a>Fold</a> a a -&gt; <a>Fold</a> s a
--   </pre>
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a

-- | Transform every element by recursively applying a given <a>Setter</a>
--   in a bottom-up manner.
--   
--   <pre>
--   <a>transformOf</a> :: <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; a -&gt; a
--   <a>transformOf</a> :: <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; a -&gt; a
--   </pre>
transformOf :: ASetter a b a b -> (b -> b) -> a -> b

-- | Transform every element in the tree in a bottom-up manner over a
--   region indicated by a <a>Setter</a>.
--   
--   <pre>
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOn</a> :: <a>Plated</a> a =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t

-- | Transform every element in a region indicated by a <a>Setter</a> by
--   recursively applying another <a>Setter</a> in a bottom-up manner.
--   
--   <pre>
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; a) -&gt; s -&gt; s
--   <a>transformOnOf</a> :: <a>Setter'</a> s a -&gt; <a>Setter'</a> a a    -&gt; (a -&gt; a) -&gt; s -&gt; s
--   </pre>
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t

-- | Transform every element in the tree, in a bottom-up manner,
--   monadically.
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a

-- | Transform every element in a tree using a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; a -&gt; m a
--   </pre>
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b

-- | Transform every element in the tree in a region indicated by a
--   supplied <a>Traversal</a>, in a bottom-up manner, monadically.
--   
--   <pre>
--   <a>transformMOn</a> :: (<a>Monad</a> m, <a>Plated</a> a) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t

-- | Transform every element in a tree that lies in a region indicated by a
--   supplied <a>Traversal</a>, walking with a user supplied
--   <a>Traversal</a> in a bottom-up manner with a monadic effect.
--   
--   <pre>
--   <a>transformMOnOf</a> :: <a>Monad</a> m =&gt; <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; (a -&gt; m a) -&gt; s -&gt; m s
--   </pre>
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively.
--   
--   <pre>
--   propUniverse x = <a>universe</a> x <a>==</a> <a>map</a> <a>pos</a> (<a>contexts</a> x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contexts</a> x]
--   </pre>
--   
--   <pre>
--   <a>contexts</a> ≡ <a>contextsOf</a> <a>plate</a>
--   </pre>
contexts :: Plated a => a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure, recursively, using a user-specified <a>Traversal</a> to
--   walk each layer.
--   
--   <pre>
--   propUniverse l x = <a>universeOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>contextsOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>contextsOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>contextsOf</a> :: <a>Traversal'</a> a a -&gt; a -&gt; [<a>Context</a> a a a]
--   </pre>
contextsOf :: ATraversal' a a -> a -> [Context a a a]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using <a>plate</a>.
--   
--   <pre>
--   <a>contextsOn</a> b ≡ <a>contextsOnOf</a> b <a>plate</a>
--   </pre>
--   
--   <pre>
--   <a>contextsOn</a> :: <a>Plated</a> a =&gt; <a>Traversal'</a> s a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]

-- | Return a list of all of the editable contexts for every location in
--   the structure in an areas indicated by a user supplied
--   <a>Traversal</a>, recursively using another user-supplied
--   <a>Traversal</a> to walk each layer.
--   
--   <pre>
--   <a>contextsOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a -&gt; s -&gt; [<a>Context</a> a a s]
--   </pre>
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]

-- | The one-level version of <a>context</a>. This extracts a list of the
--   immediate children as editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren x = <a>children</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holes</a> l x)
--   propId x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holes</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holes</a> = <a>holesOf</a> <a>plate</a>
--   </pre>
holes :: Plated a => a -> [Pretext (->) a a a]

-- | An alias for <a>holesOf</a>, provided for consistency with the other
--   combinators.
--   
--   <pre>
--   <a>holesOn</a> ≡ <a>holesOf</a>
--   </pre>
--   
--   <pre>
--   <a>holesOn</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOn</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOn</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | Extract one level of <a>holes</a> from a container in a region
--   specified by one <a>Traversal</a>, using another.
--   
--   <pre>
--   <a>holesOnOf</a> b l ≡ <a>holesOf</a> (b <a>.</a> l)
--   </pre>
--   
--   <pre>
--   <a>holesOnOf</a> :: <a>Iso'</a> s a       -&gt; <a>Iso'</a> a a                -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> a a               -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>Traversal'</a> a a          -&gt; s -&gt; [<a>Pretext</a> (-&gt;) a a s]
--   <a>holesOnOf</a> :: <a>Lens'</a> s a      -&gt; <a>IndexedLens'</a> i a a      -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   <a>holesOnOf</a> :: <a>Traversal'</a> s a -&gt; <a>IndexedTraversal'</a> i a a -&gt; s -&gt; [<a>Pretext</a> (<a>Indexed</a> i) a a s]
--   </pre>
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>para</a> ≡ <a>paraOf</a> <a>plate</a>
--   </pre>
para :: Plated a => (a -> [r] -> r) -> a -> r

-- | Perform a fold-like computation on each value, technically a
--   paramorphism.
--   
--   <pre>
--   <a>paraOf</a> :: <a>Fold</a> a a -&gt; (a -&gt; [r] -&gt; r) -&gt; a -&gt; r
--   </pre>
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r

-- | Try to apply a traversal to all transitive descendants of a
--   <a>Plated</a> container, but do not recurse through matching
--   descendants.
--   
--   <pre>
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Fold</a> s a                 -&gt; <a>Fold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedFold</a> s a          -&gt; <a>IndexedFold</a> s a
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>Traversal</a> s s a b        -&gt; <a>Traversal</a> s s a b
--   <a>deep</a> :: <a>Plated</a> s =&gt; <a>IndexedTraversal</a> s s a b -&gt; <a>IndexedTraversal</a> s s a b
--   </pre>
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b

-- | Fold the immediate children of a <a>Plated</a> container.
--   
--   <pre>
--   <a>composOpFold</a> z c f = <a>foldrOf</a> <a>plate</a> (c <a>.</a> f) z
--   </pre>
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b

-- | The original <tt>uniplate</tt> combinator, implemented in terms of
--   <a>Plated</a> as a <a>Lens</a>.
--   
--   <pre>
--   <a>parts</a> ≡ <a>partsOf</a> <a>plate</a>
--   </pre>
--   
--   The resulting <a>Lens</a> is safer to use as it ignores
--   'over-application' and deals gracefully with under-application, but it
--   is only a proper <a>Lens</a> if you don't change the list
--   <a>length</a>!
parts :: Plated a => Lens' a [a]

-- | Implement <a>plate</a> operation for a type using its <a>Generic</a>
--   instance.
--   
--   Note: the behavior may be different than with <a>uniplate</a> in some
--   special cases. <a>gplate</a> doesn't look through other types in a
--   group of mutually recursive types.
--   
--   For example consider mutually recursive even and odd natural numbers:
--   
--   <pre>
--   &gt;&gt;&gt; data Even = Z | E Odd deriving (Show, Generic, Data); data Odd = O Even deriving (Show, Generic, Data)
--   </pre>
--   
--   Then <a>uniplate</a>, which is based on <a>Data</a>, finds all even
--   numbers less or equal than four:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Data.Lens (uniplate)
--   
--   &gt;&gt;&gt; universeOf uniplate (E (O (E (O Z))))
--   [E (O (E (O Z))),E (O Z),Z]
--   </pre>
--   
--   but <a>gplate</a> doesn't see through <tt>Odd</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universeOf gplate (E (O (E (O Z))))
--   [E (O (E (O Z)))]
--   </pre>
--   
--   If using <a>Data</a> is not an option, you can still write the
--   traversal manually. It is sometimes useful to use helper traversals
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let oddeven :: Traversal' Odd Even
--       oddeven f (O n) = O &lt;$&gt; f n
--       evenplate :: Traversal' Even Even
--       evenplate f Z     = pure Z
--       evenplate f (E n) = E &lt;$&gt; oddeven f n
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; universeOf evenplate (E (O (E (O Z))))
--   [E (O (E (O Z))),E (O Z),Z]
--   </pre>
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a

-- | Implement <a>plate</a> operation for a type using its <a>Generic1</a>
--   instance.
gplate1 :: (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | Convert <a>APrism</a> to the pair of functions that characterize it.
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | Clone a <a>Prism</a> so that you can reuse the same monomorphically
--   typed <a>Prism</a> for different purposes.
--   
--   See <a>cloneLens</a> and <a>cloneTraversal</a> for examples of why you
--   might want to do this.
clonePrism :: APrism s t a b -> Prism s t a b

-- | Use a <a>Prism</a> as a kind of first-class pattern.
--   
--   <pre>
--   <a>outside</a> :: <a>Prism</a> s t a b -&gt; <a>Lens</a> (t -&gt; r) (s -&gt; r) (b -&gt; r) (a -&gt; r)
--   </pre>
outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | <tt>lift</tt> a <a>Prism</a> through a <a>Traversable</a> functor,
--   giving a Prism that matches only if all the elements of the container
--   match the <a>Prism</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [Left 1, Right "foo", Left 4, Right "woot"]^..below _Right
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [Right "hail hydra!", Right "foo", Right "blah", Right "woot"]^..below _Right
--   [["hail hydra!","foo","blah","woot"]]
--   </pre>
below :: Traversable f => APrism' s a -> Prism' (f s) (f a)

-- | Check to see if this <a>Prism</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Left (Left 12)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty []
--   False
--   </pre>
--   
--   <pre>
--   <a>isn't</a> = <a>not</a> . <a>is</a>
--   <a>isn't</a> = <tt>hasn't</tt>
--   </pre>
isn't :: APrism s t a b -> s -> Bool

-- | Retrieve the value targeted by a <a>Prism</a> or return the original
--   value while allowing the type to change if it does not match.
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Just 12)
--   Right 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching _Just (Nothing :: Maybe Int) :: Either (Maybe Bool) Int
--   Left Nothing
--   </pre>
matching :: APrism s t a b -> s -> Either t a

-- | Like <a>matching</a>, but also works for combinations of <a>Lens</a>
--   and <a>Prism</a>s, and also <a>Traversal</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; matching' (_2 . _Just) ('x', Just True)
--   Right True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' (_2 . _Just) ('x', Nothing :: Maybe Int) :: Either (Char, Maybe Bool) Int
--   Left ('x',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' traverse "" :: Either [Int] Char
--   Left []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; matching' traverse "xyz" :: Either [Int] Char
--   Right 'x'
--   </pre>
matching' :: LensLike (Either a) s t a b -> s -> Either t a

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Left 2)
--   Left 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Left (+1) (Right 2)
--   Right 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 42 ^._Left :: String
--   ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Left
--   "hello"
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Left</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Left # 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Left
--   Left 5
--   </pre>
_Left :: Prism (Either a c) (Either b c) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Left 2)
--   Left 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _Right (+1) (Right 2)
--   Right 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right "hello" ^._Right
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left "hello" ^._Right :: [Double]
--   []
--   </pre>
--   
--   It also can be turned around to obtain the embedding into the
--   <a>Right</a> half of an <a>Either</a>:
--   
--   <pre>
--   &gt;&gt;&gt; _Right # 5
--   Right 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Right
--   Right 5
--   </pre>
_Right :: Prism (Either c a) (Either c b) a b

-- | This <a>Prism</a> provides a <a>Traversal</a> for tweaking the target
--   of the value of <a>Just</a> in a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over _Just (+1) (Just 2)
--   Just 3
--   </pre>
--   
--   Unlike <a>traverse</a> this is a <a>Prism</a>, and so you can use it
--   to inject as well:
--   
--   <pre>
--   &gt;&gt;&gt; _Just # 5
--   Just 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.re _Just
--   Just 5
--   </pre>
--   
--   Interestingly,
--   
--   <pre>
--   m <tt>^?</tt> <a>_Just</a> ≡ m
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just x ^? _Just
--   Just x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Just
--   Nothing
--   </pre>
_Just :: Prism (Maybe a) (Maybe b) a b

-- | This <a>Prism</a> provides the <a>Traversal</a> of a <a>Nothing</a> in
--   a <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^? _Nothing
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just () ^? _Nothing
--   Nothing
--   </pre>
--   
--   But you can turn it around and use it to construct <a>Nothing</a> as
--   well:
--   
--   <pre>
--   &gt;&gt;&gt; _Nothing # ()
--   Nothing
--   </pre>
_Nothing :: Prism' (Maybe a) ()

-- | <a>Void</a> is a logically uninhabited data type.
--   
--   This is a <a>Prism</a> that will always fail to match.
_Void :: Prism s s a Void

-- | This is an improper prism for text formatting based on <a>Read</a> and
--   <a>Show</a>.
--   
--   This <a>Prism</a> is "improper" in the sense that it normalizes the
--   text formatting, but round tripping is idempotent given sane
--   <a>Read</a>/<a>Show</a> instances.
--   
--   <pre>
--   &gt;&gt;&gt; _Show # 2
--   "2"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "EQ" ^? _Show :: Maybe Ordering
--   Just EQ
--   </pre>
--   
--   <pre>
--   <a>_Show</a> ≡ <a>prism'</a> <a>show</a> <tt>readMaybe</tt>
--   </pre>
_Show :: (Read a, Show a) => Prism' String a

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing, an example where the value is the empty
--   list and the predicate checks that a list is empty (same as
--   <a>_Empty</a> with the <a>AsEmpty</a> list instance):
--   
--   <pre>
--   &gt;&gt;&gt; nearly [] null # ()
--   []
--   
--   &gt;&gt;&gt; [1,2,3,4] ^? nearly [] null
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>nearly</a> [] <a>null</a> :: <a>Prism'</a> [a] ()
--   </pre>
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x ≡ a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()

-- | A <a>Traversal</a> is completely characterized by its behavior on a
--   <a>Bazaar</a>.
--   
--   Cloning a <a>Traversal</a> is one way to make sure you aren't given
--   something weaker, such as a <a>Fold</a> and can be used as a way to
--   pass around traversals that have to be monomorphic in <tt>f</tt>.
--   
--   Note: This only accepts a proper <a>Traversal</a> (or <a>Lens</a>). To
--   clone a <a>Lens</a> as such, use <a>cloneLens</a>.
--   
--   Note: It is usually better to use <a>ReifiedTraversal</a> and
--   <a>runTraversal</a> than to <a>cloneTraversal</a>. The former can
--   execute at full speed, while the latter needs to round trip through
--   the <a>Bazaar</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let foo l a = (view (getting (cloneTraversal l)) a, set (cloneTraversal l) 10 a)
--   
--   &gt;&gt;&gt; foo both ("hello","world")
--   ("helloworld",(10,10))
--   </pre>
--   
--   <pre>
--   <a>cloneTraversal</a> :: <a>LensLike</a> (<a>Bazaar</a> (-&gt;) a b) s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
cloneTraversal :: ATraversal s t a b -> Traversal s t a b

-- | This is the trivial empty <a>Traversal</a>.
--   
--   <pre>
--   <a>ignored</a> :: <a>IndexedTraversal</a> i s s a b
--   </pre>
--   
--   <pre>
--   <a>ignored</a> ≡ <a>const</a> <a>pure</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: Applicative f => pafb -> s -> f s

-- | An analogue of <a>to</a> for <a>review</a>.
--   
--   <pre>
--   <a>unto</a> :: (b -&gt; t) -&gt; <tt>Review'</tt> t b
--   </pre>
--   
--   <pre>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b

-- | Turn a <a>Getter</a> around to get a <a>Review</a>
--   
--   <pre>
--   <a>un</a> = <a>unto</a> . <a>view</a>
--   <a>unto</a> = <a>un</a> . <a>to</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; un (to length) # [1,2,3]
--   3
--   </pre>
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s

-- | Turn a <a>Prism</a> or <a>Iso</a> around to build a <a>Getter</a>.
--   
--   If you have an <a>Iso</a>, <a>from</a> is a more powerful version of
--   this function that will return an <a>Iso</a> instead of a mere
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^.re _Left
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 6 ^.re (_Left.unto succ)
--   Left 7
--   </pre>
--   
--   <pre>
--   <a>review</a>  ≡ <a>view</a>  <a>.</a> <a>re</a>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reuse</a>   ≡ <a>use</a>   <a>.</a> <a>re</a>
--   <a>reuses</a>  ≡ <a>uses</a>  <a>.</a> <a>re</a>
--   </pre>
--   
--   <pre>
--   <a>re</a> :: <a>Prism</a> s t a b -&gt; <a>Getter</a> b t
--   <a>re</a> :: <a>Iso</a> s t a b   -&gt; <a>Getter</a> b t
--   </pre>
re :: AReview t b -> Getter b t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>review</a> ≡ <a>view</a> <a>.</a> <a>re</a>
--   <a>review</a> . <a>unto</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "mustard"
--   Left "mustard"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review (unto succ) 5
--   6
--   </pre>
--   
--   Usually <a>review</a> is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>Iso'</a> s a   -&gt; a -&gt; s
--   <a>review</a> :: <a>Prism'</a> s a -&gt; a -&gt; s
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   <a>review</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   </pre>
review :: MonadReader b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>view</a> a value (or the current environment) through it the other
--   way, applying a function.
--   
--   <pre>
--   <a>reviews</a> ≡ <a>views</a> <a>.</a> <a>re</a>
--   <a>reviews</a> (<a>unto</a> f) g ≡ g <a>.</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews _Left isRight "mustard"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; reviews (unto succ) (*2) 3
--   8
--   </pre>
--   
--   Usually this function is used in the <tt>(-&gt;)</tt> <a>Monad</a>
--   with a <a>Prism</a> or <a>Iso</a>, in which case it may be useful to
--   think of it as having one of these more restricted type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; a -&gt; r
--   <a>reviews</a> :: <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; a -&gt; r
--   </pre>
--   
--   However, when working with a <a>Monad</a> transformer stack, it is
--   sometimes useful to be able to <a>review</a> the current environment,
--   in which case it may be beneficial to think of it as having one of
--   these slightly more liberal type signatures:
--   
--   <pre>
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   <a>reviews</a> :: <a>MonadReader</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> a value (or the current environment) through it the other
--   way.
--   
--   <pre>
--   <a>reuse</a> ≡ <a>use</a> <a>.</a> <a>re</a>
--   <a>reuse</a> <a>.</a> <a>unto</a> ≡ <a>gets</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse _Left) 5
--   Left 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuse (unto succ)) 5
--   6
--   </pre>
--   
--   <pre>
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; m s
--   <a>reuse</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; m s
--   </pre>
reuse :: MonadState b m => AReview t b -> m t

-- | This can be used to turn an <a>Iso</a> or <a>Prism</a> around and
--   <a>use</a> the current state through it the other way, applying a
--   function.
--   
--   <pre>
--   <a>reuses</a> ≡ <a>uses</a> <a>.</a> <a>re</a>
--   <a>reuses</a> (<a>unto</a> f) g ≡ <a>gets</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (reuses _Left isLeft) (5 :: Int)
--   True
--   </pre>
--   
--   <pre>
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Prism'</a> s a -&gt; (s -&gt; r) -&gt; m r
--   <a>reuses</a> :: <a>MonadState</a> a m =&gt; <a>Iso'</a> s a   -&gt; (s -&gt; r) -&gt; m r
--   </pre>
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r

-- | Coerce a polymorphic <a>Prism</a> to a <a>Review</a>.
--   
--   <pre>
--   <a>reviewing</a> :: <a>Iso</a> s t a b -&gt; <a>Review</a> t b
--   <a>reviewing</a> :: <a>Prism</a> s t a b -&gt; <a>Review</a> t b
--   </pre>
reviewing :: (Bifunctor p, Functor f) => Optic Tagged Identity s t a b -> Optic' p f t b

-- | Build a <a>Setter</a>, <a>IndexedSetter</a> or
--   <a>IndexPreservingSetter</a> depending on your choice of
--   <a>Profunctor</a>.
--   
--   <pre>
--   <a>sets</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b

-- | Build an index-preserving <a>Setter</a> from a map-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>setting</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>setting</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>sets</a> is that it takes a "semantic editor
--   combinator" and transforms it into a <a>Setter</a>.
--   
--   <pre>
--   <a>setting</a> :: ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a>Setter</a> s t a b
--   </pre>
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b

-- | Restore <a>ASetter</a> to a full <a>Setter</a>.
cloneSetter :: ASetter s t a b -> Setter s t a b

-- | Build an <a>IndexPreservingSetter</a> from any <a>Setter</a>.
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b

-- | Clone an <a>IndexedSetter</a>.
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b

-- | This <a>Setter</a> can be used to map over all of the values in a
--   <a>Functor</a>.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (+1) [1,2,3]
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped x [a,b,c]
--   [x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[a,b],[c]] &amp; mapped.mapped +~ x
--   [[a + x,b + x],[c + x]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (mapped._2) length [("hello","world"),("leaders","!!!")]
--   [("hello",5),("leaders",3)]
--   </pre>
--   
--   <pre>
--   <a>mapped</a> :: <a>Functor</a> f =&gt; <a>Setter</a> (f a) (f b) a b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>fmap</a></tt>.
mapped :: Functor f => Setter (f a) (f b) a b

-- | This <tt>setter</tt> can be used to modify all of the values in a
--   <a>Monad</a>.
--   
--   You sometimes have to use this rather than <a>mapped</a> -- due to
--   temporary insanity <a>Functor</a> was not a superclass of <a>Monad</a>
--   until GHC 7.10.
--   
--   <pre>
--   <a>liftM</a> ≡ <a>over</a> <a>lifted</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over lifted f [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set lifted b (Just a)
--   Just b
--   </pre>
--   
--   If you want an <a>IndexPreservingSetter</a> use <tt><a>setting</a>
--   <a>liftM</a></tt>.
lifted :: Monad m => Setter (m a) (m b) a b

-- | This <a>Setter</a> can be used to map over all of the inputs to a
--   <a>Contravariant</a>.
--   
--   <pre>
--   <a>contramap</a> ≡ <a>over</a> <a>contramapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getPredicate (over contramapped (*2) (Predicate even)) 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getOp (over contramapped (*5) (Op show)) 100
--   "500"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Prelude.map ($ 1) $ over (mapped . _Unwrapping' Op . contramapped) (*12) [(*2),(+1),(^3)]
--   [24,13,1728]
--   </pre>
contramapped :: Contravariant f => Setter (f b) (f a) a b

-- | This <a>Setter</a> can be used to map over the input of a
--   <a>Profunctor</a>.
--   
--   The most common <a>Profunctor</a> to use this with is
--   <tt>(-&gt;)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) g x
--   g (f x)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ show) length [1,2,3]
--   7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (argument %~ f) h x y
--   h (f x) y
--   </pre>
--   
--   Map over the argument of the result of a function -- i.e., its second
--   argument:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped.argument %~ f) h x y
--   h x (f y)
--   </pre>
--   
--   <pre>
--   <a>argument</a> :: <a>Setter</a> (b -&gt; r) (a -&gt; r) a b
--   </pre>
argument :: Profunctor p => Setter (p b r) (p a r) a b

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an alias for (<a>.=</a>).
--   
--   <pre>
--   &gt;&gt;&gt; execState (do assign _1 c; assign _2 d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   <a>assign</a> :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
assign :: MonadState s m => ASetter s s a b -> b -> m ()

-- | This is an alias for (<a>%=</a>).
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()

-- | Write to a fragment of a larger <tt>Writer</tt> format.
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a>.
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a

-- | This is a generalization of <a>pass</a> that allows you to modify just
--   a portion of the resulting <a>MonadWriter</a> with access to the index
--   of an <a>IndexedSetter</a>.
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>.
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a

-- | This is a generalization of <a>censor</a> that allows you to
--   <a>censor</a> just a portion of the resulting <a>MonadWriter</a>, with
--   access to the index of an <a>IndexedSetter</a>.
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a

-- | Modify the value of the <tt>Reader</tt> environment associated with
--   the target of a <a>Setter</a>, <a>Lens</a>, or <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l <a>id</a> a ≡ a
--   <a>locally</a> l f <a>.</a> locally l g ≡ <a>locally</a> l (f <a>.</a> g)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,1) &amp; locally _1 (+1) (uncurry (+))
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "," &amp; locally ($) ("Hello" &lt;&gt;) (&lt;&gt; " world!")
--   "Hello, world!"
--   </pre>
--   
--   <pre>
--   locally :: MonadReader s m =&gt; <a>Iso</a> s s a b       -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Lens</a> s s a b      -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Traversal</a> s s a b -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   locally :: MonadReader s m =&gt; <a>Setter</a> s s a b    -&gt; (a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r

-- | This is a generalization of <a>locally</a> that allows one to make
--   indexed <a>local</a> changes to a <tt>Reader</tt> environment
--   associated with the target of a <a>Setter</a>, <a>Lens</a>, or
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>locally</a> l f ≡ <a>ilocally</a> l f . const
--   <a>ilocally</a> l f ≡ <a>locally</a> l f . <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   ilocally :: MonadReader s m =&gt; <a>IndexedLens</a> s s a b      -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedTraversal</a> s s a b -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   ilocally :: MonadReader s m =&gt; <a>IndexedSetter</a> s s a b    -&gt; (i -&gt; a -&gt; b) -&gt; m r -&gt; m r
--   </pre>
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter'</a> or <a>Traversal</a> with a constant value, without
--   changing its type.
--   
--   This is a type restricted version of <a>set</a>, which retains the
--   type of the original.
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped x [a,b,c,d]
--   [x,x,x,x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' _2 "hello" (1,"world")
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set' mapped 0 [1,2,3,4]
--   [0,0,0,0]
--   </pre>
--   
--   Note: Attempting to adjust <a>set'</a> a <a>Fold</a> or <a>Getter</a>
--   will fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set'</a> :: <a>Setter'</a> s a    -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Iso'</a> s a       -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Lens'</a> s a      -&gt; a -&gt; s -&gt; s
--   <a>set'</a> :: <a>Traversal'</a> s a -&gt; a -&gt; s -&gt; s
--   </pre>
set' :: ASetter' s a -> a -> s -> s

-- | Map with index. (Deprecated alias for <a>iover</a>).
--   
--   When you do not need access to the index, then <a>mapOf</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>mapOf</a> l ≡ <a>imapOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapOf</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>imapOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>

-- | <i>Deprecated: Use <a>iover</a></i>
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Map with index. This is an alias for <a>imapOf</a>.
--   
--   When you do not need access to the index, then <a>over</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>over</a> l ≡ <a>iover</a> l <a>.</a> <a>const</a>
--   <a>iover</a> l ≡ <a>over</a> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>iover</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   <a>iover</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; t
--   </pre>
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t

-- | Set with index. Equivalent to <a>iover</a> with the current value
--   ignored.
--   
--   When you do not need access to the index, then <a>set</a> is more
--   liberal in what it can accept.
--   
--   <pre>
--   <a>set</a> l ≡ <a>iset</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>iset</a> :: <a>IndexedSetter</a> i s t a b    -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; b) -&gt; s -&gt; t
--   <a>iset</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; b) -&gt; s -&gt; t
--   </pre>
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t

-- | This is an alias for (<a>%@=</a>).
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()

-- | Build an <a>IndexedSetter</a> from an <a>imap</a>-like function.
--   
--   Your supplied function <tt>f</tt> is required to satisfy:
--   
--   <pre>
--   f <a>id</a> ≡ <a>id</a>
--   f g <a>.</a> f h ≡ f (g <a>.</a> h)
--   </pre>
--   
--   Equational reasoning:
--   
--   <pre>
--   <a>isets</a> <a>.</a> <a>iover</a> ≡ <a>id</a>
--   <a>iover</a> <a>.</a> <a>isets</a> ≡ <a>id</a>
--   </pre>
--   
--   Another way to view <a>isets</a> is that it takes a "semantic editor
--   combinator" which has been modified to carry an index and transforms
--   it into a <a>IndexedSetter</a>.
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b

-- | Run an arrow command and use the output to set all the targets of a
--   <a>Lens</a>, <a>Setter</a> or <a>Traversal</a> to the result.
--   
--   <a>assignA</a> can be used very similarly to (<a>&lt;~</a>), except
--   that the type of the object being modified can change; for example:
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
--   
--   <pre>
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Iso</a> s t a b       -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Lens</a> s t a b      -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Traversal</a> s t a b -&gt; p s b -&gt; p s t
--   <a>assignA</a> :: <a>Arrow</a> p =&gt; <a>Setter</a> s t a b    -&gt; p s b -&gt; p s t
--   </pre>
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t

-- | <a>mapOf</a> is a deprecated alias for <a>over</a>.

-- | <i>Deprecated: Use <a>over</a></i>
mapOf :: ASetter s t a b -> (a -> b) -> s -> t

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | Derive lenses and traversals, specifying explicit pairings of
--   <tt>(fieldName, lensName)</tt>.
--   
--   If you map multiple names to the same label, and it is present in the
--   same constructor then this will generate a <a>Traversal</a>.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeLensesFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeLensesFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeLensesFor :: [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Foo = Foo { _fooX, _fooY :: <a>Int</a> }
--   <a>makeClassy</a> ''Foo
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--     fooX :: <a>Lens'</a> t <a>Int</a>
--     fooX = foo . go where go f (Foo x y) = (\x' -&gt; Foo x' y) &lt;$&gt; f x
--     fooY :: <a>Lens'</a> t <a>Int</a>
--     fooY = foo . go where go f (Foo x y) = (\y' -&gt; Foo x y') &lt;$&gt; f y
--   instance HasFoo Foo where
--     foo = id
--   </pre>
--   
--   <pre>
--   <a>makeClassy</a> = <a>makeLensesWith</a> <a>classyRules</a>
--   </pre>
makeClassy :: Name -> DecsQ

-- | Derive lenses and traversals, using a named wrapper class, and
--   specifying explicit pairings of <tt>(fieldName, traversalName)</tt>.
--   
--   Example usage:
--   
--   <pre>
--   <a>makeClassyFor</a> "HasFoo" "foo" [("_foo", "fooLens"), ("bar", "lbar")] ''Foo
--   </pre>
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments. Works the same as <a>makeClassy</a> except that
--   (a) it expects that record field names do not begin with an
--   underscore, (b) all record fields are made into lenses, and (c) the
--   resulting lens is prefixed with an underscore.
makeClassy_ :: Name -> DecsQ

-- | Generate overloaded field accessors.
--   
--   <i>e.g</i>
--   
--   <pre>
--   data Foo a = Foo { _fooX :: <a>Int</a>, _fooY :: a }
--   newtype Bar = Bar { _barX :: <a>Char</a> }
--   makeFields ''Foo
--   makeFields ''Bar
--   </pre>
--   
--   will create
--   
--   <pre>
--   _fooXLens :: Lens' (Foo a) Int
--   _fooYLens :: Lens (Foo a) (Foo b) a b
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   instance HasX (Foo a) Int where
--     x = _fooXLens
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   instance HasY (Foo a) a where
--     y = _fooYLens
--   _barXLens :: Iso' Bar Char
--   instance HasX Bar Char where
--     x = _barXLens
--   </pre>
--   
--   For details, see <a>camelCaseFields</a>.
--   
--   <pre>
--   makeFields = <a>makeLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
makeFields :: Name -> DecsQ

-- | Generate overloaded field accessors based on field names which are
--   only prefixed with an underscore (e.g. <tt>_name</tt>), not
--   additionally with the type name (e.g. <tt>_fooName</tt>).
--   
--   This might be the desired behaviour in case the
--   <tt>DuplicateRecordFields</tt> language extension is used in order to
--   get rid of the necessity to prefix each field name with the type name.
--   
--   As an example:
--   
--   <pre>
--   data Foo a  = Foo { _x :: <a>Int</a>, _y :: a }
--   newtype Bar = Bar { _x :: <a>Char</a> }
--   makeFieldsNoPrefix ''Foo
--   makeFieldsNoPrefix ''Bar
--   </pre>
--   
--   will create classes
--   
--   <pre>
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   </pre>
--   
--   together with instances
--   
--   <pre>
--   instance HasX (Foo a) Int
--   instance HasY (Foo a) a where
--   instance HasX Bar Char where
--   </pre>
--   
--   For details, see <a>classUnderscoreNoPrefixFields</a>.
--   
--   <pre>
--   makeFieldsNoPrefix = <a>makeLensesWith</a> <a>classUnderscoreNoPrefixFields</a>
--   </pre>
makeFieldsNoPrefix :: Name -> DecsQ

-- | Build <tt>Wrapped</tt> instance for a given newtype
makeWrapped :: Name -> DecsQ

-- | Make lenses for all records in the given declaration quote. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   fooX, fooY :: <a>Lens'</a> Foo Int
--   </pre>
declareLenses :: DecsQ -> DecsQ

-- | Similar to <a>makeLensesFor</a>, but takes a declaration quote.
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ

-- | For each record in the declaration quote, make lenses and traversals
--   for it, and create a class when the type has no arguments. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareClassy [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--   instance HasFoo Foo where foo = <a>id</a>
--   fooX, fooY :: HasFoo t =&gt; <a>Lens'</a> t <a>Int</a>
--   </pre>
declareClassy :: DecsQ -> DecsQ

-- | Similar to <a>makeClassyFor</a>, but takes a declaration quote.
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ

-- | <pre>
--   declareFields = <a>declareLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
declareFields :: DecsQ -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of each data type.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declarePrisms [d|
--     data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }
--   _Lit :: <tt>Prism'</tt> Exp Int
--   _Var :: <tt>Prism'</tt> Exp String
--   _Lambda :: <tt>Prism'</tt> Exp (String, Exp)
--   </pre>
declarePrisms :: DecsQ -> DecsQ

-- | Build <a>Wrapped</a> instance for each newtype.
declareWrapped :: DecsQ -> DecsQ

-- | Build lenses with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ

-- | Declare lenses for each records in the given declarations, using the
--   specified <a>LensRules</a>. Any record syntax in the input will be
--   stripped off.
declareLensesWith :: LensRules -> DecsQ -> DecsQ

-- | Rules for making fairly simple partial lenses, ignoring the special
--   cases for isomorphisms and traversals, and not making any classes. It
--   uses <a>underscoreNoPrefixNamer</a>.
lensRules :: LensRules

-- | Construct a <a>LensRules</a> value for generating top-level
--   definitions using the given map from field names to definition names.
lensRulesFor :: [(String, String)] -> LensRules

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a>.
classyRules :: LensRules

-- | A <a>LensRules</a> used by <a>makeClassy_</a>.
classyRules_ :: LensRules
defaultFieldRules :: LensRules

-- | Field rules for fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   <b>Note</b>: The <tt>prefix</tt> must be the same as the typename
--   (with the first letter lowercased). This is a change from lens
--   versions before lens 4.5. If you want the old behaviour, use
--   <a>makeLensesWith</a> <a>abbreviatedFields</a>
camelCaseFields :: LensRules

-- | Field rules for fields in the form <tt> _fieldname </tt> (the leading
--   underscore is mandatory).
--   
--   <b>Note</b>: The primary difference to <a>camelCaseFields</a> is that
--   for <tt>classUnderscoreNoPrefixFields</tt> the field names are not
--   expected to be prefixed with the type name. This might be the desired
--   behaviour when the <tt>DuplicateRecordFields</tt> extension is
--   enabled.
classUnderscoreNoPrefixFields :: LensRules

-- | Field rules for fields in the form <tt> _prefix_fieldname </tt>
underscoreFields :: LensRules

-- | Field rules fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   Note that <tt>prefix</tt> may be any string of characters that are not
--   uppercase letters. (In particular, it may be arbitrary string of
--   lowercase letters and numbers) This is the behavior that
--   <a>defaultFieldRules</a> had in lens 4.4 and earlier.
abbreviatedFields :: LensRules

-- | <a>Lens'</a> to access the convention for naming fields in our
--   <a>LensRules</a>.
lensField :: Lens' LensRules FieldNamer

-- | <a>Lens'</a> to access the option for naming "classy" lenses.
lensClass :: Lens' LensRules ClassyNamer

-- | Generate "simple" optics even when type-changing optics are possible.
--   (e.g. <a>Lens'</a> instead of <a>Lens</a>)
simpleLenses :: Lens' LensRules Bool

-- | Create the class if the constructor is <a>Simple</a> and the
--   <a>lensClass</a> rule matches.
createClass :: Lens' LensRules Bool

-- | Indicate whether or not to supply the signatures for the generated
--   lenses.
--   
--   Disabling this can be useful if you want to provide a more restricted
--   type signature or if you want to supply hand-written haddocks.
generateSignatures :: Lens' LensRules Bool

-- | Generate "updateable" optics when <a>True</a>. When <a>False</a>,
--   <a>Fold</a>s will be generated instead of <a>Traversal</a>s and
--   <a>Getter</a>s will be generated instead of <a>Lens</a>es. This mode
--   is intended to be used for types with invariants which must be
--   maintained by "smart" constructors.
generateUpdateableOptics :: Lens' LensRules Bool

-- | Generate optics using lazy pattern matches. This can allow fields of
--   an undefined value to be initialized with lenses:
--   
--   <pre>
--   data Foo = Foo {_x :: Int, _y :: Bool}
--     deriving Show
--   
--   <a>makeLensesWith</a> (<a>lensRules</a> &amp; <a>generateLazyPatterns</a> .~ True) ''Foo
--   </pre>
--   
--   <pre>
--   &gt; undefined &amp; x .~ 8 &amp; y .~ True
--   Foo {_x = 8, _y = True}
--   </pre>
--   
--   The downside of this flag is that it can lead to space-leaks and
--   code-size/compile-time increases when generated for large records. By
--   default this flag is turned off, and strict optics are generated.
--   
--   When using lazy optics the strict optic can be recovered by composing
--   with <a>$!</a>:
--   
--   <pre>
--   strictOptic = ($!) . lazyOptic
--   </pre>
generateLazyPatterns :: Lens' LensRules Bool
generateRecordSyntax :: Lens' LensRules Bool

-- | A <a>FieldNamer</a> that strips the _ off of the field name,
--   lowercases the name, and skips the field if it doesn't start with an
--   '_'.
underscoreNoPrefixNamer :: FieldNamer

-- | Create a <a>FieldNamer</a> from explicit pairings of <tt>(fieldName,
--   lensName)</tt>.
lookingupNamer :: [(String, String)] -> FieldNamer

-- | Create a <a>FieldNamer</a> from a mapping function. If the function
--   returns <tt>[]</tt>, it creates no lens for the field.
mappingNamer :: (String -> [String]) -> FieldNamer

-- | A <a>FieldNamer</a> for <a>camelCaseFields</a>.
camelCaseNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>classUnderscoreNoPrefixFields</a>.
classUnderscoreNoPrefixNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>underscoreFields</a>.
underscoreNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>abbreviatedFields</a>.
abbreviatedNamer :: FieldNamer

-- | Build a <a>Traversal</a> by providing a function which specifies the
--   elements you wish to focus.
--   
--   The caller provides a function of type:
--   
--   <pre>
--   Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
--   
--   Which is a higher order function which accepts a "focusing function"
--   and applies it to all desired focuses within <tt>s</tt>, then
--   constructs a <tt>t</tt> using the Applicative instance of <tt>f</tt>.
--   
--   Only elements which are "focused" using the focusing function will be
--   targeted by the resulting traversal.
--   
--   For example, we can explicitly write a traversal which targets the
--   first and third elements of a tuple like this:
--   
--   <pre>
--   firstAndThird :: Traversal (a, x, a) (b, x, b) a b
--   firstAndThird = traversal go
--     where
--       go :: Applicative f =&gt; (a -&gt; f b) -&gt; (a, x, a) -&gt; f (b, x, b)
--       go focus (a, x, a') = liftA3 (,,) (focus a) (pure x) (focus a')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,"two",3) &amp; firstAndThird *~ 10
--   (10,"two",30)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over firstAndThird length ("one",2,"three")
--   (3,2,5)
--   </pre>
--   
--   We can re-use existing <a>Traversal</a>s when writing new ones by
--   passing our focusing function along to them. This example re-uses
--   <a>traverse</a> to focus all elements in a list which is embedded in a
--   tuple. This traversal could also be written simply as <tt>_2 .
--   traverse</tt>.
--   
--   <pre>
--   selectNested :: Traversal (x, [a]) (x, [b]) a b
--   selectNested = traversal go
--     where
--       go :: Applicative f =&gt; (a -&gt; f b) -&gt; (x, [a]) -&gt; f (x, [b])
--       go focus (x, as) = liftA2 (,) (pure x) (traverse focus as)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; selectNested .~ "hello" $ (1,[2,3,4,5])
--   (1,["hello","hello","hello","hello"])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,[2,3,4,5]) &amp; selectNested *~ 3
--   (1,[6,9,12,15])
--   </pre>
--   
--   Note that the <a>traversal</a> function actually just returns the same
--   function you pass to it. The function it accepts is in fact a valid
--   traversal all on its own! The use of <a>traversal</a> does nothing
--   except verify that the function it is passed matches the signature of
--   a valid traversal. One could remove the <tt>traversal</tt> combinator
--   from either of the last two examples and use the definition of
--   <tt>go</tt> directly with no change in behaviour.
--   
--   This function exists for consistency with the <a>lens</a>,
--   <tt>prism</tt> and <tt>iso</tt> constructors as well as to serve as a
--   touchpoint for beginners who wish to construct their own traversals
--   but are uncertain how to do so.
traversal :: ((a -> f b) -> s -> f t) -> LensLike f s t a b

-- | Map each element of a structure targeted by a <a>Lens</a> or
--   <a>Traversal</a>, evaluate these actions from left to right, and
--   collect the results.
--   
--   This function is only provided for consistency, <a>id</a> is strictly
--   more general.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf each print (1,2,3)
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> ≡ <a>id</a>
--   <a>itraverseOf</a> l ≡ <a>traverseOf</a> l <a>.</a> <a>Indexed</a>
--   <a>itraverseOf</a> <tt>itraversed</tt> ≡ <tt>itraverse</tt>
--   </pre>
--   
--   This yields the obvious law:
--   
--   <pre>
--   <a>traverse</a> ≡ <a>traverseOf</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Iso</a> s t a b        -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Functor</a> f     =&gt; <a>Lens</a> s t a b       -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Apply</a> f       =&gt; <a>Traversal1</a> s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   <a>traverseOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b  -&gt; (a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t

-- | A version of <a>traverseOf</a> with the arguments flipped, such that:
--   
--   <pre>
--   &gt;&gt;&gt; forOf each (1,2,3) print
--   1
--   2
--   3
--   ((),(),())
--   </pre>
--   
--   This function is only provided for consistency, <a>flip</a> is
--   strictly more general.
--   
--   <pre>
--   <a>forOf</a> ≡ <a>flip</a>
--   <a>forOf</a> ≡ <a>flip</a> . <a>traverseOf</a>
--   </pre>
--   
--   <pre>
--   <tt>for</tt> ≡ <a>forOf</a> <a>traverse</a>
--   <a>ifor</a> l s ≡ <tt>for</tt> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   <a>forOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t
--   </pre>
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceAOf both ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequenceA</a> ≡ <a>sequenceAOf</a> <a>traverse</a> ≡ <a>traverse</a> <a>id</a>
--   <a>sequenceAOf</a> l ≡ <a>traverseOf</a> l <a>id</a> ≡ l <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Iso</a> s t (f b) b       -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Functor</a> f =&gt; <a>Lens</a> s t (f b) b      -&gt; s -&gt; f t
--   <a>sequenceAOf</a> :: <a>Applicative</a> f =&gt; <a>Traversal</a> s t (f b) b -&gt; s -&gt; f t
--   </pre>
sequenceAOf :: LensLike f s t (f b) b -> s -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; mapMOf both (\x -&gt; [x, x + 1]) (1,3)
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>mapM</a> ≡ <a>mapMOf</a> <a>traverse</a>
--   <a>imapMOf</a> l ≡ <tt>forM</tt> l <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   <a>mapMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; (a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t

-- | <a>forMOf</a> is a flipped version of <a>mapMOf</a>, consistent with
--   the definition of <tt>forM</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; forMOf both (1,3) $ \x -&gt; [x, x + 1]
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <tt>forM</tt> ≡ <a>forMOf</a> <a>traverse</a>
--   <a>forMOf</a> l ≡ <a>flip</a> (<a>mapMOf</a> l)
--   <a>iforMOf</a> l s ≡ <tt>forM</tt> l s <a>.</a> <a>Indexed</a>
--   </pre>
--   
--   <pre>
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t a b       -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t a b      -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   <a>forMOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t a b -&gt; s -&gt; (a -&gt; m b) -&gt; m t
--   </pre>
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t

-- | Sequence the (monadic) effects targeted by a <a>Lens</a> in a
--   container from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4],[5,6])
--   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a> ≡ <a>sequenceOf</a> <a>traverse</a>
--   <a>sequenceOf</a> l ≡ <a>mapMOf</a> l <a>id</a>
--   <a>sequenceOf</a> l ≡ <a>unwrapMonad</a> <a>.</a> l <a>WrapMonad</a>
--   </pre>
--   
--   <pre>
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Iso</a> s t (m b) b       -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Lens</a> s t (m b) b      -&gt; s -&gt; m t
--   <a>sequenceOf</a> :: <a>Monad</a> m =&gt; <a>Traversal</a> s t (m b) b -&gt; s -&gt; m t
--   </pre>
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traverse [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a> ≡ <a>transposeOf</a> <a>traverse</a>
--   </pre>
--   
--   Since every <a>Lens</a> is a <a>Traversal</a>, we can use this as a
--   form of monadic strength as well:
--   
--   <pre>
--   <a>transposeOf</a> <a>_2</a> :: (b, [a]) -&gt; [(b, a)]
--   </pre>
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <tt>mapAccumL</tt> ≡ <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumLOf</a> :: <a>LensLike</a> (<a>State</a> acc) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumLOf</a> l f acc0 s = <a>swap</a> (<a>runState</a> (l (a -&gt; <a>state</a> (acc -&gt; <a>swap</a> (f acc a))) s) acc0)
--   </pre>
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <tt>mapAccumR</tt> ≡ <a>mapAccumROf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>Iso</a> s t a b       -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Lens</a> s t a b      -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>mapAccumROf</a> :: <a>Traversal</a> s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
--   
--   <pre>
--   <a>mapAccumROf</a> :: <a>LensLike</a> (<a>Backwards</a> (<a>State</a> acc)) s t a b -&gt; (acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanr1</a> ≡ <a>scanr1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanr1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanr1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a> or <a>Lens</a>.
--   
--   <pre>
--   <a>scanl1</a> ≡ <a>scanl1Of</a> <a>traverse</a>
--   </pre>
--   
--   <pre>
--   <a>scanl1Of</a> :: <a>Iso</a> s t a a       -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Lens</a> s t a a      -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   <a>scanl1Of</a> :: <a>Traversal</a> s t a a -&gt; (a -&gt; a -&gt; a) -&gt; s -&gt; t
--   </pre>
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t

-- | Try to map a function over this <a>Traversal</a>, failing if the
--   <a>Traversal</a> has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2] :: Maybe [Int]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4) :: Maybe (Either Int Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4) :: Maybe (Either Int Int)
--   Just (Right 8)
--   </pre>
--   
--   <pre>
--   <a>failover</a> :: Alternative m =&gt; Traversal s t a b -&gt; (a -&gt; b) -&gt; s -&gt; m t
--   </pre>
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t

-- | Try to map a function which uses the index over this
--   <a>IndexedTraversal</a>, failing if the <a>IndexedTraversal</a> has no
--   targets.
--   
--   <pre>
--   <a>ifailover</a> :: Alternative m =&gt; IndexedTraversal i s t a b -&gt; (i -&gt; a -&gt; b) -&gt; s -&gt; m t
--   </pre>
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t

-- | Clone a <a>Traversal</a> yielding an <a>IndexPreservingTraversal</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b

-- | Clone an <a>IndexedTraversal</a> yielding an <a>IndexedTraversal</a>
--   with the same index.
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b

-- | A <a>Traversal1</a> is completely characterized by its behavior on a
--   <a>Bazaar1</a>.
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b

-- | Clone a <a>Traversal1</a> yielding an <a>IndexPreservingTraversal1</a>
--   that passes through whatever index it is composed with.
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b

-- | Clone an <a>IndexedTraversal1</a> yielding an <a>IndexedTraversal1</a>
--   with the same index.
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a> that
--   resembles an early version of the <a>uniplate</a> (or <a>biplate</a>)
--   type.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y,z]
--   (x,y,z)
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [w,x,y,z]
--   (w,x,y)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; partsOf each .~ [x,y]
--   (x,y,c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('b', 'a', 'd', 'c') &amp; partsOf each %~ sort
--   ('a','b','c','d')
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>.
--   
--   <pre>
--   <a>partsOf</a> :: <a>Iso'</a> s a       -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Lens'</a> s a      -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Traversal'</a> s a -&gt; <a>Lens'</a> s [a]
--   <a>partsOf</a> :: <a>Fold</a> s a       -&gt; <a>Getter</a> s [a]
--   <a>partsOf</a> :: <a>Getter</a> s a     -&gt; <a>Getter</a> s [a]
--   </pre>
partsOf :: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]

-- | A type-restricted version of <a>partsOf</a> that can only be used with
--   a <a>Traversal</a>.
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]

-- | <a>unsafePartsOf</a> turns a <a>Traversal</a> into a <a>uniplate</a>
--   (or <a>biplate</a>) family.
--   
--   If you do not need the types of <tt>s</tt> and <tt>t</tt> to be
--   different, it is recommended that you use <a>partsOf</a>.
--   
--   It is generally safer to traverse with the <a>Bazaar</a> rather than
--   use this combinator. However, it is sometimes convenient.
--   
--   This is unsafe because if you don't supply at least as many
--   <tt>b</tt>'s as you were given <tt>a</tt>'s, then the reconstruction
--   of <tt>t</tt> <i>will</i> result in an error!
--   
--   When applied to a <a>Fold</a> the result is merely a <a>Getter</a>
--   (and becomes safe).
--   
--   <pre>
--   <a>unsafePartsOf</a> :: <a>Iso</a> s t a b       -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Lens</a> s t a b      -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Traversal</a> s t a b -&gt; <a>Lens</a> s t [a] [b]
--   <a>unsafePartsOf</a> :: <a>Fold</a> s a          -&gt; <a>Getter</a> s [a]
--   <a>unsafePartsOf</a> :: <a>Getter</a> s a        -&gt; <a>Getter</a> s [a]
--   </pre>
unsafePartsOf :: Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]

-- | The one-level version of <a>contextsOf</a>. This extracts a list of
--   the immediate children according to a given <a>Traversal</a> as
--   editable contexts.
--   
--   Given a context you can use <a>pos</a> to see the values, <a>peek</a>
--   at what the structure would be like with an edited result, or simply
--   <a>extract</a> the original structure.
--   
--   <pre>
--   propChildren l x = <a>toListOf</a> l x <a>==</a> <a>map</a> <a>pos</a> (<a>holesOf</a> l x)
--   propId l x = <a>all</a> (<a>==</a> x) [<a>extract</a> w | w &lt;- <a>holesOf</a> l x]
--   </pre>
--   
--   <pre>
--   <a>holesOf</a> :: <a>Iso'</a> s a                -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Lens'</a> s a               -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>Traversal'</a> s a          -&gt; s -&gt; [<a>Pretext'</a> (-&gt;) a s]
--   <a>holesOf</a> :: <a>IndexedLens'</a> i s a      -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   <a>holesOf</a> :: <a>IndexedTraversal'</a> i s a -&gt; s -&gt; [<a>Pretext'</a> (<a>Indexed</a> i) a s]
--   </pre>
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]

-- | The non-empty version of <a>holesOf</a>. This extract a non-empty list
--   of immediate children according to a given <a>Traversal1</a> as
--   editable contexts.
--   
--   <pre>
--   &gt;&gt;&gt; let head1 f s = runPretext (NonEmpty.head $ holes1Of traversed1 s) f
--   
--   &gt;&gt;&gt; ('a' :| "bc") ^. head1
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a' :| "bc") &amp; head1 %~ toUpper
--   'A' :| "bc"
--   </pre>
--   
--   <pre>
--   <a>holes1Of</a> :: <a>Iso'</a> s a                 -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Lens'</a> s a                -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>Traversal1'</a> s a          -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (-&gt;) a s)
--   <a>holes1Of</a> :: <a>IndexedLens'</a> i s a       -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   <a>holes1Of</a> :: <a>IndexedTraversal1'</a> i s a -&gt; s -&gt; <a>NonEmpty</a> (<a>Pretext'</a> (<a>Indexed</a> i) a s)
--   </pre>
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)

-- | This converts a <a>Traversal</a> that you "know" will target one or
--   more elements to a <a>Lens</a>. It can also be used to transform a
--   non-empty <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   supplied <a>Traversal</a> returns no results.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^. singular _head
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "singular: empty traversal") &lt;- try (evaluate ([] ^. singular _head)) :: IO (Either ErrorCall ())
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Left 4 ^. singular _Left
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^. singular (ix 7)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; singular traverse .~ 0
--   []
--   </pre>
--   
--   <pre>
--   <a>singular</a> :: <a>Traversal</a> s t a a          -&gt; <a>Lens</a> s t a a
--   <a>singular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>singular</a> :: <a>IndexedTraversal</a> i s t a a -&gt; <a>IndexedLens</a> i s t a a
--   <a>singular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a

-- | This converts a <a>Traversal</a> that you "know" will target only one
--   element to a <a>Lens</a>. It can also be used to transform a
--   <a>Fold</a> into a <a>Getter</a>.
--   
--   The resulting <a>Lens</a> or <a>Getter</a> will be partial if the
--   <a>Traversal</a> targets nothing or more than one element.
--   
--   <pre>
--   &gt;&gt;&gt; Left (ErrorCall "unsafeSingular: empty traversal") &lt;- try (evaluate ([] &amp; unsafeSingular traverse .~ 0)) :: IO (Either ErrorCall [Integer])
--   </pre>
--   
--   <pre>
--   <a>unsafeSingular</a> :: <a>Traversal</a> s t a b          -&gt; <a>Lens</a> s t a b
--   <a>unsafeSingular</a> :: <a>Fold</a> s a                   -&gt; <a>Getter</a> s a
--   <a>unsafeSingular</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedLens</a> i s t a b
--   <a>unsafeSingular</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedGetter</a> i s a
--   </pre>
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   Usually that type will be a pair. Use <a>each</a> to traverse the
--   elements of arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both *~ 10
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.both
--   "helloworld"
--   </pre>
--   
--   <pre>
--   <a>both</a> :: <a>Traversal</a> (a, a)       (b, b)       a b
--   <a>both</a> :: <a>Traversal</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both :: Bitraversable r => Traversal (r a a) (r b b) a b

-- | Traverse both parts of a <a>Bitraversable1</a> container with matching
--   types.
--   
--   Usually that type will be a pair.
--   
--   <pre>
--   <a>both1</a> :: <a>Traversal1</a> (a, a)       (b, b)       a b
--   <a>both1</a> :: <a>Traversal1</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both1 :: Bitraversable1 r => Traversal1 (r a a) (r b b) a b

-- | Apply a different <a>Traversal</a> or <a>Fold</a> to each side of a
--   <a>Bitraversable</a> container.
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (r s s') (r t t') a b
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (r s s') (r t t') a b
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>Traversal</a> s t a b                -&gt; <a>Traversal</a> s' t' a b                -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Lens</a> s t a b                     -&gt; <a>Lens</a> s' t' a b                     -&gt; <a>Traversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>Fold</a> s a                         -&gt; <a>Fold</a> s' a                          -&gt; <a>Fold</a> (s,s') a
--   <a>beside</a> :: <a>Getter</a> s a                       -&gt; <a>Getter</a> s' a                        -&gt; <a>Fold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexedTraversal</a> i s t a b       -&gt; <a>IndexedTraversal</a> i s' t' a b       -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedLens</a> i s t a b            -&gt; <a>IndexedLens</a> i s' t' a b            -&gt; <a>IndexedTraversal</a> i (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s' a                 -&gt; <a>IndexedFold</a> i (s,s') a
--   <a>beside</a> :: <a>IndexedGetter</a> i s a              -&gt; <a>IndexedGetter</a> i s' a               -&gt; <a>IndexedFold</a> i (s,s') a
--   </pre>
--   
--   <pre>
--   <a>beside</a> :: <a>IndexPreservingTraversal</a> s t a b -&gt; <a>IndexPreservingTraversal</a> s' t' a b -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingLens</a> s t a b      -&gt; <a>IndexPreservingLens</a> s' t' a b      -&gt; <a>IndexPreservingTraversal</a> (s,s') (t,t') a b
--   <a>beside</a> :: <a>IndexPreservingFold</a> s a          -&gt; <a>IndexPreservingFold</a> s' a           -&gt; <a>IndexPreservingFold</a> (s,s') a
--   <a>beside</a> :: <a>IndexPreservingGetter</a> s a        -&gt; <a>IndexPreservingGetter</a> s' a         -&gt; <a>IndexPreservingFold</a> (s,s') a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello",["world","!!!"])^..beside id traverse
--   ["hello","world","!!!"]
--   </pre>
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b

-- | Visit the first <i>n</i> targets of a <a>Traversal</a>, <a>Fold</a>,
--   <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("hello","world"),("!!!","!!!")]^.. taking 2 (traverse.both)
--   ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ [1..] ^.. taking 3 traverse
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (taking 5 traverse) succ "hello world"
--   "ifmmp world"
--   </pre>
--   
--   <pre>
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>taking</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a

-- | Visit all but the first <i>n</i> targets of a <a>Traversal</a>,
--   <a>Fold</a>, <a>Getter</a> or <a>Lens</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world") ^? dropping 1 both
--   Just "world"
--   </pre>
--   
--   Dropping works on infinite traversals as well:
--   
--   <pre>
--   &gt;&gt;&gt; [1..] ^? dropping 1 folded
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Traversal'</a> s a                   -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Lens'</a> s a                        -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Iso'</a> s a                         -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Prism'</a> s a                       -&gt; <a>Traversal'</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Getter</a> s a                       -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>Fold</a> s a                         -&gt; <a>Fold</a> s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedTraversal'</a> i s a          -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedLens'</a> i s a               -&gt; <a>IndexedTraversal'</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedGetter</a> i s a              -&gt; <a>IndexedFold</a> i s a
--   <a>dropping</a> :: <a>Int</a> -&gt; <a>IndexedFold</a> i s a                -&gt; <a>IndexedFold</a> i s a
--   </pre>
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a

-- | Try the first <a>Traversal</a> (or <a>Fold</a>), falling back on the
--   second <a>Traversal</a> (or <a>Fold</a>) if it returns no entries.
--   
--   This is only a valid <a>Traversal</a> if the second <a>Traversal</a>
--   is disjoint from the result of the first or returns exactly the same
--   results. These conditions are trivially met when given a <a>Lens</a>,
--   <a>Iso</a>, <a>Getter</a>, <a>Prism</a> or "affine" Traversal -- one
--   that has 0 or 1 target.
--   
--   Mutatis mutandis for <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 1) (ix 2)
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1,2,3] ^? failing (ix 42) (ix 2)
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>failing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Prism</a> s t a b     -&gt; <a>Prism</a> s t a b     -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Fold</a> s a          -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>Lens</a> s t a b      -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Iso</a> s t a b       -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Equality</a> s t a b  -&gt; <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   <a>failing</a> :: <a>Getter</a> s a        -&gt; <a>Fold</a> s a          -&gt; <a>Fold</a> s a
--   </pre>
--   
--   If both of the inputs are indexed, the result is also indexed, so you
--   can apply this to a pair of indexed traversals or indexed folds,
--   obtaining an indexed traversal or indexed fold.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   </pre>
--   
--   These cases are also supported, trivially, but are boring, because the
--   left hand side always succeeds.
--   
--   <pre>
--   <a>failing</a> :: <a>IndexedLens</a> i s t a b      -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   <a>failing</a> :: <a>IndexedGetter</a> i s a        -&gt; <a>IndexedGetter</a> i s a        -&gt; <a>IndexedFold</a> i s a
--   </pre>
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
infixl 5 `failing`

-- | Try the second traversal. If it returns no entries, try again with all
--   entries from the first traversal, recursively.
--   
--   <pre>
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>Fold</a> s a                   -&gt; <a>Fold</a> s a
--   <a>deepOf</a> :: <a>Traversal'</a> s s    -&gt; <a>Traversal'</a> s a             -&gt; <a>Traversal'</a> s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>Traversal</a> s t a b          -&gt; <a>Traversal</a> s t a b
--   <a>deepOf</a> :: <a>Fold</a> s s          -&gt; <a>IndexedFold</a> i s a          -&gt; <a>IndexedFold</a> i s a
--   <a>deepOf</a> :: <a>Traversal</a> s t s t -&gt; <a>IndexedTraversal</a> i s t a b -&gt; <a>IndexedTraversal</a> i s t a b
--   </pre>
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b

-- | Traverse any <a>Traversable1</a> container. This is an
--   <a>IndexedTraversal1</a> that is indexed by ordinal position.
traversed1 :: Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b

-- | Traverse any <a>Traversable</a> container. This is an
--   <a>IndexedTraversal</a> that is indexed by ordinal position.
traversed64 :: Traversable f => IndexedTraversal Int64 (f a) (f b) a b

-- | Traverse the <i>nth</i> <a>elementOf</a> a <a>Traversal</a>,
--   <a>Lens</a> or <a>Iso</a> if it exists.
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] &amp; elementOf (traverse.traverse) 1 .~ 5
--   [[1],[5,4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [[1],[3,4]] ^? elementOf (folded.folded) 1
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ ['a'..] ^?! elementOf folded 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; timingOut $ take 10 $ elementOf traverse 3 .~ 16 $ [0..]
--   [0,1,2,16,4,5,6,7,8,9]
--   </pre>
--   
--   <pre>
--   <a>elementOf</a> :: <a>Traversal'</a> s a -&gt; <a>Int</a> -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementOf</a> :: <a>Fold</a> s a       -&gt; <a>Int</a> -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a> ≡ <a>elementOf</a> <a>traverse</a>
--   </pre>
element :: Traversable t => Int -> IndexedTraversal' Int (t a) a

-- | Traverse (or fold) selected elements of a <a>Traversal</a> (or
--   <a>Fold</a>) where their ordinal positions match a predicate.
--   
--   <pre>
--   <a>elementsOf</a> :: <a>Traversal'</a> s a -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedTraversal'</a> <a>Int</a> s a
--   <a>elementsOf</a> :: <a>Fold</a> s a       -&gt; (<a>Int</a> -&gt; <a>Bool</a>) -&gt; <a>IndexedFold</a> <a>Int</a> s a
--   </pre>
elementsOf :: Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its index.
ipartsOf :: forall i p f s t a. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]

-- | A type-restricted version of <a>ipartsOf</a> that can only be used
--   with an <a>IndexedTraversal</a>.
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]

-- | An indexed version of <a>unsafePartsOf</a> that receives the entire
--   list of indices as its index.
iunsafePartsOf :: forall i p f s t a b. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]

-- | Traversal with an index.
--   
--   <i>NB:</i> When you don't need access to the index then you can just
--   apply your <a>IndexedTraversal</a> directly as a function!
--   
--   <pre>
--   <a>itraverseOf</a> ≡ <a>withIndex</a>
--   <a>traverseOf</a> l = <a>itraverseOf</a> l <a>.</a> <a>const</a> = <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>itraverseOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   <a>itraverseOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; f b) -&gt; s -&gt; f t
--   </pre>
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t

-- | Traverse with an index (and the arguments flipped).
--   
--   <pre>
--   <a>forOf</a> l a ≡ <a>iforOf</a> l a <a>.</a> <a>const</a>
--   <a>iforOf</a> ≡ <a>flip</a> <a>.</a> <a>itraverseOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforOf</a> :: <a>Functor</a> f     =&gt; <a>IndexedLens</a> i s t a b       -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Applicative</a> f =&gt; <a>IndexedTraversal</a> i s t a b  -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   <a>iforOf</a> :: <a>Apply</a> f       =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; f b) -&gt; f t
--   </pre>
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position.
--   
--   When you don't need access to the index <a>mapMOf</a> is more liberal
--   in what it can accept.
--   
--   <pre>
--   <a>mapMOf</a> l ≡ <a>imapMOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a>       i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a>  i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   <a>imapMOf</a> :: <tt>Bind</tt>  m =&gt; <a>IndexedTraversal1</a> i s t a b -&gt; (i -&gt; a -&gt; m b) -&gt; s -&gt; m t
--   </pre>
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t

-- | Map each element of a structure targeted by a <a>Lens</a> to a monadic
--   action, evaluate these actions from left to right, and collect the
--   results, with access its position (and the arguments flipped).
--   
--   <pre>
--   <a>forMOf</a> l a ≡ <a>iforMOf</a> l a <a>.</a> <a>const</a>
--   <a>iforMOf</a> ≡ <a>flip</a> <a>.</a> <a>imapMOf</a>
--   </pre>
--   
--   <pre>
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedLens</a> i s t a b      -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   <a>iforMOf</a> :: <a>Monad</a> m =&gt; <a>IndexedTraversal</a> i s t a b -&gt; s -&gt; (i -&gt; a -&gt; m b) -&gt; m t
--   </pre>
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> l ≡ <a>imapAccumROf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumROf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumROf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IndexedTraversal</a>
--   with access to the index.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> l ≡ <a>imapAccumLOf</a> l <a>.</a> <a>const</a>
--   </pre>
--   
--   <pre>
--   <a>imapAccumLOf</a> :: <a>IndexedLens</a> i s t a b      -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   <a>imapAccumLOf</a> :: <a>IndexedTraversal</a> i s t a b -&gt; (i -&gt; acc -&gt; a -&gt; (acc, b)) -&gt; acc -&gt; s -&gt; (acc, t)
--   </pre>
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)

-- | Traverse a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>traverseByOf</a> <a>traverse</a> ≡ <a>traverseBy</a>
--   </pre>
traverseByOf :: Traversal s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t

-- | Sequence a container using a specified <a>Applicative</a>.
--   
--   This is like <a>traverseBy</a> where the <a>Traversable</a> instance
--   can be specified by any <a>Traversal</a>
--   
--   <pre>
--   <a>sequenceByOf</a> <a>traverse</a> ≡ <a>sequenceBy</a>
--   </pre>
sequenceByOf :: Traversal s t (f b) b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> s -> f t

-- | This <a>Traversal</a> allows you to <a>traverse</a> the individual
--   stores in a <a>Bazaar</a>.
loci :: Traversal (Bazaar (->) a c s) (Bazaar (->) b c s) a b

-- | This <a>IndexedTraversal</a> allows you to <a>traverse</a> the
--   individual stores in a <a>Bazaar</a> with access to their indices.
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b

-- | <a>Fuse</a> a <a>Traversal</a> by reassociating all of the
--   <tt>(<a>&lt;*&gt;</a>)</tt> operations to the left and fusing all of
--   the <a>fmap</a> calls into one. This is particularly useful when
--   constructing a <a>Traversal</a> using operations from
--   <a>GHC.Generics</a>.
--   
--   Given a pair of <a>Traversal</a>s <tt>foo</tt> and <tt>bar</tt>,
--   
--   <pre>
--   <a>confusing</a> (foo.bar) = foo.bar
--   </pre>
--   
--   However, <tt>foo</tt> and <tt>bar</tt> are each going to use the
--   <a>Applicative</a> they are given.
--   
--   <a>confusing</a> exploits the <a>Yoneda</a> lemma to merge their
--   separate uses of <a>fmap</a> into a single <a>fmap</a>. and it further
--   exploits an interesting property of the right Kan lift (or
--   <a>Curried</a>) to left associate all of the uses of
--   <tt>(<a>&lt;*&gt;</a>)</tt> to make it possible to fuse together more
--   fmaps.
--   
--   This is particularly effective when the choice of functor <tt>f</tt>
--   is unknown at compile time or when the <a>Traversal</a>
--   <tt>foo.bar</tt> in the above description is recursive or complex
--   enough to prevent inlining.
--   
--   <a>fusing</a> is a version of this combinator suitable for fusing
--   lenses.
--   
--   <pre>
--   <a>confusing</a> :: <a>Traversal</a> s t a b -&gt; <a>Traversal</a> s t a b
--   </pre>
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b

-- | Strict version of <a>_10</a>
_10' :: Field10 s t a b => Lens s t a b

-- | Strict version of <a>_11</a>
_11' :: Field11 s t a b => Lens s t a b

-- | Strict version of <a>_12</a>
_12' :: Field12 s t a b => Lens s t a b

-- | Strict version of <a>_13</a>
_13' :: Field13 s t a b => Lens s t a b

-- | Strict version of <a>_14</a>
_14' :: Field14 s t a b => Lens s t a b

-- | Strict version of <a>_15</a>
_15' :: Field15 s t a b => Lens s t a b

-- | Strict version of <a>_16</a>
_16' :: Field16 s t a b => Lens s t a b

-- | Strict version of <a>_17</a>
_17' :: Field17 s t a b => Lens s t a b

-- | Strict version of <a>_18</a>
_18' :: Field18 s t a b => Lens s t a b

-- | Strict version of <a>_19</a>
_19' :: Field19 s t a b => Lens s t a b
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its type is used.
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s

-- | Work under a newtype wrapper.
--   
--   <pre>
--   &gt;&gt;&gt; Const "hello" &amp; _Wrapped %~ Prelude.length &amp; getConst
--   5
--   </pre>
--   
--   <pre>
--   <a>_Wrapped</a>   ≡ <a>from</a> <a>_Unwrapped</a>
--   <a>_Unwrapped</a> ≡ <a>from</a> <a>_Wrapped</a>
--   </pre>
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s

-- | This is a convenient version of <a>_Wrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)

-- | This is a convenient version of <a>_Unwrapped</a> with an argument
--   that's ignored.
--   
--   The user supplied function is <i>ignored</i>, merely its types are
--   used.
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s

-- | Given the constructor for a <a>Wrapped</a> type, return a
--   deconstructor that is its inverse.
--   
--   Assuming the <a>Wrapped</a> instance is legal, these laws hold:
--   
--   <pre>
--   <a>op</a> f <a>.</a> f ≡ <a>id</a>
--   f <a>.</a> <a>op</a> f ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Identity (Identity 4)
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; op Const (Const "hello")
--   "hello"
--   </pre>
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s

-- | This combinator is based on <tt>ala</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   &gt;&gt;&gt; ala Sum foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala All foldMap [True,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [False,False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Any foldMap [True,False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ala Product foldMap [1,2,3,4]
--   24
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler, type.
--   
--   <pre>
--   ala :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((Unwrapped t -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; Unwrapped s
--   </pre>
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)

-- | This combinator is based on <tt>ala'</tt> from Conor McBride's work on
--   Epigram.
--   
--   As with <a>_Wrapping</a>, the user supplied function for the newtype
--   is <i>ignored</i>.
--   
--   <pre>
--   alaf :: Rewrapping s t =&gt; (Unwrapped s -&gt; s) -&gt; ((r -&gt; t) -&gt; e -&gt; s) -&gt; (r -&gt; Unwrapped t) -&gt; e -&gt; Unwrapped s
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; alaf Sum foldMap Prelude.length ["hello","world"]
--   10
--   </pre>
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)

-- | Implement the <a>_Wrapped</a> operation for a type using its
--   <a>Generic</a> instance.
_GWrapped' :: (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)


-- | <tt>Control.Exception</tt> provides an example of a large open
--   hierarchy that we can model with prisms and isomorphisms.
--   
--   Additional combinators for working with <a>IOException</a> results can
--   be found in <a>System.IO.Error.Lens</a>.
--   
--   The combinators in this module have been generalized to work with
--   <a>MonadCatch</a> instead of just <a>IO</a>. This enables them to be
--   used more easily in <a>Monad</a> transformer stacks.
module Control.Exception.Lens

-- | Catch exceptions that match a given <a>Prism</a> (or any <a>Fold</a>,
--   really).
--   
--   <pre>
--   &gt;&gt;&gt; catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -&gt; return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a    -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   <a>catching</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a      -&gt; m r -&gt; (a -&gt; m r) -&gt; m r
--   </pre>
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r

-- | Catch exceptions that match a given <a>Prism</a> (or any
--   <a>Getter</a>), discarding the information about the match. This is
--   particularly useful when you have a <tt><a>Prism'</a> e ()</tt> where
--   the result of the <a>Prism</a> or <a>Fold</a> isn't particularly
--   valuable, just the fact that it matches.
--   
--   <pre>
--   &gt;&gt;&gt; catching_ _AssertionFailed (assert False (return "uncaught")) $ return "caught"
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a    -&gt; m r -&gt; m r -&gt; m r
--   <a>catching_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   </pre>
catching_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | A version of <a>catching</a> with the arguments swapped around; useful
--   in situations where the code for the handler is shorter.
--   
--   <pre>
--   &gt;&gt;&gt; handling _NonTermination (\_ -&gt; return "caught") $ throwIO NonTermination
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a      -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   <a>handling</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a    -&gt; (a -&gt; m r) -&gt; m r -&gt; m r
--   </pre>
handling :: MonadCatch m => Getting (First a) SomeException a -> (a -> m r) -> m r -> m r

-- | A version of <a>catching_</a> with the arguments swapped around;
--   useful in situations where the code for the handler is shorter.
--   
--   <pre>
--   &gt;&gt;&gt; handling_ _NonTermination (return "caught") $ throwIO NonTermination
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a> <a>SomeException</a> a     -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a> <a>SomeException</a> a       -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a> <a>SomeException</a> a    -&gt; m r -&gt; m r -&gt; m r
--   <a>handling_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a> <a>SomeException</a> a      -&gt; m r -&gt; m r -&gt; m r
--   </pre>
handling_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r

-- | A variant of <a>try</a> that takes a <a>Prism</a> (or any <a>Fold</a>)
--   to select which exceptions are caught (c.f. <a>tryJust</a>,
--   <a>catchJust</a>). If the <a>Exception</a> does not match the
--   predicate, it is re-thrown.
--   
--   <pre>
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>    <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   <a>trying</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>      <a>SomeException</a> a -&gt; m r -&gt; m (<a>Either</a> a r)
--   </pre>
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)

-- | A version of <a>trying</a> that discards the specific exception
--   thrown.
--   
--   <pre>
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Iso'</a>       <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Getter</a>    <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   <a>trying_</a> :: <a>MonadCatch</a> m =&gt; <a>Fold</a>      <a>SomeException</a> a -&gt; m r -&gt; m (Maybe r)
--   </pre>
trying_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Maybe r)

-- | Throw an <a>Exception</a> described by a <a>Prism</a>. Exceptions may
--   be thrown from purely functional code, but may only be caught within
--   the <a>IO</a> <a>Monad</a>.
--   
--   <pre>
--   <a>throwing</a> l ≡ <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwing</a> :: <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; r
--   <a>throwing</a> :: <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; r
--   </pre>
throwing :: AReview SomeException b -> b -> r

-- | Similar to <a>throwing</a> but specialised for the common case of
--   error constructors with no arguments.
--   
--   <pre>
--   data MyError = Foo | Bar
--   makePrisms ''MyError
--   <a>throwing_</a> _Foo :: <a>MonadError</a> MyError m =&gt; m a
--   </pre>
throwing_ :: AReview SomeException () -> m x

-- | A variant of <a>throwing</a> that can only be used within the
--   <a>IO</a> <a>Monad</a> (or any other <a>MonadCatch</a> instance) to
--   throw an <a>Exception</a> described by a <a>Prism</a>.
--   
--   Although <a>throwingM</a> has a type that is a specialization of the
--   type of <a>throwing</a>, the two functions are subtly different:
--   
--   <pre>
--   <a>throwing</a> l e `seq` x  ≡ <a>throwing</a> e
--   <a>throwingM</a> l e `seq` x ≡ x
--   </pre>
--   
--   The first example will cause the <a>Exception</a> <tt>e</tt> to be
--   raised, whereas the second one won't. In fact, <a>throwingM</a> will
--   only cause an <a>Exception</a> to be raised when it is used within the
--   <a>MonadCatch</a> instance. The <a>throwingM</a> variant should be
--   used in preference to <a>throwing</a> to raise an <a>Exception</a>
--   within the <a>Monad</a> because it guarantees ordering with respect to
--   other monadic operations, whereas <a>throwing</a> does not.
--   
--   <pre>
--   <a>throwingM</a> l ≡ <a>reviews</a> l <a>throw</a>
--   </pre>
--   
--   <pre>
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m r
--   <a>throwingM</a> :: <a>MonadThrow</a> m =&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m r
--   </pre>
throwingM :: MonadThrow m => AReview SomeException b -> b -> m r

-- | <a>throwingTo</a> raises an <a>Exception</a> specified by a
--   <a>Prism</a> in the target thread.
--   
--   <pre>
--   <a>throwingTo</a> thread l ≡ <a>reviews</a> l (<a>throwTo</a> thread)
--   </pre>
--   
--   <pre>
--   <a>throwingTo</a> :: <a>ThreadId</a> -&gt; <a>Prism'</a> <a>SomeException</a> t -&gt; t -&gt; m a
--   <a>throwingTo</a> :: <a>ThreadId</a> -&gt; <a>Iso'</a> <a>SomeException</a> t   -&gt; t -&gt; m a
--   </pre>
throwingTo :: MonadIO m => ThreadId -> AReview SomeException b -> b -> m ()

-- | This <a>Setter</a> can be used to purely map over the
--   <a>Exception</a>s an arbitrary expression might throw; it is a variant
--   of <a>mapException</a> in the same way that <a>mapped</a> is a variant
--   of <a>fmap</a>.
--   
--   <pre>
--   'mapException' ≡ 'over' 'mappedException'
--   </pre>
--   
--   This view that every Haskell expression can be regarded as carrying a
--   bag of <a>Exception</a>s is detailed in “A Semantics for Imprecise
--   Exceptions” by Peyton Jones &amp; al. at PLDI ’99.
--   
--   The following maps failed assertions to arithmetic overflow:
--   
--   <pre>
--   &gt;&gt;&gt; handling _Overflow (\_ -&gt; return "caught") $ assert False (return "uncaught") &amp; mappedException %~ \ (AssertionFailed _) -&gt; Overflow
--   "caught"
--   </pre>
mappedException :: (Exception e, Exception e') => Setter s s e e'

-- | This is a type restricted version of <a>mappedException</a>, which
--   avoids the type ambiguity in the input <a>Exception</a> when using
--   <a>set</a>.
--   
--   The following maps any exception to arithmetic overflow:
--   
--   <pre>
--   &gt;&gt;&gt; handling _Overflow (\_ -&gt; return "caught") $ assert False (return "uncaught") &amp; mappedException' .~ Overflow
--   "caught"
--   </pre>
mappedException' :: Exception e' => Setter s s SomeException e'

-- | Traverse the strongly typed <a>Exception</a> contained in
--   <a>SomeException</a> where the type of your function matches the
--   desired <a>Exception</a>.
--   
--   <pre>
--   <a>exception</a> :: (<a>Applicative</a> f, <a>Exception</a> a)
--             =&gt; (a -&gt; f a) -&gt; <a>SomeException</a> -&gt; f <a>SomeException</a>
--   </pre>
exception :: Exception a => Prism' SomeException a
pattern Exception :: Exception a => a -> SomeException

-- | Both <tt>exceptions</tt> and <a>Control.Exception</a> provide a
--   <a>Handler</a> type.
--   
--   This lets us write combinators to build handlers that are agnostic
--   about the choice of which of these they use.
class Handleable e (m :: Type -> Type) (h :: Type -> Type) | h -> e m

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really).
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler</a> <a>_AssertionFailed</a> (s -&gt; <a>print</a> <a>$</a> "Assertion Failed\n" <a>++</a> s)
--               , <a>handler</a> <a>_ErrorCall</a> (s -&gt; <a>print</a> <a>$</a> "Error\n" <a>++</a> s)
--               ]
--   </pre>
--   
--   This works ith both the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; <a>IO</a> r) -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   <a>handler</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler</a> :: <a>Getter</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Fold</a>       e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Prism'</a>     e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Lens'</a>      e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   <a>handler</a> :: <a>Traversal'</a> e a -&gt; (a -&gt; m r) -&gt; <a>Handler</a> e m r
--   </pre>
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r

-- | This builds a <a>Handler</a> for just the targets of a given
--   <a>Prism</a> (or any <a>Getter</a>, really). that ignores its input
--   and just recovers with the stated monadic action.
--   
--   <pre>
--   <a>catches</a> ... [ <a>handler_</a> <a>_NonTermination</a> (<a>return</a> "looped")
--               , <a>handler_</a> <a>_StackOverflow</a> (<a>return</a> "overflow")
--               ]
--   </pre>
--   
--   This works with the <a>Handler</a> type provided by
--   <tt>Control.Exception</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; <a>IO</a> r -&gt; <a>Handler</a> r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Catch</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Fold</a>       <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Prism'</a>     <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Lens'</a>      <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   <a>handler_</a> :: <a>Traversal'</a> <a>SomeException</a> a -&gt; m r -&gt; <a>Handler</a> m r
--   </pre>
--   
--   and with the <a>Handler</a> type provided by
--   <tt>Control.Monad.Error.Lens</tt>:
--   
--   <pre>
--   <a>handler_</a> :: <a>Getter</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Fold</a>       e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Prism'</a>     e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Lens'</a>      e a -&gt; m r -&gt; <a>Handler</a> e m r
--   <a>handler_</a> :: <a>Traversal'</a> e a -&gt; m r -&gt; <a>Handler</a> e m r
--   </pre>
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r

-- | Exceptions that occur in the <a>IO</a> <a>Monad</a>. An
--   <a>IOException</a> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
--   
--   Due to their richer structure relative to other exceptions, these have
--   a more carefully overloaded signature.
class AsIOException t

-- | Unfortunately the name <a>ioException</a> is taken by <tt>base</tt>
--   for throwing IOExceptions.
--   
--   <pre>
--   <a>_IOException</a> :: <a>Prism'</a> <a>IOException</a> <a>IOException</a>
--   <a>_IOException</a> :: <a>Prism'</a> <a>SomeException</a> <a>IOException</a>
--   </pre>
--   
--   Many combinators for working with an <a>IOException</a> are available
--   in <a>System.IO.Error.Lens</a>.
_IOException :: AsIOException t => Prism' t IOException
pattern IOException_ :: AsIOException s => IOException -> s

-- | Arithmetic exceptions.
class AsArithException t

-- | <pre>
--   <a>_ArithException</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_ArithException</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_ArithException :: AsArithException t => Prism' t ArithException

-- | Handle arithmetic <a>_Overflow</a>.
--   
--   <pre>
--   <a>_Overflow</a> ≡ <a>_ArithException</a> <a>.</a> <a>_Overflow</a>
--   </pre>
--   
--   <pre>
--   <a>_Overflow</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Overflow</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Overflow :: AsArithException t => Prism' t ()

-- | Handle arithmetic <a>_Underflow</a>.
--   
--   <pre>
--   <a>_Underflow</a> ≡ <a>_ArithException</a> <a>.</a> <a>_Underflow</a>
--   </pre>
--   
--   <pre>
--   <a>_Underflow</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Underflow</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Underflow :: AsArithException t => Prism' t ()

-- | Handle arithmetic loss of precision.
--   
--   <pre>
--   <a>_LossOfPrecision</a> ≡ <a>_ArithException</a> <a>.</a> <a>_LossOfPrecision</a>
--   </pre>
--   
--   <pre>
--   <a>_LossOfPrecision</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_LossOfPrecision</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_LossOfPrecision :: AsArithException t => Prism' t ()

-- | Handle division by zero.
--   
--   <pre>
--   <a>_DivideByZero</a> ≡ <a>_ArithException</a> <a>.</a> <a>_DivideByZero</a>
--   </pre>
--   
--   <pre>
--   <a>_DivideByZero</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_DivideByZero</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_DivideByZero :: AsArithException t => Prism' t ()

-- | Handle exceptional _Denormalized floating pure.
--   
--   <pre>
--   <a>_Denormal</a> ≡ <a>_ArithException</a> <a>.</a> <a>_Denormal</a>
--   </pre>
--   
--   <pre>
--   <a>_Denormal</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_Denormal</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_Denormal :: AsArithException t => Prism' t ()

-- | <pre>
--   <a>_RatioZeroDenominator</a> ≡ <a>_ArithException</a> <a>.</a> <a>_RatioZeroDenominator</a>
--   </pre>
--   
--   <pre>
--   <a>_RatioZeroDenominator</a> :: <a>Prism'</a> <a>ArithException</a> <a>ArithException</a>
--   <a>_RatioZeroDenominator</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArithException</a>
--   </pre>
_RatioZeroDenominator :: AsArithException t => Prism' t ()
pattern ArithException_ :: AsArithException s => ArithException -> s
pattern Overflow_ :: AsArithException s => s
pattern Underflow_ :: AsArithException s => s
pattern LossOfPrecision_ :: AsArithException s => s
pattern DivideByZero_ :: AsArithException s => s
pattern Denormal_ :: AsArithException s => s
pattern RatioZeroDenominator_ :: AsArithException s => s

-- | Exceptions generated by array operations.
class AsArrayException t

-- | Extract information about an <a>ArrayException</a>.
--   
--   <pre>
--   <a>_ArrayException</a> :: <a>Prism'</a> <a>ArrayException</a> <a>ArrayException</a>
--   <a>_ArrayException</a> :: <a>Prism'</a> <a>SomeException</a>  <a>ArrayException</a>
--   </pre>
_ArrayException :: AsArrayException t => Prism' t ArrayException

-- | An attempt was made to index an array outside its declared bounds.
--   
--   <pre>
--   <a>_IndexOutOfBounds</a> ≡ <a>_ArrayException</a> <a>.</a> <a>_IndexOutOfBounds</a>
--   </pre>
--   
--   <pre>
--   <a>_IndexOutOfBounds</a> :: <a>Prism'</a> <a>ArrayException</a> <a>String</a>
--   <a>_IndexOutOfBounds</a> :: <a>Prism'</a> <a>SomeException</a>  <a>String</a>
--   </pre>
_IndexOutOfBounds :: AsArrayException t => Prism' t String

-- | An attempt was made to evaluate an element of an array that had not
--   been initialized.
--   
--   <pre>
--   <a>_UndefinedElement</a> ≡ <a>_ArrayException</a> <a>.</a> <a>_UndefinedElement</a>
--   </pre>
--   
--   <pre>
--   <a>_UndefinedElement</a> :: <a>Prism'</a> <a>ArrayException</a> <a>String</a>
--   <a>_UndefinedElement</a> :: <a>Prism'</a> <a>SomeException</a>  <a>String</a>
--   </pre>
_UndefinedElement :: AsArrayException t => Prism' t String
pattern ArrayException_ :: AsArrayException s => ArrayException -> s
pattern IndexOutOfBounds_ :: AsArrayException s => String -> s
pattern UndefinedElement_ :: AsArrayException s => String -> s

-- | <a>assert</a> was applied to <a>False</a>.
class AsAssertionFailed t

-- | <pre>
--   <a>__AssertionFailed</a> :: <a>Prism'</a> <a>AssertionFailed</a> <a>AssertionFailed</a>
--   <a>__AssertionFailed</a> :: <a>Prism'</a> <a>SomeException</a>   <a>AssertionFailed</a>
--   </pre>
__AssertionFailed :: AsAssertionFailed t => Prism' t AssertionFailed

-- | This <a>Exception</a> contains provides information about what
--   assertion failed in the <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; handling _AssertionFailed (\ xs -&gt; "caught" &lt;$ guard ("&lt;interactive&gt;" `isInfixOf` xs) ) $ assert False (return "uncaught")
--   "caught"
--   </pre>
--   
--   <pre>
--   <a>_AssertionFailed</a> :: <a>Prism'</a> <a>AssertionFailed</a> <a>String</a>
--   <a>_AssertionFailed</a> :: <a>Prism'</a> <a>SomeException</a>   <a>String</a>
--   </pre>
_AssertionFailed :: AsAssertionFailed t => Prism' t String
pattern AssertionFailed__ :: AsAssertionFailed s => AssertionFailed -> s
pattern AssertionFailed_ :: AsAssertionFailed s => String -> s

-- | Asynchronous exceptions.
class AsAsyncException t

-- | There are several types of <a>AsyncException</a>.
--   
--   <pre>
--   <a>_AsyncException</a> :: <a>Equality'</a> <a>AsyncException</a> <a>AsyncException</a>
--   <a>_AsyncException</a> :: <a>Prism'</a>    <a>SomeException</a>  <a>AsyncException</a>
--   </pre>
_AsyncException :: AsAsyncException t => Prism' t AsyncException

-- | The current thread's stack exceeded its limit. Since an
--   <a>Exception</a> has been raised, the thread's stack will certainly be
--   below its limit again, but the programmer should take remedial action
--   immediately.
--   
--   <pre>
--   <a>_StackOverflow</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_StackOverflow</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_StackOverflow :: AsAsyncException t => Prism' t ()

-- | The program's heap is reaching its limit, and the program should take
--   action to reduce the amount of live data it has.
--   
--   Notes:
--   
--   <ul>
--   <li>It is undefined which thread receives this <a>Exception</a>.</li>
--   <li>GHC currently does not throw <a>HeapOverflow</a> exceptions.</li>
--   </ul>
--   
--   <pre>
--   <a>_HeapOverflow</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_HeapOverflow</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_HeapOverflow :: AsAsyncException t => Prism' t ()

-- | This <a>Exception</a> is raised by another thread calling
--   <a>killThread</a>, or by the system if it needs to terminate the
--   thread for some reason.
--   
--   <pre>
--   <a>_ThreadKilled</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_ThreadKilled</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_ThreadKilled :: AsAsyncException t => Prism' t ()

-- | This <a>Exception</a> is raised by default in the main thread of the
--   program when the user requests to terminate the program via the usual
--   mechanism(s) (<i>e.g.</i> Control-C in the console).
--   
--   <pre>
--   <a>_UserInterrupt</a> :: <a>Prism'</a> <a>AsyncException</a> ()
--   <a>_UserInterrupt</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_UserInterrupt :: AsAsyncException t => Prism' t ()
pattern AsyncException_ :: AsAsyncException s => AsyncException -> s
pattern StackOverflow_ :: AsAsyncException s => s
pattern HeapOverflow_ :: AsAsyncException s => s
pattern ThreadKilled_ :: AsAsyncException s => s
pattern UserInterrupt_ :: AsAsyncException s => s

-- | Thrown when the runtime system detects that the computation is
--   guaranteed not to terminate. Note that there is no guarantee that the
--   runtime system will notice whether any given computation is guaranteed
--   to terminate or not.
class AsNonTermination t

-- | <pre>
--   <a>__NonTermination</a> :: <a>Prism'</a> <a>NonTermination</a> <a>NonTermination</a>
--   <a>__NonTermination</a> :: <a>Prism'</a> <a>SomeException</a>  <a>NonTermination</a>
--   </pre>
__NonTermination :: AsNonTermination t => Prism' t NonTermination

-- | There is no additional information carried in a <a>NonTermination</a>
--   <a>Exception</a>.
--   
--   <pre>
--   <a>_NonTermination</a> :: <a>Prism'</a> <a>NonTermination</a> ()
--   <a>_NonTermination</a> :: <a>Prism'</a> <a>SomeException</a>  ()
--   </pre>
_NonTermination :: AsNonTermination t => Prism' t ()
pattern NonTermination__ :: AsNonTermination s => NonTermination -> s
pattern NonTermination_ :: AsNonTermination s => s

-- | Thrown when the program attempts to call atomically, from the
--   <a>STM</a> package, inside another call to atomically.
class AsNestedAtomically t

-- | <pre>
--   <a>__NestedAtomically</a> :: <a>Prism'</a> <a>NestedAtomically</a> <a>NestedAtomically</a>
--   <a>__NestedAtomically</a> :: <a>Prism'</a> <a>SomeException</a>    <a>NestedAtomically</a>
--   </pre>
__NestedAtomically :: AsNestedAtomically t => Prism' t NestedAtomically

-- | There is no additional information carried in a
--   <a>NestedAtomically</a> <a>Exception</a>.
--   
--   <pre>
--   <a>_NestedAtomically</a> :: <a>Prism'</a> <a>NestedAtomically</a> ()
--   <a>_NestedAtomically</a> :: <a>Prism'</a> <a>SomeException</a>    ()
--   </pre>
_NestedAtomically :: AsNestedAtomically t => Prism' t ()
pattern NestedAtomically__ :: AsNestedAtomically s => NestedAtomically -> s
pattern NestedAtomically_ :: AsNestedAtomically s => s

-- | The thread is blocked on an <a>MVar</a>, but there are no other
--   references to the <a>MVar</a> so it can't ever continue.
class AsBlockedIndefinitelyOnMVar t

-- | <pre>
--   <a>__BlockedIndefinitelyOnMVar</a> :: <a>Prism'</a> <a>BlockedIndefinitelyOnMVar</a> <a>BlockedIndefinitelyOnMVar</a>
--   <a>__BlockedIndefinitelyOnMVar</a> :: <a>Prism'</a> <a>SomeException</a>             <a>BlockedIndefinitelyOnMVar</a>
--   </pre>
__BlockedIndefinitelyOnMVar :: AsBlockedIndefinitelyOnMVar t => Prism' t BlockedIndefinitelyOnMVar

-- | There is no additional information carried in a
--   <a>BlockedIndefinitelyOnMVar</a> <a>Exception</a>.
--   
--   <pre>
--   <a>_BlockedIndefinitelyOnMVar</a> :: <a>Prism'</a> <a>BlockedIndefinitelyOnMVar</a> ()
--   <a>_BlockedIndefinitelyOnMVar</a> :: <a>Prism'</a> <a>SomeException</a>             ()
--   </pre>
_BlockedIndefinitelyOnMVar :: AsBlockedIndefinitelyOnMVar t => Prism' t ()
pattern BlockedIndefinitelyOnMVar__ :: AsBlockedIndefinitelyOnMVar s => BlockedIndefinitelyOnMVar -> s
pattern BlockedIndefinitelyOnMVar_ :: AsBlockedIndefinitelyOnMVar s => s

-- | The thread is waiting to retry an <a>STM</a> transaction, but there
--   are no other references to any TVars involved, so it can't ever
--   continue.
class AsBlockedIndefinitelyOnSTM t

-- | <pre>
--   <a>__BlockedIndefinitelyOnSTM</a> :: <a>Prism'</a> <a>BlockedIndefinitelyOnSTM</a> <a>BlockedIndefinitelyOnSTM</a>
--   <a>__BlockedIndefinitelyOnSTM</a> :: <a>Prism'</a> <a>SomeException</a>            <a>BlockedIndefinitelyOnSTM</a>
--   </pre>
__BlockedIndefinitelyOnSTM :: AsBlockedIndefinitelyOnSTM t => Prism' t BlockedIndefinitelyOnSTM

-- | There is no additional information carried in a
--   <a>BlockedIndefinitelyOnSTM</a> <a>Exception</a>.
--   
--   <pre>
--   <a>_BlockedIndefinitelyOnSTM</a> :: <a>Prism'</a> <a>BlockedIndefinitelyOnSTM</a> ()
--   <a>_BlockedIndefinitelyOnSTM</a> :: <a>Prism'</a> <a>SomeException</a>            ()
--   </pre>
_BlockedIndefinitelyOnSTM :: AsBlockedIndefinitelyOnSTM t => Prism' t ()
pattern BlockedIndefinitelyOnSTM__ :: AsBlockedIndefinitelyOnSTM s => BlockedIndefinitelyOnSTM -> s
pattern BlockedIndefinitelyOnSTM_ :: AsBlockedIndefinitelyOnSTM s => s

-- | There are no runnable threads, so the program is deadlocked. The
--   <a>Deadlock</a> <a>Exception</a> is raised in the main thread only.
class AsDeadlock t

-- | <pre>
--   <a>__Deadlock</a> :: <a>Prism'</a> <a>Deadlock</a>      <a>Deadlock</a>
--   <a>__Deadlock</a> :: <a>Prism'</a> <a>SomeException</a> <a>Deadlock</a>
--   </pre>
__Deadlock :: AsDeadlock t => Prism' t Deadlock

-- | There is no information carried in a <a>Deadlock</a> <a>Exception</a>.
--   
--   <pre>
--   <a>_Deadlock</a> :: <a>Prism'</a> <a>Deadlock</a>      ()
--   <a>_Deadlock</a> :: <a>Prism'</a> <a>SomeException</a> ()
--   </pre>
_Deadlock :: AsDeadlock t => Prism' t ()
pattern Deadlock__ :: AsDeadlock s => Deadlock -> s
pattern Deadlock_ :: AsDeadlock s => s

-- | A class method without a definition (neither a default definition, nor
--   a definition in the appropriate instance) was called.
class AsNoMethodError t

-- | <pre>
--   <a>__NoMethodError</a> :: <a>Prism'</a> <a>NoMethodError</a> <a>NoMethodError</a>
--   <a>__NoMethodError</a> :: <a>Prism'</a> <a>SomeException</a> <a>NoMethodError</a>
--   </pre>
__NoMethodError :: AsNoMethodError t => Prism' t NoMethodError

-- | Extract a description of the missing method.
--   
--   <pre>
--   <a>_NoMethodError</a> :: <a>Prism'</a> <a>NoMethodError</a> <a>String</a>
--   <a>_NoMethodError</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_NoMethodError :: AsNoMethodError t => Prism' t String
pattern NoMethodError__ :: AsNoMethodError s => NoMethodError -> s
pattern NoMethodError_ :: AsNoMethodError s => String -> s

-- | A pattern match failed.
class AsPatternMatchFail t

-- | <pre>
--   <a>__PatternMatchFail</a> :: <a>Prism'</a> <a>PatternMatchFail</a> <a>PatternMatchFail</a>
--   <a>__PatternMatchFail</a> :: <a>Prism'</a> <a>SomeException</a>    <a>PatternMatchFail</a>
--   </pre>
__PatternMatchFail :: AsPatternMatchFail t => Prism' t PatternMatchFail

-- | Information about the source location of the pattern.
--   
--   <pre>
--   <a>_PatternMatchFail</a> :: <a>Prism'</a> <a>PatternMatchFail</a> <a>String</a>
--   <a>_PatternMatchFail</a> :: <a>Prism'</a> <a>SomeException</a>    <a>String</a>
--   </pre>
_PatternMatchFail :: AsPatternMatchFail t => Prism' t String
pattern PatternMatchFail__ :: AsPatternMatchFail s => PatternMatchFail -> s
pattern PatternMatchFail_ :: AsPatternMatchFail s => String -> s

-- | An uninitialised record field was used.
class AsRecConError t

-- | <pre>
--   <a>__RecConError</a> :: <a>Prism'</a> <a>RecConError</a>   <a>RecConError</a>
--   <a>__RecConError</a> :: <a>Prism'</a> <a>SomeException</a> <a>RecConError</a>
--   </pre>
__RecConError :: AsRecConError t => Prism' t RecConError

-- | Information about the source location where the record was
--   constructed.
--   
--   <pre>
--   <a>_RecConError</a> :: <a>Prism'</a> <a>RecConError</a>   <a>String</a>
--   <a>_RecConError</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_RecConError :: AsRecConError t => Prism' t String

-- | A record selector was applied to a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another.
class AsRecSelError t

-- | <pre>
--   <a>__RecSelError</a> :: <a>Prism'</a> <a>RecSelError</a>   <a>RecSelError</a>
--   <a>__RecSelError</a> :: <a>Prism'</a> <a>SomeException</a> <a>RecSelError</a>
--   </pre>
__RecSelError :: AsRecSelError t => Prism' t RecSelError

-- | Information about the source location where the record selection
--   occurred.
--   
--   <pre>
--   <a>_RecSelError</a> :: <a>Prism'</a> <a>RecSelError</a>   <a>String</a>
--   <a>_RecSelError</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_RecSelError :: AsRecSelError t => Prism' t String

-- | A record update was performed on a constructor without the appropriate
--   field. This can only happen with a datatype with multiple
--   constructors, where some fields are in one constructor but not
--   another.
class AsRecUpdError t

-- | <pre>
--   <a>__RecUpdError</a> :: <a>Prism'</a> <a>RecUpdError</a>   <a>RecUpdError</a>
--   <a>__RecUpdError</a> :: <a>Prism'</a> <a>SomeException</a> <a>RecUpdError</a>
--   </pre>
__RecUpdError :: AsRecUpdError t => Prism' t RecUpdError

-- | Information about the source location where the record was updated.
--   
--   <pre>
--   <a>_RecUpdError</a> :: <a>Prism'</a> <a>RecUpdError</a>   <a>String</a>
--   <a>_RecUpdError</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_RecUpdError :: AsRecUpdError t => Prism' t String
pattern RecConError__ :: AsRecConError s => RecConError -> s
pattern RecConError_ :: AsRecConError s => String -> s
pattern RecSelError__ :: AsRecSelError s => RecSelError -> s
pattern RecSelError_ :: AsRecSelError s => String -> s
pattern RecUpdError__ :: AsRecUpdError s => RecUpdError -> s
pattern RecUpdError_ :: AsRecUpdError s => String -> s

-- | This is thrown when the user calls <a>error</a>.
class AsErrorCall t

-- | <pre>
--   <a>__ErrorCall</a> :: <a>Prism'</a> <a>ErrorCall</a>     <a>ErrorCall</a>
--   <a>__ErrorCall</a> :: <a>Prism'</a> <a>SomeException</a> <a>ErrorCall</a>
--   </pre>
__ErrorCall :: AsErrorCall t => Prism' t ErrorCall

-- | Retrieve the argument given to <a>error</a>.
--   
--   <a>ErrorCall</a> is isomorphic to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; catching _ErrorCall (error "touch down!") return
--   "touch down!"
--   </pre>
--   
--   <pre>
--   <a>_ErrorCall</a> :: <a>Prism'</a> <a>ErrorCall</a>     <a>String</a>
--   <a>_ErrorCall</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_ErrorCall :: AsErrorCall t => Prism' t String
pattern ErrorCall__ :: AsErrorCall s => ErrorCall -> s
pattern ErrorCall_ :: AsErrorCall s => String -> s

-- | This thread has exceeded its allocation limit.
class AsAllocationLimitExceeded t

-- | <pre>
--   <a>__AllocationLimitExceeded</a> :: <a>Prism'</a> <a>AllocationLimitExceeded</a> <a>AllocationLimitExceeded</a>
--   <a>__AllocationLimitExceeded</a> :: <a>Prism'</a> <a>SomeException</a>           <a>AllocationLimitExceeded</a>
--   </pre>
__AllocationLimitExceeded :: AsAllocationLimitExceeded t => Prism' t AllocationLimitExceeded

-- | There is no additional information carried in an
--   <a>AllocationLimitExceeded</a> <a>Exception</a>.
--   
--   <pre>
--   <a>_AllocationLimitExceeded</a> :: <a>Prism'</a> <a>AllocationLimitExceeded</a> ()
--   <a>_AllocationLimitExceeded</a> :: <a>Prism'</a> <a>SomeException</a>           ()
--   </pre>
_AllocationLimitExceeded :: AsAllocationLimitExceeded t => Prism' t ()
pattern AllocationLimitExceeded__ :: AsAllocationLimitExceeded s => AllocationLimitExceeded -> s
pattern AllocationLimitExceeded_ :: AsAllocationLimitExceeded s => s

-- | An expression that didn't typecheck during compile time was called.
--   This is only possible with <tt>-fdefer-type-errors</tt>.
class AsTypeError t

-- | <pre>
--   <a>__TypeError</a> :: <a>Prism'</a> <a>TypeError</a>     <a>TypeError</a>
--   <a>__TypeError</a> :: <a>Prism'</a> <a>SomeException</a> <a>TypeError</a>
--   </pre>
__TypeError :: AsTypeError t => Prism' t TypeError

-- | Details about the failed type check.
--   
--   <pre>
--   <a>_TypeError</a> :: <a>Prism'</a> <a>TypeError</a>     <a>String</a>
--   <a>_TypeError</a> :: <a>Prism'</a> <a>SomeException</a> <a>String</a>
--   </pre>
_TypeError :: AsTypeError t => Prism' t String
pattern TypeError__ :: AsTypeError s => TypeError -> s
pattern TypeError_ :: AsTypeError s => String -> s

-- | Compaction found an object that cannot be compacted. Functions cannot
--   be compacted, nor can mutable objects or pinned objects.
class AsCompactionFailed t

-- | <pre>
--   <a>__CompactionFailed</a> :: <a>Prism'</a> <a>CompactionFailed</a> <a>CompactionFailed</a>
--   <a>__CompactionFailed</a> :: <a>Prism'</a> <a>SomeException</a>    <a>CompactionFailed</a>
--   </pre>
__CompactionFailed :: AsCompactionFailed t => Prism' t CompactionFailed

-- | Information about why a compaction failed.
--   
--   <pre>
--   <a>_CompactionFailed</a> :: <a>Prism'</a> <a>CompactionFailed</a> <a>String</a>
--   <a>_CompactionFailed</a> :: <a>Prism'</a> <a>SomeException</a>    <a>String</a>
--   </pre>
_CompactionFailed :: AsCompactionFailed t => Prism' t String
pattern CompactionFailed__ :: AsCompactionFailed s => CompactionFailed -> s
pattern CompactionFailed_ :: AsCompactionFailed s => String -> s

-- | This <a>Exception</a> is thrown by <tt>lens</tt> when the user somehow
--   manages to rethrow an internal <a>HandlingException</a>.
class AsHandlingException t

-- | <pre>
--   <a>__HandlingException</a> :: <a>Prism'</a> <a>HandlingException</a> <a>HandlingException</a>
--   <a>__HandlingException</a> :: <a>Prism'</a> <a>SomeException</a>     <a>HandlingException</a>
--   </pre>
__HandlingException :: AsHandlingException t => Prism' t HandlingException

-- | There is no information carried in a <a>HandlingException</a>.
--   
--   <pre>
--   <a>_HandlingException</a> :: <a>Prism'</a> <a>HandlingException</a> ()
--   <a>_HandlingException</a> :: <a>Prism'</a> <a>SomeException</a>     ()
--   </pre>
_HandlingException :: AsHandlingException t => Prism' t ()
pattern HandlingException__ :: AsHandlingException s => HandlingException -> s
pattern HandlingException_ :: AsHandlingException s => s
instance Control.Exception.Lens.AsHandlingException Control.Lens.Internal.Exception.HandlingException
instance Control.Exception.Lens.AsHandlingException GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsCompactionFailed GHC.IO.Exception.CompactionFailed
instance Control.Exception.Lens.AsCompactionFailed GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsTypeError Control.Exception.Base.TypeError
instance Control.Exception.Lens.AsTypeError GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsAllocationLimitExceeded GHC.IO.Exception.AllocationLimitExceeded
instance Control.Exception.Lens.AsAllocationLimitExceeded GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsErrorCall GHC.Exception.ErrorCall
instance Control.Exception.Lens.AsErrorCall GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsRecUpdError Control.Exception.Base.RecUpdError
instance Control.Exception.Lens.AsRecUpdError GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsRecSelError Control.Exception.Base.RecSelError
instance Control.Exception.Lens.AsRecSelError GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsRecConError Control.Exception.Base.RecConError
instance Control.Exception.Lens.AsRecConError GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsPatternMatchFail Control.Exception.Base.PatternMatchFail
instance Control.Exception.Lens.AsPatternMatchFail GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsNoMethodError Control.Exception.Base.NoMethodError
instance Control.Exception.Lens.AsNoMethodError GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsDeadlock GHC.IO.Exception.Deadlock
instance Control.Exception.Lens.AsDeadlock GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsBlockedIndefinitelyOnSTM GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Control.Exception.Lens.AsBlockedIndefinitelyOnSTM GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsBlockedIndefinitelyOnMVar GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Control.Exception.Lens.AsBlockedIndefinitelyOnMVar GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsNestedAtomically Control.Exception.Base.NestedAtomically
instance Control.Exception.Lens.AsNestedAtomically GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsNonTermination Control.Exception.Base.NonTermination
instance Control.Exception.Lens.AsNonTermination GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsAsyncException GHC.IO.Exception.AsyncException
instance Control.Exception.Lens.AsAsyncException GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsAssertionFailed GHC.IO.Exception.AssertionFailed
instance Control.Exception.Lens.AsAssertionFailed GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsArrayException GHC.IO.Exception.ArrayException
instance Control.Exception.Lens.AsArrayException GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsArithException GHC.Exception.Type.ArithException
instance Control.Exception.Lens.AsArithException GHC.Exception.Type.SomeException
instance Control.Exception.Lens.AsIOException GHC.IO.Exception.IOException
instance Control.Exception.Lens.AsIOException GHC.Exception.Type.SomeException


module Data.Dynamic.Lens

-- | Any <a>Dynamic</a> can be thrown as an <a>Exception</a>
class AsDynamic t

-- | This <a>Prism</a> allows you to traverse the typed value contained in
--   a <a>Dynamic</a> where the type required by your function matches that
--   of the contents of the <a>Dynamic</a>, or construct a <a>Dynamic</a>
--   value out of whole cloth. It can also be used to catch or throw a
--   <a>Dynamic</a> value as <a>SomeException</a>.
--   
--   <pre>
--   <a>_Dynamic</a> :: <a>Typeable</a> a =&gt; <a>Prism'</a> <a>Dynamic</a>      a
--   <a>_Dynamic</a> :: <a>Typeable</a> a =&gt; <a>Prism'</a> <a>SomeException</a> a
--   </pre>
_Dynamic :: (AsDynamic t, Typeable a) => Prism' t a
pattern Dynamic :: (AsDynamic s, Typeable a) => a -> s
instance Data.Dynamic.Lens.AsDynamic Data.Dynamic.Dynamic
instance Data.Dynamic.Lens.AsDynamic GHC.Exception.Type.SomeException


module Numeric.Lens

-- | A prism that shows and reads integers in base-2 through base-36
--   
--   Note: This is an improper prism, since leading 0s are stripped when
--   reading.
--   
--   <pre>
--   &gt;&gt;&gt; "100" ^? base 16
--   Just 256
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1767707668033969 ^. re (base 36)
--   "helloworld"
--   </pre>
base :: (HasCallStack, Integral a) => Int -> Prism' String a

-- | This <a>Prism</a> can be used to model the fact that every
--   <a>Integral</a> type is a subset of <a>Integer</a>.
--   
--   Embedding through the <a>Prism</a> only succeeds if the <a>Integer</a>
--   would pass through unmodified when re-extracted.
integral :: (Integral a, Integral b) => Prism Integer Integer a b

-- | <pre>
--   <a>binary</a> = <a>base</a> 2
--   </pre>
binary :: Integral a => Prism' String a

-- | <pre>
--   <a>octal</a> = <a>base</a> 8
--   </pre>
octal :: Integral a => Prism' String a

-- | <pre>
--   <a>decimal</a> = <a>base</a> 10
--   </pre>
decimal :: Integral a => Prism' String a

-- | <pre>
--   <a>hex</a> = <a>base</a> 16
--   </pre>
hex :: Integral a => Prism' String a

-- | <pre>
--   <a>adding</a> n = <a>iso</a> (+n) (subtract n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3]^..traverse.adding 1000
--   [1001,1002,1003]
--   </pre>
adding :: Num a => a -> Iso' a a

-- | <pre>
--   <a>subtracting</a> n = <a>iso</a> (subtract n) ((+n)
--   <a>subtracting</a> n = <a>from</a> (<a>adding</a> n)
--   </pre>
subtracting :: Num a => a -> Iso' a a

-- | <pre>
--   <a>multiplying</a> n = iso (*n) (/n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; multiplying 1000 +~ 3
--   5.003
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fahrenheit = multiplying (9/5).adding 32 in 230^.from fahrenheit
--   110.0
--   </pre>
multiplying :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>dividing</a> n = <a>iso</a> (/n) (*n)
--   <a>dividing</a> n = <a>from</a> (<a>multiplying</a> n)
--   </pre>
--   
--   Note: This errors for n = 0
dividing :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>exponentiating</a> n = <a>iso</a> (**n) (**recip n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum . from (exponentiating 2)) (foldMapOf each) (3,4) == 5
--   True
--   </pre>
exponentiating :: (Floating a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>negated</a> = <a>iso</a> <a>negate</a> <a>negate</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum . negated) (foldMapOf each) (3,4) == 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (_Wrapping Sum) (foldMapOf (each.negated)) (3,4) == -7
--   True
--   </pre>
negated :: Num a => Iso' a a
pattern Integral :: Integral a => a -> Integer


-- | Useful tools for Gödel numbering.
module Numeric.Natural.Lens

-- | The natural numbers are isomorphic to the product of the natural
--   numbers with itself.
--   
--   <pre>
--   N = N*N
--   </pre>
_Pair :: Iso' Natural (Natural, Natural)

-- | The natural numbers are isomorphic to disjoint sums of natural numbers
--   embedded as evens or odds.
--   
--   <pre>
--   N = 2*N
--   </pre>
_Sum :: Iso' Natural (Either Natural Natural)

-- | The natural numbers are isomorphic to lists of natural numbers
_Naturals :: Iso' Natural [Natural]

-- | interleaves the bits of two natural numbers
pattern Pair :: Natural -> Natural -> Natural

-- | <pre>
--   Sum (Left q) = 2*q
--   Sum (Right q) = 2*q+1
--   </pre>
pattern Sum :: Either Natural Natural -> Natural

-- | <pre>
--   Naturals [] = 0
--   Naturals (h:t) = 1 + Pair h (Naturals t)
--   </pre>
pattern Naturals :: [Natural] -> Natural


-- | These prisms can be used with the combinators in
--   <a>Control.Exception.Lens</a>.
module System.Exit.Lens

-- | Exit codes that a program can return with:
class AsExitCode t
_ExitCode :: AsExitCode t => Prism' t ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
--   
--   <pre>
--   <a>_ExitFailure</a> :: <a>Prism'</a> <a>ExitCode</a>      <a>Int</a>
--   <a>_ExitFailure</a> :: <a>Prism'</a> <a>SomeException</a> <a>Int</a>
--   </pre>
_ExitFailure :: AsExitCode t => Prism' t Int

-- | indicates successful termination;
--   
--   <pre>
--   <a>_ExitSuccess</a> :: <a>Prism'</a> <a>ExitCode</a>      ()
--   <a>_ExitSuccess</a> :: <a>Prism'</a> <a>SomeException</a> ()
--   </pre>
_ExitSuccess :: AsExitCode t => Prism' t ()
pattern ExitFailure_ :: AsExitCode s => Int -> s
pattern ExitSuccess_ :: AsExitCode s => s
instance System.Exit.Lens.AsExitCode GHC.IO.Exception.ExitCode
instance System.Exit.Lens.AsExitCode GHC.Exception.Type.SomeException


module System.FilePath.Lens

-- | Modify the path by adding another path.
--   
--   <pre>
--   &gt;&gt;&gt; (both &lt;/&gt;~ "bin" $ ("hello","world")) == ("hello" &lt;/&gt; "bin", "world" &lt;/&gt; "bin")
--   True
--   </pre>
--   
--   <pre>
--   (<a>&lt;/&gt;~</a>) :: <a>Setter</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Iso</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Lens</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   (<a>&lt;/&gt;~</a>) :: <a>Traversal</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; s -&gt; a
--   </pre>
(</>~) :: ASetter s t FilePath FilePath -> FilePath -> s -> t
infixr 4 </>~

-- | Add a path onto the end of the target of a <a>Lens</a> and return the
--   result
--   
--   When you do not need the result of the operation, (<a>&lt;/&gt;~</a>)
--   is more flexible.
(<</>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> FilePath -> s -> (FilePath, a)
infixr 4 <</>~

-- | Add a path onto the end of the target of a <a>Lens</a> and return the
--   original value.
--   
--   When you do not need the original value, (<a>&lt;/&gt;~</a>) is more
--   flexible.
(<<</>~) :: Optical' (->) q ((,) FilePath) s FilePath -> FilePath -> q s (FilePath, s)
infixr 4 <<</>~

-- | Modify the path by adding an extension.
--   
--   <pre>
--   &gt;&gt;&gt; both &lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello.txt","world.txt")
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&gt;~</a>) :: <a>Setter</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Iso</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Lens</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   (<a>&lt;.&gt;~</a>) :: <a>Traversal</a> s a <a>FilePath</a> <a>FilePath</a> -&gt; <a>String</a> -&gt; s -&gt; a
--   </pre>
(<.>~) :: ASetter s a FilePath FilePath -> String -> s -> a
infixr 4 <.>~

-- | Add an extension onto the end of the target of a <a>Lens</a> and
--   return the result
--   
--   <pre>
--   &gt;&gt;&gt; _1 &lt;&lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello.txt",("hello.txt","world"))
--   </pre>
--   
--   When you do not need the result of the operation, (<a>&lt;.&gt;~</a>)
--   is more flexible.
(<<.>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> String -> s -> (FilePath, a)
infixr 4 <<.>~

-- | Add an extension onto the end of the target of a <a>Lens</a> but
--   return the old value
--   
--   <pre>
--   &gt;&gt;&gt; _1 &lt;&lt;&lt;.&gt;~ "txt" $ ("hello","world")
--   ("hello",("hello.txt","world"))
--   </pre>
--   
--   When you do not need the old value, (<a>&lt;.&gt;~</a>) is more
--   flexible.
(<<<.>~) :: Optical' (->) q ((,) FilePath) s FilePath -> String -> q s (FilePath, s)
infixr 4 <<<.>~

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by adding a path.
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;/&gt;= "bin") ("hello","world") == ("hello" &lt;/&gt; "bin", "world" &lt;/&gt; "bin")
--   True
--   </pre>
--   
--   <pre>
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   (<a>&lt;/&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>FilePath</a> -&gt; <a>FilePath</a> -&gt; m ()
--   </pre>
(</>=) :: MonadState s m => ASetter' s FilePath -> FilePath -> m ()
infix 4 </>=

-- | Add a path onto the end of the target of a <a>Lens</a> into your
--   monad's state and return the result.
--   
--   When you do not need the result of the operation, (<a>&lt;/&gt;=</a>)
--   is more flexible.
(<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath
infix 4 <</>=

-- | Add a path onto the end of a target of a <a>Lens</a> into your monad's
--   state and return the old value.
--   
--   When you do not need the result of the operation, (<a>&lt;/&gt;=</a>)
--   is more flexible.
(<<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath
infix 4 <<</>=

-- | Modify the target(s) of a <a>Lens'</a>, <a>Iso'</a>, <a>Setter'</a> or
--   <a>Traversal'</a> by adding an extension.
--   
--   <pre>
--   &gt;&gt;&gt; execState (both &lt;.&gt;= "txt") ("hello","world")
--   ("hello.txt","world.txt")
--   </pre>
--   
--   <pre>
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   (<a>&lt;.&gt;=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s <a>FilePath</a> -&gt; <a>String</a> -&gt; m ()
--   </pre>
(<.>=) :: MonadState s m => ASetter' s FilePath -> String -> m ()
infix 4 <.>=

-- | Add an extension onto the end of the target of a <a>Lens</a> into your
--   monad's state and return the result.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (_1 &lt;&lt;.&gt;= "txt") ("hello","world")
--   "hello.txt"
--   </pre>
--   
--   When you do not need the result of the operation, (<a>&lt;.&gt;=</a>)
--   is more flexible.
(<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath
infix 4 <<.>=

-- | Add an extension onto the end of the target of a <a>Lens</a> into your
--   monad's state and return the old value.
--   
--   <pre>
--   &gt;&gt;&gt; runState (_1 &lt;&lt;&lt;.&gt;= "txt") ("hello","world")
--   ("hello",("hello.txt","world"))
--   </pre>
--   
--   When you do not need the old value, (<a>&lt;.&gt;=</a>) is more
--   flexible.
(<<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath
infix 4 <<<.>=

-- | A <a>Lens</a> for reading and writing to the basename
--   
--   Note: This is <i>not</i> a legal <a>Lens</a> unless the outer
--   <a>FilePath</a> has both a directory and filename component and the
--   generated basenames are not null and contain no directory separators.
--   
--   <pre>
--   &gt;&gt;&gt; (basename .~ "filename" $ "path" &lt;/&gt; "name.png") == "path" &lt;/&gt; "filename.png"
--   True
--   </pre>
basename :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the directory
--   
--   Note: this is <i>not</i> a legal <a>Lens</a> unless the outer
--   <a>FilePath</a> already has a directory component, and generated
--   directories are not null.
--   
--   <pre>
--   &gt;&gt;&gt; (("long" &lt;/&gt; "path" &lt;/&gt; "name.txt") ^. directory) == "long" &lt;/&gt; "path"
--   True
--   </pre>
directory :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the extension
--   
--   Note: This is <i>not</i> a legal <a>Lens</a>, unless you are careful
--   to ensure that generated extension <a>FilePath</a> components are
--   either null or start with <a>extSeparator</a> and do not contain any
--   internal <a>extSeparator</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; (extension .~ ".png" $ "path" &lt;/&gt; "name.txt") == "path" &lt;/&gt; "name.png"
--   True
--   </pre>
extension :: Lens' FilePath FilePath

-- | A <a>Lens</a> for reading and writing to the full filename
--   
--   Note: This is <i>not</i> a legal <a>Lens</a>, unless you are careful
--   to ensure that generated filename <a>FilePath</a> components are not
--   null and do not contain any elements of <a>pathSeparators</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; (filename .~ "name.txt" $ "path" &lt;/&gt; "name.png") == "path" &lt;/&gt; "name.txt"
--   True
--   </pre>
filename :: Lens' FilePath FilePath


module System.IO.Error.Lens

-- | Where the error happened.
location :: Lens' IOException String

-- | Error type specific information.
description :: Lens' IOException String

-- | The handle used by the action flagging this error.
handle :: Lens' IOException (Maybe Handle)

-- | <a>fileName</a> the error is related to.
fileName :: Lens' IOException (Maybe FilePath)

-- | <a>errno</a> leading to this error, if any.
errno :: Lens' IOException (Maybe CInt)

-- | What type of error it is
errorType :: Lens' IOException IOErrorType
_AlreadyExists :: Prism' IOErrorType ()
_NoSuchThing :: Prism' IOErrorType ()
_ResourceBusy :: Prism' IOErrorType ()
_ResourceExhausted :: Prism' IOErrorType ()
_EOF :: Prism' IOErrorType ()
_IllegalOperation :: Prism' IOErrorType ()
_PermissionDenied :: Prism' IOErrorType ()
_UserError :: Prism' IOErrorType ()
_UnsatisfiedConstraints :: Prism' IOErrorType ()
_SystemError :: Prism' IOErrorType ()
_ProtocolError :: Prism' IOErrorType ()
_OtherError :: Prism' IOErrorType ()
_InvalidArgument :: Prism' IOErrorType ()
_InappropriateType :: Prism' IOErrorType ()
_HardwareFault :: Prism' IOErrorType ()
_UnsupportedOperation :: Prism' IOErrorType ()
_TimeExpired :: Prism' IOErrorType ()
_ResourceVanished :: Prism' IOErrorType ()
_Interrupted :: Prism' IOErrorType ()
