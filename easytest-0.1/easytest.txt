-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple, expressive testing library
--   
--   Simple, expressive testing library
@package easytest
@version 0.1

module EasyTest
data Status
Failed :: Status
Passed :: !Int -> Status
Skipped :: Status
Pending :: Status
combineStatus :: Status -> Status -> Status
data Env
Env :: TVar StdGen -> String -> TBQueue (Maybe (TMVar (String, Status))) -> (String -> IO ()) -> String -> Env
[rng] :: Env -> TVar StdGen
[messages] :: Env -> String
[results] :: Env -> TBQueue (Maybe (TMVar (String, Status)))
[note_] :: Env -> String -> IO ()
[allow] :: Env -> String
newtype Test a
Test :: ReaderT Env IO (Maybe a) -> Test a
io :: IO a -> Test a
atomicLogger :: IO (String -> IO ())
expect' :: HasCallStack => Bool -> Test ()
expect :: HasCallStack => Bool -> Test ()
expectEqual' :: (HasCallStack, Eq a, Show a) => a -> a -> Test ()
expectEqual :: (HasCallStack, Eq a, Show a) => a -> a -> Test ()
expectNotEqual :: (HasCallStack, Eq a, Show a) => a -> a -> Test ()
expectJust :: HasCallStack => Maybe a -> Test a
expectRight :: HasCallStack => Either e a -> Test a
expectLeft :: HasCallStack => Either e a -> Test e
tests :: [Test ()] -> Test ()

-- | Run all tests whose scope starts with the given prefix
runOnly :: String -> Test a -> IO ()

-- | Run all tests with the given seed and whose scope starts with the
--   given prefix
rerunOnly :: Int -> String -> Test a -> IO ()
run :: Test a -> IO ()
rerun :: Int -> Test a -> IO ()
run' :: Int -> (String -> IO ()) -> String -> Test a -> IO ()

-- | Label a test. Can be nested. A `<a>.</a>` is placed between nested
--   scopes, so `scope "foo" . scope "bar"` is equivalent to `scope
--   "foo.bar"`
scope :: String -> Test a -> Test a

-- | Log a message
note :: String -> Test ()

-- | Log a showable value
note' :: Show s => s -> Test ()

-- | Generate a random value
random :: Random a => Test a

-- | Generate a bounded random value. Inclusive on both sides.
random' :: Random a => a -> a -> Test a
bool :: Test Bool
word8 :: Test Word8

-- | Generate a random <a>Char</a>
char :: Test Char

-- | Generate a random <a>Int</a>
int :: Test Int

-- | Generate a random <a>Double</a>
double :: Test Double

-- | Generate a random <a>Word</a>
word :: Test Word

-- | Generate a random <a>Int</a> in the given range Note: <a>int</a> 0 5`
--   includes both `0` and `5`
int' :: Int -> Int -> Test Int

-- | Generate a random <a>Char</a> in the given range Note: <a>char</a>
--   <tt>a</tt> <tt>z'</tt> includes both `<tt>a'</tt> and `<tt>z'</tt>.
char' :: Char -> Char -> Test Char

-- | Generate a random <a>Double</a> in the given range Note: <a>double</a>
--   0 1` includes both `0` and `1`.
double' :: Double -> Double -> Test Double

-- | Generate a random <a>Double</a> in the given range Note: <a>word</a> 0
--   10` includes both `0` and `10`.
word' :: Word -> Word -> Test Word

-- | Generate a random <a>Double</a> in the given range Note: <a>word8</a>
--   0 10` includes both `0` and `10`.
word8' :: Word8 -> Word8 -> Test Word8

-- | Sample uniformly from the given list of possibilities
pick :: [a] -> Test a
picker :: Int -> [a] -> Int -> Maybe a

-- | Alias for <a>replicateM</a>
listOf :: Int -> Test a -> Test [a]

-- | Generate a list of lists of the given sizes, an alias for `sizes
--   <a>forM</a> n -&gt; listOf n gen`
listsOf :: [Int] -> Test a -> Test [[a]]

-- | Alias for `liftA2 (,)`.
pair :: Test a -> Test b -> Test (a, b)

-- | Alias for <a>pair</a>.
tuple2 :: (Random a, Random b) => Test (a, b)

-- | Generate a random 3-tuple.
tuple3 :: (Random a, Random b, Random c) => Test (a, b, c)

-- | Generate a random 4-tuple.
tuple4 :: (Random a, Random b, Random c, Random d) => Test (a, b, c, d)

-- | Generate a `Data.Map k v` of the given size.
mapOf :: Ord k => Int -> Test k -> Test v -> Test (Map k v)

-- | Generate a `[Data.Map k v]` of the given sizes.
mapsOf :: Ord k => [Int] -> Test k -> Test v -> Test [Map k v]

-- | Catch all exceptions that could occur in the given <a>Test</a>
wrap :: Test a -> Test a
runWrap :: Env -> ReaderT Env IO (Maybe a) -> IO (Maybe a)

-- | A test with a setup and teardown
using :: IO r -> (r -> IO ()) -> (r -> Test a) -> Test a

-- | The current scope
currentScope :: Test String

-- | Prepend the current scope to a logging message
noteScoped :: String -> Test ()

-- | Record a successful test at the current scope
ok :: Test ()

-- | Skip any tests depending on the return value.
done :: Test a

-- | Explicitly skip this test
skip :: Test ()

-- | Record a failure at the current scope
crash :: HasCallStack => String -> Test a

-- | Overwrites the env so that note_ (the logger) is a no op
nologging :: HasCallStack => Test a -> Test a

-- | Run a test under a new scope, without logs and suppressing all output
attempt :: Test a -> Test (Maybe a)

-- | Placeholder wrapper for a failing test. The test being wrapped is
--   expected/known to fail. Will produce a failure if the test being
--   wrapped suddenly becomes a success.
pending :: HasCallStack => Test a -> Test a
putResult :: Status -> ReaderT Env IO ()

-- | Run a test in a separate thread, not blocking for its result.
fork :: Test a -> Test ()

-- | Run a test in a separate thread, return a future which can be used to
--   block on its result.
fork' :: Test a -> Test (Test a)
instance Control.Monad.Reader.Class.MonadReader EasyTest.Env EasyTest.Test
instance GHC.Base.Monad EasyTest.Test
instance Control.Monad.Fail.MonadFail EasyTest.Test
instance Control.Monad.Catch.MonadThrow EasyTest.Test
instance Control.Monad.Catch.MonadCatch EasyTest.Test
instance GHC.Base.Functor EasyTest.Test
instance GHC.Base.Applicative EasyTest.Test
instance Control.Monad.IO.Class.MonadIO EasyTest.Test
instance GHC.Base.Alternative EasyTest.Test
instance GHC.Base.MonadPlus EasyTest.Test
