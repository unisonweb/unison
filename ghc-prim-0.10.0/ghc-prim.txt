-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   This package contains the primitive types and operations supplied by
--   GHC. It is an internal package, only for the use of GHC developers.
--   GHC users should not use it! If you do use it then expect breaking
--   changes at any time without warning. You should prefer to import
--   <tt>GHC.Exts</tt> from the <tt>base</tt> package instead.
@package ghc-prim
@version 0.10.0


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data {-# CTYPE "HsBool" #-} Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data {-# CTYPE "HsChar" #-} Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data {-# CTYPE "HsInt" #-} Int
I# :: Int# -> Int

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data {-# CTYPE "HsWord" #-} Word
W# :: Word# -> Word

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data {-# CTYPE "HsFloat" #-} Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data {-# CTYPE "HsDouble" #-} Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a

-- | The builtin list type, usually written in its non-prefix form
--   <tt>[a]</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Unless the OverloadedLists extension is enabled, list literals are
--   syntactic sugar for repeated applications of <tt>:</tt> and
--   <tt>[]</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; 1:2:3:4:[] == [1,2,3,4]
--   True
--   </pre>
--   
--   Similarly, unless the OverloadedStrings extension is enabled, string
--   literals are syntactic sugar for a lists of characters.
--   
--   <pre>
--   &gt;&gt;&gt; ['h','e','l','l','o'] == "hello"
--   True
--   </pre>
data [] a

-- | Alias for <a>tagToEnum#</a>. Returns True if its parameter is 1# and
--   False if it is 0#.
isTrue# :: Int# -> Bool

-- | <a>SPEC</a> is used by GHC in the <tt>SpecConstr</tt> pass in order to
--   inform the compiler when to be particularly aggressive. In particular,
--   it tells GHC to specialize regardless of size or the number of
--   specializations. However, not all loops fall into this category.
--   
--   Libraries can specify this by using <a>SPEC</a> data type to inform
--   which loops should be aggressively specialized.
data SPEC
SPEC :: SPEC
SPEC2 :: SPEC

-- | (Kind) This is the kind of type-level symbols.
data Symbol

-- | The type constructor <a>Any</a> is type to which you can unsafely
--   coerce any lifted type, and back. More concretely, for a lifted type
--   <tt>t</tt> and value <tt>x :: t</tt>, <tt>unsafeCoerce (unsafeCoerce x
--   :: Any) :: t</tt> is equivalent to <tt>x</tt>.
type family Any :: k

-- | Lifted, homogeneous equality. By lifted, we mean that it can be bogus
--   (deferred type error). By homogeneous, the two types <tt>a</tt> and
--   <tt>b</tt> must have the same kinds.
class a ~ b
infix 4 ~

-- | Lifted, heterogeneous equality. By lifted, we mean that it can be
--   bogus (deferred type error). By heterogeneous, the two types
--   <tt>a</tt> and <tt>b</tt> might have different kinds. Because
--   <tt>~~</tt> can appear unexpectedly in error messages to users who do
--   not care about the difference between heterogeneous equality
--   <tt>~~</tt> and homogeneous equality <tt>~</tt>, this is printed as
--   <tt>~</tt> unless <tt>-fprint-equality-relations</tt> is set.
--   
--   In <tt>0.7.0</tt>, the fixity was set to <tt>infix 4</tt> to match the
--   fixity of <a>:~~:</a>.
class a ~~ b
infix 4 ~~

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible (a :: k) (b :: k)
data TYPE (a :: RuntimeRep)
data CONSTRAINT (a :: RuntimeRep)

-- | Whether a boxed type is lifted or unlifted.
data Levity
Lifted :: Levity
Unlifted :: Levity

-- | GHC maintains a property that the kind of all inhabited types (as
--   distinct from type constructors or type-level data) tells us the
--   runtime representation of values of that type. This datatype encodes
--   the choice of runtime value. Note that <a>TYPE</a> is parameterised by
--   <a>RuntimeRep</a>; this is precisely what we mean by the fact that a
--   type's kind encodes the runtime representation.
--   
--   For boxed values (that is, values that are represented by a pointer),
--   a further distinction is made, between lifted types (that contain âŠ¥),
--   and unlifted ones (that don't).
data RuntimeRep

-- | a SIMD vector type
VecRep :: VecCount -> VecElem -> RuntimeRep

-- | An unboxed tuple of the given reps
TupleRep :: [RuntimeRep] -> RuntimeRep

-- | An unboxed sum of the given reps
SumRep :: [RuntimeRep] -> RuntimeRep

-- | boxed; represented by a pointer
BoxedRep :: Levity -> RuntimeRep

-- | signed, word-sized value
IntRep :: RuntimeRep

-- | signed, 8-bit value
Int8Rep :: RuntimeRep

-- | signed, 16-bit value
Int16Rep :: RuntimeRep

-- | signed, 32-bit value
Int32Rep :: RuntimeRep

-- | signed, 64-bit value
Int64Rep :: RuntimeRep

-- | unsigned, word-sized value
WordRep :: RuntimeRep

-- | unsigned, 8-bit value
Word8Rep :: RuntimeRep

-- | unsigned, 16-bit value
Word16Rep :: RuntimeRep

-- | unsigned, 32-bit value
Word32Rep :: RuntimeRep

-- | unsigned, 64-bit value
Word64Rep :: RuntimeRep

-- | A pointer, but <i>not</i> to a Haskell value
AddrRep :: RuntimeRep

-- | a 32-bit floating point number
FloatRep :: RuntimeRep

-- | a 64-bit floating point number
DoubleRep :: RuntimeRep

-- | The runtime representation of lifted types.
type LiftedRep = 'BoxedRep 'Lifted

-- | The runtime representation of unlifted types.
type UnliftedRep = 'BoxedRep 'Unlifted

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = TYPE LiftedRep

-- | The kind of boxed, unlifted values, for example <tt>Array#</tt> or a
--   user-defined unlifted data type, using <tt>-XUnliftedDataTypes</tt>.
type UnliftedType = TYPE UnliftedRep

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | The runtime representation of a zero-width tuple, represented by no
--   bits at all
type ZeroBitRep = 'TupleRep '[]

-- | The kind of the empty unboxed tuple type (# #)
type ZeroBitType = TYPE ZeroBitRep

-- | Length of a SIMD vector type
data VecCount
Vec2 :: VecCount
Vec4 :: VecCount
Vec8 :: VecCount
Vec16 :: VecCount
Vec32 :: VecCount
Vec64 :: VecCount

-- | Element of a SIMD vector type
data VecElem
Int8ElemRep :: VecElem
Int16ElemRep :: VecElem
Int32ElemRep :: VecElem
Int64ElemRep :: VecElem
Word8ElemRep :: VecElem
Word16ElemRep :: VecElem
Word32ElemRep :: VecElem
Word64ElemRep :: VecElem
FloatElemRep :: VecElem
DoubleElemRep :: VecElem

-- | <i>Deprecated: Void# is now an alias for the unboxed tuple (# #).</i>
type Void# = (# #)

-- | Data type <tt>Dict</tt> provides a simple way to wrap up a (lifted)
--   constraint as a type
data DictBox c
[MkDictBox] :: c => DictBox c
data WordBox (a :: TYPE WordRep)
MkWordBox :: a -> WordBox (a :: TYPE WordRep)
data IntBox (a :: TYPE IntRep)
MkIntBox :: a -> IntBox (a :: TYPE IntRep)
data FloatBox (a :: TYPE FloatRep)
MkFloatBox :: a -> FloatBox (a :: TYPE FloatRep)
data DoubleBox (a :: TYPE DoubleRep)
MkDoubleBox :: a -> DoubleBox (a :: TYPE DoubleRep)
data Multiplicity
Many :: Multiplicity
One :: Multiplicity
type family MultMul (a :: Multiplicity) (b :: Multiplicity) :: Multiplicity
data Module
Module :: TrName -> TrName -> Module
data TrName

-- | Static
TrNameS :: Addr# -> TrName

-- | Dynamic
TrNameD :: [Char] -> TrName
data TyCon
TyCon :: Word64# -> Word64# -> Module -> TrName -> Int# -> KindRep -> TyCon
data TypeLitSort
TypeLitSymbol :: TypeLitSort
TypeLitNat :: TypeLitSort
TypeLitChar :: TypeLitSort

-- | The representation produced by GHC for conjuring up the kind of a
--   <a>TypeRep</a>.
data KindRep
KindRepTyConApp :: TyCon -> [KindRep] -> KindRep
KindRepVar :: !KindBndr -> KindRep
KindRepApp :: KindRep -> KindRep -> KindRep
KindRepFun :: KindRep -> KindRep -> KindRep
KindRepTYPE :: !RuntimeRep -> KindRep
KindRepTypeLitS :: TypeLitSort -> Addr# -> KindRep
KindRepTypeLitD :: TypeLitSort -> [Char] -> KindRep

-- | A de Bruijn index for a binder within a <a>KindRep</a>.
type KindBndr = Int


-- | Comparing underlying pointers for equality.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Prim.PtrEq

-- | Compare the underlying pointers of two values for equality.
--   
--   Returns <tt>1</tt> if the pointers are equal and <tt>0</tt> otherwise.
--   
--   The two values must be of the same type, of kind <tt>Type</tt>. See
--   also <a>reallyUnsafePtrEquality#</a>, which doesn't have such
--   restrictions.
reallyUnsafePtrEquality :: a -> a -> Int#

-- | Compare the underlying pointers of two unlifted values for equality.
--   
--   This is less dangerous than <a>reallyUnsafePtrEquality</a>, since the
--   arguments are guaranteed to be evaluated. This means there is no risk
--   of accidentally comparing a thunk. It's however still more dangerous
--   than e.g. <a>sameArray#</a>.
unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#

-- | Compare the underlying pointers of two arrays.
sameArray# :: Array# a -> Array# a -> Int#

-- | Compare the underlying pointers of two mutable arrays.
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#

-- | Compare the underlying pointers of two small arrays.
sameSmallArray# :: SmallArray# a -> SmallArray# a -> Int#

-- | Compare the underlying pointers of two small mutable arrays.
sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#

-- | Compare the pointers of two byte arrays.
sameByteArray# :: ByteArray# -> ByteArray# -> Int#

-- | Compare the underlying pointers of two mutable byte arrays.
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#

-- | Compare the underlying pointers of two <a>MutVar#</a>s.
sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#

-- | Compare the underlying pointers of two <a>TVar#</a>s.
sameTVar# :: TVar# s a -> TVar# s a -> Int#

-- | Compare the underlying pointers of two <a>MVar#</a>s.
sameMVar# :: MVar# s a -> MVar# s a -> Int#

-- | Compare the underlying pointers of two <a>IOPort#</a>s.
sameIOPort# :: IOPort# s a -> IOPort# s a -> Int#

-- | Compare the underlying pointers of two <a>PromptTag#</a>s.
samePromptTag# :: PromptTag# a -> PromptTag# a -> Int#

-- | Compare two stable names for equality.
eqStableName# :: StableName# a -> StableName# b -> Int#


-- | Extra C-- routines exposed from the RTS
--   
--   Users should not import this module. It is GHC internal only. Use
--   <a>GHC.Conc</a> instead.
--   
--   Actual primops are emitted by the compiler itself. They are special
--   bits of code with backend support. The foreign functions in this
--   module aren't actual primops because the compiler doesn't care about
--   them at all: they just are extra foreign C-- calls libraries can make
--   into the RTS.
--   
--   Note that <a>Prim</a> has the same haddock section names as this
--   module, but with descriptions. Consult that module's documentation for
--   what each section means. are described over there.
module GHC.Prim.Ext

-- | Retrieves the allocation counter for the current thread.
getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)


-- | Primitive exceptions.
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Prim.Exception

-- | Raise <a>overflowException</a>
raiseOverflow :: a

-- | Raise <a>underflowException</a>
raiseUnderflow :: a

-- | Raise <a>divZeroException</a>
raiseDivZero :: a


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim
data Char#
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
data Int8#
int8ToInt# :: Int8# -> Int#
intToInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt8# :: Int8# -> Int8# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
int8ToWord8# :: Int8# -> Word8#
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
data Word8#
word8ToWord# :: Word8# -> Word#
wordToWord8# :: Word# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord8# :: Word8# -> Word8# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
andWord8# :: Word8# -> Word8# -> Word8#
orWord8# :: Word8# -> Word8# -> Word8#
xorWord8# :: Word8# -> Word8# -> Word8#
notWord8# :: Word8# -> Word8#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
word8ToInt8# :: Word8# -> Int8#
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
data Int16#
int16ToInt# :: Int16# -> Int#
intToInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt16# :: Int16# -> Int16# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
int16ToWord16# :: Int16# -> Word16#
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
data Word16#
word16ToWord# :: Word16# -> Word#
wordToWord16# :: Word# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord16# :: Word16# -> Word16# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
andWord16# :: Word16# -> Word16# -> Word16#
orWord16# :: Word16# -> Word16# -> Word16#
xorWord16# :: Word16# -> Word16# -> Word16#
notWord16# :: Word16# -> Word16#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
word16ToInt16# :: Word16# -> Int16#
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
data Int32#
int32ToInt# :: Int32# -> Int#
intToInt32# :: Int# -> Int32#
negateInt32# :: Int32# -> Int32#
plusInt32# :: Int32# -> Int32# -> Int32#
subInt32# :: Int32# -> Int32# -> Int32#
timesInt32# :: Int32# -> Int32# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt32# :: Int32# -> Int32# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt32# :: Int32# -> Int32# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
int32ToWord32# :: Int32# -> Word32#
eqInt32# :: Int32# -> Int32# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
data Word32#
word32ToWord# :: Word32# -> Word#
wordToWord32# :: Word# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
subWord32# :: Word32# -> Word32# -> Word32#
timesWord32# :: Word32# -> Word32# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord32# :: Word32# -> Word32# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord32# :: Word32# -> Word32# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
andWord32# :: Word32# -> Word32# -> Word32#
orWord32# :: Word32# -> Word32# -> Word32#
xorWord32# :: Word32# -> Word32# -> Word32#
notWord32# :: Word32# -> Word32#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
word32ToInt32# :: Word32# -> Int32#
eqWord32# :: Word32# -> Word32# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
data Int64#
int64ToInt# :: Int64# -> Int#
intToInt64# :: Int# -> Int64#
negateInt64# :: Int64# -> Int64#
plusInt64# :: Int64# -> Int64# -> Int64#
subInt64# :: Int64# -> Int64# -> Int64#
timesInt64# :: Int64# -> Int64# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt64# :: Int64# -> Int64# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt64# :: Int64# -> Int64# -> Int64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
int64ToWord64# :: Int64# -> Word64#
eqInt64# :: Int64# -> Int64# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
data Word64#
word64ToWord# :: Word64# -> Word#
wordToWord64# :: Word# -> Word64#
plusWord64# :: Word64# -> Word64# -> Word64#
subWord64# :: Word64# -> Word64# -> Word64#
timesWord64# :: Word64# -> Word64# -> Word64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord64# :: Word64# -> Word64# -> Word64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord64# :: Word64# -> Word64# -> Word64#
and64# :: Word64# -> Word64# -> Word64#
or64# :: Word64# -> Word64# -> Word64#
xor64# :: Word64# -> Word64# -> Word64#
not64# :: Word64# -> Word64#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
word64ToInt64# :: Word64# -> Int64#
eqWord64# :: Word64# -> Word64# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
data Int#
(+#) :: Int# -> Int# -> Int#
infixl 6 +#
(-#) :: Int# -> Int# -> Int#
infixl 6 -#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#
infixl 7 *#

-- | Return a triple (isHighNeeded,high,low) where high and low are
--   respectively the high and low bits of the double-word result.
--   isHighNeeded is a cheap way to test if the high word is a
--   sign-extension of the low word (isHighNeeded = 0#) or not
--   (isHighNeeded = 1#).
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero. The behavior is undefined if the second argument
--   is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(<a>quotInt#</a> x y) <a>*#</a> y <a>+#</a>
--   (<a>remInt#</a> x y) == x</tt>. The behavior is undefined if the
--   second argument is zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
remInt# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)

-- | Bitwise "and".
andI# :: Int# -> Int# -> Int#

-- | Bitwise "or".
orI# :: Int# -> Int# -> Int#

-- | Bitwise "xor".
xorI# :: Int# -> Int# -> Int#

-- | Bitwise "not", also known as the binary complement.
notI# :: Int# -> Int#

-- | Unary negation. Since the negative <a>Int#</a> range extends one
--   further than the positive range, <a>negateInt#</a> of the most
--   negative number is an identity operation. This way, <a>negateInt#</a>
--   is always its own inverse.
negateInt# :: Int# -> Int#

-- | Add signed integers reporting overflow. First member of result is the
--   sum truncated to an <a>Int#</a>; second member is zero if the true sum
--   fits in an <a>Int#</a>, nonzero if overflow occurred (the sum is
--   either too large or too small to fit in an <a>Int#</a>).
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract signed integers reporting overflow. First member of result is
--   the difference truncated to an <a>Int#</a>; second member is zero if
--   the true difference fits in an <a>Int#</a>, nonzero if overflow
--   occurred (the difference is either too large or too small to fit in an
--   <a>Int#</a>).
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
infix 4 >#
(>=#) :: Int# -> Int# -> Int#
infix 4 >=#
(==#) :: Int# -> Int# -> Int#
infix 4 ==#
(/=#) :: Int# -> Int# -> Int#
infix 4 /=#
(<#) :: Int# -> Int# -> Int#
infix 4 <#
(<=#) :: Int# -> Int# -> Int#
infix 4 <=#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#

-- | Convert an <a>Int#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Float#</a> 1# == 1.0#</tt>
int2Float# :: Int# -> Float#

-- | Convert an <a>Int#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>int2Double#</a> 1# == 1.0##</tt>
int2Double# :: Int# -> Double#

-- | Convert an <a>Word#</a> to the corresponding <a>Float#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Float#</a> 1## == 1.0#</tt>
word2Float# :: Word# -> Float#

-- | Convert an <a>Word#</a> to the corresponding <a>Double#</a> with the
--   same integral value (up to truncation due to floating-point
--   precision). e.g. <tt><a>word2Double#</a> 1## == 1.0##</tt>
word2Double# :: Word# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Word#
plusWord# :: Word# -> Word# -> Word#

-- | Add unsigned integers reporting overflow. The first element of the
--   pair is the result. The second element is the carry flag, which is
--   nonzero on overflow. See also <a>plusWord2#</a>.
addWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Subtract unsigned integers reporting overflow. The first element of
--   the pair is the result. The second element is the carry flag, which is
--   nonzero on overflow.
subWordC# :: Word# -> Word# -> (# Word#, Int# #)

-- | Add unsigned integers, with the high part (carry) in the first
--   component of the returned pair and the low part in the second
--   component of the pair. See also <a>addWordC#</a>.
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotWord# :: Word# -> Word# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
remWord# :: Word# -> Word# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)

-- | Takes high word of dividend, then low word of dividend, then divisor.
--   Requires that high word &lt; divisor.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#

-- | Deposit bits to lower 8 bits of a word at locations specified by a
--   mask.
pdep8# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 16 bits of a word at locations specified by a
--   mask.
pdep16# :: Word# -> Word# -> Word#

-- | Deposit bits to lower 32 bits of a word at locations specified by a
--   mask.
pdep32# :: Word# -> Word# -> Word#

-- | Deposit bits to a word at locations specified by a mask.
pdep64# :: Word64# -> Word64# -> Word64#

-- | Deposit bits to a word at locations specified by a mask.
pdep# :: Word# -> Word# -> Word#

-- | Extract bits from lower 8 bits of a word at locations specified by a
--   mask.
pext8# :: Word# -> Word# -> Word#

-- | Extract bits from lower 16 bits of a word at locations specified by a
--   mask.
pext16# :: Word# -> Word# -> Word#

-- | Extract bits from lower 32 bits of a word at locations specified by a
--   mask.
pext32# :: Word# -> Word# -> Word#

-- | Extract bits from a word at locations specified by a mask.
pext64# :: Word64# -> Word64# -> Word64#

-- | Extract bits from a word at locations specified by a mask.
pext# :: Word# -> Word# -> Word#

-- | Count leading zeros in the lower 8 bits of a word.
clz8# :: Word# -> Word#

-- | Count leading zeros in the lower 16 bits of a word.
clz16# :: Word# -> Word#

-- | Count leading zeros in the lower 32 bits of a word.
clz32# :: Word# -> Word#

-- | Count leading zeros in a 64-bit word.
clz64# :: Word64# -> Word#

-- | Count leading zeros in a word.
clz# :: Word# -> Word#

-- | Count trailing zeros in the lower 8 bits of a word.
ctz8# :: Word# -> Word#

-- | Count trailing zeros in the lower 16 bits of a word.
ctz16# :: Word# -> Word#

-- | Count trailing zeros in the lower 32 bits of a word.
ctz32# :: Word# -> Word#

-- | Count trailing zeros in a 64-bit word.
ctz64# :: Word64# -> Word#

-- | Count trailing zeros in a word.
ctz# :: Word# -> Word#

-- | Swap bytes in the lower 16 bits of a word. The higher bytes are
--   undefined.
byteSwap16# :: Word# -> Word#

-- | Swap bytes in the lower 32 bits of a word. The higher bytes are
--   undefined.
byteSwap32# :: Word# -> Word#

-- | Swap bytes in a 64 bits of a word.
byteSwap64# :: Word64# -> Word64#

-- | Swap bytes in a word.
byteSwap# :: Word# -> Word#

-- | Reverse the order of the bits in a 8-bit word.
bitReverse8# :: Word# -> Word#

-- | Reverse the order of the bits in a 16-bit word.
bitReverse16# :: Word# -> Word#

-- | Reverse the order of the bits in a 32-bit word.
bitReverse32# :: Word# -> Word#

-- | Reverse the order of the bits in a 64-bit word.
bitReverse64# :: Word64# -> Word64#

-- | Reverse the order of the bits in a word.
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Double#
(>##) :: Double# -> Double# -> Int#
infix 4 >##
(>=##) :: Double# -> Double# -> Int#
infix 4 >=##
(==##) :: Double# -> Double# -> Int#
infix 4 ==##
(/=##) :: Double# -> Double# -> Int#
infix 4 /=##
(<##) :: Double# -> Double# -> Int#
infix 4 <##
(<=##) :: Double# -> Double# -> Int#
infix 4 <=##
(+##) :: Double# -> Double# -> Double#
infixl 6 +##
(-##) :: Double# -> Double# -> Double#
infixl 6 -##
(*##) :: Double# -> Double# -> Double#
infixl 7 *##

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
(/##) :: Double# -> Double# -> Double#
infixl 7 /##
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#

-- | Truncates a <a>Double#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinDouble# :: Double# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)

-- | Decode <a>Double#</a> into mantissa and base-2 exponent.
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
data Float#
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#

-- | Truncates a <a>Float#</a> value to the nearest <a>Int#</a>. Results
--   are undefined if the truncation if truncation yields a value outside
--   the range of <a>Int#</a>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
logFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
asinFloat# :: Float# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <a>Int#</a> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
data Array# a
data MutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: Int# -> v -> State# s -> (# State# s, MutableArray# s v #)

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readArray# :: MutableArray# s v -> Int# -> State# s -> (# State# s, v #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeArray# :: MutableArray# s v -> Int# -> v -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofArray# :: Array# v -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: MutableArray# s v -> Int#

-- | Read from the specified index of an immutable array. The result is
--   packaged into an unboxed unary tuple; the result itself is not yet
--   evaluated. Pattern matching on the tuple forces the indexing of the
--   array to happen but does not evaluate the element itself. Evaluating
--   the thunk prevents additional thunks from building up on the heap.
--   Avoiding these thunks, in turn, reduces references to the argument
--   array, allowing it to be garbage collected more promptly.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexArray# :: Array# v -> Int# -> (# v #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: MutableArray# s v -> State# s -> (# State# s, Array# v #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: Array# v -> State# s -> (# State# s, MutableArray# s v #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyArray# :: Array# v -> Int# -> MutableArray# s v -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. In the case where the source and destination are the
--   same array the source and destination regions may overlap.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableArray# :: MutableArray# s v -> Int# -> MutableArray# s v -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneArray# :: Array# v -> Int# -> Int# -> Array# v

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneMutableArray# :: MutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s v #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeArray# :: MutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, Array# v #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawArray# :: Array# v -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s v #)

-- | Given an array, an offset, the expected old value, and the new value,
--   perform an atomic compare and swap (i.e. write the new value if the
--   current value and the old value are the same pointer). Returns 0 if
--   the swap succeeds and 1 if it fails. Additionally, returns the element
--   at the offset after the operation completes. This means that on a
--   success the new value is returned, and on a failure the actual old
--   value (not the expected one) is returned. Implies a full memory
--   barrier. The use of a pointer equality on a boxed value makes this
--   function harder to use correctly than <a>casIntArray#</a>. All of the
--   difficulties of using <a>reallyUnsafePtrEquality#</a> correctly apply
--   to <a>casArray#</a> as well.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casArray# :: MutableArray# s v -> Int# -> v -> v -> State# s -> (# State# s, Int#, v #)
data SmallArray# a
data SmallMutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newSmallArray# :: Int# -> v -> State# s -> (# State# s, SmallMutableArray# s v #)

-- | Shrink mutable array to new specified size, in the specified state
--   thread. The new size argument must be less than or equal to the
--   current size as reported by <a>getSizeofSmallMutableArray#</a>.
shrinkSmallMutableArray# :: SmallMutableArray# s v -> Int# -> State# s -> State# s

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readSmallArray# :: SmallMutableArray# s v -> Int# -> State# s -> (# State# s, v #)

-- | Write to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeSmallArray# :: SmallMutableArray# s v -> Int# -> v -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofSmallArray# :: SmallArray# v -> Int#

-- | Return the number of elements in the array. Note that this is
--   deprecated as it is unsafe in the presence of shrink and resize
--   operations on the same small mutable array.

-- | <i>Deprecated: Use <a>getSizeofSmallMutableArray#</a> instead </i>
sizeofSmallMutableArray# :: SmallMutableArray# s v -> Int#

-- | Return the number of elements in the array.
getSizeofSmallMutableArray# :: SmallMutableArray# s v -> State# s -> (# State# s, Int# #)

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexSmallArray# :: SmallArray# v -> Int# -> (# v #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeSmallArray# :: SmallMutableArray# s v -> State# s -> (# State# s, SmallArray# v #)

-- | Make an immutable array mutable, without copying.
unsafeThawSmallArray# :: SmallArray# v -> State# s -> (# State# s, SmallMutableArray# s v #)

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. Both arrays must fully contain the specified ranges, but this
--   is not checked. The two arrays must not be the same array in different
--   states, but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallArray# :: SmallArray# v -> Int# -> SmallMutableArray# s v -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, a destination
--   array, an offset into the destination array, and a number of elements
--   to copy, copy the elements from the source array to the destination
--   array. The source and destination arrays can refer to the same array.
--   Both arrays must fully contain the specified ranges, but this is not
--   checked. The regions are allowed to overlap, although this is only
--   possible when the same array is provided as both the source and the
--   destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copySmallMutableArray# :: SmallMutableArray# s v -> Int# -> SmallMutableArray# s v -> Int# -> Int# -> State# s -> State# s

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallArray# :: SmallArray# v -> Int# -> Int# -> SmallArray# v

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
cloneSmallMutableArray# :: SmallMutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s v #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
freezeSmallArray# :: SmallMutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, SmallArray# v #)

-- | Given a source array, an offset into the source array, and a number of
--   elements to copy, create a new array with the elements from the source
--   array. The provided array must fully contain the specified range, but
--   this is not checked.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
thawSmallArray# :: SmallArray# v -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s v #)

-- | Unsafe, machine-level atomic compare and swap on an element within an
--   array. See the documentation of <a>casArray#</a>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casSmallArray# :: SmallMutableArray# s v -> Int# -> v -> v -> State# s -> (# State# s, Int#, v #)

-- | A boxed, unlifted datatype representing a region of raw memory in the
--   garbage-collected heap, which is not scanned for pointers during
--   garbage collection.
--   
--   It is created by freezing a <a>MutableByteArray#</a> with
--   <a>unsafeFreezeByteArray#</a>. Freezing is essentially a no-op, as
--   <a>MutableByteArray#</a> and <a>ByteArray#</a> share the same heap
--   structure under the hood.
--   
--   The immutable and mutable variants are commonly used for scenarios
--   requiring high-performance data structures, like <tt>Text</tt>,
--   <tt>Primitive Vector</tt>, <tt>Unboxed Array</tt>, and
--   <tt>ShortByteString</tt>.
--   
--   Another application of fundamental importance is <tt>Integer</tt>,
--   which is backed by <a>ByteArray#</a>.
--   
--   The representation on the heap of a Byte Array is:
--   
--   <pre>
--   +------------+-----------------+-----------------------+
--   |            |                 |                       |
--   |   HEADER   | SIZE (in bytes) |       PAYLOAD         |
--   |            |                 |                       |
--   +------------+-----------------+-----------------------+
--   </pre>
--   
--   To obtain a pointer to actual payload (e.g., for FFI purposes) use
--   <a>byteArrayContents#</a> or <a>mutableByteArrayContents#</a>.
--   
--   Alternatively, enabling the <tt>UnliftedFFITypes</tt> extension allows
--   to mention <a>ByteArray#</a> and <a>MutableByteArray#</a> in FFI type
--   signatures directly.
data ByteArray#

-- | A mutable <tt>ByteAray#</tt>. It can be created in three ways:
--   
--   <ul>
--   <li><a>newByteArray#</a>: Create an unpinned array.</li>
--   <li><a>newPinnedByteArray#</a>: This will create a pinned array,</li>
--   <li><a>newAlignedPinnedByteArray#</a>: This will create a pinned
--   array, with a custom alignment.</li>
--   </ul>
--   
--   Unpinned arrays can be moved around during garbage collection, so you
--   must not store or pass pointers to these values if there is a chance
--   for the garbage collector to kick in. That said, even unpinned arrays
--   can be passed to unsafe FFI calls, because no garbage collection
--   happens during these unsafe calls (see <a>Guaranteed Call Safety</a>
--   in the GHC Manual). For safe FFI calls, byte arrays must be not only
--   pinned, but also kept alive by means of the keepAlive# function for
--   the duration of a call (that's because garbage collection cannot move
--   a pinned array, but is free to scrap it altogether).
data MutableByteArray# s

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread. The size of the memory underlying the array
--   will be rounded up to the platform's word size.
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Like <a>newByteArray#</a> but GC guarantees not to move it.
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Like <a>newPinnedByteArray#</a> but allow specifying an arbitrary
--   alignment, which must be a power of two.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Determine whether a <a>MutableByteArray#</a> is guaranteed not to move
--   during GC.
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#

-- | Determine whether a <a>ByteArray#</a> is guaranteed not to move during
--   GC.
isByteArrayPinned# :: ByteArray# -> Int#

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#

-- | Intended for use with pinned arrays; otherwise very unsafe!
mutableByteArrayContents# :: MutableByteArray# s -> Addr#

-- | Shrink mutable byte array to new specified size (in bytes), in the
--   specified state thread. The new size argument must be less than or
--   equal to the current size as reported by
--   <a>getSizeofMutableByteArray#</a>.
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s

-- | Resize (unpinned) mutable byte array to new specified size (in bytes).
--   The returned <a>MutableByteArray#</a> is either the original
--   <a>MutableByteArray#</a> resized in-place or, if not possible, a newly
--   allocated (unpinned) <a>MutableByteArray#</a> (with the original
--   content copied over).
--   
--   To avoid undefined behaviour, the original <a>MutableByteArray#</a>
--   shall not be accessed anymore after a <a>resizeMutableByteArray#</a>
--   has been performed. Moreover, no reference to the old one should be
--   kept in order to allow garbage collection of the original
--   <a>MutableByteArray#</a> in case a new <a>MutableByteArray#</a> had to
--   be allocated.
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes. Note that this is deprecated as
--   it is unsafe in the presence of shrink and resize operations on the
--   same mutable byte array.

-- | <i>Deprecated: Use <a>getSizeofMutableByteArray#</a> instead </i>
sizeofMutableByteArray# :: MutableByteArray# s -> Int#

-- | Return the number of elements in the array.
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharArray# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntArray# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordArray# :: ByteArray# -> Int# -> Word#

-- | Read a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrArray# :: ByteArray# -> Int# -> Addr#

-- | Read a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatArray# :: ByteArray# -> Int# -> Float#

-- | Read a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleArray# :: ByteArray# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8Array# :: ByteArray# -> Int# -> Int8#

-- | Read a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16Array# :: ByteArray# -> Int# -> Int16#

-- | Read a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32Array# :: ByteArray# -> Int# -> Int32#

-- | Read a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64Array# :: ByteArray# -> Int# -> Int64#

-- | Read a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8Array# :: ByteArray# -> Int# -> Word8#

-- | Read a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16Array# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32Array# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#

-- | Read a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#

-- | Read a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#

-- | Read a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#

-- | Read a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#

-- | Read a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#

-- | Read a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#

-- | Read a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a

-- | Read a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#

-- | Read a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#

-- | Read a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#

-- | Read a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#

-- | Read a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#

-- | Read a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Read a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | Read a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)

-- | Read a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)

-- | Read a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)

-- | Read a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | Read a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8# #)

-- | Read a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)

-- | Read a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)

-- | Read a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)

-- | Read a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8# #)

-- | Read a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)

-- | Read a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)

-- | Read a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)

-- | Read a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Read a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)

-- | Read a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)

-- | Read a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)

-- | Read a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)

-- | Read a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | Read a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)

-- | Read a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)

-- | Read a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)

-- | Read a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)

-- | Read a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)

-- | Read a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)

-- | Write a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write a 32-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write a word-sized integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Write a word-sized unsigned integer; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | Write a machine address; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s

-- | Write a single-precision floating-point value; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s

-- | Write a double-precision floating-point value; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s

-- | Write a <a>StablePtr#</a> value; offset in machine words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s

-- | Write a 8-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> State# s -> State# s

-- | Write a 16-bit signed integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s

-- | Write a 32-bit signed integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s

-- | Write a 64-bit signed integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s

-- | Write a 8-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8Array# :: MutableByteArray# s -> Int# -> Word8# -> State# s -> State# s

-- | Write a 16-bit unsigned integer; offset in 2-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16Array# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s

-- | Write a 32-bit unsigned integer; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32Array# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s

-- | Write a 64-bit unsigned integer; offset in 8-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64Array# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s

-- | Write a 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write a 32-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write a word-sized integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Write a word-sized unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s

-- | Write a machine address; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s

-- | Write a single-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s

-- | Write a double-precision floating-point value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s

-- | Write a <a>StablePtr#</a> value; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s

-- | Write a 16-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s

-- | Write a 32-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s

-- | Write a 64-bit signed integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s

-- | Write a 16-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s

-- | Write a 32-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s

-- | Write a 64-bit unsigned integer; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s

-- | <tt><a>compareByteArrays#</a> src1 src1_ofs src2 src2_ofs n</tt>
--   compares <tt>n</tt> bytes starting at offset <tt>src1_ofs</tt> in the
--   first <a>ByteArray#</a> <tt>src1</tt> to the range of <tt>n</tt> bytes
--   (i.e. same length) starting at offset <tt>src2_ofs</tt> of the second
--   <a>ByteArray#</a> <tt>src2</tt>. Both arrays must fully contain the
--   specified ranges, but this is not checked. Returns an <a>Int#</a> less
--   than, equal to, or greater than zero if the range is found,
--   respectively, to be byte-wise lexicographically less than, to match,
--   or be greater than the second range.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#

-- | <tt><a>copyByteArray#</a> src src_ofs dst dst_ofs n</tt> copies the
--   range starting at offset <tt>src_ofs</tt> of length <tt>n</tt> from
--   the <a>ByteArray#</a> <tt>src</tt> to the <a>MutableByteArray#</a>
--   <tt>dst</tt> starting at offset <tt>dst_ofs</tt>. Both arrays must
--   fully contain the specified ranges, but this is not checked. The two
--   arrays must not be the same array in different states, but this is not
--   checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableByteArray# to the specified region in
--   the second MutableByteArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked. The regions are allowed to
--   overlap, although this is only possible when the same array is
--   provided as both the source and the destination.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the ByteArray# to the memory range starting at the
--   Addr#. The ByteArray# and the memory region at Addr# must fully
--   contain the specified ranges, but this is not checked. The Addr# must
--   not point into the ByteArray# (e.g. if the ByteArray# were pinned),
--   but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a range of the MutableByteArray# to the memory range starting at
--   the Addr#. The MutableByteArray# and the memory region at Addr# must
--   fully contain the specified ranges, but this is not checked. The Addr#
--   must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s

-- | Copy a memory range starting at the Addr# to the specified range in
--   the MutableByteArray#. The memory region at Addr# and the ByteArray#
--   must fully contain the specified ranges, but this is not checked. The
--   Addr# must not point into the MutableByteArray# (e.g. if the
--   MutableByteArray# were pinned), but this is not checked either.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | <tt><a>setByteArray#</a> ba off len c</tt> sets the byte range
--   <tt>[off, off+len)</tt> of the <a>MutableByteArray#</a> to the byte
--   <tt>c</tt>.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s

-- | Given an array and an offset in machine words, read an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array and an offset in machine words, write an element. The
--   index is assumed to be in bounds. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Given an array, an offset in machine words, the expected old value,
--   and the new value, perform an atomic compare and swap i.e. write the
--   new value if the current value matches the provided old value. Returns
--   the value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, an offset in bytes, the expected old value, and the
--   new value, perform an atomic compare and swap i.e. write the new value
--   if the current value matches the provided old value. Returns the value
--   of the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> Int8# -> State# s -> (# State# s, Int8# #)

-- | Given an array, an offset in 16 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> Int16# -> State# s -> (# State# s, Int16# #)

-- | Given an array, an offset in 32 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> Int32# -> State# s -> (# State# s, Int32# #)

-- | Given an array, an offset in 64 bit units, the expected old value, and
--   the new value, perform an atomic compare and swap i.e. write the new
--   value if the current value matches the provided old value. Returns the
--   value of the element before the operation. Implies a full memory
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
casInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> Int64# -> State# s -> (# State# s, Int64# #)

-- | Given an array, and offset in machine words, and a value to add,
--   atomically add the value to the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to subtract,
--   atomically subtract the value from the element. Returns the value of
--   the element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to AND,
--   atomically AND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to NAND,
--   atomically NAND the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to OR,
--   atomically OR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | Given an array, and offset in machine words, and a value to XOR,
--   atomically XOR the value into the element. Returns the value of the
--   element before the operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr#

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <a>Addr#</a>s are so far apart that their
--   difference doesn't fit in an <a>Int#</a>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <a>Addr#</a> arg, treated like an
--   <a>Int#</a>, is divided by the <a>Int#</a> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int.

-- | <i>Deprecated: This operation is strongly deprecated. </i>
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address.

-- | <i>Deprecated: This operation is strongly deprecated. </i>
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexIntOffAddr# :: Addr# -> Int# -> Int#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWordOffAddr# :: Addr# -> Int# -> Word#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexAddrOffAddr# :: Addr# -> Int# -> Addr#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexFloatOffAddr# :: Addr# -> Int# -> Float#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexDoubleOffAddr# :: Addr# -> Int# -> Double#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt8OffAddr# :: Addr# -> Int# -> Int8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt16OffAddr# :: Addr# -> Int# -> Int16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt32OffAddr# :: Addr# -> Int# -> Int32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexInt64OffAddr# :: Addr# -> Int# -> Int64#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord8OffAddr# :: Addr# -> Int# -> Word8#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord16OffAddr# :: Addr# -> Int# -> Word16#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord32OffAddr# :: Addr# -> Int# -> Word32#

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | Reads 8-bit character; offset in bytes.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# s -> State# s

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# s -> State# s

-- | The atomic exchange operation. Atomically exchanges the value at the
--   first address with the Addr# given as second argument. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# s -> (# State# s, Addr# #)

-- | The atomic exchange operation. Atomically exchanges the value at the
--   address with the given value. Returns the old value. Implies a read
--   barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicExchangeWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Compare and swap on a word-sized memory location.
--   
--   Use as: s -&gt; atomicCasAddrAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# s -> (# State# s, Addr# #)

-- | Compare and swap on a word-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# s -> (# State# s, Word# #)

-- | Compare and swap on a 8 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr8# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# s -> (# State# s, Word8# #)

-- | Compare and swap on a 16 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr16# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# s -> (# State# s, Word16# #)

-- | Compare and swap on a 32 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr32# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# s -> (# State# s, Word32# #)

-- | Compare and swap on a 64 bit-sized and aligned memory location.
--   
--   Use as: s -&gt; atomicCasWordAddr64# location expected desired s
--   
--   This version always returns the old value read. This follows the
--   normal protocol for CAS operations (and matches the underlying
--   instruction on most architectures).
--   
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# s -> (# State# s, Word64# #)

-- | Given an address, and a value to add, atomically add the value to the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAddWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, and a value to subtract, atomically subtract the
--   value from the element. Returns the value of the element before the
--   operation. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchSubWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, and a value to AND, atomically AND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchAndWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, and a value to NAND, atomically NAND the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchNandWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, and a value to OR, atomically OR the value into the
--   element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchOrWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, and a value to XOR, atomically XOR the value into
--   the element. Returns the value of the element before the operation.
--   Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
fetchXorWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)

-- | Given an address, read a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicReadWordAddr# :: Addr# -> State# s -> (# State# s, Word# #)

-- | Given an address, write a machine word. Implies a full memory barrier.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicWriteWordAddr# :: Addr# -> Word# -> State# s -> State# s

-- | A <a>MutVar#</a> behaves like a single-element mutable array.
data MutVar# s a

-- | Create <a>MutVar#</a> with specified initial value in specified state
--   thread.
newMutVar# :: v -> State# s -> (# State# s, MutVar# s v #)

-- | Read contents of <a>MutVar#</a>. Result is not yet evaluated.
readMutVar# :: MutVar# s v -> State# s -> (# State# s, v #)

-- | Write contents of <a>MutVar#</a>.
writeMutVar# :: MutVar# s v -> v -> State# s -> State# s

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents. Note that this isn't strictly speaking the correct type for
--   this function; it should really be <tt><a>MutVar#</a> s a -&gt; (a
--   -&gt; (a,b)) -&gt; <a>State#</a> s -&gt; (# <a>State#</a> s, a, (a, b)
--   #)</tt>, but we don't know about pairs here.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s, a, c #)

-- | Modify the contents of a <a>MutVar#</a>, returning the previous
--   contents and the result of applying the given function to the previous
--   contents.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s, a, a #)

-- | Compare-and-swap: perform a pointer equality test between the first
--   value passed to this function and the value stored inside the
--   <a>MutVar#</a>. If the pointers are equal, replace the stored value
--   with the second value passed to this function, otherwise do nothing.
--   Returns the final value stored inside the <a>MutVar#</a>. The
--   <a>Int#</a> indicates whether a swap took place, with <tt>1#</tt>
--   meaning that we didn't swap, and <tt>0#</tt> that we did. Implies a
--   full memory barrier. Because the comparison is done on the level of
--   pointers, all of the difficulties of using
--   <a>reallyUnsafePtrEquality#</a> correctly apply to <a>casMutVar#</a>
--   as well.
casMutVar# :: MutVar# s v -> v -> v -> State# s -> (# State# s, Int#, v #)

-- | <tt><a>catch#</a> k handler s</tt> evaluates <tt>k s</tt>, invoking
--   <tt>handler</tt> on any exceptions thrown.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
catch# :: (State# RealWorld -> (# State# RealWorld, o #)) -> (w -> State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raise# :: v -> p

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseUnderflow# :: (# #) -> p

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseOverflow# :: (# #) -> p

-- | <b><i>Warning:</i></b> this can fail with an unchecked exception.
raiseDivZero# :: (# #) -> p
raiseIO# :: v -> State# RealWorld -> (# State# RealWorld, p #)

-- | <tt><a>maskAsyncExceptions#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)

-- | <tt><a>maskUninterruptible#</a> k s</tt> evaluates <tt>k s</tt> such
--   that asynchronous exceptions are deferred until after evaluation has
--   finished.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)

-- | <tt><tt>unmaskAsyncUninterruptible#</tt> k s</tt> evaluates <tt>k
--   s</tt> such that asynchronous exceptions are unmasked.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)

-- | See <a>GHC.Prim#continuations</a>.
data PromptTag# a

-- | See <a>GHC.Prim#continuations</a>.
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)

-- | See <a>GHC.Prim#continuations</a>.
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)

-- | See <a>GHC.Prim#continuations</a>.
control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, p #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, p #)
data TVar# s a
atomically# :: (State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)
retry# :: State# RealWorld -> (# State# RealWorld, v #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, v #)) -> (State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, v #)) -> (b -> State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)

-- | Create a new <a>TVar#</a> holding a specified initial value.
newTVar# :: v -> State# s -> (# State# s, TVar# s v #)

-- | Read contents of <a>TVar#</a> inside an STM transaction, i.e. within a
--   call to <a>atomically#</a>. Does not force evaluation of the result.
readTVar# :: TVar# s v -> State# s -> (# State# s, v #)

-- | Read contents of <a>TVar#</a> outside an STM transaction. Does not
--   force evaluation of the result.
readTVarIO# :: TVar# s v -> State# s -> (# State# s, v #)

-- | Write contents of <a>TVar#</a>.
writeTVar# :: TVar# s v -> v -> State# s -> State# s

-- | A shared mutable variable (<i>not</i> the same as a <a>MutVar#</a>!).
--   (Note: in a non-concurrent implementation, <tt>(<a>MVar#</a> a)</tt>
--   can be represented by <tt>(<a>MutVar#</a> (Maybe a))</tt>.)
data MVar# s a

-- | Create new <a>MVar#</a>; initially empty.
newMVar# :: State# s -> (# State# s, MVar# s v #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then remove and
--   return its contents, and set it empty.
takeMVar# :: MVar# s v -> State# s -> (# State# s, v #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>, and set <a>MVar#</a> empty.
tryTakeMVar# :: MVar# s v -> State# s -> (# State# s, Int#, v #)

-- | If <a>MVar#</a> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: MVar# s v -> v -> State# s -> State# s

-- | If <a>MVar#</a> is full, immediately return with integer 0. Otherwise,
--   store value arg as 'MVar#''s new contents, and return with integer 1.
tryPutMVar# :: MVar# s v -> v -> State# s -> (# State# s, Int# #)

-- | If <a>MVar#</a> is empty, block until it becomes full. Then read its
--   contents without modifying the MVar, without possibility of
--   intervention from other threads.
readMVar# :: MVar# s v -> State# s -> (# State# s, v #)

-- | If <a>MVar#</a> is empty, immediately return with integer 0 and value
--   undefined. Otherwise, return with integer 1 and contents of
--   <a>MVar#</a>.
tryReadMVar# :: MVar# s v -> State# s -> (# State# s, Int#, v #)

-- | Return 1 if <a>MVar#</a> is empty; 0 otherwise.
isEmptyMVar# :: MVar# s v -> State# s -> (# State# s, Int# #)

-- | A shared I/O port is almost the same as an <a>MVar#</a>. The main
--   difference is that IOPort has no deadlock detection or deadlock
--   breaking code that forcibly releases the lock.
data IOPort# s a

-- | Create new <a>IOPort#</a>; initially empty.
newIOPort# :: State# s -> (# State# s, IOPort# s v #)

-- | If <a>IOPort#</a> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty. Throws an
--   <tt>IOPortException</tt> if another thread is already waiting to read
--   this <a>IOPort#</a>.
readIOPort# :: IOPort# s v -> State# s -> (# State# s, v #)

-- | If <a>IOPort#</a> is full, immediately return with integer 0, throwing
--   an <tt>IOPortException</tt>. Otherwise, store value arg as 'IOPort#''s
--   new contents, and return with integer 1.
writeIOPort# :: IOPort# s v -> v -> State# s -> (# State# s, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# s -> State# s

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# s -> State# s

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# s -> State# s

-- | <a>State#</a> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt><a>State#</a> <a>RealWorld</a></tt>, or
--   <tt><a>State#</a> s</tt>, where s is a type variable. The only purpose
--   of the type parameter is to keep different state threads separate. It
--   is represented by nothing at all.
data State# s

-- | <a>RealWorld</a> is deeply magical. It is <i>primitive</i>, but it is
--   not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <a>RealWorld</a>; it's only used in the type system, to
--   parameterise <a>State#</a>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <a>myThreadId#</a>. The other
--   operations can be omitted.)
data ThreadId#
fork# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)

-- | Set the label of the given thread. The <tt>ByteArray#</tt> should
--   contain a UTF-8-encoded string.
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s

-- | Get the label of the given thread. Morally of type <tt>ThreadId# -&gt;
--   IO (Maybe ByteArray#)</tt>, with a <tt>1#</tt> tag denoting
--   <tt>Just</tt>.
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)

-- | Get the status of the given thread. Result is <tt>(ThreadStatus,
--   Capability, Locked)</tt> where <tt>ThreadStatus</tt> is one of the
--   status constants defined in <tt>rts/Constants.h</tt>,
--   <tt>Capability</tt> is the number of the capability which currently
--   owns the thread, and <tt>Locked</tt> is a boolean indicating whether
--   the thread is bound to that capability.
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)

-- | Returns an array of the threads started by the program. Note that this
--   threads which have finished execution may or may not be present in
--   this list, depending upon whether they have been collected by the
--   garbage collector.
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
data Weak# b

-- | <tt><a>mkWeak#</a> k v finalizer s</tt> creates a weak reference to
--   value <tt>k</tt>, with an associated reference to some value
--   <tt>v</tt>. If <tt>k</tt> is still alive then <tt>v</tt> can be
--   retrieved using <a>deRefWeak#</a>. Note that the type of <tt>k</tt>
--   must be represented by a pointer (i.e. of kind <tt><tt>TYPE</tt>
--   '<tt>LiftedRep</tt> or </tt><tt>TYPE</tt> '<tt>UnliftedRep</tt>@).
mkWeak# :: v -> w -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# w #)
mkWeakNoFinalizer# :: v -> w -> State# RealWorld -> (# State# RealWorld, Weak# w #)

-- | <tt><a>addCFinalizerToWeak#</a> fptr ptr flag eptr w</tt> attaches a C
--   function pointer <tt>fptr</tt> to a weak pointer <tt>w</tt> as a
--   finalizer. If <tt>flag</tt> is zero, <tt>fptr</tt> will be called with
--   one argument, <tt>ptr</tt>. Otherwise, it will be called with two
--   arguments, <tt>eptr</tt> and <tt>ptr</tt>. <a>addCFinalizerToWeak#</a>
--   returns 1 on success, or 0 if <tt>w</tt> is already dead.
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# w -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# v -> State# RealWorld -> (# State# RealWorld, Int#, v #)

-- | Finalize a weak pointer. The return value is an unboxed tuple
--   containing the new state of the world and an "unboxed Maybe",
--   represented by an <a>Int#</a> and a (possibly invalid) finalization
--   action. An <a>Int#</a> of <tt>1</tt> indicates that the finalizer is
--   valid. The return value <tt>b</tt> from the finalizer should be
--   ignored.
finalizeWeak# :: Weak# v -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: v -> State# RealWorld -> State# RealWorld
data StablePtr# a
data StableName# a
makeStablePtr# :: v -> State# RealWorld -> (# State# RealWorld, StablePtr# v #)
deRefStablePtr# :: StablePtr# v -> State# RealWorld -> (# State# RealWorld, v #)
eqStablePtr# :: StablePtr# v -> StablePtr# v -> Int#
makeStableName# :: v -> State# RealWorld -> (# State# RealWorld, StableName# v #)
stableNameToInt# :: StableName# v -> Int#
data Compact#

-- | Create a new CNF with a single compact block. The argument is the
--   capacity of the compact block (in bytes, not words). The capacity is
--   rounded up to a multiple of the allocator block size and is capped to
--   one mega block.
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)

-- | Set the new allocation size of the CNF. This value (in bytes)
--   determines the capacity of each compact block in the CNF. It does not
--   retroactively affect existing compact blocks in the CNF.
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld

-- | Returns 1# if the object is contained in the CNF, 0# otherwise.
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns 1# if the object is in any CNF at all, 0# otherwise.
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)

-- | Returns the address and the utilized size (in bytes) of the first
--   compact block of a CNF.
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Given a CNF and the address of one its compact blocks, returns the
--   next compact block and its utilized size, or <a>nullAddr#</a> if the
--   argument was the last compact block in the CNF.
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)

-- | Attempt to allocate a compact block with the capacity (in bytes) given
--   by the first argument. The <a>Addr#</a> is a pointer to previous
--   compact block of the CNF or <a>nullAddr#</a> to create a new CNF with
--   a single compact block.
--   
--   The resulting block is not known to the GC until
--   <a>compactFixupPointers#</a> is called on it, and care must be taken
--   so that the address does not escape or memory will be leaked.
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Given the pointer to the first block of a CNF and the address of the
--   root object in the old address space, fix up the internal pointers
--   inside the CNF to account for a different position in memory than when
--   it was serialized. This method must be called exactly once after
--   importing a serialized CNF. It returns the new CNF and the new
--   adjusted root address.
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)

-- | Recursively add a closure and its transitive closure to a
--   <a>Compact#</a> (a CNF), evaluating any unevaluated components at the
--   same time. Note: <a>compactAdd#</a> is not thread-safe, so only one
--   thread may call <a>compactAdd#</a> with a particular <a>Compact#</a>
--   at any given time. The primop does not enforce any mutual exclusion;
--   the caller is expected to arrange this.
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Like <a>compactAdd#</a>, but retains sharing and cycles during
--   compaction.
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)

-- | Return the total capacity (in bytes) of all the compact blocks in the
--   CNF.
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)

-- | Returns <tt>1#</tt> if the given pointers are equal and <tt>0#</tt>
--   otherwise.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
reallyUnsafePtrEquality# :: v -> w -> Int#

-- | <i>Deprecated: Use <a>spark#</a> instead </i>
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# s -> (# State# s, Int# #)

-- | <tt><a>keepAlive#</a> x s k</tt> keeps the value <tt>x</tt> alive
--   during the execution of the computation <tt>k</tt>.
--   
--   Note that the result type here isn't quite as unrestricted as the
--   polymorphic type might suggest; see the section "RuntimeRep
--   polymorphism in continuation-style primops" for details.
keepAlive# :: v -> State# RealWorld -> (State# RealWorld -> p) -> p

-- | Evaluates the argument and returns the tag of the result. Tags are
--   Zero-indexed; the first constructor has tag zero.
dataToTag# :: a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO

-- | Convert an <a>Addr#</a> to a followable Any type.
addrToAny# :: Addr# -> (# v #)

-- | Retrieve the address of any Haskell value. This is essentially an
--   <a>unsafeCoerce#</a>, but if implemented as such the core lint pass
--   complains and fails to compile. As a primop, it is opaque to core/stg,
--   and only appears in cmm (where the copy propagation pass will get rid
--   of it). Note that "a" must be a value, not a thunk! It's too late for
--   strictness analysis to enforce this, so you're on your own to
--   guarantee this. Also note that <a>Addr#</a> is not a GC pointer - up
--   to you to guarantee that it does not become a dangling pointer
--   immediately after you get it.
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)

-- | Wrap a BCO in a <tt>AP_UPD</tt> thunk which will be updated with the
--   value of the BCO when evaluated.
mkApUpd0# :: BCO -> (# a #)

-- | <tt><a>newBCO#</a> instrs lits ptrs arity bitmap</tt> creates a new
--   bytecode object. The resulting object encodes a function of the given
--   arity with the instructions encoded in <tt>instrs</tt>, and a static
--   reference table usage bitmap given by <tt>bitmap</tt>.
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO #)

-- | <tt><a>unpackClosure#</a> closure</tt> copies the closure and pointers
--   in the payload of the given closure into two new arrays, and returns a
--   pointer to the first word of the closure's info table, a non-pointer
--   array for the raw bytes of the closure, and a pointer array for the
--   pointers in the payload.
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)

-- | <tt><a>closureSize#</a> closure</tt> returns the size of the given
--   closure in machine words.
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <a>getCurrentCCS#</a> being floated out by the simplifier,
--   which would result in an uninformative stack (<a>CAF</a>).
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)

-- | Run the supplied IO action with an empty CCS. For example, this is
--   used by the interpreter to run an interpreted computation without the
--   call stack showing that it was invoked from GHC.
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)

-- | Returns the <tt>InfoProvEnt </tt> for the info table of the given
--   object (value is <tt>NULL</tt> if the table does not exist or there is
--   no information about the closure).
whereFrom# :: a -> State# s -> (# State# s, Addr# #)

-- | The builtin function type, written in infix form as <tt>a % m -&gt;
--   b</tt>. Values of this type are functions taking inputs of type
--   <tt>a</tt> and producing outputs of type <tt>b</tt>. The multiplicity
--   of the input is <tt>m</tt>.
--   
--   Note that <tt><a>FUN</a> m a b</tt> permits representation
--   polymorphism in both <tt>a</tt> and <tt>b</tt>, so that types like
--   <tt><a>Int#</a> -&gt; <a>Int#</a></tt> can still be well-kinded.
data FUN m a b

-- | The token used in the implementation of the IO monad as a state monad.
--   It does not pass any information at runtime. See also <a>runRW#</a>.
realWorld# :: State# RealWorld

-- | This is an alias for the unboxed unit tuple constructor. In earlier
--   versions of GHC, <a>void#</a> was a value of the primitive type
--   <tt>Void#</tt>, which is now defined to be <tt>(# #)</tt>.

-- | <i>Deprecated: Use an unboxed unit tuple instead </i>
void# :: (# #)

-- | The type constructor <a>Proxy#</a> is used to bear witness to some
--   type variable. It's used when you want to pass around proxy values for
--   doing things like modelling type applications. A <a>Proxy#</a> is not
--   only unboxed, it also has a polymorphic kind, and has no runtime
--   representation, being totally free.
data Proxy# a

-- | Witness for an unboxed <a>Proxy#</a> value, which has no runtime
--   representation.
proxy# :: Proxy# a

-- | The value of <tt><a>seq</a> a b</tt> is bottom if <tt>a</tt> is
--   bottom, and otherwise equal to <tt>b</tt>. In other words, it
--   evaluates the first argument <tt>a</tt> to weak head normal form
--   (WHNF). <a>seq</a> is usually introduced to improve performance by
--   avoiding unneeded laziness.
--   
--   A note on evaluation order: the expression <tt><a>seq</a> a b</tt>
--   does <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <a>seq</a> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <a>seq</a> returns
--   a value. In particular, this means that <tt>b</tt> may be evaluated
--   before <tt>a</tt>. If you need to guarantee a specific order of
--   evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | The function <a>unsafeCoerce#</a> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <a>unsafeCoerce#</a> are supposed to work (i.e.
--   not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size.
--   (Casting between floating-point and integral types does not work. See
--   the <a>GHC.Float</a> module for functions to do work.)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt><tt>Ptr</tt>
--   <tt>Int</tt></tt> to <tt><tt>Ptr</tt> <tt>Float</tt></tt>, or
--   <tt>[<tt>Int</tt>]</tt> to <tt>[<tt>Float</tt>]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <a>unsafeCoerce#</a> are undefined. In particular, you
--   should not use <a>unsafeCoerce#</a> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt><tt>Int</tt>-&gt;<tt>Int</tt></tt> to <tt>Bool</tt>, even if
--   you later cast that <tt>Bool</tt> back to
--   <tt><tt>Int</tt>-&gt;<tt>Int</tt></tt> before applying it. The reasons
--   have to do with GHC's internal representation details (for the
--   cognoscenti, data values can be entered but function closures cannot).
--   If you want a safe type to cast things to, use <tt>Any</tt>, which is
--   not an algebraic data type.
--   
--   <b><i>Warning:</i></b> this can fail with an unchecked exception.
unsafeCoerce# :: a -> b

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the <tt>.eventlog</tt> file, or to
--   stderr, depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# s -> State# s

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the binary object passed as the first argument with the given
--   length passed as the second argument. The event will be emitted to the
--   <tt>.eventlog</tt> file.
traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s

-- | Emits a marker event via the RTS tracing framework. The contents of
--   the event is the zero-terminated byte string passed as the first
--   argument. The event will be emitted either to the <tt>.eventlog</tt>
--   file, or to stderr, depending on the runtime RTS flags.
traceMarker# :: Addr# -> State# s -> State# s

-- | Sets the allocation counter for the current thread to the given value.
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld

-- | Haskell representation of a <tt>StgStack*</tt> that was created
--   (cloned) with a function in <a>GHC.Stack.CloneStack</a>. Please check
--   the documentation in that module for more detailed explanations.
data StackSnapshot#

-- | The function <a>coerce</a> allows you to safely convert between values
--   of types that have the same representation with no run-time overhead.
--   In the simplest case you can use it instead of a newtype constructor,
--   to go from the newtype's concrete type to the abstract type. But it
--   also works in more complicated settings, e.g. converting a list of
--   newtypes to a list of concrete types.
--   
--   When used in conversions involving a newtype wrapper, make sure the
--   newtype constructor is in scope.
--   
--   This function is representation-polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt><a>coerce</a> @<tt>Int</tt> @Age
--   42</tt>.
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; newtype TTL = TTL Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; newtype Age = Age Int deriving (Eq, Ord, Show)
--   
--   &gt;&gt;&gt; coerce (Age 42) :: TTL
--   TTL 42
--   
--   &gt;&gt;&gt; coerce (+ (1 :: Int)) (Age 42) :: TTL
--   TTL 43
--   
--   &gt;&gt;&gt; coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]
--   [TTL 43,TTL 25]
--   </pre>
coerce :: Coercible a b => a -> b

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int8X64#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int16X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int32X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Int64X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word8X64#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word16X32#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word32X16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data Word64X8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX2#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX8#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX4#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data FloatX16#

-- | <b><i>Warning:</i></b> this is only available on LLVM.
data DoubleX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X16# :: Int8# -> Int8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X8# :: Int16# -> Int16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X4# :: Int32# -> Int32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X2# :: Int64# -> Int64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X32# :: Int8# -> Int8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X16# :: Int16# -> Int16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X8# :: Int32# -> Int32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X4# :: Int64# -> Int64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt8X64# :: Int8# -> Int8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt16X32# :: Int16# -> Int16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt32X16# :: Int32# -> Int32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastInt64X8# :: Int64# -> Int64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X16# :: Word8# -> Word8X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X8# :: Word16# -> Word16X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X4# :: Word32# -> Word32X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X2# :: Word64# -> Word64X2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X32# :: Word8# -> Word8X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X16# :: Word16# -> Word16X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X8# :: Word32# -> Word32X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X4# :: Word64# -> Word64X4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord8X64# :: Word8# -> Word8X64#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord16X32# :: Word16# -> Word16X32#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord32X16# :: Word32# -> Word32X16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastWord64X8# :: Word64# -> Word64X8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX4# :: Float# -> FloatX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX2# :: Double# -> DoubleX2#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX8# :: Float# -> FloatX8#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX4# :: Double# -> DoubleX4#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastFloatX16# :: Float# -> FloatX16#

-- | Broadcast a scalar to all elements of a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
broadcastDoubleX8# :: Double# -> DoubleX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#

-- | Pack the elements of an unboxed tuple into a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)

-- | Unpack the elements of a vector into an unboxed tuple. #
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#

-- | Insert a scalar at the given position in a vector.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Add two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Subtract two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Multiply two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#

-- | Divide two vectors element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Rounds towards zero element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#

-- | Satisfies <tt>(<tt>quot#</tt> x y) <tt>times#</tt> y <tt>plus#</tt>
--   (<tt>rem#</tt> x y) == x</tt>.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X16# :: Int8X16# -> Int8X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X8# :: Int16X8# -> Int16X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X4# :: Int32X4# -> Int32X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X2# :: Int64X2# -> Int64X2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X32# :: Int8X32# -> Int8X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X16# :: Int16X16# -> Int16X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X8# :: Int32X8# -> Int32X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X4# :: Int64X4# -> Int64X4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt8X64# :: Int8X64# -> Int8X64#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt16X32# :: Int16X32# -> Int16X32#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt32X16# :: Int32X16# -> Int32X16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateInt64X8# :: Int64X8# -> Int64X8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX4# :: FloatX4# -> FloatX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX2# :: DoubleX2# -> DoubleX2#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX8# :: FloatX8# -> FloatX8#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX4# :: DoubleX4# -> DoubleX4#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateFloatX16# :: FloatX16# -> FloatX16#

-- | Negate element-wise.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM.
negateDoubleX8# :: DoubleX8# -> DoubleX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16Array# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8Array# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4Array# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2Array# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32Array# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16Array# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8Array# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4Array# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64Array# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32Array# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16Array# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8Array# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16Array# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8Array# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4Array# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2Array# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32Array# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16Array# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8Array# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4Array# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64Array# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32Array# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16Array# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8Array# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4Array# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2Array# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8Array# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4Array# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16Array# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8Array# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8X64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16X32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32X16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64X8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX2OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX4OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatX16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleX8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X16OffAddr# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X8OffAddr# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X4OffAddr# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X2OffAddr# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X32OffAddr# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X16OffAddr# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X8OffAddr# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X4OffAddr# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8X64OffAddr# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16X32OffAddr# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32X16OffAddr# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64X8OffAddr# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X16OffAddr# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X8OffAddr# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X4OffAddr# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X2OffAddr# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X32OffAddr# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X16OffAddr# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X8OffAddr# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X4OffAddr# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8X64OffAddr# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16X32OffAddr# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32X16OffAddr# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64X8OffAddr# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX4OffAddr# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX8OffAddr# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatX16OffAddr# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in bytes.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#

-- | Read a vector from specified index of immutable array of scalars;
--   offset is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Read a vector from specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X16# :: MutableByteArray# s -> Int# -> Int8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X8# :: MutableByteArray# s -> Int# -> Int16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X4# :: MutableByteArray# s -> Int# -> Int32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X2# :: MutableByteArray# s -> Int# -> Int64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X32# :: MutableByteArray# s -> Int# -> Int8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X16# :: MutableByteArray# s -> Int# -> Int16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X8# :: MutableByteArray# s -> Int# -> Int32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X4# :: MutableByteArray# s -> Int# -> Int64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8ArrayAsInt8X64# :: MutableByteArray# s -> Int# -> Int8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16ArrayAsInt16X32# :: MutableByteArray# s -> Int# -> Int16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32ArrayAsInt32X16# :: MutableByteArray# s -> Int# -> Int32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64ArrayAsInt64X8# :: MutableByteArray# s -> Int# -> Int64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X16# :: MutableByteArray# s -> Int# -> Word8X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X8# :: MutableByteArray# s -> Int# -> Word16X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X4# :: MutableByteArray# s -> Int# -> Word32X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X2# :: MutableByteArray# s -> Int# -> Word64X2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X32# :: MutableByteArray# s -> Int# -> Word8X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X16# :: MutableByteArray# s -> Int# -> Word16X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X8# :: MutableByteArray# s -> Int# -> Word32X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X4# :: MutableByteArray# s -> Int# -> Word64X4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8ArrayAsWord8X64# :: MutableByteArray# s -> Int# -> Word8X64# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16ArrayAsWord16X32# :: MutableByteArray# s -> Int# -> Word16X32# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32ArrayAsWord32X16# :: MutableByteArray# s -> Int# -> Word32X16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64ArrayAsWord64X8# :: MutableByteArray# s -> Int# -> Word64X8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX4# :: MutableByteArray# s -> Int# -> FloatX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX2# :: MutableByteArray# s -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX8# :: MutableByteArray# s -> Int# -> FloatX8# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX4# :: MutableByteArray# s -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatArrayAsFloatX16# :: MutableByteArray# s -> Int# -> FloatX16# -> State# s -> State# s

-- | Write a vector to specified index of mutable array of scalars; offset
--   is in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleArrayAsDoubleX8# :: MutableByteArray# s -> Int# -> DoubleX8# -> State# s -> State# s

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X16# :: Addr# -> Int# -> State# s -> (# State# s, Int8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X8# :: Addr# -> Int# -> State# s -> (# State# s, Int16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X4# :: Addr# -> Int# -> State# s -> (# State# s, Int32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X2# :: Addr# -> Int# -> State# s -> (# State# s, Int64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X32# :: Addr# -> Int# -> State# s -> (# State# s, Int8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X16# :: Addr# -> Int# -> State# s -> (# State# s, Int16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X8# :: Addr# -> Int# -> State# s -> (# State# s, Int32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X4# :: Addr# -> Int# -> State# s -> (# State# s, Int64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt8OffAddrAsInt8X64# :: Addr# -> Int# -> State# s -> (# State# s, Int8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt16OffAddrAsInt16X32# :: Addr# -> Int# -> State# s -> (# State# s, Int16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt32OffAddrAsInt32X16# :: Addr# -> Int# -> State# s -> (# State# s, Int32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readInt64OffAddrAsInt64X8# :: Addr# -> Int# -> State# s -> (# State# s, Int64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X16# :: Addr# -> Int# -> State# s -> (# State# s, Word8X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X8# :: Addr# -> Int# -> State# s -> (# State# s, Word16X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X4# :: Addr# -> Int# -> State# s -> (# State# s, Word32X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X2# :: Addr# -> Int# -> State# s -> (# State# s, Word64X2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X32# :: Addr# -> Int# -> State# s -> (# State# s, Word8X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X16# :: Addr# -> Int# -> State# s -> (# State# s, Word16X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X8# :: Addr# -> Int# -> State# s -> (# State# s, Word32X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X4# :: Addr# -> Int# -> State# s -> (# State# s, Word64X4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord8OffAddrAsWord8X64# :: Addr# -> Int# -> State# s -> (# State# s, Word8X64# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord16OffAddrAsWord16X32# :: Addr# -> Int# -> State# s -> (# State# s, Word16X32# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord32OffAddrAsWord32X16# :: Addr# -> Int# -> State# s -> (# State# s, Word32X16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readWord64OffAddrAsWord64X8# :: Addr# -> Int# -> State# s -> (# State# s, Word64X8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX4# :: Addr# -> Int# -> State# s -> (# State# s, FloatX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX2# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX8# :: Addr# -> Int# -> State# s -> (# State# s, FloatX8# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX4# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readFloatOffAddrAsFloatX16# :: Addr# -> Int# -> State# s -> (# State# s, FloatX16# #)

-- | Reads vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
readDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> State# s -> (# State# s, DoubleX8# #)

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16# -> State# s -> State# s

-- | Write vector; offset in scalar elements.
--   
--   <b><i>Warning:</i></b> this is only available on LLVM and can fail
--   with an unchecked exception.
writeDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8# -> State# s -> State# s
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | Defines the <a>withDict</a> function. For more information, see
--   <tt>Note [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC. The
--   definition of <a>withDict</a> is located in a separate module from
--   <a>GHC.Magic</a> because <a>withDict</a> is <tt>Unsafe</tt> (it
--   threatens type class coherence) while <a>GHC.Magic</a> is
--   <tt>Trustworthy</tt>.
--   
--   Use <a>GHC.Exts</a> from the <tt>base</tt> package instead of
--   importing this module directly.
module GHC.Magic.Dict

-- | The constraint <tt><a>WithDict</a> cls meth</tt> can be solved when
--   evidence for the constraint <tt>cls</tt> can be provided in the form
--   of a dictionary of type <tt>meth</tt>. This requires <tt>cls</tt> to
--   be a class constraint whose single method has type <tt>meth</tt>.
--   
--   For more (important) details on how this works, see <tt>Note
--   [withDict]</tt> in <a>GHC.Tc.Instance.Class</a> in GHC.
class WithDict cls meth
withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). WithDict cls meth => meth -> (cls => r) -> r


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call <tt>inline f</tt> arranges that <tt>f</tt> is inlined,
--   regardless of its size. More precisely, the call <tt>inline f</tt>
--   rewrites to the right-hand side of <tt>f</tt>'s definition. This
--   allows the programmer to control inlining from a particular call site
--   rather than the definition site of the function (c.f. <tt>INLINE</tt>
--   pragmas).
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler; it is
--   therefore recommended to mark the function with an <tt>INLINABLE</tt>
--   pragma at its definition so that GHC guarantees to record its
--   unfolding regardless of size.
--   
--   If no inlining takes place, the <a>inline</a> function expands to the
--   identity function in Phase zero, so its use imposes no overhead.
inline :: a -> a

-- | The call <tt>noinline f</tt> arranges that <tt>f</tt> will not be
--   inlined. It is removed during CorePrep so that its use imposes no
--   overhead (besides the fact that it blocks inlining.)
noinline :: a -> a

-- | The <a>lazy</a> function restrains strictness analysis a little. The
--   call <tt>lazy e</tt> means the same as <tt>e</tt>, but <a>lazy</a> has
--   a magical property so far as strictness analysis is concerned: it is
--   lazy in its first argument, even though its semantics is strict. After
--   strictness analysis has run, calls to <a>lazy</a> are inlined to be
--   the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <a>lazy</a> is used in the library definition of
--   <a>par</a>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <a>lazy</a> were not lazy, <a>par</a> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <a>par</a>.
lazy :: a -> a

-- | The <a>oneShot</a> function can be used to give a hint to the compiler
--   that its argument will be called at most once, which may (or may not)
--   enable certain optimizations. It can be useful to improve the
--   performance of code in continuation passing style.
--   
--   If <a>oneShot</a> is used wrongly, then it may be that computations
--   whose result that would otherwise be shared are re-evaluated every
--   time they are used. Otherwise, the use of <a>oneShot</a> is safe.
--   
--   <a>oneShot</a> is representation-polymorphic: the type variables may
--   refer to lifted or unlifted types.
oneShot :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b

-- | Apply a function to a <tt><a>State#</a> <a>RealWorld</a></tt> token.
--   When manually applying a function to <a>realWorld#</a>, it is
--   necessary to use <tt>NOINLINE</tt> to prevent semantically undesirable
--   floating. <a>runRW#</a> is inlined, but only very late in compilation
--   after all floating is complete.
runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o


-- | Primitive panics.
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Prim.Panic

-- | Closure introduced by GHC.Stg.Unarise for unused unboxed sum fields.
--   
--   See Note [aBSENT_SUM_FIELD_ERROR_ID] in GHC.Core.Make
absentSumFieldError :: a

-- | Display the CString whose address is given as an argument and exit.
panicError :: Addr# -> a

-- | Displays "Oops! Entered absent arg" ++ errormsg and exits the program.
absentError :: forall (a :: Type). Addr# -> a
absentConstraintError :: forall (a :: Type). Addr# -> a


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a

-- | Compute the length of a NUL-terminated string. This address must refer
--   to immutable memory. GHC includes a built-in rule for constant folding
--   when the argument is a statically-known literal. That is, a
--   core-to-core pass reduces the expression <tt>cstringLength#
--   "hello"#</tt> to the constant <tt>5#</tt>.
cstringLength# :: Addr# -> Int#
unpackCStringUtf8# :: Addr# -> [Char]
unpackAppendCStringUtf8# :: Addr# -> [Char] -> [Char]
unpackFoldrCStringUtf8# :: Addr# -> (Char -> a -> a) -> a -> a
unpackNBytes# :: Addr# -> Int# -> [Char]


-- | The tuple data types
module GHC.Tuple.Prim

-- | The unit datatype <tt>()</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data Solo a
MkSolo :: a -> Solo a
getSolo :: Solo a -> a
data (,) a b
(,) :: a -> b -> (,) a b
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> j2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 k2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> j2 -> k2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 k2
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 k2 l2
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a1 -> b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> l1 -> m1 -> n1 -> o1 -> p1 -> q1 -> r1 -> s1 -> t1 -> u1 -> v1 -> w1 -> x1 -> y1 -> z1 -> a2 -> b2 -> c2 -> d2 -> e2 -> f2 -> g2 -> h2 -> i2 -> j2 -> k2 -> l2 -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a1 b1 c1 d1 e1 f1 g1 h1 i1 j1 k1 l1 m1 n1 o1 p1 q1 r1 s1 t1 u1 v1 w1 x1 y1 z1 a2 b2 c2 d2 e2 f2 g2 h2 i2 j2 k2 l2


-- | The tuple data types
--   
--   Users should not import this module. It is GHC internal only.
module GHC.Tuple

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data Solo a
MkSolo :: a -> Solo a

-- | <i>Deprecated: The Solo constructor has been renamed to MkSolo to
--   avoid punning.</i>
pattern Solo :: a -> Solo a


-- | Users should not import this module. It is GHC internal only. Use
--   <a>GHC.Exts</a> instead.
module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Int#
geChar# :: Char# -> Char# -> Int#
eqChar# :: Char# -> Char# -> Int#
neChar# :: Char# -> Char# -> Int#
ltChar# :: Char# -> Char# -> Int#
leChar# :: Char# -> Char# -> Int#
ord# :: Char# -> Int#
int8ToInt# :: Int8# -> Int#
intToInt8# :: Int# -> Int8#
negateInt8# :: Int8# -> Int8#
plusInt8# :: Int8# -> Int8# -> Int8#
subInt8# :: Int8# -> Int8# -> Int8#
timesInt8# :: Int8# -> Int8# -> Int8#
quotInt8# :: Int8# -> Int8# -> Int8#
remInt8# :: Int8# -> Int8# -> Int8#
quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
int8ToWord8# :: Int8# -> Word8#
eqInt8# :: Int8# -> Int8# -> Int#
geInt8# :: Int8# -> Int8# -> Int#
gtInt8# :: Int8# -> Int8# -> Int#
leInt8# :: Int8# -> Int8# -> Int#
ltInt8# :: Int8# -> Int8# -> Int#
neInt8# :: Int8# -> Int8# -> Int#
word8ToWord# :: Word8# -> Word#
wordToWord8# :: Word# -> Word8#
plusWord8# :: Word8# -> Word8# -> Word8#
subWord8# :: Word8# -> Word8# -> Word8#
timesWord8# :: Word8# -> Word8# -> Word8#
quotWord8# :: Word8# -> Word8# -> Word8#
remWord8# :: Word8# -> Word8# -> Word8#
quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
andWord8# :: Word8# -> Word8# -> Word8#
orWord8# :: Word8# -> Word8# -> Word8#
xorWord8# :: Word8# -> Word8# -> Word8#
notWord8# :: Word8# -> Word8#
uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
word8ToInt8# :: Word8# -> Int8#
eqWord8# :: Word8# -> Word8# -> Int#
geWord8# :: Word8# -> Word8# -> Int#
gtWord8# :: Word8# -> Word8# -> Int#
leWord8# :: Word8# -> Word8# -> Int#
ltWord8# :: Word8# -> Word8# -> Int#
neWord8# :: Word8# -> Word8# -> Int#
int16ToInt# :: Int16# -> Int#
intToInt16# :: Int# -> Int16#
negateInt16# :: Int16# -> Int16#
plusInt16# :: Int16# -> Int16# -> Int16#
subInt16# :: Int16# -> Int16# -> Int16#
timesInt16# :: Int16# -> Int16# -> Int16#
quotInt16# :: Int16# -> Int16# -> Int16#
remInt16# :: Int16# -> Int16# -> Int16#
quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
int16ToWord16# :: Int16# -> Word16#
eqInt16# :: Int16# -> Int16# -> Int#
geInt16# :: Int16# -> Int16# -> Int#
gtInt16# :: Int16# -> Int16# -> Int#
leInt16# :: Int16# -> Int16# -> Int#
ltInt16# :: Int16# -> Int16# -> Int#
neInt16# :: Int16# -> Int16# -> Int#
word16ToWord# :: Word16# -> Word#
wordToWord16# :: Word# -> Word16#
plusWord16# :: Word16# -> Word16# -> Word16#
subWord16# :: Word16# -> Word16# -> Word16#
timesWord16# :: Word16# -> Word16# -> Word16#
quotWord16# :: Word16# -> Word16# -> Word16#
remWord16# :: Word16# -> Word16# -> Word16#
quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
andWord16# :: Word16# -> Word16# -> Word16#
orWord16# :: Word16# -> Word16# -> Word16#
xorWord16# :: Word16# -> Word16# -> Word16#
notWord16# :: Word16# -> Word16#
uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
word16ToInt16# :: Word16# -> Int16#
eqWord16# :: Word16# -> Word16# -> Int#
geWord16# :: Word16# -> Word16# -> Int#
gtWord16# :: Word16# -> Word16# -> Int#
leWord16# :: Word16# -> Word16# -> Int#
ltWord16# :: Word16# -> Word16# -> Int#
neWord16# :: Word16# -> Word16# -> Int#
int32ToInt# :: Int32# -> Int#
intToInt32# :: Int# -> Int32#
negateInt32# :: Int32# -> Int32#
plusInt32# :: Int32# -> Int32# -> Int32#
subInt32# :: Int32# -> Int32# -> Int32#
timesInt32# :: Int32# -> Int32# -> Int32#
quotInt32# :: Int32# -> Int32# -> Int32#
remInt32# :: Int32# -> Int32# -> Int32#
quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
int32ToWord32# :: Int32# -> Word32#
eqInt32# :: Int32# -> Int32# -> Int#
geInt32# :: Int32# -> Int32# -> Int#
gtInt32# :: Int32# -> Int32# -> Int#
leInt32# :: Int32# -> Int32# -> Int#
ltInt32# :: Int32# -> Int32# -> Int#
neInt32# :: Int32# -> Int32# -> Int#
word32ToWord# :: Word32# -> Word#
wordToWord32# :: Word# -> Word32#
plusWord32# :: Word32# -> Word32# -> Word32#
subWord32# :: Word32# -> Word32# -> Word32#
timesWord32# :: Word32# -> Word32# -> Word32#
quotWord32# :: Word32# -> Word32# -> Word32#
remWord32# :: Word32# -> Word32# -> Word32#
quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
andWord32# :: Word32# -> Word32# -> Word32#
orWord32# :: Word32# -> Word32# -> Word32#
xorWord32# :: Word32# -> Word32# -> Word32#
notWord32# :: Word32# -> Word32#
uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
word32ToInt32# :: Word32# -> Int32#
eqWord32# :: Word32# -> Word32# -> Int#
geWord32# :: Word32# -> Word32# -> Int#
gtWord32# :: Word32# -> Word32# -> Int#
leWord32# :: Word32# -> Word32# -> Int#
ltWord32# :: Word32# -> Word32# -> Int#
neWord32# :: Word32# -> Word32# -> Int#
int64ToInt# :: Int64# -> Int#
intToInt64# :: Int# -> Int64#
negateInt64# :: Int64# -> Int64#
plusInt64# :: Int64# -> Int64# -> Int64#
subInt64# :: Int64# -> Int64# -> Int64#
timesInt64# :: Int64# -> Int64# -> Int64#
quotInt64# :: Int64# -> Int64# -> Int64#
remInt64# :: Int64# -> Int64# -> Int64#
uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
int64ToWord64# :: Int64# -> Word64#
eqInt64# :: Int64# -> Int64# -> Int#
geInt64# :: Int64# -> Int64# -> Int#
gtInt64# :: Int64# -> Int64# -> Int#
leInt64# :: Int64# -> Int64# -> Int#
ltInt64# :: Int64# -> Int64# -> Int#
neInt64# :: Int64# -> Int64# -> Int#
word64ToWord# :: Word64# -> Word#
wordToWord64# :: Word# -> Word64#
plusWord64# :: Word64# -> Word64# -> Word64#
subWord64# :: Word64# -> Word64# -> Word64#
timesWord64# :: Word64# -> Word64# -> Word64#
quotWord64# :: Word64# -> Word64# -> Word64#
remWord64# :: Word64# -> Word64# -> Word64#
and64# :: Word64# -> Word64# -> Word64#
or64# :: Word64# -> Word64# -> Word64#
xor64# :: Word64# -> Word64# -> Word64#
not64# :: Word64# -> Word64#
uncheckedShiftL64# :: Word64# -> Int# -> Word64#
uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
word64ToInt64# :: Word64# -> Int64#
eqWord64# :: Word64# -> Word64# -> Int#
geWord64# :: Word64# -> Word64# -> Int#
gtWord64# :: Word64# -> Word64# -> Int#
leWord64# :: Word64# -> Word64# -> Int#
ltWord64# :: Word64# -> Word64# -> Int#
neWord64# :: Word64# -> Word64# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
andI# :: Int# -> Int# -> Int#
orI# :: Int# -> Int# -> Int#
xorI# :: Int# -> Int# -> Int#
notI# :: Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Int#
(>=#) :: Int# -> Int# -> Int#
(==#) :: Int# -> Int# -> Int#
(/=#) :: Int# -> Int# -> Int#
(<#) :: Int# -> Int# -> Int#
(<=#) :: Int# -> Int# -> Int#
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
word2Float# :: Word# -> Float#
word2Double# :: Word# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
addWordC# :: Word# -> Word# -> (# Word#, Int# #)
subWordC# :: Word# -> Word# -> (# Word#, Int# #)
plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Int#
geWord# :: Word# -> Word# -> Int#
eqWord# :: Word# -> Word# -> Int#
neWord# :: Word# -> Word# -> Int#
ltWord# :: Word# -> Word# -> Int#
leWord# :: Word# -> Word# -> Int#
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word64# -> Word#
popCnt# :: Word# -> Word#
pdep8# :: Word# -> Word# -> Word#
pdep16# :: Word# -> Word# -> Word#
pdep32# :: Word# -> Word# -> Word#
pdep64# :: Word64# -> Word64# -> Word64#
pdep# :: Word# -> Word# -> Word#
pext8# :: Word# -> Word# -> Word#
pext16# :: Word# -> Word# -> Word#
pext32# :: Word# -> Word# -> Word#
pext64# :: Word64# -> Word64# -> Word64#
pext# :: Word# -> Word# -> Word#
clz8# :: Word# -> Word#
clz16# :: Word# -> Word#
clz32# :: Word# -> Word#
clz64# :: Word64# -> Word#
clz# :: Word# -> Word#
ctz8# :: Word# -> Word#
ctz16# :: Word# -> Word#
ctz32# :: Word# -> Word#
ctz64# :: Word64# -> Word#
ctz# :: Word# -> Word#
byteSwap16# :: Word# -> Word#
byteSwap32# :: Word# -> Word#
byteSwap64# :: Word64# -> Word64#
byteSwap# :: Word# -> Word#
bitReverse8# :: Word# -> Word#
bitReverse16# :: Word# -> Word#
bitReverse32# :: Word# -> Word#
bitReverse64# :: Word64# -> Word64#
bitReverse# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Int#
(>=##) :: Double# -> Double# -> Int#
(==##) :: Double# -> Double# -> Int#
(/=##) :: Double# -> Double# -> Int#
(<##) :: Double# -> Double# -> Int#
(<=##) :: Double# -> Double# -> Int#
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
fabsDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
expm1Double# :: Double# -> Double#
logDouble# :: Double# -> Double#
log1pDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
asinhDouble# :: Double# -> Double#
acoshDouble# :: Double# -> Double#
atanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
gtFloat# :: Float# -> Float# -> Int#
geFloat# :: Float# -> Float# -> Int#
eqFloat# :: Float# -> Float# -> Int#
neFloat# :: Float# -> Float# -> Int#
ltFloat# :: Float# -> Float# -> Int#
leFloat# :: Float# -> Float# -> Int#
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
fabsFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
expm1Float# :: Float# -> Float#
logFloat# :: Float# -> Float#
log1pFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
asinhFloat# :: Float# -> Float#
acoshFloat# :: Float# -> Float#
atanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: Int# -> v -> State# s -> (# State# s, MutableArray# s v #)
readArray# :: MutableArray# s v -> Int# -> State# s -> (# State# s, v #)
writeArray# :: MutableArray# s v -> Int# -> v -> State# s -> State# s
sizeofArray# :: Array# v -> Int#
sizeofMutableArray# :: MutableArray# s v -> Int#
indexArray# :: Array# v -> Int# -> (# v #)
unsafeFreezeArray# :: MutableArray# s v -> State# s -> (# State# s, Array# v #)
unsafeThawArray# :: Array# v -> State# s -> (# State# s, MutableArray# s v #)
copyArray# :: Array# v -> Int# -> MutableArray# s v -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s v -> Int# -> MutableArray# s v -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# v -> Int# -> Int# -> Array# v
cloneMutableArray# :: MutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s v #)
freezeArray# :: MutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, Array# v #)
thawArray# :: Array# v -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s v #)
casArray# :: MutableArray# s v -> Int# -> v -> v -> State# s -> (# State# s, Int#, v #)
newSmallArray# :: Int# -> v -> State# s -> (# State# s, SmallMutableArray# s v #)
shrinkSmallMutableArray# :: SmallMutableArray# s v -> Int# -> State# s -> State# s
readSmallArray# :: SmallMutableArray# s v -> Int# -> State# s -> (# State# s, v #)
writeSmallArray# :: SmallMutableArray# s v -> Int# -> v -> State# s -> State# s
sizeofSmallArray# :: SmallArray# v -> Int#
sizeofSmallMutableArray# :: SmallMutableArray# s v -> Int#
getSizeofSmallMutableArray# :: SmallMutableArray# s v -> State# s -> (# State# s, Int# #)
indexSmallArray# :: SmallArray# v -> Int# -> (# v #)
unsafeFreezeSmallArray# :: SmallMutableArray# s v -> State# s -> (# State# s, SmallArray# v #)
unsafeThawSmallArray# :: SmallArray# v -> State# s -> (# State# s, SmallMutableArray# s v #)
copySmallArray# :: SmallArray# v -> Int# -> SmallMutableArray# s v -> Int# -> Int# -> State# s -> State# s
copySmallMutableArray# :: SmallMutableArray# s v -> Int# -> SmallMutableArray# s v -> Int# -> Int# -> State# s -> State# s
cloneSmallArray# :: SmallArray# v -> Int# -> Int# -> SmallArray# v
cloneSmallMutableArray# :: SmallMutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s v #)
freezeSmallArray# :: SmallMutableArray# s v -> Int# -> Int# -> State# s -> (# State# s, SmallArray# v #)
thawSmallArray# :: SmallArray# v -> Int# -> Int# -> State# s -> (# State# s, SmallMutableArray# s v #)
casSmallArray# :: SmallMutableArray# s v -> Int# -> v -> v -> State# s -> (# State# s, Int#, v #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
isByteArrayPinned# :: ByteArray# -> Int#
byteArrayContents# :: ByteArray# -> Addr#
mutableByteArrayContents# :: MutableByteArray# s -> Addr#
shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s, Int# #)
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int8#
indexInt16Array# :: ByteArray# -> Int# -> Int16#
indexInt32Array# :: ByteArray# -> Int# -> Int32#
indexInt64Array# :: ByteArray# -> Int# -> Int64#
indexWord8Array# :: ByteArray# -> Int# -> Word8#
indexWord16Array# :: ByteArray# -> Int# -> Word16#
indexWord32Array# :: ByteArray# -> Int# -> Word32#
indexWord64Array# :: ByteArray# -> Int# -> Word64#
indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int8# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word8# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)
readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int16# #)
readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int32# #)
readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word16# #)
readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word32# #)
readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word8# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s
writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int16# -> State# s -> State# s
writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int32# -> State# s -> State# s
writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word16# -> State# s -> State# s
writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word32# -> State# s -> State# s
writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s
compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s, Int# #)
casInt8Array# :: MutableByteArray# s -> Int# -> Int8# -> Int8# -> State# s -> (# State# s, Int8# #)
casInt16Array# :: MutableByteArray# s -> Int# -> Int16# -> Int16# -> State# s -> (# State# s, Int16# #)
casInt32Array# :: MutableByteArray# s -> Int# -> Int32# -> Int32# -> State# s -> (# State# s, Int32# #)
casInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> Int64# -> State# s -> (# State# s, Int64# #)
fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s, Int# #)
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Int#
geAddr# :: Addr# -> Addr# -> Int#
eqAddr# :: Addr# -> Addr# -> Int#
neAddr# :: Addr# -> Addr# -> Int#
ltAddr# :: Addr# -> Addr# -> Int#
leAddr# :: Addr# -> Addr# -> Int#
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int8#
indexInt16OffAddr# :: Addr# -> Int# -> Int16#
indexInt32OffAddr# :: Addr# -> Int# -> Int32#
indexInt64OffAddr# :: Addr# -> Int# -> Int64#
indexWord8OffAddr# :: Addr# -> Int# -> Word8#
indexWord16OffAddr# :: Addr# -> Int# -> Word16#
indexWord32OffAddr# :: Addr# -> Int# -> Word32#
indexWord64OffAddr# :: Addr# -> Int# -> Word64#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int8# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int16# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int32# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word8# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word16# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word32# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int8# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int16# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int32# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word8# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word16# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word32# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# s -> State# s
atomicExchangeAddrAddr# :: Addr# -> Addr# -> State# s -> (# State# s, Addr# #)
atomicExchangeWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
atomicCasAddrAddr# :: Addr# -> Addr# -> Addr# -> State# s -> (# State# s, Addr# #)
atomicCasWordAddr# :: Addr# -> Word# -> Word# -> State# s -> (# State# s, Word# #)
atomicCasWord8Addr# :: Addr# -> Word8# -> Word8# -> State# s -> (# State# s, Word8# #)
atomicCasWord16Addr# :: Addr# -> Word16# -> Word16# -> State# s -> (# State# s, Word16# #)
atomicCasWord32Addr# :: Addr# -> Word32# -> Word32# -> State# s -> (# State# s, Word32# #)
atomicCasWord64Addr# :: Addr# -> Word64# -> Word64# -> State# s -> (# State# s, Word64# #)
fetchAddWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchSubWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchAndWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchNandWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchOrWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
fetchXorWordAddr# :: Addr# -> Word# -> State# s -> (# State# s, Word# #)
atomicReadWordAddr# :: Addr# -> State# s -> (# State# s, Word# #)
atomicWriteWordAddr# :: Addr# -> Word# -> State# s -> State# s
newMutVar# :: v -> State# s -> (# State# s, MutVar# s v #)
readMutVar# :: MutVar# s v -> State# s -> (# State# s, v #)
writeMutVar# :: MutVar# s v -> v -> State# s -> State# s
atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s, a, c #)
atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s, a, a #)
casMutVar# :: MutVar# s v -> v -> v -> State# s -> (# State# s, Int#, v #)
catch# :: (State# RealWorld -> (# State# RealWorld, o #)) -> (w -> State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)
raise# :: v -> p
raiseUnderflow# :: (# #) -> p
raiseOverflow# :: (# #) -> p
raiseDivZero# :: (# #) -> p
raiseIO# :: v -> State# RealWorld -> (# State# RealWorld, p #)
maskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)
maskUninterruptible# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)
unmaskAsyncExceptions# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, o #)
getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
newPromptTag# :: State# RealWorld -> (# State# RealWorld, PromptTag# a #)
prompt# :: PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
control0# :: PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, p #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, p #)
atomically# :: (State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)
retry# :: State# RealWorld -> (# State# RealWorld, v #)
catchRetry# :: (State# RealWorld -> (# State# RealWorld, v #)) -> (State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)
catchSTM# :: (State# RealWorld -> (# State# RealWorld, v #)) -> (b -> State# RealWorld -> (# State# RealWorld, v #)) -> State# RealWorld -> (# State# RealWorld, v #)
newTVar# :: v -> State# s -> (# State# s, TVar# s v #)
readTVar# :: TVar# s v -> State# s -> (# State# s, v #)
readTVarIO# :: TVar# s v -> State# s -> (# State# s, v #)
writeTVar# :: TVar# s v -> v -> State# s -> State# s
newMVar# :: State# s -> (# State# s, MVar# s v #)
takeMVar# :: MVar# s v -> State# s -> (# State# s, v #)
tryTakeMVar# :: MVar# s v -> State# s -> (# State# s, Int#, v #)
putMVar# :: MVar# s v -> v -> State# s -> State# s
tryPutMVar# :: MVar# s v -> v -> State# s -> (# State# s, Int# #)
readMVar# :: MVar# s v -> State# s -> (# State# s, v #)
tryReadMVar# :: MVar# s v -> State# s -> (# State# s, Int#, v #)
isEmptyMVar# :: MVar# s v -> State# s -> (# State# s, Int# #)
newIOPort# :: State# s -> (# State# s, IOPort# s v #)
readIOPort# :: IOPort# s v -> State# s -> (# State# s, v #)
writeIOPort# :: IOPort# s v -> v -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
forkOn# :: Int# -> (State# RealWorld -> (# State# RealWorld, o #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
killThread# :: ThreadId# -> a -> State# RealWorld -> State# RealWorld
yield# :: State# RealWorld -> State# RealWorld
myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
noDuplicate# :: State# s -> State# s
threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
mkWeak# :: v -> w -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# w #)
mkWeakNoFinalizer# :: v -> w -> State# RealWorld -> (# State# RealWorld, Weak# w #)
addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# w -> State# RealWorld -> (# State# RealWorld, Int# #)
deRefWeak# :: Weak# v -> State# RealWorld -> (# State# RealWorld, Int#, v #)
finalizeWeak# :: Weak# v -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
touch# :: v -> State# RealWorld -> State# RealWorld
makeStablePtr# :: v -> State# RealWorld -> (# State# RealWorld, StablePtr# v #)
deRefStablePtr# :: StablePtr# v -> State# RealWorld -> (# State# RealWorld, v #)
eqStablePtr# :: StablePtr# v -> StablePtr# v -> Int#
makeStableName# :: v -> State# RealWorld -> (# State# RealWorld, StableName# v #)
stableNameToInt# :: StableName# v -> Int#
compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
compactContains# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactContainsAny# :: a -> State# RealWorld -> (# State# RealWorld, Int# #)
compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
compactAdd# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactAddWithSharing# :: Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
reallyUnsafePtrEquality# :: v -> w -> Int#
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
keepAlive# :: v -> State# RealWorld -> (State# RealWorld -> p) -> p
dataToTag# :: a -> Int#
addrToAny# :: Addr# -> (# v #)
anyToAddr# :: a -> State# RealWorld -> (# State# RealWorld, Addr# #)
mkApUpd0# :: BCO -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO #)
unpackClosure# :: a -> (# Addr#, ByteArray#, Array# b #)
closureSize# :: a -> Int#
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
clearCCS# :: (State# s -> (# State# s, a #)) -> State# s -> (# State# s, a #)
whereFrom# :: a -> State# s -> (# State# s, Addr# #)
traceEvent# :: Addr# -> State# s -> State# s
traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s
traceMarker# :: Addr# -> State# s -> State# s
setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
prefetchValue3# :: a -> State# s -> State# s
prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
prefetchValue2# :: a -> State# s -> State# s
prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
prefetchValue1# :: a -> State# s -> State# s
prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
prefetchValue0# :: a -> State# s -> State# s


-- | Users should not import this module. It is GHC internal only.
module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()


-- | Basic classes. Do not import this module directly. It is an GHC
--   internal only module. Some of its contents are instead available from
--   <tt>Prelude</tt> and <tt>GHC.Int</tt>.
module GHC.Classes

-- | The syntax <tt>?x :: a</tt> is desugared into <tt>IP "x" a</tt> IP is
--   declared very early, so that libraries can take advantage of the
--   implicit-call-stack feature
class IP (x :: Symbol) a | x -> a
ip :: IP x a => a

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class (Eq a) => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <
infix 4 <=
infix 4 >
eqInt :: Int -> Int -> Bool
neInt :: Int -> Int -> Bool
eqWord :: Word -> Word -> Bool
neWord :: Word -> Word -> Bool
eqChar :: Char -> Char -> Bool
neChar :: Char -> Char -> Bool
eqFloat :: Float -> Float -> Bool
eqDouble :: Double -> Double -> Bool
gtInt :: Int -> Int -> Bool
geInt :: Int -> Int -> Bool
leInt :: Int -> Int -> Bool
ltInt :: Int -> Int -> Bool
compareInt :: Int -> Int -> Ordering
compareInt# :: Int# -> Int# -> Ordering
gtWord :: Word -> Word -> Bool
geWord :: Word -> Word -> Bool
leWord :: Word -> Word -> Bool
ltWord :: Word -> Word -> Bool
compareWord :: Word -> Word -> Ordering
compareWord# :: Word# -> Word# -> Ordering

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool
divInt# :: Int# -> Int# -> Int#
divInt8# :: Int8# -> Int8# -> Int8#
divInt16# :: Int16# -> Int16# -> Int16#
divInt32# :: Int32# -> Int32# -> Int32#
modInt# :: Int# -> Int# -> Int#
modInt8# :: Int8# -> Int8# -> Int8#
modInt16# :: Int16# -> Int16# -> Int16#
modInt32# :: Int32# -> Int32# -> Int32#
divModInt# :: Int# -> Int# -> (# Int#, Int# #)
divModInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
divModInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
divModInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
instance GHC.Classes.Eq ()
instance GHC.Classes.Eq a => GHC.Classes.Eq (Solo a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (a, b, c)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (a, b, c, d)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e) => GHC.Classes.Eq (a, b, c, d, e)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (a, b, c, d, e, f)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g) => GHC.Classes.Eq (a, b, c, d, e, f, g)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h) => GHC.Classes.Eq (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Classes.Eq GHC.Types.Module
instance GHC.Classes.Eq GHC.Types.Bool
instance GHC.Classes.Eq GHC.Types.Ordering
instance GHC.Classes.Ord ()
instance GHC.Classes.Ord a => GHC.Classes.Ord (Solo a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (a, b, c)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (a, b, c, d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e) => GHC.Classes.Ord (a, b, c, d, e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f) => GHC.Classes.Ord (a, b, c, d, e, f)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g) => GHC.Classes.Ord (a, b, c, d, e, f, g)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h) => GHC.Classes.Ord (a, b, c, d, e, f, g, h)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n, GHC.Classes.Ord o) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance GHC.Classes.Ord GHC.Types.Bool
instance GHC.Classes.Ord GHC.Types.Ordering
instance GHC.Classes.Ord GHC.Types.TyCon
instance GHC.Classes.Ord a => GHC.Classes.Ord [a]
instance GHC.Classes.Ord GHC.Types.Char
instance GHC.Classes.Ord GHC.Types.Float
instance GHC.Classes.Ord GHC.Types.Double
instance GHC.Classes.Ord GHC.Types.Int
instance GHC.Classes.Ord GHC.Types.Word
instance GHC.Classes.Eq a => GHC.Classes.Eq [a]
instance GHC.Classes.Eq GHC.Types.TrName
instance GHC.Classes.Eq GHC.Types.Word
instance GHC.Classes.Eq GHC.Types.Char
instance GHC.Classes.Eq GHC.Types.Float
instance GHC.Classes.Eq GHC.Types.Double
instance GHC.Classes.Eq GHC.Types.Int
instance GHC.Classes.Eq GHC.Types.TyCon
