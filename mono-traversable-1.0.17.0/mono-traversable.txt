-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes for mapping, folding, and traversing monomorphic containers
--   
--   Please see the README at
--   <a>https://www.stackage.org/package/mono-traversable</a>
@package mono-traversable
@version 1.0.17.0


-- | Type classes mirroring standard typeclasses, but working with
--   monomorphic containers.
--   
--   The motivation is that some commonly used data types (i.e.,
--   <tt>ByteString</tt> and <tt>Text</tt>) do not allow for instances of
--   typeclasses like <a>Functor</a> and <tt>Foldable</tt>, since they are
--   monomorphic structures. This module allows both monomorphic and
--   polymorphic data types to be instances of the same typeclasses.
--   
--   All of the laws for the polymorphic typeclasses apply to their
--   monomorphic cousins. Thus, even though a <a>MonoFunctor</a> instance
--   for <a>Set</a> could theoretically be defined, it is omitted since it
--   could violate the functor law of <tt><a>omap</a> f . <a>omap</a> g =
--   <a>omap</a> (f . g)</tt>.
--   
--   Note that all typeclasses have been prefixed with <tt>Mono</tt>, and
--   functions have been prefixed with <tt>o</tt>. The mnemonic for
--   <tt>o</tt> is "only one", or alternatively "it's mono, but m is
--   overused in Haskell, so we'll use the second letter instead." (Agreed,
--   it's not a great mangling scheme, input is welcome!)
module Data.MonoTraversable

-- | Type family for getting the type of the elements of a monomorphic
--   container.
type family Element mono

-- | Monomorphic containers that can be mapped over.
class MonoFunctor mono

-- | Map over a monomorphic container
omap :: MonoFunctor mono => (Element mono -> Element mono) -> mono -> mono

-- | Map over a monomorphic container
omap :: (MonoFunctor mono, Functor f, Element (f a) ~ a, f a ~ mono) => (Element mono -> Element mono) -> mono -> mono

-- | <tt><a>replaceElem</a> old new</tt> replaces all <tt>old</tt> elements
--   with <tt>new</tt>.
replaceElem :: (MonoFunctor mono, Eq (Element mono)) => Element mono -> Element mono -> mono -> mono
replaceElemStrictText :: Char -> Char -> Text -> Text
replaceElemLazyText :: Char -> Char -> Text -> Text

-- | Monomorphic containers that can be folded.
class MonoFoldable mono

-- | Map each element of a monomorphic container to a <a>Monoid</a> and
--   combine the results.
ofoldMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m

-- | Map each element of a monomorphic container to a <a>Monoid</a> and
--   combine the results.
ofoldMap :: (MonoFoldable mono, t a ~ mono, a ~ Element (t a), Foldable t, Monoid m) => (Element mono -> m) -> mono -> m

-- | Right-associative fold of a monomorphic container.
ofoldr :: MonoFoldable mono => (Element mono -> b -> b) -> b -> mono -> b

-- | Right-associative fold of a monomorphic container.
ofoldr :: (MonoFoldable mono, t a ~ mono, a ~ Element (t a), Foldable t) => (Element mono -> b -> b) -> b -> mono -> b

-- | Strict left-associative fold of a monomorphic container.
ofoldl' :: MonoFoldable mono => (a -> Element mono -> a) -> a -> mono -> a

-- | Strict left-associative fold of a monomorphic container.
ofoldl' :: (MonoFoldable mono, t b ~ mono, b ~ Element (t b), Foldable t) => (a -> Element mono -> a) -> a -> mono -> a

-- | Convert a monomorphic container to a list.
otoList :: MonoFoldable mono => mono -> [Element mono]

-- | Are <b>all</b> of the elements in a monomorphic container converted to
--   booleans <a>True</a>?
oall :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Are <b>any</b> of the elements in a monomorphic container converted to
--   booleans <a>True</a>?
oany :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Is the monomorphic container empty?
onull :: MonoFoldable mono => mono -> Bool

-- | Length of a monomorphic container, returns a <a>Int</a>.
olength :: MonoFoldable mono => mono -> Int

-- | Length of a monomorphic container, returns a <a>Int64</a>.
olength64 :: MonoFoldable mono => mono -> Int64

-- | Compare the length of a monomorphic container and a given number.
ocompareLength :: (MonoFoldable mono, Integral i) => mono -> i -> Ordering

-- | Map each element of a monomorphic container to an action, evaluate
--   these actions from left to right, and ignore the results.
otraverse_ :: (MonoFoldable mono, Applicative f) => (Element mono -> f b) -> mono -> f ()

-- | <a>ofor_</a> is <a>otraverse_</a> with its arguments flipped.
ofor_ :: (MonoFoldable mono, Applicative f) => mono -> (Element mono -> f b) -> f ()

-- | Map each element of a monomorphic container to a monadic action,
--   evaluate these actions from left to right, and ignore the results.
omapM_ :: (MonoFoldable mono, Applicative m) => (Element mono -> m ()) -> mono -> m ()

-- | <a>oforM_</a> is <a>omapM_</a> with its arguments flipped.
oforM_ :: (MonoFoldable mono, Applicative m) => mono -> (Element mono -> m ()) -> m ()

-- | Monadic fold over the elements of a monomorphic container, associating
--   to the left.
ofoldlM :: (MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldMap1</a> from <a>Data.NonNull</a> for a total version
--   of this function.</i>
ofoldMap1Ex :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> mono -> m

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldr1</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
ofoldr1Ex :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldr1</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
ofoldr1Ex :: (MonoFoldable mono, t a ~ mono, a ~ Element (t a), Foldable t) => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldl1'</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
ofoldl1Ex' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>ofoldl1'</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
ofoldl1Ex' :: (MonoFoldable mono, t a ~ mono, a ~ Element (t a), Foldable t) => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Get the first element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>head</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
headEx :: MonoFoldable mono => mono -> Element mono

-- | Get the last element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>last</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
lastEx :: MonoFoldable mono => mono -> Element mono

-- | Equivalent to <a>headEx</a>.
unsafeHead :: MonoFoldable mono => mono -> Element mono

-- | Equivalent to <a>lastEx</a>.
unsafeLast :: MonoFoldable mono => mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>maximumBy</a> from <a>Data.NonNull</a> for a total version
--   of this function.</i>
maximumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>minimumBy</a> from <a>Data.NonNull</a> for a total version
--   of this function.</i>
minimumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono

-- | Checks if the monomorphic container includes the supplied element.
oelem :: (MonoFoldable mono, Eq (Element mono)) => Element mono -> mono -> Bool

-- | Checks if the monomorphic container does not include the supplied
--   element.
onotElem :: (MonoFoldable mono, Eq (Element mono)) => Element mono -> mono -> Bool

-- | Safe version of <a>headEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
headMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | Safe version of <a>lastEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
lastMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | <a>osum</a> computes the sum of the numbers of a monomorphic
--   container.
osum :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | <a>oproduct</a> computes the product of the numbers of a monomorphic
--   container.
oproduct :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | Are <b>all</b> of the elements <a>True</a>?
oand :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | Are <b>any</b> of the elements <a>True</a>?
oor :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | Synonym for <a>ofoldMap</a>
oconcatMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m

-- | Monoidally combine all values in the container
ofold :: (MonoFoldable mono, Monoid (Element mono)) => mono -> Element mono

-- | Synonym for <a>ofold</a>
oconcat :: (MonoFoldable mono, Monoid (Element mono)) => mono -> Element mono

-- | Synonym for <a>ofoldlM</a>
ofoldM :: (MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a

-- | Perform all actions in the given container
osequence_ :: (Applicative m, MonoFoldable mono, Element mono ~ m ()) => mono -> m ()

-- | Get the minimum element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>maximum</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
maximumEx :: (MonoFoldable mono, Ord (Element mono)) => mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Note: this is a partial function. On an empty <a>MonoFoldable</a>, it
--   will throw an exception.
--   
--   <i>See <a>minimum</a> from <a>Data.NonNull</a> for a total version of
--   this function.</i>
minimumEx :: (MonoFoldable mono, Ord (Element mono)) => mono -> Element mono

-- | Safe version of <a>maximumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumMay :: (MonoFoldable mono, Ord (Element mono)) => mono -> Maybe (Element mono)

-- | Safe version of <a>maximumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Safe version of <a>minimumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumMay :: (MonoFoldable mono, Ord (Element mono)) => mono -> Maybe (Element mono)

-- | Safe version of <a>minimumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Monomorphic containers that can be traversed from left to right.
--   
--   NOTE: Due to limitations with the role system, GHC is yet unable to
--   provide newtype-derivation of <a>MonoTraversable</a>. See
--   <a>https://stackoverflow.com/questions/49776924/newtype-deriving-issequence</a>.
class (MonoFunctor mono, MonoFoldable mono) => MonoTraversable mono

-- | Map each element of a monomorphic container to an action, evaluate
--   these actions from left to right, and collect the results.
otraverse :: (MonoTraversable mono, Applicative f) => (Element mono -> f (Element mono)) -> mono -> f mono

-- | Map each element of a monomorphic container to an action, evaluate
--   these actions from left to right, and collect the results.
otraverse :: (MonoTraversable mono, Traversable t, mono ~ t a, a ~ Element mono, Applicative f) => (Element mono -> f (Element mono)) -> mono -> f mono

-- | Map each element of a monomorphic container to a monadic action,
--   evaluate these actions from left to right, and collect the results.
omapM :: (MonoTraversable mono, Applicative m) => (Element mono -> m (Element mono)) -> mono -> m mono

-- | <a>ofor</a> is <a>otraverse</a> with its arguments flipped.
ofor :: (MonoTraversable mono, Applicative f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | <a>oforM</a> is <a>omapM</a> with its arguments flipped.
oforM :: (MonoTraversable mono, Applicative f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | A strict left fold, together with an unwrap function.
--   
--   This is convenient when the accumulator value is not the same as the
--   final expected type. It is provided mainly for integration with the
--   <tt>foldl</tt> package, to be used in conjunction with
--   <tt>purely</tt>.
ofoldlUnwrap :: MonoFoldable mono => (x -> Element mono -> x) -> x -> (x -> b) -> mono -> b

-- | A monadic strict left fold, together with an unwrap function.
--   
--   Similar to <tt>foldlUnwrap</tt>, but allows monadic actions. To be
--   used with <tt>impurely</tt> from <tt>foldl</tt>.
ofoldMUnwrap :: (Monad m, MonoFoldable mono) => (x -> Element mono -> m x) -> m x -> (x -> m b) -> mono -> m b

-- | Typeclass for monomorphic containers that an element can be lifted
--   into.
--   
--   For any <a>MonoFunctor</a>, the following law holds:
--   
--   <pre>
--   <a>omap</a> f . <a>opoint</a> = <a>opoint</a> . f
--   </pre>
class MonoPointed mono

-- | Lift an element into a monomorphic container.
--   
--   <a>opoint</a> is the same as <a>pure</a> for an <a>Applicative</a>
opoint :: MonoPointed mono => Element mono -> mono

-- | Lift an element into a monomorphic container.
--   
--   <a>opoint</a> is the same as <a>pure</a> for an <a>Applicative</a>
opoint :: (MonoPointed mono, Applicative f, f a ~ mono, Element (f a) ~ a) => Element mono -> mono

-- | Typeclass for monomorphic containers where it is always okay to
--   "extract" a value from with <a>oextract</a>, and where you can
--   extrapolate any "extracting" function to be a function on the whole
--   part with <a>oextend</a>.
--   
--   <a>oextend</a> and <a>oextract</a> should work together following the
--   laws:
--   
--   <pre>
--   <a>oextend</a> <a>oextract</a>      = <a>id</a>
--   <a>oextract</a> . <a>oextend</a> f  = f
--   <a>oextend</a> f . <a>oextend</a> g = <a>oextend</a> (f . <a>oextend</a> g)
--   </pre>
--   
--   As an intuition, <tt><a>oextend</a> f</tt> uses <tt>f</tt> to "build
--   up" a new <tt>mono</tt> with pieces from the old one received by
--   <tt>f</tt>.
class MonoFunctor mono => MonoComonad mono

-- | Extract an element from <tt>mono</tt>. Can be thought of as a dual
--   concept to <tt>opoint</tt>.
oextract :: MonoComonad mono => mono -> Element mono

-- | <a>Extend</a> a <tt>mono -&gt; <a>Element</a> mono</tt> function to be
--   a <tt>mono -&gt; mono</tt>; that is, builds a new <tt>mono</tt> from
--   the old one by using pieces glimpsed from the given function.
oextend :: MonoComonad mono => (mono -> Element mono) -> mono -> mono

-- | Containers which, when two values are combined, the combined length is
--   no less than the larger of the two inputs. In code:
--   
--   <pre>
--   olength (x &lt;&gt; y) &gt;= max (olength x) (olength y)
--   </pre>
--   
--   This class has no methods, and is simply used to assert that this law
--   holds, in order to provide guarantees of correctness (see, for
--   instance, <a>Data.NonNull</a>).
--   
--   This should have a <tt>Semigroup</tt> superclass constraint, however,
--   due to <tt>Semigroup</tt> only recently moving to base, some packages
--   do not provide instances.
class MonoFoldable mono => GrowingAppend mono

-- | <tt>intercalate</tt> <tt>seq seqs</tt> inserts <tt>seq</tt> in between
--   <tt>seqs</tt> and concatenates the result.
ointercalate :: (MonoFoldable mono, Monoid (Element mono)) => Element mono -> mono -> Element mono

-- | Provides a <a>MonoFoldable</a>, <a>MonoFunctor</a> or
--   <a>MonoPointed</a> for an arbitrary <a>Foldable</a>, <a>Functor</a> or
--   <a>Applicative</a>.
--   
--   Useful for, e.g., passing a <a>Foldable</a> type you don't own into a
--   function that expects a <a>MonoFoldable</a>.
--   
--   <pre>
--   // package A
--   data MyList a = MyList [a] deriving Foldable
--   
--   // package B
--   process :: MonoFoldable mono =&gt; mono -&gt; IO ()
--   
--   // package C
--   process (WrappedPoly (MyList []))
--   </pre>
newtype WrappedPoly f a
WrappedPoly :: f a -> WrappedPoly f a
[unwrapPoly] :: WrappedPoly f a -> f a

-- | Provides a <a>Foldable</a> for an arbitrary <a>MonoFoldable</a>.
data WrappedMono mono a
[WrappedMono] :: Element mono ~ a => mono -> WrappedMono mono a

-- | Unwraps a <a>WrappedMono</a>.
unwrapMono :: WrappedMono mono a -> mono
instance GHC.Base.Monad f => GHC.Base.Monad (Data.MonoTraversable.WrappedPoly f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.MonoTraversable.WrappedPoly f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.MonoTraversable.WrappedPoly f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.MonoTraversable.WrappedPoly f)
instance Data.MonoTraversable.MonoFoldable mono => Data.MonoTraversable.MonoFoldable (Data.MonoTraversable.WrappedMono mono a)
instance Data.MonoTraversable.MonoFunctor mono => Data.MonoTraversable.MonoFunctor (Data.MonoTraversable.WrappedMono mono a)
instance (Data.MonoTraversable.MonoPointed mono, Data.MonoTraversable.Element mono GHC.Types.~ a) => Data.MonoTraversable.MonoPointed (Data.MonoTraversable.WrappedMono mono a)
instance Data.MonoTraversable.MonoFoldable mono => Data.Foldable.Foldable (Data.MonoTraversable.WrappedMono mono)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Data.MonoTraversable.WrappedPoly f a)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (Data.MonoTraversable.WrappedPoly f a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (Data.MonoTraversable.WrappedPoly f a)
instance Data.MonoTraversable.GrowingAppend (Data.Sequence.Internal.Seq a)
instance Data.MonoTraversable.GrowingAppend [a]
instance Data.MonoTraversable.GrowingAppend (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.GrowingAppend (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.GrowingAppend (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.GrowingAppend Data.ByteString.Internal.Type.ByteString
instance Data.MonoTraversable.GrowingAppend Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.GrowingAppend Data.Text.Internal.Text
instance Data.MonoTraversable.GrowingAppend Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.GrowingAppend (GHC.Base.NonEmpty a)
instance GHC.Classes.Ord k => Data.MonoTraversable.GrowingAppend (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.MonoTraversable.GrowingAppend (Data.HashMap.Internal.HashMap k v)
instance GHC.Classes.Ord v => Data.MonoTraversable.GrowingAppend (Data.Set.Internal.Set v)
instance (GHC.Classes.Eq v, Data.Hashable.Class.Hashable v) => Data.MonoTraversable.GrowingAppend (Data.HashSet.Internal.HashSet v)
instance Data.MonoTraversable.GrowingAppend Data.IntSet.Internal.IntSet
instance Data.MonoTraversable.GrowingAppend (Data.IntMap.Internal.IntMap v)
instance Data.MonoTraversable.MonoComonad (Data.Sequence.Internal.ViewL a)
instance Data.MonoTraversable.MonoComonad (Data.Sequence.Internal.ViewR a)
instance Data.MonoTraversable.MonoPointed Data.ByteString.Internal.Type.ByteString
instance Data.MonoTraversable.MonoPointed Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoPointed Data.ByteString.Builder.Internal.Builder
instance Data.MonoTraversable.MonoPointed Data.Text.Internal.Text
instance Data.MonoTraversable.MonoPointed Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoPointed [a]
instance Data.MonoTraversable.MonoPointed (GHC.Maybe.Maybe a)
instance Data.MonoTraversable.MonoPointed (GHC.Base.NonEmpty a)
instance Data.MonoTraversable.MonoPointed (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoPointed (Data.Vector.Vector a)
instance Data.MonoTraversable.MonoPointed (GHC.Types.IO a)
instance Data.MonoTraversable.MonoPointed (Control.Applicative.ZipList a)
instance Data.MonoTraversable.MonoPointed (r -> a)
instance GHC.Base.Monoid a => Data.MonoTraversable.MonoPointed (a, b)
instance GHC.Base.Monoid m => Data.MonoTraversable.MonoPointed (Data.Functor.Const.Const m a)
instance GHC.Base.Monad m => Data.MonoTraversable.MonoPointed (Control.Applicative.WrappedMonad m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Identity.IdentityT m a)
instance Control.Arrow.Arrow a => Data.MonoTraversable.MonoPointed (Control.Applicative.WrappedArrow a b c)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Reader.ReaderT r m a)
instance Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Cont.ContT r m a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed (Data.Functor.Product.Product f g a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed ((GHC.Generics.:.:) f g a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed ((GHC.Generics.:*:) f g a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (GHC.Generics.M1 i c f a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (GHC.Generics.Rec1 f a)
instance Data.MonoTraversable.MonoPointed (GHC.Generics.Par1 a)
instance Data.MonoTraversable.MonoPointed (GHC.Generics.U1 a)
instance Data.MonoTraversable.MonoPointed (Data.Proxy.Proxy a)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.Internal.Seq a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoPointed (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoPointed (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoPointed (Data.Either.Either a b)
instance Data.MonoTraversable.MonoPointed Data.IntSet.Internal.IntSet
instance Data.MonoTraversable.MonoPointed (Data.Set.Internal.Set a)
instance Data.Hashable.Class.Hashable a => Data.MonoTraversable.MonoPointed (Data.HashSet.Internal.HashSet a)
instance GHC.Base.Applicative f => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.Maybe.MaybeT f a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance (GHC.Base.Monoid w, GHC.Base.Applicative m) => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.State.Lazy.StateT s m a)
instance GHC.Base.Applicative m => Data.MonoTraversable.MonoPointed (Control.Monad.Trans.State.Strict.StateT s m a)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.Internal.ViewL a)
instance Data.MonoTraversable.MonoPointed (Data.Sequence.Internal.ViewR a)
instance Data.MonoTraversable.MonoPointed (Data.Tree.Tree a)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => Data.MonoTraversable.MonoPointed ((GHC.Generics.:+:) f g a)
instance Data.MonoTraversable.MonoTraversable Data.ByteString.Internal.Type.ByteString
instance Data.MonoTraversable.MonoTraversable Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoTraversable Data.Text.Internal.Text
instance Data.MonoTraversable.MonoTraversable Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoTraversable [a]
instance Data.MonoTraversable.MonoTraversable (GHC.Maybe.Maybe a)
instance Data.MonoTraversable.MonoTraversable (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.Internal.Seq a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.Internal.ViewL a)
instance Data.MonoTraversable.MonoTraversable (Data.Sequence.Internal.ViewR a)
instance Data.MonoTraversable.MonoTraversable (Data.IntMap.Internal.IntMap a)
instance Data.MonoTraversable.MonoTraversable (GHC.Base.NonEmpty a)
instance Data.MonoTraversable.MonoTraversable (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoTraversable (Data.Map.Internal.Map k v)
instance Data.MonoTraversable.MonoTraversable (Data.HashMap.Internal.HashMap k v)
instance Data.MonoTraversable.MonoTraversable (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoTraversable (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoTraversable (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoTraversable (Data.Either.Either a b)
instance Data.MonoTraversable.MonoTraversable (a, b)
instance Data.MonoTraversable.MonoTraversable (Data.Functor.Const.Const m a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Maybe.MaybeT f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable (Data.Functor.Compose.Compose f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable (Data.Functor.Product.Product f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable ((GHC.Generics.:.:) f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable ((GHC.Generics.:*:) f g a)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.MonoTraversable.MonoTraversable ((GHC.Generics.:+:) f g a)
instance Data.MonoTraversable.MonoTraversable (GHC.Generics.K1 i c a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (GHC.Generics.M1 i c f a)
instance Data.Traversable.Traversable f => Data.MonoTraversable.MonoTraversable (GHC.Generics.Rec1 f a)
instance Data.MonoTraversable.MonoTraversable (GHC.Generics.Par1 a)
instance Data.MonoTraversable.MonoTraversable (GHC.Generics.U1 a)
instance Data.MonoTraversable.MonoTraversable (GHC.Generics.V1 a)
instance Data.MonoTraversable.MonoTraversable (Data.Proxy.Proxy a)
instance Data.MonoTraversable.MonoFoldable Data.ByteString.Internal.Type.ByteString
instance Data.MonoTraversable.MonoFoldable Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFoldable Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFoldable Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFoldable Data.IntSet.Internal.IntSet
instance Data.MonoTraversable.MonoFoldable [a]
instance Data.MonoTraversable.MonoFoldable (GHC.Maybe.Maybe a)
instance Data.MonoTraversable.MonoFoldable (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.Internal.Seq a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.Internal.ViewL a)
instance Data.MonoTraversable.MonoFoldable (Data.Sequence.Internal.ViewR a)
instance Data.MonoTraversable.MonoFoldable (Data.IntMap.Internal.IntMap a)
instance Data.MonoTraversable.MonoFoldable (GHC.Base.NonEmpty a)
instance Data.MonoTraversable.MonoFoldable (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoFoldable (Data.Map.Internal.Map k v)
instance Data.MonoTraversable.MonoFoldable (Data.HashMap.Internal.HashMap k v)
instance Data.MonoTraversable.MonoFoldable (Data.Vector.Vector a)
instance GHC.Classes.Ord e => Data.MonoTraversable.MonoFoldable (Data.Set.Internal.Set e)
instance Data.MonoTraversable.MonoFoldable (Data.HashSet.Internal.HashSet e)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoFoldable (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoFoldable (Data.Vector.Storable.Vector a)
instance Data.MonoTraversable.MonoFoldable (Data.Either.Either a b)
instance Data.MonoTraversable.MonoFoldable (a, b)
instance Data.MonoTraversable.MonoFoldable (Data.Functor.Const.Const m a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Maybe.MaybeT f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Identity.IdentityT f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Writer.Lazy.WriterT w f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (Control.Monad.Trans.Writer.Strict.WriterT w f a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable (Data.Functor.Compose.Compose f g a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable (Data.Functor.Product.Product f g a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable ((GHC.Generics.:.:) f g a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable ((GHC.Generics.:*:) f g a)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.MonoTraversable.MonoFoldable ((GHC.Generics.:+:) f g a)
instance Data.MonoTraversable.MonoFoldable (GHC.Generics.K1 i c a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (GHC.Generics.M1 i c f a)
instance Data.Foldable.Foldable f => Data.MonoTraversable.MonoFoldable (GHC.Generics.Rec1 f a)
instance Data.MonoTraversable.MonoFoldable (GHC.Generics.Par1 a)
instance Data.MonoTraversable.MonoFoldable (GHC.Generics.U1 a)
instance Data.MonoTraversable.MonoFoldable (GHC.Generics.V1 a)
instance Data.MonoTraversable.MonoFoldable (Data.Proxy.Proxy a)
instance Data.MonoTraversable.MonoFunctor Data.ByteString.Internal.Type.ByteString
instance Data.MonoTraversable.MonoFunctor Data.ByteString.Lazy.Internal.ByteString
instance Data.MonoTraversable.MonoFunctor Data.Text.Internal.Text
instance Data.MonoTraversable.MonoFunctor Data.Text.Internal.Lazy.Text
instance Data.MonoTraversable.MonoFunctor [a]
instance Data.MonoTraversable.MonoFunctor (GHC.Types.IO a)
instance Data.MonoTraversable.MonoFunctor (Control.Applicative.ZipList a)
instance Data.MonoTraversable.MonoFunctor (GHC.Maybe.Maybe a)
instance Data.MonoTraversable.MonoFunctor (Data.Tree.Tree a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.Internal.Seq a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.Internal.ViewL a)
instance Data.MonoTraversable.MonoFunctor (Data.Sequence.Internal.ViewR a)
instance Data.MonoTraversable.MonoFunctor (Data.IntMap.Internal.IntMap a)
instance Data.MonoTraversable.MonoFunctor (GHC.Base.NonEmpty a)
instance Data.MonoTraversable.MonoFunctor (Data.Functor.Identity.Identity a)
instance Data.MonoTraversable.MonoFunctor (r -> a)
instance Data.MonoTraversable.MonoFunctor (Data.Either.Either a b)
instance Data.MonoTraversable.MonoFunctor (a, b)
instance Data.MonoTraversable.MonoFunctor (Data.Functor.Const.Const m a)
instance GHC.Base.Monad m => Data.MonoTraversable.MonoFunctor (Control.Applicative.WrappedMonad m a)
instance Data.MonoTraversable.MonoFunctor (Data.Map.Internal.Map k v)
instance Data.MonoTraversable.MonoFunctor (Data.HashMap.Internal.HashMap k v)
instance Data.MonoTraversable.MonoFunctor (Data.Vector.Vector a)
instance Data.MonoTraversable.MonoFunctor (Data.Semigroup.Arg a b)
instance Control.Arrow.Arrow a => Data.MonoTraversable.MonoFunctor (Control.Applicative.WrappedArrow a b c)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Maybe.MaybeT m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Identity.IdentityT m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Writer.Lazy.WriterT w m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Writer.Strict.WriterT w m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.State.Lazy.StateT s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.State.Strict.StateT s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.RWS.Lazy.RWST r w s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.RWS.Strict.RWST r w s m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Reader.ReaderT r m a)
instance GHC.Base.Functor m => Data.MonoTraversable.MonoFunctor (Control.Monad.Trans.Cont.ContT r m a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor (Data.Functor.Compose.Compose f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor (Data.Functor.Product.Product f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor ((GHC.Generics.:.:) f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor ((GHC.Generics.:*:) f g a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => Data.MonoTraversable.MonoFunctor ((GHC.Generics.:+:) f g a)
instance Data.MonoTraversable.MonoFunctor (GHC.Generics.K1 i c a)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (GHC.Generics.M1 i c f a)
instance GHC.Base.Functor f => Data.MonoTraversable.MonoFunctor (GHC.Generics.Rec1 f a)
instance Data.MonoTraversable.MonoFunctor (GHC.Generics.Par1 a)
instance Data.MonoTraversable.MonoFunctor (GHC.Generics.U1 a)
instance Data.MonoTraversable.MonoFunctor (GHC.Generics.V1 a)
instance Data.MonoTraversable.MonoFunctor (Data.Proxy.Proxy a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.MonoTraversable.MonoFunctor (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.MonoTraversable.MonoFunctor (Data.Vector.Storable.Vector a)


module Data.Containers

-- | A container whose values are stored in Key-Value pairs.
class (Monoid set, Semigroup set, MonoFoldable set, Eq (ContainerKey set), GrowingAppend set) => SetContainer set where {
    
    -- | The type of the key
    type ContainerKey set;
}

-- | Check if there is a value with the supplied key in the container.
member :: SetContainer set => ContainerKey set -> set -> Bool

-- | Check if there isn't a value with the supplied key in the container.
notMember :: SetContainer set => ContainerKey set -> set -> Bool

-- | Get the union of two containers.
union :: SetContainer set => set -> set -> set

-- | Combine a collection of <tt>SetContainer</tt>s, with left-most values
--   overriding when there are matching keys.
unions :: (SetContainer set, MonoFoldable mono, Element mono ~ set) => mono -> set

-- | Get the difference of two containers.
difference :: SetContainer set => set -> set -> set

-- | Get the intersection of two containers.
intersection :: SetContainer set => set -> set -> set

-- | Get a list of all of the keys in the container.
keys :: SetContainer set => set -> [ContainerKey set]

-- | A guaranteed-polymorphic <tt>Map</tt>, which allows for more
--   polymorphic versions of functions.
class PolyMap map

-- | Get the difference between two maps, using the left map's values.
differenceMap :: PolyMap map => map value1 -> map value2 -> map value1

-- | Get the intersection of two maps, using the left map's values.
intersectionMap :: PolyMap map => map value1 -> map value2 -> map value1

-- | Get the intersection of two maps with a supplied function that takes
--   in the left map's value and the right map's value.
intersectionWithMap :: PolyMap map => (value1 -> value2 -> value3) -> map value1 -> map value2 -> map value3

-- | A <tt>Map</tt> type polymorphic in both its key and value.
class BiPolyMap map where {
    type BPMKeyConstraint map key :: Constraint;
}
mapKeysWith :: (BiPolyMap map, BPMKeyConstraint map k1, BPMKeyConstraint map k2) => (v -> v -> v) -> (k1 -> k2) -> map k1 v -> map k2 v

-- | Polymorphic typeclass for interacting with different map types
class (MonoTraversable map, SetContainer map) => IsMap map where {
    
    -- | In some cases, <a>MapValue</a> and <a>Element</a> will be different,
    --   e.g., the <a>IsMap</a> instance of associated lists.
    type MapValue map;
}

-- | Look up a value in a map with a specified key.
lookup :: IsMap map => ContainerKey map -> map -> Maybe (MapValue map)

-- | Insert a key-value pair into a map.
insertMap :: IsMap map => ContainerKey map -> MapValue map -> map -> map

-- | Delete a key-value pair of a map using a specified key.
deleteMap :: IsMap map => ContainerKey map -> map -> map

-- | Create a map from a single key-value pair.
singletonMap :: IsMap map => ContainerKey map -> MapValue map -> map

-- | Convert a list of key-value pairs to a map
mapFromList :: IsMap map => [(ContainerKey map, MapValue map)] -> map

-- | Convert a map to a list of key-value pairs.
mapToList :: IsMap map => map -> [(ContainerKey map, MapValue map)]

-- | Like <a>lookup</a>, but uses a default value when the key does not
--   exist in the map.
findWithDefault :: IsMap map => MapValue map -> ContainerKey map -> map -> MapValue map

-- | Insert a key-value pair into a map.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the new value and
--   the previous value and insert that result into the map.
insertWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map

-- | Insert a key-value pair into a map.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the key, the new
--   value, and the previous value and insert that result into the map.
insertWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map

-- | Insert a key-value pair into a map, return the previous key's value if
--   it existed.
--   
--   Inserts the value directly if the key does not exist in the map.
--   Otherwise, apply a supplied function that accepts the key, the new
--   value, and the previous value and insert that result into the map.
insertLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> (Maybe (MapValue map), map)

-- | Apply a function to the value of a given key.
--   
--   Returns the input map when the key-value pair does not exist.
adjustMap :: IsMap map => (MapValue map -> MapValue map) -> ContainerKey map -> map -> map

-- | Equivalent to <a>adjustMap</a>, but the function accepts the key, as
--   well as the previous value.
adjustWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> ContainerKey map -> map -> map

-- | Apply a function to the value of a given key.
--   
--   If the function returns <a>Nothing</a>, this deletes the key-value
--   pair.
--   
--   Returns the input map when the key-value pair does not exist.
updateMap :: IsMap map => (MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Equivalent to <a>updateMap</a>, but the function accepts the key, as
--   well as the previous value.
updateWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Apply a function to the value of a given key.
--   
--   If the map does not contain the key this returns <a>Nothing</a> and
--   the input map.
--   
--   If the map does contain the key but the function returns
--   <a>Nothing</a>, this returns the previous value and the map with the
--   key-value pair removed.
--   
--   If the map contains the key and the function returns a value, this
--   returns the new value and the map with the key-value pair with the new
--   value.
updateLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> (Maybe (MapValue map), map)

-- | Update/Delete the value of a given key.
--   
--   Applies a function to previous value of a given key, if it results in
--   <a>Nothing</a> delete the key-value pair from the map, otherwise
--   replace the previous value with the new value.
alterMap :: IsMap map => (Maybe (MapValue map) -> Maybe (MapValue map)) -> ContainerKey map -> map -> map

-- | Combine two maps.
--   
--   When a key exists in both maps, apply a function to both of the values
--   and use the result of that as the value of the key in the resulting
--   map.
unionWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> map -> map -> map
unionWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> map -> map -> map

-- | Combine a list of maps.
--   
--   When a key exists in two different maps, apply a function to both of
--   the values and use the result of that as the value of the key in the
--   resulting map.
unionsWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> [map] -> map

-- | Apply a function over every key-value pair of a map.
mapWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> map -> map

-- | Apply a function over every key of a pair and run <a>unionsWith</a>
--   over the results.
omapKeysWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> (ContainerKey map -> ContainerKey map) -> map -> map

-- | Filter values in a map.
filterMap :: (IsMap map, IsMap map) => (MapValue map -> Bool) -> map -> map

-- | Polymorphic typeclass for interacting with different set types
class (SetContainer set, Element set ~ ContainerKey set) => IsSet set

-- | Insert a value into a set.
insertSet :: IsSet set => Element set -> set -> set

-- | Delete a value from a set.
deleteSet :: IsSet set => Element set -> set -> set

-- | Create a set from a single element.
singletonSet :: IsSet set => Element set -> set

-- | Convert a list to a set.
setFromList :: IsSet set => [Element set] -> set

-- | Convert a set to a list.
setToList :: IsSet set => set -> [Element set]

-- | Filter values in a set.
filterSet :: IsSet set => (Element set -> Bool) -> set -> set

-- | Zip operations on <a>MonoFunctor</a>s.
class MonoFunctor mono => MonoZip mono

-- | Combine each element of two <a>MonoZip</a>s using a supplied function.
ozipWith :: MonoZip mono => (Element mono -> Element mono -> Element mono) -> mono -> mono -> mono

-- | Take two <a>MonoZip</a>s and return a list of the pairs of their
--   elements.
ozip :: MonoZip mono => mono -> mono -> [(Element mono, Element mono)]

-- | Take a list of pairs of elements and return a <a>MonoZip</a> of the
--   first components and a <a>MonoZip</a> of the second components.
ounzip :: MonoZip mono => [(Element mono, Element mono)] -> (mono, mono)

-- | Type class for maps whose keys can be converted into sets.
class SetContainer set => HasKeysSet set where {
    
    -- | Type of the key set.
    type KeySet set;
}

-- | Convert a map into a set of its keys.
keysSet :: HasKeysSet set => set -> KeySet set
instance GHC.Classes.Ord k => Data.Containers.HasKeysSet (Data.Map.Internal.Map k v)
instance Data.Containers.HasKeysSet (Data.IntMap.Internal.IntMap v)
instance (Data.Hashable.Class.Hashable k, GHC.Classes.Eq k) => Data.Containers.HasKeysSet (Data.HashMap.Internal.HashMap k v)
instance Data.Containers.MonoZip Data.ByteString.Internal.Type.ByteString
instance Data.Containers.MonoZip Data.ByteString.Lazy.Internal.ByteString
instance Data.Containers.MonoZip Data.Text.Internal.Text
instance Data.Containers.MonoZip Data.Text.Internal.Lazy.Text
instance GHC.Classes.Ord element => Data.Containers.IsSet (Data.Set.Internal.Set element)
instance (GHC.Classes.Eq element, Data.Hashable.Class.Hashable element) => Data.Containers.IsSet (Data.HashSet.Internal.HashSet element)
instance Data.Containers.IsSet Data.IntSet.Internal.IntSet
instance GHC.Classes.Eq key => Data.Containers.SetContainer [(key, value)]
instance Data.Containers.BiPolyMap Data.HashMap.Internal.HashMap
instance GHC.Classes.Ord key => Data.Containers.IsMap (Data.Map.Internal.Map key value)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.IsMap (Data.HashMap.Internal.HashMap key value)
instance Data.Containers.IsMap (Data.IntMap.Internal.IntMap value)
instance GHC.Classes.Eq key => Data.Containers.IsMap [(key, value)]
instance Data.Containers.BiPolyMap Data.Map.Internal.Map
instance GHC.Classes.Ord key => Data.Containers.PolyMap (Data.Map.Internal.Map key)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.PolyMap (Data.HashMap.Internal.HashMap key)
instance Data.Containers.PolyMap Data.IntMap.Internal.IntMap
instance GHC.Classes.Ord k => Data.Containers.SetContainer (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq key, Data.Hashable.Class.Hashable key) => Data.Containers.SetContainer (Data.HashMap.Internal.HashMap key value)
instance Data.Containers.SetContainer (Data.IntMap.Internal.IntMap value)
instance GHC.Classes.Ord element => Data.Containers.SetContainer (Data.Set.Internal.Set element)
instance (GHC.Classes.Eq element, Data.Hashable.Class.Hashable element) => Data.Containers.SetContainer (Data.HashSet.Internal.HashSet element)
instance Data.Containers.SetContainer Data.IntSet.Internal.IntSet


-- | The functions in <a>Data.MonoTraversable</a> are all prefixed with the
--   letter <tt>o</tt> to avoid conflicts with their polymorphic
--   counterparts. This module exports the same identifiers without the
--   prefix, for all cases where the monomorphic variant loses no
--   generality versus the polymorphic version. For example, <a>olength</a>
--   is just as general as <tt>Data.Foldable.length</tt>, so we export
--   <tt>length = length</tt>. By contrast, <a>omap</a> cannot fully
--   subsume <tt>fmap</tt> or <tt>map</tt>, so we do not provide such an
--   export.
module Data.MonoTraversable.Unprefixed

-- | Synonym for <a>ofoldMap</a>
foldMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m

-- | Synonym for <a>ofoldr</a>
foldr :: MonoFoldable mono => (Element mono -> b -> b) -> b -> mono -> b

-- | Synonym for <a>ofoldl'</a>
foldl' :: MonoFoldable mono => (a -> Element mono -> a) -> a -> mono -> a

-- | Synonym for <a>otoList</a>
toList :: MonoFoldable mono => mono -> [Element mono]

-- | Synonym for <a>oall</a>
all :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Synonym for <a>oany</a>
any :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool

-- | Synonym for <a>onull</a>
null :: MonoFoldable mono => mono -> Bool

-- | Synonym for <a>olength</a>
length :: MonoFoldable mono => mono -> Int

-- | Synonym for <a>olength64</a>
length64 :: MonoFoldable mono => mono -> Int64

-- | Synonym for <a>ocompareLength</a>
compareLength :: (MonoFoldable mono, Integral i) => mono -> i -> Ordering

-- | Synonym for <a>otraverse_</a>
traverse_ :: (MonoFoldable mono, Applicative f) => (Element mono -> f b) -> mono -> f ()

-- | Synonym for <a>ofor_</a>
for_ :: (MonoFoldable mono, Applicative f) => mono -> (Element mono -> f b) -> f ()

-- | Synonym for <a>omapM_</a>
mapM_ :: (MonoFoldable mono, Applicative m) => (Element mono -> m ()) -> mono -> m ()

-- | Synonym for <a>oforM_</a>
forM_ :: (MonoFoldable mono, Applicative m) => mono -> (Element mono -> m ()) -> m ()

-- | Synonym for <a>ofoldlM</a>
foldlM :: (MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a

-- | Synonym for <a>ofoldMap1Ex</a>
foldMap1Ex :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> mono -> m

-- | Synonym for <a>ofoldr1Ex</a>
foldr1Ex :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Synonym for <a>ofoldl1Ex'</a>
foldl1Ex' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono

-- | Synonym for <a>osum</a>
sum :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | Synonym for <a>oproduct</a>
product :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | Synonym for <a>oand</a>
and :: (MonoFoldable mono, Element mono ~ Bool) => mono -> Bool

-- | Synonym for <a>oor</a>
or :: (MonoFoldable mono, Element mono ~ Bool) => mono -> Bool

-- | Synonym for <a>oconcatMap</a>
concatMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m

-- | Synonym for <a>oelem</a>
elem :: (MonoFoldable mono, Eq (Element mono)) => Element mono -> mono -> Bool

-- | Synonym for <a>onotElem</a>
notElem :: (MonoFoldable mono, Eq (Element mono)) => Element mono -> mono -> Bool

-- | Synonym for <a>opoint</a>
point :: MonoPointed mono => Element mono -> mono

-- | Synonym for <a>ointercalate</a>
intercalate :: (MonoFoldable mono, Monoid (Element mono)) => Element mono -> mono -> Element mono

-- | Synonym for <a>ofold</a>
fold :: (MonoFoldable mono, Monoid (Element mono)) => mono -> Element mono

-- | Synonym for <a>oconcat</a>
concat :: (MonoFoldable mono, Monoid (Element mono)) => mono -> Element mono

-- | Synonym for <a>ofoldM</a>
foldM :: (MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a

-- | Synonym for <a>osequence_</a>
sequence_ :: (Applicative m, MonoFoldable mono, Element mono ~ m ()) => mono -> m ()


-- | Abstractions over sequential data structures, like lists and vectors.
module Data.Sequences

-- | <a>SemiSequence</a> was created to share code between
--   <a>IsSequence</a> and <tt>NonNull</tt>.
--   
--   <tt>Semi</tt> means <tt>SemiGroup</tt> A <a>SemiSequence</a> can
--   accommodate a <tt>SemiGroup</tt> such as <tt>NonEmpty</tt> or
--   <tt>NonNull</tt> A Monoid should be able to fill out
--   <a>IsSequence</a>.
--   
--   <a>SemiSequence</a> operations maintain the same type because they all
--   maintain the same number of elements or increase them. However, a
--   decreasing function such as filter may change they type. For example,
--   from <tt>NonEmpty</tt> to '[]' This type-changing function exists on
--   <tt>NonNull</tt> as <tt>nfilter</tt>
--   
--   <a>filter</a> and other such functions are placed in <a>IsSequence</a>
--   
--   <i>NOTE</i>: Like <a>GrowingAppend</a>, ideally we'd have a
--   <tt>Semigroup</tt> superclass constraint here, but that would pull in
--   more dependencies to this package than desired.
class (Integral (Index seq), GrowingAppend seq) => SemiSequence seq where {
    
    -- | The type of the index of a sequence.
    type Index seq;
}

-- | <a>intersperse</a> takes an element and intersperses that element
--   between the elements of the sequence.
--   
--   <pre>
--   &gt; <a>intersperse</a> ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: SemiSequence seq => Element seq -> seq -> seq

-- | Reverse a sequence
--   
--   <pre>
--   &gt; <a>reverse</a> "hello world"
--   "dlrow olleh"
--   </pre>
reverse :: SemiSequence seq => seq -> seq

-- | <a>find</a> takes a predicate and a sequence and returns the first
--   element in the sequence matching the predicate, or <a>Nothing</a> if
--   there isn't an element that matches the predicate.
--   
--   <pre>
--   &gt; <a>find</a> (== 5) [1 .. 10]
--   <a>Just</a> 5
--   
--   &gt; <a>find</a> (== 15) [1 .. 10]
--   <a>Nothing</a>
--   </pre>
find :: SemiSequence seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)

-- | Sort a sequence using an supplied element ordering function.
--   
--   <pre>
--   &gt; let compare' x y = case <a>compare</a> x y of LT -&gt; GT; EQ -&gt; EQ; GT -&gt; LT
--   &gt; <a>sortBy</a> compare' [5,3,6,1,2,4]
--   [6,5,4,3,2,1]
--   </pre>
sortBy :: SemiSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq

-- | Prepend an element onto a sequence.
--   
--   <pre>
--   &gt; 4 `<a>cons</a>` [1,2,3]
--   [4,1,2,3]
--   </pre>
cons :: SemiSequence seq => Element seq -> seq -> seq

-- | Append an element onto a sequence.
--   
--   <pre>
--   &gt; [1,2,3] `<a>snoc</a>` 4
--   [1,2,3,4]
--   </pre>
snoc :: SemiSequence seq => seq -> Element seq -> seq

-- | Create a sequence from a single element.
--   
--   <pre>
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>String</tt>
--   "a"
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>Vector</tt> <a>Char</a>
--   <a>fromList</a> "a"
--   </pre>
singleton :: MonoPointed seq => Element seq -> seq

-- | Sequence Laws:
--   
--   <pre>
--   <a>fromList</a> . <a>otoList</a> = <a>id</a>
--   <a>fromList</a> (x &lt;&gt; y) = <a>fromList</a> x &lt;&gt; <a>fromList</a> y
--   <a>otoList</a> (<a>fromList</a> x &lt;&gt; <a>fromList</a> y) = x &lt;&gt; y
--   </pre>
class (Monoid seq, MonoTraversable seq, SemiSequence seq, MonoPointed seq) => IsSequence seq

-- | Convert a list to a sequence.
--   
--   <pre>
--   &gt; <a>fromList</a> [<tt>a</tt>, <tt>b</tt>, <tt>c</tt>] :: Text
--   "abc"
--   </pre>
fromList :: IsSequence seq => [Element seq] -> seq

-- | <a>lengthIndex</a> returns the length of a sequence as
--   <tt><a>Index</a> seq</tt>.
lengthIndex :: IsSequence seq => seq -> Index seq

-- | <a>break</a> applies a predicate to a sequence, and returns a tuple
--   where the first element is the longest prefix (possibly empty) of
--   elements that <i>do not satisfy</i> the predicate. The second element
--   of the tuple is the remainder of the sequence.
--   
--   <tt><a>break</a> p</tt> is equivalent to <tt><a>span</a> (<tt>not</tt>
--   . p)</tt>
--   
--   <pre>
--   &gt; <a>break</a> (&gt; 3) (<a>fromList</a> [1,2,3,4,1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2,3],fromList [4,1,2,3,4])
--   
--   &gt; <a>break</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("","abc")
--   
--   &gt; <a>break</a> (&gt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("abc","")
--   </pre>
break :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>span</a> applies a predicate to a sequence, and returns a tuple
--   where the first element is the longest prefix (possibly empty) that
--   <i>does satisfy</i> the predicate. The second element of the tuple is
--   the remainder of the sequence.
--   
--   <tt><a>span</a> p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
--   
--   <pre>
--   &gt; <a>span</a> (&lt; 3) (<a>fromList</a> [1,2,3,4,1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2],fromList [3,4,1,2,3,4])
--   
--   &gt; <a>span</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ("abc","")
--   
--   &gt; <a>span</a> (&lt; 0) <a>1,2,3</a>
--   </pre>
span :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>dropWhile</a> returns the suffix remaining after <a>takeWhile</a>.
--   
--   <pre>
--   &gt; <a>dropWhile</a> (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt; <a>dropWhile</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   ""
--   </pre>
dropWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | <a>takeWhile</a> applies a predicate to a sequence, and returns the
--   longest prefix (possibly empty) of the sequence of elements that
--   <i>satisfy</i> the predicate.
--   
--   <pre>
--   &gt; <a>takeWhile</a> (&lt; 3) [1,2,3,4,5,1,2,3]
--   [1,2]
--   
--   &gt; <a>takeWhile</a> (&lt; <tt>z</tt>) (<a>fromList</a> "abc" :: <tt>Text</tt>)
--   "abc"
--   </pre>
takeWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | <tt><a>splitAt</a> n se</tt> returns a tuple where the first element
--   is the prefix of the sequence <tt>se</tt> with length <tt>n</tt>, and
--   the second element is the remainder of the sequence.
--   
--   <pre>
--   &gt; <a>splitAt</a> 6 "Hello world!"
--   ("Hello ","world!")
--   
--   &gt; <a>splitAt</a> 3 (<a>fromList</a> [1,2,3,4,5] :: <tt>Vector</tt> <a>Int</a>)
--   (fromList [1,2,3],fromList [4,5])
--   </pre>
splitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)

-- | Equivalent to <a>splitAt</a>.
unsafeSplitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)

-- | <tt><a>take</a> n</tt> returns the prefix of a sequence of length
--   <tt>n</tt>, or the sequence itself if <tt>n &gt; <a>olength</a>
--   seq</tt>.
--   
--   <pre>
--   &gt; <a>take</a> 3 "abcdefg"
--   "abc"
--   &gt; <a>take</a> 4 (<a>fromList</a> [1,2,3,4,5,6] :: <tt>Vector</tt> <a>Int</a>)
--   fromList [1,2,3,4]
--   </pre>
take :: IsSequence seq => Index seq -> seq -> seq

-- | Equivalent to <a>take</a>.
unsafeTake :: IsSequence seq => Index seq -> seq -> seq

-- | <tt><a>drop</a> n</tt> returns the suffix of a sequence after the
--   first <tt>n</tt> elements, or an empty sequence if <tt>n &gt;
--   <a>olength</a> seq</tt>.
--   
--   <pre>
--   &gt; <a>drop</a> 3 "abcdefg"
--   "defg"
--   &gt; <a>drop</a> 4 (<a>fromList</a> [1,2,3,4,5,6] :: <tt>Vector</tt> <a>Int</a>)
--   fromList [5,6]
--   </pre>
drop :: IsSequence seq => Index seq -> seq -> seq

-- | Equivalent to <a>drop</a>
unsafeDrop :: IsSequence seq => Index seq -> seq -> seq

-- | Same as <a>drop</a> but drops from the end of the sequence instead.
--   
--   <pre>
--   &gt; <a>dropEnd</a> 3 "abcdefg"
--   "abcd"
--   &gt; <a>dropEnd</a> 4 (<a>fromList</a> [1,2,3,4,5,6] :: <tt>Vector</tt> <a>Int</a>)
--   fromList [1,2]
--   </pre>
dropEnd :: IsSequence seq => Index seq -> seq -> seq

-- | <a>partition</a> takes a predicate and a sequence and returns the pair
--   of sequences of elements which do and do not satisfy the predicate.
--   
--   <pre>
--   <a>partition</a> p se = (<a>filter</a> p se, <a>filter</a> (<tt>not</tt> . p) se)
--   </pre>
partition :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)

-- | <a>uncons</a> returns the tuple of the first element of a sequence and
--   the rest of the sequence, or <a>Nothing</a> if the sequence is empty.
--   
--   <pre>
--   &gt; <a>uncons</a> (<a>fromList</a> [1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   <a>Just</a> (1,fromList [2,3,4])
--   
--   &gt; <a>uncons</a> ([] :: [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
uncons :: IsSequence seq => seq -> Maybe (Element seq, seq)

-- | <a>unsnoc</a> returns the tuple of the init of a sequence and the last
--   element, or <a>Nothing</a> if the sequence is empty.
--   
--   <pre>
--   &gt; <a>unsnoc</a> (<a>fromList</a> [1,2,3,4] :: <tt>Vector</tt> <a>Int</a>)
--   <a>Just</a> (fromList [1,2,3],4)
--   
--   &gt; <a>unsnoc</a> ([] :: [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
unsnoc :: IsSequence seq => seq -> Maybe (seq, Element seq)

-- | <a>filter</a> given a predicate returns a sequence of all elements
--   that satisfy the predicate.
--   
--   <pre>
--   &gt; <a>filter</a> (&lt; 5) [1 .. 10]
--   [1,2,3,4]
--   </pre>
filter :: IsSequence seq => (Element seq -> Bool) -> seq -> seq

-- | The monadic version of <a>filter</a>.
filterM :: (IsSequence seq, Monad m) => (Element seq -> m Bool) -> seq -> m seq

-- | <tt><a>replicate</a> n x</tt> is a sequence of length <tt>n</tt> with
--   <tt>x</tt> as the value of every element.
--   
--   <pre>
--   &gt; <a>replicate</a> 10 <tt>a</tt> :: Text
--   "aaaaaaaaaa"
--   </pre>
replicate :: IsSequence seq => Index seq -> Element seq -> seq

-- | The monadic version of <a>replicateM</a>.
replicateM :: (IsSequence seq, Monad m) => Index seq -> m (Element seq) -> m seq

-- | <a>group</a> takes a sequence and returns a list of sequences such
--   that the concatenation of the result is equal to the argument. Each
--   subsequence in the result contains only equal elements, using the
--   supplied equality test.
--   
--   <pre>
--   &gt; <a>groupBy</a> (==) <a>Mississippi</a>
--   [<a>M</a>,"i","ss","i","ss","i","pp","i"]
--   </pre>
groupBy :: IsSequence seq => (Element seq -> Element seq -> Bool) -> seq -> [seq]

-- | Similar to standard <a>groupBy</a>, but operates on the whole
--   collection, not just the consecutive items.
groupAllOn :: (IsSequence seq, Eq b) => (Element seq -> b) -> seq -> [seq]

-- | <a>subsequences</a> returns a list of all subsequences of the
--   argument.
--   
--   <pre>
--   &gt; <a>subsequences</a> "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: IsSequence seq => seq -> [seq]

-- | <a>permutations</a> returns a list of all permutations of the
--   argument.
--   
--   <pre>
--   &gt; <a>permutations</a> "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: IsSequence seq => seq -> [seq]

-- | <b>Unsafe</b>
--   
--   Get the tail of a sequence, throw an exception if the sequence is
--   empty.
--   
--   <pre>
--   &gt; <a>tailEx</a> [1,2,3]
--   [2,3]
--   </pre>
tailEx :: IsSequence seq => seq -> seq

-- | Safe version of <a>tailEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
tailMay :: IsSequence seq => seq -> Maybe seq

-- | <b>Unsafe</b>
--   
--   Get the init of a sequence, throw an exception if the sequence is
--   empty.
--   
--   <pre>
--   &gt; <a>initEx</a> [1,2,3]
--   [1,2]
--   </pre>
initEx :: IsSequence seq => seq -> seq

-- | Safe version of <a>initEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
initMay :: IsSequence seq => seq -> Maybe seq

-- | Equivalent to <a>tailEx</a>.
unsafeTail :: IsSequence seq => seq -> seq

-- | Equivalent to <a>initEx</a>.
unsafeInit :: IsSequence seq => seq -> seq

-- | Get the element of a sequence at a certain index, returns
--   <a>Nothing</a> if that index does not exist.
--   
--   <pre>
--   &gt; <a>index</a> (<a>fromList</a> [1,2,3] :: <tt>Vector</tt> <a>Int</a>) 1
--   <a>Just</a> 2
--   &gt; <a>index</a> (<a>fromList</a> [1,2,3] :: <tt>Vector</tt> <a>Int</a>) 4
--   <a>Nothing</a>
--   </pre>
index :: IsSequence seq => seq -> Index seq -> Maybe (Element seq)

-- | <b>Unsafe</b>
--   
--   Get the element of a sequence at a certain index, throws an exception
--   if the index does not exist.
indexEx :: IsSequence seq => seq -> Index seq -> Element seq

-- | Equivalent to <a>indexEx</a>.
unsafeIndex :: IsSequence seq => seq -> Index seq -> Element seq

-- | <a>splitWhen</a> splits a sequence into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. The number of
--   resulting components is greater by one than number of separators.
--   
--   Since 0.9.3
splitWhen :: IsSequence seq => (Element seq -> Bool) -> seq -> [seq]

-- | Returns all the final segments of <tt>seq</tt> with the longest first.
--   
--   <pre>
--   &gt; tails [1,2]
--   [[1,2],[2],[]]
--   &gt; tails []
--   [[]]
--   </pre>
tails :: IsSequence seq => seq -> [seq]

-- | Return all the initial segments of <tt>seq</tt> with the shortest
--   first.
--   
--   <pre>
--   &gt; inits [1,2]
--   [[],[1],[1,2]]
--   &gt; inits []
--   [[]]
--   </pre>
inits :: IsSequence seq => seq -> [seq]

-- | Return all the pairs of inital and final segments of <tt>seq</tt>.
--   
--   <pre>
--   &gt; initTails [1,2]
--   [([],[1,2]),([1],[2]),([1,2],[])]
--   &gt; initTails []
--   [([],[])]
--   </pre>
initTails :: IsSequence seq => seq -> [(seq, seq)]

-- | Use <a>Data.List</a>'s implementation of <a>find</a>.
defaultFind :: MonoFoldable seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)

-- | Use <a>Data.List</a>'s implementation of <a>intersperse</a>.
defaultIntersperse :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>reverse</a>.
defaultReverse :: IsSequence seq => seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>sortBy</a>.
defaultSortBy :: IsSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq

-- | Use <a>splitWhen</a> from <a>Data.List.Split</a>
defaultSplitWhen :: IsSequence seq => (Element seq -> Bool) -> seq -> [seq]

-- | Sort a vector using an supplied element ordering function.
vectorSortBy :: Vector v e => (e -> e -> Ordering) -> v e -> v e

-- | Sort a vector.
vectorSort :: (Vector v e, Ord e) => v e -> v e

-- | Use <a>Data.List</a>'s <a>:</a> to prepend an element to a sequence.
defaultCons :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s <a>++</a> to append an element to a sequence.
defaultSnoc :: IsSequence seq => seq -> Element seq -> seq

-- | like Data.List.tail, but an input of <a>mempty</a> returns
--   <a>mempty</a>
tailDef :: IsSequence seq => seq -> seq

-- | like Data.List.init, but an input of <a>mempty</a> returns
--   <a>mempty</a>
initDef :: IsSequence seq => seq -> seq

-- | <tt><a>splitElem</a></tt> splits a sequence into components delimited
--   by separator element. It's equivalent to <a>splitWhen</a> with
--   equality predicate:
--   
--   <pre>
--   splitElem sep === splitWhen (== sep)
--   </pre>
--   
--   Since 0.9.3
splitElem :: (IsSequence seq, Eq (Element seq)) => Element seq -> seq -> [seq]

-- | <tt><a>splitSeq</a></tt> splits a sequence into components delimited
--   by separator subsequence. <a>splitSeq</a> is the right inverse of
--   <tt>intercalate</tt>:
--   
--   <pre>
--   ointercalate x . splitSeq x === id
--   </pre>
--   
--   <a>splitElem</a> can be considered a special case of <a>splitSeq</a>
--   
--   <pre>
--   splitSeq (singleton sep) === splitElem sep
--   </pre>
--   
--   <tt><a>splitSeq</a> mempty</tt> is another special case: it splits
--   just before each element, and in line with <a>splitWhen</a> rules, it
--   has at least one output component:
--   
--   <pre>
--   &gt; <a>splitSeq</a> "" ""
--   [""]
--   &gt; <a>splitSeq</a> "" "a"
--   ["", "a"]
--   &gt; <a>splitSeq</a> "" "ab"
--   ["", "a", "b"]
--   </pre>
--   
--   Since 0.9.3
splitSeq :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> [seq]

-- | <tt><a>replaceSeq</a> old new</tt> replaces all <tt>old</tt>
--   subsequences with <tt>new</tt>.
--   
--   <pre>
--   replaceSeq old new === ointercalate new . splitSeq old
--   </pre>
replaceSeq :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> seq -> seq

-- | <a>stripPrefix</a> drops the given prefix from a sequence. It returns
--   <a>Nothing</a> if the sequence did not start with the prefix given, or
--   <a>Just</a> the sequence after the prefix, if it does.
--   
--   <pre>
--   &gt; <a>stripPrefix</a> "foo" "foobar"
--   <a>Just</a> "bar"
--   &gt; <a>stripPrefix</a> "abc" "foobar"
--   <a>Nothing</a>
--   </pre>
stripPrefix :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> Maybe seq

-- | <a>stripSuffix</a> drops the given suffix from a sequence. It returns
--   <a>Nothing</a> if the sequence did not end with the suffix given, or
--   <a>Just</a> the sequence before the suffix, if it does.
--   
--   <pre>
--   &gt; <a>stripSuffix</a> "bar" "foobar"
--   <a>Just</a> "foo"
--   &gt; <a>stripSuffix</a> "abc" "foobar"
--   <a>Nothing</a>
--   </pre>
stripSuffix :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> Maybe seq

-- | <a>dropPrefix</a> drops the given prefix from a sequence. It returns
--   the original sequence if the sequence doesn't start with the given
--   prefix.
--   
--   <pre>
--   &gt; <a>dropPrefix</a> "foo" "foobar"
--   "bar"
--   &gt; <a>dropPrefix</a> "abc" "foobar"
--   "foobar"
--   </pre>
dropPrefix :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> seq

-- | <a>dropSuffix</a> drops the given suffix from a sequence. It returns
--   the original sequence if the sequence doesn't end with the given
--   suffix.
--   
--   <pre>
--   &gt; <a>dropSuffix</a> "bar" "foobar"
--   "foo"
--   &gt; <a>dropSuffix</a> "abc" "foobar"
--   "foobar"
--   </pre>
dropSuffix :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> seq

-- | <a>ensurePrefix</a> will add a prefix to a sequence if it doesn't
--   exist, and otherwise have no effect.
--   
--   <pre>
--   &gt; <a>ensurePrefix</a> "foo" "foobar"
--   "foobar"
--   &gt; <a>ensurePrefix</a> "abc" "foobar"
--   "abcfoobar"
--   </pre>
ensurePrefix :: (Eq (Element seq), IsSequence seq) => seq -> seq -> seq

-- | Append a suffix to a sequence, unless it already has that suffix.
--   
--   <pre>
--   &gt; <a>ensureSuffix</a> "bar" "foobar"
--   "foobar"
--   &gt; <a>ensureSuffix</a> "abc" "foobar"
--   "foobarabc"
--   </pre>
ensureSuffix :: (Eq (Element seq), IsSequence seq) => seq -> seq -> seq

-- | <a>isPrefixOf</a> takes two sequences and returns <a>True</a> if the
--   first sequence is a prefix of the second.
isPrefixOf :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> Bool

-- | <a>isSuffixOf</a> takes two sequences and returns <a>True</a> if the
--   first sequence is a suffix of the second.
isSuffixOf :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> Bool

-- | <a>isInfixOf</a> takes two sequences and returns <tt>true</tt> if the
--   first sequence is contained, wholly and intact, anywhere within the
--   second.
isInfixOf :: (IsSequence seq, Eq (Element seq)) => seq -> seq -> Bool

-- | Equivalent to <tt><a>groupBy</a> (==)</tt>
group :: (IsSequence seq, Eq (Element seq)) => seq -> [seq]

-- | Similar to standard <a>group</a>, but operates on the whole
--   collection, not just the consecutive items.
--   
--   Equivalent to <tt><a>groupAllOn</a> id</tt>
groupAll :: (IsSequence seq, Eq (Element seq)) => seq -> [seq]

delete :: (IsSequence seq, Eq (Element seq)) => Element seq -> seq -> seq

deleteBy :: (IsSequence seq, Eq (Element seq)) => (Element seq -> Element seq -> Bool) -> Element seq -> seq -> seq
splitElemStrictBS :: Word8 -> ByteString -> [ByteString]
stripPrefixStrictBS :: ByteString -> ByteString -> Maybe ByteString
stripSuffixStrictBS :: ByteString -> ByteString -> Maybe ByteString
splitSeqLazyBS :: Word8 -> ByteString -> [ByteString]
stripPrefixLazyBS :: ByteString -> ByteString -> Maybe ByteString
stripSuffixLazyBS :: ByteString -> ByteString -> Maybe ByteString
splitSeqStrictText :: Text -> Text -> [Text]
replaceSeqStrictText :: Text -> Text -> Text -> Text
splitSeqLazyText :: Text -> Text -> [Text]
replaceSeqLazyText :: Text -> Text -> Text -> Text

-- | Sort a ordered sequence.
--   
--   <pre>
--   &gt; <a>sort</a> [4,3,1,2]
--   [1,2,3,4]
--   </pre>
sort :: (SemiSequence seq, Ord (Element seq)) => seq -> seq

-- | A typeclass for sequences whose elements are <a>Char</a>s.
class (IsSequence t, IsString t, Element t ~ Char) => Textual t

-- | Break up a textual sequence into a list of words, which were delimited
--   by white space.
--   
--   <pre>
--   &gt; <a>words</a> "abc  def ghi"
--   ["abc","def","ghi"]
--   </pre>
words :: Textual t => t -> [t]

-- | Join a list of textual sequences using separating spaces.
--   
--   <pre>
--   &gt; <a>unwords</a> ["abc","def","ghi"]
--   "abc def ghi"
--   </pre>
unwords :: (Textual t, Element seq ~ t, MonoFoldable seq) => seq -> t

-- | Break up a textual sequence at newline characters.
--   
--   <pre>
--   &gt; <a>lines</a> "hello\nworld"
--   ["hello","world"]
--   </pre>
lines :: Textual t => t -> [t]

-- | Join a list of textual sequences using newlines.
--   
--   <pre>
--   &gt; <a>unlines</a> ["abc","def","ghi"]
--   "abc\ndef\nghi"
--   </pre>
unlines :: (Textual t, Element seq ~ t, MonoFoldable seq) => seq -> t

-- | Convert a textual sequence to lower-case.
--   
--   <pre>
--   &gt; <a>toLower</a> "HELLO WORLD"
--   "hello world"
--   </pre>
toLower :: Textual t => t -> t

-- | Convert a textual sequence to upper-case.
--   
--   <pre>
--   &gt; <a>toUpper</a> "hello world"
--   "HELLO WORLD"
--   </pre>
toUpper :: Textual t => t -> t

-- | Convert a textual sequence to folded-case.
--   
--   Slightly different from <a>toLower</a>, see
--   <tt><a>Data.Text</a>.<a>toCaseFold</a></tt>
toCaseFold :: Textual t => t -> t

-- | Split a textual sequence into two parts, split at the first space.
--   
--   <pre>
--   &gt; <a>breakWord</a> "hello world"
--   ("hello","world")
--   </pre>
breakWord :: Textual t => t -> (t, t)

-- | Split a textual sequence into two parts, split at the newline.
--   
--   <pre>
--   &gt; <a>breakLine</a> "abc\ndef"
--   ("abc","def")
--   </pre>
breakLine :: Textual t => t -> (t, t)

-- | Takes all of the <a>Just</a> values from a sequence of <tt>Maybe
--   t</tt>s and concatenates them into an unboxed sequence of <tt>t</tt>s.
--   
--   Since 0.6.2
catMaybes :: (IsSequence (f (Maybe t)), Functor f, Element (f (Maybe t)) ~ Maybe t) => f (Maybe t) -> f t

-- | Same as <tt>sortBy . comparing</tt>.
--   
--   Since 0.7.0
sortOn :: (Ord o, SemiSequence seq) => (Element seq -> o) -> seq -> seq

-- | Lazy sequences containing strict chunks of data.
class (IsSequence lazy, IsSequence strict) => LazySequence lazy strict | lazy -> strict, strict -> lazy
toChunks :: LazySequence lazy strict => lazy -> [strict]
fromChunks :: LazySequence lazy strict => [strict] -> lazy
toStrict :: LazySequence lazy strict => lazy -> strict
fromStrict :: LazySequence lazy strict => strict -> lazy

-- | Synonym for <a>fromList</a>
pack :: IsSequence seq => [Element seq] -> seq

-- | Synonym for <a>otoList</a>
unpack :: MonoFoldable mono => mono -> [Element mono]

-- | Repack from one type to another, dropping to a list in the middle.
--   
--   <tt>repack = pack . unpack</tt>.
repack :: (MonoFoldable a, IsSequence b, Element a ~ Element b) => a -> b

-- | Textual data which can be encoded to and decoded from UTF8.
class (Textual textual, IsSequence binary) => Utf8 textual binary | textual -> binary, binary -> textual

-- | Encode from textual to binary using UTF-8 encoding
encodeUtf8 :: Utf8 textual binary => textual -> binary

-- | Note that this function is required to be pure. In the case of a
--   decoding error, Unicode replacement characters must be used.
decodeUtf8 :: Utf8 textual binary => binary -> textual
instance (c GHC.Types.~ GHC.Types.Char, w GHC.Types.~ GHC.Word.Word8) => Data.Sequences.Utf8 [c] [w]
instance Data.Sequences.Utf8 Data.Text.Internal.Text Data.ByteString.Internal.Type.ByteString
instance Data.Sequences.Utf8 Data.Text.Internal.Lazy.Text Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.LazySequence Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Internal.Type.ByteString
instance Data.Sequences.LazySequence Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
instance (c GHC.Types.~ GHC.Types.Char) => Data.Sequences.Textual [c]
instance Data.Sequences.Textual Data.Text.Internal.Text
instance Data.Sequences.Textual Data.Text.Internal.Lazy.Text
instance Data.Sequences.IsSequence [a]
instance Data.Sequences.IsSequence Data.ByteString.Internal.Type.ByteString
instance Data.Sequences.IsSequence Data.Text.Internal.Text
instance Data.Sequences.IsSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.IsSequence Data.Text.Internal.Lazy.Text
instance Data.Sequences.IsSequence (Data.Sequence.Internal.Seq a)
instance Data.Sequences.IsSequence (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Sequences.IsSequence (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.Sequences.IsSequence (Data.Vector.Storable.Vector a)
instance Data.Sequences.SemiSequence [a]
instance Data.Sequences.SemiSequence (GHC.Base.NonEmpty a)
instance Data.Sequences.SemiSequence Data.ByteString.Internal.Type.ByteString
instance Data.Sequences.SemiSequence Data.Text.Internal.Text
instance Data.Sequences.SemiSequence Data.ByteString.Lazy.Internal.ByteString
instance Data.Sequences.SemiSequence Data.Text.Internal.Lazy.Text
instance Data.Sequences.SemiSequence (Data.Sequence.Internal.Seq a)
instance Data.Sequences.SemiSequence (Data.Vector.Vector a)
instance Data.Vector.Unboxed.Base.Unbox a => Data.Sequences.SemiSequence (Data.Vector.Unboxed.Base.Vector a)
instance Foreign.Storable.Storable a => Data.Sequences.SemiSequence (Data.Vector.Storable.Vector a)


-- | <a>Data.NonNull</a> extends the concepts from
--   <a>Data.List.NonEmpty</a> to any <a>MonoFoldable</a>.
--   
--   <a>NonNull</a> is a newtype wrapper for a container with 1 or more
--   elements.
module Data.NonNull

-- | A monomorphic container that is not null.
data NonNull mono

-- | <b>Safely</b> convert from an <b>unsafe</b> monomorphic container to a
--   <b>safe</b> non-null monomorphic container.
fromNullable :: MonoFoldable mono => mono -> Maybe (NonNull mono)

-- | <b>Unsafely</b> convert from an <b>unsafe</b> monomorphic container to
--   a <b>safe</b> non-null monomorphic container.
--   
--   Throws an exception if the monomorphic container is empty.
impureNonNull :: MonoFoldable mono => mono -> NonNull mono

-- | Old synonym for <a>impureNonNull</a>

-- | <i>Deprecated: Please use the more explicit impureNonNull instead</i>
nonNull :: MonoFoldable mono => mono -> NonNull mono

-- | <b>Safely</b> convert from a non-null monomorphic container to a
--   nullable monomorphic container.
toNullable :: NonNull mono -> mono

-- | <b>Safely</b> convert from a <tt>NonEmpty</tt> list to a non-null
--   monomorphic container.
fromNonEmpty :: IsSequence seq => NonEmpty (Element seq) -> NonNull seq

-- | <b>Safely</b> convert from a <a>NonNull</a> container to a
--   <tt>NonEmpty</tt> list.
toNonEmpty :: MonoFoldable mono => NonNull mono -> NonEmpty (Element mono)

-- | Prepend an element to a <a>SemiSequence</a>, creating a non-null
--   <a>SemiSequence</a>.
--   
--   Generally this uses cons underneath. cons is not efficient for most
--   data structures.
--   
--   Alternatives:
--   
--   <ul>
--   <li>if you don't need to cons, use <a>fromNullable</a> or
--   <a>nonNull</a> if you can create your structure in one go.</li>
--   <li>if you need to cons, you might be able to start off with an
--   efficient data structure such as a <tt>NonEmpty</tt> List.
--   <a>fromNonEmpty</a> will convert that to your data structure using the
--   structure's fromList function.</li>
--   </ul>
ncons :: SemiSequence seq => Element seq -> seq -> NonNull seq

-- | Extract the first element of a sequence and the rest of the non-null
--   sequence if it exists.
nuncons :: IsSequence seq => NonNull seq -> (Element seq, Maybe (NonNull seq))

-- | Same as <a>nuncons</a> with no guarantee that the rest of the sequence
--   is non-null.
splitFirst :: IsSequence seq => NonNull seq -> (Element seq, seq)

-- | Equivalent to <tt><a>Data.Sequences</a>.<a>filter</a></tt>, but works
--   on non-nullable sequences.
nfilter :: IsSequence seq => (Element seq -> Bool) -> NonNull seq -> seq

-- | Equivalent to <tt><a>Data.Sequences</a>.<a>filterM</a></tt>, but works
--   on non-nullable sequences.
nfilterM :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> NonNull seq -> m seq

-- | Equivalent to <tt><a>Data.Sequences</a>.<a>replicate</a></tt>
--   
--   <tt>i</tt> must be <tt>&gt; 0</tt>
--   
--   <tt>i &lt;= 0</tt> is treated the same as providing <tt>1</tt>
nReplicate :: IsSequence seq => Index seq -> Element seq -> NonNull seq

-- | Return the first element of a monomorphic container.
--   
--   Safe version of <a>headEx</a>, only works on monomorphic containers
--   wrapped in a <a>NonNull</a>.
head :: MonoFoldable mono => NonNull mono -> Element mono

-- | <b>Safe</b> version of <a>tailEx</a>, only working on non-nullable
--   sequences.
tail :: IsSequence seq => NonNull seq -> seq

-- | Return the last element of a monomorphic container.
--   
--   Safe version of <a>lastEx</a>, only works on monomorphic containers
--   wrapped in a <a>NonNull</a>.
last :: MonoFoldable mono => NonNull mono -> Element mono

-- | <b>Safe</b> version of <a>initEx</a>, only working on non-nullable
--   sequences.
init :: IsSequence seq => NonNull seq -> seq

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Safe version of <a>ofoldMap1Ex</a>, only works on monomorphic
--   containers wrapped in a <a>NonNull</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons ("hello", 1 :: <a>Integer</a>) [(" world", 2)]
--   &gt; <a>ofoldMap1</a> <a>fst</a> xs
--   "hello world"
--   </pre>
ofoldMap1 :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> NonNull mono -> m

-- | Join a monomorphic container, whose elements are <a>Semigroup</a>s,
--   together.
--   
--   Safe, only works on monomorphic containers wrapped in a
--   <a>NonNull</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons "a" ["b", "c"]
--   &gt; xs
--   <a>NonNull</a> {toNullable = ["a","b","c"]}
--   
--   &gt; <a>ofold1</a> xs
--   "abc"
--   </pre>
ofold1 :: (MonoFoldable mono, Semigroup (Element mono)) => NonNull mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldr1Ex</a>, only works on monomorphic containers
--   wrapped in a <a>NonNull</a>.
--   
--   <pre>
--   <a>foldr1</a> f = <a>Prelude</a>.<a>foldr1</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons "a" ["b", "c"]
--   &gt; <a>ofoldr1</a> (++) xs
--   "abc"
--   </pre>
ofoldr1 :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> NonNull mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldl1Ex'</a>, only works on monomorphic
--   containers wrapped in a <a>NonNull</a>.
--   
--   <pre>
--   <tt>foldl1'</tt> f = <a>Prelude</a>.<a>foldl1'</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons "a" ["b", "c"]
--   &gt; <a>ofoldl1'</a> (++) xs
--   "abc"
--   </pre>
ofoldl1' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> NonNull mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Safe version of <a>maximumEx</a>, only works on monomorphic containers
--   wrapped in a <a>NonNull</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons 1 [2, 3 :: Int]
--   &gt; <a>maximum</a> xs
--   3
--   </pre>
maximum :: (MonoFoldable mono, Ord (Element mono)) => NonNull mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>maximumByEx</a>, only works on monomorphic
--   containers wrapped in a <a>NonNull</a>.
maximumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> NonNull mono -> Element mono

-- | Get the minimum element of a monomorphic container.
--   
--   Safe version of <a>minimumEx</a>, only works on monomorphic containers
--   wrapped in a <a>NonNull</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ncons 1 [2, 3 :: Int]
--   &gt; <a>minimum</a> xs
--   1
--   </pre>
minimum :: (MonoFoldable mono, Ord (Element mono)) => NonNull mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>minimumByEx</a>, only works on monomorphic
--   containers wrapped in a <a>NonNull</a>.
minimumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> NonNull mono -> Element mono

-- | Prepend an element to a non-null <a>SemiSequence</a>.
(<|) :: SemiSequence seq => Element seq -> NonNull seq -> NonNull seq
infixr 5 <|

-- | Specializes <a>fromNonEmpty</a> to lists only.
toMinList :: NonEmpty a -> NonNull [a]

-- | <a>fmap</a> over the underlying container in a <a>NonNull</a>.
mapNonNull :: (Functor f, MonoFoldable (f b)) => (a -> b) -> NonNull (f a) -> NonNull (f b)

-- | Containers which, when two values are combined, the combined length is
--   no less than the larger of the two inputs. In code:
--   
--   <pre>
--   olength (x &lt;&gt; y) &gt;= max (olength x) (olength y)
--   </pre>
--   
--   This class has no methods, and is simply used to assert that this law
--   holds, in order to provide guarantees of correctness (see, for
--   instance, <a>Data.NonNull</a>).
--   
--   This should have a <tt>Semigroup</tt> superclass constraint, however,
--   due to <tt>Semigroup</tt> only recently moving to base, some packages
--   do not provide instances.
class MonoFoldable mono => GrowingAppend mono
instance GHC.Show.Show Data.NonNull.NullError
instance Data.Data.Data mono => Data.Data.Data (Data.NonNull.NonNull mono)
instance GHC.Show.Show mono => GHC.Show.Show (Data.NonNull.NonNull mono)
instance GHC.Read.Read mono => GHC.Read.Read (Data.NonNull.NonNull mono)
instance GHC.Classes.Ord mono => GHC.Classes.Ord (Data.NonNull.NonNull mono)
instance GHC.Classes.Eq mono => GHC.Classes.Eq (Data.NonNull.NonNull mono)
instance Data.MonoTraversable.MonoFunctor mono => Data.MonoTraversable.MonoFunctor (Data.NonNull.NonNull mono)
instance Data.MonoTraversable.MonoFoldable mono => Data.MonoTraversable.MonoFoldable (Data.NonNull.NonNull mono)
instance Data.MonoTraversable.MonoTraversable mono => Data.MonoTraversable.MonoTraversable (Data.NonNull.NonNull mono)
instance Data.MonoTraversable.GrowingAppend mono => Data.MonoTraversable.GrowingAppend (Data.NonNull.NonNull mono)
instance (GHC.Base.Semigroup mono, Data.MonoTraversable.GrowingAppend mono) => GHC.Base.Semigroup (Data.NonNull.NonNull mono)
instance Data.Sequences.SemiSequence seq => Data.Sequences.SemiSequence (Data.NonNull.NonNull seq)
instance Data.MonoTraversable.MonoPointed mono => Data.MonoTraversable.MonoPointed (Data.NonNull.NonNull mono)
instance Data.Sequences.IsSequence mono => Data.MonoTraversable.MonoComonad (Data.NonNull.NonNull mono)
instance GHC.Exception.Type.Exception Data.NonNull.NullError
