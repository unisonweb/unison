-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deep evaluation of data structures
--   
--   This package provides methods for fully evaluating data structures
--   ("deep evaluation"). Deep evaluation is often used for adding
--   strictness to a program, e.g. in order to force pending exceptions,
--   remove space leaks, or force lazy I/O to happen. It is also useful in
--   parallel programs, to ensure pending work does not migrate to the
--   wrong thread.
--   
--   The primary use of this package is via the <a>deepseq</a> function, a
--   "deep" version of <a>seq</a>. It is implemented on top of an
--   <a>NFData</a> typeclass ("Normal Form Data", data structures with no
--   unevaluated components) which defines strategies for fully evaluating
--   different data types. See module documentation in
--   <a>Control.DeepSeq</a> for more details.
@package deepseq
@version 1.4.8.1


-- | This module provides overloaded functions, such as <a>deepseq</a> and
--   <a>rnf</a>, for fully evaluating data structures (that is, evaluating
--   to "Normal Form").
--   
--   A typical use is to prevent resource leaks in lazy IO programs, by
--   forcing all characters from a file to be read. For example:
--   
--   <pre>
--   import System.IO
--   import Control.DeepSeq
--   import Control.Exception (evaluate)
--   
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = do
--       h &lt;- openFile fn ReadMode
--       s &lt;- hGetContents h
--       evaluate (rnf s)
--       hClose h
--       return s
--   </pre>
--   
--   <b>Note</b>: The example above should rather be written in terms of
--   <a>bracket</a> to ensure releasing file-descriptors in a timely matter
--   (see the description of <a>force</a> for an example).
--   
--   <a>deepseq</a> differs from <a>seq</a> as it traverses data structures
--   deeply, for example, <a>seq</a> will evaluate only to the first
--   constructor in the list:
--   
--   <pre>
--   &gt; [1,2,undefined] `seq` 3
--   3
--   </pre>
--   
--   While <a>deepseq</a> will force evaluation of all the list elements:
--   
--   <pre>
--   &gt; [1,2,undefined] `deepseq` 3
--   *** Exception: Prelude.undefined
--   </pre>
--   
--   Another common use is to ensure any exceptions hidden within lazy
--   fields of a data structure do not leak outside the scope of the
--   exception handler, or to force evaluation of a data structure in one
--   thread, before passing to another thread (preventing work moving to
--   the wrong threads).
module Control.DeepSeq

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: (NFData a, Generic a, GNFData Zero (Rep a)) => a -> ()

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b
infixr 0 `deepseq`

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | Deeply strict version of <a>&lt;$&gt;</a>.
(<$!!>) :: (Monad m, NFData b) => (a -> b) -> m a -> m b
infixl 4 <$!!>

-- | Reduce to weak head normal form
--   
--   Equivalent to <tt>\x -&gt; <a>seq</a> x ()</tt>.
--   
--   Useful for defining <a>NFData</a> for types for which NF=WHNF holds.
--   
--   <pre>
--   data T = C1 | C2 | C3
--   instance NFData T where rnf = rwhnf
--   </pre>
rwhnf :: a -> ()

-- | A class of functors that can be fully evaluated.
class NFData1 f

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return <tt>()</tt>.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: NFData1 f => (a -> ()) -> f a -> ()

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return <tt>()</tt>.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: (NFData1 f, Generic1 f, GNFData One (Rep1 f)) => (a -> ()) -> f a -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf1 :: (NFData1 f, NFData a) => f a -> ()

-- | A class of bifunctors that can be fully evaluated.
class NFData2 p

-- | <a>liftRnf2</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given functions to reduce
--   <tt>a</tt> and <tt>b</tt> arguments respectively, and then return
--   <tt>()</tt>.
--   
--   <b>Note</b>: Unlike for the unary <a>liftRnf</a>, there is currently
--   no support for generically deriving <a>liftRnf2</a>.
liftRnf2 :: NFData2 p => (a -> ()) -> (b -> ()) -> p a b -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf2 :: (NFData2 p, NFData a, NFData b) => p a b -> ()
instance Control.DeepSeq.NFData2 (Data.Type.Equality.:~:)
instance Control.DeepSeq.NFData2 (Data.Type.Equality.:~~:)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Data.Either.Either a)
instance Control.DeepSeq.NFData2 Data.Either.Either
instance Control.DeepSeq.NFData2 Data.Functor.Const.Const
instance Control.DeepSeq.NFData2 GHC.Arr.Array
instance Control.DeepSeq.NFData2 GHC.STRef.STRef
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Data.Semigroup.Arg a)
instance Control.DeepSeq.NFData2 Data.Semigroup.Arg
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 ((,) a)
instance Control.DeepSeq.NFData2 (,)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2) => Control.DeepSeq.NFData1 ((,,) a1 a2)
instance Control.DeepSeq.NFData a1 => Control.DeepSeq.NFData2 ((,,) a1)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData1 ((,,,) a1 a2 a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2) => Control.DeepSeq.NFData2 ((,,,) a1 a2)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData1 ((,,,,) a1 a2 a3 a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData2 ((,,,,) a1 a2 a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData1 ((,,,,,) a1 a2 a3 a4 a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData2 ((,,,,,) a1 a2 a3 a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData1 ((,,,,,,) a1 a2 a3 a4 a5 a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData2 ((,,,,,,) a1 a2 a3 a4 a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData1 ((,,,,,,,) a1 a2 a3 a4 a5 a6 a7)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData2 ((,,,,,,,) a1 a2 a3 a4 a5 a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8) => Control.DeepSeq.NFData1 ((,,,,,,,,) a1 a2 a3 a4 a5 a6 a7 a8)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData2 ((,,,,,,,,) a1 a2 a3 a4 a5 a6 a7)
instance Control.DeepSeq.NFData1 f => Control.DeepSeq.GNFData Control.DeepSeq.One (GHC.Generics.Rec1 f)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.GNFData Control.DeepSeq.One g) => Control.DeepSeq.GNFData Control.DeepSeq.One (f GHC.Generics.:.: g)
instance Control.DeepSeq.NFData1 Data.Proxy.Proxy
instance Control.DeepSeq.NFData1 ((Data.Type.Equality.:~:) a)
instance forall k1 (a :: k1). Control.DeepSeq.NFData1 ((Data.Type.Equality.:~~:) a)
instance Control.DeepSeq.NFData1 Data.Functor.Identity.Identity
instance Control.DeepSeq.NFData1 Data.Fixed.Fixed
instance Control.DeepSeq.NFData1 GHC.Real.Ratio
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Compose.Compose f g)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Functor.Compose.Compose f g a)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Sum.Sum f g)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Functor.Sum.Sum f g a)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (Data.Functor.Product.Product f g)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Data.Functor.Product.Product f g a)
instance Control.DeepSeq.NFData1 GHC.Maybe.Maybe
instance Control.DeepSeq.NFData1 []
instance Control.DeepSeq.NFData1 Control.Applicative.ZipList
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Data.Functor.Const.Const a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (GHC.Arr.Array a)
instance Control.DeepSeq.NFData1 Data.Ord.Down
instance Control.DeepSeq.NFData1 Data.Semigroup.Internal.Dual
instance Control.DeepSeq.NFData1 Data.Monoid.First
instance Control.DeepSeq.NFData1 Data.Monoid.Last
instance Control.DeepSeq.NFData1 Data.Semigroup.Internal.Sum
instance Control.DeepSeq.NFData1 Data.Semigroup.Internal.Product
instance Control.DeepSeq.NFData1 GHC.StableName.StableName
instance Control.DeepSeq.NFData1 GHC.IORef.IORef
instance Control.DeepSeq.NFData1 (GHC.STRef.STRef s)
instance Control.DeepSeq.NFData1 GHC.MVar.MVar
instance Control.DeepSeq.NFData1 GHC.Ptr.Ptr
instance Control.DeepSeq.NFData1 GHC.Ptr.FunPtr
instance Control.DeepSeq.NFData1 GHC.Base.NonEmpty
instance Control.DeepSeq.NFData1 Data.Semigroup.Min
instance Control.DeepSeq.NFData1 Data.Semigroup.Max
instance Control.DeepSeq.NFData1 Data.Semigroup.First
instance Control.DeepSeq.NFData1 Data.Semigroup.Last
instance Control.DeepSeq.NFData1 Data.Semigroup.WrappedMonoid
instance Control.DeepSeq.NFData1 Solo
instance Control.DeepSeq.NFData a => Control.DeepSeq.GNFData arity (GHC.Generics.K1 i a)
instance Control.DeepSeq.NFData GHC.Types.Int
instance Control.DeepSeq.NFData GHC.Types.Word
instance Control.DeepSeq.NFData GHC.Num.Integer.Integer
instance Control.DeepSeq.NFData GHC.Types.Float
instance Control.DeepSeq.NFData GHC.Types.Double
instance Control.DeepSeq.NFData GHC.Types.Char
instance Control.DeepSeq.NFData GHC.Types.Bool
instance Control.DeepSeq.NFData GHC.Types.Ordering
instance Control.DeepSeq.NFData ()
instance Control.DeepSeq.NFData GHC.Int.Int8
instance Control.DeepSeq.NFData GHC.Int.Int16
instance Control.DeepSeq.NFData GHC.Int.Int32
instance Control.DeepSeq.NFData GHC.Int.Int64
instance Control.DeepSeq.NFData GHC.Word.Word8
instance Control.DeepSeq.NFData GHC.Word.Word16
instance Control.DeepSeq.NFData GHC.Word.Word32
instance Control.DeepSeq.NFData GHC.Word.Word64
instance Control.DeepSeq.NFData GHC.IO.MaskingState
instance forall k (a :: k). Control.DeepSeq.NFData (Data.Proxy.Proxy a)
instance forall k (a :: k) (b :: k). Control.DeepSeq.NFData (a Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). Control.DeepSeq.NFData (a Data.Type.Equality.:~~: b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Functor.Identity.Identity a)
instance Control.DeepSeq.NFData GHC.Base.Void
instance Control.DeepSeq.NFData GHC.Num.Natural.Natural
instance forall k (a :: k). Control.DeepSeq.NFData (Data.Fixed.Fixed a)
instance Control.DeepSeq.NFData (a -> b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Real.Ratio a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Complex.Complex a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Maybe.Maybe a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Either.Either a b)
instance Control.DeepSeq.NFData Data.Version.Version
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData [a]
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Control.Applicative.ZipList a)
instance forall k a (b :: k). Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Functor.Const.Const a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (GHC.Arr.Array a b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Ord.Down a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Internal.Dual a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Monoid.First a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Monoid.Last a)
instance Control.DeepSeq.NFData Data.Semigroup.Internal.Any
instance Control.DeepSeq.NFData Data.Semigroup.Internal.All
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Internal.Sum a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Internal.Product a)
instance Control.DeepSeq.NFData (GHC.StableName.StableName a)
instance Control.DeepSeq.NFData GHC.Conc.Sync.ThreadId
instance Control.DeepSeq.NFData Data.Unique.Unique
instance Control.DeepSeq.NFData Data.Typeable.TypeRep
instance Control.DeepSeq.NFData GHC.Types.TyCon
instance forall k (a :: k). Control.DeepSeq.NFData (Data.Typeable.Internal.TypeRep a)
instance Control.DeepSeq.NFData GHC.Types.Module
instance Control.DeepSeq.NFData (GHC.IORef.IORef a)
instance Control.DeepSeq.NFData (GHC.STRef.STRef s a)
instance Control.DeepSeq.NFData (GHC.MVar.MVar a)
instance Control.DeepSeq.NFData GHC.Fingerprint.Type.Fingerprint
instance Control.DeepSeq.NFData (GHC.Ptr.Ptr a)
instance Control.DeepSeq.NFData (GHC.Ptr.FunPtr a)
instance Control.DeepSeq.NFData Foreign.C.Types.CChar
instance Control.DeepSeq.NFData Foreign.C.Types.CSChar
instance Control.DeepSeq.NFData Foreign.C.Types.CUChar
instance Control.DeepSeq.NFData Foreign.C.Types.CShort
instance Control.DeepSeq.NFData Foreign.C.Types.CUShort
instance Control.DeepSeq.NFData Foreign.C.Types.CInt
instance Control.DeepSeq.NFData Foreign.C.Types.CUInt
instance Control.DeepSeq.NFData Foreign.C.Types.CLong
instance Control.DeepSeq.NFData Foreign.C.Types.CULong
instance Control.DeepSeq.NFData Foreign.C.Types.CPtrdiff
instance Control.DeepSeq.NFData Foreign.C.Types.CSize
instance Control.DeepSeq.NFData Foreign.C.Types.CWchar
instance Control.DeepSeq.NFData Foreign.C.Types.CSigAtomic
instance Control.DeepSeq.NFData Foreign.C.Types.CLLong
instance Control.DeepSeq.NFData Foreign.C.Types.CULLong
instance Control.DeepSeq.NFData Foreign.C.Types.CIntPtr
instance Control.DeepSeq.NFData Foreign.C.Types.CUIntPtr
instance Control.DeepSeq.NFData Foreign.C.Types.CIntMax
instance Control.DeepSeq.NFData Foreign.C.Types.CUIntMax
instance Control.DeepSeq.NFData Foreign.C.Types.CClock
instance Control.DeepSeq.NFData Foreign.C.Types.CTime
instance Control.DeepSeq.NFData Foreign.C.Types.CUSeconds
instance Control.DeepSeq.NFData Foreign.C.Types.CSUSeconds
instance Control.DeepSeq.NFData Foreign.C.Types.CFloat
instance Control.DeepSeq.NFData Foreign.C.Types.CDouble
instance Control.DeepSeq.NFData Foreign.C.Types.CFile
instance Control.DeepSeq.NFData Foreign.C.Types.CFpos
instance Control.DeepSeq.NFData Foreign.C.Types.CJmpBuf
instance Control.DeepSeq.NFData Foreign.C.Types.CBool
instance Control.DeepSeq.NFData GHC.IO.Exception.ExitCode
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (GHC.Base.NonEmpty a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Min a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Max a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (Data.Semigroup.Arg a b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.First a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Semigroup.Last a)
instance Control.DeepSeq.NFData m => Control.DeepSeq.NFData (Data.Semigroup.WrappedMonoid m)
instance Control.DeepSeq.NFData GHC.Stack.Types.SrcLoc
instance Control.DeepSeq.NFData GHC.Stack.Types.CallStack
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Solo a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (a, b)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3) => Control.DeepSeq.NFData (a1, a2, a3)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4) => Control.DeepSeq.NFData (a1, a2, a3, a4)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7, a8)
instance (Control.DeepSeq.NFData a1, Control.DeepSeq.NFData a2, Control.DeepSeq.NFData a3, Control.DeepSeq.NFData a4, Control.DeepSeq.NFData a5, Control.DeepSeq.NFData a6, Control.DeepSeq.NFData a7, Control.DeepSeq.NFData a8, Control.DeepSeq.NFData a9) => Control.DeepSeq.NFData (a1, a2, a3, a4, a5, a6, a7, a8, a9)
instance Control.DeepSeq.NFData Data.Array.Byte.ByteArray
instance Control.DeepSeq.NFData (Data.Array.Byte.MutableByteArray s)
instance Control.DeepSeq.GNFData arity GHC.Generics.V1
instance Control.DeepSeq.GNFData arity GHC.Generics.U1
instance Control.DeepSeq.GNFData arity a => Control.DeepSeq.GNFData arity (GHC.Generics.M1 i c a)
instance Control.DeepSeq.GNFData arity (GHC.Generics.URec a)
instance (Control.DeepSeq.GNFData arity a, Control.DeepSeq.GNFData arity b) => Control.DeepSeq.GNFData arity (a GHC.Generics.:*: b)
instance (Control.DeepSeq.GNFData arity a, Control.DeepSeq.GNFData arity b) => Control.DeepSeq.GNFData arity (a GHC.Generics.:+: b)
instance Control.DeepSeq.GNFData Control.DeepSeq.One GHC.Generics.Par1
