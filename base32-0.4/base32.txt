-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast RFC 4648-compliant Base32 encoding
--   
--   RFC 4648-compliant Base32 encodings and decodings. This library
--   provides performant encoding and decoding primitives, as well as
--   support for textual values.
@package base32
@version 0.4


-- | Internal module defining the encoding and decoding processes and
--   tables.
module Data.ByteString.Base32.Internal

-- | Head of the padded base32 encoding loop.
--   
--   This function takes an alphabet in the form of an unboxed
--   <a>Addr#</a>, allocates the correct number of bytes that will be
--   written, and executes the inner encoding loop against that data.
encodeBase32_ :: Addr# -> ByteString -> ByteString

-- | Head of the unpadded base32 encoding loop.
--   
--   This function takes an alphabet in the form of an unboxed
--   <a>Addr#</a>, allocates the correct number of bytes that will be
--   written, and executes the inner encoding loop against that data.
encodeBase32NoPad_ :: Addr# -> ByteString -> ByteString

-- | Head of the base32 decoding loop.
--   
--   This function takes a base32-decoding lookup table and base32-encoded
--   bytestring, allocates the correct number of bytes that will be
--   written, and executes the inner decoding loop against that data.
decodeBase32_ :: Ptr Word8 -> ByteString -> IO (Either Text ByteString)

-- | Validate a base32-encoded bytestring against some alphabet.
validateBase32 :: ByteString -> ByteString -> Bool

-- | This function checks that the last N-chars of a bytestring are '='
--   and, if true, fails with a message or completes some io action.
--   
--   This is necessary to check when decoding permissively (i.e. filling in
--   padding chars). Consider the following 8 cases of a string of length
--   l:
--   
--   <ul>
--   <li><tt>l = 0 mod 8</tt>: No pad chars are added, since the input is
--   assumed to be good.</li>
--   <li><tt>l = 1 mod 8</tt>: Never an admissible length in base32</li>
--   <li><tt>l = 2 mod 8</tt>: 6 padding chars are added. If padding chars
--   are present in the string, they will fail as to decode as final
--   quanta</li>
--   <li><tt>l = 3 mod 8</tt>: Never an admissible length in base32</li>
--   <li><tt>l = 4 mod 8</tt>: 4 padding chars are added. If 2 padding
--   chars are present in the string this can be "completed" in the sense
--   that it now acts like a string `l == 2 mod 8` with 6 padding chars,
--   and could potentially form corrupted data.</li>
--   <li><tt>l = 5 mod 8</tt>: 3 padding chars are added. If 3 padding
--   chars are present in the string, this could form corrupted data like
--   in the previous case.</li>
--   <li><tt>l = 6 mod 8</tt>: Never an admissible length in base32</li>
--   <li><tt>l = 7 mod 8</tt>: 1 padding char is added. If 5 padding chars
--   are present in the string, this could form corrupted data like the
--   previous cases.</li>
--   </ul>
--   
--   Hence, permissive decodes should only fill in padding chars when it
--   makes sense to add them. That is, if an input is degenerate, it should
--   never succeed when we add padding chars. We need the following
--   invariant to hold:
--   
--   <pre>
--   B32.decodeUnpadded <a>|</a> B32.decodePadded ~ B32.decode
--   </pre>
validateLastNPads :: Int -> ByteString -> IO (Either Text ByteString) -> Either Text ByteString


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32hex encoding
--   format. This includes padded and unpadded decoding variants, as well
--   as internal and external validation for canonicity.
module Data.ByteString.Base32.Hex

-- | Encode a <a>ByteString</a> value as a Base32hex <a>Text</a> value with
--   padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as a Base32hex <a>ByteString</a>
--   value with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32' "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32' :: ByteString -> ByteString

-- | Encode a <a>ByteString</a> value as a Base32hex <a>Text</a> value
--   without padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as a Base32hex <a>ByteString</a>
--   value without padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded' :: ByteString -> ByteString

-- | Decode an arbitrarily padded Base32hex-encoded <a>ByteString</a>
--   value. If its length is not a multiple of 8, then padding characters
--   will be added to fill out the input to a multiple of 8 for safe
--   decoding, as Base32hex-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQM==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ByteString -> Either Text ByteString

-- | Decode an unpadded Base32hex-encoded <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ByteString -> Either Text ByteString

-- | Decode a padded Base32hex-encoded <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ByteString -> Either Text ByteString

-- | Tell whether a <a>ByteString</a> value is encoded in padded or
--   unpadded Base32hex format
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: ByteString -> Bool

-- | Tell whether a <a>ByteString</a> value is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape (including
--   padding/size etc.). To check whether it is a true Base32hex encoded
--   <a>ByteString</a> value, use <tt>isBase32</tt>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: ByteString -> Bool


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32 encoding format.
--   This includes padded and unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.ByteString.Base32

-- | Encode a <a>ByteString</a> value as a Base32 <a>Text</a> value with
--   padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as a Base32 <a>ByteString</a> value
--   with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32' "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32' :: ByteString -> ByteString

-- | Encode a <a>ByteString</a> value as a Base32 <a>Text</a> value without
--   padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as a Base32 <a>ByteString</a> value
--   without padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded' :: ByteString -> ByteString

-- | Decode an arbitrarily padded Base32-encoded <a>ByteString</a> value.
--   If its length is not a multiple of 8, then padding characters will be
--   added to fill out the input to a multiple of 8 for safe decoding, as
--   Base32-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ByteString -> Either Text ByteString

-- | Decode an unpadded Base32-encoded <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ByteString -> Either Text ByteString

-- | Decode a padded Base32-encoded <a>ByteString</a> value.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ByteString -> Either Text ByteString

-- | Tell whether a <a>ByteString</a> value is encoded in padded or
--   unpadded Base32 format
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: ByteString -> Bool

-- | Tell whether a <a>ByteString</a> value is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape (including
--   padding/size etc.). To check whether it is a true Base32 encoded
--   <a>ByteString</a> value, use <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: ByteString -> Bool


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32 encoding format.
--   This includes strictly padded/unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.ByteString.Lazy.Base32

-- | Encode a <a>ByteString</a> value as a Base32 <tt>Text</tt> value with
--   padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: ByteString -> Text

-- | Encode a <a>ByteString</a> as a Base32 <a>ByteString</a> value with
--   padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32' :: ByteString -> ByteString

-- | Encode a <a>ByteString</a> value as Base32 <tt>Text</tt> without
--   padding. Note that for Base32, padding is optional. If you call this
--   function, you will simply be encoding as Base32 and stripping padding
--   chars from the output.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as Base32 without padding. Note that
--   for Base32, padding is optional. If you call this function, you will
--   simply be encoding as Base32 and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded' :: ByteString -> ByteString

-- | Decode an arbitrarily padded Base32 encoded <a>ByteString</a> value.
--   If its length is not a multiple of 4, then padding chars will be added
--   to fill out the input to a multiple of 4 for safe decoding as
--   Base32-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ByteString -> Either Text ByteString

-- | Decode an unpadded Base32-encoded <a>ByteString</a> value. Input
--   strings are required to be unpadded, and will undergo validation prior
--   to decoding to confirm.
--   
--   In general, unless unpadded Base32 is explicitly required, it is safer
--   to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ByteString -> Either Text ByteString

-- | Decode a padded Base32-encoded <a>ByteString</a> value. Input strings
--   are required to be correctly padded, and will be validated prior to
--   decoding to confirm.
--   
--   In general, unless padded Base32 is explicitly required, it is safer
--   to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ByteString -> Either Text ByteString

-- | Tell whether a <a>ByteString</a> is Base32-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: ByteString -> Bool

-- | Tell whether a <a>ByteString</a> is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>ByteString</a> value, use
--   <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: ByteString -> Bool


-- | This module contains <a>ByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32hex encoding
--   format. This includes strictly padded/unpadded decoding variants, as
--   well as internal and external validation for canonicity.
module Data.ByteString.Lazy.Base32.Hex

-- | Encode a <a>ByteString</a> value as a Base32hex <tt>Text</tt> value
--   with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: ByteString -> Text

-- | Encode a <a>ByteString</a> as a Base32hex <a>ByteString</a> value with
--   padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32' "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32' :: ByteString -> ByteString

-- | Encode a <a>ByteString</a> value as Base32hex <tt>Text</tt> without
--   padding. Note that for Base32hex, padding is optional. If you call
--   this function, you will simply be encoding as Base32hex and stripping
--   padding chars from the output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: ByteString -> Text

-- | Encode a <a>ByteString</a> value as Base32hex without padding. Note
--   that for Base32hex, padding is optional. If you call this function,
--   you will simply be encoding as Base32hex and stripping padding chars
--   from the output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded' :: ByteString -> ByteString

-- | Decode an arbitrarily padded Base32hex encoded <a>ByteString</a>
--   value. If its length is not a multiple of 4, then padding chars will
--   be added to fill out the input to a multiple of 4 for safe decoding as
--   Base32hex-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ByteString -> Either Text ByteString

-- | Decode an unpadded Base32hex-encoded <a>ByteString</a> value. Input
--   strings are required to be unpadded, and will undergo validation prior
--   to decoding to confirm.
--   
--   In general, unless unpadded Base32hex is explicitly required, it is
--   safer to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ByteString -> Either Text ByteString

-- | Decode a padded Base32hex-encoded <a>ByteString</a> value. Input
--   strings are required to be correctly padded, and will be validated
--   prior to decoding to confirm.
--   
--   In general, unless padded Base32hex is explicitly required, it is
--   safer to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ByteString -> Either Text ByteString

-- | Tell whether a <a>ByteString</a> is Base32hex-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: ByteString -> Bool

-- | Tell whether a <a>ByteString</a> is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32hex encoded <a>ByteString</a> value, use
--   <a>isBase32Hex</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: ByteString -> Bool


-- | This module contains <a>ShortByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32 encoding format.
--   This includes strictly padded/unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.ByteString.Short.Base32

-- | Encode a <a>ShortByteString</a> value as a Base32 <a>Text</a> value
--   with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: ShortByteString -> ShortText

-- | Encode a <a>ShortByteString</a> as a Base32 <a>ShortByteString</a>
--   value with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32' "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32' :: ShortByteString -> ShortByteString

-- | Encode a <a>ShortByteString</a> value as Base32 <a>Text</a> without
--   padding. Note that for Base32, padding is optional. If you call this
--   function, you will simply be encoding as Base32 and stripping padding
--   chars from the output.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: ShortByteString -> ShortText

-- | Encode a <a>ShortByteString</a> value as Base32 without padding. Note
--   that for Base32, padding is optional. If you call this function, you
--   will simply be encoding as Base32 and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded' :: ShortByteString -> ShortByteString

-- | Decode an arbitrarily padded Base32 encoded <a>ShortByteString</a>
--   value. If its length is not a multiple of 4, then padding chars will
--   be added to fill out the input to a multiple of 4 for safe decoding as
--   Base32-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ShortByteString -> Either Text ShortByteString

-- | Decode an unpadded Base32-encoded <a>ShortByteString</a> value. Input
--   strings are required to be unpadded, and will undergo validation prior
--   to decoding to confirm.
--   
--   In general, unless unpadded Base32 is explicitly required, it is safer
--   to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ShortByteString -> Either Text ShortByteString

-- | Decode a padded Base32-encoded <a>ShortByteString</a> value. Input
--   strings are required to be correctly padded, and will be validated
--   prior to decoding to confirm.
--   
--   In general, unless padded Base32 is explicitly required, it is safer
--   to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ShortByteString -> Either Text ShortByteString

-- | Tell whether a <a>ShortByteString</a> is Base32-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: ShortByteString -> Bool

-- | Tell whether a <a>ShortByteString</a> is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>ShortByteString</a> value, use
--   <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: ShortByteString -> Bool


-- | This module contains <a>ShortByteString</a>-valued combinators for
--   implementing the RFC 4648 specification of the Base32hex encoding
--   format. This includes strictly padded/unpadded and decoding variants,
--   as well as internal and external validation for canonicity.
module Data.ByteString.Short.Base32.Hex

-- | Encode a <a>ShortByteString</a> value as a Base32hex <a>Text</a> value
--   with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: ShortByteString -> ShortText

-- | Encode a <a>ShortByteString</a> as a Base32hex <a>ShortByteString</a>
--   value with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32' "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32' :: ShortByteString -> ShortByteString

-- | Encode a <a>ShortByteString</a> value as Base32hex <a>Text</a> without
--   padding. Note that for Base32hex, padding is optional. If you call
--   this function, you will simply be encoding as Base32hex and stripping
--   padding chars from the output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: ShortByteString -> ShortText

-- | Encode a <a>ShortByteString</a> value as Base32hex without padding.
--   Note that for Base32hex, padding is optional. If you call this
--   function, you will simply be encoding as Base32hex and stripping
--   padding chars from the output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded' "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded' :: ShortByteString -> ShortByteString

-- | Decode an arbitrarily padded Base32hex encoded <a>ShortByteString</a>
--   value. If its length is not a multiple of 4, then padding chars will
--   be added to fill out the input to a multiple of 4 for safe decoding as
--   Base32hex-encoded values are optionally padded.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQM==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ShortByteString -> Either Text ShortByteString

-- | Decode an unpadded Base32hex-encoded <a>ShortByteString</a> value.
--   Input strings are required to be unpadded, and will undergo validation
--   prior to decoding to confirm.
--   
--   In general, unless unpadded Base32hex is explicitly required, it is
--   safer to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ShortByteString -> Either Text ShortByteString

-- | Decode a padded Base32hex-encoded <a>ShortByteString</a> value. Input
--   strings are required to be correctly padded, and will be validated
--   prior to decoding to confirm.
--   
--   In general, unless padded Base32hex is explicitly required, it is
--   safer to call <a>decodeBase32</a>.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ShortByteString -> Either Text ShortByteString

-- | Tell whether a <a>ShortByteString</a> is Base32hex-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: ShortByteString -> Bool

-- | Tell whether a <a>ShortByteString</a> is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>ShortByteString</a> value, use
--   <a>isBase32Hex</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: ShortByteString -> Bool


-- | This module contains the error types raised (not as exceptions!) in
--   the decoding process.
module Data.Text.Encoding.Base32.Error

-- | This data type represents the type of decoding errors of various kinds
--   as they pertain to decoding <a>Text</a> values. Namely, to distinguish
--   between decoding errors from opaque unicode exceptions caught in the
--   unicode decoding process.
data Base32Error e

-- | The error associated with decoding failure as a result of the Base32
--   decoding process
DecodeError :: Text -> Base32Error e

-- | The error associated with the decoding failure as a result of the
--   conversion process
ConversionError :: e -> Base32Error e
instance GHC.Generics.Generic (Data.Text.Encoding.Base32.Error.Base32Error e)
instance GHC.Show.Show e => GHC.Show.Show (Data.Text.Encoding.Base32.Error.Base32Error e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Data.Text.Encoding.Base32.Error.Base32Error e)
instance GHC.Exception.Type.Exception e => GHC.Exception.Type.Exception (Data.Text.Encoding.Base32.Error.Base32Error e)
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Data.Text.Encoding.Base32.Error.Base32Error e)


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base32 encoding format. This
--   includes strictly padded/unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.Text.Encoding.Base32

-- | Encode a <a>Text</a> value in Base32 with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: Text -> Text

-- | Decode an arbitrarily padded Base32-encoded <a>Text</a> value. If its
--   length is not a multiple of 4, then padding chars will be added to
--   fill out the input to a multiple of 4 for safe decoding as base32
--   encodings are optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: Text -> Either Text Text

-- | Attempt to decode a <a>Text</a> value as Base32, converting from
--   <a>ByteString</a> to <a>Text</a> according to some encoding function.
--   In practice, This is something like <tt>decodeUtf8'</tt>, which may
--   produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32With :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Encode a <a>Text</a> value in Base32 without padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: Text -> Text

-- | Decode an unpadded Base32 encoded <a>Text</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <tt>decodeBase32WUnpaddedWith</tt> and pass in a
--   custom decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: Text -> Either Text Text

-- | Attempt to decode an unpadded <a>ByteString</a> value as Base32,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32UnpaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an padded Base32 encoded <a>Text</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: Text -> Either Text Text

-- | Attempt to decode a padded <a>ByteString</a> value as Base32,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32PaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32PaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Tell whether a <a>Text</a> value is Base32-encoded
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: Text -> Bool

-- | Tell whether a <a>Text</a> value is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>Text</a> value, use
--   <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: Text -> Bool


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base32hex encoding format. This
--   includes strictly padded and unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.Text.Encoding.Base32.Hex

-- | Encode a <a>Text</a> value in Base32hex with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: Text -> Text

-- | Decode a padded Base32hex-encoded <a>Text</a> value. If its length is
--   not a multiple of 4, then padding chars will be added to fill out the
--   input to a multiple of 4 for safe decoding as base32hex encodings are
--   optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: Text -> Either Text Text

-- | Attempt to decode a <a>ByteString</a> value as Base32hex, converting
--   from <a>ByteString</a> to <a>Text</a> according to some encoding
--   function. In practice, This is something like <a>decodeUtf8'</a>,
--   which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> <a>decodeUtf8'</a>
--     :: <a>Text</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32With :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Encode a <a>Text</a> value in Base32hex without padding. Note that for
--   Base32hex, padding is optional. If you call this function, you will
--   simply be encoding as Base32hex and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: Text -> Text

-- | Decode an unpadded Base32hex encoded <a>Text</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <tt>decodeBase32WUnpaddedWith</tt> and pass in a
--   custom decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: Text -> Either Text Text

-- | Attempt to decode an unpadded <a>ByteString</a> value as Base32hex,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32UnpaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an padded Base32hex encoded <a>Text</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: Text -> Either Text Text

-- | Attempt to decode a padded <a>ByteString</a> value as Base32hex,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32PaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32PaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Tell whether a <a>Text</a> value is Base32hex-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: Text -> Bool

-- | Tell whether a <a>Text</a> value is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>Text</a> value, use
--   <a>isBase32Hex</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: Text -> Bool


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base32 encoding format. This
--   includes strictly padded/unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.Text.Lazy.Encoding.Base32

-- | Encode a <a>Text</a> value in Base32 with padding.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: Text -> Text

-- | Encode a <a>Text</a> value in Base32 without padding. Note that for
--   Base32, padding is optional. If you call this function, you will
--   simply be encoding as Base32 and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: Text -> Text

-- | Decode an arbitrarily padded Base32-encoded <a>Text</a> value. If its
--   length is not a multiple of 4, then padding chars will be added to
--   fill out the input to a multiple of 4 for safe decoding as base32
--   encodings are optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: Text -> Either Text Text

-- | Attempt to decode a lazy <a>ByteString</a> value as Base32, converting
--   from <a>ByteString</a> to <a>Text</a> according to some encoding
--   function. In practice, This is something like <a>decodeUtf8'</a>,
--   which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32With :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an unpadded Base32 encoded <a>Text</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <tt>decodeBase32WUnpaddedWith</tt> and pass in a
--   custom decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: Text -> Either Text Text

-- | Attempt to decode an unpadded lazy <a>ByteString</a> value as Base32,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32UnpaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an padded Base32 encoded <a>Text</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: Text -> Either Text Text

-- | Attempt to decode a padded lazy <a>ByteString</a> value as Base32,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 6</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32PaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <tt>Text</tt>
--   </pre>
decodeBase32PaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Tell whether a <a>Text</a> value is Base32-encoded
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: Text -> Bool

-- | Tell whether a <a>Text</a> value is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>Text</a> value, use
--   <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: Text -> Bool


-- | This module contains <a>Text</a>-valued combinators for implementing
--   the RFC 4648 specification of the Base32hex encoding format. This
--   includes strictly padded/unpadded decoding variants, as well as
--   internal and external validation for canonicity.
module Data.Text.Lazy.Encoding.Base32.Hex

-- | Encode a <a>Text</a> value in Base32hex with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: Text -> Text

-- | Encode a <a>Text</a> value in Base32hex without padding. Note that for
--   Base32hex, padding is optional. If you call this function, you will
--   simply be encoding as Base32hex and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: Text -> Text

-- | Decode a padded Base32hex-encoded <a>Text</a> value. If its length is
--   not a multiple of 4, then padding chars will be added to fill out the
--   input to a multiple of 4 for safe decoding as base32hex encodings are
--   optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: Text -> Either Text Text

-- | Attempt to decode a lazy <a>ByteString</a> value as Base32hex,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32With :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an unpadded Base32hex encoded <a>Text</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <tt>decodeBase32WUnpaddedWith</tt> and pass in a
--   custom decode function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: Text -> Either Text Text

-- | Attempt to decode an unpadded lazy <a>ByteString</a> value as
--   Base32hex, converting from <a>ByteString</a> to <a>Text</a> according
--   to some encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>Text</a>
--   </pre>
decodeBase32UnpaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Decode an padded Base32hex encoded <a>Text</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: Text -> Either Text Text

-- | Attempt to decode a padded lazy <a>ByteString</a> value as Base32hex,
--   converting from <a>ByteString</a> to <a>Text</a> according to some
--   encoding function. In practice, This is something like
--   <a>decodeUtf8'</a>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Example</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32PaddedWith</a> <a>decodeUtf8'</a>
--     :: <a>ByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <tt>Text</tt>
--   </pre>
decodeBase32PaddedWith :: (ByteString -> Either err Text) -> ByteString -> Either (Base32Error err) Text

-- | Tell whether a <a>Text</a> value is Base32hex-encoded
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: Text -> Bool

-- | Tell whether a <a>Text</a> value is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>Text</a> value, use
--   <a>isBase32Hex</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: Text -> Bool


-- | This module contains <a>ShortText</a>-valued combinators implementing
--   the RFC 4648 specification for the Base32 encoding format. This
--   includes strictly padded/unpadded decoding variants, and external +
--   internal validations for canonicity.
module Data.Text.Short.Encoding.Base32

-- | Encode a <a>ShortText</a> value in Base32 with padding.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "KN2W4==="
--   </pre>
encodeBase32 :: ShortText -> ShortText

-- | Encode a <a>ShortText</a> value in Base32 without padding. Note that
--   for Base32, padding is optional. If you call this function, you will
--   simply be encoding as Base32 and stripping padding chars from the
--   output.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "KN2W4"
--   </pre>
encodeBase32Unpadded :: ShortText -> ShortText

-- | Decode an arbitrarily padded Base32-encoded <a>ShortText</a> value. If
--   its length is not a multiple of 4, then padding chars will be added to
--   fill out the input to a multiple of 4 for safe decoding as base32
--   encodings are optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "KN2W==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ShortText -> Either Text ShortText

-- | Attempt to decode a <a>ShortByteString</a> value as Base32, converting
--   from <tt>ByteString</tt> to <a>ShortText</a> according to some
--   encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> '(fmap fromText . T.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32With :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Decode an unpadded Base32 encoded <a>ShortText</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32UnpaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "KN2W4==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ShortText -> Either Text ShortText

-- | Attempt to decode an unpadded <a>ShortByteString</a> value as Base32,
--   converting from <a>ShortByteString</a> to <a>ShortText</a> according
--   to some encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> '(fmap fromText . T.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32UnpaddedWith :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Decode an padded Base32 encoded <a>ShortText</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "KN2W4"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ShortText -> Either Text ShortText

-- | Attempt to decode a padded <a>ShortByteString</a> value as Base32,
--   converting from <tt>ByteString</tt> to <a>ShortText</a> according to
--   some encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4328 section 6</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> '(fmap fromText . T.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32PaddedWith :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Tell whether a <a>ShortText</a> value is Base32-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32 "KN2W4=="
--   False
--   </pre>
isBase32 :: ShortText -> Bool

-- | Tell whether a <a>ShortText</a> value is a valid Base32 format.
--   
--   This will not tell you whether or not this is a correct Base32
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>ShortText</a> value, use
--   <a>isBase32</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32 "KN2W4%"
--   False
--   </pre>
isValidBase32 :: ShortText -> Bool


-- | This module contains <a>ShortText</a>-valued combinators implementing
--   the RFC 4648 specification for the Base32hex encoding format. This
--   includes strictly padded/unpadded decoding variants, and external +
--   internal validations for canonicity.
module Data.Text.Short.Encoding.Base32.Hex

-- | Encode a <a>ShortText</a> value in Base32hex with padding.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32 "Sun"
--   "ADQMS==="
--   </pre>
encodeBase32 :: ShortText -> ShortText

-- | Encode a <a>ShortText</a> value in Base32hex without padding. Note
--   that for Base32hex, padding is optional. If you call this function,
--   you will simply be encoding as Base32hex and stripping padding chars
--   from the output.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; encodeBase32Unpadded "Sun"
--   "ADQMS"
--   </pre>
encodeBase32Unpadded :: ShortText -> ShortText

-- | Decode an arbitrarily padded Base32hex-encoded <a>ShortText</a> value.
--   If its length is not a multiple of 4, then padding chars will be added
--   to fill out the input to a multiple of 4 for safe decoding as
--   base32hex encodings are optionally padded.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32With</a> and pass in a custom decode
--   function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32 "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32 :: ShortText -> Either Text ShortText

-- | Attempt to decode a <a>ShortByteString</a> value as Base32hex,
--   converting from <tt>ByteString</tt> to <a>ShortText</a> according to
--   some encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> '(fmap fromText . Data.Text.Encoding.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32With :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Decode an unpadded Base32hex encoded <a>ShortText</a> value.
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32UnpaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS"
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Unpadded "ADQMS==="
--   Left "Base32-encoded bytestring has invalid padding"
--   </pre>
decodeBase32Unpadded :: ShortText -> Either Text ShortText

-- | Attempt to decode an unpadded <a>ShortByteString</a> value as
--   Base32hex, converting from <a>ShortByteString</a> to <a>ShortText</a>
--   according to some encoding function. In practice, This is something
--   like <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32UnpaddedWith</a> '(fmap fromText . Data.Text.Encoding.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32UnpaddedWith :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Decode an padded Base32hex encoded <a>ShortText</a> value
--   
--   <i>Note:</i> This function makes sure that decoding is total by
--   deferring to <a>decodeUtf8</a>. This will always round trip for any
--   valid Base32-encoded text value, but it may not round trip for bad
--   inputs. The onus is on the caller to make sure inputs are valid. If
--   unsure, defer to <a>decodeBase32PaddedWith</a> and pass in a custom
--   decode function.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS==="
--   Right "Sun"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; decodeBase32Padded "ADQMS"
--   Left "Base32-encoded bytestring requires padding"
--   </pre>
decodeBase32Padded :: ShortText -> Either Text ShortText

-- | Attempt to decode a padded <a>ShortByteString</a> value as Base32hex,
--   converting from <tt>ByteString</tt> to <a>ShortText</a> according to
--   some encoding function. In practice, This is something like
--   <tt>decodeUtf8'</tt>, which may produce an error.
--   
--   See: <a>RFC-4648 section 7</a>
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   <a>decodeBase32With</a> '(fmap fromText . Data.Text.Encoding.decodeUtf8' . toText)'
--     :: <a>ShortByteString</a> -&gt; <a>Either</a> (<a>Base32Error</a> <tt>UnicodeException</tt>) <a>ShortText</a>
--   </pre>
decodeBase32PaddedWith :: (ShortByteString -> Either err ShortText) -> ShortByteString -> Either (Base32Error err) ShortText

-- | Tell whether a <a>ShortText</a> value is Base32hex-encoded.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS==="
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBase32Hex "ADQMS=="
--   False
--   </pre>
isBase32Hex :: ShortText -> Bool

-- | Tell whether a <a>ShortText</a> value is a valid Base32hex format.
--   
--   This will not tell you whether or not this is a correct Base32hex
--   representation, only that it conforms to the correct shape. To check
--   whether it is a true Base32 encoded <a>ShortText</a> value, use
--   <a>isBase32Hex</a>.
--   
--   <h3><b>Examples</b>:</h3>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS="
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isValidBase32Hex "ADQMS%"
--   False
--   </pre>
isValidBase32Hex :: ShortText -> Bool
