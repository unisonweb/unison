-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple lazy, infinite trie from integers
--   
--   A simple lazy, infinite trie from integers
@package data-inttrie
@version 0.1.4


-- | Provides a minimal infinite, lazy trie for integral types. It
--   intentionally leaves out ideas such as delete and emptiness so that it
--   can be used lazily, eg. as the target of an infinite foldr.
--   Essentially its purpose is to be an efficient implementation of a
--   function from integral type, given point-at-a-time modifications.
module Data.IntTrie

-- | A trie from integers to values of type a.
--   
--   Semantics: [[IntTrie a]] = Integer -&gt; a
data IntTrie a

-- | The identity trie.
--   
--   <pre>
--   apply identity = id
--   </pre>
identity :: (Num a, Bits a) => IntTrie a

-- | Apply the trie to an argument. This is the semantic map.
apply :: (Ord b, Num b, Bits b) => IntTrie a -> b -> a

-- | Modify the function at one point
--   
--   <pre>
--   apply (modify x f t) i | i == x = f (apply t i)
--                          | otherwise = apply t i
--   </pre>
modify :: (Ord b, Num b, Bits b) => b -> (a -> a) -> IntTrie a -> IntTrie a

-- | Modify the function at one point (strict version)
modify' :: (Ord b, Num b, Bits b) => b -> (a -> a) -> IntTrie a -> IntTrie a

-- | Overwrite the function at one point
--   
--   <pre>
--   overwrite i x = modify i (const x)
--   </pre>
overwrite :: (Ord b, Num b, Bits b) => b -> a -> IntTrie a -> IntTrie a

-- | Negate the domain of the function
--   
--   <pre>
--   apply (mirror t) i = apply t (-i)
--   mirror . mirror = id
--   </pre>
mirror :: IntTrie a -> IntTrie a

-- | Modify the function at a (potentially infinite) list of points in
--   ascending order
--   
--   <pre>
--   modifyAscList [(i0, f0)..(iN, fN)] = modify i0 f0 . ... . modify iN fN
--   </pre>
modifyAscList :: (Ord b, Num b, Bits b) => [(b, a -> a)] -> IntTrie a -> IntTrie a

-- | Modify the function at a (potentially infinite) list of points in
--   descending order
modifyDescList :: (Ord b, Num b, Bits b) => [(b, a -> a)] -> IntTrie a -> IntTrie a
instance GHC.Base.Functor Data.IntTrie.IntTrie
instance GHC.Base.Applicative Data.IntTrie.IntTrie
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.IntTrie.IntTrie a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.IntTrie.IntTrie a)
instance GHC.Base.Functor Data.IntTrie.BitTrie
instance GHC.Base.Applicative Data.IntTrie.BitTrie
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.IntTrie.BitTrie a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.IntTrie.BitTrie a)
