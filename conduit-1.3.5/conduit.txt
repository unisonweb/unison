-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Streaming data processing library.
--   
--   <a>conduit</a> is a solution to the streaming data problem, allowing
--   for production, transformation, and consumption of streams of data in
--   constant memory. It is an alternative to lazy I/O which guarantees
--   deterministic resource handling.
--   
--   For more information about conduit in general, and how this package in
--   particular fits into the ecosystem, see <a>the conduit homepage</a>.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/conduit</a>.
@package conduit
@version 1.3.5

module Data.Conduit.Internal.Fusion

-- | This is the same as stream fusion's Step. Constructors are renamed to
--   avoid confusion with conduit names.
data Step s o r
Emit :: s -> o -> Step s o r
Skip :: s -> Step s o r
Stop :: r -> Step s o r
data Stream m o r
Stream :: (s -> m (Step s o r)) -> m s -> Stream m o r
data ConduitWithStream i o m r
type StreamConduitT i o m r = Stream m i () -> Stream m o r
type StreamConduit i m o = StreamConduitT i o m ()
type StreamSource m o = StreamConduitT () o m ()
type StreamProducer m o = forall i. StreamConduitT i o m ()
type StreamSink i m r = StreamConduitT i Void m r
type StreamConsumer i m r = forall o. StreamConduitT i o m r
streamConduit :: ConduitT i o m r -> (Stream m i () -> Stream m o r) -> ConduitWithStream i o m r
streamSource :: Monad m => Stream m o () -> ConduitWithStream i o m ()
streamSourcePure :: Monad m => Stream Identity o () -> ConduitWithStream i o m ()
unstream :: ConduitWithStream i o m r -> ConduitT i o m r
instance GHC.Base.Functor (Data.Conduit.Internal.Fusion.Step s o)

module Data.Conduit.Internal.List.Stream
unfoldS :: Monad m => (b -> Maybe (a, b)) -> b -> StreamProducer m a
unfoldEitherS :: Monad m => (b -> Either r (a, b)) -> b -> StreamConduitT i a m r
unfoldMS :: Monad m => (b -> m (Maybe (a, b))) -> b -> StreamProducer m a
unfoldEitherMS :: Monad m => (b -> m (Either r (a, b))) -> b -> StreamConduitT i a m r
sourceListS :: Monad m => [a] -> StreamProducer m a
enumFromToS :: (Enum a, Ord a, Monad m) => a -> a -> StreamProducer m a
enumFromToS_int :: (Integral a, Monad m) => a -> a -> StreamProducer m a
iterateS :: Monad m => (a -> a) -> a -> StreamProducer m a
replicateS :: Monad m => Int -> a -> StreamProducer m a
replicateMS :: Monad m => Int -> m a -> StreamProducer m a
foldS :: Monad m => (b -> a -> b) -> b -> StreamConsumer a m b
foldMS :: Monad m => (b -> a -> m b) -> b -> StreamConsumer a m b
mapM_S :: Monad m => (a -> m ()) -> StreamConsumer a m ()
dropS :: Monad m => Int -> StreamConsumer a m ()
takeS :: Monad m => Int -> StreamConsumer a m [a]
headS :: Monad m => StreamConsumer a m (Maybe a)
mapS :: Monad m => (a -> b) -> StreamConduit a m b
mapMS :: Monad m => (a -> m b) -> StreamConduit a m b
iterMS :: Monad m => (a -> m ()) -> StreamConduit a m a
mapMaybeS :: Monad m => (a -> Maybe b) -> StreamConduit a m b
mapMaybeMS :: Monad m => (a -> m (Maybe b)) -> StreamConduit a m b
catMaybesS :: Monad m => StreamConduit (Maybe a) m a
concatS :: (Monad m, Foldable f) => StreamConduit (f a) m a
concatMapS :: Monad m => (a -> [b]) -> StreamConduit a m b
concatMapMS :: Monad m => (a -> m [b]) -> StreamConduit a m b
concatMapAccumS :: Monad m => (a -> accum -> (accum, [b])) -> accum -> StreamConduit a m b
mapAccumS :: Monad m => (a -> s -> (s, b)) -> s -> StreamConduitT a b m s
mapAccumMS :: Monad m => (a -> s -> m (s, b)) -> s -> StreamConduitT a b m s
concatMapAccumMS :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> StreamConduit a m b
mapFoldableS :: (Monad m, Foldable f) => (a -> f b) -> StreamConduit a m b
mapFoldableMS :: (Monad m, Foldable f) => (a -> m (f b)) -> StreamConduit a m b
consumeS :: Monad m => StreamConsumer a m [a]
groupByS :: Monad m => (a -> a -> Bool) -> StreamConduit a m [a]
groupOn1S :: (Monad m, Eq b) => (a -> b) -> StreamConduit a m (a, [a])
data GroupByState a b s
GBStart :: s -> GroupByState a b s
GBLoop :: ([a] -> [a]) -> a -> b -> s -> GroupByState a b s
GBDone :: GroupByState a b s
groupBy1S :: Monad m => (a -> b) -> (b -> b -> Bool) -> StreamConduit a m (a, [a])
isolateS :: Monad m => Int -> StreamConduit a m a
filterS :: Monad m => (a -> Bool) -> StreamConduit a m a
sinkNullS :: Monad m => StreamConsumer a m ()
sourceNullS :: Monad m => StreamProducer m a


-- | These are stream fusion versions of some of the functions in
--   <a>Data.Conduit.Combinators</a>. Many functions don't have stream
--   versions here because instead they have <tt>RULES</tt> which inline a
--   definition that fuses.
module Data.Conduit.Combinators.Stream
yieldManyS :: (Monad m, MonoFoldable mono) => mono -> StreamProducer m (Element mono)
repeatMS :: Monad m => m a -> StreamProducer m a
repeatWhileMS :: Monad m => m a -> (a -> Bool) -> StreamProducer m a
foldl1S :: Monad m => (a -> a -> a) -> StreamConsumer a m (Maybe a)
allS :: Monad m => (a -> Bool) -> StreamConsumer a m Bool
anyS :: Monad m => (a -> Bool) -> StreamConsumer a m Bool
sinkLazyS :: (Monad m, LazySequence lazy strict) => StreamConsumer strict m lazy
sinkVectorS :: (Vector v a, PrimMonad m) => StreamConsumer a m (v a)
sinkVectorNS :: (Vector v a, PrimMonad m) => Int -> StreamConsumer a m (v a)
sinkLazyBuilderS :: Monad m => StreamConsumer Builder m ByteString
lastS :: Monad m => StreamConsumer a m (Maybe a)
lastES :: (Monad m, IsSequence seq) => StreamConsumer seq m (Maybe (Element seq))
findS :: Monad m => (a -> Bool) -> StreamConsumer a m (Maybe a)
concatMapS :: (Monad m, MonoFoldable mono) => (a -> mono) -> StreamConduit a m (Element mono)
concatMapMS :: (Monad m, MonoFoldable mono) => (a -> m mono) -> StreamConduit a m (Element mono)
concatS :: (Monad m, MonoFoldable mono) => StreamConduit mono m (Element mono)
scanlS :: Monad m => (a -> b -> a) -> a -> StreamConduit b m a
scanlMS :: Monad m => (a -> b -> m a) -> a -> StreamConduit b m a
mapAccumWhileS :: Monad m => (a -> s -> Either s (s, b)) -> s -> StreamConduitT a b m s
mapAccumWhileMS :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> StreamConduitT a b m s
intersperseS :: Monad m => a -> StreamConduit a m a
slidingWindowS :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> StreamConduit a m seq
filterMS :: Monad m => (a -> m Bool) -> StreamConduit a m a
splitOnUnboundedES :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> StreamConduit seq m seq

-- | Streaming versions of
--   <tt>Data.Conduit.Combinators.Internal.initReplicate</tt>
initReplicateS :: Monad m => m seed -> (seed -> m a) -> Int -> StreamProducer m a

-- | Streaming versions of
--   <tt>Data.Conduit.Combinators.Internal.initRepeat</tt>
initRepeatS :: Monad m => m seed -> (seed -> m a) -> StreamProducer m a


-- | If this is your first time with conduit, you should probably start
--   with the tutorial: <a>https://github.com/snoyberg/conduit#readme</a>.
module Data.Conduit

-- | Core datatype of the conduit package. This type represents a general
--   component which can consume a stream of input values <tt>i</tt>,
--   produce a stream of output values <tt>o</tt>, perform actions in the
--   <tt>m</tt> monad, and produce a final result <tt>r</tt>. The type
--   synonyms provided here are simply wrappers around this type.
--   
--   Since 1.3.0
data ConduitT i o m r

-- | Provides a stream of output values, without consuming any input or
--   producing a final result.
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Source m o = ConduitT () o m ()

-- | Consumes a stream of input values and produces a stream of output
--   values, without producing a final result.
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Conduit i m o = ConduitT i o m ()

-- | Consumes a stream of input values and produces a final result, without
--   producing any output.
--   
--   <pre>
--   type Sink i m r = ConduitT i Void m r
--   </pre>
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Sink i = ConduitT i Void

-- | Same as <a>ConduitT</a>, for backwards compat
type ConduitM = ConduitT

-- | Combine two <tt>Conduit</tt>s together into a new <tt>Conduit</tt>
--   (aka <a>fuse</a>).
--   
--   Output from the upstream (left) conduit will be fed into the
--   downstream (right) conduit. Processing will terminate when downstream
--   (right) returns. Leftover data returned from the right
--   <tt>Conduit</tt> will be discarded.
--   
--   Equivalent to <a>fuse</a> and <a>=$=</a>, however the latter is
--   deprecated and will be removed in a future version.
--   
--   Note that, while this operator looks like categorical composition
--   (from <a>Control.Category</a>), there are a few reasons it's
--   different:
--   
--   <ul>
--   <li>The position of the type parameters to <a>ConduitT</a> do not
--   match. We would need to change <tt>ConduitT i o m r</tt> to
--   <tt>ConduitT r m i o</tt>, which would preclude a <a>Monad</a> or
--   <a>MonadTrans</a> instance.</li>
--   <li>The result value from upstream and downstream are allowed to
--   differ between upstream and downstream. In other words, we would need
--   the type signature here to look like <tt>ConduitT a b m r -&gt;
--   ConduitT b c m r -&gt; ConduitT a c m r</tt>.</li>
--   <li>Due to leftovers, we do not have a left identity in Conduit. This
--   can be achieved with the underlying <tt>Pipe</tt> datatype, but this
--   is not generally recommended. See
--   <a>https://stackoverflow.com/a/15263700</a>.</li>
--   </ul>
(.|) :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r
infixr 2 .|

-- | Equivalent to using <a>runConduit</a> and <a>.|</a> together.
--   
--   Since 1.2.3
connect :: Monad m => ConduitT () a m () -> ConduitT a Void m r -> m r

-- | Named function synonym for <a>.|</a>
--   
--   Equivalent to <a>.|</a> and <a>=$=</a>. However, the latter is
--   deprecated and will be removed in a future version.
--   
--   Since 1.2.3
fuse :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r

-- | The connect operator, which pulls data from a source and pushes to a
--   sink. If you would like to keep the <tt>Source</tt> open to be used
--   for other operations, use the connect-and-resume operator <a>$$+</a>.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use runConduit and .|</i>
($$) :: Monad m => Source m a -> Sink a m b -> m b
infixr 0 $$

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
($=) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixl 1 $=

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
(=$) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixr 2 =$

-- | Deprecated fusion operator.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
(=$=) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixr 2 =$=

-- | Fuse two <tt>ConduitT</tt>s together, and provide the return value of
--   both. Note that this will force the entire upstream <tt>ConduitT</tt>
--   to be run to produce the result value, even if the downstream
--   terminates early.
--   
--   Since 1.1.5
fuseBoth :: Monad m => ConduitT a b m r1 -> ConduitT b c m r2 -> ConduitT a c m (r1, r2)

-- | Like <a>fuseBoth</a>, but does not force consumption of the
--   <tt>Producer</tt>. In the case that the <tt>Producer</tt> terminates,
--   the result value is provided as a <tt>Just</tt> value. If it does not
--   terminate, then a <tt>Nothing</tt> value is returned.
--   
--   One thing to note here is that "termination" here only occurs if the
--   <tt>Producer</tt> actually yields a <tt>Nothing</tt> value. For
--   example, with the <tt>Producer</tt> <tt>mapM_ yield [1..5]</tt>, if
--   five values are requested, the <tt>Producer</tt> has not yet
--   terminated. Termination only occurs when the sixth value is awaited
--   for and the <tt>Producer</tt> signals termination.
--   
--   Since 1.2.4
fuseBothMaybe :: Monad m => ConduitT a b m r1 -> ConduitT b c m r2 -> ConduitT a c m (Maybe r1, r2)

-- | Same as <tt>fuseBoth</tt>, but ignore the return value from the
--   downstream <tt>Conduit</tt>. Same caveats of forced consumption apply.
--   
--   Since 1.1.5
fuseUpstream :: Monad m => ConduitT a b m r -> ConduitT b c m () -> ConduitT a c m r

-- | Wait for a single input value from upstream. If no data is available,
--   returns <tt>Nothing</tt>. Once <tt>await</tt> returns
--   <tt>Nothing</tt>, subsequent calls will also return <tt>Nothing</tt>.
--   
--   Since 0.5.0
await :: Monad m => ConduitT i o m (Maybe i)

-- | Send a value downstream to the next component to consume. If the
--   downstream component terminates, this call will never return control.
--   
--   Since 0.5.0
yield :: Monad m => o -> ConduitT i o m ()

-- | Send a monadic value downstream for the next component to consume.
yieldM :: Monad m => m o -> ConduitT i o m ()

-- | Provide a single piece of leftover input to be consumed by the next
--   component in the current monadic binding.
--   
--   <i>Note</i>: it is highly encouraged to only return leftover values
--   from input already consumed from upstream.
leftover :: i -> ConduitT i o m ()

-- | Run a pipeline until processing completes.
--   
--   Since 1.2.1
runConduit :: Monad m => ConduitT () Void m r -> m r

-- | Run a pure pipeline until processing completes, i.e. a pipeline with
--   <tt>Identity</tt> as the base monad. This is equivalient to
--   <tt>runIdentity . runConduit</tt>.
runConduitPure :: ConduitT () Void Identity r -> r

-- | Run a pipeline which acquires resources with <tt>ResourceT</tt>, and
--   then run the <tt>ResourceT</tt> transformer. This is equivalent to
--   <tt>runResourceT . runConduit</tt>.
runConduitRes :: MonadUnliftIO m => ConduitT () Void (ResourceT m) r -> m r

-- | Bracket a conduit computation between allocation and release of a
--   resource. Two guarantees are given about resource finalization:
--   
--   <ol>
--   <li>It will be <i>prompt</i>. The finalization will be run as early as
--   possible.</li>
--   <li>It is exception safe. Due to usage of <tt>resourcet</tt>, the
--   finalization will be run in the event of any exceptions.</li>
--   </ol>
--   
--   Since 0.5.0
bracketP :: MonadResource m => IO a -> (a -> IO ()) -> (a -> ConduitT i o m r) -> ConduitT i o m r

-- | Catch all exceptions thrown by the current component of the pipeline.
--   
--   Note: this will <i>not</i> catch exceptions thrown by other
--   components! For example, if an exception is thrown in a
--   <tt>Source</tt> feeding to a <tt>Sink</tt>, and the <tt>Sink</tt> uses
--   <tt>catchC</tt>, the exception will <i>not</i> be caught.
--   
--   Due to this behavior (as well as lack of async exception safety), you
--   should not try to implement combinators such as <tt>onException</tt>
--   in terms of this primitive function.
--   
--   Note also that the exception handling will <i>not</i> be applied to
--   any finalizers generated by this conduit.
--   
--   Since 1.0.11
catchC :: (MonadUnliftIO m, Exception e) => ConduitT i o m r -> (e -> ConduitT i o m r) -> ConduitT i o m r

-- | The same as <tt>flip catchC</tt>.
--   
--   Since 1.0.11
handleC :: (MonadUnliftIO m, Exception e) => (e -> ConduitT i o m r) -> ConduitT i o m r -> ConduitT i o m r

-- | A version of <tt>try</tt> for use within a pipeline. See the comments
--   in <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
tryC :: (MonadUnliftIO m, Exception e) => ConduitT i o m r -> ConduitT i o m (Either e r)

-- | A component which produces a stream of output values, regardless of
--   the input stream. A <tt>Producer</tt> is a generalization of a
--   <tt>Source</tt>, and can be used as either a <tt>Source</tt> or a
--   <tt>Conduit</tt>.
--   
--   Since 1.0.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Producer m o = forall i. ConduitT i o m ()

-- | A component which consumes a stream of input values and produces a
--   final result, regardless of the output stream. A <tt>Consumer</tt> is
--   a generalization of a <tt>Sink</tt>, and can be used as either a
--   <tt>Sink</tt> or a <tt>Conduit</tt>.
--   
--   Since 1.0.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Consumer i m r = forall o. ConduitT i o m r

-- | Generalize a <a>Source</a> to a <a>Producer</a>.
--   
--   Since 1.0.0
toProducer :: Monad m => ConduitT () a m () -> ConduitT i a m ()

-- | Generalize a <a>Sink</a> to a <a>Consumer</a>.
--   
--   Since 1.0.0
toConsumer :: Monad m => ConduitT a Void m b -> ConduitT a o m b

-- | Wait for input forever, calling the given inner component for each
--   piece of new input.
--   
--   This function is provided as a convenience for the common pattern of
--   <tt>await</tt>ing input, checking if it's <tt>Just</tt> and then
--   looping.
--   
--   Since 0.5.0
awaitForever :: Monad m => (i -> ConduitT i o m r) -> ConduitT i o m ()

-- | Transform the monad that a <tt>ConduitT</tt> lives in.
--   
--   Note that the monad transforming function will be run multiple times,
--   resulting in unintuitive behavior in some cases. For a fuller
--   treatment, please see:
--   
--   
--   <a>https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers</a>
--   
--   Since 0.4.0
transPipe :: Monad m => (forall a. m a -> n a) -> ConduitT i o m r -> ConduitT i o n r

-- | Apply a function to all the output values of a <tt>ConduitT</tt>.
--   
--   This mimics the behavior of <a>fmap</a> for a <a>Source</a> and
--   <a>Conduit</a> in pre-0.4 days. It can also be simulated by fusing
--   with the <tt>map</tt> conduit from <a>Data.Conduit.List</a>.
--   
--   Since 0.4.1
mapOutput :: Monad m => (o1 -> o2) -> ConduitT i o1 m r -> ConduitT i o2 m r

-- | Same as <a>mapOutput</a>, but use a function that returns
--   <tt>Maybe</tt> values.
--   
--   Since 0.5.0
mapOutputMaybe :: Monad m => (o1 -> Maybe o2) -> ConduitT i o1 m r -> ConduitT i o2 m r

-- | Apply a function to all the input values of a <tt>ConduitT</tt>.
--   
--   Since 0.5.0
mapInput :: Monad m => (i1 -> i2) -> (i2 -> Maybe i1) -> ConduitT i2 o m r -> ConduitT i1 o m r

-- | Apply a monadic action to all the input values of a <tt>ConduitT</tt>.
--   
--   Since 1.3.2
mapInputM :: Monad m => (i1 -> m i2) -> (i2 -> m (Maybe i1)) -> ConduitT i2 o m r -> ConduitT i1 o m r

-- | Merge a <tt>Source</tt> into a <tt>Conduit</tt>. The new conduit will
--   stop processing once either source or upstream have been exhausted.
mergeSource :: Monad m => ConduitT () i m () -> ConduitT a (i, a) m ()

-- | Turn a <tt>Sink</tt> into a <tt>Conduit</tt> in the following way:
--   
--   <ul>
--   <li>All input passed to the <tt>Sink</tt> is yielded downstream.</li>
--   <li>When the <tt>Sink</tt> finishes processing, the result is passed
--   to the provided to the finalizer function.</li>
--   </ul>
--   
--   Note that the <tt>Sink</tt> will stop receiving input as soon as the
--   downstream it is connected to shuts down.
--   
--   An example usage would be to write the result of a <tt>Sink</tt> to
--   some mutable variable while allowing other processing to continue.
--   
--   Since 1.1.0
passthroughSink :: Monad m => ConduitT i Void m r -> (r -> m ()) -> ConduitT i i m ()

-- | Convert a <tt>Source</tt> into a list. The basic functionality can be
--   explained as:
--   
--   <pre>
--   sourceToList src = src $$ Data.Conduit.List.consume
--   </pre>
--   
--   However, <tt>sourceToList</tt> is able to produce its results lazily,
--   which cannot be done when running a conduit pipeline in general.
--   Unlike the <tt>Data.Conduit.Lazy</tt> module (in conduit-extra), this
--   function performs no unsafe I/O operations, and therefore can only be
--   as lazy as the underlying monad.
--   
--   Since 1.2.6
sourceToList :: Monad m => ConduitT () a m () -> m [a]

-- | In order to provide for efficient monadic composition, the
--   <tt>ConduitT</tt> type is implemented internally using a technique
--   known as the codensity transform. This allows for cheap appending, but
--   makes one case much more expensive: partially running a
--   <tt>ConduitT</tt> and that capturing the new state.
--   
--   This data type is the same as <tt>ConduitT</tt>, but does not use the
--   codensity transform technique.
data SealedConduitT i o m r
sealConduitT :: ConduitT i o m r -> SealedConduitT i o m r
unsealConduitT :: Monad m => SealedConduitT i o m r -> ConduitT i o m r

-- | The connect-and-resume operator. This does not close the
--   <tt>Source</tt>, but instead returns it to be used again. This allows
--   a <tt>Source</tt> to be used incrementally in a large program, without
--   forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Mnemonic: connect + do more.
--   
--   Since 0.5.0
($$+) :: Monad m => ConduitT () a m () -> ConduitT a Void m b -> m (SealedConduitT () a m (), b)
infixr 0 $$+

-- | Continue processing after usage of <tt>$$+</tt>.
--   
--   Since 0.5.0
($$++) :: Monad m => SealedConduitT () a m () -> ConduitT a Void m b -> m (SealedConduitT () a m (), b)
infixr 0 $$++

-- | Same as <tt>$$++</tt> and <tt>connectResume</tt>, but doesn't include
--   the updated <tt>SealedConduitT</tt>.
--   
--   <i>NOTE</i> In previous versions, this would cause finalizers to run.
--   Since version 1.3.0, there are no finalizers in conduit.
--   
--   Since 0.5.0
($$+-) :: Monad m => SealedConduitT () a m () -> ConduitT a Void m b -> m b
infixr 0 $$+-

-- | Left fusion for a sealed source.
--   
--   Since 1.0.16
($=+) :: Monad m => SealedConduitT () a m () -> ConduitT a b m () -> SealedConduitT () b m ()
infixl 1 $=+

-- | The connect-and-resume operator. This does not close the
--   <tt>Conduit</tt>, but instead returns it to be used again. This allows
--   a <tt>Conduit</tt> to be used incrementally in a large program,
--   without forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Leftover data returned from the <tt>Sink</tt> will be discarded.
--   
--   Mnemonic: connect + do more.
--   
--   Since 1.0.17
(=$$+) :: Monad m => ConduitT a b m () -> ConduitT b Void m r -> ConduitT a Void m (SealedConduitT a b m (), r)
infixr 0 =$$+

-- | Continue processing after usage of <a>=$$+</a>. Connect a
--   <a>SealedConduitT</a> to a sink and return the output of the sink
--   together with a new <a>SealedConduitT</a>.
--   
--   Since 1.0.17
(=$$++) :: Monad m => SealedConduitT i o m () -> ConduitT o Void m r -> ConduitT i Void m (SealedConduitT i o m (), r)
infixr 0 =$$++

-- | Same as <tt>=$$++</tt>, but doesn't include the updated
--   <tt>SealedConduitT</tt>.
--   
--   <i>NOTE</i> In previous versions, this would cause finalizers to run.
--   Since version 1.3.0, there are no finalizers in conduit.
--   
--   Since 1.0.17
(=$$+-) :: Monad m => SealedConduitT i o m () -> ConduitT o Void m r -> ConduitT i Void m r
infixr 0 =$$+-

-- | Similar to <tt>fuseReturnLeftovers</tt>, but use the provided function
--   to convert downstream leftovers to upstream leftovers.
--   
--   Since 1.0.17
fuseLeftovers :: Monad m => ([b] -> [a]) -> ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r

-- | Same as normal fusion (e.g. <tt>=$=</tt>), except instead of
--   discarding leftovers from the downstream component, return them.
--   
--   Since 1.0.17
fuseReturnLeftovers :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m (r, [b])

-- | Provide for a stream of data that can be flushed.
--   
--   A number of <tt>Conduit</tt>s (e.g., zlib compression) need the
--   ability to flush the stream at some point. This provides a single
--   wrapper datatype to be used in all such circumstances.
--   
--   Since 0.3.0
data Flush a
Chunk :: a -> Flush a
Flush :: Flush a

-- | A wrapper for defining an <a>Applicative</a> instance for
--   <a>Source</a>s which allows to combine sources together, generalizing
--   <a>zipSources</a>. A combined source will take input yielded from each
--   of its <tt>Source</tt>s until any of them stop producing output.
--   
--   Since 1.0.13
newtype ZipSource m o
ZipSource :: ConduitT () o m () -> ZipSource m o
[getZipSource] :: ZipSource m o -> ConduitT () o m ()

-- | Coalesce all values yielded by all of the <tt>Source</tt>s.
--   
--   Implemented on top of <tt>ZipSource</tt> and as such, it exhibits the
--   same short-circuiting behavior as <tt>ZipSource</tt>. See that data
--   type for more details. If you want to create a source that yields
--   *all* values from multiple sources, use <a>sequence_</a>.
--   
--   Since 1.0.13
sequenceSources :: (Traversable f, Monad m) => f (ConduitT () o m ()) -> ConduitT () (f o) m ()

-- | A wrapper for defining an <a>Applicative</a> instance for <a>Sink</a>s
--   which allows to combine sinks together, generalizing <a>zipSinks</a>.
--   A combined sink distributes the input to all its participants and when
--   all finish, produces the result. This allows to define functions like
--   
--   <pre>
--   sequenceSinks :: (Monad m)
--             =&gt; [ConduitT i Void m r] -&gt; ConduitT i Void m [r]
--   sequenceSinks = getZipSink . sequenceA . fmap ZipSink
--   </pre>
--   
--   Note that the standard <a>Applicative</a> instance for conduits works
--   differently. It feeds one sink with input until it finishes, then
--   switches to another, etc., and at the end combines their results.
--   
--   This newtype is in fact a type constrained version of
--   <a>ZipConduit</a>, and has the same behavior. It's presented as a
--   separate type since (1) it historically predates <tt>ZipConduit</tt>,
--   and (2) the type constraining can make your code clearer (and thereby
--   make your error messages more easily understood).
--   
--   Since 1.0.13
newtype ZipSink i m r
ZipSink :: ConduitT i Void m r -> ZipSink i m r
[getZipSink] :: ZipSink i m r -> ConduitT i Void m r

-- | Send incoming values to all of the <tt>Sink</tt> providing, and
--   ultimately coalesce together all return values.
--   
--   Implemented on top of <tt>ZipSink</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSinks :: (Traversable f, Monad m) => f (ConduitT i Void m r) -> ConduitT i Void m (f r)

-- | Provides an alternative <tt>Applicative</tt> instance for
--   <tt>ConduitT</tt>. In this instance, every incoming value is provided
--   to all <tt>ConduitT</tt>s, and output is coalesced together. Leftovers
--   from individual <tt>ConduitT</tt>s will be used within that component,
--   and then discarded at the end of their computation. Output and
--   finalizers will both be handled in a left-biased manner.
--   
--   As an example, take the following program:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       let src = mapM_ yield [1..3 :: Int]
--           conduit1 = CL.map (+1)
--           conduit2 = CL.concatMap (replicate 2)
--           conduit = getZipConduit $ ZipConduit conduit1 &lt;* ZipConduit conduit2
--           sink = CL.mapM_ print
--       src $$ conduit =$ sink
--   </pre>
--   
--   It will produce the output: 2, 1, 1, 3, 2, 2, 4, 3, 3
--   
--   Since 1.0.17
newtype ZipConduit i o m r
ZipConduit :: ConduitT i o m r -> ZipConduit i o m r
[getZipConduit] :: ZipConduit i o m r -> ConduitT i o m r

-- | Provide identical input to all of the <tt>Conduit</tt>s and combine
--   their outputs into a single stream.
--   
--   Implemented on top of <tt>ZipConduit</tt>, see that data type for more
--   details.
--   
--   Since 1.0.17
sequenceConduits :: (Traversable f, Monad m) => f (ConduitT i o m r) -> ConduitT i o m (f r)

-- | Uninhabited data type
data () => Void

module Data.Conduit.Internal

-- | The underlying datatype for all the types in this package. In has six
--   type parameters:
--   
--   <ul>
--   <li><i>l</i> is the type of values that may be left over from this
--   <tt>Pipe</tt>. A <tt>Pipe</tt> with no leftovers would use
--   <tt>Void</tt> here, and one with leftovers would use the same type as
--   the <i>i</i> parameter. Leftovers are automatically provided to the
--   next <tt>Pipe</tt> in the monadic chain.</li>
--   <li><i>i</i> is the type of values for this <tt>Pipe</tt>'s input
--   stream.</li>
--   <li><i>o</i> is the type of values for this <tt>Pipe</tt>'s output
--   stream.</li>
--   <li><i>u</i> is the result type from the upstream <tt>Pipe</tt>.</li>
--   <li><i>m</i> is the underlying monad.</li>
--   <li><i>r</i> is the result type.</li>
--   </ul>
--   
--   A basic intuition is that every <tt>Pipe</tt> produces a stream of
--   output values (<i>o</i>), and eventually indicates that this stream is
--   terminated by sending a result (<i>r</i>). On the receiving end of a
--   <tt>Pipe</tt>, these become the <i>i</i> and <i>u</i> parameters.
--   
--   Since 0.5.0
data Pipe l i o u m r

-- | Provide new output to be sent downstream. This constructor has two
--   fields: the next <tt>Pipe</tt> to be used and the output value.
HaveOutput :: Pipe l i o u m r -> o -> Pipe l i o u m r

-- | Request more input from upstream. The first field takes a new input
--   value and provides a new <tt>Pipe</tt>. The second takes an upstream
--   result value, which indicates that upstream is producing no more
--   results.
NeedInput :: (i -> Pipe l i o u m r) -> (u -> Pipe l i o u m r) -> Pipe l i o u m r

-- | Processing with this <tt>Pipe</tt> is complete, providing the final
--   result.
Done :: r -> Pipe l i o u m r

-- | Require running of a monadic action to get the next <tt>Pipe</tt>.
PipeM :: m (Pipe l i o u m r) -> Pipe l i o u m r

-- | Return leftover input, which should be provided to future operations.
Leftover :: Pipe l i o u m r -> l -> Pipe l i o u m r

-- | Wait for a single input value from upstream.
--   
--   Since 0.5.0
await :: Pipe l i o u m (Maybe i)

-- | This is similar to <tt>await</tt>, but will return the upstream result
--   value as <tt>Left</tt> if available.
--   
--   Since 0.5.0
awaitE :: Pipe l i o u m (Either u i)

-- | Wait for input forever, calling the given inner <tt>Pipe</tt> for each
--   piece of new input. Returns the upstream result type.
--   
--   Since 0.5.0
awaitForever :: Monad m => (i -> Pipe l i o r m r') -> Pipe l i o r m r

-- | Send a single output value downstream. If the downstream <tt>Pipe</tt>
--   terminates, this <tt>Pipe</tt> will terminate as well.
--   
--   Since 0.5.0
yield :: Monad m => o -> Pipe l i o u m ()
yieldM :: Monad m => m o -> Pipe l i o u m ()

-- | Provide a single piece of leftover input to be consumed by the next
--   pipe in the current monadic binding.
--   
--   <i>Note</i>: it is highly encouraged to only return leftover values
--   from input already consumed from upstream.
--   
--   Since 0.5.0
leftover :: l -> Pipe l i o u m ()

-- | Split a pipe into head and tail.
--   
--   Since 1.3.3
unconsM :: Monad m => Pipe Void () o () m () -> m (Maybe (o, Pipe Void () o () m ()))

-- | Split a pipe into head and tail or return its result if it is done.
--   
--   Since 1.3.3
unconsEitherM :: Monad m => Pipe Void () o () m r -> m (Either r (o, Pipe Void () o () m r))

-- | Bracket a pipe computation between allocation and release of a
--   resource. We guarantee, via the <tt>MonadResource</tt> context, that
--   the resource finalization is exception safe. However, it will not
--   necessarily be <i>prompt</i>, in that running a finalizer may wait
--   until the <tt>ResourceT</tt> block exits.
--   
--   Since 0.5.0
bracketP :: MonadResource m => IO a -> (a -> IO ()) -> (a -> Pipe l i o u m r) -> Pipe l i o u m r

-- | The identity <tt>Pipe</tt>.
--   
--   Since 0.5.0
idP :: Monad m => Pipe l a a r m r

-- | Compose a left and right pipe together into a complete pipe.
--   
--   Since 0.5.0
pipe :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2

-- | Same as <a>pipe</a>, but automatically applies <a>injectLeftovers</a>
--   to the right <tt>Pipe</tt>.
--   
--   Since 0.5.0
pipeL :: Monad m => Pipe l a b r0 m r1 -> Pipe b b c r1 m r2 -> Pipe l a c r0 m r2

-- | Run a pipeline until processing completes.
--   
--   Since 0.5.0
runPipe :: Monad m => Pipe Void () Void () m r -> m r

-- | Transforms a <tt>Pipe</tt> that provides leftovers to one which does
--   not, allowing it to be composed.
--   
--   This function will provide any leftover values within this
--   <tt>Pipe</tt> to any calls to <tt>await</tt>. If there are more
--   leftover values than are demanded, the remainder are discarded.
--   
--   Since 0.5.0
injectLeftovers :: Monad m => Pipe i i o u m r -> Pipe l i o u m r

-- | Fuse together two <tt>Pipe</tt>s, connecting the output from the left
--   to the input of the right.
--   
--   Notice that the <i>leftover</i> parameter for the <tt>Pipe</tt>s must
--   be <tt>Void</tt>. This ensures that there is no accidental data loss
--   of leftovers during fusion. If you have a <tt>Pipe</tt> with
--   leftovers, you must first call <a>injectLeftovers</a>.
--   
--   Since 0.5.0
(>+>) :: Monad m => Pipe l a b r0 m r1 -> Pipe Void b c r1 m r2 -> Pipe l a c r0 m r2
infixl 9 >+>

-- | Same as <a>&gt;+&gt;</a>, but reverse the order of the arguments.
--   
--   Since 0.5.0
(<+<) :: Monad m => Pipe Void b c r1 m r2 -> Pipe l a b r0 m r1 -> Pipe l a c r0 m r2
infixr 9 <+<

-- | See <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
catchP :: (MonadUnliftIO m, Exception e) => Pipe l i o u m r -> (e -> Pipe l i o u m r) -> Pipe l i o u m r

-- | The same as <tt>flip catchP</tt>.
--   
--   Since 1.0.11
handleP :: (MonadUnliftIO m, Exception e) => (e -> Pipe l i o u m r) -> Pipe l i o u m r -> Pipe l i o u m r

-- | See <tt>tryC</tt> for more details.
--   
--   Since 1.0.11
tryP :: (MonadUnliftIO m, Exception e) => Pipe l i o u m r -> Pipe l i o u m (Either e r)

-- | Transform the monad that a <tt>Pipe</tt> lives in.
--   
--   Note that the monad transforming function will be run multiple times,
--   resulting in unintuitive behavior in some cases. For a fuller
--   treatment, please see:
--   
--   
--   <a>https://github.com/snoyberg/conduit/wiki/Dealing-with-monad-transformers</a>
--   
--   This function is just a synonym for <tt>hoist</tt>.
--   
--   Since 0.4.0
transPipe :: Monad m => (forall a. m a -> n a) -> Pipe l i o u m r -> Pipe l i o u n r

-- | Apply a function to all the output values of a <tt>Pipe</tt>.
--   
--   This mimics the behavior of <a>fmap</a> for a <tt>Source</tt> and
--   <tt>Conduit</tt> in pre-0.4 days.
--   
--   Since 0.4.1
mapOutput :: Monad m => (o1 -> o2) -> Pipe l i o1 u m r -> Pipe l i o2 u m r

-- | Same as <a>mapOutput</a>, but use a function that returns
--   <tt>Maybe</tt> values.
--   
--   Since 0.5.0
mapOutputMaybe :: Monad m => (o1 -> Maybe o2) -> Pipe l i o1 u m r -> Pipe l i o2 u m r

-- | Apply a function to all the input values of a <tt>Pipe</tt>.
--   
--   Since 0.5.0
mapInput :: Monad m => (i1 -> i2) -> (l2 -> Maybe l1) -> Pipe l2 i2 o u m r -> Pipe l1 i1 o u m r

-- | Convert a list into a source.
--   
--   Since 0.3.0
sourceList :: Monad m => [a] -> Pipe l i a u m ()

-- | Returns a tuple of the upstream and downstream results. Note that this
--   will force consumption of the entire input stream.
--   
--   Since 0.5.0
withUpstream :: Monad m => Pipe l i o u m r -> Pipe l i o u m (u, r)
enumFromTo :: (Enum o, Eq o, Monad m) => o -> o -> Pipe l i o u m ()

-- | Generalize the upstream return value for a <tt>Pipe</tt> from unit to
--   any type.
--   
--   Since 1.1.5
generalizeUpstream :: Monad m => Pipe l i o () m r -> Pipe l i o u m r

-- | Core datatype of the conduit package. This type represents a general
--   component which can consume a stream of input values <tt>i</tt>,
--   produce a stream of output values <tt>o</tt>, perform actions in the
--   <tt>m</tt> monad, and produce a final result <tt>r</tt>. The type
--   synonyms provided here are simply wrappers around this type.
--   
--   Since 1.3.0
newtype ConduitT i o m r
ConduitT :: (forall b. (r -> Pipe i i o () m b) -> Pipe i i o () m b) -> ConduitT i o m r
[unConduitT] :: ConduitT i o m r -> forall b. (r -> Pipe i i o () m b) -> Pipe i i o () m b

-- | Provides a stream of output values, without consuming any input or
--   producing a final result.
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Source m o = ConduitT () o m ()

-- | Consumes a stream of input values and produces a stream of output
--   values, without producing a final result.
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Conduit i m o = ConduitT i o m ()

-- | Consumes a stream of input values and produces a final result, without
--   producing any output.
--   
--   <pre>
--   type Sink i m r = ConduitT i Void m r
--   </pre>
--   
--   Since 0.5.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Sink i = ConduitT i Void

-- | Same as <a>ConduitT</a>, for backwards compat
type ConduitM = ConduitT

-- | A component which produces a stream of output values, regardless of
--   the input stream. A <tt>Producer</tt> is a generalization of a
--   <tt>Source</tt>, and can be used as either a <tt>Source</tt> or a
--   <tt>Conduit</tt>.
--   
--   Since 1.0.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Producer m o = forall i. ConduitT i o m ()

-- | A component which consumes a stream of input values and produces a
--   final result, regardless of the output stream. A <tt>Consumer</tt> is
--   a generalization of a <tt>Sink</tt>, and can be used as either a
--   <tt>Sink</tt> or a <tt>Conduit</tt>.
--   
--   Since 1.0.0

-- | <i>Deprecated: Use ConduitT directly</i>
type Consumer i m r = forall o. ConduitT i o m r

-- | In order to provide for efficient monadic composition, the
--   <tt>ConduitT</tt> type is implemented internally using a technique
--   known as the codensity transform. This allows for cheap appending, but
--   makes one case much more expensive: partially running a
--   <tt>ConduitT</tt> and that capturing the new state.
--   
--   This data type is the same as <tt>ConduitT</tt>, but does not use the
--   codensity transform technique.
newtype SealedConduitT i o m r
SealedConduitT :: Pipe i i o () m r -> SealedConduitT i o m r

-- | Provide for a stream of data that can be flushed.
--   
--   A number of <tt>Conduit</tt>s (e.g., zlib compression) need the
--   ability to flush the stream at some point. This provides a single
--   wrapper datatype to be used in all such circumstances.
--   
--   Since 0.3.0
data Flush a
Chunk :: a -> Flush a
Flush :: Flush a

-- | A wrapper for defining an <a>Applicative</a> instance for
--   <a>Source</a>s which allows to combine sources together, generalizing
--   <a>zipSources</a>. A combined source will take input yielded from each
--   of its <tt>Source</tt>s until any of them stop producing output.
--   
--   Since 1.0.13
newtype ZipSource m o
ZipSource :: ConduitT () o m () -> ZipSource m o
[getZipSource] :: ZipSource m o -> ConduitT () o m ()

-- | A wrapper for defining an <a>Applicative</a> instance for <a>Sink</a>s
--   which allows to combine sinks together, generalizing <a>zipSinks</a>.
--   A combined sink distributes the input to all its participants and when
--   all finish, produces the result. This allows to define functions like
--   
--   <pre>
--   sequenceSinks :: (Monad m)
--             =&gt; [ConduitT i Void m r] -&gt; ConduitT i Void m [r]
--   sequenceSinks = getZipSink . sequenceA . fmap ZipSink
--   </pre>
--   
--   Note that the standard <a>Applicative</a> instance for conduits works
--   differently. It feeds one sink with input until it finishes, then
--   switches to another, etc., and at the end combines their results.
--   
--   This newtype is in fact a type constrained version of
--   <a>ZipConduit</a>, and has the same behavior. It's presented as a
--   separate type since (1) it historically predates <tt>ZipConduit</tt>,
--   and (2) the type constraining can make your code clearer (and thereby
--   make your error messages more easily understood).
--   
--   Since 1.0.13
newtype ZipSink i m r
ZipSink :: ConduitT i Void m r -> ZipSink i m r
[getZipSink] :: ZipSink i m r -> ConduitT i Void m r

-- | Provides an alternative <tt>Applicative</tt> instance for
--   <tt>ConduitT</tt>. In this instance, every incoming value is provided
--   to all <tt>ConduitT</tt>s, and output is coalesced together. Leftovers
--   from individual <tt>ConduitT</tt>s will be used within that component,
--   and then discarded at the end of their computation. Output and
--   finalizers will both be handled in a left-biased manner.
--   
--   As an example, take the following program:
--   
--   <pre>
--   main :: IO ()
--   main = do
--       let src = mapM_ yield [1..3 :: Int]
--           conduit1 = CL.map (+1)
--           conduit2 = CL.concatMap (replicate 2)
--           conduit = getZipConduit $ ZipConduit conduit1 &lt;* ZipConduit conduit2
--           sink = CL.mapM_ print
--       src $$ conduit =$ sink
--   </pre>
--   
--   It will produce the output: 2, 1, 1, 3, 2, 2, 4, 3, 3
--   
--   Since 1.0.17
newtype ZipConduit i o m r
ZipConduit :: ConduitT i o m r -> ZipConduit i o m r
[getZipConduit] :: ZipConduit i o m r -> ConduitT i o m r

-- | The connect operator, which pulls data from a source and pushes to a
--   sink. If you would like to keep the <tt>Source</tt> open to be used
--   for other operations, use the connect-and-resume operator <a>$$+</a>.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use runConduit and .|</i>
($$) :: Monad m => Source m a -> Sink a m b -> m b
infixr 0 $$

-- | Combine two <tt>Conduit</tt>s together into a new <tt>Conduit</tt>
--   (aka <a>fuse</a>).
--   
--   Output from the upstream (left) conduit will be fed into the
--   downstream (right) conduit. Processing will terminate when downstream
--   (right) returns. Leftover data returned from the right
--   <tt>Conduit</tt> will be discarded.
--   
--   Equivalent to <a>fuse</a> and <a>=$=</a>, however the latter is
--   deprecated and will be removed in a future version.
--   
--   Note that, while this operator looks like categorical composition
--   (from <a>Control.Category</a>), there are a few reasons it's
--   different:
--   
--   <ul>
--   <li>The position of the type parameters to <a>ConduitT</a> do not
--   match. We would need to change <tt>ConduitT i o m r</tt> to
--   <tt>ConduitT r m i o</tt>, which would preclude a <a>Monad</a> or
--   <a>MonadTrans</a> instance.</li>
--   <li>The result value from upstream and downstream are allowed to
--   differ between upstream and downstream. In other words, we would need
--   the type signature here to look like <tt>ConduitT a b m r -&gt;
--   ConduitT b c m r -&gt; ConduitT a c m r</tt>.</li>
--   <li>Due to leftovers, we do not have a left identity in Conduit. This
--   can be achieved with the underlying <tt>Pipe</tt> datatype, but this
--   is not generally recommended. See
--   <a>https://stackoverflow.com/a/15263700</a>.</li>
--   </ul>
(.|) :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r
infixr 2 .|

-- | Equivalent to using <a>runConduit</a> and <a>.|</a> together.
--   
--   Since 1.2.3
connect :: Monad m => ConduitT () a m () -> ConduitT a Void m r -> m r

-- | Named function synonym for <a>.|</a>
--   
--   Equivalent to <a>.|</a> and <a>=$=</a>. However, the latter is
--   deprecated and will be removed in a future version.
--   
--   Since 1.2.3
fuse :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
($=) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixl 1 $=

-- | A synonym for <a>=$=</a> for backwards compatibility.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
(=$) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixr 2 =$

-- | Deprecated fusion operator.
--   
--   Since 0.4.0

-- | <i>Deprecated: Use .|</i>
(=$=) :: Monad m => Conduit a m b -> ConduitT b c m r -> ConduitT a c m r
infixr 2 =$=

-- | Fuse two <tt>ConduitT</tt>s together, and provide the return value of
--   both. Note that this will force the entire upstream <tt>ConduitT</tt>
--   to be run to produce the result value, even if the downstream
--   terminates early.
--   
--   Since 1.1.5
fuseBoth :: Monad m => ConduitT a b m r1 -> ConduitT b c m r2 -> ConduitT a c m (r1, r2)

-- | Like <a>fuseBoth</a>, but does not force consumption of the
--   <tt>Producer</tt>. In the case that the <tt>Producer</tt> terminates,
--   the result value is provided as a <tt>Just</tt> value. If it does not
--   terminate, then a <tt>Nothing</tt> value is returned.
--   
--   One thing to note here is that "termination" here only occurs if the
--   <tt>Producer</tt> actually yields a <tt>Nothing</tt> value. For
--   example, with the <tt>Producer</tt> <tt>mapM_ yield [1..5]</tt>, if
--   five values are requested, the <tt>Producer</tt> has not yet
--   terminated. Termination only occurs when the sixth value is awaited
--   for and the <tt>Producer</tt> signals termination.
--   
--   Since 1.2.4
fuseBothMaybe :: Monad m => ConduitT a b m r1 -> ConduitT b c m r2 -> ConduitT a c m (Maybe r1, r2)

-- | Same as <tt>fuseBoth</tt>, but ignore the return value from the
--   downstream <tt>Conduit</tt>. Same caveats of forced consumption apply.
--   
--   Since 1.1.5
fuseUpstream :: Monad m => ConduitT a b m r -> ConduitT b c m () -> ConduitT a c m r

-- | Run a pipeline until processing completes.
--   
--   Since 1.2.1
runConduit :: Monad m => ConduitT () Void m r -> m r

-- | Run a pure pipeline until processing completes, i.e. a pipeline with
--   <tt>Identity</tt> as the base monad. This is equivalient to
--   <tt>runIdentity . runConduit</tt>.
runConduitPure :: ConduitT () Void Identity r -> r

-- | Run a pipeline which acquires resources with <tt>ResourceT</tt>, and
--   then run the <tt>ResourceT</tt> transformer. This is equivalent to
--   <tt>runResourceT . runConduit</tt>.
runConduitRes :: MonadUnliftIO m => ConduitT () Void (ResourceT m) r -> m r

-- | Catch all exceptions thrown by the current component of the pipeline.
--   
--   Note: this will <i>not</i> catch exceptions thrown by other
--   components! For example, if an exception is thrown in a
--   <tt>Source</tt> feeding to a <tt>Sink</tt>, and the <tt>Sink</tt> uses
--   <tt>catchC</tt>, the exception will <i>not</i> be caught.
--   
--   Due to this behavior (as well as lack of async exception safety), you
--   should not try to implement combinators such as <tt>onException</tt>
--   in terms of this primitive function.
--   
--   Note also that the exception handling will <i>not</i> be applied to
--   any finalizers generated by this conduit.
--   
--   Since 1.0.11
catchC :: (MonadUnliftIO m, Exception e) => ConduitT i o m r -> (e -> ConduitT i o m r) -> ConduitT i o m r

-- | The same as <tt>flip catchC</tt>.
--   
--   Since 1.0.11
handleC :: (MonadUnliftIO m, Exception e) => (e -> ConduitT i o m r) -> ConduitT i o m r -> ConduitT i o m r

-- | A version of <tt>try</tt> for use within a pipeline. See the comments
--   in <tt>catchC</tt> for more details.
--   
--   Since 1.0.11
tryC :: (MonadUnliftIO m, Exception e) => ConduitT i o m r -> ConduitT i o m (Either e r)

-- | Generalize a <a>Source</a> to a <a>Producer</a>.
--   
--   Since 1.0.0
toProducer :: Monad m => ConduitT () a m () -> ConduitT i a m ()

-- | Generalize a <a>Sink</a> to a <a>Consumer</a>.
--   
--   Since 1.0.0
toConsumer :: Monad m => ConduitT a Void m b -> ConduitT a o m b

-- | Merge a <tt>Source</tt> into a <tt>Conduit</tt>. The new conduit will
--   stop processing once either source or upstream have been exhausted.
mergeSource :: Monad m => ConduitT () i m () -> ConduitT a (i, a) m ()

-- | Turn a <tt>Sink</tt> into a <tt>Conduit</tt> in the following way:
--   
--   <ul>
--   <li>All input passed to the <tt>Sink</tt> is yielded downstream.</li>
--   <li>When the <tt>Sink</tt> finishes processing, the result is passed
--   to the provided to the finalizer function.</li>
--   </ul>
--   
--   Note that the <tt>Sink</tt> will stop receiving input as soon as the
--   downstream it is connected to shuts down.
--   
--   An example usage would be to write the result of a <tt>Sink</tt> to
--   some mutable variable while allowing other processing to continue.
--   
--   Since 1.1.0
passthroughSink :: Monad m => ConduitT i Void m r -> (r -> m ()) -> ConduitT i i m ()

-- | Convert a <tt>Source</tt> into a list. The basic functionality can be
--   explained as:
--   
--   <pre>
--   sourceToList src = src $$ Data.Conduit.List.consume
--   </pre>
--   
--   However, <tt>sourceToList</tt> is able to produce its results lazily,
--   which cannot be done when running a conduit pipeline in general.
--   Unlike the <tt>Data.Conduit.Lazy</tt> module (in conduit-extra), this
--   function performs no unsafe I/O operations, and therefore can only be
--   as lazy as the underlying monad.
--   
--   Since 1.2.6
sourceToList :: Monad m => ConduitT () a m () -> m [a]
sealConduitT :: ConduitT i o m r -> SealedConduitT i o m r
unsealConduitT :: Monad m => SealedConduitT i o m r -> ConduitT i o m r

-- | The connect-and-resume operator. This does not close the
--   <tt>Source</tt>, but instead returns it to be used again. This allows
--   a <tt>Source</tt> to be used incrementally in a large program, without
--   forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Mnemonic: connect + do more.
--   
--   Since 0.5.0
($$+) :: Monad m => ConduitT () a m () -> ConduitT a Void m b -> m (SealedConduitT () a m (), b)
infixr 0 $$+

-- | Continue processing after usage of <tt>$$+</tt>.
--   
--   Since 0.5.0
($$++) :: Monad m => SealedConduitT () a m () -> ConduitT a Void m b -> m (SealedConduitT () a m (), b)
infixr 0 $$++

-- | Same as <tt>$$++</tt> and <tt>connectResume</tt>, but doesn't include
--   the updated <tt>SealedConduitT</tt>.
--   
--   <i>NOTE</i> In previous versions, this would cause finalizers to run.
--   Since version 1.3.0, there are no finalizers in conduit.
--   
--   Since 0.5.0
($$+-) :: Monad m => SealedConduitT () a m () -> ConduitT a Void m b -> m b
infixr 0 $$+-

-- | Left fusion for a sealed source.
--   
--   Since 1.0.16
($=+) :: Monad m => SealedConduitT () a m () -> ConduitT a b m () -> SealedConduitT () b m ()
infixl 1 $=+

-- | The connect-and-resume operator. This does not close the
--   <tt>Conduit</tt>, but instead returns it to be used again. This allows
--   a <tt>Conduit</tt> to be used incrementally in a large program,
--   without forcing the entire program to live in the <tt>Sink</tt> monad.
--   
--   Leftover data returned from the <tt>Sink</tt> will be discarded.
--   
--   Mnemonic: connect + do more.
--   
--   Since 1.0.17
(=$$+) :: Monad m => ConduitT a b m () -> ConduitT b Void m r -> ConduitT a Void m (SealedConduitT a b m (), r)
infixr 0 =$$+

-- | Continue processing after usage of <a>=$$+</a>. Connect a
--   <a>SealedConduitT</a> to a sink and return the output of the sink
--   together with a new <a>SealedConduitT</a>.
--   
--   Since 1.0.17
(=$$++) :: Monad m => SealedConduitT i o m () -> ConduitT o Void m r -> ConduitT i Void m (SealedConduitT i o m (), r)
infixr 0 =$$++

-- | Same as <tt>=$$++</tt>, but doesn't include the updated
--   <tt>SealedConduitT</tt>.
--   
--   <i>NOTE</i> In previous versions, this would cause finalizers to run.
--   Since version 1.3.0, there are no finalizers in conduit.
--   
--   Since 1.0.17
(=$$+-) :: Monad m => SealedConduitT i o m () -> ConduitT o Void m r -> ConduitT i Void m r
infixr 0 =$$+-

-- | Similar to <tt>fuseReturnLeftovers</tt>, but use the provided function
--   to convert downstream leftovers to upstream leftovers.
--   
--   Since 1.0.17
fuseLeftovers :: Monad m => ([b] -> [a]) -> ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m r

-- | Same as normal fusion (e.g. <tt>=$=</tt>), except instead of
--   discarding leftovers from the downstream component, return them.
--   
--   Since 1.0.17
fuseReturnLeftovers :: Monad m => ConduitT a b m () -> ConduitT b c m r -> ConduitT a c m (r, [b])

-- | Coalesce all values yielded by all of the <tt>Source</tt>s.
--   
--   Implemented on top of <tt>ZipSource</tt> and as such, it exhibits the
--   same short-circuiting behavior as <tt>ZipSource</tt>. See that data
--   type for more details. If you want to create a source that yields
--   *all* values from multiple sources, use <a>sequence_</a>.
--   
--   Since 1.0.13
sequenceSources :: (Traversable f, Monad m) => f (ConduitT () o m ()) -> ConduitT () (f o) m ()

-- | Send incoming values to all of the <tt>Sink</tt> providing, and
--   ultimately coalesce together all return values.
--   
--   Implemented on top of <tt>ZipSink</tt>, see that data type for more
--   details.
--   
--   Since 1.0.13
sequenceSinks :: (Traversable f, Monad m) => f (ConduitT i Void m r) -> ConduitT i Void m (f r)

-- | Provide identical input to all of the <tt>Conduit</tt>s and combine
--   their outputs into a single stream.
--   
--   Implemented on top of <tt>ZipConduit</tt>, see that data type for more
--   details.
--   
--   Since 1.0.17
sequenceConduits :: (Traversable f, Monad m) => f (ConduitT i o m r) -> ConduitT i o m (f r)

-- | Connect a <tt>Source</tt> to a <tt>Sink</tt> until the latter closes.
--   Returns both the most recent state of the <tt>Source</tt> and the
--   result of the <tt>Sink</tt>.
--   
--   Since 0.5.0
connectResume :: Monad m => SealedConduitT () a m () -> ConduitT a Void m r -> m (SealedConduitT () a m (), r)

-- | Connect a <a>Conduit</a> to a sink and return the output of the sink
--   together with a new <a>Conduit</a>.
--   
--   Since 1.0.17
connectResumeConduit :: Monad m => SealedConduitT i o m () -> ConduitT o Void m r -> ConduitT i Void m (SealedConduitT i o m (), r)
sourceToPipe :: Monad m => ConduitT () o m () -> Pipe l i o u m ()
sinkToPipe :: Monad m => ConduitT i Void m r -> Pipe l i o u m r
conduitToPipe :: Monad m => ConduitT i o m () -> Pipe l i o u m ()

-- | Combines two sinks. The new sink will complete when both input sinks
--   have completed.
--   
--   Any leftovers are discarded.
--   
--   Since 0.4.1
zipSinks :: Monad m => ConduitT i Void m r -> ConduitT i Void m r' -> ConduitT i Void m (r, r')

-- | Combines two sources. The new source will stop producing once either
--   source has been exhausted.
--   
--   Since 1.0.13
zipSources :: Monad m => ConduitT () a m () -> ConduitT () b m () -> ConduitT () (a, b) m ()

-- | Combines two sources. The new source will stop producing once either
--   source has been exhausted.
--   
--   Since 1.0.13
zipSourcesApp :: Monad m => ConduitT () (a -> b) m () -> ConduitT () a m () -> ConduitT () b m ()

-- | Since 1.0.17
zipConduitApp :: Monad m => ConduitT i o m (x -> y) -> ConduitT i o m x -> ConduitT i o m y


-- | Allow monad transformers to be run/eval/exec in a section of conduit
--   rather then needing to run across the whole conduit. The circumvents
--   many of the problems with breaking the monad transformer laws. For
--   more information, see the announcement blog post:
--   <a>http://www.yesodweb.com/blog/2014/01/conduit-transformer-exception</a>
--   
--   This module was added in conduit 1.0.11.
module Data.Conduit.Lift

-- | Wrap the base monad in <a>ExceptT</a>
--   
--   Since 1.2.12
exceptC :: Monad m => ConduitT i o m (Either e a) -> ConduitT i o (ExceptT e m) a

-- | Run <a>ExceptT</a> in the base monad
--   
--   Since 1.2.12
runExceptC :: Monad m => ConduitT i o (ExceptT e m) r -> ConduitT i o m (Either e r)

-- | Catch an error in the base monad
--   
--   Since 1.2.12
catchExceptC :: Monad m => ConduitT i o (ExceptT e m) r -> (e -> ConduitT i o (ExceptT e m) r) -> ConduitT i o (ExceptT e m) r

-- | Run <a>CatchT</a> in the base monad
--   
--   Since 1.1.0
runCatchC :: Monad m => ConduitT i o (CatchT m) r -> ConduitT i o m (Either SomeException r)

-- | Catch an exception in the base monad
--   
--   Since 1.1.0
catchCatchC :: Monad m => ConduitT i o (CatchT m) r -> (SomeException -> ConduitT i o (CatchT m) r) -> ConduitT i o (CatchT m) r

-- | Wrap the base monad in <a>MaybeT</a>
--   
--   Since 1.0.11
maybeC :: Monad m => ConduitT i o m (Maybe a) -> ConduitT i o (MaybeT m) a

-- | Run <a>MaybeT</a> in the base monad
--   
--   Since 1.0.11
runMaybeC :: Monad m => ConduitT i o (MaybeT m) r -> ConduitT i o m (Maybe r)

-- | Wrap the base monad in <a>ReaderT</a>
--   
--   Since 1.0.11
readerC :: Monad m => (r -> ConduitT i o m a) -> ConduitT i o (ReaderT r m) a

-- | Run <a>ReaderT</a> in the base monad
--   
--   Since 1.0.11
runReaderC :: Monad m => r -> ConduitT i o (ReaderT r m) res -> ConduitT i o m res

-- | Wrap the base monad in <a>StateT</a>
--   
--   Since 1.0.11
stateLC :: Monad m => (s -> ConduitT i o m (a, s)) -> ConduitT i o (StateT s m) a

-- | Run <a>StateT</a> in the base monad
--   
--   Since 1.0.11
runStateLC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m (r, s)

-- | Evaluate <a>StateT</a> in the base monad
--   
--   Since 1.0.11
evalStateLC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m r

-- | Execute <a>StateT</a> in the base monad
--   
--   Since 1.0.11
execStateLC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m s

-- | Wrap the base monad in <a>StateT</a>
--   
--   Since 1.0.11
stateC :: Monad m => (s -> ConduitT i o m (a, s)) -> ConduitT i o (StateT s m) a

-- | Run <a>StateT</a> in the base monad
--   
--   Since 1.0.11
runStateC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m (r, s)

-- | Evaluate <a>StateT</a> in the base monad
--   
--   Since 1.0.11
evalStateC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m r

-- | Execute <a>StateT</a> in the base monad
--   
--   Since 1.0.11
execStateC :: Monad m => s -> ConduitT i o (StateT s m) r -> ConduitT i o m s

-- | Wrap the base monad in <a>WriterT</a>
--   
--   Since 1.0.11
writerLC :: (Monad m, Monoid w) => ConduitT i o m (b, w) -> ConduitT i o (WriterT w m) b

-- | Run <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
runWriterLC :: (Monad m, Monoid w) => ConduitT i o (WriterT w m) r -> ConduitT i o m (r, w)

-- | Execute <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
execWriterLC :: (Monad m, Monoid w) => ConduitT i o (WriterT w m) r -> ConduitT i o m w

-- | Wrap the base monad in <a>WriterT</a>
--   
--   Since 1.0.11
writerC :: (Monad m, Monoid w) => ConduitT i o m (b, w) -> ConduitT i o (WriterT w m) b

-- | Run <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
runWriterC :: (Monad m, Monoid w) => ConduitT i o (WriterT w m) r -> ConduitT i o m (r, w)

-- | Execute <a>WriterT</a> in the base monad
--   
--   Since 1.0.11
execWriterC :: (Monad m, Monoid w) => ConduitT i o (WriterT w m) r -> ConduitT i o m w

-- | Wrap the base monad in <a>RWST</a>
--   
--   Since 1.0.11
rwsLC :: (Monad m, Monoid w) => (r -> s -> ConduitT i o m (a, s, w)) -> ConduitT i o (RWST r w s m) a

-- | Run <a>RWST</a> in the base monad
--   
--   Since 1.0.11
runRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (res, s, w)

-- | Evaluate <a>RWST</a> in the base monad
--   
--   Since 1.0.11
evalRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (res, w)

-- | Execute <a>RWST</a> in the base monad
--   
--   Since 1.0.11
execRWSLC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (s, w)

-- | Wrap the base monad in <a>RWST</a>
--   
--   Since 1.0.11
rwsC :: (Monad m, Monoid w) => (r -> s -> ConduitT i o m (a, s, w)) -> ConduitT i o (RWST r w s m) a

-- | Run <a>RWST</a> in the base monad
--   
--   Since 1.0.11
runRWSC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (res, s, w)

-- | Evaluate <a>RWST</a> in the base monad
--   
--   Since 1.0.11
evalRWSC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (res, w)

-- | Execute <a>RWST</a> in the base monad
--   
--   Since 1.0.11
execRWSC :: (Monad m, Monoid w) => r -> s -> ConduitT i o (RWST r w s m) res -> ConduitT i o m (s, w)


-- | <i>NOTE</i> It is recommended to start using
--   <a>Data.Conduit.Combinators</a> instead of this module.
--   
--   Higher-level functions to interact with the elements of a stream. Most
--   of these are based on list functions.
--   
--   Note that these functions all deal with individual elements of a
--   stream as a sort of "black box", where there is no introspection of
--   the contained elements. Values such as <tt>ByteString</tt> and
--   <tt>Text</tt> will likely need to be treated specially to deal with
--   their contents properly (<tt>Word8</tt> and <tt>Char</tt>,
--   respectively). See the <tt>Data.Conduit.Binary</tt> and
--   <tt>Data.Conduit.Text</tt> modules in the <tt>conduit-extra</tt>
--   package.
module Data.Conduit.List

-- | Yield the values from the list.
--   
--   Subject to fusion
sourceList :: Monad m => [a] -> ConduitT i a m ()

-- | A source that outputs no values. Note that this is just a
--   type-restricted synonym for <a>mempty</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
sourceNull :: Monad m => ConduitT i o m ()

-- | Generate a source from a seed value.
--   
--   Subject to fusion
--   
--   Since 0.4.2
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> ConduitT i a m ()

-- | Generate a source from a seed value with a return value.
--   
--   Subject to fusion
unfoldEither :: Monad m => (b -> Either r (a, b)) -> b -> ConduitT i a m r

-- | A monadic unfold.
--   
--   Subject to fusion
--   
--   Since 1.1.2
unfoldM :: Monad m => (b -> m (Maybe (a, b))) -> b -> ConduitT i a m ()

-- | A monadic unfoldEither.
--   
--   Subject to fusion
unfoldEitherM :: Monad m => (b -> m (Either r (a, b))) -> b -> ConduitT i a m r

-- | Enumerate from a value to a final value, inclusive, via <tt>succ</tt>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
--   
--   Subject to fusion
--   
--   Since 0.4.2
enumFromTo :: (Enum a, Ord a, Monad m) => a -> a -> ConduitT i a m ()

-- | Produces an infinite stream of repeated applications of f to x.
--   
--   Subject to fusion
iterate :: Monad m => (a -> a) -> a -> ConduitT i a m ()

-- | Replicate a single value the given number of times.
--   
--   Subject to fusion
--   
--   Since 1.2.0
replicate :: Monad m => Int -> a -> ConduitT i a m ()

-- | Replicate a monadic value the given number of times.
--   
--   Subject to fusion
--   
--   Since 1.2.0
replicateM :: Monad m => Int -> m a -> ConduitT i a m ()

-- | A strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.3.0
fold :: Monad m => (b -> a -> b) -> b -> ConduitT a o m b

-- | A monoidal strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.5.3
foldMap :: (Monad m, Monoid b) => (a -> b) -> ConduitT a o m b

-- | Split a pure conduit into head and tail. This is equivalent to
--   <tt>runIdentity . unconsM</tt>.
--   
--   Note that you have to <a>sealConduitT</a> it first.
--   
--   Since 1.3.3
uncons :: SealedConduitT () o Identity () -> Maybe (o, SealedConduitT () o Identity ())

-- | Split a pure conduit into head and tail or return its result if it is
--   done. This is equivalent to <tt>runIdentity . unconsEitherM</tt>.
--   
--   Note that you have to <a>sealConduitT</a> it first.
--   
--   Since 1.3.3
unconsEither :: SealedConduitT () o Identity r -> Either r (o, SealedConduitT () o Identity r)

-- | Take some values from the stream and return as a list. If you want to
--   instead create a conduit that pipes data to another sink, see
--   <a>isolate</a>. This function is semantically equivalent to:
--   
--   <pre>
--   take i = isolate i =$ consume
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.3.0
take :: Monad m => Int -> ConduitT a o m [a]

-- | Ignore a certain number of values in the stream. This function is
--   semantically equivalent to:
--   
--   <pre>
--   drop i = take i &gt;&gt; return ()
--   </pre>
--   
--   However, <tt>drop</tt> is more efficient as it does not need to hold
--   values in memory.
--   
--   Subject to fusion
--   
--   Since 0.3.0
drop :: Monad m => Int -> ConduitT a o m ()

-- | Take a single value from the stream, if available.
--   
--   Subject to fusion
--   
--   Since 0.3.0
head :: Monad m => ConduitT a o m (Maybe a)

-- | Look at the next value in the stream, if available. This function will
--   not change the state of the stream.
--   
--   Since 0.3.0
peek :: Monad m => ConduitT a o m (Maybe a)

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory.
--   
--   Subject to fusion
--   
--   Since 0.3.0
consume :: Monad m => ConduitT a o m [a]

-- | Ignore the remainder of values in the source. Particularly useful when
--   combined with <a>isolate</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
sinkNull :: Monad m => ConduitT i o m ()

-- | A monoidal strict left fold in a Monad.
--   
--   Since 1.0.8
foldMapM :: (Monad m, Monoid b) => (a -> m b) -> ConduitT a o m b

-- | A monadic strict left fold.
--   
--   Subject to fusion
--   
--   Since 0.3.0
foldM :: Monad m => (b -> a -> m b) -> b -> ConduitT a o m b

-- | Split a conduit into head and tail.
--   
--   Note that you have to <a>sealConduitT</a> it first.
--   
--   Since 1.3.3
unconsM :: Monad m => SealedConduitT () o m () -> m (Maybe (o, SealedConduitT () o m ()))

-- | Split a conduit into head and tail or return its result if it is done.
--   
--   Note that you have to <a>sealConduitT</a> it first.
--   
--   Since 1.3.3
unconsEitherM :: Monad m => SealedConduitT () o m r -> m (Either r (o, SealedConduitT () o m r))

-- | Apply the action to all values in the stream.
--   
--   Subject to fusion
--   
--   Since 0.3.0
mapM_ :: Monad m => (a -> m ()) -> ConduitT a o m ()

-- | Apply a transformation to all values in a stream.
--   
--   Subject to fusion
--   
--   Since 0.3.0
map :: Monad m => (a -> b) -> ConduitT a b m ()

-- | Apply a transformation that may fail to all values in a stream,
--   discarding the failures.
--   
--   Subject to fusion
--   
--   Since 0.5.1
mapMaybe :: Monad m => (a -> Maybe b) -> ConduitT a b m ()

-- | Generalization of <a>mapMaybe</a> and <a>concatMap</a>. It applies
--   function to all values in a stream and send values inside resulting
--   <tt>Foldable</tt> downstream.
--   
--   Subject to fusion
--   
--   Since 1.0.6
mapFoldable :: (Monad m, Foldable f) => (a -> f b) -> ConduitT a b m ()

-- | Filter the <tt>Just</tt> values from a stream, discarding the
--   <tt>Nothing</tt> values.
--   
--   Subject to fusion
--   
--   Since 0.5.1
catMaybes :: Monad m => ConduitT (Maybe a) a m ()

-- | Generalization of <a>catMaybes</a>. It puts all values from
--   <a>Foldable</a> into stream.
--   
--   Subject to fusion
--   
--   Since 1.0.6
concat :: (Monad m, Foldable f) => ConduitT (f a) a m ()

-- | Apply a transformation to all values in a stream, concatenating the
--   output values.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMap :: Monad m => (a -> [b]) -> ConduitT a b m ()

-- | <a>concatMap</a> with a strict accumulator.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapAccum :: Monad m => (a -> accum -> (accum, [b])) -> accum -> ConduitT a b m ()

-- | Deprecated synonym for <tt>mapAccum</tt>
--   
--   Since 1.0.6

-- | <i>Deprecated: Use mapAccum instead</i>
scanl :: Monad m => (a -> s -> (s, b)) -> s -> ConduitT a b m ()

-- | Analog of <a>scanl</a> for lists.
--   
--   Subject to fusion
--   
--   Since 1.1.1
scan :: Monad m => (a -> b -> b) -> b -> ConduitT a b m b

-- | Analog of <tt>mapAccumL</tt> for lists. Note that in contrast to
--   <tt>mapAccumL</tt>, the function argument takes the accumulator as its
--   second argument, not its first argument, and the accumulated value is
--   strict.
--   
--   Subject to fusion
--   
--   Since 1.1.1
mapAccum :: Monad m => (a -> s -> (s, b)) -> s -> ConduitT a b m s

-- | Group a stream into chunks of a given size. The last chunk may contain
--   fewer than n elements.
--   
--   Subject to fusion
--   
--   Since 1.2.9
chunksOf :: Monad m => Int -> ConduitT a [a] m ()

-- | Grouping input according to an equality function.
--   
--   Subject to fusion
--   
--   Since 0.3.0
groupBy :: Monad m => (a -> a -> Bool) -> ConduitT a [a] m ()

-- | <a>groupOn1</a> is similar to <tt>groupBy id</tt>
--   
--   returns a pair, indicating there are always 1 or more items in the
--   grouping. This is designed to be converted into a NonEmpty structure
--   but it avoids a dependency on another package
--   
--   <pre>
--   import Data.List.NonEmpty
--   
--   groupOn1 :: (Monad m, Eq b) =&gt; (a -&gt; b) -&gt; Conduit a m (NonEmpty a)
--   groupOn1 f = CL.groupOn1 f .| CL.map (uncurry (:|))
--   </pre>
--   
--   Subject to fusion
--   
--   Since 1.1.7
groupOn1 :: (Monad m, Eq b) => (a -> b) -> ConduitT a (a, [a]) m ()

-- | Like <a>groupOn1</a>, but returning a <a>NonEmpty</a> structure.
groupOn :: (Monad m, Eq b) => (a -> b) -> ConduitT a (NonEmpty a) m ()

-- | Ensure that the inner sink consumes no more than the given number of
--   values. Note this this does <i>not</i> ensure that the sink consumes
--   all of those values. To get the latter behavior, combine with
--   <a>sinkNull</a>, e.g.:
--   
--   <pre>
--   src $$ do
--       x &lt;- isolate count =$ do
--           x &lt;- someSink
--           sinkNull
--           return x
--       someOtherSink
--       ...
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.3.0
isolate :: Monad m => Int -> ConduitT a a m ()

-- | Keep only values in the stream passing a given predicate.
--   
--   Subject to fusion
--   
--   Since 0.3.0
filter :: Monad m => (a -> Bool) -> ConduitT a a m ()

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <a>mapM_</a>.
--   
--   Subject to fusion
--   
--   Since 0.3.0
mapM :: Monad m => (a -> m b) -> ConduitT a b m ()

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
--   
--   Subject to fusion
--   
--   Since 0.5.6
iterM :: Monad m => (a -> m ()) -> ConduitT a a m ()

-- | Deprecated synonym for <tt>mapAccumM</tt>
--   
--   Since 1.0.6

-- | <i>Deprecated: Use mapAccumM instead</i>
scanlM :: Monad m => (a -> s -> m (s, b)) -> s -> ConduitT a b m ()

-- | Monadic <tt>scanl</tt>.
--   
--   Subject to fusion
--   
--   Since 1.1.1
scanM :: Monad m => (a -> b -> m b) -> b -> ConduitT a b m b

-- | Monadic <a>mapAccum</a>.
--   
--   Subject to fusion
--   
--   Since 1.1.1
mapAccumM :: Monad m => (a -> s -> m (s, b)) -> s -> ConduitT a b m s

-- | Apply a monadic transformation that may fail to all values in a
--   stream, discarding the failures.
--   
--   Subject to fusion
--   
--   Since 0.5.1
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> ConduitT a b m ()

-- | Monadic variant of <a>mapFoldable</a>.
--   
--   Subject to fusion
--   
--   Since 1.0.6
mapFoldableM :: (Monad m, Foldable f) => (a -> m (f b)) -> ConduitT a b m ()

-- | Apply a monadic transformation to all values in a stream,
--   concatenating the output values.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapM :: Monad m => (a -> m [b]) -> ConduitT a b m ()

-- | <a>concatMapM</a> with a strict accumulator.
--   
--   Subject to fusion
--   
--   Since 0.3.0
concatMapAccumM :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> ConduitT a b m ()

-- | Run a <tt>Pipe</tt> repeatedly, and output its result value
--   downstream. Stops when no more input is available from upstream.
--   
--   Since 0.5.0
sequence :: Monad m => ConduitT i o m o -> ConduitT i o m ()


-- | This module is meant as a replacement for Data.Conduit.List. That
--   module follows a naming scheme which was originally inspired by its
--   enumerator roots. This module is meant to introduce a naming scheme
--   which encourages conduit best practices.
--   
--   There are two versions of functions in this module. Those with a
--   trailing E work in the individual elements of a chunk of data, e.g.,
--   the bytes of a ByteString, the Chars of a Text, or the Ints of a
--   Vector Int. Those without a trailing E work on unchunked streams.
--   
--   FIXME: discuss overall naming, usage of mono-traversable, etc
--   
--   Mention take (Conduit) vs drop (Consumer)
module Data.Conduit.Combinators

-- | Yield each of the values contained by the given <tt>MonoFoldable</tt>.
--   
--   This will work on many data structures, including lists,
--   <tt>ByteString</tt>s, and <tt>Vector</tt>s.
--   
--   Subject to fusion
yieldMany :: (Monad m, MonoFoldable mono) => mono -> ConduitT i (Element mono) m ()

-- | Generate a producer from a seed value.
--   
--   Subject to fusion
unfold :: Monad m => (b -> Maybe (a, b)) -> b -> ConduitT i a m ()

-- | Enumerate from a value to a final value, inclusive, via <a>succ</a>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
--   
--   Subject to fusion
enumFromTo :: (Monad m, Enum a, Ord a) => a -> a -> ConduitT i a m ()

-- | Produces an infinite stream of repeated applications of f to x.
--   
--   Subject to fusion
iterate :: Monad m => (a -> a) -> a -> ConduitT i a m ()

-- | Produce an infinite stream consisting entirely of the given value.
--   
--   Subject to fusion
repeat :: Monad m => a -> ConduitT i a m ()

-- | Produce a finite stream consisting of n copies of the given value.
--   
--   Subject to fusion
replicate :: Monad m => Int -> a -> ConduitT i a m ()

-- | Generate a producer by yielding each of the strict chunks in a
--   <tt>LazySequence</tt>.
--   
--   For more information, see <a>toChunks</a>.
--   
--   Subject to fusion
sourceLazy :: (Monad m, LazySequence lazy strict) => lazy -> ConduitT i strict m ()

-- | Repeatedly run the given action and yield all values it produces.
--   
--   Subject to fusion
repeatM :: Monad m => m a -> ConduitT i a m ()

-- | Repeatedly run the given action and yield all values it produces,
--   until the provided predicate returns <tt>False</tt>.
--   
--   Subject to fusion
repeatWhileM :: Monad m => m a -> (a -> Bool) -> ConduitT i a m ()

-- | Perform the given action n times, yielding each result.
--   
--   Subject to fusion
replicateM :: Monad m => Int -> m a -> ConduitT i a m ()

-- | Stream the contents of a file as binary data.
sourceFile :: MonadResource m => FilePath -> ConduitT i ByteString m ()

-- | Same as <a>sourceFile</a>. The alternate name is a holdover from an
--   older version, when <a>sourceFile</a> was more polymorphic than it is
--   today.
sourceFileBS :: MonadResource m => FilePath -> ConduitT i ByteString m ()

-- | Stream the contents of a <a>Handle</a> as binary data. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes, since it did not acquire the <tt>Handle</tt> in
--   the first place.
sourceHandle :: MonadIO m => Handle -> ConduitT i ByteString m ()

-- | Same as <tt>sourceHandle</tt>, but instead of allocating a new buffer
--   for each incoming chunk of data, reuses the same buffer. Therefore,
--   the <tt>ByteString</tt>s yielded by this function are not
--   referentially transparent between two different <tt>yield</tt>s.
--   
--   This function will be slightly more efficient than
--   <tt>sourceHandle</tt> by avoiding allocations and reducing garbage
--   collections, but should only be used if you can guarantee that you do
--   not reuse a <tt>ByteString</tt> (or any slice thereof) between two
--   calls to <tt>await</tt>.
sourceHandleUnsafe :: MonadIO m => Handle -> ConduitT i ByteString m ()

-- | An alternative to <a>sourceHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in read
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sourceIOHandle :: MonadResource m => IO Handle -> ConduitT i ByteString m ()

-- | <tt>sourceHandle</tt> applied to <tt>stdin</tt>.
--   
--   Subject to fusion
stdin :: MonadIO m => ConduitT i ByteString m ()

-- | Like <a>withBinaryFile</a>, but provides a source to read bytes from.
withSourceFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM i ByteString n () -> m a) -> m a

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
sourceDirectory :: MonadResource m => FilePath -> ConduitT i FilePath m ()

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> ConduitT i FilePath m ()

-- | Ignore a certain number of values in the stream.
--   
--   Note: since this function doesn't produce anything, you probably want
--   to use it with (<a>&gt;&gt;</a>) instead of directly plugging it into
--   a pipeline:
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| drop 2 .| sinkList
--   []
--   
--   &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| (drop 2 &gt;&gt; sinkList)
--   [3,4,5]
--   </pre>
drop :: Monad m => Int -> ConduitT a o m ()

-- | Drop a certain number of elements from a chunked stream.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>drop</a>.
dropE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq o m ()

-- | Drop all values which match the given predicate.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>drop</a>.
dropWhile :: Monad m => (a -> Bool) -> ConduitT a o m ()

-- | Drop all elements in the chunked stream which match the given
--   predicate.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>drop</a>.
dropWhileE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq o m ()

-- | Monoidally combine all values in the stream.
--   
--   Subject to fusion
fold :: (Monad m, Monoid a) => ConduitT a o m a

-- | Monoidally combine all elements in the chunked stream.
--   
--   Subject to fusion
foldE :: (Monad m, MonoFoldable mono, Monoid (Element mono)) => ConduitT mono o m (Element mono)

-- | A strict left fold.
--   
--   Subject to fusion
foldl :: Monad m => (a -> b -> a) -> a -> ConduitT b o m a

-- | A strict left fold with no starting value. Returns <a>Nothing</a> when
--   the stream is empty.
--   
--   Subject to fusion
foldl1 :: Monad m => (a -> a -> a) -> ConduitT a o m (Maybe a)

-- | A strict left fold on a chunked stream.
--   
--   Subject to fusion
foldlE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> a) -> a -> ConduitT mono o m a

-- | Apply the provided mapping function and monoidal combine all values.
--   
--   Subject to fusion
foldMap :: (Monad m, Monoid b) => (a -> b) -> ConduitT a o m b

-- | Apply the provided mapping function and monoidal combine all elements
--   of the chunked stream.
--   
--   Subject to fusion
foldMapE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> ConduitT mono o m w

-- | Specialized version of <a>mapAccumWhile</a> that does not provide
--   values downstream.
foldWhile :: Monad m => (a -> s -> Either e s) -> s -> ConduitT a o m (Either e s)

-- | Check that all values in the stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Subject to fusion
all :: Monad m => (a -> Bool) -> ConduitT a o m Bool

-- | Check that all elements in the chunked stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
--   
--   Subject to fusion
allE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m Bool

-- | Check that at least one value in the stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Subject to fusion
any :: Monad m => (a -> Bool) -> ConduitT a o m Bool

-- | Check that at least one element in the chunked stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
--   
--   Subject to fusion
anyE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m Bool

-- | Are all values in the stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Subject to fusion
and :: Monad m => ConduitT Bool o m Bool

-- | Are all elements in the chunked stream True?
--   
--   Consumption stops once the first False is encountered.
--   
--   Subject to fusion
andE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => ConduitT mono o m Bool

-- | Are any values in the stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Subject to fusion
or :: Monad m => ConduitT Bool o m Bool

-- | Are any elements in the chunked stream True?
--   
--   Consumption stops once the first True is encountered.
--   
--   Subject to fusion
orE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => ConduitT mono o m Bool

-- | <a>Alternative</a>ly combine all values in the stream.
asum :: (Monad m, Alternative f) => ConduitT (f a) o m (f a)

-- | Are any values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
elem :: (Monad m, Eq a) => a -> ConduitT a o m Bool

-- | Are any elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
elemE :: (Monad m, IsSequence seq, Eq (Element seq)) => Element seq -> ConduitT seq o m Bool

-- | Are no values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
notElem :: (Monad m, Eq a) => a -> ConduitT a o m Bool

-- | Are no elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
--   
--   Subject to fusion
notElemE :: (Monad m, IsSequence seq, Eq (Element seq)) => Element seq -> ConduitT seq o m Bool

-- | Consume all incoming strict chunks into a lazy sequence. Note that the
--   entirety of the sequence will be resident at memory.
--   
--   This can be used to consume a stream of strict ByteStrings into a lazy
--   ByteString, for example.
--   
--   Subject to fusion
sinkLazy :: (Monad m, LazySequence lazy strict) => ConduitT strict o m lazy

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory.
--   
--   Subject to fusion
sinkList :: Monad m => ConduitT a o m [a]

-- | Sink incoming values into a vector, growing the vector as necessary to
--   fit more elements.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
sinkVector :: (Vector v a, PrimMonad m) => ConduitT a o m (v a)

-- | Sink incoming values into a vector, up until size <tt>maxSize</tt>.
--   Subsequent values will be left in the stream. If there are less than
--   <tt>maxSize</tt> values present, returns a <tt>Vector</tt> of smaller
--   size.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
sinkVectorN :: (Vector v a, PrimMonad m) => Int -> ConduitT a o m (v a)

-- | Same as <tt>sinkBuilder</tt>, but afterwards convert the builder to
--   its lazy representation.
--   
--   Alternatively, this could be considered an alternative to
--   <tt>sinkLazy</tt>, with the following differences:
--   
--   <ul>
--   <li>This function will allow multiple input types, not just the strict
--   version of the lazy structure.</li>
--   <li>Some buffer copying may occur in this version.</li>
--   </ul>
--   
--   Subject to fusion
sinkLazyBuilder :: Monad m => ConduitT Builder o m ByteString

-- | Consume and discard all remaining values in the stream.
--   
--   Subject to fusion
sinkNull :: Monad m => ConduitT a o m ()

-- | Same as <tt>await</tt>, but discards any leading <a>onull</a> values.
awaitNonNull :: (Monad m, MonoFoldable a) => ConduitT a o m (Maybe (NonNull a))

-- | Take a single value from the stream, if available.
head :: Monad m => ConduitT a o m (Maybe a)

-- | Same as <a>head</a>, but returns a default value if none are available
--   from the stream.
headDef :: Monad m => a -> ConduitT a o m a

-- | Get the next element in the chunked stream.
headE :: (Monad m, IsSequence seq) => ConduitT seq o m (Maybe (Element seq))

-- | View the next value in the stream without consuming it.
peek :: Monad m => ConduitT a o m (Maybe a)

-- | View the next element in the chunked stream without consuming it.
peekE :: (Monad m, MonoFoldable mono) => ConduitT mono o m (Maybe (Element mono))

-- | Retrieve the last value in the stream, if present.
--   
--   Subject to fusion
last :: Monad m => ConduitT a o m (Maybe a)

-- | Same as <a>last</a>, but returns a default value if none are available
--   from the stream.
lastDef :: Monad m => a -> ConduitT a o m a

-- | Retrieve the last element in the chunked stream, if present.
--   
--   Subject to fusion
lastE :: (Monad m, IsSequence seq) => ConduitT seq o m (Maybe (Element seq))

-- | Count how many values are in the stream.
--   
--   Subject to fusion
length :: (Monad m, Num len) => ConduitT a o m len

-- | Count how many elements are in the chunked stream.
--   
--   Subject to fusion
lengthE :: (Monad m, Num len, MonoFoldable mono) => ConduitT mono o m len

-- | Count how many values in the stream pass the given predicate.
--   
--   Subject to fusion
lengthIf :: (Monad m, Num len) => (a -> Bool) -> ConduitT a o m len

-- | Count how many elements in the chunked stream pass the given
--   predicate.
--   
--   Subject to fusion
lengthIfE :: (Monad m, Num len, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m len

-- | Get the largest value in the stream, if present.
--   
--   Subject to fusion
maximum :: (Monad m, Ord a) => ConduitT a o m (Maybe a)

-- | Get the largest element in the chunked stream, if present.
--   
--   Subject to fusion
maximumE :: (Monad m, IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))

-- | Get the smallest value in the stream, if present.
--   
--   Subject to fusion
minimum :: (Monad m, Ord a) => ConduitT a o m (Maybe a)

-- | Get the smallest element in the chunked stream, if present.
--   
--   Subject to fusion
minimumE :: (Monad m, IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))

-- | True if there are no values in the stream.
--   
--   This function does not modify the stream.
null :: Monad m => ConduitT a o m Bool

-- | True if there are no elements in the chunked stream.
--   
--   This function may remove empty leading chunks from the stream, but
--   otherwise will not modify it.
nullE :: (Monad m, MonoFoldable mono) => ConduitT mono o m Bool

-- | Get the sum of all values in the stream.
--   
--   Subject to fusion
sum :: (Monad m, Num a) => ConduitT a o m a

-- | Get the sum of all elements in the chunked stream.
--   
--   Subject to fusion
sumE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)

-- | Get the product of all values in the stream.
--   
--   Subject to fusion
product :: (Monad m, Num a) => ConduitT a o m a

-- | Get the product of all elements in the chunked stream.
--   
--   Subject to fusion
productE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)

-- | Find the first matching value.
--   
--   Subject to fusion
find :: Monad m => (a -> Bool) -> ConduitT a o m (Maybe a)

-- | Apply the action to all values in the stream.
--   
--   Note: if you want to <i>pass</i> the values instead of
--   <i>consuming</i> them, use <a>iterM</a> instead.
--   
--   Subject to fusion
mapM_ :: Monad m => (a -> m ()) -> ConduitT a o m ()

-- | Apply the action to all elements in the chunked stream.
--   
--   Note: the same caveat as with <a>mapM_</a> applies. If you don't want
--   to consume the values, you can use <a>iterM</a>:
--   
--   <pre>
--   iterM (omapM_ f)
--   </pre>
--   
--   Subject to fusion
mapM_E :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> ConduitT mono o m ()

-- | A monadic strict left fold.
--   
--   Subject to fusion
foldM :: Monad m => (a -> b -> m a) -> a -> ConduitT b o m a

-- | A monadic strict left fold on a chunked stream.
--   
--   Subject to fusion
foldME :: (Monad m, MonoFoldable mono) => (a -> Element mono -> m a) -> a -> ConduitT mono o m a

-- | Apply the provided monadic mapping function and monoidal combine all
--   values.
--   
--   Subject to fusion
foldMapM :: (Monad m, Monoid w) => (a -> m w) -> ConduitT a o m w

-- | Apply the provided monadic mapping function and monoidal combine all
--   elements in the chunked stream.
--   
--   Subject to fusion
foldMapME :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> m w) -> ConduitT mono o m w

-- | Stream all incoming data to the given file.
sinkFile :: MonadResource m => FilePath -> ConduitT ByteString o m ()

-- | Cautious version of <a>sinkFile</a>. The idea here is to stream the
--   values to a temporary file in the same directory of the destination
--   file, and only on successfully writing the entire file, moves it
--   atomically to the destination path.
--   
--   In the event of an exception occurring, the temporary file will be
--   deleted and no move will be made. If the application shuts down
--   without running exception handling (such as machine failure or a
--   SIGKILL), the temporary file will remain and the destination file will
--   be untouched.
sinkFileCautious :: MonadResource m => FilePath -> ConduitM ByteString o m ()

-- | Stream data into a temporary file in the given directory with the
--   given filename pattern, and return the temporary filename. The
--   temporary file will be automatically deleted when exiting the active
--   <tt>ResourceT</tt> block, if it still exists.
sinkTempFile :: MonadResource m => FilePath -> String -> ConduitM ByteString o m FilePath

-- | Same as <a>sinkTempFile</a>, but will use the default temp file
--   directory for the system as the first argument.
sinkSystemTempFile :: MonadResource m => String -> ConduitM ByteString o m FilePath

-- | <a>sinkFile</a> specialized to <a>ByteString</a> to help with type
--   inference.
sinkFileBS :: MonadResource m => FilePath -> ConduitT ByteString o m ()

-- | Stream all incoming data to the given <a>Handle</a>. Note that this
--   function does <i>not</i> flush and will <i>not</i> close the
--   <tt>Handle</tt> when processing completes.
sinkHandle :: MonadIO m => Handle -> ConduitT ByteString o m ()

-- | An alternative to <a>sinkHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in write
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sinkIOHandle :: MonadResource m => IO Handle -> ConduitT ByteString o m ()

-- | Print all incoming values to stdout.
--   
--   Subject to fusion
print :: (Show a, MonadIO m) => ConduitT a o m ()

-- | <tt>sinkHandle</tt> applied to <tt>stdout</tt>.
--   
--   Subject to fusion
stdout :: MonadIO m => ConduitT ByteString o m ()

-- | <tt>sinkHandle</tt> applied to <tt>stderr</tt>.
--   
--   Subject to fusion
stderr :: MonadIO m => ConduitT ByteString o m ()

-- | Like <a>withBinaryFile</a>, but provides a sink to write bytes to.
withSinkFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Same as <a>withSinkFile</a>, but lets you use a <a>Builder</a>.
withSinkFileBuilder :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM Builder o n () -> m a) -> m a

-- | Like <a>sinkFileCautious</a>, but uses the <tt>with</tt> pattern
--   instead of <tt>MonadResource</tt>.
withSinkFileCautious :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Stream incoming builders, executing them directly on the buffer of the
--   given <a>Handle</a>. Note that this function does <i>not</i>
--   automatically close the <tt>Handle</tt> when processing completes.
--   Pass <a>flush</a> to flush the buffer.
sinkHandleBuilder :: MonadIO m => Handle -> ConduitM Builder o m ()

-- | Stream incoming <tt>Flush</tt>es, executing them on <tt>IO.Handle</tt>
--   Note that this function does <i>not</i> automatically close the
--   <tt>Handle</tt> when processing completes
sinkHandleFlush :: MonadIO m => Handle -> ConduitM (Flush ByteString) o m ()

-- | Apply a transformation to all values in a stream.
--   
--   Subject to fusion
map :: Monad m => (a -> b) -> ConduitT a b m ()

-- | Apply a transformation to all elements in a chunked stream.
--   
--   Subject to fusion
mapE :: (Monad m, Functor f) => (a -> b) -> ConduitT (f a) (f b) m ()

-- | Apply a monomorphic transformation to all elements in a chunked
--   stream.
--   
--   Unlike <tt>mapE</tt>, this will work on types like <tt>ByteString</tt>
--   and <tt>Text</tt> which are <tt>MonoFunctor</tt> but not
--   <tt>Functor</tt>.
--   
--   Subject to fusion
omapE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> ConduitT mono mono m ()

-- | Apply the function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Subject to fusion
concatMap :: (Monad m, MonoFoldable mono) => (a -> mono) -> ConduitT a (Element mono) m ()

-- | Apply the function to each element in the chunked stream, resulting in
--   a foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
--   
--   Subject to fusion
concatMapE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> ConduitT mono w m ()

-- | Stream up to n number of values downstream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <a>takeExactly</a>.
--   
--   Subject to fusion
take :: Monad m => Int -> ConduitT a a m ()

-- | Stream up to n number of elements downstream in a chunked stream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <a>takeExactlyE</a>.
takeE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Stream all values downstream that match the given predicate.
--   
--   Same caveats regarding downstream termination apply as with
--   <a>take</a>.
takeWhile :: Monad m => (a -> Bool) -> ConduitT a a m ()

-- | Stream all elements downstream that match the given predicate in a
--   chunked stream.
--   
--   Same caveats regarding downstream termination apply as with
--   <a>takeE</a>.
takeWhileE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq seq m ()

-- | Consume precisely the given number of values and feed them downstream.
--   
--   This function is in contrast to <a>take</a>, which will only consume
--   up to the given number of values, and will terminate early if
--   downstream terminates early. This function will discard any additional
--   values in the stream if they are unconsumed.
--   
--   Note that this function takes a downstream <tt>ConduitT</tt> as a
--   parameter, as opposed to working with normal fusion. For more
--   information, see
--   <a>http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit</a>,
--   the section titled "pipes and conduit: isolate".
takeExactly :: Monad m => Int -> ConduitT a b m r -> ConduitT a b m r

-- | Same as <a>takeExactly</a>, but for chunked streams.
takeExactlyE :: (Monad m, IsSequence a) => Index a -> ConduitT a b m r -> ConduitT a b m r

-- | Flatten out a stream by yielding the values contained in an incoming
--   <tt>MonoFoldable</tt> as individually yielded values.
--   
--   Subject to fusion
concat :: (Monad m, MonoFoldable mono) => ConduitT mono (Element mono) m ()

-- | Keep only values in the stream passing a given predicate.
--   
--   Subject to fusion
filter :: Monad m => (a -> Bool) -> ConduitT a a m ()

-- | Keep only elements in the chunked stream passing a given predicate.
--   
--   Subject to fusion
filterE :: (IsSequence seq, Monad m) => (Element seq -> Bool) -> ConduitT seq seq m ()

-- | Map values as long as the result is <tt>Just</tt>.
mapWhile :: Monad m => (a -> Maybe b) -> ConduitT a b m ()

-- | Break up a stream of values into vectors of size n. The final vector
--   may be smaller than n if the total number of values is not a strict
--   multiple of n. No empty vectors will be yielded.
conduitVector :: (Vector v a, PrimMonad m) => Int -> ConduitT a (v a) m ()

-- | Analog of <a>scanl</a> for lists.
--   
--   Subject to fusion
scanl :: Monad m => (a -> b -> a) -> a -> ConduitT b a m ()

-- | <a>mapWhile</a> with a break condition dependent on a strict
--   accumulator. Equivalently, <a>mapAccum</a> as long as the result is
--   <tt>Right</tt>. Instead of producing a leftover, the breaking input
--   determines the resulting accumulator via <tt>Left</tt>.
--   
--   Subject to fusion
mapAccumWhile :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitT a b m s

-- | <a>concatMap</a> with an accumulator.
--   
--   Subject to fusion
concatMapAccum :: Monad m => (a -> accum -> (accum, [b])) -> accum -> ConduitT a b m ()

-- | Insert the given value between each two values in the stream.
--   
--   Subject to fusion
intersperse :: Monad m => a -> ConduitT a a m ()

-- | Sliding window of values 1,2,3,4,5 with window size 2 gives
--   [1,2],[2,3],[3,4],[4,5]
--   
--   Best used with structures that support O(1) snoc.
--   
--   Subject to fusion
slidingWindow :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> ConduitT a seq m ()

-- | Split input into chunk of size <tt>chunkSize</tt>
--   
--   The last element may be smaller than the <tt>chunkSize</tt> (see also
--   <a>chunksOfExactlyE</a> which will not yield this last element)
chunksOfE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Split input into chunk of size <tt>chunkSize</tt>
--   
--   If the input does not split into chunks exactly, the remainder will be
--   leftover (see also <a>chunksOfE</a>)
chunksOfExactlyE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <a>mapM_</a>.
--   
--   Subject to fusion
mapM :: Monad m => (a -> m b) -> ConduitT a b m ()

-- | Apply a monadic transformation to all elements in a chunked stream.
--   
--   Subject to fusion
mapME :: (Monad m, Traversable f) => (a -> m b) -> ConduitT (f a) (f b) m ()

-- | Apply a monadic monomorphic transformation to all elements in a
--   chunked stream.
--   
--   Unlike <tt>mapME</tt>, this will work on types like
--   <tt>ByteString</tt> and <tt>Text</tt> which are <tt>MonoFunctor</tt>
--   but not <tt>Functor</tt>.
--   
--   Subject to fusion
omapME :: (Monad m, MonoTraversable mono) => (Element mono -> m (Element mono)) -> ConduitT mono mono m ()

-- | Apply the monadic function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMapM, mapMaybeM, and mapFoldableM.
--   
--   Subject to fusion
concatMapM :: (Monad m, MonoFoldable mono) => (a -> m mono) -> ConduitT a (Element mono) m ()

-- | Keep only values in the stream passing a given monadic predicate.
--   
--   Subject to fusion
filterM :: Monad m => (a -> m Bool) -> ConduitT a a m ()

-- | Keep only elements in the chunked stream passing a given monadic
--   predicate.
--   
--   Subject to fusion
filterME :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> ConduitT seq seq m ()

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
--   
--   Subject to fusion
iterM :: Monad m => (a -> m ()) -> ConduitT a a m ()

-- | Analog of <a>scanl</a> for lists, monadic.
--   
--   Subject to fusion
scanlM :: Monad m => (a -> b -> m a) -> a -> ConduitT b a m ()

-- | Monadic <a>mapAccumWhile</a>.
--   
--   Subject to fusion
mapAccumWhileM :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> ConduitT a b m s

-- | <a>concatMapM</a> with an accumulator.
--   
--   Subject to fusion
concatMapAccumM :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> ConduitT a b m ()

-- | Encode a stream of text as UTF8.
--   
--   Subject to fusion
encodeUtf8 :: (Monad m, Utf8 text binary) => ConduitT text binary m ()

-- | Decode a stream of binary data as UTF8.
decodeUtf8 :: MonadThrow m => ConduitT ByteString Text m ()

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes
--   with the Unicode replacement character.
decodeUtf8Lenient :: Monad m => ConduitT ByteString Text m ()

-- | Stream in the entirety of a single line.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the line
--   regardless of the behavior of the inner Conduit.
line :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq o m r -> ConduitT seq o m r

-- | Same as <a>line</a>, but operates on ASCII/binary data.
lineAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq o m r -> ConduitT seq o m r

-- | Insert a newline character after each incoming chunk of data.
--   
--   Subject to fusion
unlines :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq seq m ()

-- | Same as <a>unlines</a>, but operates on ASCII/binary data.
--   
--   Subject to fusion
unlinesAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq seq m ()

-- | Stream in the chunked input until an element matches a predicate.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the
--   prefix regardless of the behavior of the inner Conduit.
takeExactlyUntilE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq o m r -> ConduitT seq o m r

-- | Convert a stream of arbitrarily-chunked textual data into a stream of
--   data where each chunk represents a single line. Note that, if you have
--   unknown or untrusted input, this function is <i>unsafe</i>, since it
--   would allow an attacker to form lines of massive length and exhaust
--   memory.
--   
--   Subject to fusion
linesUnbounded :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq seq m ()

-- | Same as <a>linesUnbounded</a>, but for ASCII/binary data.
--   
--   Subject to fusion
linesUnboundedAscii :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq seq m ()

-- | Split a stream of arbitrarily-chunked data, based on a predicate on
--   elements. Elements that satisfy the predicate will cause chunks to be
--   split, and aren't included in these output chunks. Note that, if you
--   have unknown or untrusted input, this function is <i>unsafe</i>, since
--   it would allow an attacker to form chunks of massive length and
--   exhaust memory.
splitOnUnboundedE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq seq m ()

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: PrimMonad m => ConduitT Builder ByteString m ()

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: PrimMonad m => ConduitT Builder ByteString m ()

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: PrimMonad m => BufferAllocStrategy -> ConduitT Builder ByteString m ()

-- | Same as <a>builderToByteString</a>, but input and output are wrapped
--   in <a>Flush</a>.
builderToByteStringFlush :: PrimMonad m => ConduitT (Flush Builder) (Flush ByteString) m ()

builderToByteStringWithFlush :: PrimMonad m => BufferAllocStrategy -> ConduitT (Flush Builder) (Flush ByteString) m ()

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO (IO Buffer))

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy

-- | Generally speaking, yielding values from inside a Conduit requires
--   some allocation for constructors. This can introduce an overhead,
--   similar to the overhead needed to represent a list of values instead
--   of a vector. This overhead is even more severe when talking about
--   unboxed values.
--   
--   This combinator allows you to overcome this overhead, and efficiently
--   fill up vectors. It takes two parameters. The first is the size of
--   each mutable vector to be allocated. The second is a function. The
--   function takes an argument which will yield the next value into a
--   mutable vector.
--   
--   Under the surface, this function uses a number of tricks to get high
--   performance. For more information on both usage and implementation,
--   please see:
--   <a>https://www.schoolofhaskell.com/user/snoyberg/library-documentation/vectorbuilder</a>
vectorBuilder :: (PrimMonad m, PrimMonad n, Vector v e, PrimState m ~ PrimState n) => Int -> ((e -> n ()) -> ConduitT i Void m r) -> ConduitT i (v e) m r

-- | Consume a source with a strict accumulator, in a way piecewise defined
--   by a controlling stream. The latter will be evaluated until it
--   terminates.
--   
--   <pre>
--   &gt;&gt;&gt; let f a s = liftM (:s) $ mapC (*a) =$ CL.take a
--   
--   &gt;&gt;&gt; reverse $ runIdentity $ yieldMany [0..3] $$ mapAccumS f [] (yieldMany [1..])
--   [[],[1],[4,6],[12,15,18]] :: [[Int]]
--   </pre>
mapAccumS :: Monad m => (a -> s -> ConduitT b Void m s) -> s -> ConduitT () b m () -> ConduitT a Void m s

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
peekForever :: Monad m => ConduitT i o m () -> ConduitT i o m ()

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
--   
--   In contrast to <a>peekForever</a>, this function will ignore empty
--   chunks of data. So for example, if a stream of data contains an empty
--   <tt>ByteString</tt>, it is still treated as empty, and the consuming
--   function is not called.
peekForeverE :: (Monad m, MonoFoldable i) => ConduitT i o m () -> ConduitT i o m ()


-- | Your intended one-stop-shop for conduit functionality. This re-exports
--   functions from many commonly used modules. When there is a conflict
--   with standard functions, functions in this module are disambiguated by
--   adding a trailing C (or for chunked functions, replacing a trailing E
--   with CE). This means that the Conduit module can be imported
--   unqualified without causing naming conflicts.
--   
--   For more information on the naming scheme and intended usages of the
--   combinators, please see the <a>Data.Conduit.Combinators</a>
--   documentation.
module Conduit

-- | Yield each of the values contained by the given <tt>MonoFoldable</tt>.
--   
--   This will work on many data structures, including lists,
--   <tt>ByteString</tt>s, and <tt>Vector</tt>s.
--   
--   Subject to fusion
yieldMany :: (Monad m, MonoFoldable mono) => mono -> ConduitT i (Element mono) m ()

-- | Generate a producer from a seed value.
unfoldC :: Monad m => (b -> Maybe (a, b)) -> b -> ConduitT i a m ()

-- | Enumerate from a value to a final value, inclusive, via <tt>succ</tt>.
--   
--   This is generally more efficient than using <tt>Prelude</tt>'s
--   <tt>enumFromTo</tt> and combining with <tt>sourceList</tt> since this
--   avoids any intermediate data structures.
enumFromToC :: (Monad m, Enum a, Ord a) => a -> a -> ConduitT i a m ()

-- | Produces an infinite stream of repeated applications of f to x.
iterateC :: Monad m => (a -> a) -> a -> ConduitT i a m ()

-- | Produce an infinite stream consisting entirely of the given value.
repeatC :: Monad m => a -> ConduitT i a m ()

-- | Produce a finite stream consisting of n copies of the given value.
replicateC :: Monad m => Int -> a -> ConduitT i a m ()

-- | Generate a producer by yielding each of the strict chunks in a
--   <tt>LazySequence</tt>.
--   
--   For more information, see <a>toChunks</a>.
--   
--   Subject to fusion
sourceLazy :: (Monad m, LazySequence lazy strict) => lazy -> ConduitT i strict m ()

-- | Repeatedly run the given action and yield all values it produces.
repeatMC :: Monad m => m a -> ConduitT i a m ()

-- | Repeatedly run the given action and yield all values it produces,
--   until the provided predicate returns <tt>False</tt>.
repeatWhileMC :: Monad m => m a -> (a -> Bool) -> ConduitT i a m ()

-- | Perform the given action n times, yielding each result.
replicateMC :: Monad m => Int -> m a -> ConduitT i a m ()

-- | Stream the contents of a file as binary data.
sourceFile :: MonadResource m => FilePath -> ConduitT i ByteString m ()

-- | Same as <a>sourceFile</a>. The alternate name is a holdover from an
--   older version, when <a>sourceFile</a> was more polymorphic than it is
--   today.
sourceFileBS :: MonadResource m => FilePath -> ConduitT i ByteString m ()

-- | Stream the contents of a <a>Handle</a> as binary data. Note that this
--   function will <i>not</i> automatically close the <tt>Handle</tt> when
--   processing completes, since it did not acquire the <tt>Handle</tt> in
--   the first place.
sourceHandle :: MonadIO m => Handle -> ConduitT i ByteString m ()

-- | Same as <tt>sourceHandle</tt>, but instead of allocating a new buffer
--   for each incoming chunk of data, reuses the same buffer. Therefore,
--   the <tt>ByteString</tt>s yielded by this function are not
--   referentially transparent between two different <tt>yield</tt>s.
--   
--   This function will be slightly more efficient than
--   <tt>sourceHandle</tt> by avoiding allocations and reducing garbage
--   collections, but should only be used if you can guarantee that you do
--   not reuse a <tt>ByteString</tt> (or any slice thereof) between two
--   calls to <tt>await</tt>.
sourceHandleUnsafe :: MonadIO m => Handle -> ConduitT i ByteString m ()

-- | An alternative to <a>sourceHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in read
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sourceIOHandle :: MonadResource m => IO Handle -> ConduitT i ByteString m ()

-- | <tt>sourceHandle</tt> applied to <tt>stdin</tt>.
stdinC :: MonadIO m => ConduitT i ByteString m ()

-- | Like <a>withBinaryFile</a>, but provides a source to read bytes from.
withSourceFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM i ByteString n () -> m a) -> m a

-- | Stream the contents of the given directory, without traversing deeply.
--   
--   This function will return <i>all</i> of the contents of the directory,
--   whether they be files, directories, etc.
--   
--   Note that the generated filepaths will be the complete path, not just
--   the filename. In other words, if you have a directory <tt>foo</tt>
--   containing files <tt>bar</tt> and <tt>baz</tt>, and you use
--   <tt>sourceDirectory</tt> on <tt>foo</tt>, the results will be
--   <tt>foo/bar</tt> and <tt>foo/baz</tt>.
sourceDirectory :: MonadResource m => FilePath -> ConduitT i FilePath m ()

-- | Deeply stream the contents of the given directory.
--   
--   This works the same as <tt>sourceDirectory</tt>, but will not return
--   directories at all. This function also takes an extra parameter to
--   indicate whether symlinks will be followed.
sourceDirectoryDeep :: MonadResource m => Bool -> FilePath -> ConduitT i FilePath m ()

-- | Ignore a certain number of values in the stream.
--   
--   Note: since this function doesn't produce anything, you probably want
--   to use it with (<a>&gt;&gt;</a>) instead of directly plugging it into
--   a pipeline:
--   
--   <pre>
--   &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| dropC 2 .| sinkList
--   []
--   
--   &gt;&gt;&gt; runConduit $ yieldMany [1..5] .| (dropC 2 &gt;&gt; sinkList)
--   [3,4,5]
--   </pre>
dropC :: Monad m => Int -> ConduitT a o m ()

-- | Drop a certain number of elements from a chunked stream.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>dropC</a>.
dropCE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq o m ()

-- | Drop all values which match the given predicate.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>dropC</a>.
dropWhileC :: Monad m => (a -> Bool) -> ConduitT a o m ()

-- | Drop all elements in the chunked stream which match the given
--   predicate.
--   
--   Note: you likely want to use it with monadic composition. See the docs
--   for <a>dropC</a>.
dropWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq o m ()

-- | Monoidally combine all values in the stream.
foldC :: (Monad m, Monoid a) => ConduitT a o m a

-- | Monoidally combine all elements in the chunked stream.
foldCE :: (Monad m, MonoFoldable mono, Monoid (Element mono)) => ConduitT mono o m (Element mono)

-- | A strict left fold.
foldlC :: Monad m => (a -> b -> a) -> a -> ConduitT b o m a

-- | A strict left fold on a chunked stream.
foldlCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> a) -> a -> ConduitT mono o m a

-- | Apply the provided mapping function and monoidal combine all values.
foldMapC :: (Monad m, Monoid b) => (a -> b) -> ConduitT a o m b

-- | Apply the provided mapping function and monoidal combine all elements
--   of the chunked stream.
foldMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> ConduitT mono o m w

-- | Check that all values in the stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
allC :: Monad m => (a -> Bool) -> ConduitT a o m Bool

-- | Check that all elements in the chunked stream return True.
--   
--   Subject to shortcut logic: at the first False, consumption of the
--   stream will stop.
allCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m Bool

-- | Check that at least one value in the stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
anyC :: Monad m => (a -> Bool) -> ConduitT a o m Bool

-- | Check that at least one element in the chunked stream returns True.
--   
--   Subject to shortcut logic: at the first True, consumption of the
--   stream will stop.
anyCE :: (Monad m, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m Bool

-- | Are all values in the stream True?
--   
--   Consumption stops once the first False is encountered.
andC :: Monad m => ConduitT Bool o m Bool

-- | Are all elements in the chunked stream True?
--   
--   Consumption stops once the first False is encountered.
andCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => ConduitT mono o m Bool

-- | Are any values in the stream True?
--   
--   Consumption stops once the first True is encountered.
orC :: Monad m => ConduitT Bool o m Bool

-- | Are any elements in the chunked stream True?
--   
--   Consumption stops once the first True is encountered.
orCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool) => ConduitT mono o m Bool

-- | <a>Alternative</a>ly combine all values in the stream.
asumC :: (Monad m, Alternative f) => ConduitT (f a) o m (f a)

-- | Are any values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
elemC :: (Monad m, Eq a) => a -> ConduitT a o m Bool

-- | Are any elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
elemCE :: (Monad m, IsSequence seq, Eq (Element seq)) => Element seq -> ConduitT seq o m Bool

-- | Are no values in the stream equal to the given value?
--   
--   Stops consuming as soon as a match is found.
notElemC :: (Monad m, Eq a) => a -> ConduitT a o m Bool

-- | Are no elements in the chunked stream equal to the given element?
--   
--   Stops consuming as soon as a match is found.
notElemCE :: (Monad m, IsSequence seq, Eq (Element seq)) => Element seq -> ConduitT seq o m Bool

-- | Consume all incoming strict chunks into a lazy sequence. Note that the
--   entirety of the sequence will be resident at memory.
--   
--   This can be used to consume a stream of strict ByteStrings into a lazy
--   ByteString, for example.
--   
--   Subject to fusion
sinkLazy :: (Monad m, LazySequence lazy strict) => ConduitT strict o m lazy

-- | Consume all values from the stream and return as a list. Note that
--   this will pull all values into memory.
--   
--   Subject to fusion
sinkList :: Monad m => ConduitT a o m [a]

-- | Sink incoming values into a vector, growing the vector as necessary to
--   fit more elements.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
sinkVector :: (Vector v a, PrimMonad m) => ConduitT a o m (v a)

-- | Sink incoming values into a vector, up until size <tt>maxSize</tt>.
--   Subsequent values will be left in the stream. If there are less than
--   <tt>maxSize</tt> values present, returns a <tt>Vector</tt> of smaller
--   size.
--   
--   Note that using this function is more memory efficient than
--   <tt>sinkList</tt> and then converting to a <tt>Vector</tt>, as it
--   avoids intermediate list constructors.
--   
--   Subject to fusion
sinkVectorN :: (Vector v a, PrimMonad m) => Int -> ConduitT a o m (v a)

-- | Same as <tt>sinkBuilder</tt>, but afterwards convert the builder to
--   its lazy representation.
--   
--   Alternatively, this could be considered an alternative to
--   <tt>sinkLazy</tt>, with the following differences:
--   
--   <ul>
--   <li>This function will allow multiple input types, not just the strict
--   version of the lazy structure.</li>
--   <li>Some buffer copying may occur in this version.</li>
--   </ul>
--   
--   Subject to fusion
sinkLazyBuilder :: Monad m => ConduitT Builder o m ByteString

-- | Consume and discard all remaining values in the stream.
--   
--   Subject to fusion
sinkNull :: Monad m => ConduitT a o m ()

-- | Same as <tt>await</tt>, but discards any leading <a>onull</a> values.
awaitNonNull :: (Monad m, MonoFoldable a) => ConduitT a o m (Maybe (NonNull a))

-- | Take a single value from the stream, if available.
headC :: Monad m => ConduitT a o m (Maybe a)

-- | Same as <a>headC</a>, but returns a default value if none are
--   available from the stream.
headDefC :: Monad m => a -> ConduitT a o m a

-- | Get the next element in the chunked stream.
headCE :: (Monad m, IsSequence seq) => ConduitT seq o m (Maybe (Element seq))

-- | View the next value in the stream without consuming it.
peekC :: Monad m => ConduitT a o m (Maybe a)

-- | View the next element in the chunked stream without consuming it.
peekCE :: (Monad m, MonoFoldable mono) => ConduitT mono o m (Maybe (Element mono))

-- | Retrieve the last value in the stream, if present.
lastC :: Monad m => ConduitT a o m (Maybe a)

-- | Same as <a>lastC</a>, but returns a default value if none are
--   available from the stream.
lastDefC :: Monad m => a -> ConduitT a o m a

-- | Retrieve the last element in the chunked stream, if present.
lastCE :: (Monad m, IsSequence seq) => ConduitT seq o m (Maybe (Element seq))

-- | Count how many values are in the stream.
lengthC :: (Monad m, Num len) => ConduitT a o m len

-- | Count how many elements are in the chunked stream.
lengthCE :: (Monad m, Num len, MonoFoldable mono) => ConduitT mono o m len

-- | Count how many values in the stream pass the given predicate.
lengthIfC :: (Monad m, Num len) => (a -> Bool) -> ConduitT a o m len

-- | Count how many elements in the chunked stream pass the given
--   predicate.
lengthIfCE :: (Monad m, Num len, MonoFoldable mono) => (Element mono -> Bool) -> ConduitT mono o m len

-- | Get the largest value in the stream, if present.
maximumC :: (Monad m, Ord a) => ConduitT a o m (Maybe a)

-- | Get the largest element in the chunked stream, if present.
maximumCE :: (Monad m, IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))

-- | Get the smallest value in the stream, if present.
minimumC :: (Monad m, Ord a) => ConduitT a o m (Maybe a)

-- | Get the smallest element in the chunked stream, if present.
minimumCE :: (Monad m, IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))

-- | True if there are no values in the stream.
--   
--   This function does not modify the stream.
nullC :: Monad m => ConduitT a o m Bool

-- | True if there are no elements in the chunked stream.
--   
--   This function may remove empty leading chunks from the stream, but
--   otherwise will not modify it.
nullCE :: (Monad m, MonoFoldable mono) => ConduitT mono o m Bool

-- | Get the sum of all values in the stream.
sumC :: (Monad m, Num a) => ConduitT a o m a

-- | Get the sum of all elements in the chunked stream.
sumCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)

-- | Get the product of all values in the stream.
productC :: (Monad m, Num a) => ConduitT a o m a

-- | Get the product of all elements in the chunked stream.
productCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)

-- | Find the first matching value.
findC :: Monad m => (a -> Bool) -> ConduitT a o m (Maybe a)

-- | Apply the action to all values in the stream.
--   
--   Note: if you want to <i>pass</i> the values instead of
--   <i>consuming</i> them, use <tt>iterM</tt> instead.
mapM_C :: Monad m => (a -> m ()) -> ConduitT a o m ()

-- | Apply the action to all elements in the chunked stream.
--   
--   Note: the same caveat as with <a>mapM_C</a> applies. If you don't want
--   to consume the values, you can use <tt>iterM</tt>:
--   
--   <pre>
--   iterM (omapM_ f)
--   </pre>
mapM_CE :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> ConduitT mono o m ()

-- | A monadic strict left fold.
foldMC :: Monad m => (a -> b -> m a) -> a -> ConduitT b o m a

-- | A monadic strict left fold on a chunked stream.
foldMCE :: (Monad m, MonoFoldable mono) => (a -> Element mono -> m a) -> a -> ConduitT mono o m a

-- | Apply the provided monadic mapping function and monoidal combine all
--   values.
foldMapMC :: (Monad m, Monoid w) => (a -> m w) -> ConduitT a o m w

-- | Apply the provided monadic mapping function and monoidal combine all
--   elements in the chunked stream.
foldMapMCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> m w) -> ConduitT mono o m w

-- | Stream all incoming data to the given file.
sinkFile :: MonadResource m => FilePath -> ConduitT ByteString o m ()

-- | Cautious version of <a>sinkFile</a>. The idea here is to stream the
--   values to a temporary file in the same directory of the destination
--   file, and only on successfully writing the entire file, moves it
--   atomically to the destination path.
--   
--   In the event of an exception occurring, the temporary file will be
--   deleted and no move will be made. If the application shuts down
--   without running exception handling (such as machine failure or a
--   SIGKILL), the temporary file will remain and the destination file will
--   be untouched.
sinkFileCautious :: MonadResource m => FilePath -> ConduitM ByteString o m ()

-- | Stream data into a temporary file in the given directory with the
--   given filename pattern, and return the temporary filename. The
--   temporary file will be automatically deleted when exiting the active
--   <tt>ResourceT</tt> block, if it still exists.
sinkTempFile :: MonadResource m => FilePath -> String -> ConduitM ByteString o m FilePath

-- | Same as <a>sinkTempFile</a>, but will use the default temp file
--   directory for the system as the first argument.
sinkSystemTempFile :: MonadResource m => String -> ConduitM ByteString o m FilePath

-- | <a>sinkFile</a> specialized to <a>ByteString</a> to help with type
--   inference.
sinkFileBS :: MonadResource m => FilePath -> ConduitT ByteString o m ()

-- | Stream all incoming data to the given <a>Handle</a>. Note that this
--   function does <i>not</i> flush and will <i>not</i> close the
--   <tt>Handle</tt> when processing completes.
sinkHandle :: MonadIO m => Handle -> ConduitT ByteString o m ()

-- | An alternative to <a>sinkHandle</a>. Instead of taking a pre-opened
--   <a>Handle</a>, it takes an action that opens a <a>Handle</a> (in write
--   mode), so that it can open it only when needed and close it as soon as
--   possible.
sinkIOHandle :: MonadResource m => IO Handle -> ConduitT ByteString o m ()

-- | Print all incoming values to stdout.
printC :: (Show a, MonadIO m) => ConduitT a o m ()

-- | <tt>sinkHandle</tt> applied to <tt>stdout</tt>.
stdoutC :: MonadIO m => ConduitT ByteString o m ()

-- | <tt>sinkHandle</tt> applied to <tt>stderr</tt>.
stderrC :: MonadIO m => ConduitT ByteString o m ()

-- | Like <a>withBinaryFile</a>, but provides a sink to write bytes to.
withSinkFile :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Same as <a>withSinkFile</a>, but lets you use a <a>Builder</a>.
withSinkFileBuilder :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM Builder o n () -> m a) -> m a

-- | Like <a>sinkFileCautious</a>, but uses the <tt>with</tt> pattern
--   instead of <tt>MonadResource</tt>.
withSinkFileCautious :: (MonadUnliftIO m, MonadIO n) => FilePath -> (ConduitM ByteString o n () -> m a) -> m a

-- | Stream incoming builders, executing them directly on the buffer of the
--   given <a>Handle</a>. Note that this function does <i>not</i>
--   automatically close the <tt>Handle</tt> when processing completes.
--   Pass <a>flush</a> to flush the buffer.
sinkHandleBuilder :: MonadIO m => Handle -> ConduitM Builder o m ()

-- | Stream incoming <tt>Flush</tt>es, executing them on <tt>IO.Handle</tt>
--   Note that this function does <i>not</i> automatically close the
--   <tt>Handle</tt> when processing completes
sinkHandleFlush :: MonadIO m => Handle -> ConduitM (Flush ByteString) o m ()

-- | Apply a transformation to all values in a stream.
mapC :: Monad m => (a -> b) -> ConduitT a b m ()

-- | Apply a transformation to all elements in a chunked stream.
mapCE :: (Monad m, Functor f) => (a -> b) -> ConduitT (f a) (f b) m ()

-- | Apply a monomorphic transformation to all elements in a chunked
--   stream.
--   
--   Unlike <tt>mapE</tt>, this will work on types like <tt>ByteString</tt>
--   and <tt>Text</tt> which are <tt>MonoFunctor</tt> but not
--   <tt>Functor</tt>.
omapCE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> ConduitT mono mono m ()

-- | Apply the function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
concatMapC :: (Monad m, MonoFoldable mono) => (a -> mono) -> ConduitT a (Element mono) m ()

-- | Apply the function to each element in the chunked stream, resulting in
--   a foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMap, mapMaybe, and mapFoldable.
concatMapCE :: (Monad m, MonoFoldable mono, Monoid w) => (Element mono -> w) -> ConduitT mono w m ()

-- | Stream up to n number of values downstream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <tt>takeExactly</tt>.
takeC :: Monad m => Int -> ConduitT a a m ()

-- | Stream up to n number of elements downstream in a chunked stream.
--   
--   Note that, if downstream terminates early, not all values will be
--   consumed. If you want to force <i>exactly</i> the given number of
--   values to be consumed, see <tt>takeExactlyE</tt>.
takeCE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Stream all values downstream that match the given predicate.
--   
--   Same caveats regarding downstream termination apply as with
--   <tt>take</tt>.
takeWhileC :: Monad m => (a -> Bool) -> ConduitT a a m ()

-- | Stream all elements downstream that match the given predicate in a
--   chunked stream.
--   
--   Same caveats regarding downstream termination apply as with
--   <tt>takeE</tt>.
takeWhileCE :: (Monad m, IsSequence seq) => (Element seq -> Bool) -> ConduitT seq seq m ()

-- | Consume precisely the given number of values and feed them downstream.
--   
--   This function is in contrast to <tt>take</tt>, which will only consume
--   up to the given number of values, and will terminate early if
--   downstream terminates early. This function will discard any additional
--   values in the stream if they are unconsumed.
--   
--   Note that this function takes a downstream <tt>ConduitT</tt> as a
--   parameter, as opposed to working with normal fusion. For more
--   information, see
--   <a>http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit</a>,
--   the section titled "pipes and conduit: isolate".
takeExactlyC :: Monad m => Int -> ConduitT a b m r -> ConduitT a b m r

-- | Same as <tt>takeExactly</tt>, but for chunked streams.
takeExactlyCE :: (Monad m, IsSequence a) => Index a -> ConduitT a b m r -> ConduitT a b m r

-- | Flatten out a stream by yielding the values contained in an incoming
--   <tt>MonoFoldable</tt> as individually yielded values.
concatC :: (Monad m, MonoFoldable mono) => ConduitT mono (Element mono) m ()

-- | Keep only values in the stream passing a given predicate.
filterC :: Monad m => (a -> Bool) -> ConduitT a a m ()

-- | Keep only elements in the chunked stream passing a given predicate.
filterCE :: (IsSequence seq, Monad m) => (Element seq -> Bool) -> ConduitT seq seq m ()

-- | Map values as long as the result is <tt>Just</tt>.
mapWhileC :: Monad m => (a -> Maybe b) -> ConduitT a b m ()

-- | Break up a stream of values into vectors of size n. The final vector
--   may be smaller than n if the total number of values is not a strict
--   multiple of n. No empty vectors will be yielded.
conduitVector :: (Vector v a, PrimMonad m) => Int -> ConduitT a (v a) m ()

-- | Analog of <a>scanl</a> for lists.
scanlC :: Monad m => (a -> b -> a) -> a -> ConduitT b a m ()

-- | <a>mapWhileC</a> with a break condition dependent on a strict
--   accumulator. Equivalently, <a>mapAccum</a> as long as the result is
--   <tt>Right</tt>. Instead of producing a leftover, the breaking input
--   determines the resulting accumulator via <tt>Left</tt>.
mapAccumWhileC :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitT a b m s

-- | <tt>concatMap</tt> with an accumulator.
concatMapAccumC :: Monad m => (a -> accum -> (accum, [b])) -> accum -> ConduitT a b m ()

-- | Insert the given value between each two values in the stream.
intersperseC :: Monad m => a -> ConduitT a a m ()

-- | Sliding window of values 1,2,3,4,5 with window size 2 gives
--   [1,2],[2,3],[3,4],[4,5]
--   
--   Best used with structures that support O(1) snoc.
slidingWindowC :: (Monad m, IsSequence seq, Element seq ~ a) => Int -> ConduitT a seq m ()

-- | Split input into chunk of size <tt>chunkSize</tt>
--   
--   The last element may be smaller than the <tt>chunkSize</tt> (see also
--   <tt>chunksOfExactlyE</tt> which will not yield this last element)
chunksOfCE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Split input into chunk of size <tt>chunkSize</tt>
--   
--   If the input does not split into chunks exactly, the remainder will be
--   leftover (see also <tt>chunksOfE</tt>)
chunksOfExactlyCE :: (Monad m, IsSequence seq) => Index seq -> ConduitT seq seq m ()

-- | Apply a monadic transformation to all values in a stream.
--   
--   If you do not need the transformed values, and instead just want the
--   monadic side-effects of running the action, see <tt>mapM_</tt>.
mapMC :: Monad m => (a -> m b) -> ConduitT a b m ()

-- | Apply a monadic transformation to all elements in a chunked stream.
mapMCE :: (Monad m, Traversable f) => (a -> m b) -> ConduitT (f a) (f b) m ()

-- | Apply a monadic monomorphic transformation to all elements in a
--   chunked stream.
--   
--   Unlike <tt>mapME</tt>, this will work on types like
--   <tt>ByteString</tt> and <tt>Text</tt> which are <tt>MonoFunctor</tt>
--   but not <tt>Functor</tt>.
omapMCE :: (Monad m, MonoTraversable mono) => (Element mono -> m (Element mono)) -> ConduitT mono mono m ()

-- | Apply the monadic function to each value in the stream, resulting in a
--   foldable value (e.g., a list). Then yield each of the individual
--   values in that foldable value separately.
--   
--   Generalizes concatMapM, mapMaybeM, and mapFoldableM.
concatMapMC :: (Monad m, MonoFoldable mono) => (a -> m mono) -> ConduitT a (Element mono) m ()

-- | Keep only values in the stream passing a given monadic predicate.
filterMC :: Monad m => (a -> m Bool) -> ConduitT a a m ()

-- | Keep only elements in the chunked stream passing a given monadic
--   predicate.
filterMCE :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> ConduitT seq seq m ()

-- | Apply a monadic action on all values in a stream.
--   
--   This <tt>Conduit</tt> can be used to perform a monadic side-effect for
--   every value, whilst passing the value through the <tt>Conduit</tt>
--   as-is.
--   
--   <pre>
--   iterM f = mapM (\a -&gt; f a &gt;&gt;= \() -&gt; return a)
--   </pre>
iterMC :: Monad m => (a -> m ()) -> ConduitT a a m ()

-- | Analog of <a>scanl</a> for lists, monadic.
scanlMC :: Monad m => (a -> b -> m a) -> a -> ConduitT b a m ()

-- | Monadic <a>mapAccumWhileC</a>.
mapAccumWhileMC :: Monad m => (a -> s -> m (Either s (s, b))) -> s -> ConduitT a b m s

-- | <tt>concatMapM</tt> with an accumulator.
concatMapAccumMC :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> ConduitT a b m ()

-- | Encode a stream of text as UTF8.
encodeUtf8C :: (Monad m, Utf8 text binary) => ConduitT text binary m ()

-- | Decode a stream of binary data as UTF8.
decodeUtf8C :: MonadThrow m => ConduitT ByteString Text m ()

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes
--   with the Unicode replacement character.
decodeUtf8LenientC :: Monad m => ConduitT ByteString Text m ()

-- | Stream in the entirety of a single line.
--   
--   Like <tt>takeExactly</tt>, this will consume the entirety of the line
--   regardless of the behavior of the inner Conduit.
lineC :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq o m r -> ConduitT seq o m r

-- | Same as <tt>line</tt>, but operates on ASCII/binary data.
lineAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq o m r -> ConduitT seq o m r

-- | Insert a newline character after each incoming chunk of data.
unlinesC :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq seq m ()

-- | Same as <tt>unlines</tt>, but operates on ASCII/binary data.
unlinesAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq seq m ()

-- | Convert a stream of arbitrarily-chunked textual data into a stream of
--   data where each chunk represents a single line. Note that, if you have
--   unknown<i>untrusted input, this function is </i>unsafe/, since it
--   would allow an attacker to form lines of massive length and exhaust
--   memory.
linesUnboundedC :: (Monad m, IsSequence seq, Element seq ~ Char) => ConduitT seq seq m ()

-- | Same as <tt>linesUnbounded</tt>, but for ASCII/binary data.
linesUnboundedAsciiC :: (Monad m, IsSequence seq, Element seq ~ Word8) => ConduitT seq seq m ()

-- | Incrementally execute builders and pass on the filled chunks as
--   bytestrings.
builderToByteString :: PrimMonad m => ConduitT Builder ByteString m ()

-- | Incrementally execute builders on the given buffer and pass on the
--   filled chunks as bytestrings. Note that, if the given buffer is too
--   small for the execution of a build step, a larger one will be
--   allocated.
--   
--   WARNING: This conduit yields bytestrings that are NOT referentially
--   transparent. Their content will be overwritten as soon as control is
--   returned from the inner sink!
unsafeBuilderToByteString :: PrimMonad m => ConduitT Builder ByteString m ()

-- | A conduit that incrementally executes builders and passes on the
--   filled chunks as bytestrings to an inner sink.
--   
--   INV: All bytestrings passed to the inner sink are non-empty.
builderToByteStringWith :: PrimMonad m => BufferAllocStrategy -> ConduitT Builder ByteString m ()

-- | Same as <a>builderToByteString</a>, but input and output are wrapped
--   in <a>Flush</a>.
builderToByteStringFlush :: PrimMonad m => ConduitT (Flush Builder) (Flush ByteString) m ()

builderToByteStringWithFlush :: PrimMonad m => BufferAllocStrategy -> ConduitT (Flush Builder) (Flush ByteString) m ()

-- | A buffer allocation strategy <tt>(buf0, nextBuf)</tt> specifies the
--   initial buffer to use and how to compute a new buffer <tt>nextBuf
--   minSize buf</tt> with at least size <tt>minSize</tt> from a filled
--   buffer <tt>buf</tt>. The double nesting of the <tt>IO</tt> monad helps
--   to ensure that the reference to the filled buffer <tt>buf</tt> is lost
--   as soon as possible, but the new buffer doesn't have to be allocated
--   too early.
type BufferAllocStrategy = (IO Buffer, Int -> Buffer -> IO (IO Buffer))

-- | The simplest buffer allocation strategy: whenever a buffer is
--   requested, allocate a new one that is big enough for the next build
--   step to execute.
--   
--   NOTE that this allocation strategy may spill quite some memory upon
--   direct insertion of a bytestring by the builder. Thats no problem for
--   garbage collection, but it may lead to unreasonably high memory
--   consumption in special circumstances.
allNewBuffersStrategy :: Int -> BufferAllocStrategy

-- | An unsafe, but possibly more efficient buffer allocation strategy:
--   reuse the buffer, if it is big enough for the next build step to
--   execute.
reuseBufferStrategy :: IO Buffer -> BufferAllocStrategy

-- | Generally speaking, yielding values from inside a Conduit requires
--   some allocation for constructors. This can introduce an overhead,
--   similar to the overhead needed to represent a list of values instead
--   of a vector. This overhead is even more severe when talking about
--   unboxed values.
--   
--   This combinator allows you to overcome this overhead, and efficiently
--   fill up vectors. It takes two parameters. The first is the size of
--   each mutable vector to be allocated. The second is a function. The
--   function takes an argument which will yield the next value into a
--   mutable vector.
--   
--   Under the surface, this function uses a number of tricks to get high
--   performance. For more information on both usage and implementation,
--   please see:
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/vectorbuilder</a>
vectorBuilderC :: (PrimMonad m, Vector v e, PrimMonad n, PrimState m ~ PrimState n) => Int -> ((e -> n ()) -> ConduitT i Void m r) -> ConduitT i (v e) m r

-- | Consume a source with a strict accumulator, in a way piecewise defined
--   by a controlling stream. The latter will be evaluated until it
--   terminates.
--   
--   <pre>
--   &gt;&gt;&gt; let f a s = liftM (:s) $ mapC (*a) =$ CL.take a
--   
--   &gt;&gt;&gt; reverse $ runIdentity $ yieldMany [0..3] $$ mapAccumS f [] (yieldMany [1..])
--   [[],[1],[4,6],[12,15,18]] :: [[Int]]
--   </pre>
mapAccumS :: Monad m => (a -> s -> ConduitT b Void m s) -> s -> ConduitT () b m () -> ConduitT a Void m s

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
peekForever :: Monad m => ConduitT i o m () -> ConduitT i o m ()

-- | Run a consuming conduit repeatedly, only stopping when there is no
--   more data available from upstream.
--   
--   In contrast to <a>peekForever</a>, this function will ignore empty
--   chunks of data. So for example, if a stream of data contains an empty
--   <tt>ByteString</tt>, it is still treated as empty, and the consuming
--   function is not called.
peekForeverE :: (Monad m, MonoFoldable i) => ConduitT i o m () -> ConduitT i o m ()

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, HasCallStack, Exception e) => e -> m a

-- | Monads which allow their actions to be run in <a>IO</a>.
--   
--   While <a>MonadIO</a> allows an <a>IO</a> action to be lifted into
--   another monad, this class captures the opposite concept: allowing you
--   to capture the monadic context. Note that, in order to meet the laws
--   given below, the intuition is that a monad must have no monadic state,
--   but may have monadic context. This essentially limits
--   <a>MonadUnliftIO</a> to <a>ReaderT</a> and <a>IdentityT</a>
--   transformers on top of <a>IO</a>.
--   
--   Laws. For any function <tt>run</tt> provided by <a>withRunInIO</a>, it
--   must meet the monad transformer laws as reformulated for
--   <tt>MonadUnliftIO</tt>:
--   
--   <ul>
--   <li><pre>run . return = return</pre></li>
--   <li><pre>run (m &gt;&gt;= f) = run m &gt;&gt;= run . f</pre></li>
--   </ul>
--   
--   Instances of <tt>MonadUnliftIO</tt> must also satisfy the following
--   laws:
--   
--   <ul>
--   <li><i>Identity law</i> <tt>withRunInIO (\run -&gt; run m) =
--   m</tt></li>
--   <li><i>Inverse law</i> <tt>withRunInIO (\_ -&gt; m) = liftIO
--   m</tt></li>
--   </ul>
--   
--   As an example of an invalid instance, a naive implementation of
--   <tt>MonadUnliftIO (StateT s m)</tt> might be
--   
--   <pre>
--   withRunInIO inner =
--     StateT $ \s -&gt;
--       withRunInIO $ \run -&gt;
--         inner (run . flip evalStateT s)
--   </pre>
--   
--   This breaks the identity law because the inner <tt>run m</tt> would
--   throw away any state changes in <tt>m</tt>.
class MonadIO m => MonadUnliftIO (m :: Type -> Type)

-- | Convenience function for capturing the monadic context and running an
--   <a>IO</a> action with a runner function. The runner function is used
--   to run a monadic action <tt>m</tt> in <tt>IO</tt>.
withRunInIO :: MonadUnliftIO m => ((forall a. () => m a -> IO a) -> IO b) -> m b

-- | Class of monads which can perform primitive state-transformer actions.
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type.
    type family PrimState (m :: Type -> Type);
}

-- | Execute a primitive operation.
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack which includes a <tt>ResourceT</tt> can be
--   an instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a <tt>MonadUnliftIO
--   m</tt> monad, which allows control operations to be lifted. A
--   <tt>MonadResource</tt> does not have this requirement. This means that
--   transformers such as <tt>ContT</tt> can be an instance of
--   <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will need
--   to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class MonadIO m => MonadResource (m :: Type -> Type)

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <tt>runResourceT</tt>). Actions may be registered via
--   <tt>register</tt>, or resources may be allocated atomically via
--   <tt>allocate</tt>. <tt>allocate</tt> corresponds closely to
--   <tt>bracket</tt>.
--   
--   Releasing may be performed before exit via the <tt>release</tt>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Since 0.3.0
data () => ResourceT (m :: Type -> Type) a

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to
--   <a>resourceForkIO</a>. If multiple threads are sharing the same
--   collection of resources, only the last call to <tt>runResourceT</tt>
--   will deallocate the resources.
--   
--   <i>NOTE</i> Since version 1.2.0, this function will throw a
--   <a>ResourceCleanupException</a> if any of the cleanup functions throw
--   an exception.
runResourceT :: MonadUnliftIO m => ResourceT m a -> m a

-- | A method for acquiring a scarce resource, providing the means of
--   freeing it when no longer needed. This data type provides
--   <tt>Functor</tt>/<tt>Applicative</tt>/<tt>Monad</tt> instances for
--   composing different resources together. You can allocate these
--   resources using either the <tt>bracket</tt> pattern (via
--   <tt>with</tt>) or using <tt>ResourceT</tt> (via
--   <tt>allocateAcquire</tt>).
--   
--   This concept was originally introduced by Gabriel Gonzalez and
--   described at:
--   <a>http://www.haskellforall.com/2013/06/the-resource-applicative.html</a>.
--   The implementation in this package is slightly different, due to
--   taking a different approach to async exception safety.
data () => Acquire a

-- | The way in which a release is called.
data () => ReleaseType
ReleaseEarly :: ReleaseType
ReleaseNormal :: ReleaseType
ReleaseExceptionWith :: SomeException -> ReleaseType
pattern ReleaseException :: ReleaseType

-- | Create an <tt>Acquire</tt> value using the given allocate and free
--   functions.
--   
--   To acquire and free the resource in an arbitrary monad with
--   <a>MonadUnliftIO</a>, do the following:
--   
--   <pre>
--   acquire &lt;- withRunInIO $ \runInIO -&gt;
--     return $ mkAcquire (runInIO create) (runInIO . free)
--   </pre>
--   
--   Note that this is only safe if the Acquire is run and freed within the
--   same monadic scope it was created in.
mkAcquire :: IO a -> (a -> IO ()) -> Acquire a

-- | Same as <a>mkAcquire</a>, but the cleanup function will be informed of
--   <i>how</i> cleanup was initiated. This allows you to distinguish, for
--   example, between normal and exceptional exits.
--   
--   To acquire and free the resource in an arbitrary monad with
--   <a>MonadUnliftIO</a>, do the following:
--   
--   <pre>
--   acquire &lt;- withRunInIO $ \runInIO -&gt;
--     return $ mkAcquireType (runInIO create) (\a -&gt; runInIO . free a)
--   </pre>
--   
--   Note that this is only safe if the Acquire is run and freed within the
--   same monadic scope it was created in.
mkAcquireType :: IO a -> (a -> ReleaseType -> IO ()) -> Acquire a

-- | Allocate a resource and register an action with the
--   <tt>MonadResource</tt> to free the resource.
allocateAcquire :: MonadResource m => Acquire a -> m (ReleaseKey, a)

-- | Longer name for <a>with</a>, in case <tt>with</tt> is not obvious
--   enough in context.
withAcquire :: MonadUnliftIO m => Acquire a -> (a -> m b) -> m b

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
