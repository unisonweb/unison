-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Text lines and ropes
--   
--   A wrapper around <a>Text</a> for fast line/column navigation and
--   logarithmic concatenation.
@package text-rope
@version 0.2


module Data.Text.Lines

-- | A wrapper around <a>Text</a> for fast line/column navigation.
--   Concatenation takes linear time.
--   
--   This is a building block for <a>Rope</a>, which provides logarithmic
--   concatenation.
data TextLines

-- | Create from <a>Text</a>, linear time.
fromText :: () => Text -> TextLines

-- | Extract <a>Text</a>, O(1).
toText :: TextLines -> Text

-- | Check whether a text is empty, O(1).
null :: TextLines -> Bool

-- | Split into lines by <tt>\n</tt>, similar to
--   <tt>Data.Text.</tt><a>lines</a>. Each line is produced in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lines ""
--   []
--   
--   &gt;&gt;&gt; lines "foo"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n\n"
--   ["foo",""]
--   
--   &gt;&gt;&gt; lines "foo\nbar"
--   ["foo","bar"]
--   </pre>
lines :: TextLines -> [Text]

-- | Equivalent to <a>length</a> . <a>lines</a>, but in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthInLines ""
--   0
--   
--   &gt;&gt;&gt; lengthInLines "foo"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n\n"
--   2
--   
--   &gt;&gt;&gt; lengthInLines "foo\nbar"
--   2
--   </pre>
lengthInLines :: TextLines -> Word

-- | Split at given line, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\l -&gt; splitAtLine l "foo\nbar") [0..3]
--   [("","foo\nbar"),("foo\n","bar"),("foo\nbar",""),("foo\nbar","")]
--   </pre>
splitAtLine :: () => Word -> TextLines -> (TextLines, TextLines)

-- | Length in code points, similar to <tt>Data.Text.</tt><a>length</a>.
--   Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; length "fÑğ€€"
--   3
--   
--   &gt;&gt;&gt; Data.Text.Utf16.Lines.length "fÑğ€€"
--   4
--   </pre>
length :: TextLines -> Word

-- | Span by a predicate, similar to <tt>Data.Text.</tt><a>span</a>. Takes
--   linear (by length of the prefix satisfying the predicate) time.
span :: () => (Char -> Bool) -> TextLines -> (TextLines, TextLines)

-- | Split at given code point, similar to
--   <tt>Data.Text.</tt><a>splitAt</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; splitAt c "fÑğ€€") [0..4]
--   [("","fÑğ€€"),("f","Ñğ€€"),("fÑ","ğ€€"),("fÑğ€€",""),("fÑğ€€","")]
--   </pre>
splitAt :: () => Word -> TextLines -> (TextLines, TextLines)

-- | Represent a position in a text.
data Position
Position :: !Word -> !Word -> Position

-- | Line.
[posLine] :: Position -> !Word

-- | Column in code points.
[posColumn] :: Position -> !Word

-- | Measure text length as an amount of lines and columns. Time is
--   proportional to the length of the last line.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 2}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 1}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
lengthAsPosition :: TextLines -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>splitAt</a>. Time
--   is linear in <a>posColumn</a>, but does not depend on <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   </pre>
splitAtPosition :: () => Position -> TextLines -> (TextLines, TextLines)


module Data.Text.Rope

-- | Rope of <a>Text</a> chunks with logarithmic concatenation. This rope
--   offers an interface, based on code points. Use
--   <a>Data.Text.Utf16.Rope</a>, if you need UTF-16 code units, or
--   <a>Data.Text.Utf16.Rope.Mixed</a>, if you need both interfaces.
data Rope

-- | Create from <a>Text</a>, linear time.
fromText :: Text -> Rope

-- | Create from <a>TextLines</a>, linear time.
fromTextLines :: TextLines -> Rope

-- | Glue chunks into <a>Text</a>, linear time.
toText :: Rope -> Text

-- | Glue chunks into <a>TextLines</a>, linear time.
toTextLines :: Rope -> TextLines

-- | Check whether a rope is empty, O(1).
null :: Rope -> Bool

-- | Split into lines by <tt>\n</tt>, similar to
--   <tt>Data.Text.</tt><a>lines</a>. Each line is produced in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lines ""
--   []
--   
--   &gt;&gt;&gt; lines "foo"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n\n"
--   ["foo",""]
--   
--   &gt;&gt;&gt; lines "foo\nbar"
--   ["foo","bar"]
--   </pre>
lines :: Rope -> [Text]

-- | Equivalent to <a>length</a> . <a>lines</a>, but in logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthInLines ""
--   0
--   
--   &gt;&gt;&gt; lengthInLines "foo"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n\n"
--   2
--   
--   &gt;&gt;&gt; lengthInLines "foo\nbar"
--   2
--   </pre>
--   
--   If you do not care about ignoring the last newline character, you can
--   use <a>posLine</a> . <a>lengthAsPosition</a> instead, which works in
--   O(1).
lengthInLines :: Rope -> Word

-- | Split at given line, logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\l -&gt; splitAtLine l "foo\nbar") [0..3]
--   [("","foo\nbar"),("foo\n","bar"),("foo\nbar",""),("foo\nbar","")]
--   </pre>
splitAtLine :: () => Word -> Rope -> (Rope, Rope)

-- | Length in code points, similar to <tt>Data.Text.</tt><a>length</a>,
--   O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; length "fÑğ€€"
--   3
--   
--   &gt;&gt;&gt; Data.Text.Utf16.Rope.length "fÑğ€€"
--   4
--   </pre>
length :: Rope -> Word

-- | Split at given code point, similar to
--   <tt>Data.Text.</tt><a>splitAt</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; splitAt c "fÑğ€€") [0..4]
--   [("","fÑğ€€"),("f","Ñğ€€"),("fÑ","ğ€€"),("fÑğ€€",""),("fÑğ€€","")]
--   </pre>
splitAt :: () => Word -> Rope -> (Rope, Rope)

-- | Represent a position in a text.
data Position
Position :: !Word -> !Word -> Position

-- | Line.
[posLine] :: Position -> !Word

-- | Column in code points.
[posColumn] :: Position -> !Word

-- | Measure text length as an amount of lines and columns, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 2}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 1}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
lengthAsPosition :: Rope -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>splitAt</a>. Time
--   is linear in <a>posColumn</a> and logarithmic in <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   </pre>
splitAtPosition :: () => Position -> Rope -> (Rope, Rope)
instance GHC.Base.Semigroup Data.Text.Rope.Lines
instance GHC.Base.Monoid Data.Text.Rope.Lines
instance Control.DeepSeq.NFData Data.Text.Rope.Rope
instance GHC.Classes.Eq Data.Text.Rope.Rope
instance GHC.Classes.Ord Data.Text.Rope.Rope
instance GHC.Show.Show Data.Text.Rope.Rope
instance Data.String.IsString Data.Text.Rope.Rope
instance GHC.Base.Semigroup Data.Text.Rope.Rope
instance GHC.Base.Monoid Data.Text.Rope.Rope


module Data.Text.Utf16.Lines

-- | A wrapper around <a>Text</a> for fast line/column navigation.
--   Concatenation takes linear time.
--   
--   This is a building block for <a>Rope</a>, which provides logarithmic
--   concatenation.
data TextLines

-- | Create from <a>Text</a>, linear time.
fromText :: () => Text -> TextLines

-- | Extract <a>Text</a>, O(1).
toText :: TextLines -> Text

-- | Check whether a text is empty, O(1).
null :: TextLines -> Bool

-- | Split into lines by <tt>\n</tt>, similar to
--   <tt>Data.Text.</tt><a>lines</a>. Each line is produced in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lines ""
--   []
--   
--   &gt;&gt;&gt; lines "foo"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n\n"
--   ["foo",""]
--   
--   &gt;&gt;&gt; lines "foo\nbar"
--   ["foo","bar"]
--   </pre>
lines :: TextLines -> [Text]

-- | Equivalent to <a>length</a> . <a>lines</a>, but in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthInLines ""
--   0
--   
--   &gt;&gt;&gt; lengthInLines "foo"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n\n"
--   2
--   
--   &gt;&gt;&gt; lengthInLines "foo\nbar"
--   2
--   </pre>
lengthInLines :: TextLines -> Word

-- | Split at given line, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\l -&gt; splitAtLine l "foo\nbar") [0..3]
--   [("","foo\nbar"),("foo\n","bar"),("foo\nbar",""),("foo\nbar","")]
--   </pre>
splitAtLine :: () => Word -> TextLines -> (TextLines, TextLines)

-- | Length in UTF-16 code units. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; length "fÑğ€€"
--   4
--   
--   &gt;&gt;&gt; Data.Text.Lines.length "fÑğ€€"
--   3
--   </pre>
length :: TextLines -> Word

-- | Split at given UTF-16 code unit. If requested number of code units
--   splits a code point in half, return <a>Nothing</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; splitAt c "fÑğ€€") [0..4]
--   [Just ("","fÑğ€€"),Just ("f","Ñğ€€"),Just ("fÑ","ğ€€"),Nothing,Just ("fÑğ€€","")]
--   </pre>
splitAt :: () => Word -> TextLines -> Maybe (TextLines, TextLines)

-- | Represent a position in a text.
data Position
Position :: !Word -> !Word -> Position

-- | Line.
[posLine] :: Position -> !Word

-- | Column in UTF-16 code units.
[posColumn] :: Position -> !Word

-- | Measure text length as an amount of lines and columns. Time is
--   proportional to the length of the last line.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 3}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 2}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
lengthAsPosition :: TextLines -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>splitAt</a>. If
--   requested number of code units splits a code point in half, return
--   <a>Nothing</a>. Time is linear in <a>posColumn</a>, but does not
--   depend on <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   </pre>
splitAtPosition :: () => Position -> TextLines -> Maybe (TextLines, TextLines)
instance GHC.Show.Show Data.Text.Utf16.Lines.Position
instance GHC.Classes.Ord Data.Text.Utf16.Lines.Position
instance GHC.Classes.Eq Data.Text.Utf16.Lines.Position
instance Control.DeepSeq.NFData Data.Text.Utf16.Lines.Position
instance GHC.Base.Semigroup Data.Text.Utf16.Lines.Position
instance GHC.Base.Monoid Data.Text.Utf16.Lines.Position


module Data.Text.Utf16.Rope

-- | Rope of <a>Text</a> chunks with logarithmic concatenation. This rope
--   offers an interface, based on UTF-16 code units. Use
--   <a>Data.Text.Rope</a>, if you need code points, or
--   <a>Data.Text.Utf16.Rope.Mixed</a>, if you need both interfaces.
data Rope

-- | Create from <a>Text</a>, linear time.
fromText :: Text -> Rope

-- | Create from <a>TextLines</a>, linear time.
fromTextLines :: TextLines -> Rope

-- | Glue chunks into <a>Text</a>, linear time.
toText :: Rope -> Text

-- | Glue chunks into <a>TextLines</a>, linear time.
toTextLines :: Rope -> TextLines

-- | Check whether a rope is empty, O(1).
null :: Rope -> Bool

-- | Split into lines by <tt>\n</tt>, similar to
--   <tt>Data.Text.</tt><a>lines</a>. Each line is produced in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lines ""
--   []
--   
--   &gt;&gt;&gt; lines "foo"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n\n"
--   ["foo",""]
--   
--   &gt;&gt;&gt; lines "foo\nbar"
--   ["foo","bar"]
--   </pre>
lines :: Rope -> [Text]

-- | Equivalent to <a>length</a> . <a>lines</a>, but in logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthInLines ""
--   0
--   
--   &gt;&gt;&gt; lengthInLines "foo"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n\n"
--   2
--   
--   &gt;&gt;&gt; lengthInLines "foo\nbar"
--   2
--   </pre>
--   
--   If you do not care about ignoring the last newline character, you can
--   use <a>posLine</a> . <a>lengthAsPosition</a> instead, which works in
--   O(1).
lengthInLines :: Rope -> Word

-- | Split at given line, logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\l -&gt; splitAtLine l "foo\nbar") [0..3]
--   [("","foo\nbar"),("foo\n","bar"),("foo\nbar",""),("foo\nbar","")]
--   </pre>
splitAtLine :: () => Word -> Rope -> (Rope, Rope)

-- | Length in UTF-16 code units, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; length "fÑğ€€"
--   4
--   
--   &gt;&gt;&gt; Data.Text.Rope.length "fÑğ€€"
--   3
--   </pre>
length :: Rope -> Word

-- | Split at given UTF-16 code unit. If requested number of code units
--   splits a code point in half, return <a>Nothing</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; splitAt c "fÑğ€€") [0..4]
--   [Just ("","fÑğ€€"),Just ("f","Ñğ€€"),Just ("fÑ","ğ€€"),Nothing,Just ("fÑğ€€","")]
--   </pre>
splitAt :: () => Word -> Rope -> Maybe (Rope, Rope)

-- | Represent a position in a text.
data Position
Position :: !Word -> !Word -> Position

-- | Line.
[posLine] :: Position -> !Word

-- | Column in UTF-16 code units.
[posColumn] :: Position -> !Word

-- | Measure text length as an amount of lines and columns, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 3}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 2}
--   
--   &gt;&gt;&gt; lengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
lengthAsPosition :: Rope -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>splitAt</a>. Time
--   is linear in <a>posColumn</a> and logarithmic in <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; splitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; splitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   </pre>
splitAtPosition :: () => Position -> Rope -> Maybe (Rope, Rope)
instance GHC.Base.Semigroup Data.Text.Utf16.Rope.Lines
instance GHC.Base.Monoid Data.Text.Utf16.Rope.Lines
instance Control.DeepSeq.NFData Data.Text.Utf16.Rope.Rope
instance GHC.Classes.Eq Data.Text.Utf16.Rope.Rope
instance GHC.Classes.Ord Data.Text.Utf16.Rope.Rope
instance GHC.Show.Show Data.Text.Utf16.Rope.Rope
instance Data.String.IsString Data.Text.Utf16.Rope.Rope
instance GHC.Base.Semigroup Data.Text.Utf16.Rope.Rope
instance GHC.Base.Monoid Data.Text.Utf16.Rope.Rope


module Data.Text.Utf16.Rope.Mixed

-- | Rope of <a>Text</a> chunks with logarithmic concatenation. This rope
--   offers two interfaces: one based on code points and another one based
--   on UTF-16 code units. This comes with a price of double bookkeeping
--   and is less performant than <a>Data.Text.Rope</a> or
--   <a>Data.Text.Utf16.Rope</a>.
data Rope

-- | Create from <a>Text</a>, linear time.
fromText :: Text -> Rope

-- | Create from <a>TextLines</a>, linear time.
fromTextLines :: TextLines -> Rope

-- | Glue chunks into <a>Text</a>, linear time.
toText :: Rope -> Text

-- | Glue chunks into <a>TextLines</a>, linear time.
toTextLines :: Rope -> TextLines

-- | Check whether a rope is empty, O(1).
null :: Rope -> Bool

-- | Split into lines by <tt>\n</tt>, similar to
--   <tt>Data.Text.</tt><a>lines</a>. Each line is produced in O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lines ""
--   []
--   
--   &gt;&gt;&gt; lines "foo"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n"
--   ["foo"]
--   
--   &gt;&gt;&gt; lines "foo\n\n"
--   ["foo",""]
--   
--   &gt;&gt;&gt; lines "foo\nbar"
--   ["foo","bar"]
--   </pre>
lines :: Rope -> [Text]

-- | Equivalent to <a>length</a> . <a>lines</a>, but in logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; lengthInLines ""
--   0
--   
--   &gt;&gt;&gt; lengthInLines "foo"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n"
--   1
--   
--   &gt;&gt;&gt; lengthInLines "foo\n\n"
--   2
--   
--   &gt;&gt;&gt; lengthInLines "foo\nbar"
--   2
--   </pre>
--   
--   If you do not care about ignoring the last newline character, you can
--   use <a>posLine</a> . <a>charLengthAsPosition</a> instead, which works
--   in O(1).
lengthInLines :: Rope -> Word

-- | Split at given line, logarithmic time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\l -&gt; splitAtLine l "foo\nbar") [0..3]
--   [("","foo\nbar"),("foo\n","bar"),("foo\nbar",""),("foo\nbar","")]
--   </pre>
splitAtLine :: () => Word -> Rope -> (Rope, Rope)

-- | Length in code points, similar to <tt>Data.Text.</tt><a>length</a>,
--   O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; charLength "fÑğ€€"
--   3
--   </pre>
charLength :: Rope -> Word

-- | Split at given code point, similar to
--   <tt>Data.Text.</tt><a>splitAt</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; charSplitAt c "fÑğ€€") [0..4]
--   [("","fÑğ€€"),("f","Ñğ€€"),("fÑ","ğ€€"),("fÑğ€€",""),("fÑğ€€","")]
--   </pre>
charSplitAt :: () => Word -> Rope -> (Rope, Rope)

-- | Measure text length as an amount of lines and columns, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; charLengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 2}
--   
--   &gt;&gt;&gt; charLengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 1}
--   
--   &gt;&gt;&gt; charLengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
charLengthAsPosition :: Rope -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>charSplitAt</a>.
--   Time is linear in <a>posColumn</a> and logarithmic in <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; charSplitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   ("f\nğ€€Ñ","")
--   </pre>
charSplitAtPosition :: () => Position -> Rope -> (Rope, Rope)

-- | Length in UTF-16 code units, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; utf16Length "fÑğ€€"
--   4
--   </pre>
utf16Length :: Rope -> Word

-- | Split at given UTF-16 code unit. If requested number of code units
--   splits a code point in half, return <a>Nothing</a>. Takes linear time.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; map (\c -&gt; utf16SplitAt c "fÑğ€€") [0..4]
--   [Just ("","fÑğ€€"),Just ("f","Ñğ€€"),Just ("fÑ","ğ€€"),Nothing,Just ("fÑğ€€","")]
--   </pre>
utf16SplitAt :: () => Word -> Rope -> Maybe (Rope, Rope)

-- | Measure text length as an amount of lines and columns, O(1).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; utf16LengthAsPosition "fğ€€"
--   Position {posLine = 0, posColumn = 3}
--   
--   &gt;&gt;&gt; utf16LengthAsPosition "f\nğ€€"
--   Position {posLine = 1, posColumn = 2}
--   
--   &gt;&gt;&gt; utf16LengthAsPosition "f\nğ€€\n"
--   Position {posLine = 2, posColumn = 0}
--   </pre>
utf16LengthAsPosition :: Rope -> Position

-- | Combination of <a>splitAtLine</a> and subsequent <a>utf16SplitAt</a>.
--   Time is linear in <a>posColumn</a> and logarithmic in <a>posLine</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 1 0) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 1 1) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 1 2) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 0 2) "f\nğ€€Ñ"
--   Just ("f\n","ğ€€Ñ")
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 0 3) "f\nğ€€Ñ"
--   Nothing
--   
--   &gt;&gt;&gt; utf16SplitAtPosition (Position 0 4) "f\nğ€€Ñ"
--   Just ("f\nğ€€","Ñ")
--   </pre>
utf16SplitAtPosition :: () => Position -> Rope -> Maybe (Rope, Rope)
instance GHC.Base.Semigroup Data.Text.Utf16.Rope.Mixed.Lines
instance GHC.Base.Monoid Data.Text.Utf16.Rope.Mixed.Lines
instance Control.DeepSeq.NFData Data.Text.Utf16.Rope.Mixed.Rope
instance GHC.Classes.Eq Data.Text.Utf16.Rope.Mixed.Rope
instance GHC.Classes.Ord Data.Text.Utf16.Rope.Mixed.Rope
instance GHC.Show.Show Data.Text.Utf16.Rope.Mixed.Rope
instance Data.String.IsString Data.Text.Utf16.Rope.Mixed.Rope
instance GHC.Base.Semigroup Data.Text.Utf16.Rope.Mixed.Rope
instance GHC.Base.Monoid Data.Text.Utf16.Rope.Mixed.Rope
