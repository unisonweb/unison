-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell98 invariant functors
--   
--   Haskell98 invariant functors (also known as exponential functors).
--   
--   For more information, see Edward Kmett's article "Rotten Bananas":
--   
--   <a>http://comonad.com/reader/2008/rotten-bananas/</a>
@package invariant
@version 0.6.3


-- | Haskell98 invariant functors (also known as exponential functors).
--   
--   For more information, see Edward Kmett's article "Rotten Bananas":
--   
--   <a>http://comonad.com/reader/2008/rotten-bananas/</a>
module Data.Functor.Invariant

-- | Any <tt>* -&gt; *</tt> type parametric in the argument permits an
--   instance of <tt>Invariant</tt>.
--   
--   Instances should satisfy the following laws:
--   
--   <pre>
--   invmap id id = id
--   invmap f2 f2' . invmap f1 f1' = invmap (f2 . f1) (f1' . f2')
--   </pre>
class Invariant f
invmap :: Invariant f => (a -> b) -> (b -> a) -> f a -> f b
invmap :: (Invariant f, Generic1 f, Invariant (Rep1 f)) => (a -> b) -> (b -> a) -> f a -> f b

-- | Every <a>Functor</a> is also an <a>Invariant</a> functor.
invmapFunctor :: Functor f => (a -> b) -> (b -> a) -> f a -> f b

-- | A generic implementation of <a>invmap</a>.
genericInvmap :: (Generic1 f, Invariant (Rep1 f)) => (a -> b) -> (b -> a) -> f a -> f b

-- | Wrap a <a>Functor</a> to be used as a member of <a>Invariant</a>.
newtype WrappedFunctor f a
WrapFunctor :: f a -> WrappedFunctor f a
[unwrapFunctor] :: WrappedFunctor f a -> f a

-- | Every <a>Contravariant</a> functor is also an <a>Invariant</a>
--   functor.
invmapContravariant :: Contravariant f => (a -> b) -> (b -> a) -> f a -> f b

-- | A <a>Profunctor</a> with the same input and output types can be seen
--   as an <a>Invariant</a> functor.
invmapProfunctor :: Profunctor p => (a -> b) -> (b -> a) -> p a a -> p b b

-- | An <a>Arrow</a> with the same input and output types can be seen as an
--   <a>Invariant</a> functor.
invmapArrow :: Arrow arr => (a -> b) -> (b -> a) -> arr a a -> arr b b

-- | Wrap a <a>Contravariant</a> functor to be used as a member of
--   <a>Invariant</a>.
newtype WrappedContravariant f a
WrapContravariant :: f a -> WrappedContravariant f a
[unwrapContravariant] :: WrappedContravariant f a -> f a

-- | A <a>Profunctor</a> with the same input and output types can be seen
--   as an <a>Invariant</a> functor.
newtype InvariantProfunctor p a
InvariantProfunctor :: p a a -> InvariantProfunctor p a

-- | An <a>Arrow</a> with the same input and output types can be seen as an
--   <a>Invariant</a> functor.
newtype InvariantArrow c a
InvariantArrow :: c a a -> InvariantArrow c a

-- | Any <tt>* -&gt; * -&gt; *</tt> type parametric in both arguments
--   permits an instance of <tt>Invariant2</tt>.
--   
--   Instances should satisfy the following laws:
--   
--   <pre>
--   invmap2 id id id id = id
--   invmap2 f2 f2' g2 g2' . invmap2 f1 f1' g1 g1' =
--     invmap2 (f2 . f1) (f1' . f2') (g2 . g1) (g1' . g2')
--   </pre>
class Invariant2 f
invmap2 :: Invariant2 f => (a -> c) -> (c -> a) -> (b -> d) -> (d -> b) -> f a b -> f c d

-- | Every <a>Bifunctor</a> is also an <a>Invariant2</a> functor.
invmap2Bifunctor :: Bifunctor f => (a -> c) -> (c -> a) -> (b -> d) -> (d -> b) -> f a b -> f c d

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype () => WrappedBifunctor (p :: k -> k1 -> Type) (a :: k) (b :: k1)
WrapBifunctor :: p a b -> WrappedBifunctor (p :: k -> k1 -> Type) (a :: k) (b :: k1)
[unwrapBifunctor] :: WrappedBifunctor (p :: k -> k1 -> Type) (a :: k) (b :: k1) -> p a b

-- | Every <a>Profunctor</a> is also an <a>Invariant2</a> functor.
invmap2Profunctor :: Profunctor f => (a -> c) -> (c -> a) -> (b -> d) -> (d -> b) -> f a b -> f c d

-- | Wrap a <a>Profunctor</a> to be used as a member of <a>Invariant2</a>.
newtype WrappedProfunctor p a b
WrapProfunctor :: p a b -> WrappedProfunctor p a b
[unwrapProfunctor] :: WrappedProfunctor p a b -> p a b
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Invariant.WrappedFunctor f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Functor.Invariant.WrappedFunctor f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Invariant.WrappedFunctor f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Invariant.WrappedFunctor f a)
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Functor.Invariant.WrappedContravariant f a)
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Functor.Invariant.WrappedContravariant f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Functor.Invariant.WrappedContravariant f a)
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Functor.Invariant.WrappedContravariant f a)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Show.Show (p a b) => GHC.Show.Show (Data.Functor.Invariant.WrappedProfunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Read.Read (p a b) => GHC.Read.Read (Data.Functor.Invariant.WrappedProfunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Classes.Ord (p a b) => GHC.Classes.Ord (Data.Functor.Invariant.WrappedProfunctor p a b)
instance forall k1 k2 (p :: k1 -> k2 -> *) (a :: k1) (b :: k2). GHC.Classes.Eq (p a b) => GHC.Classes.Eq (Data.Functor.Invariant.WrappedProfunctor p a b)
instance Control.Arrow.Arrow c => Data.Functor.Invariant.Invariant (Data.Functor.Invariant.InvariantArrow c)
instance Data.Profunctor.Unsafe.Profunctor p => Data.Functor.Invariant.Invariant (Data.Functor.Invariant.InvariantProfunctor p)
instance Data.Profunctor.Unsafe.Profunctor p => Data.Functor.Invariant.Invariant2 (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Unsafe.Profunctor p => Data.Functor.Invariant.Invariant (Data.Functor.Invariant.WrappedProfunctor p a)
instance Data.Profunctor.Unsafe.Profunctor p => Data.Profunctor.Unsafe.Profunctor (Data.Functor.Invariant.WrappedProfunctor p)
instance forall k (p :: k -> k -> *). Control.Category.Category p => Control.Category.Category (Data.Functor.Invariant.WrappedProfunctor p)
instance Control.Arrow.Arrow p => Control.Arrow.Arrow (Data.Functor.Invariant.WrappedProfunctor p)
instance Control.Arrow.ArrowZero p => Control.Arrow.ArrowZero (Data.Functor.Invariant.WrappedProfunctor p)
instance Control.Arrow.ArrowPlus p => Control.Arrow.ArrowPlus (Data.Functor.Invariant.WrappedProfunctor p)
instance Control.Arrow.ArrowChoice p => Control.Arrow.ArrowChoice (Data.Functor.Invariant.WrappedProfunctor p)
instance Control.Arrow.ArrowLoop p => Control.Arrow.ArrowLoop (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Strong.Strong p => Data.Profunctor.Strong.Strong (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Choice.Choice p => Data.Profunctor.Choice.Choice (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Strong.Costrong p => Data.Profunctor.Strong.Costrong (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Choice.Cochoice p => Data.Profunctor.Choice.Cochoice (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Closed.Closed p => Data.Profunctor.Closed.Closed (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Traversing.Traversing p => Data.Profunctor.Traversing.Traversing (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Mapping.Mapping p => Data.Profunctor.Mapping.Mapping (Data.Functor.Invariant.WrappedProfunctor p)
instance Data.Profunctor.Monad.ProfunctorFunctor Data.Functor.Invariant.WrappedProfunctor
instance Data.Profunctor.Monad.ProfunctorMonad Data.Functor.Invariant.WrappedProfunctor
instance Data.Profunctor.Monad.ProfunctorComonad Data.Functor.Invariant.WrappedProfunctor
instance forall k2 (p :: * -> * -> *) (g :: * -> *) (f :: k2 -> *) (a :: k2). (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Bifunctor.Biff.Biff p f g a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Bifunctor.Fix.Fix p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Bifunctor.Flip.Flip p a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Bifunctor.Join.Join p)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant2 p) => Data.Functor.Invariant.Invariant (Data.Bifunctor.Tannen.Tannen f p a)
instance Data.Bifunctor.Bifunctor p => Data.Functor.Invariant.Invariant (Data.Bifunctor.Wrapped.WrappedBifunctor p a)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Data.Profunctor.Types.Star f a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Closed.Closure p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Closed.Environment p a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Ran.Codensity p a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Rep.Coprep p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Rep.Prep p)
instance forall k2 (p :: * -> * -> *) (q :: k2 -> * -> *) (a :: k2). Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Composition.Procompose p q a)
instance forall k2 (p :: * -> * -> *) (q :: k2 -> * -> *) (a :: k2). Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Composition.Rift p q a)
instance forall k1 (q :: * -> * -> *) (p :: * -> k1 -> *) (a :: k1). Data.Functor.Invariant.Invariant2 q => Data.Functor.Invariant.Invariant (Data.Profunctor.Ran.Ran p q a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Strong.Tambara p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Choice.PastroSum p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Mapping.FreeMapping p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Traversing.FreeTraversing p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Strong.Pastro p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Strong.Copastro p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Choice.CopastroSum p a)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant (Data.Profunctor.Choice.TambaraSum p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Yoneda.Coyoneda p a)
instance Data.Functor.Invariant.Invariant2 (->)
instance Data.Functor.Invariant.Invariant2 Data.Either.Either
instance Data.Functor.Invariant.Invariant2 (,)
instance Data.Functor.Invariant.Invariant2 ((,,) a)
instance Data.Functor.Invariant.Invariant2 ((,,,) a b)
instance Data.Functor.Invariant.Invariant2 ((,,,,) a b c)
instance Data.Functor.Invariant.Invariant2 Data.Functor.Const.Const
instance Control.Arrow.Arrow arr => Data.Functor.Invariant.Invariant2 (Control.Applicative.WrappedArrow arr)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant2 (Control.Arrow.Kleisli m)
instance Data.Functor.Invariant.Invariant2 Data.Semigroup.Arg
instance (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Biff.Biff p f g)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Clown.Clown f)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Flip.Flip p)
instance Data.Functor.Invariant.Invariant g => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Joker.Joker g)
instance (Data.Functor.Invariant.Invariant2 f, Data.Functor.Invariant.Invariant2 g) => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Product.Product f g)
instance (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant2 q) => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Sum.Sum p q)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant2 p) => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Tannen.Tannen f p)
instance Data.Bifunctor.Bifunctor p => Data.Functor.Invariant.Invariant2 (Data.Bifunctor.Wrapped.WrappedBifunctor p)
instance Data.Functor.Invariant.Invariant w => Data.Functor.Invariant.Invariant2 (Control.Comonad.Cokleisli w)
instance Data.Functor.Invariant.Invariant2 Data.Functor.Contravariant.Op
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Types.Star f)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Types.Costar f)
instance Control.Arrow.Arrow arr => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Types.WrappedArrow arr)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Types.Forget r)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant2 p) => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Cayley.Cayley f p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Closed.Closure p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Closed.Environment p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Ran.Codensity p)
instance (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant2 q) => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Composition.Procompose p q)
instance (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant2 q) => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Composition.Rift p q)
instance (Data.Functor.Invariant.Invariant2 p, Data.Functor.Invariant.Invariant2 q) => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Ran.Ran p q)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Strong.Tambara p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Choice.PastroSum p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Mapping.CofreeMapping p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Mapping.FreeMapping p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Traversing.CofreeTraversing p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Traversing.FreeTraversing p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Strong.Pastro p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Strong.Cotambara p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Strong.Copastro p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Choice.CopastroSum p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Choice.CotambaraSum p)
instance Data.Functor.Invariant.Invariant2 p => Data.Functor.Invariant.Invariant2 (Data.Profunctor.Choice.TambaraSum p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Yoneda.Yoneda p)
instance Data.Functor.Invariant.Invariant2 (Data.Profunctor.Yoneda.Coyoneda p)
instance Data.Functor.Invariant.Invariant2 Data.Tagged.Tagged
instance Data.Functor.Invariant.Invariant2 Data.Functor.Constant.Constant
instance Data.Functor.Invariant.Invariant2 (GHC.Generics.K1 i)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Invariant.Invariant (Data.Functor.Invariant.WrappedContravariant f)
instance Data.Functor.Contravariant.Contravariant f => Data.Functor.Contravariant.Contravariant (Data.Functor.Invariant.WrappedContravariant f)
instance Data.Functor.Contravariant.Divisible.Divisible f => Data.Functor.Contravariant.Divisible.Divisible (Data.Functor.Invariant.WrappedContravariant f)
instance Data.Functor.Contravariant.Divisible.Decidable f => Data.Functor.Contravariant.Divisible.Decidable (Data.Functor.Invariant.WrappedContravariant f)
instance GHC.Base.Functor f => Data.Functor.Invariant.Invariant (Data.Functor.Invariant.WrappedFunctor f)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Invariant.WrappedFunctor f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Data.Functor.Invariant.WrappedFunctor f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Data.Functor.Invariant.WrappedFunctor f)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Functor.Invariant.WrappedFunctor m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Functor.Invariant.WrappedFunctor m)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Functor.Invariant.WrappedFunctor f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Functor.Invariant.WrappedFunctor f)
instance Data.Functor.Invariant.Invariant GHC.Maybe.Maybe
instance Data.Functor.Invariant.Invariant []
instance Data.Functor.Invariant.Invariant GHC.Types.IO
instance Data.Functor.Invariant.Invariant (GHC.ST.ST s)
instance Data.Functor.Invariant.Invariant (Control.Monad.ST.Lazy.Imp.ST s)
instance Data.Functor.Invariant.Invariant Text.ParserCombinators.ReadP.ReadP
instance Data.Functor.Invariant.Invariant Text.ParserCombinators.ReadPrec.ReadPrec
instance Data.Functor.Invariant.Invariant ((->) a)
instance Data.Functor.Invariant.Invariant (Data.Either.Either a)
instance Data.Functor.Invariant.Invariant ((,) a)
instance Data.Functor.Invariant.Invariant ((,,) a b)
instance Data.Functor.Invariant.Invariant ((,,,) a b c)
instance Data.Functor.Invariant.Invariant ((,,,,) a b c d)
instance Data.Functor.Invariant.Invariant (Data.Functor.Const.Const a)
instance Data.Functor.Invariant.Invariant Control.Applicative.ZipList
instance GHC.Base.Monad m => Data.Functor.Invariant.Invariant (Control.Applicative.WrappedMonad m)
instance Control.Arrow.Arrow arr => Data.Functor.Invariant.Invariant (Control.Applicative.WrappedArrow arr a)
instance Control.Arrow.Arrow a => Data.Functor.Invariant.Invariant (Control.Arrow.ArrowMonad a)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Arrow.Kleisli m a)
instance Data.Functor.Invariant.Invariant Control.Exception.Handler
instance Data.Functor.Invariant.Invariant Data.Complex.Complex
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Compose.Compose f g)
instance Data.Functor.Invariant.Invariant Data.Functor.Identity.Identity
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Product.Product f g)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Sum.Sum f g)
instance Data.Functor.Invariant.Invariant GHC.Base.NonEmpty
instance Data.Functor.Invariant.Invariant Data.Semigroup.Internal.Dual
instance Data.Functor.Invariant.Invariant Data.Semigroup.Internal.Endo
instance Data.Functor.Invariant.Invariant Data.Monoid.First
instance Data.Functor.Invariant.Invariant Data.Monoid.Last
instance Data.Functor.Invariant.Invariant Data.Semigroup.Internal.Product
instance Data.Functor.Invariant.Invariant Data.Semigroup.Internal.Sum
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Data.Semigroup.Internal.Alt f)
instance Data.Functor.Invariant.Invariant Data.Proxy.Proxy
instance Data.Functor.Invariant.Invariant Data.Semigroup.Min
instance Data.Functor.Invariant.Invariant Data.Semigroup.Max
instance Data.Functor.Invariant.Invariant Data.Semigroup.First
instance Data.Functor.Invariant.Invariant Data.Semigroup.Last
instance Data.Functor.Invariant.Invariant (Data.Semigroup.Arg a)
instance Data.Functor.Invariant.Invariant System.Console.GetOpt.ArgDescr
instance Data.Functor.Invariant.Invariant System.Console.GetOpt.ArgOrder
instance Data.Functor.Invariant.Invariant System.Console.GetOpt.OptDescr
instance Data.Functor.Invariant.Invariant (GHC.Arr.Array i)
instance forall k (f :: k -> *) (a :: k). Data.Functor.Invariant.Invariant (Data.Bifunctor.Clown.Clown f a)
instance forall k1 (g :: * -> *) (a :: k1). Data.Functor.Invariant.Invariant g => Data.Functor.Invariant.Invariant (Data.Bifunctor.Joker.Joker g a)
instance forall k (w :: k -> *) (a :: k). Data.Functor.Invariant.Invariant (Control.Comonad.Cokleisli w a)
instance Data.Functor.Invariant.Invariant Data.IntMap.Internal.IntMap
instance Data.Functor.Invariant.Invariant (Data.Map.Internal.Map k)
instance Data.Functor.Invariant.Invariant Data.Sequence.Internal.Seq
instance Data.Functor.Invariant.Invariant Data.Sequence.Internal.ViewL
instance Data.Functor.Invariant.Invariant Data.Sequence.Internal.ViewR
instance Data.Functor.Invariant.Invariant Data.Tree.Tree
instance Data.Functor.Invariant.Invariant Data.Functor.Contravariant.Predicate
instance Data.Functor.Invariant.Invariant Data.Functor.Contravariant.Comparison
instance Data.Functor.Invariant.Invariant Data.Functor.Contravariant.Equivalence
instance Data.Functor.Invariant.Invariant (Data.Functor.Contravariant.Op a)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Contravariant.Compose.Compose f g)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Contravariant.Compose.ComposeCF f g)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (Data.Functor.Contravariant.Compose.ComposeFC f g)
instance forall k (f :: k -> *) (a :: k). Data.Functor.Invariant.Invariant (Data.Profunctor.Types.Costar f a)
instance Control.Arrow.Arrow arr => Data.Functor.Invariant.Invariant (Data.Profunctor.Types.WrappedArrow arr a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Types.Forget r a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Strong.Cotambara p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Choice.CotambaraSum p a)
instance Data.Functor.Invariant.Invariant (Data.Profunctor.Yoneda.Yoneda p a)
instance Data.Functor.Invariant.Invariant Data.StateVar.StateVar
instance Data.Functor.Invariant.Invariant Data.StateVar.SettableStateVar
instance Data.Functor.Invariant.Invariant GHC.Conc.Sync.STM
instance forall k (s :: k). Data.Functor.Invariant.Invariant (Data.Tagged.Tagged s)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Control.Applicative.Lift.Lift f)
instance forall k (r :: k) (m :: k -> *). Data.Functor.Invariant.Invariant (Control.Monad.Trans.Cont.ContT r m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Functor.Invariant.Invariant m => Data.Functor.Invariant.Invariant (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Functor.Invariant.Invariant (Data.Functor.Constant.Constant a)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Invariant.Invariant (Data.HashMap.Internal.HashMap k)
instance Data.Functor.Invariant.Invariant GHC.Generics.V1
instance Data.Functor.Invariant.Invariant GHC.Generics.U1
instance (Data.Functor.Invariant.Invariant l, Data.Functor.Invariant.Invariant r) => Data.Functor.Invariant.Invariant (l GHC.Generics.:+: r)
instance (Data.Functor.Invariant.Invariant l, Data.Functor.Invariant.Invariant r) => Data.Functor.Invariant.Invariant (l GHC.Generics.:*: r)
instance Data.Functor.Invariant.Invariant (GHC.Generics.K1 i c)
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (GHC.Generics.M1 i t f)
instance Data.Functor.Invariant.Invariant GHC.Generics.Par1
instance Data.Functor.Invariant.Invariant f => Data.Functor.Invariant.Invariant (GHC.Generics.Rec1 f)
instance (Data.Functor.Invariant.Invariant f, Data.Functor.Invariant.Invariant g) => Data.Functor.Invariant.Invariant (f GHC.Generics.:.: g)
instance Data.Functor.Invariant.Invariant GHC.Generics.UAddr
instance Data.Functor.Invariant.Invariant GHC.Generics.UChar
instance Data.Functor.Invariant.Invariant GHC.Generics.UDouble
instance Data.Functor.Invariant.Invariant GHC.Generics.UFloat
instance Data.Functor.Invariant.Invariant GHC.Generics.UInt
instance Data.Functor.Invariant.Invariant GHC.Generics.UWord


-- | Functions to mechanically derive <a>Invariant</a> or <a>Invariant2</a>
--   instances, or to splice <a>invmap</a> or <a>invmap2</a> into Haskell
--   source code. You need to enable the <tt>TemplateHaskell</tt> language
--   extension in order to use this module.
module Data.Functor.Invariant.TH

-- | Generates an <a>Invariant</a> instance declaration for the given data
--   type or data family instance.
deriveInvariant :: Name -> Q [Dec]

-- | Like <a>deriveInvariant</a>, but takes an <a>Options</a> argument.
deriveInvariantOptions :: Options -> Name -> Q [Dec]

-- | Generates an <a>Invariant2</a> instance declaration for the given data
--   type or data family instance.
deriveInvariant2 :: Name -> Q [Dec]

-- | Like <a>deriveInvariant2</a>, but takes an <a>Options</a> argument.
deriveInvariant2Options :: Options -> Name -> Q [Dec]

-- | Generates a lambda expression which behaves like <a>invmap</a>
--   (without requiring an <a>Invariant</a> instance).
makeInvmap :: Name -> Q Exp

-- | Like <a>makeInvmap</a>, but takes an <a>Options</a> argument.
makeInvmapOptions :: Options -> Name -> Q Exp

-- | Generates a lambda expression which behaves like <a>invmap2</a>
--   (without requiring an <a>Invariant2</a> instance).
makeInvmap2 :: Name -> Q Exp

-- | Like <a>makeInvmap2</a>, but takes an <a>Options</a> argument.
makeInvmap2Options :: Options -> Name -> Q Exp

-- | Options that further configure how the functions in
--   <a>Data.Functor.Invariant.TH</a> should behave.
newtype Options
Options :: Bool -> Options

-- | If <a>True</a>, derived instances for empty data types (i.e., ones
--   with no data constructors) will use the <tt>EmptyCase</tt> language
--   extension. If <a>False</a>, derived instances will simply use
--   <a>seq</a> instead. (This has no effect on GHCs before 7.8, since
--   <tt>EmptyCase</tt> is only available in 7.8 or later.)
[emptyCaseBehavior] :: Options -> Bool

-- | Conservative <a>Options</a> that doesn't attempt to use
--   <tt>EmptyCase</tt> (to prevent users from having to enable that
--   extension at use sites.)
defaultOptions :: Options
instance GHC.Show.Show Data.Functor.Invariant.TH.Options
instance GHC.Read.Read Data.Functor.Invariant.TH.Options
instance GHC.Classes.Ord Data.Functor.Invariant.TH.Options
instance GHC.Classes.Eq Data.Functor.Invariant.TH.Options
