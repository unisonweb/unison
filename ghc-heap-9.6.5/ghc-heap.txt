-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for walking GHC's heap
--   
--   This package provides functions for walking the GHC heap data
--   structures and retrieving information about those data structures.
@package ghc-heap
@version 9.6.5

module GHC.Exts.Heap.ClosureTypes
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
CONTINUATION :: ClosureType
N_CLOSURE_TYPES :: ClosureType

-- | Return the size of the closures header in words
closureTypeHeaderSize :: ClosureType -> Int
instance GHC.Generics.Generic GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Show.Show GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Ord GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Classes.Eq GHC.Exts.Heap.ClosureTypes.ClosureType
instance GHC.Enum.Enum GHC.Exts.Heap.ClosureTypes.ClosureType

module GHC.Exts.Heap.Constants
wORD_SIZE :: Int
tAG_MASK :: Int
wORD_SIZE_IN_BITS :: Int

module GHC.Exts.Heap.InfoTable.Types

-- | This is a somewhat faithful representation of an info table. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]
instance GHC.Generics.Generic GHC.Exts.Heap.InfoTable.Types.StgInfoTable
instance GHC.Show.Show GHC.Exts.Heap.InfoTable.Types.StgInfoTable

module GHC.Exts.Heap.InfoTable

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.InfoTableProf
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

module GHC.Exts.Heap.ProfInfo.Types

-- | This is a somewhat faithful representation of StgTSOProfInfo. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/TSO.h</a>
--   for more details on this data structure.
newtype StgTSOProfInfo
StgTSOProfInfo :: Maybe CostCentreStack -> StgTSOProfInfo
[cccs] :: StgTSOProfInfo -> Maybe CostCentreStack

-- | This is a somewhat faithful representation of CostCentreStack. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentreStack
CostCentreStack :: Int -> CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Maybe CostCentreStack -> Word -> Word64 -> Word -> Word -> Word64 -> Word64 -> Word -> CostCentreStack
[ccs_ccsID] :: CostCentreStack -> Int
[ccs_cc] :: CostCentreStack -> CostCentre
[ccs_prevStack] :: CostCentreStack -> Maybe CostCentreStack
[ccs_indexTable] :: CostCentreStack -> Maybe IndexTable
[ccs_root] :: CostCentreStack -> Maybe CostCentreStack
[ccs_depth] :: CostCentreStack -> Word
[ccs_scc_count] :: CostCentreStack -> Word64
[ccs_selected] :: CostCentreStack -> Word
[ccs_time_ticks] :: CostCentreStack -> Word
[ccs_mem_alloc] :: CostCentreStack -> Word64
[ccs_inherited_alloc] :: CostCentreStack -> Word64
[ccs_inherited_ticks] :: CostCentreStack -> Word

-- | This is a somewhat faithful representation of CostCentre. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentre
CostCentre :: Int -> String -> String -> Maybe String -> Word64 -> Word -> Bool -> Maybe CostCentre -> CostCentre
[cc_ccID] :: CostCentre -> Int
[cc_label] :: CostCentre -> String
[cc_module] :: CostCentre -> String
[cc_srcloc] :: CostCentre -> Maybe String
[cc_mem_alloc] :: CostCentre -> Word64
[cc_time_ticks] :: CostCentre -> Word
[cc_is_caf] :: CostCentre -> Bool
[cc_link] :: CostCentre -> Maybe CostCentre

-- | This is a somewhat faithful representation of IndexTable. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data IndexTable
IndexTable :: CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Bool -> IndexTable
[it_cc] :: IndexTable -> CostCentre
[it_ccs] :: IndexTable -> Maybe CostCentreStack
[it_next] :: IndexTable -> Maybe IndexTable
[it_back_edge] :: IndexTable -> Bool
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Show.Show GHC.Exts.Heap.ProfInfo.Types.CostCentre
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Show.Show GHC.Exts.Heap.ProfInfo.Types.CostCentreStack
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Show.Show GHC.Exts.Heap.ProfInfo.Types.IndexTable
instance GHC.Classes.Ord GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Classes.Eq GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Generics.Generic GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo
instance GHC.Show.Show GHC.Exts.Heap.ProfInfo.Types.StgTSOProfInfo

module GHC.Exts.Heap.ProfInfo.PeekProfInfo_ProfilingEnabled
peekStgTSOProfInfo :: (Ptr b -> IO (Maybe CostCentreStack)) -> Ptr a -> IO (Maybe StgTSOProfInfo)
peekTopCCS :: Ptr b -> IO (Maybe CostCentreStack)

module GHC.Exts.Heap.ProfInfo.PeekProfInfo_ProfilingDisabled

-- | This implementation is used when PROFILING is undefined. It always
--   returns <a>Nothing</a>, because there is no profiling info available.
peekStgTSOProfInfo :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO (Maybe StgTSOProfInfo)
peekTopCCS :: Ptr a -> IO (Maybe CostCentreStack)

module GHC.Exts.Heap.ProfInfo.PeekProfInfo

module GHC.Exts.Heap.Closures
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by <tt>b</tt>: the type to store
--   references in. Usually this is a <a>Box</a> with the type synonym
--   <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | A <tt>SmallMutableArray#</tt>
SmallMutArrClosure :: !StgInfoTable -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | An <tt>IOPort#</tt>, with a queue of thread state objects blocking on
--   them
IOPortClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b
WeakClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !Maybe b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[cfinalizers] :: GenClosure b -> !b
[key] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b
[finalizer] :: GenClosure b -> !b

-- | next weak pointer for the capability
[weakLink] :: GenClosure b -> !Maybe b

-- | Representation of StgTSO: A Thread State Object. The values for
--   <a>what_next</a>, <a>why_blocked</a> and <a>flags</a> are defined in
--   <tt>Constants.h</tt>.
TSOClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !b -> !b -> !Maybe b -> !WhatNext -> !WhyBlocked -> ![TsoFlags] -> !Word64 -> !Word32 -> !Word32 -> !Int64 -> !Word32 -> !Maybe StgTSOProfInfo -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b
[global_link] :: GenClosure b -> !b

-- | stackobj from StgTSO
[tsoStack] :: GenClosure b -> !b
[trec] :: GenClosure b -> !b
[blocked_exceptions] :: GenClosure b -> !b
[bq] :: GenClosure b -> !b
[thread_label] :: GenClosure b -> !Maybe b
[what_next] :: GenClosure b -> !WhatNext
[why_blocked] :: GenClosure b -> !WhyBlocked
[flags] :: GenClosure b -> ![TsoFlags]
[threadId] :: GenClosure b -> !Word64
[saved_errno] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[tso_dirty] :: GenClosure b -> !Word32
[alloc_limit] :: GenClosure b -> !Int64
[tot_stack_size] :: GenClosure b -> !Word32
[prof] :: GenClosure b -> !Maybe StgTSOProfInfo

-- | Representation of StgStack: The 'tsoStack ' of a <a>TSOClosure</a>.
StackClosure :: !StgInfoTable -> !Word32 -> !Word8 -> !Word8 -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | stack size in *words*
[stack_size] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[stack_dirty] :: GenClosure b -> !Word8
[stack_marking] :: GenClosure b -> !Word8

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
data WhatNext
ThreadRunGHC :: WhatNext
ThreadInterpret :: WhatNext
ThreadKilled :: WhatNext
ThreadComplete :: WhatNext

-- | Please report this as a bug
WhatNextUnknownValue :: Word16 -> WhatNext
data WhyBlocked
NotBlocked :: WhyBlocked
BlockedOnMVar :: WhyBlocked
BlockedOnMVarRead :: WhyBlocked
BlockedOnBlackHole :: WhyBlocked
BlockedOnRead :: WhyBlocked
BlockedOnWrite :: WhyBlocked
BlockedOnDelay :: WhyBlocked
BlockedOnSTM :: WhyBlocked
BlockedOnDoProc :: WhyBlocked
BlockedOnCCall :: WhyBlocked
BlockedOnCCall_Interruptible :: WhyBlocked
BlockedOnMsgThrowTo :: WhyBlocked
ThreadMigrating :: WhyBlocked

-- | Please report this as a bug
WhyBlockedUnknownValue :: Word16 -> WhyBlocked
data TsoFlags
TsoLocked :: TsoFlags
TsoBlockx :: TsoFlags
TsoInterruptible :: TsoFlags
TsoStoppedOnBreakpoint :: TsoFlags
TsoMarked :: TsoFlags
TsoSqueezed :: TsoFlags
TsoAllocLimit :: TsoFlags

-- | Please report this as a bug
TsoFlagsUnknownValue :: Word32 -> TsoFlags

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | Get the size of the top-level closure in words. Includes header and
--   payload. Does not follow pointers.
closureSize :: Box -> Int

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.PrimType
instance GHC.Generics.Generic GHC.Exts.Heap.Closures.PrimType
instance GHC.Show.Show GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.PrimType
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.WhatNext
instance GHC.Generics.Generic GHC.Exts.Heap.Closures.WhatNext
instance GHC.Show.Show GHC.Exts.Heap.Closures.WhatNext
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.WhatNext
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Generics.Generic GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Show.Show GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.WhyBlocked
instance GHC.Classes.Ord GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Generics.Generic GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Show.Show GHC.Exts.Heap.Closures.TsoFlags
instance GHC.Classes.Eq GHC.Exts.Heap.Closures.TsoFlags
instance Data.Traversable.Traversable GHC.Exts.Heap.Closures.GenClosure
instance Data.Foldable.Foldable GHC.Exts.Heap.Closures.GenClosure
instance GHC.Base.Functor GHC.Exts.Heap.Closures.GenClosure
instance GHC.Generics.Generic (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Show.Show b => GHC.Show.Show (GHC.Exts.Heap.Closures.GenClosure b)
instance GHC.Show.Show GHC.Exts.Heap.Closures.Box

module GHC.Exts.Heap.FFIClosures_ProfilingEnabled
data TSOFields
TSOFields :: WhatNext -> WhyBlocked -> [TsoFlags] -> Word64 -> Word32 -> Word32 -> Int64 -> Word32 -> Maybe StgTSOProfInfo -> TSOFields
[tso_what_next] :: TSOFields -> WhatNext
[tso_why_blocked] :: TSOFields -> WhyBlocked
[tso_flags] :: TSOFields -> [TsoFlags]
[tso_threadId] :: TSOFields -> Word64
[tso_saved_errno] :: TSOFields -> Word32
[tso_dirty] :: TSOFields -> Word32
[tso_alloc_limit] :: TSOFields -> Int64
[tso_tot_stack_size] :: TSOFields -> Word32
[tso_prof] :: TSOFields -> Maybe StgTSOProfInfo

-- | Get non-pointer fields from <tt>StgTSO_</tt> (<tt>TSO.h</tt>)
peekTSOFields :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO TSOFields
parseWhatNext :: Word16 -> WhatNext
parseWhyBlocked :: Word16 -> WhyBlocked
parseTsoFlags :: Word32 -> [TsoFlags]
isSet :: Word32 -> Word32 -> Bool
unset :: Word32 -> Word32 -> Word32
data StackFields
StackFields :: Word32 -> Word8 -> Word8 -> Addr# -> StackFields
[stack_size] :: StackFields -> Word32
[stack_dirty] :: StackFields -> Word8
[stack_marking] :: StackFields -> Word8
[stack_sp] :: StackFields -> Addr#

-- | Get non-closure fields from <tt>StgStack_</tt> (<tt>TSO.h</tt>)
peekStackFields :: Ptr a -> IO StackFields

module GHC.Exts.Heap.FFIClosures_ProfilingDisabled
data TSOFields
TSOFields :: WhatNext -> WhyBlocked -> [TsoFlags] -> Word64 -> Word32 -> Word32 -> Int64 -> Word32 -> Maybe StgTSOProfInfo -> TSOFields
[tso_what_next] :: TSOFields -> WhatNext
[tso_why_blocked] :: TSOFields -> WhyBlocked
[tso_flags] :: TSOFields -> [TsoFlags]
[tso_threadId] :: TSOFields -> Word64
[tso_saved_errno] :: TSOFields -> Word32
[tso_dirty] :: TSOFields -> Word32
[tso_alloc_limit] :: TSOFields -> Int64
[tso_tot_stack_size] :: TSOFields -> Word32
[tso_prof] :: TSOFields -> Maybe StgTSOProfInfo

-- | Get non-pointer fields from <tt>StgTSO_</tt> (<tt>TSO.h</tt>)
peekTSOFields :: (Ptr a -> IO (Maybe CostCentreStack)) -> Ptr tsoPtr -> IO TSOFields
parseWhatNext :: Word16 -> WhatNext
parseWhyBlocked :: Word16 -> WhyBlocked
parseTsoFlags :: Word32 -> [TsoFlags]
isSet :: Word32 -> Word32 -> Bool
unset :: Word32 -> Word32 -> Word32
data StackFields
StackFields :: Word32 -> Word8 -> Word8 -> Addr# -> StackFields
[stack_size] :: StackFields -> Word32
[stack_dirty] :: StackFields -> Word8
[stack_marking] :: StackFields -> Word8
[stack_sp] :: StackFields -> Addr#

-- | Get non-closure fields from <tt>StgStack_</tt> (<tt>TSO.h</tt>)
peekStackFields :: Ptr a -> IO StackFields

module GHC.Exts.Heap.FFIClosures

module GHC.Exts.Heap.Utils
dataConNames :: Ptr StgInfoTable -> IO (String, String, String)


-- | With this module, you can investigate the heap representation of
--   Haskell values, i.e. to investigate sharing and lazy evaluation.
module GHC.Exts.Heap
type Closure = GenClosure Box

-- | This is the representation of a Haskell value on the heap. It reflects
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/Closures.h</a>
--   
--   The data type is parametrized by <tt>b</tt>: the type to store
--   references in. Usually this is a <a>Box</a> with the type synonym
--   <a>Closure</a>.
--   
--   All Heap objects have the same basic layout. A header containing a
--   pointer to the info table and a payload with various fields. The
--   <tt>info</tt> field below always refers to the info table pointed to
--   by the header. The remaining fields are the payload.
--   
--   See
--   <a>https://gitlab.haskell.org/ghc/ghc/wikis/commentary/rts/storage/heap-objects</a>
--   for more information.
data GenClosure b

-- | A data constructor
ConstrClosure :: !StgInfoTable -> ![b] -> ![Word] -> !String -> !String -> !String -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | Package name
[pkg] :: GenClosure b -> !String

-- | Module name
[modl] :: GenClosure b -> !String

-- | Constructor name
[name] :: GenClosure b -> !String

-- | A function
FunClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk, an expression not obviously in head normal form
ThunkClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer arguments
[ptrArgs] :: GenClosure b -> ![b]

-- | Non-pointer arguments
[dataArgs] :: GenClosure b -> ![Word]

-- | A thunk which performs a simple selection operation
SelectorClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to the object being selected from
[selectee] :: GenClosure b -> !b

-- | An unsaturated function application
PAPClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A function application
APClosure :: !StgInfoTable -> !HalfWord -> !HalfWord -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | Size of the payload in words
[n_args] :: GenClosure b -> !HalfWord

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A suspended thunk evaluation
APStackClosure :: !StgInfoTable -> !b -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to a <a>FunClosure</a>
[fun] :: GenClosure b -> !b

-- | Sequence of already applied arguments
[payload] :: GenClosure b -> ![b]

-- | A pointer to another closure, introduced when a thunk is updated to
--   point at its value
IndClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A byte-code object (BCO) which can be interpreted by GHC's byte-code
--   interpreter (e.g. as used by GHCi)
BCOClosure :: !StgInfoTable -> !b -> !b -> !b -> !HalfWord -> !HalfWord -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | A pointer to an ArrWords of instructions
[instrs] :: GenClosure b -> !b

-- | A pointer to an ArrWords of literals
[literals] :: GenClosure b -> !b

-- | A pointer to an ArrWords of byte code objects
[bcoptrs] :: GenClosure b -> !b

-- | Arity of the partial application
[arity] :: GenClosure b -> !HalfWord

-- | The size of this BCO in words
[size] :: GenClosure b -> !HalfWord

-- | An StgLargeBitmap describing the pointerhood of its args/free vars
[bitmap] :: GenClosure b -> ![Word]

-- | A thunk under evaluation by another thread
BlackholeClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Target closure
[indirectee] :: GenClosure b -> !b

-- | A <tt>ByteArray#</tt>
ArrWordsClosure :: !StgInfoTable -> !Word -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Size of array in bytes
[bytes] :: GenClosure b -> !Word

-- | Array payload
[arrWords] :: GenClosure b -> ![Word]

-- | A <tt>MutableByteArray#</tt>
MutArrClosure :: !StgInfoTable -> !Word -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | ?? Closures.h vs ClosureMacros.h
[mccSize] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | A <tt>SmallMutableArray#</tt>
SmallMutArrClosure :: !StgInfoTable -> !Word -> ![b] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Number of pointers
[mccPtrs] :: GenClosure b -> !Word

-- | Array payload Card table ignored
[mccPayload] :: GenClosure b -> ![b]

-- | An <tt>MVar#</tt>, with a queue of thread state objects blocking on
--   them
MVarClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | An <tt>IOPort#</tt>, with a queue of thread state objects blocking on
--   them
IOPortClosure :: !StgInfoTable -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to head of queue
[queueHead] :: GenClosure b -> !b

-- | Pointer to tail of queue
[queueTail] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b

-- | A <tt>MutVar#</tt>
MutVarClosure :: !StgInfoTable -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | Pointer to contents
[var] :: GenClosure b -> !b

-- | An STM blocking queue.
BlockingQueueClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b

-- | The blackhole closure
[blackHole] :: GenClosure b -> !b

-- | The owning thread state object
[owner] :: GenClosure b -> !b

-- | ??
[queue] :: GenClosure b -> !b
WeakClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !Maybe b -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[cfinalizers] :: GenClosure b -> !b
[key] :: GenClosure b -> !b

-- | Pointer to closure
[value] :: GenClosure b -> !b
[finalizer] :: GenClosure b -> !b

-- | next weak pointer for the capability
[weakLink] :: GenClosure b -> !Maybe b

-- | Representation of StgTSO: A Thread State Object. The values for
--   <a>what_next</a>, <a>why_blocked</a> and <a>flags</a> are defined in
--   <tt>Constants.h</tt>.
TSOClosure :: !StgInfoTable -> !b -> !b -> !b -> !b -> !b -> !b -> !Maybe b -> !WhatNext -> !WhyBlocked -> ![TsoFlags] -> !Word64 -> !Word32 -> !Word32 -> !Int64 -> !Word32 -> !Maybe StgTSOProfInfo -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | ?? Here so it looks like an IND
[link] :: GenClosure b -> !b
[global_link] :: GenClosure b -> !b

-- | stackobj from StgTSO
[tsoStack] :: GenClosure b -> !b
[trec] :: GenClosure b -> !b
[blocked_exceptions] :: GenClosure b -> !b
[bq] :: GenClosure b -> !b
[thread_label] :: GenClosure b -> !Maybe b
[what_next] :: GenClosure b -> !WhatNext
[why_blocked] :: GenClosure b -> !WhyBlocked
[flags] :: GenClosure b -> ![TsoFlags]
[threadId] :: GenClosure b -> !Word64
[saved_errno] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[tso_dirty] :: GenClosure b -> !Word32
[alloc_limit] :: GenClosure b -> !Int64
[tot_stack_size] :: GenClosure b -> !Word32
[prof] :: GenClosure b -> !Maybe StgTSOProfInfo

-- | Representation of StgStack: The 'tsoStack ' of a <a>TSOClosure</a>.
StackClosure :: !StgInfoTable -> !Word32 -> !Word8 -> !Word8 -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable

-- | stack size in *words*
[stack_size] :: GenClosure b -> !Word32

-- | non-zero =&gt; dirty
[stack_dirty] :: GenClosure b -> !Word8
[stack_marking] :: GenClosure b -> !Word8

-- | Primitive Int
IntClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[intVal] :: GenClosure b -> !Int

-- | Primitive Word
WordClosure :: PrimType -> !Word -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[wordVal] :: GenClosure b -> !Word

-- | Primitive Int64
Int64Closure :: PrimType -> !Int64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[int64Val] :: GenClosure b -> !Int64

-- | Primitive Word64
Word64Closure :: PrimType -> !Word64 -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[word64Val] :: GenClosure b -> !Word64

-- | Primitive Addr
AddrClosure :: PrimType -> !Int -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[addrVal] :: GenClosure b -> !Int

-- | Primitive Float
FloatClosure :: PrimType -> !Float -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[floatVal] :: GenClosure b -> !Float

-- | Primitive Double
DoubleClosure :: PrimType -> !Double -> GenClosure b
[ptipe] :: GenClosure b -> PrimType
[doubleVal] :: GenClosure b -> !Double

-- | Another kind of closure
OtherClosure :: !StgInfoTable -> ![b] -> ![Word] -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
[hvalues] :: GenClosure b -> ![b]
[rawWords] :: GenClosure b -> ![Word]
UnsupportedClosure :: !StgInfoTable -> GenClosure b
[info] :: GenClosure b -> !StgInfoTable
data ClosureType
INVALID_OBJECT :: ClosureType
CONSTR :: ClosureType
CONSTR_1_0 :: ClosureType
CONSTR_0_1 :: ClosureType
CONSTR_2_0 :: ClosureType
CONSTR_1_1 :: ClosureType
CONSTR_0_2 :: ClosureType
CONSTR_NOCAF :: ClosureType
FUN :: ClosureType
FUN_1_0 :: ClosureType
FUN_0_1 :: ClosureType
FUN_2_0 :: ClosureType
FUN_1_1 :: ClosureType
FUN_0_2 :: ClosureType
FUN_STATIC :: ClosureType
THUNK :: ClosureType
THUNK_1_0 :: ClosureType
THUNK_0_1 :: ClosureType
THUNK_2_0 :: ClosureType
THUNK_1_1 :: ClosureType
THUNK_0_2 :: ClosureType
THUNK_STATIC :: ClosureType
THUNK_SELECTOR :: ClosureType
BCO :: ClosureType
AP :: ClosureType
PAP :: ClosureType
AP_STACK :: ClosureType
IND :: ClosureType
IND_STATIC :: ClosureType
RET_BCO :: ClosureType
RET_SMALL :: ClosureType
RET_BIG :: ClosureType
RET_FUN :: ClosureType
UPDATE_FRAME :: ClosureType
CATCH_FRAME :: ClosureType
UNDERFLOW_FRAME :: ClosureType
STOP_FRAME :: ClosureType
BLOCKING_QUEUE :: ClosureType
BLACKHOLE :: ClosureType
MVAR_CLEAN :: ClosureType
MVAR_DIRTY :: ClosureType
TVAR :: ClosureType
ARR_WORDS :: ClosureType
MUT_ARR_PTRS_CLEAN :: ClosureType
MUT_ARR_PTRS_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
MUT_VAR_CLEAN :: ClosureType
MUT_VAR_DIRTY :: ClosureType
WEAK :: ClosureType
PRIM :: ClosureType
MUT_PRIM :: ClosureType
TSO :: ClosureType
STACK :: ClosureType
TREC_CHUNK :: ClosureType
ATOMICALLY_FRAME :: ClosureType
CATCH_RETRY_FRAME :: ClosureType
CATCH_STM_FRAME :: ClosureType
WHITEHOLE :: ClosureType
SMALL_MUT_ARR_PTRS_CLEAN :: ClosureType
SMALL_MUT_ARR_PTRS_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_DIRTY :: ClosureType
SMALL_MUT_ARR_PTRS_FROZEN_CLEAN :: ClosureType
COMPACT_NFDATA :: ClosureType
CONTINUATION :: ClosureType
N_CLOSURE_TYPES :: ClosureType
data PrimType
PInt :: PrimType
PWord :: PrimType
PInt64 :: PrimType
PWord64 :: PrimType
PAddr :: PrimType
PFloat :: PrimType
PDouble :: PrimType
data WhatNext
ThreadRunGHC :: WhatNext
ThreadInterpret :: WhatNext
ThreadKilled :: WhatNext
ThreadComplete :: WhatNext

-- | Please report this as a bug
WhatNextUnknownValue :: Word16 -> WhatNext
data WhyBlocked
NotBlocked :: WhyBlocked
BlockedOnMVar :: WhyBlocked
BlockedOnMVarRead :: WhyBlocked
BlockedOnBlackHole :: WhyBlocked
BlockedOnRead :: WhyBlocked
BlockedOnWrite :: WhyBlocked
BlockedOnDelay :: WhyBlocked
BlockedOnSTM :: WhyBlocked
BlockedOnDoProc :: WhyBlocked
BlockedOnCCall :: WhyBlocked
BlockedOnCCall_Interruptible :: WhyBlocked
BlockedOnMsgThrowTo :: WhyBlocked
ThreadMigrating :: WhyBlocked

-- | Please report this as a bug
WhyBlockedUnknownValue :: Word16 -> WhyBlocked
data TsoFlags
TsoLocked :: TsoFlags
TsoBlockx :: TsoFlags
TsoInterruptible :: TsoFlags
TsoStoppedOnBreakpoint :: TsoFlags
TsoMarked :: TsoFlags
TsoSqueezed :: TsoFlags
TsoAllocLimit :: TsoFlags

-- | Please report this as a bug
TsoFlagsUnknownValue :: Word32 -> TsoFlags
class HasHeapRep (a :: TYPE rep)

-- | Decode a closure to it's heap representation (<a>GenClosure</a>).
getClosureData :: HasHeapRep a => a -> IO Closure

-- | Convert an unpacked heap object, to a `GenClosure b`. The inputs to
--   this function can be generated from a heap object using
--   <a>unpackClosure#</a>.
getClosureDataFromHeapRep :: ByteArray# -> Ptr StgInfoTable -> [b] -> IO (GenClosure b)
getClosureDataFromHeapRepPrim :: IO (String, String, String) -> (Ptr a -> IO (Maybe CostCentreStack)) -> StgInfoTable -> ByteArray# -> [b] -> IO (GenClosure b)

-- | This is a somewhat faithful representation of an info table. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/InfoTables.h</a>
--   for more details on this data structure.
data StgInfoTable
StgInfoTable :: Maybe EntryFunPtr -> HalfWord -> HalfWord -> ClosureType -> HalfWord -> Maybe ItblCodes -> StgInfoTable
[entry] :: StgInfoTable -> Maybe EntryFunPtr
[ptrs] :: StgInfoTable -> HalfWord
[nptrs] :: StgInfoTable -> HalfWord
[tipe] :: StgInfoTable -> ClosureType
[srtlen] :: StgInfoTable -> HalfWord
[code] :: StgInfoTable -> Maybe ItblCodes
type EntryFunPtr = FunPtr (Ptr () -> IO (Ptr ()))
type HalfWord = Word32
type ItblCodes = Either [Word8] [Word32]

-- | Size in bytes of a standard InfoTable
itblSize :: Int

-- | Read an InfoTable from the heap into a haskell type. WARNING: This
--   code assumes it is passed a pointer to a "standard" info table. If
--   tables_next_to_code is enabled, it will look 1 byte before the start
--   for the entry field.
peekItbl :: Ptr StgInfoTable -> IO StgInfoTable
pokeItbl :: Ptr StgInfoTable -> StgInfoTable -> IO ()

-- | This is a somewhat faithful representation of StgTSOProfInfo. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/storage/TSO.h</a>
--   for more details on this data structure.
newtype StgTSOProfInfo
StgTSOProfInfo :: Maybe CostCentreStack -> StgTSOProfInfo
[cccs] :: StgTSOProfInfo -> Maybe CostCentreStack

-- | This is a somewhat faithful representation of IndexTable. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data IndexTable
IndexTable :: CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Bool -> IndexTable
[it_cc] :: IndexTable -> CostCentre
[it_ccs] :: IndexTable -> Maybe CostCentreStack
[it_next] :: IndexTable -> Maybe IndexTable
[it_back_edge] :: IndexTable -> Bool

-- | This is a somewhat faithful representation of CostCentre. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentre
CostCentre :: Int -> String -> String -> Maybe String -> Word64 -> Word -> Bool -> Maybe CostCentre -> CostCentre
[cc_ccID] :: CostCentre -> Int
[cc_label] :: CostCentre -> String
[cc_module] :: CostCentre -> String
[cc_srcloc] :: CostCentre -> Maybe String
[cc_mem_alloc] :: CostCentre -> Word64
[cc_time_ticks] :: CostCentre -> Word
[cc_is_caf] :: CostCentre -> Bool
[cc_link] :: CostCentre -> Maybe CostCentre

-- | This is a somewhat faithful representation of CostCentreStack. See
--   <a>https://gitlab.haskell.org/ghc/ghc/blob/master/rts/include/rts/prof/CCS.h</a>
--   for more details on this data structure.
data CostCentreStack
CostCentreStack :: Int -> CostCentre -> Maybe CostCentreStack -> Maybe IndexTable -> Maybe CostCentreStack -> Word -> Word64 -> Word -> Word -> Word64 -> Word64 -> Word -> CostCentreStack
[ccs_ccsID] :: CostCentreStack -> Int
[ccs_cc] :: CostCentreStack -> CostCentre
[ccs_prevStack] :: CostCentreStack -> Maybe CostCentreStack
[ccs_indexTable] :: CostCentreStack -> Maybe IndexTable
[ccs_root] :: CostCentreStack -> Maybe CostCentreStack
[ccs_depth] :: CostCentreStack -> Word
[ccs_scc_count] :: CostCentreStack -> Word64
[ccs_selected] :: CostCentreStack -> Word
[ccs_time_ticks] :: CostCentreStack -> Word
[ccs_mem_alloc] :: CostCentreStack -> Word64
[ccs_inherited_alloc] :: CostCentreStack -> Word64
[ccs_inherited_ticks] :: CostCentreStack -> Word

-- | Like <a>getClosureData</a>, but taking a <a>Box</a>, so it is easier
--   to work with.
getBoxedClosureData :: Box -> IO Closure

-- | For generic code, this function returns all referenced closures.
allClosures :: GenClosure b -> [b]

-- | An arbitrary Haskell value in a safe Box. The point is that even
--   unevaluated thunks can safely be moved around inside the Box, and when
--   required, e.g. in <tt>getBoxedClosureData</tt>, the function knows how
--   far it has to evaluate the argument.
data Box
Box :: Any -> Box

-- | This takes an arbitrary value and puts it into a box. Note that calls
--   like
--   
--   <pre>
--   asBox (head list)
--   </pre>
--   
--   will put the thunk "head list" into the box, <i>not</i> the element at
--   the head of the list. For that, use careful case expressions:
--   
--   <pre>
--   case list of x:_ -&gt; asBox x
--   </pre>
asBox :: a -> Box

-- | Boxes can be compared, but this is not pure, as different heap objects
--   can, after garbage collection, become the same object.
areBoxesEqual :: Box -> Box -> IO Bool
instance GHC.Exts.Heap.HasHeapRep a
instance GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Int64# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Word64# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Addr# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Float# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
instance (GHC.Prim.Double# GHC.Types.~ a) => GHC.Exts.Heap.HasHeapRep a
