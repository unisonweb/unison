-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast combinator parsing for bytestrings and text
--   
--   A fast parser combinator library, aimed particularly at dealing
--   efficiently with network protocols and complicated text/binary file
--   formats.
@package attoparsec
@version 0.14.4


-- | Simple, efficient parser combinators, loosely based on the Parsec
--   library.
module Data.Attoparsec.Internal.Types

-- | The core parser type. This is parameterised over the type <tt>i</tt>
--   of string being processed.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Monad</a>, where <a>fail</a> throws an exception (i.e. fails)
--   with an error message.</li>
--   <li><a>Functor</a> and <a>Applicative</a>, which follow the usual
--   definitions.</li>
--   <li><a>MonadPlus</a>, where <a>mzero</a> fails (with no error message)
--   and <a>mplus</a> executes the right-hand parser if the left-hand one
--   fails. When the parser on the right executes, the input is reset to
--   the same state as the parser on the left started with. (In other
--   words, attoparsec is a backtracking parser that supports arbitrary
--   lookahead.)</li>
--   <li><a>Alternative</a>, which follows <a>MonadPlus</a>.</li>
--   </ul>
newtype Parser i a
Parser :: (forall r. State i -> Pos -> More -> Failure i (State i) r -> Success i (State i) a r -> IResult i r) -> Parser i a
[runParser] :: Parser i a -> forall r. State i -> Pos -> More -> Failure i (State i) r -> Success i (State i) a r -> IResult i r
type family State i
type Failure i t r = t -> Pos -> More -> [String] -> String -> IResult i r
type Success i t a r = t -> Pos -> More -> a -> IResult i r
newtype Pos
Pos :: Int -> Pos
[fromPos] :: Pos -> Int

-- | The result of a parse. This is parameterised over the type <tt>i</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | Have we read all available input?
data More
Complete :: More
Incomplete :: More

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | A common interface for input chunks.
class Monoid c => Chunk c where {
    type ChunkElem c;
}

-- | Test if the chunk is empty.
nullChunk :: Chunk c => c -> Bool

-- | Append chunk to a buffer.
pappendChunk :: Chunk c => State c -> c -> State c

-- | Position at the end of a buffer. The first argument is ignored.
atBufferEnd :: Chunk c => c -> State c -> Pos

-- | Return the buffer element at the given position along with its length.
bufferElemAt :: Chunk c => c -> Pos -> State c -> Maybe (ChunkElem c, Int)

-- | Map an element to the corresponding character. The first argument is
--   ignored.
chunkElemToChar :: Chunk c => c -> ChunkElem c -> Char
instance GHC.Num.Num Data.Attoparsec.Internal.Types.Pos
instance GHC.Show.Show Data.Attoparsec.Internal.Types.Pos
instance GHC.Classes.Ord Data.Attoparsec.Internal.Types.Pos
instance GHC.Classes.Eq Data.Attoparsec.Internal.Types.Pos
instance GHC.Show.Show Data.Attoparsec.Internal.Types.More
instance GHC.Classes.Eq Data.Attoparsec.Internal.Types.More
instance Data.Attoparsec.Internal.Types.Chunk Data.ByteString.Internal.Type.ByteString
instance Data.Attoparsec.Internal.Types.Chunk Data.Text.Internal.Text
instance GHC.Base.Monad (Data.Attoparsec.Internal.Types.Parser i)
instance Control.Monad.Fail.MonadFail (Data.Attoparsec.Internal.Types.Parser i)
instance GHC.Base.MonadPlus (Data.Attoparsec.Internal.Types.Parser i)
instance GHC.Base.Functor (Data.Attoparsec.Internal.Types.Parser i)
instance GHC.Base.Applicative (Data.Attoparsec.Internal.Types.Parser i)
instance GHC.Base.Semigroup (Data.Attoparsec.Internal.Types.Parser i a)
instance GHC.Base.Monoid (Data.Attoparsec.Internal.Types.Parser i a)
instance GHC.Base.Alternative (Data.Attoparsec.Internal.Types.Parser i)
instance GHC.Base.Semigroup Data.Attoparsec.Internal.Types.More
instance GHC.Base.Monoid Data.Attoparsec.Internal.Types.More
instance (GHC.Show.Show i, GHC.Show.Show r) => GHC.Show.Show (Data.Attoparsec.Internal.Types.IResult i r)
instance (Control.DeepSeq.NFData i, Control.DeepSeq.NFData r) => Control.DeepSeq.NFData (Data.Attoparsec.Internal.Types.IResult i r)
instance GHC.Base.Functor (Data.Attoparsec.Internal.Types.IResult i)


-- | Simple, efficient parser combinators, loosely based on the Parsec
--   library.
module Data.Attoparsec.Internal

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | Ask for input. If we receive any, pass the augmented input to a
--   success continuation, otherwise to a failure continuation.
prompt :: Chunk t => State t -> Pos -> More -> (State t -> Pos -> More -> IResult t r) -> (State t -> Pos -> More -> IResult t r) -> IResult t r

-- | Immediately demand more input via a <a>Partial</a> continuation
--   result.
demandInput :: Chunk t => Parser t ()

-- | Immediately demand more input via a <a>Partial</a> continuation
--   result. Return the new input.
demandInput_ :: Chunk t => Parser t t

-- | This parser always succeeds. It returns <a>True</a> if any input is
--   available either immediately or on demand, and <a>False</a> if the end
--   of all input has been reached.
wantInput :: forall t. Chunk t => Parser t Bool

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool

-- | The parser <tt>satisfyElem p</tt> succeeds for any chunk element for
--   which the predicate <tt>p</tt> returns <a>True</a>. Returns the
--   element that is actually parsed.
satisfyElem :: forall t. Chunk t => (ChunkElem t -> Bool) -> Parser t (ChunkElem t)

-- | Concatenate a monoid after reversing its elements. Used to glue
--   together a series of textual chunks that have been accumulated
--   "backwards".
concatReverse :: Monoid m => [m] -> m


-- | This module is deprecated, and both the module and <a>Number</a> type
--   will be removed in the next major release. Use the <a>scientific</a>
--   package and the <a>Scientific</a> type instead.
--   
--   A simple number type, useful for parsing both exact and inexact
--   quantities without losing much precision.

-- | <i>Deprecated: This module will be removed in the next major
--   release.</i>
module Data.Attoparsec.Number

-- | A numeric type that can represent integers accurately, and floating
--   point numbers to the precision of a <a>Double</a>.
--   
--   <i>Note</i>: this type is deprecated, and will be removed in the next
--   major release. Use the <a>Scientific</a> type instead.
data Number
I :: !Integer -> Number
D :: {-# UNPACK #-} !Double -> Number
instance Data.Data.Data Data.Attoparsec.Number.Number
instance GHC.Show.Show Data.Attoparsec.Number.Number
instance Control.DeepSeq.NFData Data.Attoparsec.Number.Number
instance GHC.Classes.Eq Data.Attoparsec.Number.Number
instance GHC.Classes.Ord Data.Attoparsec.Number.Number
instance GHC.Num.Num Data.Attoparsec.Number.Number
instance GHC.Real.Real Data.Attoparsec.Number.Number
instance GHC.Real.Fractional Data.Attoparsec.Number.Number
instance GHC.Real.RealFrac Data.Attoparsec.Number.Number


-- | Simple, efficient parser combinators for strings, loosely based on the
--   Parsec library.
module Data.Attoparsec.Types

-- | The core parser type. This is parameterised over the type <tt>i</tt>
--   of string being processed.
--   
--   This type is an instance of the following classes:
--   
--   <ul>
--   <li><a>Monad</a>, where <a>fail</a> throws an exception (i.e. fails)
--   with an error message.</li>
--   <li><a>Functor</a> and <a>Applicative</a>, which follow the usual
--   definitions.</li>
--   <li><a>MonadPlus</a>, where <a>mzero</a> fails (with no error message)
--   and <a>mplus</a> executes the right-hand parser if the left-hand one
--   fails. When the parser on the right executes, the input is reset to
--   the same state as the parser on the left started with. (In other
--   words, attoparsec is a backtracking parser that supports arbitrary
--   lookahead.)</li>
--   <li><a>Alternative</a>, which follows <a>MonadPlus</a>.</li>
--   </ul>
data Parser i a

-- | The result of a parse. This is parameterised over the type <tt>i</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | A common interface for input chunks.
class Monoid c => Chunk c

-- | Map an element to the corresponding character. The first argument is
--   ignored.
chunkElemToChar :: Chunk c => c -> ChunkElem c -> Char


-- | A tiny, highly specialized combinator parser for <a>ByteString</a>
--   strings.
--   
--   While the main attoparsec module generally performs well, this module
--   is particularly fast for simple non-recursive loops that should not
--   normally result in failed parses.
--   
--   <i>Warning</i>: on more complex inputs involving recursion or failure,
--   parsers based on this module may be as much as <i>ten times slower</i>
--   than regular attoparsec! You should <i>only</i> use this module when
--   you have benchmarks that prove that its use speeds your code up.
module Data.Attoparsec.Zepto
type Parser a = ZeptoT Identity a

-- | A simple parser.
--   
--   This monad is strict in its state, and the monadic bind operator
--   (<a>&gt;&gt;=</a>) evaluates each result to weak head normal form
--   before passing it along.
data ZeptoT m a

-- | Run a parser.
parse :: Parser a -> ByteString -> Either String a

-- | Run a parser on top of the given base monad.
parseT :: Monad m => ZeptoT m a -> ByteString -> m (Either String a)

-- | Indicate whether the end of the input has been reached.
atEnd :: Monad m => ZeptoT m Bool

-- | Match a string exactly.
string :: Monad m => ByteString -> ZeptoT m ()

-- | Consume <tt>n</tt> bytes of input.
take :: Monad m => Int -> ZeptoT m ByteString

-- | Consume input while the predicate returns <a>True</a>.
takeWhile :: Monad m => (Word8 -> Bool) -> ZeptoT m ByteString
instance GHC.Base.Monad m => GHC.Base.Functor (Data.Attoparsec.Zepto.ZeptoT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Attoparsec.Zepto.ZeptoT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Attoparsec.Zepto.ZeptoT m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Data.Attoparsec.Zepto.ZeptoT m)
instance GHC.Base.Monad m => GHC.Base.MonadPlus (Data.Attoparsec.Zepto.ZeptoT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Data.Attoparsec.Zepto.ZeptoT m)
instance GHC.Base.Monad m => GHC.Base.Semigroup (Data.Attoparsec.Zepto.ZeptoT m a)
instance GHC.Base.Monad m => GHC.Base.Monoid (Data.Attoparsec.Zepto.ZeptoT m a)
instance GHC.Base.Monad m => GHC.Base.Alternative (Data.Attoparsec.Zepto.ZeptoT m)


-- | Useful parser combinators, similar to those provided by Parsec.
module Data.Attoparsec.Combinator

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | The parser <tt>satisfyElem p</tt> succeeds for any chunk element for
--   which the predicate <tt>p</tt> returns <a>True</a>. Returns the
--   element that is actually parsed.
satisfyElem :: forall t. Chunk t => (ChunkElem t -> Bool) -> Parser t (ChunkElem t)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool

-- | Apply a parser without consuming any input.
lookAhead :: Parser i a -> Parser i a


-- | Simple, efficient combinator parsing for <a>Text</a> strings, loosely
--   based on the Parsec library.
module Data.Attoparsec.Text
type Parser = Parser Text
type Result = IResult Text

-- | The result of a parse. This is parameterised over the type <tt>i</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | Run a parser.
parse :: Parser a -> Text -> Result a

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
--   
--   This function does not force a parser to consume all of its input.
--   Instead, any residual input will be discarded. To force a parser to
--   consume all of its input, use something like this:
--   
--   <pre>
--   <a>parseOnly</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
parseOnly :: Parser a -> Text -> Either String a

-- | Run a parser with an initial input string, and a monadic action that
--   can supply more input if needed.
parseWith :: Monad m => m Text -> Parser a -> Text -> m (Result a)

-- | Run a parser and print its result to standard output.
parseTest :: Show a => Parser a -> Text -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value. A
--   <tt>Partial</tt> result is treated as failure.
maybeResult :: Result r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value. A
--   <tt>Partial</tt> result is treated as failure.
eitherResult :: Result r -> Either String r

-- | Match a specific character.
char :: Char -> Parser Char

-- | Match any character.
anyChar :: Parser Char

-- | Match any character except the given one.
notChar :: Char -> Parser Char

-- | The parser <tt>satisfy p</tt> succeeds for any character for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the character that
--   is actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
satisfy :: (Char -> Bool) -> Parser Char

-- | The parser <tt>satisfyWith f p</tt> transforms a character, and
--   succeeds if the predicate <tt>p</tt> returns <a>True</a> on the
--   transformed value. The parser returns the transformed character that
--   was parsed.
satisfyWith :: (Char -> a) -> (a -> Bool) -> Parser a

-- | The parser <tt>skip p</tt> succeeds for any character for which the
--   predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   skipDigit = skip isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
skip :: (Char -> Bool) -> Parser ()

-- | Match any character, to perform lookahead. Returns <a>Nothing</a> if
--   end of input has been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekChar :: Parser (Maybe Char)

-- | Match any character, to perform lookahead. Does not consume any input,
--   but will fail if end of input has been reached.
peekChar' :: Parser Char

-- | Parse a single digit, as recognised by <a>isDigit</a>.
digit :: Parser Char

-- | Parse a letter, as recognised by <a>isAlpha</a>.
letter :: Parser Char

-- | Parse a space character, as recognised by <a>isSpace</a>.
space :: Parser Char

-- | Match any character in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal <tt>'-'</tt> to a set, place it at the beginning or
--   end of the string.
inClass :: String -> Char -> Bool

-- | Match any character not in a set.
notInClass :: String -> Char -> Bool

-- | <tt>string s</tt> parses a sequence of characters that identically
--   match <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This
--   parser consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: Text -> Parser Text

-- | Satisfy a literal string, ignoring case.
--   
--   Note: this function is currently quite inefficient. Unicode case
--   folding can change the length of a string ("ÃŸ" becomes "ss"), which
--   makes a simple, efficient implementation tricky. We have (for now)
--   chosen simplicity over efficiency.

-- | <i>Deprecated: this is very inefficient, use asciiCI instead</i>
stringCI :: Text -> Parser Text

-- | Satisfy a literal string, ignoring case for characters in the ASCII
--   range.
asciiCI :: Text -> Parser Text

-- | Skip over white space.
skipSpace :: Parser ()

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Char -> Bool) -> Parser ()

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each character of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: s -> (s -> Char -> Maybe s) -> Parser Text

-- | Like <a>scan</a>, but generalized to return the final state of the
--   scanner.
runScanner :: s -> (s -> Char -> Maybe s) -> Parser (Text, s)

-- | Consume exactly <tt>n</tt> characters of input.
take :: Int -> Parser Text

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Char -> Bool) -> Parser Text

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one
--   character of input: it will fail if the predicate never returns
--   <a>True</a> or if there is no input left.
takeWhile1 :: (Char -> Bool) -> Parser Text

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Char -> Bool) -> Parser Text

-- | <i>Obsolete</i>. A type-specialized version of <a>*&gt;</a> for
--   <a>Text</a>. Use <a>*&gt;</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>*&gt;</a> instead.</i>
(.*>) :: Text -> Parser a -> Parser a

-- | <i>Obsolete</i>. A type-specialized version of <a>&lt;*</a> for
--   <a>Text</a>. Use <a>*&gt;</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>&lt;*</a> instead.</i>
(<*.) :: Parser a -> Text -> Parser a

-- | Consume all remaining input and return it as a single string.
takeText :: Parser Text

-- | Consume all remaining input and return it as a single string.
takeLazyText :: Parser Text

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
endOfLine :: Parser ()

-- | A predicate that matches either a carriage return <tt>'\r'</tt> or
--   newline <tt>'\n'</tt> character.
isEndOfLine :: Char -> Bool

-- | A predicate that matches either a space <tt>' '</tt> or horizontal tab
--   <tt>'\t'</tt> character.
isHorizontalSpace :: Char -> Bool

-- | Parse and decode an unsigned decimal number.
decimal :: Integral a => Parser a

-- | Parse and decode an unsigned hexadecimal number. The hex digits
--   <tt>'a'</tt> through <tt>'f'</tt> may be upper or lower case.
--   
--   This parser does not accept a leading <tt>"0x"</tt> string.
hexadecimal :: (Integral a, Bits a) => Parser a

-- | Parse a number with an optional leading <tt>'+'</tt> or <tt>'-'</tt>
--   sign character.
signed :: Num a => Parser a -> Parser a

-- | Parse a <a>Double</a>.
--   
--   This parser accepts an optional leading sign character, followed by at
--   most one decimal digit. The syntax is similar to that accepted by the
--   <a>read</a> function, with the exception that a trailing <tt>'.'</tt>
--   is consumed.
--   
--   <h3>Examples</h3>
--   
--   These examples use this helper:
--   
--   <pre>
--   r :: <a>Parser</a> a -&gt; <a>Text</a> -&gt; <a>Result</a> a
--   r p s = <a>feed</a> (<a>parse</a> p s) <a>mempty</a>
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>, if you feed an empty
--   continuation to the first result:
--   
--   <pre>
--   r double "3"     == Done "" 3.0
--   r double "3.1"   == Done "" 3.1
--   r double "3e4"   == Done "" 30000.0
--   r double "3.1e4" == Done "" 31000.0
--   r double "3e"    == Done "e" 3.0
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>:
--   
--   <pre>
--   r double ".3"    == Fail ".3" _ _
--   r double "e3"    == Fail "e3" _ _
--   </pre>
--   
--   Example of difference from <a>read</a>:
--   
--   <pre>
--   r double "3.foo" == Done "foo" 3.0
--   </pre>
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".
double :: Parser Double

-- | A numeric type that can represent integers accurately, and floating
--   point numbers to the precision of a <a>Double</a>.
--   
--   <i>Note</i>: this type is deprecated, and will be removed in the next
--   major release. Use the <a>Scientific</a> type instead.
data Number
I :: !Integer -> Number
D :: {-# UNPACK #-} !Double -> Number

-- | Parse a number, attempting to preserve both speed and precision.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".

-- | <i>Deprecated: Use <a>scientific</a> instead.</i>
number :: Parser Number

-- | Parse a rational number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
--   
--   <i>Note</i>: this parser is not safe for use with inputs from
--   untrusted sources. An input with a suitably large exponent such as
--   <tt>"1e1000000000"</tt> will cause a huge <a>Integer</a> to be
--   allocated, resulting in what is effectively a denial-of-service
--   attack.
--   
--   In most cases, it is better to use <a>double</a> or <a>scientific</a>
--   instead.
rational :: Fractional a => Parser a

-- | Parse a scientific number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
scientific :: Parser Scientific

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Return both the result of a parse and the portion of the input that
--   was consumed while it was being parsed.
match :: Parser a -> Parser (Text, a)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool


-- | Simple, efficient combinator parsing that can consume lazy <a>Text</a>
--   strings, loosely based on the Parsec library.
--   
--   This is essentially the same code as in the <a>Text</a> module, only
--   with a <a>parse</a> function that can consume a lazy <a>Text</a>
--   incrementally, and a <a>Result</a> type that does not allow more input
--   to be fed in. Think of this as suitable for use with a lazily read
--   file, e.g. via <a>readFile</a> or <a>hGetContents</a>.
--   
--   <i>Note:</i> The various parser functions and combinators such as
--   <a>string</a> still expect <i>strict</i> <a>Text</a> parameters, and
--   return strict <a>Text</a> results. Behind the scenes, strict
--   <a>Text</a> values are still used internally to store parser input and
--   manipulate it efficiently.
module Data.Attoparsec.Text.Lazy

-- | The result of a parse.
data Result r

-- | The parse failed. The <a>Text</a> is the input that had not yet been
--   consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: Text -> [String] -> String -> Result r

-- | The parse succeeded. The <a>Text</a> is the input that had not yet
--   been consumed (if any) when the parse succeeded.
Done :: Text -> r -> Result r

-- | A numeric type that can represent integers accurately, and floating
--   point numbers to the precision of a <a>Double</a>.
--   
--   <i>Note</i>: this type is deprecated, and will be removed in the next
--   major release. Use the <a>Scientific</a> type instead.
data Number
I :: !Integer -> Number
D :: {-# UNPACK #-} !Double -> Number
type Parser = Parser Text

-- | Parse a scientific number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
scientific :: Parser Scientific

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Char -> Bool) -> Parser Text

-- | Consume exactly <tt>n</tt> characters of input.
take :: Int -> Parser Text

-- | The parser <tt>satisfy p</tt> succeeds for any character for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the character that
--   is actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
satisfy :: (Char -> Bool) -> Parser Char

-- | Match a specific character.
char :: Char -> Parser Char

-- | <tt>string s</tt> parses a sequence of characters that identically
--   match <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This
--   parser consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: Text -> Parser Text

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | The parser <tt>skip p</tt> succeeds for any character for which the
--   predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   skipDigit = skip isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
skip :: (Char -> Bool) -> Parser ()

-- | Return both the result of a parse and the portion of the input that
--   was consumed while it was being parsed.
match :: Parser a -> Parser (Text, a)

-- | Parse a space character, as recognised by <a>isSpace</a>.
space :: Parser Char

-- | Parse a <a>Double</a>.
--   
--   This parser accepts an optional leading sign character, followed by at
--   most one decimal digit. The syntax is similar to that accepted by the
--   <a>read</a> function, with the exception that a trailing <tt>'.'</tt>
--   is consumed.
--   
--   <h3>Examples</h3>
--   
--   These examples use this helper:
--   
--   <pre>
--   r :: <a>Parser</a> a -&gt; <a>Text</a> -&gt; <a>Result</a> a
--   r p s = <a>feed</a> (<a>parse</a> p s) <a>mempty</a>
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>, if you feed an empty
--   continuation to the first result:
--   
--   <pre>
--   r double "3"     == Done "" 3.0
--   r double "3.1"   == Done "" 3.1
--   r double "3e4"   == Done "" 30000.0
--   r double "3.1e4" == Done "" 31000.0
--   r double "3e"    == Done "e" 3.0
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>:
--   
--   <pre>
--   r double ".3"    == Fail ".3" _ _
--   r double "e3"    == Fail "e3" _ _
--   </pre>
--   
--   Example of difference from <a>read</a>:
--   
--   <pre>
--   r double "3.foo" == Done "foo" 3.0
--   </pre>
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".
double :: Parser Double

-- | Parse a rational number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
--   
--   <i>Note</i>: this parser is not safe for use with inputs from
--   untrusted sources. An input with a suitably large exponent such as
--   <tt>"1e1000000000"</tt> will cause a huge <a>Integer</a> to be
--   allocated, resulting in what is effectively a denial-of-service
--   attack.
--   
--   In most cases, it is better to use <a>double</a> or <a>scientific</a>
--   instead.
rational :: Fractional a => Parser a

-- | Parse and decode an unsigned decimal number.
decimal :: Integral a => Parser a

-- | Parse and decode an unsigned hexadecimal number. The hex digits
--   <tt>'a'</tt> through <tt>'f'</tt> may be upper or lower case.
--   
--   This parser does not accept a leading <tt>"0x"</tt> string.
hexadecimal :: (Integral a, Bits a) => Parser a

-- | Parse a number with an optional leading <tt>'+'</tt> or <tt>'-'</tt>
--   sign character.
signed :: Num a => Parser a -> Parser a

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | The parser <tt>satisfyWith f p</tt> transforms a character, and
--   succeeds if the predicate <tt>p</tt> returns <a>True</a> on the
--   transformed value. The parser returns the transformed character that
--   was parsed.
satisfyWith :: (Char -> a) -> (a -> Bool) -> Parser a

-- | Match any character in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal <tt>'-'</tt> to a set, place it at the beginning or
--   end of the string.
inClass :: String -> Char -> Bool

-- | Match any character not in a set.
notInClass :: String -> Char -> Bool

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Char -> Bool) -> Parser ()

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each character of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: s -> (s -> Char -> Maybe s) -> Parser Text

-- | Like <a>scan</a>, but generalized to return the final state of the
--   scanner.
runScanner :: s -> (s -> Char -> Maybe s) -> Parser (Text, s)

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one
--   character of input: it will fail if the predicate never returns
--   <a>True</a> or if there is no input left.
takeWhile1 :: (Char -> Bool) -> Parser Text

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first character of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Char -> Bool) -> Parser Text

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool

-- | Match any character.
anyChar :: Parser Char

-- | Match any character except the given one.
notChar :: Char -> Parser Char

-- | Match any character, to perform lookahead. Returns <a>Nothing</a> if
--   end of input has been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekChar :: Parser (Maybe Char)

-- | Match any character, to perform lookahead. Does not consume any input,
--   but will fail if end of input has been reached.
peekChar' :: Parser Char

-- | Parse a single digit, as recognised by <a>isDigit</a>.
digit :: Parser Char

-- | Satisfy a literal string, ignoring case.
--   
--   Note: this function is currently quite inefficient. Unicode case
--   folding can change the length of a string ("ÃŸ" becomes "ss"), which
--   makes a simple, efficient implementation tricky. We have (for now)
--   chosen simplicity over efficiency.

-- | <i>Deprecated: this is very inefficient, use asciiCI instead</i>
stringCI :: Text -> Parser Text

-- | Skip over white space.
skipSpace :: Parser ()

-- | <i>Obsolete</i>. A type-specialized version of <a>*&gt;</a> for
--   <a>Text</a>. Use <a>*&gt;</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>*&gt;</a> instead.</i>
(.*>) :: Text -> Parser a -> Parser a

-- | <i>Obsolete</i>. A type-specialized version of <a>&lt;*</a> for
--   <a>Text</a>. Use <a>*&gt;</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>&lt;*</a> instead.</i>
(<*.) :: Parser a -> Text -> Parser a

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
endOfLine :: Parser ()

-- | A predicate that matches either a carriage return <tt>'\r'</tt> or
--   newline <tt>'\n'</tt> character.
isEndOfLine :: Char -> Bool

-- | A predicate that matches either a space <tt>' '</tt> or horizontal tab
--   <tt>'\t'</tt> character.
isHorizontalSpace :: Char -> Bool

-- | Parse a number, attempting to preserve both speed and precision.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".

-- | <i>Deprecated: Use <a>scientific</a> instead.</i>
number :: Parser Number

-- | Parse a letter, as recognised by <a>isAlpha</a>.
letter :: Parser Char

-- | Satisfy a literal string, ignoring case for characters in the ASCII
--   range.
asciiCI :: Text -> Parser Text

-- | Consume all remaining input and return it as a single string.
takeText :: Parser Text

-- | Consume all remaining input and return it as a single string.
takeLazyText :: Parser Text

-- | Run a parser and return its result.
parse :: Parser a -> Text -> Result a

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
--   
--   This function does not force a parser to consume all of its input.
--   Instead, any residual input will be discarded. To force a parser to
--   consume all of its input, use something like this:
--   
--   <pre>
--   <a>parseOnly</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
parseOnly :: Parser a -> Text -> Either String a

-- | Run a parser and print its result to standard output.
parseTest :: Show a => Parser a -> Text -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value.
maybeResult :: Result r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value.
eitherResult :: Result r -> Either String r
instance GHC.Show.Show r => GHC.Show.Show (Data.Attoparsec.Text.Lazy.Result r)
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (Data.Attoparsec.Text.Lazy.Result r)
instance GHC.Base.Functor Data.Attoparsec.Text.Lazy.Result


-- | Simple, efficient combinator parsing for <a>ByteString</a> strings,
--   loosely based on the Parsec library.
module Data.Attoparsec.ByteString
type Parser = Parser ByteString
type Result = IResult ByteString

-- | The result of a parse. This is parameterised over the type <tt>i</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | Run a parser.
parse :: Parser a -> ByteString -> Result a

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
--   
--   This function does not force a parser to consume all of its input.
--   Instead, any residual input will be discarded. To force a parser to
--   consume all of its input, use something like this:
--   
--   <pre>
--   <a>parseOnly</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
parseOnly :: Parser a -> ByteString -> Either String a

-- | Run a parser with an initial input string, and a monadic action that
--   can supply more input if needed.
parseWith :: Monad m => m ByteString -> Parser a -> ByteString -> m (Result a)

-- | Run a parser and print its result to standard output.
parseTest :: Show a => Parser a -> ByteString -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value. A
--   <a>Partial</a> result is treated as failure.
maybeResult :: Result r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value. A
--   <a>Partial</a> result is treated as failure.
eitherResult :: Result r -> Either String r

-- | Match a specific byte.
word8 :: Word8 -> Parser Word8

-- | Match any byte.
anyWord8 :: Parser Word8

-- | Match any byte except the given one.
notWord8 :: Word8 -> Parser Word8

-- | The parser <tt>satisfy p</tt> succeeds for any byte for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the byte that is
--   actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
--   </pre>
satisfy :: (Word8 -> Bool) -> Parser Word8

-- | The parser <tt>satisfyWith f p</tt> transforms a byte, and succeeds if
--   the predicate <tt>p</tt> returns <a>True</a> on the transformed value.
--   The parser returns the transformed byte that was parsed.
satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser a

-- | The parser <tt>skip p</tt> succeeds for any byte for which the
--   predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   skipDigit = skip isDigit
--       where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
--   </pre>
skip :: (Word8 -> Bool) -> Parser ()

-- | Match any byte, to perform lookahead. Returns <a>Nothing</a> if end of
--   input has been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekWord8 :: Parser (Maybe Word8)

-- | Match any byte, to perform lookahead. Does not consume any input, but
--   will fail if end of input has been reached.
peekWord8' :: Parser Word8

-- | Match any byte in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal <tt>'-'</tt> to a set, place it at the beginning or
--   end of the string.
inClass :: String -> Word8 -> Bool

-- | Match any byte not in a set.
notInClass :: String -> Word8 -> Bool

-- | <tt>string s</tt> parses a sequence of bytes that identically match
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This parser
--   consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: ByteString -> Parser ByteString

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Word8 -> Bool) -> Parser ()

-- | Consume exactly <tt>n</tt> bytes of input.
take :: Int -> Parser ByteString

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each byte of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: s -> (s -> Word8 -> Maybe s) -> Parser ByteString

-- | Like <a>scan</a>, but generalized to return the final state of the
--   scanner.
runScanner :: s -> (s -> Word8 -> Maybe s) -> Parser (ByteString, s)

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Word8 -> Bool) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one byte of
--   input: it will fail if the predicate never returns <a>True</a> or if
--   there is no input left.
takeWhile1 :: (Word8 -> Bool) -> Parser ByteString

-- | Consume input until immediately after the predicate returns
--   <a>True</a>, and return the consumed input.
--   
--   This parser will consume at least one <a>Word8</a> or fail.
takeWhileIncluding :: (Word8 -> Bool) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Word8 -> Bool) -> Parser ByteString

-- | Return the rest of the current chunk without consuming anything.
--   
--   If the current chunk is empty, then ask for more input. If there is no
--   more input, then return <a>Nothing</a>
getChunk :: Parser (Maybe ByteString)

-- | Consume all remaining input and return it as a single string.
takeByteString :: Parser ByteString

-- | Consume all remaining input and return it as a single string.
takeLazyByteString :: Parser ByteString

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Return both the result of a parse and the portion of the input that
--   was consumed while it was being parsed.
match :: Parser a -> Parser (ByteString, a)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool


-- | Simple, efficient combinator parsing that can consume lazy
--   <a>ByteString</a> strings, loosely based on the Parsec library.
--   
--   This is essentially the same code as in the <a>Attoparsec</a> module,
--   only with a <a>parse</a> function that can consume a lazy
--   <a>ByteString</a> incrementally, and a <a>Result</a> type that does
--   not allow more input to be fed in. Think of this as suitable for use
--   with a lazily read file, e.g. via <a>readFile</a> or
--   <a>hGetContents</a>.
--   
--   <i>Note:</i> The various parser functions and combinators such as
--   <a>string</a> still expect <i>strict</i> <a>ByteString</a> parameters,
--   and return strict <a>ByteString</a> results. Behind the scenes, strict
--   <a>ByteString</a> values are still used internally to store parser
--   input and manipulate it efficiently.
module Data.Attoparsec.ByteString.Lazy

-- | The result of a parse.
data Result r

-- | The parse failed. The <a>ByteString</a> is the input that had not yet
--   been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: ByteString -> [String] -> String -> Result r

-- | The parse succeeded. The <a>ByteString</a> is the input that had not
--   yet been consumed (if any) when the parse succeeded.
Done :: ByteString -> r -> Result r
type Parser = Parser ByteString

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Word8 -> Bool) -> Parser ByteString

-- | Consume exactly <tt>n</tt> bytes of input.
take :: Int -> Parser ByteString

-- | The parser <tt>satisfy p</tt> succeeds for any byte for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the byte that is
--   actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
--   </pre>
satisfy :: (Word8 -> Bool) -> Parser Word8

-- | <tt>string s</tt> parses a sequence of bytes that identically match
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This parser
--   consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: ByteString -> Parser ByteString

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | The parser <tt>skip p</tt> succeeds for any byte for which the
--   predicate <tt>p</tt> returns <a>True</a>.
--   
--   <pre>
--   skipDigit = skip isDigit
--       where isDigit w = w &gt;= 48 &amp;&amp; w &lt;= 57
--   </pre>
skip :: (Word8 -> Bool) -> Parser ()

-- | Match a specific byte.
word8 :: Word8 -> Parser Word8

-- | Return both the result of a parse and the portion of the input that
--   was consumed while it was being parsed.
match :: Parser a -> Parser (ByteString, a)

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Match any byte.
anyWord8 :: Parser Word8

-- | Match any byte except the given one.
notWord8 :: Word8 -> Parser Word8

-- | The parser <tt>satisfyWith f p</tt> transforms a byte, and succeeds if
--   the predicate <tt>p</tt> returns <a>True</a> on the transformed value.
--   The parser returns the transformed byte that was parsed.
satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser a

-- | Match any byte, to perform lookahead. Returns <a>Nothing</a> if end of
--   input has been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekWord8 :: Parser (Maybe Word8)

-- | Match any byte, to perform lookahead. Does not consume any input, but
--   will fail if end of input has been reached.
peekWord8' :: Parser Word8

-- | Match any byte in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal <tt>'-'</tt> to a set, place it at the beginning or
--   end of the string.
inClass :: String -> Word8 -> Bool

-- | Match any byte not in a set.
notInClass :: String -> Word8 -> Bool

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Word8 -> Bool) -> Parser ()

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each byte of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: s -> (s -> Word8 -> Maybe s) -> Parser ByteString

-- | Like <a>scan</a>, but generalized to return the final state of the
--   scanner.
runScanner :: s -> (s -> Word8 -> Maybe s) -> Parser (ByteString, s)

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one byte of
--   input: it will fail if the predicate never returns <a>True</a> or if
--   there is no input left.
takeWhile1 :: (Word8 -> Bool) -> Parser ByteString

-- | Consume input until immediately after the predicate returns
--   <a>True</a>, and return the consumed input.
--   
--   This parser will consume at least one <a>Word8</a> or fail.
takeWhileIncluding :: (Word8 -> Bool) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <a>many</a>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Word8 -> Bool) -> Parser ByteString

-- | Return the rest of the current chunk without consuming anything.
--   
--   If the current chunk is empty, then ask for more input. If there is no
--   more input, then return <a>Nothing</a>
getChunk :: Parser (Maybe ByteString)

-- | Consume all remaining input and return it as a single string.
takeByteString :: Parser ByteString

-- | Consume all remaining input and return it as a single string.
takeLazyByteString :: Parser ByteString

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool

-- | Run a parser and return its result.
parse :: Parser a -> ByteString -> Result a

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
--   
--   This function does not force a parser to consume all of its input.
--   Instead, any residual input will be discarded. To force a parser to
--   consume all of its input, use something like this:
--   
--   <pre>
--   <a>parseOnly</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
parseOnly :: Parser a -> ByteString -> Either String a

-- | Run a parser and print its result to standard output.
parseTest :: Show a => Parser a -> ByteString -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value.
maybeResult :: Result r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value.
eitherResult :: Result r -> Either String r
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (Data.Attoparsec.ByteString.Lazy.Result r)
instance GHC.Show.Show r => GHC.Show.Show (Data.Attoparsec.ByteString.Lazy.Result r)
instance GHC.Base.Functor Data.Attoparsec.ByteString.Lazy.Result


-- | Simple, efficient combinator parsing for lazy <tt>ByteString</tt>
--   strings, loosely based on the Parsec library.
--   
--   This is essentially the same code as in the <a>Attoparsec</a> module,
--   only with a <a>parse</a> function that can consume a lazy
--   <tt>ByteString</tt> incrementally, and a <a>Result</a> type that does
--   not allow more input to be fed in. Think of this as suitable for use
--   with a lazily read file, e.g. via <a>readFile</a> or
--   <a>hGetContents</a>.
--   
--   Behind the scenes, strict <a>ByteString</a> values are still used
--   internally to store parser input and manipulate it efficiently.
--   High-performance parsers such as <a>string</a> still expect strict
--   <a>ByteString</a> parameters.
module Data.Attoparsec.Lazy


-- | Simple, efficient, character-oriented combinator parsing for
--   <a>ByteString</a> strings, loosely based on the Parsec library.
module Data.Attoparsec.ByteString.Char8
type Parser = Parser ByteString
type Result = IResult ByteString

-- | The result of a parse. This is parameterised over the type <tt>i</tt>
--   of string that was processed.
--   
--   This type is an instance of <a>Functor</a>, where <a>fmap</a>
--   transforms the value in a <a>Done</a> result.
data IResult i r

-- | The parse failed. The <tt>i</tt> parameter is the input that had not
--   yet been consumed when the failure occurred. The
--   <tt>[</tt><a>String</a><tt>]</tt> is a list of contexts in which the
--   error occurred. The <a>String</a> is the message describing the error,
--   if any.
Fail :: i -> [String] -> String -> IResult i r

-- | Supply this continuation with more input so that the parser can
--   resume. To indicate that no more input is available, pass an empty
--   string to the continuation.
--   
--   <b>Note</b>: if you get a <a>Partial</a> result, do not call its
--   continuation more than once.
Partial :: (i -> IResult i r) -> IResult i r

-- | The parse succeeded. The <tt>i</tt> parameter is the input that had
--   not yet been consumed (if any) when the parse succeeded.
Done :: i -> r -> IResult i r

-- | Compare two <a>IResult</a> values for equality.
--   
--   If both <a>IResult</a>s are <a>Partial</a>, the result will be
--   <a>Nothing</a>, as they are incomplete and hence their equality cannot
--   be known. (This is why there is no <a>Eq</a> instance for
--   <a>IResult</a>.)
compareResults :: (Eq i, Eq r) => IResult i r -> IResult i r -> Maybe Bool

-- | Run a parser.
parse :: Parser a -> ByteString -> Result a

-- | If a parser has returned a <a>Partial</a> result, supply it with more
--   input.
feed :: Monoid i => IResult i r -> i -> IResult i r

-- | Run a parser that cannot be resupplied via a <a>Partial</a> result.
--   
--   This function does not force a parser to consume all of its input.
--   Instead, any residual input will be discarded. To force a parser to
--   consume all of its input, use something like this:
--   
--   <pre>
--   <a>parseOnly</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
parseOnly :: Parser a -> ByteString -> Either String a

-- | Run a parser with an initial input string, and a monadic action that
--   can supply more input if needed.
parseWith :: Monad m => m ByteString -> Parser a -> ByteString -> m (Result a)

-- | Run a parser and print its result to standard output.
parseTest :: Show a => Parser a -> ByteString -> IO ()

-- | Convert a <a>Result</a> value to a <a>Maybe</a> value. A
--   <a>Partial</a> result is treated as failure.
maybeResult :: Result r -> Maybe r

-- | Convert a <a>Result</a> value to an <a>Either</a> value. A
--   <a>Partial</a> result is treated as failure.
eitherResult :: Result r -> Either String r

-- | Match a specific character.
char :: Char -> Parser Char

-- | Match a specific character, but return its <a>Word8</a> value.
char8 :: Char -> Parser Word8

-- | Match any character.
anyChar :: Parser Char

-- | Match any character except the given one.
notChar :: Char -> Parser Char

-- | The parser <tt>satisfy p</tt> succeeds for any byte for which the
--   predicate <tt>p</tt> returns <a>True</a>. Returns the byte that is
--   actually parsed.
--   
--   <pre>
--   digit = satisfy isDigit
--       where isDigit c = c &gt;= '0' &amp;&amp; c &lt;= '9'
--   </pre>
satisfy :: (Char -> Bool) -> Parser Char

-- | Match any character, to perform lookahead. Returns <a>Nothing</a> if
--   end of input has been reached. Does not consume any input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <tt>many</tt>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
peekChar :: Parser (Maybe Char)

-- | Match any character, to perform lookahead. Does not consume any input,
--   but will fail if end of input has been reached.
peekChar' :: Parser Char

-- | Parse a single digit.
digit :: Parser Char

-- | Match a letter, in the ISO-8859-15 encoding.
letter_iso8859_15 :: Parser Char

-- | Match a letter, in the ASCII encoding.
letter_ascii :: Parser Char

-- | Parse a space character.
--   
--   <i>Note</i>: This parser only gives correct answers for the ASCII
--   encoding. For instance, it does not recognise U+00A0 (non-breaking
--   space) as a space character, even though it is a valid ISO-8859-15
--   byte.
space :: Parser Char

-- | A fast digit predicate.
isDigit :: Char -> Bool

-- | A fast digit predicate.
isDigit_w8 :: Word8 -> Bool

-- | A fast alphabetic predicate for the ISO-8859-15 encoding
--   
--   <i>Note</i>: For all character encodings other than ISO-8859-15, and
--   almost all Unicode code points above U+00A3, this predicate gives
--   <i>wrong answers</i>.
isAlpha_iso8859_15 :: Char -> Bool

-- | A fast alphabetic predicate for the ASCII encoding
--   
--   <i>Note</i>: For all character encodings other than ASCII, and almost
--   all Unicode code points above U+007F, this predicate gives <i>wrong
--   answers</i>.
isAlpha_ascii :: Char -> Bool

-- | Fast predicate for matching ASCII space characters.
--   
--   <i>Note</i>: This predicate only gives correct answers for the ASCII
--   encoding. For instance, it does not recognise U+00A0 (non-breaking
--   space) as a space character, even though it is a valid ISO-8859-15
--   byte. For a Unicode-aware and only slightly slower predicate, use
--   <a>isSpace</a>
isSpace :: Char -> Bool

-- | Fast <a>Word8</a> predicate for matching ASCII space characters.
isSpace_w8 :: Word8 -> Bool

-- | Match any character in a set.
--   
--   <pre>
--   vowel = inClass "aeiou"
--   </pre>
--   
--   Range notation is supported.
--   
--   <pre>
--   halfAlphabet = inClass "a-nA-N"
--   </pre>
--   
--   To add a literal '-' to a set, place it at the beginning or end of the
--   string.
inClass :: String -> Char -> Bool

-- | Match any character not in a set.
notInClass :: String -> Char -> Bool

-- | <tt>string s</tt> parses a sequence of bytes that identically match
--   <tt>s</tt>. Returns the parsed string (i.e. <tt>s</tt>). This parser
--   consumes no input if it fails (even if a partial match).
--   
--   <i>Note</i>: The behaviour of this parser is different to that of the
--   similarly-named parser in Parsec, as this one is all-or-nothing. To
--   illustrate the difference, the following parser will fail under Parsec
--   given an input of <tt>"for"</tt>:
--   
--   <pre>
--   string "foo" &lt;|&gt; string "for"
--   </pre>
--   
--   The reason for its failure is that the first branch is a partial
--   match, and will consume the letters <tt>'f'</tt> and <tt>'o'</tt>
--   before failing. In attoparsec, the above parser will <i>succeed</i> on
--   that input, because the failed first branch will consume nothing.
string :: ByteString -> Parser ByteString

-- | Satisfy a literal string, ignoring case.
stringCI :: ByteString -> Parser ByteString

-- | Skip over white space.
skipSpace :: Parser ()

-- | Skip past input for as long as the predicate returns <a>True</a>.
skipWhile :: (Char -> Bool) -> Parser ()

-- | Consume exactly <tt>n</tt> bytes of input.
take :: Int -> Parser ByteString

-- | A stateful scanner. The predicate consumes and transforms a state
--   argument, and each transformed state is passed to successive
--   invocations of the predicate on each byte of the input until one
--   returns <a>Nothing</a> or the input ends.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>Nothing</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <tt>many</tt>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
scan :: s -> (s -> Char -> Maybe s) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>False</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <tt>many</tt>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeWhile :: (Char -> Bool) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>True</a>, and return
--   the consumed input.
--   
--   This parser requires the predicate to succeed on at least one byte of
--   input: it will fail if the predicate never returns <a>True</a> or if
--   there is no input left.
takeWhile1 :: (Char -> Bool) -> Parser ByteString

-- | Consume input as long as the predicate returns <a>False</a> (i.e.
--   until it returns <a>True</a>), and return the consumed input.
--   
--   This parser does not fail. It will return an empty string if the
--   predicate returns <a>True</a> on the first byte of input.
--   
--   <i>Note</i>: Because this parser does not fail, do not use it with
--   combinators such as <tt>many</tt>, because such parsers loop until a
--   failure occurs. Careless use will thus result in an infinite loop.
takeTill :: (Char -> Bool) -> Parser ByteString

-- | <i>Obsolete</i>. A type-specialized version of <a>*&gt;</a> for
--   <a>ByteString</a>. Use <a>*&gt;</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>*&gt;</a> instead.</i>
(.*>) :: ByteString -> Parser a -> Parser a

-- | <i>Obsolete</i>. A type-specialized version of <a>&lt;*</a> for
--   <a>ByteString</a>. Use <a>&lt;*</a> instead.

-- | <i>Deprecated: This is no longer necessary, and will be removed. Use
--   <a>&lt;*</a> instead.</i>
(<*.) :: Parser a -> ByteString -> Parser a

-- | Consume all remaining input and return it as a single string.
takeByteString :: Parser ByteString

-- | Consume all remaining input and return it as a single string.
takeLazyByteString :: Parser ByteString

-- | Match either a single newline character <tt>'\n'</tt>, or a carriage
--   return followed by a newline character <tt>"\r\n"</tt>.
endOfLine :: Parser ()

-- | A predicate that matches either a carriage return <tt>'\r'</tt> or
--   newline <tt>'\n'</tt> character.
isEndOfLine :: Word8 -> Bool

-- | A predicate that matches either a space <tt>' '</tt> or horizontal tab
--   <tt>'\t'</tt> character.
isHorizontalSpace :: Word8 -> Bool

-- | Parse and decode an unsigned decimal number.
decimal :: Integral a => Parser a

-- | Parse and decode an unsigned hexadecimal number. The hex digits
--   <tt>'a'</tt> through <tt>'f'</tt> may be upper or lower case.
--   
--   This parser does not accept a leading <tt>"0x"</tt> string.
hexadecimal :: (Integral a, Bits a) => Parser a

-- | Parse a number with an optional leading <tt>'+'</tt> or <tt>'-'</tt>
--   sign character.
signed :: Num a => Parser a -> Parser a

-- | Parse a <a>Double</a>.
--   
--   This parser accepts an optional leading sign character, followed by at
--   most one decimal digit. The syntax is similar to that accepted by the
--   <a>read</a> function, with the exception that a trailing <tt>'.'</tt>
--   is consumed.
--   
--   <h3>Examples</h3>
--   
--   These examples use this helper:
--   
--   <pre>
--   r :: <a>Parser</a> a -&gt; <a>ByteString</a> -&gt; <a>Result</a> a
--   r p s = <a>feed</a> (<a>parse</a> p s) <a>mempty</a>
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>, if you feed an empty
--   continuation to the first result:
--   
--   <pre>
--   double "3"     == Done "" 3.0
--   double "3.1"   == Done "" 3.1
--   double "3e4"   == Done "" 30000.0
--   double "3.1e4" == Done "" 31000.0
--   double "3e"    == Done "e" 3.0
--   </pre>
--   
--   Examples with behaviour identical to <a>read</a>:
--   
--   <pre>
--   double ".3"    == Fail ".3" _ _
--   double "e3"    == Fail "e3" _ _
--   </pre>
--   
--   Example of difference from <a>read</a>:
--   
--   <pre>
--   double "3.foo" == Done "foo" 3.0
--   </pre>
--   
--   This function does not accept string representations of "NaN" or
--   "Infinity".
double :: Parser Double

-- | A numeric type that can represent integers accurately, and floating
--   point numbers to the precision of a <a>Double</a>.
--   
--   <i>Note</i>: this type is deprecated, and will be removed in the next
--   major release. Use the <a>Scientific</a> type instead.
data Number
I :: !Integer -> Number
D :: {-# UNPACK #-} !Double -> Number

-- | Parse a number, attempting to preserve both speed and precision.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.

-- | <i>Deprecated: Use <a>scientific</a> instead.</i>
number :: Parser Number

-- | Parse a rational number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
--   
--   <i>Note</i>: this parser is not safe for use with inputs from
--   untrusted sources. An input with a suitably large exponent such as
--   <tt>"1e1000000000"</tt> will cause a huge <a>Integer</a> to be
--   allocated, resulting in what is effectively a denial-of-service
--   attack.
--   
--   In most cases, it is better to use <a>double</a> or <a>scientific</a>
--   instead.
rational :: Fractional a => Parser a

-- | Parse a scientific number.
--   
--   The syntax accepted by this parser is the same as for <a>double</a>.
scientific :: Parser Scientific

-- | Attempt a parse, and if it fails, rewind the input so that no input
--   appears to have been consumed.
--   
--   This combinator is provided for compatibility with Parsec. attoparsec
--   parsers always backtrack on failure.
try :: Parser i a -> Parser i a

-- | Name the parser, in case failure occurs.
(<?>) :: Parser i a -> String -> Parser i a
infix 0 <?>

-- | <tt>choice ps</tt> tries to apply the actions in the list <tt>ps</tt>
--   in order, until one of them succeeds. Returns the value of the
--   succeeding action.
choice :: Alternative f => [f a] -> f a

-- | Apply the given action repeatedly, returning every result.
count :: Monad m => Int -> m a -> m [a]

-- | <tt>option x p</tt> tries to apply action <tt>p</tt>. If <tt>p</tt>
--   fails without consuming input, it returns the value <tt>x</tt>,
--   otherwise the value returned by <tt>p</tt>.
--   
--   <pre>
--   priority  = option 0 (digitToInt &lt;$&gt; digit)
--   </pre>
option :: Alternative f => a -> f a -> f a

-- | <tt>many' p</tt> applies the action <tt>p</tt> <i>zero</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many' letter
--   </pre>
many' :: MonadPlus m => m a -> m [a]

-- | <tt>many1 p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>.
--   
--   <pre>
--   word  = many1 letter
--   </pre>
many1 :: Alternative f => f a -> f [a]

-- | <tt>many1' p</tt> applies the action <tt>p</tt> <i>one</i> or more
--   times. Returns a list of the returned values of <tt>p</tt>. The value
--   returned by <tt>p</tt> is forced to WHNF.
--   
--   <pre>
--   word  = many1' letter
--   </pre>
many1' :: MonadPlus m => m a -> m [a]

-- | <tt>manyTill p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
manyTill :: Alternative f => f a -> f b -> f [a]

-- | <tt>manyTill' p end</tt> applies action <tt>p</tt> <i>zero</i> or more
--   times until action <tt>end</tt> succeeds, and returns the list of
--   values returned by <tt>p</tt>. This can be used to scan comments:
--   
--   <pre>
--   simpleComment   = string "&lt;!--" *&gt; manyTill' anyChar (string "--&gt;")
--   </pre>
--   
--   (Note the overlapping parsers <tt>anyChar</tt> and <tt>string
--   "--&gt;"</tt>. While this will work, it is not very efficient, as it
--   will cause a lot of backtracking.)
--   
--   The value returned by <tt>p</tt> is forced to WHNF.
manyTill' :: MonadPlus m => m a -> m b -> m [a]

-- | <tt>sepBy p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy` (char ',')
--   </pre>
sepBy :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy' p sep</tt> applies <i>zero</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy'` (char ',')
--   </pre>
sepBy' :: MonadPlus m => m a -> m s -> m [a]

-- | <tt>sepBy1 p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>.
--   
--   <pre>
--   commaSep p  = p `sepBy1` (char ',')
--   </pre>
sepBy1 :: Alternative f => f a -> f s -> f [a]

-- | <tt>sepBy1' p sep</tt> applies <i>one</i> or more occurrences of
--   <tt>p</tt>, separated by <tt>sep</tt>. Returns a list of the values
--   returned by <tt>p</tt>. The value returned by <tt>p</tt> is forced to
--   WHNF.
--   
--   <pre>
--   commaSep p  = p `sepBy1'` (char ',')
--   </pre>
sepBy1' :: MonadPlus m => m a -> m s -> m [a]

-- | Skip zero or more instances of an action.
skipMany :: Alternative f => f a -> f ()

-- | Skip one or more instances of an action.
skipMany1 :: Alternative f => f a -> f ()

-- | Combine two alternatives.
eitherP :: Alternative f => f a -> f b -> f (Either a b)

-- | Return both the result of a parse and the portion of the input that
--   was consumed while it was being parsed.
match :: Parser a -> Parser (ByteString, a)

-- | Match only if all input has been consumed.
endOfInput :: forall t. Chunk t => Parser t ()

-- | Return an indication of whether the end of input has been reached.
atEnd :: Chunk t => Parser t Bool
instance (a GHC.Types.~ Data.ByteString.Internal.Type.ByteString) => Data.String.IsString (Data.Attoparsec.ByteString.Internal.Parser a)


-- | Simple, efficient, character-oriented combinator parsing for
--   <a>ByteString</a> strings, loosely based on the Parsec library.
--   
--   This module is deprecated. Use <a>Data.Attoparsec.ByteString.Char8</a>
--   instead.

-- | <i>Deprecated: This module will be removed in the next major
--   release.</i>
module Data.Attoparsec.Char8


-- | Simple, efficient combinator parsing for <a>ByteString</a> strings,
--   loosely based on the Parsec library.
--   
--   This module is deprecated. Use <a>Data.Attoparsec.ByteString</a>
--   instead.

-- | <i>Deprecated: This module will be removed in the next major
--   release.</i>
module Data.Attoparsec
