-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optics construction using TemplateHaskell
--   
--   This package is part of the <tt><a>optics</a></tt> package family. It
--   provides machinery to construct optics using <tt>TemplateHaskell</tt>.
--   
--   See the <tt>template-haskell-optics</tt> package for optics to work
--   with <tt>template-haskell</tt> types.
@package optics-th
@version 0.4.1

module Optics.TH.Internal.Utils

-- | Apply arguments to a type constructor
appsT :: TypeQ -> [TypeQ] -> TypeQ

-- | Apply arguments to a function
appsE1 :: ExpQ -> [ExpQ] -> ExpQ

-- | Construct a tuple type given a list of types.
toTupleT :: [TypeQ] -> TypeQ

-- | Construct a tuple value given a list of expressions.
toTupleE :: [ExpQ] -> ExpQ

-- | Construct a tuple pattern given a list of patterns.
toTupleP :: [PatQ] -> PatQ

-- | Apply arguments to a type constructor.
conAppsT :: Name -> [Type] -> Type

-- | Generate many new names from a given base name.
newNames :: String -> Int -> Q [Name]
eqSubst :: Type -> String -> Q (Type, Pred)
addKindInfo :: DatatypeInfo -> Type -> Type

-- | Fill in kind variables using info from datatype type parameters.
addKindInfo' :: [Type] -> DatatypeInfo -> Type -> Type

-- | Template Haskell wants type variables declared in a forall, so we find
--   all free type variables in a given type and declare them.
quantifyType :: [TyVarBndrSpec] -> Cxt -> Type -> Type

-- | This function works like <a>quantifyType</a> except that it takes a
--   list of variables to exclude from quantification.
quantifyType' :: Set Name -> [TyVarBndrSpec] -> Cxt -> Type -> Type

-- | Transform <a>TyVarBndr</a> into a <a>Type</a> so it's suitable e.g.
--   for freeVariablesWellScoped or type substitution.
tyVarBndrToType :: TyVarBndr_ flag -> Type

-- | Pass in a list of lists of extensions, where any of the given
--   extensions will satisfy it. For example, you might need either GADTs
--   or ExistentialQuantification, so you'd write:
--   
--   <pre>
--   requireExtensions [[GADTs, ExistentialQuantification]]
--   </pre>
--   
--   But if you need TypeFamilies and MultiParamTypeClasses, then you'd
--   write:
--   
--   <pre>
--   requireExtensions [[TypeFamilies], [MultiParamTypeClasses]]
--   </pre>
requireExtensions :: String -> [[Extension]] -> Q ()
requireExtensionsForLabels :: Q ()
requireExtensionsForFields :: Q ()
inlinePragma :: Name -> [DecQ]

module Optics.TH.Internal.Sum

-- | Generate a <a>Prism</a> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ
makePrismLabels :: Name -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz % _Foo
--     _Bar = _FooBarBaz % _Bar
--     _Baz = _FooBarBaz % _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
makeClassyPrisms :: Name -> DecsQ

-- | Generate prisms for the given <a>Dec</a>
makeDecPrisms :: Bool -> Dec -> DecsQ
instance GHC.Classes.Eq Optics.TH.Internal.Sum.OpticType
instance GHC.Show.Show Optics.TH.Internal.Sum.NCon
instance GHC.Classes.Eq Optics.TH.Internal.Sum.NCon
instance Language.Haskell.TH.Optics.Internal.HasTypeVars Optics.TH.Internal.Sum.NCon

module Optics.TH.Internal.Product

-- | Rules to construct lenses for data fields.
data LensRules
LensRules :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> FieldNamer -> ClassyNamer -> LensRules
[_simpleLenses] :: LensRules -> Bool
[_generateSigs] :: LensRules -> Bool
[_generateClasses] :: LensRules -> Bool
[_allowIsos] :: LensRules -> Bool

-- | Allow Lens<i>Traversal (otherwise Getter</i>Fold)
[_allowUpdates] :: LensRules -> Bool
[_lazyPatterns] :: LensRules -> Bool

-- | Type Name -&gt; Field Names -&gt; Target Field Name -&gt; Definition
--   Names
[_fieldToDef] :: LensRules -> FieldNamer
[_classyLenses] :: LensRules -> ClassyNamer

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of all fields (including the field being named) in the data type. [Name] -> -- | Name of the field being named. Name -> -- | Name(s) of the lens functions. If empty, no lens is created for that field. [DefName]

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definition name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of the class and the main method it generates, respectively. Maybe (Name, Name)

-- | Compute the field optics for the type identified by the given type
--   name. Lenses will be computed when possible, Traversals otherwise.
makeFieldOptics :: LensRules -> Name -> DecsQ
makeFieldOpticsForDec :: LensRules -> Dec -> DecsQ
makeFieldOpticsForDec' :: LensRules -> Dec -> HasFieldClasses [Dec]

-- | Build field optics as labels with a custom configuration.
makeFieldLabelsWith :: LensRules -> Name -> DecsQ
makeFieldLabelsForDec :: LensRules -> Dec -> DecsQ

-- | Tracks the field class <a>Name</a>s that have been created so far. We
--   consult these so that we may avoid creating duplicate classes.
type HasFieldClasses = StateT (Set Name) Q
instance GHC.Show.Show Optics.TH.Internal.Product.OpticType
instance GHC.Show.Show Optics.TH.Internal.Product.OpticStab
instance GHC.Classes.Ord Optics.TH.Internal.Product.DefName
instance GHC.Classes.Eq Optics.TH.Internal.Product.DefName
instance GHC.Show.Show Optics.TH.Internal.Product.DefName

module Optics.TH

-- | Build field optics as instances of the <a>LabelOptic</a> class for use
--   with overloaded labels. See <a>Optics.Label</a> for how to use this
--   pattern.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Animal
--     = Cat { animalAge  :: Int
--           , animalName :: String
--           }
--     | Dog { animalAge    :: Int
--           , animalAbsurd :: forall a b. a -&gt; b
--           }
--   makeFieldLabels ''Animal
--   </pre>
--   
--   will create
--   
--   <pre>
--   instance
--     (k ~ A_Lens, a ~ Int, b ~ Int
--     ) =&gt; LabelOptic "age" k Animal Animal a b where
--     labelOptic = lensVL $ \f s -&gt; case s of
--       Cat x1 x2 -&gt; fmap (\y -&gt; Cat y x2) (f x1)
--       Dog x1 x2 -&gt; fmap (\y -&gt; Dog y x2) (f x1)
--   
--   instance
--     (k ~ An_AffineTraversal, a ~ String, b ~ String
--     ) =&gt; LabelOptic "name" k Animal Animal a b where
--     labelOptic = atraversalVL $ \point f s -&gt; case s of
--       Cat x1 x2 -&gt; fmap (\y -&gt; Cat x1 y) (f x2)
--       Dog x1 x2 -&gt; point (Dog x1 x2)
--   
--   instance
--     ( Dysfunctional "absurd" k Animal Animal a b
--     , k ~ An_AffineFold, a ~ (x -&gt; y), b ~ (x -&gt; y)
--     ) =&gt; LabelOptic "absurd" k Animal Animal a b where
--     labelOptic = afolding $ \s -&gt; case s of
--       Cat _ _  -&gt; Nothing
--       Dog _ f  -&gt; Just f
--   </pre>
--   
--   which can be used as <tt>#age</tt>, <tt>#name</tt> and
--   <tt>#absurd</tt> with the <tt>OverloadedLabels</tt> language
--   extension.
--   
--   <i>Note:</i> if you wonder about the structure of instances, see
--   <a>Optics.Label#structure</a>.
--   
--   <pre>
--   <a>makeFieldOptics</a> = <a>makeFieldLabelsWith</a> <a>fieldLabelsRules</a>
--   </pre>
makeFieldLabels :: Name -> DecsQ

-- | An alias for <tt>makeFieldLabels noPrefixFieldLabels</tt>.
makeFieldLabelsNoPrefix :: Name -> DecsQ

-- | Derive field optics as labels, specifying explicit pairings of
--   <tt>(fieldName, labelName)</tt>.
--   
--   If you map multiple fields to the same label and it is present in the
--   same constructor, <a>Traversal</a> (or <a>Fold</a> for a read only
--   version) will be generated.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeFieldLabelsFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeFieldLabelsFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeFieldLabelsFor :: [(String, String)] -> Name -> DecsQ

-- | Build field optics as labels with a custom configuration.
makeFieldLabelsWith :: LensRules -> Name -> DecsQ

-- | Make field optics as labels for all records in the given declaration
--   quote. All record syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Dog = Dog { name :: String, age :: Int }
--       deriving Show
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Dog = Dog String Int
--     deriving Show
--   instance (k ~ A_Lens, ...) =&gt; LabelOptic "name" k Dog Dog ...
--   instance (k ~ A_Lens, ...) =&gt; LabelOptic "age" k Dog Dog ...
--   </pre>
declareFieldLabels :: DecsQ -> DecsQ

-- | Similar to <a>makeFieldLabelsFor</a>, but takes a declaration quote.
declareFieldLabelsFor :: [(String, String)] -> DecsQ -> DecsQ
declareFieldLabelsWith :: LensRules -> DecsQ -> DecsQ

-- | Rules for generation of <a>LabelOptic</a> instances for use with
--   OverloadedLabels. Same as <a>lensRules</a>, but uses
--   <a>camelCaseNamer</a>.
--   
--   <i>Note:</i> if you don't want to prefix field names with the full
--   name of the data type, you can use <a>abbreviatedNamer</a> instead.
fieldLabelsRules :: LensRules

-- | Construct a <a>LensRules</a> value for generating <a>LabelOptic</a>
--   instances using the given map from field names to definition names.
fieldLabelsRulesFor :: [(String, String)] -> LensRules

-- | Build field optics as top level functions with a sensible default
--   configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Animal
--     = Cat { _age  :: <a>Int</a>
--           , _name :: <a>String</a>
--           }
--     | Dog { _age    :: <a>Int</a>
--           , _absurd :: forall a b. a -&gt; b
--           }
--   <a>makeLenses</a> ''Animal
--   </pre>
--   
--   will create
--   
--   <pre>
--   absurd :: forall a b. AffineFold Animal (a -&gt; b)
--   absurd = afolding $ \s -&gt; case s of
--     Cat _ _ -&gt; Nothing
--     Dog _ x -&gt; Just x
--   
--   age :: Lens' Animal Int
--   age = lensVL $ \f s -&gt; case s of
--     Cat x1 x2 -&gt; fmap (\y -&gt; Cat y x2) (f x1)
--     Dog x1 x2 -&gt; fmap (\y -&gt; Dog y x2) (f x1)
--   
--   name :: AffineTraversal' Animal String
--   name = atraversalVL $ \point f s -&gt; case s of
--     Cat x1 x2 -&gt; fmap (\y -&gt; Cat x1 y) (f x2)
--     Dog x1 x2 -&gt; point (Dog x1 x2)
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | Derive field optics, specifying explicit pairings of <tt>(fieldName,
--   opticName)</tt>.
--   
--   If you map multiple fields to the same optic and it is present in the
--   same constructor, <a>Traversal</a> (or <a>Fold</a> for a read only
--   version) will be generated.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   <a>makeLensesFor</a> [("_foo", "fooLens"), ("baz", "lbaz")] ''Foo
--   <a>makeLensesFor</a> [("_barX", "bar"), ("_barY", "bar")] ''Bar
--   </pre>
makeLensesFor :: [(String, String)] -> Name -> DecsQ

-- | Build field optics with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ

-- | Make field optics for all records in the given declaration quote. All
--   record syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareLenses [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   fooX, fooY :: <a>Lens'</a> Foo Int
--   </pre>
declareLenses :: DecsQ -> DecsQ

-- | Similar to <a>makeLensesFor</a>, but takes a declaration quote.
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ

-- | <a>declareLenses</a> with custom <a>LensRules</a>.
declareLensesWith :: LensRules -> DecsQ -> DecsQ

-- | Rules for making read-write field optics as top-level functions. It
--   uses <a>underscoreNoPrefixNamer</a>.
lensRules :: LensRules

-- | Construct a <a>LensRules</a> value for generating top-level functions
--   using the given map from field names to definition names.
lensRulesFor :: [(String, String)] -> LensRules

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data Foo = Foo { _fooX, _fooY :: <a>Int</a> }
--   <a>makeClassy</a> ''Foo
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasFoo c where
--     foo  :: Lens' c Foo
--     fooX :: Lens' c Int
--     fooY :: Lens' c Int
--     fooX = foo % fooX
--     fooY = foo % fooY
--   
--   instance HasFoo Foo where
--     foo  = lensVL id
--     fooX = lensVL $ \f s -&gt; case s of
--       Foo x1 x2 -&gt; fmap (\y -&gt; Foo y x2) (f x1)
--     fooY = lensVL $ \f s -&gt; case s of
--       Foo x1 x2 -&gt; fmap (\y -&gt; Foo x1 y) (f x2)
--   </pre>
--   
--   <pre>
--   <a>makeClassy</a> = <a>makeLensesWith</a> <a>classyRules</a>
--   </pre>
makeClassy :: Name -> DecsQ

-- | Make lenses and traversals for a type, and create a class when the
--   type has no arguments. Works the same as <a>makeClassy</a> except that
--   (a) it expects that record field names do not begin with an
--   underscore, (b) all record fields are made into lenses, and (c) the
--   resulting lens is prefixed with an underscore.
makeClassy_ :: Name -> DecsQ

-- | Derive lenses and traversals, using a named wrapper class, and
--   specifying explicit pairings of <tt>(fieldName, traversalName)</tt>.
--   
--   Example usage:
--   
--   <pre>
--   <a>makeClassyFor</a> "HasFoo" "foo" [("_foo", "fooLens"), ("bar", "lbar")] ''Foo
--   </pre>
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ

-- | For each record in the declaration quote, make lenses and traversals
--   for it, and create a class when the type has no arguments. All record
--   syntax in the input will be stripped off.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declareClassy [d|
--     data Foo = Foo { fooX, fooY :: <a>Int</a> }
--       deriving <a>Show</a>
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Foo = Foo <a>Int</a> <a>Int</a> deriving <a>Show</a>
--   class HasFoo t where
--     foo :: <a>Lens'</a> t Foo
--   instance HasFoo Foo where foo = <a>id</a>
--   fooX, fooY :: HasFoo t =&gt; <a>Lens'</a> t <a>Int</a>
--   </pre>
declareClassy :: DecsQ -> DecsQ

-- | Similar to <a>makeClassyFor</a>, but takes a declaration quote.
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a>.
classyRules :: LensRules

-- | A <a>LensRules</a> used by <a>makeClassy_</a>.
classyRules_ :: LensRules

-- | Rules for making lenses and traversals that precompose another
--   <a>Lens</a> using a custom function for naming the class, main class
--   method, and a mapping from field names to definition names.
classyRulesFor :: (String -> Maybe (String, String)) -> [(String, String)] -> LensRules

-- | Generate overloaded field accessors.
--   
--   <i>e.g</i>
--   
--   <pre>
--   data Foo a = Foo { _fooX :: <a>Int</a>, _fooY :: a }
--   newtype Bar = Bar { _barX :: <a>Char</a> }
--   makeFields ''Foo
--   makeFields ''Bar
--   </pre>
--   
--   will create
--   
--   <pre>
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   
--   instance HasX (Foo a) Int where
--     x = lensVL $ \f s -&gt; case s of
--       Foo x1 x2 -&gt; fmap (\y -&gt; Foo y x2) (f x1)
--   
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   
--   instance HasY (Foo a) a where
--     y = lensVL $ \f s -&gt; case s of
--       Foo x1 x2 -&gt; fmap (\y -&gt; Foo x1 y) (f x2)
--   
--   instance HasX Bar Char where
--     x = lensVL $ \f s -&gt; case s of
--       Bar x1 -&gt; fmap (\y -&gt; Bar y) (f x1)
--   </pre>
--   
--   For details, see <a>camelCaseFields</a>.
--   
--   <pre>
--   makeFields = <a>makeLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
makeFields :: Name -> DecsQ

-- | Generate overloaded field accessors based on field names which are
--   only prefixed with an underscore (e.g. <tt>_name</tt>), not
--   additionally with the type name (e.g. <tt>_fooName</tt>).
--   
--   This might be the desired behaviour in case the
--   <tt>DuplicateRecordFields</tt> language extension is used in order to
--   get rid of the necessity to prefix each field name with the type name.
--   
--   As an example:
--   
--   <pre>
--   data Foo a  = Foo { _x :: <a>Int</a>, _y :: a }
--   newtype Bar = Bar { _x :: <a>Char</a> }
--   makeFieldsNoPrefix ''Foo
--   makeFieldsNoPrefix ''Bar
--   </pre>
--   
--   will create classes
--   
--   <pre>
--   class HasX s a | s -&gt; a where
--     x :: Lens' s a
--   class HasY s a | s -&gt; a where
--     y :: Lens' s a
--   </pre>
--   
--   together with instances
--   
--   <pre>
--   instance HasX (Foo a) Int
--   instance HasY (Foo a) a where
--   instance HasX Bar Char where
--   </pre>
--   
--   For details, see <a>classUnderscoreNoPrefixFields</a>.
--   
--   <pre>
--   makeFieldsNoPrefix = <a>makeLensesWith</a> <a>classUnderscoreNoPrefixFields</a>
--   </pre>
makeFieldsNoPrefix :: Name -> DecsQ

-- | <pre>
--   declareFields = <a>declareLensesWith</a> <a>defaultFieldRules</a>
--   </pre>
declareFields :: DecsQ -> DecsQ
defaultFieldRules :: LensRules
makePrismLabels :: Name -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of a data type. Isos
--   generated when possible. Reviews are created for constructors with
--   existentially quantified constructors and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makePrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   _Foo :: Prism' (FooBarBaz a) Int
--   _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b
--   _Baz :: Prism' (FooBarBaz a) (Int, Char)
--   </pre>
makePrisms :: Name -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of each data type.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   declarePrisms [d|
--     data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }
--     |]
--   </pre>
--   
--   will create
--   
--   <pre>
--   data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }
--   _Lit :: <a>Prism'</a> Exp Int
--   _Var :: <a>Prism'</a> Exp String
--   _Lambda :: <a>Prism'</a> Exp (String, Exp)
--   </pre>
declarePrisms :: DecsQ -> DecsQ

-- | Generate a <a>Prism</a> for each constructor of a data type and
--   combine them into a single class. No Isos are created. Reviews are
--   created for constructors with existentially quantified constructors
--   and GADTs.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBarBaz a
--     = Foo Int
--     | Bar a
--     | Baz Int Char
--   makeClassyPrisms ''FooBarBaz
--   </pre>
--   
--   will create
--   
--   <pre>
--   class AsFooBarBaz s a | s -&gt; a where
--     _FooBarBaz :: Prism' s (FooBarBaz a)
--     _Foo :: Prism' s Int
--     _Bar :: Prism' s a
--     _Baz :: Prism' s (Int,Char)
--   
--     _Foo = _FooBarBaz % _Foo
--     _Bar = _FooBarBaz % _Bar
--     _Baz = _FooBarBaz % _Baz
--   
--   instance AsFooBarBaz (FooBarBaz a) a
--   </pre>
--   
--   Generate an <a>As</a> class of prisms. Names are selected by prefixing
--   the constructor name with an underscore. Constructors with multiple
--   fields will construct Prisms to tuples of those fields.
makeClassyPrisms :: Name -> DecsQ

-- | Rules to construct lenses for data fields.
data LensRules

-- | Generate "simple" optics even when type-changing optics are possible.
--   (e.g. <a>Lens'</a> instead of <a>Lens</a>)
simpleLenses :: Lens' LensRules Bool

-- | Indicate whether or not to supply the signatures for the generated
--   lenses.
--   
--   Disabling this can be useful if you want to provide a more restricted
--   type signature or if you want to supply hand-written haddocks.
generateSignatures :: Lens' LensRules Bool

-- | Generate "updateable" optics when <a>True</a>. When <a>False</a>,
--   (affine) folds will be generated instead of (affine) traversals and
--   getters will be generated instead of lenses. This mode is intended to
--   be used for types with invariants which must be maintained by "smart"
--   constructors.
generateUpdateableOptics :: Lens' LensRules Bool

-- | Generate optics using lazy pattern matches. This can allow fields of
--   an undefined value to be initialized with lenses:
--   
--   <pre>
--   data Foo = Foo {_x :: Int, _y :: Bool}
--     deriving Show
--   
--   <a>makeLensesWith</a> (<a>lensRules</a> &amp; <a>generateLazyPatterns</a> .~ True) ''Foo
--   </pre>
--   
--   <pre>
--   &gt; undefined &amp; x .~ 8 &amp; y .~ True
--   Foo {_x = 8, _y = True}
--   </pre>
--   
--   The downside of this flag is that it can lead to space-leaks and
--   code-size/compile-time increases when generated for large records. By
--   default this flag is turned off, and strict optics are generated.
--   
--   When using lazy optics the strict optic can be recovered by composing
--   with <a>equality'</a>:
--   
--   <pre>
--   strictOptic = equality' % lazyOptic
--   </pre>
generateLazyPatterns :: Lens' LensRules Bool

-- | Create the class if the constructor if generated lenses would be
--   type-preserving and the <a>lensClass</a> rule matches.
createClass :: Lens' LensRules Bool

-- | <a>Lens'</a> to access the convention for naming fields in our
--   <a>LensRules</a>.
lensField :: Lens' LensRules FieldNamer

-- | <a>Lens'</a> to access the option for naming "classy" lenses.
lensClass :: Lens' LensRules ClassyNamer

-- | Field rules for fields without any prefix. Useful for generation of
--   field labels when paired with <tt>DuplicateRecordFields</tt> language
--   extension so that no prefixes for field names are necessary.
noPrefixFieldLabels :: LensRules
abbreviatedFieldLabels :: LensRules

-- | Field rules for fields in the form <tt> _prefix_fieldname </tt>
underscoreFields :: LensRules

-- | Field rules for fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt>
--   
--   If you want all fields to be lensed, then there is no reason to use an
--   <tt>_</tt> before the prefix. If any of the record fields leads with
--   an <tt>_</tt> then it is assume a field without an <tt>_</tt> should
--   not have a lens created.
--   
--   <b>Note</b>: The <tt>prefix</tt> must be the same as the typename
--   (with the first letter lowercased). This is a change from lens
--   versions before lens 4.5. If you want the old behaviour, use
--   <a>makeLensesWith</a> <a>abbreviatedFields</a>
camelCaseFields :: LensRules

-- | Field rules for fields in the form <tt> _fieldname </tt> (the leading
--   underscore is mandatory).
--   
--   <b>Note</b>: The primary difference to <a>camelCaseFields</a> is that
--   for <tt>classUnderscoreNoPrefixFields</tt> the field names are not
--   expected to be prefixed with the type name. This might be the desired
--   behaviour when the <tt>DuplicateRecordFields</tt> extension is
--   enabled.
classUnderscoreNoPrefixFields :: LensRules

-- | Field rules fields in the form <tt> prefixFieldname or
--   _prefixFieldname </tt> If you want all fields to be lensed, then there
--   is no reason to use an <tt>_</tt> before the prefix. If any of the
--   record fields leads with an <tt>_</tt> then it is assume a field
--   without an <tt>_</tt> should not have a lens created.
--   
--   Note that <tt>prefix</tt> may be any string of characters that are not
--   uppercase letters. (In particular, it may be arbitrary string of
--   lowercase letters and numbers) This is the behavior that
--   <a>defaultFieldRules</a> had in lens 4.4 and earlier.
abbreviatedFields :: LensRules

-- | The rule to create function names of lenses for data fields.
--   
--   Although it's sometimes useful, you won't need the first two arguments
--   most of the time.
type FieldNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of all fields (including the field being named) in the data type. [Name] -> -- | Name of the field being named. Name -> -- | Name(s) of the lens functions. If empty, no lens is created for that field. [DefName]

-- | The optional rule to create a class and method around a monomorphic
--   data type. If this naming convention is provided, it generates a
--   "classy" lens.
type ClassyNamer = -- | Name of the data type that lenses are being generated for. Name -> -- | Names of the class and the main method it generates, respectively. Maybe (Name, Name)

-- | Name to give to generated field optics.
data DefName

-- | Simple top-level definition name
TopName :: Name -> DefName

-- | makeFields-style class name and method name
MethodName :: Name -> Name -> DefName

-- | A <a>FieldNamer</a> that leaves the field name as-is. Useful for
--   generation of field labels when paired with
--   <tt>DuplicateRecordFields</tt> language extension so that no prefixes
--   for field names are necessary.
noPrefixNamer :: FieldNamer

-- | A <a>FieldNamer</a> that strips the _ off of the field name,
--   lowercases the name, and skips the field if it doesn't start with an
--   '_'.
underscoreNoPrefixNamer :: FieldNamer

-- | Create a <a>FieldNamer</a> from explicit pairings of <tt>(fieldName,
--   lensName)</tt>.
lookingupNamer :: [(String, String)] -> FieldNamer

-- | Create a <a>FieldNamer</a> from a mapping function. If the function
--   returns <tt>[]</tt>, it creates no lens for the field.
mappingNamer :: (String -> [String]) -> FieldNamer

-- | A <a>FieldNamer</a> for <a>underscoreFields</a>.
underscoreNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>camelCaseFields</a>.
camelCaseNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>classUnderscoreNoPrefixFields</a>.
classUnderscoreNoPrefixNamer :: FieldNamer

-- | A <a>FieldNamer</a> for <a>abbreviatedFields</a>.
abbreviatedNamer :: FieldNamer
