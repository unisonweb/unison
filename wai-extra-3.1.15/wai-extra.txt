-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides some basic WAI handlers and middleware.
--   
--   Provides basic WAI handler and middleware functionality:
--   
--   <ul>
--   <li>WAI Testing Framework</li>
--   </ul>
--   
--   Hspec testing facilities and helpers for WAI.
--   
--   <ul>
--   <li>Event Source/Event Stream</li>
--   </ul>
--   
--   Send server events to the client. Compatible with the JavaScript
--   EventSource API.
--   
--   <ul>
--   <li>Accept Override</li>
--   </ul>
--   
--   Override the Accept header in a request. Special handling for the
--   _accept query parameter (which is used throughout WAI override the
--   Accept header).
--   
--   <ul>
--   <li>Add Headers</li>
--   </ul>
--   
--   WAI Middleware for adding arbitrary headers to an HTTP request.
--   
--   <ul>
--   <li>Clean Path</li>
--   </ul>
--   
--   Clean a request path to a canonical form.
--   
--   <ul>
--   <li>Combine Headers</li>
--   </ul>
--   
--   Combine duplicate headers into one.
--   
--   <ul>
--   <li>GZip Compression</li>
--   </ul>
--   
--   Negotiate HTTP payload gzip compression.
--   
--   <ul>
--   <li>Health check endpoint</li>
--   </ul>
--   
--   Add an empty health check endpoint.
--   
--   <ul>
--   <li>HTTP Basic Authentication</li>
--   </ul>
--   
--   WAI Basic Authentication Middleware which uses Authorization header.
--   
--   <ul>
--   <li>JSONP</li>
--   </ul>
--   
--   "JSON with Padding" middleware. Automatic wrapping of JSON responses
--   to convert into JSONP.
--   
--   <ul>
--   <li>Method Override / Post</li>
--   </ul>
--   
--   Allows overriding of the HTTP request method via the _method query
--   string parameter.
--   
--   <ul>
--   <li>Request Logging</li>
--   </ul>
--   
--   Request logging middleware for development and production environments
--   
--   <ul>
--   <li>Request Rewrite</li>
--   </ul>
--   
--   Rewrite request path info based on a custom conversion rules.
--   
--   <ul>
--   <li>Select</li>
--   </ul>
--   
--   Dynamically choose between Middlewares.
--   
--   <ul>
--   <li>Stream Files</li>
--   </ul>
--   
--   Convert ResponseFile type responses into ResponseStream type.
--   
--   <ul>
--   <li>Virtual Host</li>
--   </ul>
--   
--   Redirect incoming requests to a new host based on custom rules.
--   
--   API docs and the README are available at
--   <a>http://www.stackage.org/package/wai-extra</a>.
@package wai-extra
@version 3.1.15


-- | Internal module, usually you don't need to use it.
module Network.Wai.EventSource.EventStream

-- | Type representing a communication over an event stream. This can be an
--   actual event, a comment, a modification to the retry timer, or a
--   special "close" event indicating the server should close the
--   connection.
data ServerEvent
ServerEvent :: Maybe Builder -> Maybe Builder -> [Builder] -> ServerEvent
[eventName] :: ServerEvent -> Maybe Builder
[eventId] :: ServerEvent -> Maybe Builder
[eventData] :: ServerEvent -> [Builder]
CommentEvent :: Builder -> ServerEvent
[eventComment] :: ServerEvent -> Builder
RetryEvent :: Int -> ServerEvent
[eventRetry] :: ServerEvent -> Int
CloseEvent :: ServerEvent

-- | Converts a <a>ServerEvent</a> to its wire representation as specified
--   by the <tt>text/event-stream</tt> content type.
eventToBuilder :: ServerEvent -> Maybe Builder


-- | A WAI adapter to the HTML5 Server-Sent Events API.
--   
--   If running through a proxy like Nginx you might need to add the
--   headers:
--   
--   <pre>
--   [ ("X-Accel-Buffering", "no"), ("Cache-Control", "no-cache")]
--   </pre>
--   
--   There is a small example using these functions in the <tt>example</tt>
--   directory.
module Network.Wai.EventSource

-- | Type representing a communication over an event stream. This can be an
--   actual event, a comment, a modification to the retry timer, or a
--   special "close" event indicating the server should close the
--   connection.
data ServerEvent
ServerEvent :: Maybe Builder -> Maybe Builder -> [Builder] -> ServerEvent
[eventName] :: ServerEvent -> Maybe Builder
[eventId] :: ServerEvent -> Maybe Builder
[eventData] :: ServerEvent -> [Builder]
CommentEvent :: Builder -> ServerEvent
[eventComment] :: ServerEvent -> Builder
RetryEvent :: Int -> ServerEvent
[eventRetry] :: ServerEvent -> Int
CloseEvent :: ServerEvent

-- | Make a new WAI EventSource application reading events from the given
--   channel.
eventSourceAppChan :: Chan ServerEvent -> Application

-- | Make a new WAI EventSource application reading events from the given
--   IO action.
eventSourceAppIO :: IO ServerEvent -> Application

-- | Make a new WAI EventSource application with a handler that emits
--   events.
eventStreamAppRaw :: ((ServerEvent -> IO ()) -> IO () -> IO ()) -> Application


-- | Backend for Common Gateway Interface. Almost all users should use the
--   <a>run</a> function.
module Network.Wai.Handler.CGI

-- | Run an application using CGI.
run :: Application -> IO ()

-- | Some web servers provide an optimization for sending files via a
--   sendfile system call via a special header. To use this feature,
--   provide that header name here.
runSendfile :: ByteString -> Application -> IO ()

-- | A generic CGI helper, which allows other backends (FastCGI and SCGI)
--   to use the same code as CGI. Most users will not need this function,
--   and can stick with <a>run</a> or <a>runSendfile</a>.
runGeneric :: [(String, String)] -> (Int -> IO (IO ByteString)) -> (ByteString -> IO ()) -> Maybe ByteString -> Application -> IO ()
requestBodyFunc :: (Int -> IO (Maybe ByteString)) -> Int -> IO (IO ByteString)

module Network.Wai.Handler.SCGI
run :: Application -> IO ()
runSendfile :: ByteString -> Application -> IO ()


-- | Since 3.0.3
module Network.Wai.Middleware.AddHeaders

-- | Prepend a list of headers without any checks
--   
--   Since 3.0.3
addHeaders :: [(ByteString, ByteString)] -> Middleware


-- | Automatically produce responses to HEAD requests based on the
--   underlying applications GET response.
module Network.Wai.Middleware.Autohead
autohead :: Middleware

module Network.Wai.Middleware.CleanPath
cleanPath :: ([Text] -> Either ByteString [Text]) -> ByteString -> ([Text] -> Application) -> Application


-- | Add empty endpoint (for Health check tests)
module Network.Wai.Middleware.HealthCheckEndpoint

-- | Add empty endpoint (for Health check tests) called "/_healthz"
healthCheck :: Middleware

-- | Add empty endpoint
voidEndpoint :: ByteString -> Middleware


-- | Implements HTTP Basic Authentication.
--   
--   This module may add digest authentication in the future.
module Network.Wai.Middleware.HttpAuth

-- | Perform basic authentication.
--   
--   <pre>
--   basicAuth (\u p -&gt; return $ u == "michael" &amp;&amp; p == "mypass") "My Realm"
--   </pre>
basicAuth :: CheckCreds -> AuthSettings -> Middleware

-- | Like <a>basicAuth</a>, but also passes a request to the authentication
--   function.
basicAuth' :: (Request -> CheckCreds) -> AuthSettings -> Middleware

-- | Check if a given username and password is valid.
type CheckCreds = ByteString -> ByteString -> IO Bool

-- | Basic authentication settings. This value is an instance of
--   <tt>IsString</tt>, so the recommended approach to create a value is to
--   provide a string literal (which will be the realm) and then overriding
--   individual fields.
--   
--   <pre>
--   "My Realm" { authIsProtected = someFunc } :: AuthSettings
--   </pre>
data AuthSettings

authRealm :: AuthSettings -> ByteString

-- | Takes the realm and returns an appropriate 401 response when
--   authentication is not provided.
authOnNoAuth :: AuthSettings -> ByteString -> Application

-- | Determine if access to the requested resource is restricted.
--   
--   Default: always returns <tt>True</tt>.
authIsProtected :: AuthSettings -> Request -> IO Bool

-- | Extract basic authentication data from usually <b>Authorization</b>
--   header value. Returns username and password
extractBasicAuth :: ByteString -> Maybe (ByteString, ByteString)

-- | Extract bearer authentication data from <b>Authorization</b> header
--   value. Returns bearer token
extractBearerAuth :: ByteString -> Maybe ByteString
instance Data.String.IsString Network.Wai.Middleware.HttpAuth.AuthSettings


-- | Automatic wrapping of JSON responses to convert into JSONP.
module Network.Wai.Middleware.Jsonp

-- | Wrap json responses in a jsonp callback.
--   
--   Basically, if the user requested a "text/javascript" and supplied a
--   "callback" GET parameter, ask the application for an
--   "application/json" response, then convert that into a JSONP response,
--   having a content type of "text/javascript" and calling the specified
--   callback function.
jsonp :: Middleware


-- | Only allow local connections.
module Network.Wai.Middleware.Local

-- | This middleware rejects non-local connections with a specific
--   response. It is useful when supporting web-based local applications,
--   which would typically want to reject external connections.
local :: Response -> Middleware

module Network.Wai.Middleware.MethodOverride

-- | Overriding of HTTP request method via <tt>_method</tt> query string
--   parameter.
--   
--   This middleware only applies when the initial request method is POST.
--   Allows submitting of normal HTML forms, without worries of semantic
--   mismatches with the HTTP spec.
methodOverride :: Middleware


-- | Changes the request-method via first post-parameter _method.
module Network.Wai.Middleware.MethodOverridePost

-- | Allows overriding of the HTTP request method via the _method post
--   string parameter.
--   
--   <ul>
--   <li>Looks for the Content-Type requestHeader.</li>
--   <li>If the header is set to application/x-www-form-urlencoded and the
--   first POST parameter is _method then it changes the request-method to
--   the value of that parameter.</li>
--   <li>This middleware only applies when the initial request method is
--   POST.</li>
--   </ul>
methodOverridePost :: Middleware


-- | Infer the remote IP address using headers
module Network.Wai.Middleware.RealIp

-- | Infer the remote IP address from the <tt>X-Forwarded-For</tt> header,
--   trusting requests from any private IP address. See <a>realIpHeader</a>
--   and <a>realIpTrusted</a> for more information and options.
realIp :: Middleware

-- | Infer the remote IP address using the given header, trusting requests
--   from any private IP address. See <a>realIpTrusted</a> for more
--   information and options.
realIpHeader :: HeaderName -> Middleware

-- | Infer the remote IP address using the given header, but only if the
--   request came from an IP that is trusted by the provided predicate.
--   
--   The last non-trusted address is used to replace the <a>remoteHost</a>
--   in the <tt>Request</tt>, unless all present IP addresses are trusted,
--   in which case the first address is used. Invalid IP addresses are
--   ignored, and the remoteHost value remains unaltered if no valid IP
--   addresses are found.
--   
--   Examples:
--   
--   <pre>
--   realIpTrusted "X-Forwarded-For" $ flip ipInRange "10.0.0.0/8"
--   </pre>
--   
--   <pre>
--   realIpTrusted "X-Real-Ip" $ \ip -&gt; any (ipInRange ip) defaultTrusted
--   </pre>
realIpTrusted :: HeaderName -> (IP -> Bool) -> Middleware

-- | Standard private IP ranges.
defaultTrusted :: [IPRange]

-- | Check if the given IP address is in the given range.
--   
--   IPv4 addresses can be checked against IPv6 ranges, but testing an IPv6
--   address against an IPv4 range is always <a>False</a>.
ipInRange :: IP -> IPRange -> Bool


-- | Internal constructors and helper functions. Note that no guarantees
--   are given for stability of these interfaces.
module Network.Wai.Middleware.RequestSizeLimit.Internal

-- | Settings to configure <tt>requestSizeLimitMiddleware</tt>.
--   
--   This type (but not the constructor, or record fields) is exported from
--   <a>Network.Wai.Middleware.RequestSizeLimit</a>. Since the constructor
--   isn't exported, create a default value with
--   <tt>defaultRequestSizeLimitSettings</tt> first, then set the values
--   using <a>setMaxLengthForRequest</a> and <a>setOnLengthExceeded</a>
--   (See the examples below).
--   
--   If you need to access the constructor directly, it's exported from
--   <a>Network.Wai.Middleware.RequestSizeLimit.Internal</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <h5>Conditionally setting the limit based on the request</h5>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.Wai
--   import Network.Wai.Middleware.RequestSizeLimit
--   
--   let megabyte = 1024 * 1024
--   let sizeForReq req = if pathInfo req == ["upload", "image"] then pure $ Just $ megabyte * 20 else pure $ Just $ megabyte * 2
--   let finalSettings = setMaxLengthForRequest sizeForReq defaultRequestSizeLimitSettings
--   </pre>
--   
--   <h5>JSON response</h5>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.Wai
--   import Network.Wai.Middleware.RequestSizeLimit
--   import Network.HTTP.Types.Status (requestEntityTooLarge413)
--   import Data.Aeson
--   import Data.Text (Text)
--   
--   let jsonResponse = \_maxLen _app _req sendResponse -&gt; sendResponse $ responseLBS requestEntityTooLarge413 [("Content-Type", "application/json")] (encode $ object ["error" .= ("request size too large" :: Text)])
--   let finalSettings = setOnLengthExceeded jsonResponse defaultRequestSizeLimitSettings
--   </pre>
data RequestSizeLimitSettings
RequestSizeLimitSettings :: (Request -> IO (Maybe Word64)) -> (Word64 -> Middleware) -> RequestSizeLimitSettings

-- | Function to determine the maximum request size in bytes for the
--   request. Return <a>Nothing</a> for no limit. Since 3.1.1
[maxLengthForRequest] :: RequestSizeLimitSettings -> Request -> IO (Maybe Word64)

-- | Callback function when maximum length is exceeded. The <a>Word64</a>
--   argument is the limit computed by <a>maxLengthForRequest</a>. Since
--   3.1.1
[onLengthExceeded] :: RequestSizeLimitSettings -> Word64 -> Middleware

-- | Function to determine the maximum request size in bytes for the
--   request. Return <a>Nothing</a> for no limit.
setMaxLengthForRequest :: (Request -> IO (Maybe Word64)) -> RequestSizeLimitSettings -> RequestSizeLimitSettings

-- | Callback function when maximum length is exceeded. The <a>Word64</a>
--   argument is the limit computed by <a>setMaxLengthForRequest</a>.
setOnLengthExceeded :: (Word64 -> Middleware) -> RequestSizeLimitSettings -> RequestSizeLimitSettings

module Network.Wai.Middleware.Rewrite

-- | A tuple of the path sections as [<a>Text</a>] and query parameters as
--   <a>Query</a>. This makes writing type signatures for the conversion
--   function far more pleasant.
--   
--   Note that this uses <a>Query</a> not <a>QueryText</a> to more
--   accurately reflect the paramaters that can be supplied in URLs. It may
--   be safe to treat parameters as text; use the <a>queryToQueryText</a>
--   and <a>queryTextToQuery</a> functions to interconvert.
type PathsAndQueries = ([Text], Query)

-- | Rewrite based on your own conversion function for paths and queries.
--   This function is to be supplied by users of this library, and operates
--   in <a>IO</a>.
rewriteWithQueries :: (PathsAndQueries -> RequestHeaders -> IO PathsAndQueries) -> Middleware

-- | Rewrite based on pure conversion function for paths and queries. This
--   function is to be supplied by users of this library.
rewritePureWithQueries :: (PathsAndQueries -> RequestHeaders -> PathsAndQueries) -> Middleware

-- | Rewrite root requests (/) to a specified path
--   
--   Note that <i>index.html</i> in example below should already be a valid
--   route.
--   
--   <pre>
--   rewriteRoot "index.html" :: Middleware
--   </pre>
rewriteRoot :: Text -> Middleware

-- | Rewrite based on your own conversion function for paths only, to be
--   supplied by users of this library (with the conversion operating in
--   <a>IO</a>).
--   
--   For new code, use <a>rewriteWithQueries</a> instead.

-- | <i>Warning: This modifies the <a>rawPathInfo</a> field of a
--   <a>Request</a>. This is not recommended behaviour; it is however how
--   this function has worked in the past. Use <a>rewriteWithQueries</a>
--   instead</i>
rewrite :: ([Text] -> RequestHeaders -> IO [Text]) -> Middleware

-- | Rewrite based on pure conversion function for paths only, to be
--   supplied by users of this library.
--   
--   For new code, use <a>rewritePureWithQueries</a> instead.

-- | <i>Warning: This modifies the <a>rawPathInfo</a> field of a
--   <a>Request</a>. This is not recommended behaviour; it is however how
--   this function has worked in the past. Use
--   <a>rewritePureWithQueries</a> instead</i>
rewritePure :: ([Text] -> RequestHeaders -> [Text]) -> Middleware

-- | Modify a <a>Request</a> using the supplied function in <a>IO</a>. This
--   is suitable for the reverse proxy example.
rewriteRequest :: (PathsAndQueries -> RequestHeaders -> IO PathsAndQueries) -> Request -> IO Request

-- | Modify a <a>Request</a> using the pure supplied function. This is
--   suitable for the reverse proxy example.
rewriteRequestPure :: (PathsAndQueries -> RequestHeaders -> PathsAndQueries) -> Request -> Request


-- | Since 3.0.9
module Network.Wai.Middleware.Routed

-- | Apply a middleware based on a test of pathInfo
--   
--   example:
--   
--   <pre>
--   let corsify = routedMiddleWare ("static" `elem`) addCorsHeaders
--   </pre>
--   
--   Since 3.0.9
routedMiddleware :: ([Text] -> Bool) -> Middleware -> Middleware

-- | Only apply the middleware to certain hosts
--   
--   Since 3.0.9
hostedMiddleware :: ByteString -> Middleware -> Middleware


-- | Dynamically choose between Middlewares
--   
--   It's useful when you want some <a>Middleware</a>s applied selectively.
--   
--   Example: do not log health check calls:
--   
--   <pre>
--   import Network.Wai
--   import Network.Wai.Middleware.HealthCheckEndpoint
--   import Network.Wai.Middleware.RequestLogger
--   
--   app' :: Application
--   app' =
--     selectMiddleware (selectMiddlewareExceptRawPathInfo "/_healthz" logStdout)
--       $ healthCheck app
--   </pre>
module Network.Wai.Middleware.Select

-- | Relevant Middleware for a given <a>Request</a>.
newtype MiddlewareSelection
MiddlewareSelection :: (Request -> Maybe Middleware) -> MiddlewareSelection
[applySelectedMiddleware] :: MiddlewareSelection -> Request -> Maybe Middleware

-- | Create the <a>Middleware</a> dynamically applying
--   <a>MiddlewareSelection</a>.
selectMiddleware :: MiddlewareSelection -> Middleware

-- | Use the <a>Middleware</a> when the predicate holds.
selectMiddlewareOn :: (Request -> Bool) -> Middleware -> MiddlewareSelection

-- | Use the <a>Middleware</a> for the given <a>rawPathInfo</a>.
selectMiddlewareOnRawPathInfo :: ByteString -> Middleware -> MiddlewareSelection

-- | Use the <a>Middleware</a> for all <a>rawPathInfo</a> except then given
--   one.
selectMiddlewareExceptRawPathInfo :: ByteString -> Middleware -> MiddlewareSelection
passthroughMiddleware :: Middleware
instance GHC.Base.Semigroup Network.Wai.Middleware.Select.MiddlewareSelection
instance GHC.Base.Monoid Network.Wai.Middleware.Select.MiddlewareSelection


-- | Since 3.0.4
module Network.Wai.Middleware.StreamFile

-- | Convert ResponseFile type responses into ResponseStream type
--   
--   Checks the response type, and if it's a ResponseFile, converts it into
--   a ResponseStream. Other response types are passed through unchanged.
--   
--   Converted responses get a Content-Length header.
--   
--   Streaming a file will bypass a sendfile system call, and may be useful
--   to work around systems without working sendfile implementations.
--   
--   Since 3.0.4
streamFile :: Middleware

module Network.Wai.Middleware.StripHeaders
stripHeader :: ByteString -> Response -> Response
stripHeaders :: [ByteString] -> Response -> Response

-- | If the request satisifes the provided predicate, strip headers
--   matching the provided header name.
--   
--   Since 3.0.8
stripHeaderIf :: ByteString -> (Request -> Bool) -> Middleware

-- | If the request satisifes the provided predicate, strip all headers
--   whose header name is in the list of provided header names.
--   
--   Since 3.0.8
stripHeadersIf :: [ByteString] -> (Request -> Bool) -> Middleware


-- | Timeout requests
module Network.Wai.Middleware.Timeout

-- | Time out the request after the given number of seconds
--   
--   Timeouts respond with <tt><a>status503</a></tt>. See
--   <tt><a>timeoutStatus</a></tt> or <tt><a>timeoutAs</a></tt> to
--   customize the behavior of the timed-out case.
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeout :: Int -> Middleware

-- | Time out with the given <tt><a>Status</a></tt>
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeoutStatus :: Status -> Int -> Middleware

-- | Time out with the given <tt><a>Response</a></tt>
--   
--   <pre>
--   since 3.0.24.0
--   </pre>
timeoutAs :: Response -> Int -> Middleware


-- | This module provides a middleware to validate response headers. <a>RFC
--   9110</a> constrains the allowed octets in header names and values:
--   
--   <ul>
--   <li>Header names are <a>tokens</a>, i.e. visible ASCII characters
--   (octets 33 to 126 inclusive) except delimiters.</li>
--   <li>Header values should be limited to visible ASCII characters, the
--   whitespace characters space and horizontal tab and octets 128 to 255.
--   Headers values may not have trailing whitespace (see <a>RFC 9110
--   Section 5.5</a>). Folding is not allowed.</li>
--   </ul>
--   
--   <a>validateHeadersMiddleware</a> enforces these constraints for
--   response headers by responding with a 500 Internal Server Error when
--   an offending character is present. This is meant to catch programmer
--   errors early on and reduce attack surface.
module Network.Wai.Middleware.ValidateHeaders

-- | Middleware to validate response headers.
validateHeadersMiddleware :: ValidateHeadersSettings -> Middleware

-- | Configuration for <a>validateHeadersMiddleware</a>.
data ValidateHeadersSettings
ValidateHeadersSettings :: (InvalidHeader -> Middleware) -> ValidateHeadersSettings

-- | Called when an invalid header is present.
[onInvalidHeader] :: ValidateHeadersSettings -> InvalidHeader -> Middleware

-- | Default configuration for <a>validateHeadersMiddleware</a>. Checks
--   that each header meets the requirements listed at the top of this
--   module: Allowed octets for name and value and no trailing whitespace
--   in the value.
defaultValidateHeadersSettings :: ValidateHeadersSettings

-- | Description of an invalid header.
data InvalidHeader
InvalidHeader :: Header -> InvalidHeaderReason -> InvalidHeader

-- | Reasons a header might be invalid.
data InvalidHeaderReason

-- | Header name contains an invalid octet.
InvalidOctetInHeaderName :: Word8 -> InvalidHeaderReason

-- | Header value contains an invalid octet.
InvalidOctetInHeaderValue :: Word8 -> InvalidHeaderReason

-- | Header value contains trailing whitespace.
TrailingWhitespaceInHeaderValue :: InvalidHeaderReason

module Network.Wai.Middleware.Vhost
vhost :: [(Request -> Bool, Application)] -> Application -> Application
redirectWWW :: Text -> Application -> Application
redirectTo :: ByteString -> Response
redirectToLogged :: (Text -> IO ()) -> ByteString -> IO Response


-- | Some helpers for parsing data out of a raw WAI <a>Request</a>.
module Network.Wai.Parse

-- | Parse the HTTP accept string to determine supported content types.
parseHttpAccept :: ByteString -> [ByteString]

-- | Parse the body of an HTTP request. See parseRequestBodyEx for details.
--   Note: This function does not limit the memory it allocates. When
--   dealing with untrusted data (as is usually the case when receiving
--   input from the internet), it is recommended to use the
--   <a>parseRequestBodyEx</a> function instead.
--   
--   since 3.1.15 : throws <a>RequestParseException</a> if something goes
--   wrong
parseRequestBody :: BackEnd y -> Request -> IO ([Param], [File y])

-- | The mimetype of the http body. Depending on whether just parameters or
--   parameters and files are passed, one or the other mimetype should be
--   used.
data RequestBodyType

-- | application/x-www-form-urlencoded (parameters only)
UrlEncoded :: RequestBodyType

-- | multipart/form-data (parameters and files)
Multipart :: ByteString -> RequestBodyType

-- | Get the mimetype of the body of an http request.
getRequestBodyType :: Request -> Maybe RequestBodyType

-- | since 3.1.15 : throws <a>RequestParseException</a> if something goes
--   wrong
sinkRequestBody :: BackEnd y -> RequestBodyType -> IO ByteString -> IO ([Param], [File y])

-- | Throws <a>RequestParseException</a> if something goes wrong
--   
--   since 3.1.15 : throws <a>RequestParseException</a> if something goes
--   wrong
sinkRequestBodyEx :: ParseRequestBodyOptions -> BackEnd y -> RequestBodyType -> IO ByteString -> IO ([Param], [File y])

-- | Things that could go wrong while parsing a <a>Request</a>
data RequestParseException
MaxParamSizeExceeded :: Int -> RequestParseException
ParamNameTooLong :: ByteString -> Int -> RequestParseException
MaxFileNumberExceeded :: Int -> RequestParseException
FilenameTooLong :: ByteString -> Int -> RequestParseException
TooManyHeaderLines :: Int -> RequestParseException

-- | A file uploading backend. Takes the parameter name, file name, and a
--   stream of data.
type BackEnd a = -- | parameter name ByteString -> FileInfo () -> IO ByteString -> IO a

-- | Store uploaded files in memory
lbsBackEnd :: Monad m => ignored1 -> ignored2 -> m ByteString -> m ByteString

-- | Save uploaded files on disk as temporary files
--   
--   Note: starting with version 2.0, removal of temp files is registered
--   with the provided <tt>InternalState</tt>. It is the responsibility of
--   the caller to ensure that this <tt>InternalState</tt> gets cleaned up.
tempFileBackEnd :: InternalState -> ignored1 -> ignored2 -> IO ByteString -> IO FilePath

-- | Same as <a>tempFileBackEnd</a>, but use configurable temp folders and
--   patterns.
tempFileBackEndOpts :: IO FilePath -> String -> InternalState -> ignored1 -> ignored2 -> IO ByteString -> IO FilePath

-- | Post parameter name and value.
type Param = (ByteString, ByteString)

-- | Post parameter name and associated file information.
type File y = (ByteString, FileInfo y)

-- | Information on an uploaded file.
data FileInfo c
FileInfo :: ByteString -> ByteString -> c -> FileInfo c
[fileName] :: FileInfo c -> ByteString
[fileContentType] :: FileInfo c -> ByteString
[fileContent] :: FileInfo c -> c

-- | Parse a content type value, turning a single <tt>ByteString</tt> into
--   the actual content type and a list of pairs of attributes.
parseContentType :: ByteString -> (ByteString, [(ByteString, ByteString)])

-- | A data structure that describes the behavior of the parseRequestBodyEx
--   function.
data ParseRequestBodyOptions

-- | A reasonable default set of parsing options. Maximum key/filename
--   length: 32 bytes; maximum files: 10; filesize unlimited; maximum size
--   for parameters: 64kbytes; maximum number of header lines: 32 bytes
--   (applies only to headers of a mime/multipart message); maximum header
--   line length: Apache's default for that is 8190 bytes
--   (http:/<i>httpd.apache.org</i>docs<i>2.2</i>mod/core.html#limitrequestline)
--   so we're using that here as well.
defaultParseRequestBodyOptions :: ParseRequestBodyOptions

-- | Do not impose any memory limits.
noLimitParseRequestBodyOptions :: ParseRequestBodyOptions

-- | Parse the body of an HTTP request, limit resource usage. The HTTP body
--   can contain both parameters and files. This function will return a
--   list of key,value pairs for all parameters, and a list of key,a pairs
--   for filenames. The a depends on the used backend that is responsible
--   for storing the received files.
--   
--   since 3.1.15 : throws <a>RequestParseException</a> if something goes
--   wrong
parseRequestBodyEx :: ParseRequestBodyOptions -> BackEnd y -> Request -> IO ([Param], [File y])

-- | Set the maximum length of a filename.
setMaxRequestKeyLength :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the length of filenames.
clearMaxRequestKeyLength :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum number of files per request.
setMaxRequestNumFiles :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum number of files per request.
clearMaxRequestNumFiles :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum filesize per file (in bytes).
setMaxRequestFileSize :: Int64 -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum filesize per file.
clearMaxRequestFileSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum size of all files per request.
setMaxRequestFilesSize :: Int64 -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum size of all files per request.
clearMaxRequestFilesSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum size of the sum of all parameters.
setMaxRequestParmsSize :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum size of the sum of all parameters.
clearMaxRequestParmsSize :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum header lines per mime/multipart entry.
setMaxHeaderLines :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum header lines per mime/multipart entry.
clearMaxHeaderLines :: ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Set the maximum header line length per mime/multipart entry.
setMaxHeaderLineLength :: Int -> ParseRequestBodyOptions -> ParseRequestBodyOptions

-- | Do not limit the maximum header lines per mime/multipart entry.
clearMaxHeaderLineLength :: ParseRequestBodyOptions -> ParseRequestBodyOptions
instance GHC.Show.Show c => GHC.Show.Show (Network.Wai.Parse.FileInfo c)
instance GHC.Classes.Eq c => GHC.Classes.Eq (Network.Wai.Parse.FileInfo c)
instance GHC.Classes.Eq Network.Wai.Parse.RequestParseException
instance GHC.Show.Show Network.Wai.Parse.Bound
instance GHC.Classes.Eq Network.Wai.Parse.Bound
instance GHC.Exception.Type.Exception Network.Wai.Parse.RequestParseException
instance GHC.Show.Show Network.Wai.Parse.RequestParseException


-- | Some helpers for interrogating a WAI <a>Request</a>.
module Network.Wai.Request

-- | Does this request appear to have been made over an SSL connection?
--   
--   This function first checks <tt><a>isSecure</a></tt>, but also checks
--   for headers that may indicate a secure connection even in the presence
--   of reverse proxies.
--   
--   Note: these headers can be easily spoofed, so decisions which require
--   a true SSL connection (i.e. sending sensitive information) should only
--   use <tt><a>isSecure</a></tt>. This is not always the case though: for
--   example, deciding to force a non-SSL request to SSL by redirect. One
--   can safely choose not to redirect when the request <i>appears</i>
--   secure, even if it's actually not.
appearsSecure :: Request -> Bool

-- | Guess the "application root" based on the given request.
--   
--   The application root is the basis for forming URLs pointing at the
--   current application. For more information and relevant caveats, please
--   see <a>Network.Wai.Middleware.Approot</a>.
guessApproot :: Request -> ByteString

-- | see <a>requestSizeCheck</a>
newtype RequestSizeException
RequestSizeException :: Word64 -> RequestSizeException

-- | Check request body size to avoid server crash when request is too
--   large.
--   
--   This function first checks <tt><a>requestBodyLength</a></tt>, if
--   content-length is known but larger than limit, or it's unknown but we
--   have received too many chunks, a <a>RequestSizeException</a> are
--   thrown when user use <tt><a>requestBody</a></tt> to extract request
--   body inside IO.
requestSizeCheck :: Word64 -> Request -> IO Request
instance GHC.Classes.Ord Network.Wai.Request.RequestSizeException
instance GHC.Classes.Eq Network.Wai.Request.RequestSizeException
instance GHC.Exception.Type.Exception Network.Wai.Request.RequestSizeException
instance GHC.Show.Show Network.Wai.Request.RequestSizeException


-- | The functions in this module allow you to limit the total size of
--   incoming request bodies.
--   
--   Limiting incoming request body size helps protect your server against
--   denial-of-service (DOS) attacks, in which an attacker sends huge
--   bodies to your server.
module Network.Wai.Middleware.RequestSizeLimit

-- | Middleware to limit request bodies to a certain size.
--   
--   This uses <a>requestSizeCheck</a> under the hood; see that function
--   for details.
requestSizeLimitMiddleware :: RequestSizeLimitSettings -> Middleware

-- | Create a <a>RequestSizeLimitSettings</a> with these settings:
--   
--   <ul>
--   <li>2MB size limit for all requests</li>
--   <li>When the limit is exceeded, return a plain text response
--   describing the error, with a 413 status code.</li>
--   </ul>
defaultRequestSizeLimitSettings :: RequestSizeLimitSettings

-- | Settings to configure <tt>requestSizeLimitMiddleware</tt>.
--   
--   This type (but not the constructor, or record fields) is exported from
--   <a>Network.Wai.Middleware.RequestSizeLimit</a>. Since the constructor
--   isn't exported, create a default value with
--   <tt>defaultRequestSizeLimitSettings</tt> first, then set the values
--   using <a>setMaxLengthForRequest</a> and <a>setOnLengthExceeded</a>
--   (See the examples below).
--   
--   If you need to access the constructor directly, it's exported from
--   <a>Network.Wai.Middleware.RequestSizeLimit.Internal</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <h5>Conditionally setting the limit based on the request</h5>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.Wai
--   import Network.Wai.Middleware.RequestSizeLimit
--   
--   let megabyte = 1024 * 1024
--   let sizeForReq req = if pathInfo req == ["upload", "image"] then pure $ Just $ megabyte * 20 else pure $ Just $ megabyte * 2
--   let finalSettings = setMaxLengthForRequest sizeForReq defaultRequestSizeLimitSettings
--   </pre>
--   
--   <h5>JSON response</h5>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.Wai
--   import Network.Wai.Middleware.RequestSizeLimit
--   import Network.HTTP.Types.Status (requestEntityTooLarge413)
--   import Data.Aeson
--   import Data.Text (Text)
--   
--   let jsonResponse = \_maxLen _app _req sendResponse -&gt; sendResponse $ responseLBS requestEntityTooLarge413 [("Content-Type", "application/json")] (encode $ object ["error" .= ("request size too large" :: Text)])
--   let finalSettings = setOnLengthExceeded jsonResponse defaultRequestSizeLimitSettings
--   </pre>
data RequestSizeLimitSettings

-- | Function to determine the maximum request size in bytes for the
--   request. Return <a>Nothing</a> for no limit.
setMaxLengthForRequest :: (Request -> IO (Maybe Word64)) -> RequestSizeLimitSettings -> RequestSizeLimitSettings

-- | Callback function when maximum length is exceeded. The <a>Word64</a>
--   argument is the limit computed by <a>setMaxLengthForRequest</a>.
setOnLengthExceeded :: (Word64 -> Middleware) -> RequestSizeLimitSettings -> RequestSizeLimitSettings


-- | Redirect non-SSL requests to https
--   
--   Since 3.0.7
module Network.Wai.Middleware.ForceSSL

-- | For requests that don't appear secure, redirect to https
--   
--   Since 3.0.7
forceSSL :: Middleware


module Network.Wai.Middleware.ForceDomain

-- | Force a domain by redirecting. The <tt>checkDomain</tt> function takes
--   the current domain and checks whether it is correct. It should return
--   <a>Nothing</a> if the domain is correct, or `Just "domain.com"` if it
--   is incorrect.
forceDomain :: (ByteString -> Maybe ByteString) -> Middleware


-- | Middleware for establishing the root of the application.
--   
--   Many application need the ability to create URLs referring back to the
--   application itself. For example: generate RSS feeds or sitemaps,
--   giving users copy-paste links, or sending emails. In many cases, the
--   approot can be determined correctly from the request headers. However,
--   some things can prevent this, especially reverse proxies. This module
--   provides multiple ways of configuring approot discovery, and functions
--   for applications to get that approot.
--   
--   Approots are structured such that they can be prepended to a string
--   such as <tt><i>foo</i>bar?baz=bin</tt>. For example, if your
--   application is hosted on example.com using HTTPS, the approot would be
--   <tt><a>https://example.com</a></tt>. Note the lack of a trailing
--   slash.
module Network.Wai.Middleware.Approot

-- | The most generic version of the middleware, allowing you to provide a
--   function to get the approot for each request. For many use cases, one
--   of the helper functions provided by this module will give the
--   necessary functionality more conveniently.
--   
--   Since 3.0.7
approotMiddleware :: (Request -> IO ByteString) -> Middleware

-- | Same as <tt><a>envFallbackNamed</a> <a>APPROOT</a></tt>.
--   
--   The environment variable <tt>APPROOT</tt> is used by Keter, School of
--   Haskell, and yesod-devel.
--   
--   Since 3.0.7
envFallback :: IO Middleware

-- | Produce a middleware that takes the approot from the given environment
--   variable, falling back to the behavior of <a>fromRequest</a> if the
--   variable is not set.
--   
--   Since 3.0.7
envFallbackNamed :: String -> IO Middleware

-- | Hard-code the given value as the approot.
--   
--   Since 3.0.7
hardcoded :: ByteString -> Middleware

-- | Get the approot by analyzing the request. This is not a full-proof
--   approach, but in many common cases will work. Situations that can
--   break this are:
--   
--   <ul>
--   <li>Requests which spoof headers and imply the connection is over
--   HTTPS</li>
--   <li>Reverse proxies that change ports in surprising ways</li>
--   <li>Invalid Host headers</li>
--   <li>Reverse proxies which modify the path info</li>
--   </ul>
--   
--   Normally trusting headers in this way is insecure, however in the case
--   of approot, the worst that can happen is that the client will get an
--   incorrect URL. If you are relying on the approot for some
--   security-sensitive purpose, it is highly recommended to use
--   <tt>hardcoded</tt>, which cannot be spoofed.
--   
--   Since 3.0.7
fromRequest :: Middleware

-- | Get the approot set by the middleware. If the middleware is not in
--   use, then this function will return an exception. For a total version
--   of the function, see <a>getApprootMay</a>.
--   
--   Since 3.0.7
getApproot :: Request -> ByteString

-- | A total version of <a>getApproot</a>, which returns <a>Nothing</a> if
--   the middleware is not in use.
--   
--   Since 3.0.7
getApprootMay :: Request -> Maybe ByteString
instance GHC.Show.Show Network.Wai.Middleware.Approot.ApprootMiddlewareNotSetup
instance GHC.Exception.Type.Exception Network.Wai.Middleware.Approot.ApprootMiddlewareNotSetup

module Network.Wai.Test.Internal
type Session = ReaderT Application (StateT ClientState IO)

-- | Since 3.0.6
type ClientCookies = Map ByteString SetCookie
newtype ClientState
ClientState :: ClientCookies -> ClientState
[clientCookies] :: ClientState -> ClientCookies

-- | Since 3.0.20.0
initState :: ClientState

-- | Like <tt>runSession</tt>, but if allows you to hand in cookies and get
--   the updated cookies back. One use case for this is writing tests that
--   address the application under test alternatingly through rest api and
--   through db handle.
--   
--   Since 3.0.20.0
runSessionWith :: ClientState -> Session a -> Application -> IO (a, ClientState)

module Network.Wai.Test
type Session = ReaderT Application (StateT ClientState IO)

-- | See also: <a>runSessionWith</a>.
runSession :: Session a -> Application -> IO a

-- | Synonym for 'flip runSession'
withSession :: Application -> Session a -> IO a

-- | Since 3.0.6
type ClientCookies = Map ByteString SetCookie

-- | Since 3.0.6
getClientCookies :: Session ClientCookies

-- | Since 3.0.6
modifyClientCookies :: (ClientCookies -> ClientCookies) -> Session ()

-- | Since 3.0.6
setClientCookie :: SetCookie -> Session ()

-- | Since 3.0.6
deleteClientCookie :: ByteString -> Session ()
request :: Request -> Session SResponse

-- | Similar to <a>request</a>, but allows setting the request body as a
--   plain <a>ByteString</a>.
srequest :: SRequest -> Session SResponse
data SRequest
SRequest :: Request -> ByteString -> SRequest
[simpleRequest] :: SRequest -> Request

-- | Request body that will override the one set in <a>simpleRequest</a>.
--   
--   This is usually simpler than setting the body as a stateful IO-action
--   in <a>simpleRequest</a>.
[simpleRequestBody] :: SRequest -> ByteString
data SResponse
SResponse :: Status -> ResponseHeaders -> ByteString -> SResponse
[simpleStatus] :: SResponse -> Status
[simpleHeaders] :: SResponse -> ResponseHeaders
[simpleBody] :: SResponse -> ByteString

-- | A default, blank request.
defaultRequest :: Request

-- | Set whole path (request path + query string).
setPath :: Request -> ByteString -> Request
setRawPathInfo :: Request -> ByteString -> Request
assertStatus :: HasCallStack => Int -> SResponse -> Session ()
assertContentType :: HasCallStack => ByteString -> SResponse -> Session ()
assertBody :: HasCallStack => ByteString -> SResponse -> Session ()
assertBodyContains :: HasCallStack => ByteString -> SResponse -> Session ()
assertHeader :: HasCallStack => CI ByteString -> ByteString -> SResponse -> Session ()
assertNoHeader :: HasCallStack => CI ByteString -> SResponse -> Session ()

-- | Since 3.0.6
assertClientCookieExists :: HasCallStack => String -> ByteString -> Session ()

-- | Since 3.0.6
assertNoClientCookieExists :: HasCallStack => String -> ByteString -> Session ()

-- | Since 3.0.6
assertClientCookieValue :: HasCallStack => String -> ByteString -> ByteString -> Session ()
instance GHC.Classes.Eq Network.Wai.Test.SResponse
instance GHC.Show.Show Network.Wai.Test.SResponse


-- | This module gives you a way to mount applications under sub-URIs. For
--   example:
--   
--   <pre>
--   bugsApp, helpdeskApp, apiV1, apiV2, mainApp :: Application
--   
--   myApp :: Application
--   myApp = mapUrls $
--         mount "bugs"     bugsApp
--     &lt;|&gt; mount "helpdesk" helpdeskApp
--     &lt;|&gt; mount "api"
--             (   mount "v1" apiV1
--             &lt;|&gt; mount "v2" apiV2
--             )
--     &lt;|&gt; mountRoot mainApp
--   </pre>
module Network.Wai.UrlMap
data UrlMap' a
type UrlMap = UrlMap' Application

-- | Mount an application under a given path. The ToApplication typeclass
--   gives you the option to pass either an <a>Application</a> or an
--   <a>UrlMap</a> as the second argument.
mount' :: ToApplication a => Path -> a -> UrlMap

-- | A convenience function like mount', but for mounting things under a
--   single path segment.
mount :: ToApplication a => Text -> a -> UrlMap

-- | Mount something at the root. Use this for the last application in the
--   block, to avoid 500 errors from none of the applications matching.
mountRoot :: ToApplication a => a -> UrlMap
mapUrls :: UrlMap -> Application
instance Network.Wai.UrlMap.ToApplication Network.Wai.Application
instance Network.Wai.UrlMap.ToApplication Network.Wai.UrlMap.UrlMap
instance GHC.Base.Functor Network.Wai.UrlMap.UrlMap'
instance GHC.Base.Applicative Network.Wai.UrlMap.UrlMap'
instance GHC.Base.Alternative Network.Wai.UrlMap.UrlMap'


-- | Sometimes incoming requests don't stick to the "no duplicate headers"
--   invariant, for a number of possible reasons (e.g. proxy servers
--   blindly adding headers), or your application (or other middleware)
--   blindly adds headers.
--   
--   In those cases, you can use this <a>Middleware</a> to make sure that
--   headers that <i>can</i> be combined <i>are</i> combined. (e.g.
--   applications might only check the first "Accept" header and fail,
--   while there might be another one that would match)
module Network.Wai.Middleware.CombineHeaders

-- | This middleware will reorganize the incoming and/or outgoing headers
--   in such a way that it combines any duplicates of headers that, on
--   their own, can normally have more than one value, and any other
--   headers will stay untouched.
--   
--   This middleware WILL change the global order of headers (they will be
--   put in alphabetical order), but keep the order of the same type of
--   header. I.e. if there are 3 "Set-Cookie" headers, the first one will
--   still be first, the second one will still be second, etc. But now they
--   are guaranteed to be next to each other.
--   
--   N.B. This <a>Middleware</a> assumes the headers it combines are
--   correctly formatted. If one of the to-be-combined headers is
--   malformed, the new combined header will also (probably) be malformed.
combineHeaders :: CombineSettings -> Middleware

-- | These settings define which headers should be combined, if the
--   combining should happen on incoming (request) headers and if it should
--   happen on outgoing (response) headers.
--   
--   Any header you put in the header map *will* be used to combine those
--   headers with commas. There's no check to see if it is a header that
--   allows comma-separated lists, so if you want to combine custom
--   headers, go ahead.
--   
--   (You can check the documentation of <a>defaultCombineSettings</a> to
--   see which standard headers are specified to be able to be combined)
data CombineSettings

-- | Settings that combine request headers, but don't touch response
--   headers.
--   
--   All types of headers that <i>can</i> be combined (as defined in the
--   spec) <i>will</i> be combined.
--   
--   To be exact, this is the list:
--   
--   <ul>
--   <li>Accept</li>
--   <li>Accept-CH</li>
--   <li>Accept-Charset</li>
--   <li>Accept-Encoding</li>
--   <li>Accept-Language</li>
--   <li>Accept-Post</li>
--   <li>Access-Control-Allow-Headers</li>
--   <li>Access-Control-Allow-Methods</li>
--   <li>Access-Control-Expose-Headers</li>
--   <li>Access-Control-Request-Headers</li>
--   <li>Allow</li>
--   <li>Alt-Svc <tt>(KeepOnly "clear"")</tt></li>
--   <li>Cache-Control</li>
--   <li>Clear-Site-Data <tt>(KeepOnly "*")</tt></li>
--   <li>Connection</li>
--   <li>Content-Encoding</li>
--   <li>Content-Language</li>
--   <li>Digest</li>
--   <li>If-Match</li>
--   <li>If-None-Match <tt>(KeepOnly "*")</tt></li>
--   <li>Link</li>
--   <li>Permissions-Policy</li>
--   <li>TE</li>
--   <li>Timing-Allow-Origin <tt>(KeepOnly "*")</tt></li>
--   <li>Trailer</li>
--   <li>Transfer-Encoding</li>
--   <li>Upgrade</li>
--   <li>Via</li>
--   <li>Vary <tt>(KeepOnly "*")</tt></li>
--   <li>Want-Digest</li>
--   </ul>
--   
--   N.B. Any header name that has "KeepOnly" after it will be combined
--   like normal, unless one of the values is the one mentioned ("*" most
--   of the time), then that value is used and all others are dropped.
defaultCombineSettings :: CombineSettings

-- | The mapping of <a>HeaderName</a> to <a>HandleType</a>
type HeaderMap = Map HeaderName HandleType

-- | Both will concatenate with <tt>,</tt> (commas), but <a>KeepOnly</a>
--   will drop all values except the given one if present (e.g. in case of
--   wildcards/special values)
--   
--   For example: If there are multiple <tt>"Clear-Site-Data"</tt> headers,
--   but one of them is the wildcard <tt>"*"</tt> value, using
--   <tt><a>KeepOnly</a> "*"</tt> will cause all others to be dropped and
--   only the wildcard value to remain. (The <tt>"*"</tt> wildcard in this
--   case means <i>ALL site data</i> should be cleared, so no need to
--   include more)
data HandleType

-- | The default collection of HTTP headers that can be combined in case
--   there are multiples in one request or response.
--   
--   See the documentation of <a>defaultCombineSettings</a> for the exact
--   list.
defaultHeaderMap :: HeaderMap

-- | Convenience function to add a header to the header map or, if it is
--   already in the map, to change the <a>HandleType</a>.
setHeader :: HeaderName -> HandleType -> CombineSettings -> CombineSettings

-- | Convenience function to remove a header from the header map.
removeHeader :: HeaderName -> CombineSettings -> CombineSettings

-- | Override the <a>HeaderMap</a> of the <a>CombineSettings</a> (default:
--   <a>defaultHeaderMap</a>)
setHeaderMap :: HeaderMap -> CombineSettings -> CombineSettings

-- | Use the regular strategy when combining headers. (i.e. merge into one
--   header and separate values with commas)
regular :: HandleType

-- | Use the regular strategy when combining headers, but if the exact
--   supplied <tt>ByteString</tt> is encountered then discard all other
--   values and only keep that value.
--   
--   e.g. <tt>keepOnly "*"</tt> will drop all other encountered values
keepOnly :: ByteString -> HandleType

-- | Set whether the combining of headers should be applied to the incoming
--   request headers. (default: True)
setRequestHeaders :: Bool -> CombineSettings -> CombineSettings

-- | Set whether the combining of headers should be applied to the outgoing
--   response headers. (default: False)
setResponseHeaders :: Bool -> CombineSettings -> CombineSettings
instance GHC.Show.Show Network.Wai.Middleware.CombineHeaders.HandleType
instance GHC.Classes.Eq Network.Wai.Middleware.CombineHeaders.HandleType
instance GHC.Show.Show Network.Wai.Middleware.CombineHeaders.CombineSettings
instance GHC.Classes.Eq Network.Wai.Middleware.CombineHeaders.CombineSettings


-- | Some helpers for dealing with WAI <a>Header</a>s.
module Network.Wai.Header

-- | More useful for a response. A Wai Request already has a
--   requestBodyLength
contentLength :: [(HeaderName, ByteString)] -> Maybe Integer

-- | Only to be used on header's values which support quality value syntax
--   
--   A few things to keep in mind when using this function: * The resulting
--   <a>Int</a> will be anywhere from 1000 to 0 ("1" = 1000, "0.6" = 600,
--   "0.025" = 25) * The absence of a Q value will result in 'Just 1000' *
--   A bad parse of the Q value will result in a <a>Nothing</a>, e.g. * Q
--   value has more than 3 digits behind the dot * Q value is missing * Q
--   value is higher than 1 * Q value is not a number
parseQValueList :: ByteString -> [(ByteString, Maybe Int)]
replaceHeader :: HeaderName -> ByteString -> [Header] -> [Header]

module Network.Wai.Middleware.RequestLogger

-- | Production request logger middleware.
--   
--   This uses the <a>Apache</a> logging format, and takes IP addresses for
--   clients from the socket (see <a>IPAddrSource</a> for more
--   information). It logs to <a>stdout</a>.
logStdout :: Middleware

-- | Development request logger middleware.
--   
--   This uses the <a>Detailed</a> <a>True</a> logging format and logs to
--   <a>stdout</a>.
logStdoutDev :: Middleware
mkRequestLogger :: RequestLoggerSettings -> IO Middleware

-- | <tt>RequestLoggerSettings</tt> is an instance of Default. See
--   <a>Data.Default</a> for more information.
--   
--   <tt>outputFormat</tt>, <tt>autoFlush</tt>, and <tt>destination</tt>
--   are record fields for the record type <tt>RequestLoggerSettings</tt>,
--   so they can be used to modify settings values using record syntax.
data RequestLoggerSettings
defaultRequestLoggerSettings :: RequestLoggerSettings

-- | Default value: <tt>Detailed</tt> <tt>True</tt>.
outputFormat :: RequestLoggerSettings -> OutputFormat

-- | Only applies when using the <tt>Handle</tt> constructor for
--   <tt>destination</tt>.
--   
--   Default value: <tt>True</tt>.
autoFlush :: RequestLoggerSettings -> Bool

-- | Default: <tt>Handle</tt> <tt>stdout</tt>.
destination :: RequestLoggerSettings -> Destination

-- | The logging format.
data OutputFormat
Apache :: IPAddrSource -> OutputFormat

ApacheWithSettings :: ApacheSettings -> OutputFormat

-- | use colors?
Detailed :: Bool -> OutputFormat

DetailedWithSettings :: DetailedSettings -> OutputFormat
CustomOutputFormat :: OutputFormatter -> OutputFormat
CustomOutputFormatWithDetails :: OutputFormatterWithDetails -> OutputFormat
CustomOutputFormatWithDetailsAndHeaders :: OutputFormatterWithDetailsAndHeaders -> OutputFormat

-- | Settings for the <a>ApacheWithSettings</a> <a>OutputFormat</a>. This
--   is purposely kept as an abstract data type so that new settings can be
--   added without breaking backwards compatibility. In order to create an
--   <a>ApacheSettings</a> value, use <a>defaultApacheSettings</a> and the
--   various 'setApache' functions to modify individual fields. For
--   example:
--   
--   <pre>
--   setApacheIPAddrSource FromHeader defaultApacheSettings
--   </pre>
data ApacheSettings
defaultApacheSettings :: ApacheSettings

-- | Where to take IP addresses for clients from. See <a>IPAddrSource</a>
--   for more information.
--   
--   Default value: FromSocket
setApacheIPAddrSource :: IPAddrSource -> ApacheSettings -> ApacheSettings

-- | Function that allows you to filter which requests are logged, based on
--   the request and response
--   
--   Default: log all requests
setApacheRequestFilter :: (Request -> Response -> Bool) -> ApacheSettings -> ApacheSettings

-- | Function that allows you to get the current user from the request,
--   which will then be added in the log.
--   
--   Default: return no user
setApacheUserGetter :: (Request -> Maybe ByteString) -> ApacheSettings -> ApacheSettings

-- | Settings for the <a>Detailed</a> <a>OutputFormat</a>.
--   
--   <a>mModifyParams</a> allows you to pass a function to hide
--   confidential information (such as passwords) from the logs. If result
--   is <a>Nothing</a>, then the parameter is hidden. For example: &gt;
--   myformat = Detailed True (Just hidePasswords) &gt; where hidePasswords
--   p@(k,v) = if k = "password" then (k, "***REDACTED***") else p
--   
--   <a>mFilterRequests</a> allows you to filter which requests are logged,
--   based on the request and response.
data DetailedSettings
DetailedSettings :: Bool -> Maybe (Param -> Maybe Param) -> Maybe (Request -> Response -> Bool) -> Bool -> DetailedSettings
[useColors] :: DetailedSettings -> Bool
[mModifyParams] :: DetailedSettings -> Maybe (Param -> Maybe Param)
[mFilterRequests] :: DetailedSettings -> Maybe (Request -> Response -> Bool)

[mPrelogRequests] :: DetailedSettings -> Bool
type OutputFormatter = ZonedDate -> Request -> Status -> Maybe Integer -> LogStr
type OutputFormatterWithDetails = ZonedDate -> Request -> Status -> Maybe Integer -> NominalDiffTime -> [ByteString] -> Builder -> LogStr

-- | Same as <tt>OutputFormatterWithDetails</tt> but with response headers
--   included
--   
--   This is useful if you wish to include arbitrary application data in
--   your logs, e.g., an authenticated user ID, which you would set in a
--   response header in your application and retrieve in the log formatter.
type OutputFormatterWithDetailsAndHeaders = -- | When the log message was generated ZonedDate -> -- | The WAI request Request -> -- | HTTP status code Status -> -- | Response size Maybe Integer -> -- | Duration of the request NominalDiffTime -> -- | The request body [ByteString] -> -- | Raw response Builder -> -- | The response headers [Header] -> LogStr
data Destination
Handle :: Handle -> Destination
Logger :: LoggerSet -> Destination
Callback :: Callback -> Destination
type Callback = LogStr -> IO ()

-- | Source from which the IP source address of the client is obtained.
data () => IPAddrSource

-- | From the peer address of the HTTP connection.
FromSocket :: IPAddrSource

-- | From X-Real-IP: or X-Forwarded-For: in the HTTP header.
FromHeader :: IPAddrSource

-- | From the peer address if header is not found.
FromFallback :: IPAddrSource
instance Data.Default.Class.Default Network.Wai.Middleware.RequestLogger.RequestLoggerSettings
instance Data.Default.Class.Default Network.Wai.Middleware.RequestLogger.DetailedSettings

module Network.Wai.Middleware.RequestLogger.JSON
formatAsJSON :: OutputFormatterWithDetails

-- | Same as <tt>formatAsJSON</tt> but with response headers included
--   
--   This is useful for passing arbitrary data from your application out to
--   the WAI layer for it to be logged, but you may need to be careful to
--   subsequently redact any headers which may contain sensitive data.
formatAsJSONWithHeaders :: OutputFormatterWithDetailsAndHeaders

-- | Get the JSON representation for a request
--   
--   This representation is identical to that used in <a>formatAsJSON</a>
--   for the request. It includes:
--   
--   <ul>
--   <li><i><tt>method</tt></i></li>
--   <li><i><tt>path</tt></i></li>
--   <li><i><tt>queryString</tt></i></li>
--   <li><i><tt>size</tt></i> The size of the body, as defined in the
--   request. This may differ from the size of the data passed in the
--   second argument.</li>
--   <li><i><tt>body</tt></i> The body, concatenated directly from the
--   chunks passed in</li>
--   <li><i><tt>remoteHost</tt></i></li>
--   <li><i><tt>httpVersion</tt></i></li>
--   <li><i><tt>headers</tt></i></li>
--   </ul>
--   
--   If a <tt><a>Just</a> duration</tt> is passed in, then additionally the
--   JSON includes:
--   
--   <ul>
--   <li><i><tt>durationMs</tt></i> The duration, formatted in
--   milliseconds, to 2 decimal places</li>
--   </ul>
--   
--   This representation is not an API, and may change at any time (within
--   reason) without a major version bump.
requestToJSON :: Request -> [ByteString] -> Maybe NominalDiffTime -> Value


-- | Automatic gzip compression of responses.
module Network.Wai.Middleware.Gzip

-- | Use gzip to compress the body of the response.
gzip :: GzipSettings -> Middleware
data GzipSettings

-- | Default settings for the <a>gzip</a> middleware.
--   
--   <ul>
--   <li>Does not compress files.</li>
--   <li>Uses <a>defaultCheckMime</a>.</li>
--   <li>Compession threshold set to 860 bytes.</li>
--   </ul>
defaultGzipSettings :: GzipSettings

-- | Gzip behavior for files
--   
--   Only applies to <a>ResponseFile</a> (<a>responseFile</a>) responses.
--   So any streamed data will be compressed based solely on the response
--   headers having the right "Content-Type" and "Content-Length". (which
--   are checked with <a>gzipCheckMime</a> and <a>gzipSizeThreshold</a>,
--   respectively)
gzipFiles :: GzipSettings -> GzipFiles

-- | Decide which files to compress based on MIME type
--   
--   The <a>ByteString</a> is the value of the "Content-Type" response
--   header and will default to <a>False</a> if the header is missing.
--   
--   E.g. if you'd only want to compress <tt>json</tt> data, you might
--   define your own function as follows:
--   
--   <pre>
--   myCheckMime mime = mime == "application/json"
--   </pre>
gzipCheckMime :: GzipSettings -> ByteString -> Bool

-- | Skip compression when the size of the response body is below this
--   amount of bytes (default: 860.)
--   
--   <i>Setting this option to less than 150 will actually increase</i>
--   <i>the size of outgoing data if its original size is less than 150
--   bytes</i>.
--   
--   This will only skip compression if the response includes a
--   "Content-Length" header <i>AND</i> the length is less than this
--   threshold.
gzipSizeThreshold :: GzipSettings -> Integer

-- | Gzip behavior for files.
data GzipFiles

-- | Do not compress file (<a>ResponseFile</a>) responses. Any
--   <a>ResponseBuilder</a> or <a>ResponseStream</a> might still be
--   compressed.
GzipIgnore :: GzipFiles

-- | Compress files. Note that this may counteract zero-copy response
--   optimizations on some platforms.
GzipCompress :: GzipFiles

-- | Compress files, caching the compressed version in the given directory.
GzipCacheFolder :: FilePath -> GzipFiles

-- | Takes the ETag response header into consideration when caching files
--   in the given folder. If there's no ETag header, this setting is
--   equivalent to <a>GzipCacheFolder</a>.
--   
--   N.B. Make sure the <a>gzip</a> middleware is applied before any
--   <a>Middleware</a> that will set the ETag header.
GzipCacheETag :: FilePath -> GzipFiles

-- | If we use compression then try to use the filename with ".gz" appended
--   to it. If the file is missing then try next action.
GzipPreCompressed :: GzipFiles -> GzipFiles

-- | MIME types that will be compressed by default: <tt>text/</tt>
--   <tt>*</tt>, <tt>application/json</tt>,
--   <tt>application/javascript</tt>, <tt>application/ecmascript</tt>,
--   <tt>image/x-icon</tt>.
defaultCheckMime :: ByteString -> Bool

-- | The default value for this type.
def :: Default a => a
instance GHC.Read.Read Network.Wai.Middleware.Gzip.GzipFiles
instance GHC.Classes.Eq Network.Wai.Middleware.Gzip.GzipFiles
instance GHC.Show.Show Network.Wai.Middleware.Gzip.GzipFiles
instance Data.Default.Class.Default Network.Wai.Middleware.Gzip.GzipSettings

module Network.Wai.Middleware.AcceptOverride
acceptOverride :: Middleware
