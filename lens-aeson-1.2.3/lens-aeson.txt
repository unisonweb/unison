-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Law-abiding lenses for aeson
--   
--   Law-abiding lenses for aeson.
@package lens-aeson
@version 1.2.3


-- | This module also exports orphan <tt><a>Ixed</a> <a>Value</a></tt> and
--   <tt><a>Plated</a> <a>Value</a></tt> instances.
module Data.Aeson.Lens
class AsNumber t

-- | <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 0 . _Number
--   Just 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 1 . _Number
--   Nothing
--   </pre>
_Number :: AsNumber t => Prism' t Scientific

-- | <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 0 . _Number
--   Just 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 1 . _Number
--   Nothing
--   </pre>
_Number :: (AsNumber t, AsValue t) => Prism' t Scientific

-- | Prism into an <a>Double</a> over a <a>Value</a> or <a>Scientific</a>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.2]" ^? nth 0 . _Double
--   Just 10.2
--   </pre>
_Double :: AsNumber t => Prism' t Double

-- | Prism into an <a>Integer</a> over a <a>Value</a> or <a>Scientific</a>
--   
--   <pre>
--   &gt;&gt;&gt; "[10]" ^? nth 0 . _Integer
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.5]" ^? nth 0 . _Integer
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "42" ^? _Integer
--   Just 42
--   </pre>
_Integer :: AsNumber t => Prism' t Integer

-- | Access Integer <a>Value</a>s as Integrals.
--   
--   <pre>
--   &gt;&gt;&gt; "[10]" ^? nth 0 . _Integral
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.5]" ^? nth 0 . _Integral
--   Just 10
--   </pre>
_Integral :: (AsNumber t, Integral a) => Prism' t a

-- | Prism into non-<a>Null</a> values
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "a" . nonNull
--   Just (String "xyz")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "a" . nonNull
--   Just (Object (fromList []))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "b" . nonNull
--   Nothing
--   </pre>
nonNull :: Prism' Value Value
class AsNumber t => AsValue t

-- | <pre>
--   &gt;&gt;&gt; preview _Value "[1,2,3]" == Just (Array (Vector.fromList [Number 1.0,Number 2.0,Number 3.0]))
--   True
--   </pre>
_Value :: AsValue t => Prism' t Value

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "a" . _String
--   Just "xyz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "b" . _String
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Object._Wrapped # [("key" :: Key, _String # "value")] :: String
--   "{\"key\":\"value\"}"
--   </pre>
_String :: AsValue t => Prism' t Text

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "b" . _Bool
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "a" . _Bool
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Bool # True :: String
--   "true"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Bool # False :: String
--   "false"
--   </pre>
_Bool :: AsValue t => Prism' t Bool

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "b" . _Null
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "a" . _Null
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Null # () :: String
--   "null"
--   </pre>
_Null :: AsValue t => Prism' t ()

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "a" . _Object
--   Just (fromList [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "b" . _Object
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Object._Wrapped # [("key" :: Key, _String # "value")] :: String
--   "{\"key\":\"value\"}"
--   </pre>
_Object :: AsValue t => Prism' t (KeyMap Value)

-- | <pre>
--   &gt;&gt;&gt; preview _Array "[1,2,3]" == Just (Vector.fromList [Number 1.0,Number 2.0,Number 3.0])
--   True
--   </pre>
_Array :: AsValue t => Prism' t (Vector Value)

-- | Like <a>ix</a>, but for <a>Object</a> with <a>Key</a> indices. This
--   often has better inference than <a>ix</a> when used with
--   OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" ^? key "a"
--   Just (Number 100.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^? key "a"
--   Nothing
--   </pre>
key :: AsValue t => Key -> Traversal' t Value

-- | Like <a>key</a>, but uses <a>at</a> instead of <a>ix</a>. This is
--   handy when adding and removing object keys:
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" &amp; atKey "a" .~ Nothing
--   "{\"b\":200}"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" &amp; atKey "c" ?~ String "300"
--   "{\"a\":100,\"b\":200,\"c\":\"300\"}"
--   </pre>
atKey :: AsValue t => Key -> Traversal' t (Maybe Value)

-- | An indexed Traversal into Object properties
--   
--   <pre>
--   &gt;&gt;&gt; Data.List.sort ("{\"a\": 4, \"b\": 7}" ^@.. members . _Number)
--   [("a",4.0),("b",7.0)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 4}" &amp; members . _Number *~ 10
--   "{\"a\":40}"
--   </pre>
members :: AsValue t => IndexedTraversal' Key t Value

-- | Like <a>ix</a>, but for Arrays with Int indexes
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^? nth 1
--   Just (Number 2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" ^? nth 1
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" &amp; nth 1 .~ Number 20
--   "[1,20,3]"
--   </pre>
nth :: AsValue t => Int -> Traversal' t Value

-- | An indexed Traversal into Array elements
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^.. values
--   [Number 1.0,Number 2.0,Number 3.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" &amp; values . _Number *~ 10
--   "[10,20,30]"
--   </pre>
values :: AsValue t => IndexedTraversal' Int t Value
class IsKey t

-- | <a>_Key</a> is an <a>ReifiedIso</a> from something to a <a>Key</a>.
--   This is primarily intended for situations where one wishes to use
--   object keys that are not string literals and therefore must be
--   converted:
--   
--   <pre>
--   &gt;&gt;&gt; let k = "a" :: Text
--   
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" ^? key (k ^. _Key)
--   Just (Number 100.0)
--   </pre>
--   
--   Note that applying <a>_Key</a> directly to a string literal (e.g.,
--   <tt>"a" ^. <a>_Key</a></tt>) will likely not typecheck when
--   <tt>OverloadedStrings</tt> is enabled.
_Key :: IsKey t => Iso' t Key
class AsJSON t

-- | <a>_JSON</a> is a <a>ReifiedPrism</a> from something containing JSON
--   to something encoded in that structure
_JSON :: (AsJSON t, FromJSON a, ToJSON b) => Prism t t a b
_JSON' :: (AsJSON t, FromJSON a, ToJSON a) => Prism' t a
pattern JSON :: (FromJSON a, ToJSON a, AsJSON t) => () => a -> t
pattern Value_ :: (FromJSON a, ToJSON a) => () => a -> Value
pattern Number_ :: AsNumber t => Scientific -> t
pattern Double :: AsNumber t => Double -> t
pattern Integer :: AsNumber t => Integer -> t
pattern Integral :: (AsNumber t, Integral a) => a -> t
pattern Bool_ :: AsValue t => Bool -> t
pattern String_ :: AsValue t => Text -> t
pattern Null_ :: AsValue t => t
pattern Key_ :: IsKey t => Key -> t
instance Data.Aeson.Lens.AsValue Data.ByteString.Internal.Type.ByteString
instance Data.Aeson.Lens.AsValue Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsValue GHC.Base.String
instance Data.Aeson.Lens.AsValue Data.Text.Internal.Text
instance Data.Aeson.Lens.AsValue Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsJSON Data.ByteString.Internal.Type.ByteString
instance Data.Aeson.Lens.AsJSON Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsJSON GHC.Base.String
instance Data.Aeson.Lens.AsJSON Data.Text.Internal.Text
instance Data.Aeson.Lens.AsJSON Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsJSON Data.Aeson.Types.Internal.Value
instance Data.Aeson.Lens.IsKey Data.Aeson.Key.Key
instance Data.Aeson.Lens.IsKey GHC.Base.String
instance Data.Aeson.Lens.IsKey Data.Text.Internal.Text
instance Data.Aeson.Lens.IsKey Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.IsKey Data.Text.Short.Internal.ShortText
instance Data.Aeson.Lens.IsKey Data.ByteString.Internal.Type.ByteString
instance Data.Aeson.Lens.IsKey Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsNumber Data.Aeson.Types.Internal.Value
instance Data.Aeson.Lens.AsNumber Data.Scientific.Scientific
instance Data.Aeson.Lens.AsNumber Data.ByteString.Internal.Type.ByteString
instance Data.Aeson.Lens.AsNumber Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsNumber Data.Text.Internal.Text
instance Data.Aeson.Lens.AsNumber Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsNumber GHC.Base.String
instance Data.Aeson.Lens.AsValue Data.Aeson.Types.Internal.Value
instance Control.Lens.At.Ixed Data.Aeson.Types.Internal.Value
instance Control.Lens.Plated.Plated Data.Aeson.Types.Internal.Value
instance Control.Lens.At.Ixed (Data.Aeson.KeyMap.KeyMap v)
instance Control.Lens.At.At (Data.Aeson.KeyMap.KeyMap v)
instance Control.Lens.Each.Each (Data.Aeson.KeyMap.KeyMap a) (Data.Aeson.KeyMap.KeyMap b) a b
instance (t GHC.Types.~ Data.Aeson.KeyMap.KeyMap v') => Control.Lens.Wrapped.Rewrapped (Data.Aeson.KeyMap.KeyMap v) t
instance Control.Lens.Wrapped.Wrapped (Data.Aeson.KeyMap.KeyMap v)
