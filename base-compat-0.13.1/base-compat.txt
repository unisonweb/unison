-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A compatibility layer for base
--   
--   Provides functions available in later versions of <tt>base</tt> to a
--   wider range of compilers, without requiring you to use CPP pragmas in
--   your code. See the <a>README</a> for what is covered. Also see the
--   <a>changelog</a> for recent changes.
--   
--   Note that <tt>base-compat</tt> does not add any orphan instances.
--   There is a separate package, <tt><a>base-orphans</a></tt>, for that.
--   
--   In addition, <tt>base-compat</tt> does not backport any data types or
--   type classes. See <tt><a>this section of the README</a></tt> for more
--   info.
--   
--   <tt>base-compat</tt> is designed to have zero dependencies. For a
--   version of <tt>base-compat</tt> that depends on compatibility
--   libraries for a wider support window, see the
--   <tt><a>base-compat-batteries</a></tt> package. Most of the modules in
--   this library have the same names as in <tt>base-compat-batteries</tt>
--   to make it easier to switch between the two. There also exist versions
--   of each module with the suffix <tt>.Repl</tt>, which are distinct from
--   anything in <tt>base-compat-batteries</tt>, to allow for easier use in
--   GHCi.
@package base-compat
@version 0.13.1

module Control.Concurrent.Compat

-- | Fork a thread and call the supplied function when the thread is about
--   to terminate, with an exception or a returned value. The function is
--   called with asynchronous exceptions masked.
--   
--   <pre>
--   forkFinally action and_then =
--     mask $ \restore -&gt;
--       forkIO $ try (restore action) &gt;&gt;= and_then
--   </pre>
--   
--   This function is useful for informing the parent when a child
--   terminates, for example.
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is a bound thread,
--   as with <a>forkOS</a>.
forkOSWithUnmask :: ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId


-- | Reexports <a>Control.Concurrent.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.Compat.Repl

module Control.Concurrent.MVar.Compat

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
withMVarMasked :: MVar a -> (a -> IO b) -> IO b


-- | Reexports <a>Control.Concurrent.MVar.Compat</a> from a globally unique
--   namespace.
module Control.Concurrent.MVar.Compat.Repl

module Control.Exception.Compat

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
--   
--   WARNING: You may want to use <tt>throwIO</tt> instead so that your
--   pure code stays exception-free.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a


-- | Reexports <a>Control.Exception.Compat</a> from a globally unique
--   namespace.
module Control.Exception.Compat.Repl

module Control.Monad.Compat

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions using <a>(&lt;|&gt;)</a>,
--   generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage, using the <a>MonadPlus</a> instance for <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; msum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results:
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (\x1 -&gt; m2
--   <a>&gt;&gt;=</a> (\x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
--   
--   <tt>fail s</tt> should be an action that runs in the monad itself, not
--   an exception (except in instances of <tt>MonadIO</tt>). In particular,
--   <tt>fail</tt> should not be implemented in terms of <tt>error</tt>.
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a


-- | Reexports <a>Control.Monad.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Compat.Repl

module Control.Monad.Fail.Compat


-- | Reexports <a>Control.Monad.Fail.Compat</a> from a globally unique
--   namespace.
module Control.Monad.Fail.Compat.Repl

module Control.Monad.IO.Class.Compat


-- | Reexports <a>Control.Monad.IO.Class.Compat</a> from a globally unique
--   namespace.
module Control.Monad.IO.Class.Compat.Repl

module Control.Monad.ST.Lazy.Unsafe.Compat
unsafeInterleaveST :: ST s a -> ST s a
unsafeIOToST :: IO a -> ST s a


-- | Reexports <a>Control.Monad.ST.Lazy.Unsafe.Compat</a> from a globally
--   unique namespace.
module Control.Monad.ST.Lazy.Unsafe.Compat.Repl

module Control.Monad.ST.Unsafe.Compat

-- | <a>unsafeInterleaveST</a> allows an <a>ST</a> computation to be
--   deferred lazily. When passed a value of type <tt>ST a</tt>, the
--   <a>ST</a> computation will only be performed when the value of the
--   <tt>a</tt> is demanded.
unsafeInterleaveST :: ST s a -> ST s a

-- | Convert an <a>IO</a> action to an <a>ST</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
unsafeIOToST :: IO a -> ST s a

-- | Convert an <a>ST</a> action to an <a>IO</a> action. This relies on
--   <a>IO</a> and <a>ST</a> having the same representation modulo the
--   constraint on the state thread type parameter.
--   
--   For an example demonstrating why this is unsafe, see
--   <a>https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html</a>
unsafeSTToIO :: ST s a -> IO a


-- | Reexports <a>Control.Monad.ST.Unsafe.Compat</a> from a globally unique
--   namespace.
module Control.Monad.ST.Unsafe.Compat.Repl

module Data.Bifoldable.Compat


-- | Reexports <a>Data.Bifoldable.Compat</a> from a globally unique
--   namespace.
module Data.Bifoldable.Compat.Repl

module Data.Bifoldable1.Compat


-- | Reexports <a>Data.Bifoldable1.Compat</a> from a globally unique
--   namespace.
module Data.Bifoldable1.Compat.Repl

module Data.Bifunctor.Compat


-- | Reexports <a>Data.Bifunctor.Compat</a> from a globally unique
--   namespace.
module Data.Bifunctor.Compat.Repl

module Data.Bitraversable.Compat


-- | Reexports <a>Data.Bitraversable.Compat</a> from a globally unique
--   namespace.
module Data.Bitraversable.Compat.Repl

module Data.Bits.Compat

-- | Default implementation for <a>bit</a>.
--   
--   Note that: <tt>bitDefault i = 1 <a>shiftL</a> i</tt>
bitDefault :: (Bits a, Num a) => Int -> a

-- | Default implementation for <a>testBit</a>.
--   
--   Note that: <tt>testBitDefault x i = (x .&amp;. bit i) /= 0</tt>
testBitDefault :: (Bits a, Num a) => a -> Int -> Bool

-- | Default implementation for <a>popCount</a>.
--   
--   This implementation is intentionally naive. Instances are expected to
--   provide an optimized implementation for their size.
popCountDefault :: (Bits a, Num a) => a -> Int

-- | Infix version of <a>xor</a>.
(.^.) :: Bits a => a -> a -> a
infixl 6 .^.

-- | Infix version of <a>shiftR</a>.
(.>>.) :: Bits a => a -> Int -> a
infixl 8 .>>.

-- | Infix version of <a>shiftL</a>.
(.<<.) :: Bits a => a -> Int -> a
infixl 8 .<<.

-- | Infix version of <a>unsafeShiftR</a>.
(!>>.) :: Bits a => a -> Int -> a
infixl 8 !>>.

-- | Infix version of <a>unsafeShiftL</a>.
(!<<.) :: Bits a => a -> Int -> a
infixl 8 !<<.

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == toInteger y = Just y
--     | otherwise                  = Nothing
--     where
--       y = fromIntegral x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | A more concise version of <tt>complement zeroBits</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; complement (zeroBits :: Word) == (oneBits :: Word)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; complement (oneBits :: Word) == (zeroBits :: Word)
--   True
--   </pre>
--   
--   <h1>Note</h1>
--   
--   The constraint on <a>oneBits</a> is arguably too strong. However, as
--   some types (such as <tt>Natural</tt>) have undefined
--   <a>complement</a>, this is the only safe choice.
oneBits :: FiniteBits a => a


-- | Reexports <a>Data.Bits.Compat</a> from a globally unique namespace.
module Data.Bits.Compat.Repl

module Data.Bool.Compat

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Reexports <a>Data.Bool.Compat</a> from a globally unique namespace.
module Data.Bool.Compat.Repl

module Data.Complex.Compat


-- | Reexports <a>Data.Complex.Compat</a> from a globally unique namespace.
module Data.Complex.Compat.Repl

module Data.Either.Compat

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b


-- | Reexports <a>Data.Either.Compat</a> from a globally unique namespace.
module Data.Either.Compat.Repl

module Data.Foldable.Compat


-- | Reexports <a>Data.Foldable.Compat</a> from a globally unique
--   namespace.
module Data.Foldable.Compat.Repl

module Data.Foldable1.Compat


-- | Reexports <a>Data.Foldable1.Compat</a> from a globally unique
--   namespace.
module Data.Foldable1.Compat.Repl

module Data.Function.Compat

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <a>applyWhen</a> applies a function to a value if a condition is true,
--   otherwise, it returns the value unchanged.
--   
--   It is equivalent to <tt><a>flip</a> (<a>bool</a> <a>id</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>applyWhen <a>True</a> = <a>id</a></pre></li>
--   <li><pre>applyWhen <a>False</a> f = <a>id</a></pre></li>
--   </ul>
applyWhen :: Bool -> (a -> a) -> a -> a


-- | Reexports <a>Data.Function.Compat</a> from a globally unique
--   namespace.
module Data.Function.Compat.Repl

module Data.Functor.Compat

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds. See
--   <a>https://www.schoolofhaskell.com/user/edwardk/snippets/fmap</a> or
--   <a>https://github.com/quchen/articles/blob/master/second_functor_law.md</a>
--   for an explanation.
class () => Functor (f :: Type -> Type)

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   <h4><b>Examples</b></h4>
--   
--   Perform a computation with <a>Maybe</a> and replace the result with a
--   constant value if it is <a>Just</a>:
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;$ Just 2
--   Just 'a'
--   
--   &gt;&gt;&gt; 'a' &lt;$ Nothing
--   Nothing
--   </pre>
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Generalization of <tt>Data.List.</tt><a>unzip</a>.
--   
--   <i>Since: 4.19.0.0</i>
unzip :: Functor f => f (a, b) -> (f a, f b)


-- | Reexports <a>Data.Functor.Compat</a> from a globally unique namespace.
module Data.Functor.Compat.Repl

module Data.Functor.Compose.Compat


-- | Reexports <a>Data.Functor.Compose.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Compose.Compat.Repl

module Data.Functor.Const.Compat

-- | The <a>Const</a> functor.
newtype () => Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a


-- | Reexports <a>Data.Functor.Const.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Const.Compat.Repl

module Data.Functor.Contravariant.Compat


-- | Reexports <a>Data.Functor.Contravariant.Compat</a> from a globally
--   unique namespace.
module Data.Functor.Contravariant.Compat.Repl

module Data.Functor.Identity.Compat


-- | Reexports <a>Data.Functor.Identity.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Identity.Compat.Repl

module Data.Functor.Product.Compat


-- | Reexports <a>Data.Functor.Product.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Product.Compat.Repl

module Data.Functor.Sum.Compat


-- | Reexports <a>Data.Functor.Sum.Compat</a> from a globally unique
--   namespace.
module Data.Functor.Sum.Compat.Repl

module Data.IORef.Compat

-- | Strict version of <a>modifyIORef</a>. This is not an atomic update,
--   consider using <a>atomicModifyIORef'</a> when operating in a
--   multithreaded environment.
modifyIORef' :: IORef a -> (a -> a) -> IO ()

-- | Strict version of <a>atomicModifyIORef</a>. This forces both the value
--   stored in the <a>IORef</a> and the value returned. The new value is
--   installed in the <a>IORef</a> before the returned value is forced. So
--   
--   <pre>
--   atomicModifyIORef' ref (x -&gt; (x+1, undefined))
--   </pre>
--   
--   will increment the <a>IORef</a> and then throw an exception in the
--   calling thread.
--   
--   This function imposes a memory barrier, preventing reordering; see
--   <a>Data.IORef#memmodel</a> for details.
atomicModifyIORef' :: IORef a -> (a -> (a, b)) -> IO b

-- | Variant of <a>writeIORef</a>. The prefix "atomic" relates to a fact
--   that it imposes a reordering barrier, similar to
--   <a>atomicModifyIORef</a>. Such a write will not be reordered with
--   other reads or writes even on CPUs with weak memory model.
atomicWriteIORef :: IORef a -> a -> IO ()


-- | Reexports <a>Data.IORef.Compat</a> from a globally unique namespace.
module Data.IORef.Compat.Repl


-- | This backports the modern <a>Data.Semigroup</a> interface back to
--   <tt>base-4.9</tt>/GHC 8.0.
module Data.List.NonEmpty.Compat

-- | Non-empty (and non-strict) list type.
data () => NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Map a function over a <a>NonEmpty</a> stream.
map :: (a -> b) -> NonEmpty a -> NonEmpty b

-- | 'intersperse x xs' alternates elements of the list with copies of
--   <tt>x</tt>.
--   
--   <pre>
--   intersperse 0 (1 :| [2,3]) == 1 :| [0,2,0,3]
--   </pre>
intersperse :: a -> NonEmpty a -> NonEmpty a

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a stream of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == z :| [z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == x1 :| [x1 `f` x2, x1 `f` (x2 `f` x3), ...]
--   </pre>
scanl1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (a -> a -> a) -> NonEmpty a -> NonEmpty a

-- | <a>transpose</a> for <a>NonEmpty</a>, behaves the same as
--   <a>transpose</a> The rows/columns need not be the same length, in
--   which case &gt; transpose . transpose /= id
transpose :: NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)

-- | <a>sortBy</a> for <a>NonEmpty</a>, behaves the same as <a>sortBy</a>
sortBy :: (a -> a -> Ordering) -> NonEmpty a -> NonEmpty a

-- | <a>sortWith</a> for <a>NonEmpty</a>, behaves the same as:
--   
--   <pre>
--   sortBy . comparing
--   </pre>
sortWith :: Ord o => (a -> o) -> NonEmpty a -> NonEmpty a

-- | Number of elements in <a>NonEmpty</a> list.
length :: NonEmpty a -> Int

-- | Extract the first element of the stream.
head :: NonEmpty a -> a

-- | Extract the possibly-empty tail of the stream.
tail :: NonEmpty a -> [a]

-- | Extract the last element of the stream.
last :: NonEmpty a -> a

-- | Extract everything except the last element of the stream.
init :: NonEmpty a -> [a]

-- | Construct a <a>NonEmpty</a> list from a single element.
singleton :: a -> NonEmpty a

-- | Prepend an element to the stream.
(<|) :: a -> NonEmpty a -> NonEmpty a
infixr 5 <|

-- | Synonym for <a>&lt;|</a>.
cons :: a -> NonEmpty a -> NonEmpty a

-- | <a>uncons</a> produces the first element of the stream, and a stream
--   of the remaining elements, if any.
uncons :: NonEmpty a -> (a, Maybe (NonEmpty a))

-- | The <a>unfoldr</a> function is analogous to <a>Data.List</a>'s
--   <a>unfoldr</a> operation.
unfoldr :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | Sort a stream.
sort :: Ord a => NonEmpty a -> NonEmpty a

-- | <a>reverse</a> a finite NonEmpty stream.
reverse :: NonEmpty a -> NonEmpty a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>, starting with the shortest. The
--   result is <a>NonEmpty</a> because the result always contains the empty
--   list as the first element.
--   
--   <pre>
--   inits [1,2,3] == [] :| [[1], [1,2], [1,2,3]]
--   inits [1] == [] :| [[1]]
--   inits [] == [] :| []
--   </pre>
inits :: Foldable f => f a -> NonEmpty [a]

-- | The <a>inits1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the <a>NonEmpty</a> finite prefixes of <tt>xs</tt>,
--   starting with the shortest.
--   
--   <pre>
--   inits1 (1 :| [2,3]) == (1 :| []) :| [1 :| [2], 1 :| [2,3]]
--   inits1 (1 :| []) == (1 :| []) :| []
--   </pre>
inits1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>, starting with the longest. The result is
--   <a>NonEmpty</a> because the result always contains the empty list as
--   the last element.
--   
--   <pre>
--   tails [1,2,3] == [1,2,3] :| [[2,3], [3], []]
--   tails [1] == [1] :| [[]]
--   tails [] == [] :| []
--   </pre>
tails :: Foldable f => f a -> NonEmpty [a]

-- | The <a>tails1</a> function takes a <a>NonEmpty</a> stream <tt>xs</tt>
--   and returns all the non-empty suffixes of <tt>xs</tt>, starting with
--   the longest.
--   
--   <pre>
--   tails1 (1 :| [2,3]) == (1 :| [2,3]) :| [2 :| [3], 3 :| []]
--   tails1 (1 :| []) == (1 :| []) :| []
--   </pre>
tails1 :: NonEmpty a -> NonEmpty (NonEmpty a)

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = x :| [f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> NonEmpty a

-- | <tt><a>repeat</a> x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> NonEmpty a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle (1 :| [2,3]) = 1 :| [2,3,1,2,3,...]
--   </pre>
cycle :: NonEmpty a -> NonEmpty a

-- | <a>unfold</a> produces a new stream by repeatedly applying the
--   unfolding function to the seed value to produce an element of type
--   <tt>b</tt> and a new seed value. When the unfolding function returns
--   <a>Nothing</a> instead of a new seed value, the stream ends.
unfold :: (a -> (b, Maybe a)) -> a -> NonEmpty b

-- | <tt><a>insert</a> x xs</tt> inserts <tt>x</tt> into the last position
--   in <tt>xs</tt> where it is still less than or equal to the next
--   element. In particular, if the list is sorted beforehand, the result
--   will also be sorted.
insert :: (Foldable f, Ord a) => a -> f a -> NonEmpty a

-- | <tt><a>some1</a> x</tt> sequences <tt>x</tt> one or more times.
some1 :: Alternative f => f a -> f (NonEmpty a)

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
take :: Int -> NonEmpty a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Int -> NonEmpty a -> [a]

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <pre>
--   'splitAt' n xs == ('take' n xs, 'drop' n xs)
--   xs == ys ++ zs where (ys, zs) = 'splitAt' n xs
--   </pre>
splitAt :: Int -> NonEmpty a -> ([a], [a])

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
dropWhile :: (a -> Bool) -> NonEmpty a -> [a]

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
--   
--   <pre>
--   'span' p xs == ('takeWhile' p xs, 'dropWhile' p xs)
--   xs == ys ++ zs where (ys, zs) = 'span' p xs
--   </pre>
span :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <tt><a>break</a> p</tt> function is equivalent to <tt><a>span</a>
--   (not . p)</tt>.
break :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | <tt><a>filter</a> p xs</tt> removes any elements from <tt>xs</tt> that
--   do not satisfy <tt>p</tt>.
filter :: (a -> Bool) -> NonEmpty a -> [a]

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of lists. The first list
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <pre>
--   'partition' p xs = ('filter' p xs, 'filter' (not . p) xs)
--   </pre>
partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])

-- | The <a>group</a> function takes a stream and returns a list of streams
--   such that flattening the resulting list is equal to the argument.
--   Moreover, each stream in the resulting list contains only equal
--   elements. For example, in list notation:
--   
--   <pre>
--   'group' $ 'cycle' "Mississippi"
--     = "M" : "i" : "ss" : "i" : "ss" : "i" : "pp" : "i" : "M" : "i" : ...
--   </pre>
group :: (Foldable f, Eq a) => f a -> [NonEmpty a]

-- | <a>groupBy</a> operates like <a>group</a>, but uses the provided
--   equality predicate instead of <a>==</a>.
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]

-- | <a>groupWith</a> operates like <a>group</a>, but uses the provided
--   projection when comparing for equality
groupWith :: (Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]

-- | <a>groupAllWith</a> operates like <a>groupWith</a>, but sorts the list
--   first so that each equivalence class has, at most, one list in the
--   output
groupAllWith :: Ord b => (a -> b) -> [a] -> [NonEmpty a]

-- | <a>group1</a> operates like <a>group</a>, but uses the knowledge that
--   its input is non-empty to produce guaranteed non-empty output.
group1 :: Eq a => NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupBy1</a> is to <a>group1</a> as <a>groupBy</a> is to
--   <a>group</a>.
groupBy1 :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupWith1</a> is to <a>group1</a> as <a>groupWith</a> is to
--   <a>group</a>
groupWith1 :: Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | <a>groupAllWith1</a> is to <a>groupWith1</a> as <a>groupAllWith</a> is
--   to <a>groupWith</a>
groupAllWith1 :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)

-- | The <a>isPrefixOf</a> function returns <a>True</a> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> NonEmpty a -> Bool

-- | The <a>nub</a> function removes duplicate elements from a list. In
--   particular, it keeps only the first occurrence of each element. (The
--   name <a>nub</a> means 'essence'.) It is a special case of
--   <a>nubBy</a>, which allows the programmer to supply their own
--   inequality test.
nub :: Eq a => NonEmpty a -> NonEmpty a

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
nubBy :: (a -> a -> Bool) -> NonEmpty a -> NonEmpty a

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: a negative or out-of-bounds index will cause an error.
(!!) :: HasCallStack => NonEmpty a -> Int -> a
infixl 9 !!

-- | The <a>zip</a> function takes two streams and returns a stream of
--   corresponding pairs.
zip :: NonEmpty a -> NonEmpty b -> NonEmpty (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the elements, the elements are combined using the function
--   passed as the first argument.
zipWith :: (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Converts a normal list to a <a>NonEmpty</a> stream.
--   
--   Raises an error if given an empty list.
fromList :: HasCallStack => [a] -> NonEmpty a

-- | Convert a stream to a normal list efficiently.
toList :: NonEmpty a -> [a]

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Compute n-ary logic exclusive OR operation on <a>NonEmpty</a> list.
xor :: NonEmpty Bool -> Bool


-- | Reexports <a>Data.List.NonEmpty.Compat</a> from a globally unique
--   namespace.
module Data.List.NonEmpty.Compat.Repl

module Data.Monoid.Compat

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype () => Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype () => Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype () => Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Maybe monoid returning the rightmost non-<a>Nothing</a> value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <tt>Data.Semigroup.</tt><a>Last</a>. The former returns the last
--   non-<a>Nothing</a>, so <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>. The latter simply returns the last value, thus <tt>x &lt;&gt;
--   Data.Semigroup.Last Nothing = Data.Semigroup.Last Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world")
--   Last {getLast = Just "world"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Last Nothing &lt;&gt; mempty
--   Last {getLast = Nothing}
--   </pre>
newtype () => Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | Maybe monoid returning the leftmost non-<a>Nothing</a> value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   Beware that <tt>Data.Monoid.</tt><a>First</a> is different from
--   <tt>Data.Semigroup.</tt><a>First</a>. The former returns the first
--   non-<a>Nothing</a>, so <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>. The latter simply returns the first value, thus
--   <tt>Data.Semigroup.First Nothing &lt;&gt; x = Data.Semigroup.First
--   Nothing</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world")
--   First {getFirst = Just "hello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; First Nothing &lt;&gt; mempty
--   First {getFirst = Nothing}
--   </pre>
newtype () => First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   You can alternatively define <a>mconcat</a> instead of <a>mempty</a>,
--   in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>mconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>mconcat</a> (<a>join</a> xss) =
--   <a>mconcat</a> (<a>fmap</a> <a>mconcat</a> xss)</tt></li>
--   <li><i>Subclass</i> <tt><a>mconcat</a> (<tt>toList</tt> xs) =
--   <a>sconcat</a> xs</tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mempty &lt;&gt; [1, 2, 3]
--   [1,2,3]
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   Alt l &lt;&gt; Alt r == Alt (l &lt;|&gt; r)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Alt (Just 12) &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Alt Nothing &lt;&gt; Alt (Just 24)
--   Alt {getAlt = Just 24}
--   </pre>
newtype () => Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype () => All
All :: Bool -> All
[getAll] :: All -> Bool

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype () => Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype () => Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Ap (Just [1, 2, 3]) &lt;&gt; Ap Nothing
--   Ap {getAp = Nothing}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ap [Sum 10, Sum 20] &lt;&gt; Ap [Sum 1, Sum 2]
--   Ap {getAp = [Sum {getSum = 11},Sum {getSum = 12},Sum {getSum = 21},Sum {getSum = 22}]}
--   </pre>
newtype () => Ap (f :: k -> Type) (a :: k)
Ap :: f a -> Ap (f :: k -> Type) (a :: k)
[getAp] :: Ap (f :: k -> Type) (a :: k) -> f a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>


-- | Reexports <a>Data.Monoid.Compat</a> from a globally unique namespace.
module Data.Monoid.Compat.Repl

module Data.Proxy.Compat

-- | <a>asProxyTypeOf</a> is a type-restricted version of <a>const</a>. It
--   is usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   tag of the second.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Proxy :: Proxy Word8)
--   asProxyTypeOf 123 (Proxy :: Proxy Word8) :: Word8
--   </pre>
--   
--   Note the lower-case <tt>proxy</tt> in the definition. This allows any
--   type constructor with just one argument to be passed to the function,
--   for example we could also write
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Word
--   
--   &gt;&gt;&gt; :type asProxyTypeOf 123 (Just (undefined :: Word8))
--   asProxyTypeOf 123 (Just (undefined :: Word8)) :: Word8
--   </pre>
asProxyTypeOf :: a -> proxy a -> a


-- | Reexports <a>Data.Proxy.Compat</a> from a globally unique namespace.
module Data.Proxy.Compat.Repl

module Data.Ratio.Compat


-- | Reexports <a>Data.Ratio.Compat</a> from a globally unique namespace.
module Data.Ratio.Compat.Repl

module Data.STRef.Compat

-- | Strict version of <a>modifySTRef</a>
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()


-- | Reexports <a>Data.STRef.Compat</a> from a globally unique namespace.
module Data.STRef.Compat.Repl


-- | This backports the modern <a>Data.Semigroup</a> interface back to
--   <tt>base-4.9</tt>/GHC 8.0.
module Data.Semigroup.Compat

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
--   
--   You can alternatively define <a>sconcat</a> instead of
--   (<a>&lt;&gt;</a>), in which case the laws are:
--   
--   <ul>
--   <li><i>Unit</i> <tt><a>sconcat</a> (<a>pure</a> x) = x</tt></li>
--   <li><i>Multiplication</i> <tt><a>sconcat</a> (<a>join</a> xss) =
--   <a>sconcat</a> (<a>fmap</a> <a>sconcat</a> xss)</tt></li>
--   </ul>
class () => Semigroup a

-- | An associative operation.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [1, 2, 3] &lt;&gt; Just [4, 5, 6]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, " &lt;&gt; putStrLn "World!"
--   Hello, World!
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <h4><b>Examples</b></h4>
--   
--   For the following examples, we will assume that we have:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty (NonEmpty (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Just [1, 2, 3] :| [Nothing, Just [4, 5, 6]]
--   Just [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Left 1 :| [Right 2, Left 3, Right 4]
--   Right 2
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   The default definition will raise an exception for a multiplier that
--   is <tt>&lt;= 0</tt>. This may be overridden with an implementation
--   that is total. For monoids it is preferred to use
--   <tt>stimesMonoid</tt>.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 5 (putStr "hi!")
--   hi!hi!hi!hi!hi!
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stimes 3 (Right ":)")
--   Right ":)"
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;.
stimesIdempotent :: Integral b => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   In many cases, <tt><a>stimes</a> 0 a</tt> for a <a>Monoid</a> will
--   produce <a>mempty</a>. However, there are situations when it cannot do
--   so. In particular, the following situation is fairly common:
--   
--   <pre>
--   data T a = ...
--   
--   class Constraint1 a
--   class Constraint1 a =&gt; Constraint2 a
--   </pre>
--   
--   <pre>
--   instance Constraint1 a =&gt; <a>Semigroup</a> (T a)
--   instance Constraint2 a =&gt; <a>Monoid</a> (T a)
--   </pre>
--   
--   Since <tt>Constraint1</tt> is insufficient to implement <a>mempty</a>,
--   <a>stimes</a> for <tt>T a</tt> cannot do so.
--   
--   When working with such a type, or when working polymorphically with
--   <a>Semigroup</a> instances, <tt>mtimesDefault</tt> should be used when
--   the multiplier might be zero. It is implemented using <a>stimes</a>
--   when the multiplier is nonzero and <a>mempty</a> when it is zero.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 0 "bark"
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mtimesDefault 3 "meow"
--   "meowmeowmeow"
--   </pre>
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | The <a>Min</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   smaller element as by the <a>Ord</a> instance and <a>min</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min 42 &lt;&gt; Min 3
--   Min 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Min 1 :| [ Min n | n &lt;- [2 .. 100]]
--   Min {getMin = 1}
--   </pre>
newtype () => Min a
Min :: a -> Min a
[getMin] :: Min a -> a

-- | The <a>Max</a> <a>Monoid</a> and <a>Semigroup</a> always choose the
--   bigger element as by the <a>Ord</a> instance and <a>max</a> of the
--   contained type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max 42 &lt;&gt; Max 3
--   Max 42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Max 1 :| [ Max n | n &lt;- [2 .. 100]]
--   Max {getMax = 100}
--   </pre>
newtype () => Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>First</a> is different from
--   <tt>Data.Monoid.</tt><a>First</a>. The former simply returns the first
--   value, so <tt>Data.Semigroup.First Nothing &lt;&gt; x =
--   Data.Semigroup.First Nothing</tt>. The latter returns the first
--   non-<a>Nothing</a>, thus <tt>Data.Monoid.First Nothing &lt;&gt; x =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; First 0 &lt;&gt; First 10
--   First 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ First 1 :| [ First n | n &lt;- [2 ..] ]
--   First 1
--   </pre>
newtype () => First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Beware that <tt>Data.Semigroup.</tt><a>Last</a> is different from
--   <tt>Data.Monoid.</tt><a>Last</a>. The former simply returns the last
--   value, so <tt>x &lt;&gt; Data.Semigroup.Last Nothing =
--   Data.Semigroup.Last Nothing</tt>. The latter returns the last
--   non-<a>Nothing</a>, thus <tt>x &lt;&gt; Data.Monoid.Last Nothing =
--   x</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Last 0 &lt;&gt; Last 10
--   Last {getLast = 10}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sconcat $ Last 1 :| [ Last n | n &lt;- [2..]]
--   Last {getLast = * hangs forever *
--   </pre>
newtype () => Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype () => WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>. | The dual of a <a>Monoid</a>, obtained by swapping
--   the arguments of <a>(&lt;&gt;)</a>.
--   
--   <pre>
--   Dual a &lt;&gt; Dual b == Dual (b &lt;&gt; a)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Dual "Hello" &lt;&gt; Dual "World"
--   Dual {getDual = "WorldHello"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Dual (Dual "Hello") &lt;&gt; Dual (Dual "World")
--   Dual {getDual = Dual {getDual = "HelloWorld"}}
--   </pre>
newtype () => Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   Endo f &lt;&gt; Endo g == Endo (f . g)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo (*3) &lt;&gt; Endo (+1)
--   
--   &gt;&gt;&gt; appEndo computation 1
--   6
--   </pre>
newtype () => Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Boolean monoid under conjunction <a>(&amp;&amp;)</a>.
--   
--   <pre>
--   All x &lt;&gt; All y = All (x &amp;&amp; y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty &lt;&gt; All False)
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8])
--   All {getAll = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; All True &lt;&gt; mempty
--   All {getAll = True}
--   </pre>
newtype () => All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Boolean monoid under disjunction <a>(||)</a>.
--   
--   <pre>
--   Any x &lt;&gt; Any y = Any (x || y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Any True &lt;&gt; mempty &lt;&gt; Any False
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8])
--   Any {getAny = True}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Any False &lt;&gt; mempty
--   Any {getAny = False}
--   </pre>
newtype () => Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Monoid under addition.
--   
--   <pre>
--   Sum a &lt;&gt; Sum b = Sum (a + b)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty
--   Sum {getSum = 3}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Sum n | n &lt;- [3 .. 9]]
--   Sum {getSum = 42}
--   </pre>
newtype () => Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   Product x &lt;&gt; Product y == Product (x * y)
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Product 3 &lt;&gt; Product 4 &lt;&gt; mempty
--   Product {getProduct = 12}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [ Product n | n &lt;- [2 .. 10]]
--   Product {getProduct = 3628800}
--   </pre>
newtype () => Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   let hello = diff "Hello, "
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo hello "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; mempty) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (mempty &lt;&gt; hello) "World!"
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   let world = diff "World"
--   let excl = diff "!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo (hello &lt;&gt; (world &lt;&gt; excl)) mempty
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; appEndo ((hello &lt;&gt; world) &lt;&gt; excl) mempty
--   "Hello, World!"
--   </pre>
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ cycle1 [1, 2, 3]
--   [1,2,3,1,2,3,1,2,3,1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Right 1)
--   Right 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cycle1 (Left 1)
--   * hangs forever *
--   </pre>
cycle1 :: Semigroup m => m -> m

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (x * x) x | x &lt;- [-10 .. 10] ]
--   Arg 0 0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg 3.8 4.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (-0.2*x^2 + 1.5*x + 1) x | x &lt;- [-10 .. 10] ]
--   Arg (-34.0) (-10.0)
--   </pre>
data () => Arg a b
Arg :: a -> b -> Arg a b

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Min (Arg 0 ()) &lt;&gt; Min (Arg 1 ())
--   Min {getMin = Arg 0 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 3 "lea"
--   </pre>
type ArgMin a b = Min Arg a b

-- | <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; Max (Arg 0 ()) &lt;&gt; Max (Arg 1 ())
--   Max {getMax = Arg 1 ()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum [ Arg (length name) name | name &lt;- ["violencia", "lea", "pixie"]]
--   Arg 9 "violencia"
--   </pre>
type ArgMax a b = Max Arg a b


-- | Reexports <a>Data.Semigroup.Compat</a> from a globally unique
--   namespace.
module Data.Semigroup.Compat.Repl

module Data.String.Compat

-- | <a>String</a> is an alias for a list of characters.
--   
--   String constants in Haskell are values of type <a>String</a>. That
--   means if you write a string literal like <tt>"hello world"</tt>, it
--   will have the type <tt>[Char]</tt>, which is the same as
--   <tt>String</tt>.
--   
--   <b>Note:</b> You can ask the compiler to automatically infer different
--   types with the <tt>-XOverloadedStrings</tt> language extension, for
--   example <tt>"hello world" :: Text</tt>. See <a>IsString</a> for more
--   information.
--   
--   Because <tt>String</tt> is just a list of characters, you can use
--   normal list functions to do basic string manipulation. See
--   <a>Data.List</a> for operations on lists.
--   
--   <h3><b>Performance considerations</b></h3>
--   
--   <tt>[Char]</tt> is a relatively memory-inefficient type. It is a
--   linked list of boxed word-size characters, internally it looks
--   something like:
--   
--   <pre>
--   ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭─────┬───┬──╮  ╭────╮
--   │ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ (:) │   │ ─┼─&gt;│ [] │
--   ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰─────┴─┼─┴──╯  ╰────╯
--           v               v               v
--          'a'             'b'             'c'
--   </pre>
--   
--   The <tt>String</tt> "abc" will use <tt>5*3+1 = 16</tt> (in general
--   <tt>5n+1</tt>) words of space in memory.
--   
--   Furthermore, operations like <a>(++)</a> (string concatenation) are
--   <tt>O(n)</tt> (in the left argument).
--   
--   For historical reasons, the <tt>base</tt> library uses <tt>String</tt>
--   in a lot of places for the conceptual simplicity, but library code
--   dealing with user-data should use the <a>text</a> package for Unicode
--   text, or the the <a>bytestring</a> package for binary data.
type String = [Char]

-- | Splits the argument into a list of <i>lines</i> stripped of their
--   terminating <tt>\n</tt> characters. The <tt>\n</tt> terminator is
--   optional in a final non-empty line of the argument string.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; lines ""           -- empty input contains no lines
--   []
--   
--   &gt;&gt;&gt; lines "\n"         -- single empty line
--   [""]
--   
--   &gt;&gt;&gt; lines "one"        -- single unterminated line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n"      -- single non-empty line
--   ["one"]
--   
--   &gt;&gt;&gt; lines "one\n\n"    -- second line is empty
--   ["one",""]
--   
--   &gt;&gt;&gt; lines "one\ntwo"   -- second line is unterminated
--   ["one","two"]
--   
--   &gt;&gt;&gt; lines "one\ntwo\n" -- two non-empty lines
--   ["one","two"]
--   </pre>
--   
--   When the argument string is empty, or ends in a <tt>\n</tt> character,
--   it can be recovered by passing the result of <a>lines</a> to the
--   <a>unlines</a> function. Otherwise, <a>unlines</a> appends the missing
--   terminating <tt>\n</tt>. This makes <tt>unlines . lines</tt>
--   <i>idempotent</i>:
--   
--   <pre>
--   (unlines . lines) . (unlines . lines) = (unlines . lines)
--   </pre>
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space (as defined by <a>isSpace</a>). This function
--   trims any white spaces at the beginning and at the end.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   
--   &gt;&gt;&gt; words " foo bar "
--   ["foo","bar"]
--   </pre>
words :: String -> [String]

-- | Appends a <tt>\n</tt> character to each input string, then
--   concatenates the results. Equivalent to <tt><tt>foldMap</tt> (s -&gt;
--   s <a>++</a> "\n")</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
--   
--   Note that <tt><a>unlines</a> <a>.</a> <a>lines</a> <a>/=</a>
--   <a>id</a></tt> when the input is not <tt>\n</tt>-terminated:
--   
--   <pre>
--   &gt;&gt;&gt; unlines . lines $ "foo\nbar"
--   "foo\nbar\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> joins words with separating spaces (U+0020 SPACE).
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
--   
--   <a>unwords</a> is neither left nor right inverse of <a>words</a>:
--   
--   <pre>
--   &gt;&gt;&gt; words (unwords [" "])
--   []
--   
--   &gt;&gt;&gt; unwords (words "foo\nbar")
--   "foo bar"
--   </pre>
unwords :: [String] -> String


-- | Reexports <a>Data.String.Compat</a> from a globally unique namespace.
module Data.String.Compat.Repl

module Data.Traversable.Compat

-- | The <a>mapAccumM</a> function behaves like a combination of
--   <a>mapM</a> and <a>mapAccumL</a> that traverses the structure while
--   evaluating the actions and passing an accumulating parameter from left
--   to right. It returns a final value of this accumulator together with
--   the new structure. The accummulator is often used for caching the
--   intermediate results of a computation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let expensiveDouble a = putStrLn ("Doubling " &lt;&gt; show a) &gt;&gt; pure (2 * a)
--   
--   &gt;&gt;&gt; :{
--   mapAccumM (\cache a -&gt; case lookup a cache of
--       Nothing -&gt; expensiveDouble a &gt;&gt;= \double -&gt; pure ((a, double):cache, double)
--       Just double -&gt; pure (cache, double)
--       ) [] [1, 2, 3, 1, 2, 3]
--   :}
--   Doubling 1
--   Doubling 2
--   Doubling 3
--   ([(3,6),(2,4),(1,2)],[2,4,6,2,4,6])
--   </pre>
mapAccumM :: (Monad m, Traversable t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)

-- | <a>forAccumM</a> is <a>mapAccumM</a> with the arguments rearranged.
forAccumM :: (Monad m, Traversable t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)


-- | Reexports <a>Data.Traversable.Compat</a> from a globally unique
--   namespace.
module Data.Traversable.Compat.Repl


-- | Note that we only re-export <tt>MkSolo</tt> when building with
--   <tt>ghc-prim-0.10.0</tt> (bundled with GHC 9.6) or later. If you want
--   to backport <tt>MkSolo</tt> to older versions of GHC, import
--   <tt>Data.Tuple.Compat</tt> from <tt>base-compat-batteries</tt>
--   instead.
module Data.Tuple.Compat

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data () => Solo a
MkSolo :: a -> Solo a
pattern Solo :: a -> Solo a
getSolo :: Solo a -> a


-- | Reexports <a>Data.Tuple.Compat</a> from a globally unique namespace.
module Data.Tuple.Compat.Repl

module Data.Type.Coercion.Compat

-- | Generalized form of type-safe cast using representational equality
gcoerceWith :: forall {k} (a :: k) (b :: k) r. Coercion a b -> (Coercible a b => r) -> r


-- | Reexports <a>Data.Type.Coercion.Compat</a> from a globally unique
--   namespace.
module Data.Type.Coercion.Compat.Repl

module Data.Type.Equality.Compat


-- | Reexports <a>Data.Type.Equality.Compat</a> from a globally unique
--   namespace.
module Data.Type.Equality.Compat.Repl

module Data.Version.Compat

-- | Construct tag-less <a>Version</a>
makeVersion :: [Int] -> Version


-- | Reexports <a>Data.Version.Compat</a> from a globally unique namespace.
module Data.Version.Compat.Repl

module Data.Void.Compat


-- | Reexports <a>Data.Void.Compat</a> from a globally unique namespace.
module Data.Void.Compat.Repl

module Data.Word.Compat

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64


-- | Reexports <a>Data.Word.Compat</a> from a globally unique namespace.
module Data.Word.Compat.Repl

module Debug.Trace.Compat

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   hello
--   "hello"
--   </pre>
traceId :: String -> String

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <a>MonadIO</a>, <tt><a>liftIO</a> .
--   <a>traceIO</a></tt> may be a better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a>, but outputs the result of calling a function on the
--   argument.
--   
--   <pre>
--   &gt;&gt;&gt; traceWith fst ("hello","world")
--   hello
--   ("hello","world")
--   </pre>
traceWith :: (a -> String) -> a -> a

-- | Like <a>traceWith</a>, but uses <a>show</a> on the result of the
--   function to convert it to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowWith length [1,2,3]
--   3
--   [1,2,3]
--   </pre>
traceShowWith :: Show b => (a -> b) -> a -> a

-- | Like <a>traceEvent</a>, but emits the result of calling a function on
--   its argument.
traceEventWith :: (a -> String) -> a -> a


-- | Reexports <a>Debug.Trace.Compat</a> from a globally unique namespace.
module Debug.Trace.Compat.Repl

module Foreign.ForeignPtr.Compat

-- | Advances the given address by the given offset in bytes.
--   
--   The new <a>ForeignPtr</a> shares the finalizer of the original,
--   equivalent from a finalization standpoint to just creating another
--   reference to the original. That is, the finalizer will not be called
--   before the new <a>ForeignPtr</a> is unreachable, nor will it be called
--   an additional time due to this call, and the finalizer will be called
--   with the same address that it would have had this call not happened,
--   *not* the new address.
plusForeignPtr :: ForeignPtr a -> Int -> ForeignPtr b


-- | Reexports <a>Foreign.ForeignPtr.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Compat.Repl

module Foreign.ForeignPtr.Safe.Compat

-- | The type <a>ForeignPtr</a> represents references to objects that are
--   maintained in a foreign language, i.e., that are not part of the data
--   structures usually managed by the Haskell storage manager. The
--   essential difference between <a>ForeignPtr</a>s and vanilla memory
--   references of type <tt>Ptr a</tt> is that the former may be associated
--   with <i>finalizers</i>. A finalizer is a routine that is invoked when
--   the Haskell storage manager detects that - within the Haskell heap and
--   stack - there are no more references left that are pointing to the
--   <a>ForeignPtr</a>. Typically, the finalizer will, then, invoke
--   routines in the foreign language that free the resources bound by the
--   foreign object.
--   
--   The <a>ForeignPtr</a> is parameterised in the same way as <a>Ptr</a>.
--   The type argument of <a>ForeignPtr</a> should normally be an instance
--   of class <a>Storable</a>.
data () => ForeignPtr a

-- | A finalizer is represented as a pointer to a foreign function that, at
--   finalisation time, gets as an argument a plain pointer variant of the
--   foreign pointer that the finalizer is associated with.
--   
--   Note that the foreign function <i>must</i> use the <tt>ccall</tt>
--   calling convention.
type FinalizerPtr a = FunPtr Ptr a -> IO ()
type FinalizerEnvPtr env a = FunPtr Ptr env -> Ptr a -> IO ()

-- | Turns a plain memory reference into a foreign pointer, and associates
--   a finalizer with the reference. The finalizer will be executed after
--   the last reference to the foreign object is dropped. There is no
--   guarantee of promptness, however the finalizer will be executed before
--   the program exits.
newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)

-- | Turns a plain memory reference into a foreign pointer that may be
--   associated with finalizers by using <a>addForeignPtrFinalizer</a>.
newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)

-- | This function adds a finalizer to the given foreign object. The
--   finalizer will run <i>before</i> all other finalizers for the same
--   object which have already been registered.
addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()

-- | This variant of <a>newForeignPtr</a> adds a finalizer that expects an
--   environment in addition to the finalized pointer. The environment that
--   will be passed to the finalizer is fixed by the second argument to
--   <a>newForeignPtrEnv</a>.
newForeignPtrEnv :: FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)

-- | Like <a>addForeignPtrFinalizer</a> but the finalizer is passed an
--   additional environment parameter.
addForeignPtrFinalizerEnv :: FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()

-- | This is a way to look at the pointer living inside a foreign object.
--   This function takes a function which is applied to that pointer. The
--   resulting <a>IO</a> action is then executed. The foreign object is
--   kept alive at least during the whole action, even if it is not used
--   directly inside. Note that it is not safe to return the pointer from
--   the action and use it after the action completes. All uses of the
--   pointer should be inside the <a>withForeignPtr</a> bracket. The reason
--   for this unsafeness is the same as for <a>unsafeForeignPtrToPtr</a>
--   below: the finalizer may run earlier than expected, because the
--   compiler can only track usage of the <a>ForeignPtr</a> object, not a
--   <a>Ptr</a> object made from it.
--   
--   This function is normally used for marshalling data to or from the
--   object pointed to by the <a>ForeignPtr</a>, using the operations from
--   the <a>Storable</a> class.
withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b

-- | Causes the finalizers associated with a foreign pointer to be run
--   immediately. The foreign pointer must not be used again after this
--   function is called. If the foreign pointer does not support
--   finalizers, this is a no-op.
finalizeForeignPtr :: ForeignPtr a -> IO ()

-- | This function ensures that the foreign object in question is alive at
--   the given place in the sequence of IO actions. However, this comes
--   with a significant caveat: the contract above does not hold if GHC can
--   demonstrate that the code preceding <tt>touchForeignPtr</tt> diverges
--   (e.g. by looping infinitely or throwing an exception). For this
--   reason, you are strongly advised to use instead <a>withForeignPtr</a>
--   where possible.
--   
--   Also, note that this function should not be used to express
--   dependencies between finalizers on <a>ForeignPtr</a>s. For example, if
--   the finalizer for a <a>ForeignPtr</a> <tt>F1</tt> calls
--   <a>touchForeignPtr</a> on a second <a>ForeignPtr</a> <tt>F2</tt>, then
--   the only guarantee is that the finalizer for <tt>F2</tt> is never
--   started before the finalizer for <tt>F1</tt>. They might be started
--   together if for example both <tt>F1</tt> and <tt>F2</tt> are otherwise
--   unreachable, and in that case the scheduler might end up running the
--   finalizer for <tt>F2</tt> first.
--   
--   In general, it is not recommended to use finalizers on separate
--   objects with ordering constraints between them. To express the
--   ordering robustly requires explicit synchronisation using
--   <tt>MVar</tt>s between the finalizers, but even then the runtime
--   sometimes runs multiple finalizers sequentially in a single thread
--   (for performance reasons), so synchronisation between finalizers could
--   result in artificial deadlock. Another alternative is to use explicit
--   reference counting.
touchForeignPtr :: ForeignPtr a -> IO ()

-- | This function casts a <a>ForeignPtr</a> parameterised by one type into
--   another type.
castForeignPtr :: ForeignPtr a -> ForeignPtr b

-- | Allocate some memory and return a <a>ForeignPtr</a> to it. The memory
--   will be released automatically when the <a>ForeignPtr</a> is
--   discarded.
--   
--   <a>mallocForeignPtr</a> is equivalent to
--   
--   <pre>
--   do { p &lt;- malloc; newForeignPtr finalizerFree p }
--   </pre>
--   
--   although it may be implemented differently internally: you may not
--   assume that the memory returned by <a>mallocForeignPtr</a> has been
--   allocated with <a>malloc</a>.
--   
--   GHC notes: <a>mallocForeignPtr</a> has a heavily optimised
--   implementation in GHC. It uses pinned memory in the garbage collected
--   heap, so the <a>ForeignPtr</a> does not require a finalizer to free
--   the memory. Use of <a>mallocForeignPtr</a> and associated functions is
--   strongly recommended in preference to <a>newForeignPtr</a> with a
--   finalizer.
mallocForeignPtr :: Storable a => IO (ForeignPtr a)

-- | This function is similar to <a>mallocForeignPtr</a>, except that the
--   size of the memory required is given explicitly as a number of bytes.
mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)

-- | This function is similar to <a>mallocArray0</a>, but yields a memory
--   area that has a finalizer attached that releases the memory area. As
--   with <a>mallocForeignPtr</a>, it is not guaranteed that the block of
--   memory was allocated by <a>malloc</a>.
mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)


-- | Reexports <a>Foreign.ForeignPtr.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.ForeignPtr.Safe.Compat.Repl

module Foreign.ForeignPtr.Unsafe.Compat

-- | This function extracts the pointer component of a foreign pointer.
--   This is a potentially dangerous operations, as if the argument to
--   <a>unsafeForeignPtrToPtr</a> is the last usage occurrence of the given
--   foreign pointer, then its finalizer(s) will be run, which potentially
--   invalidates the plain pointer just obtained. Hence,
--   <a>touchForeignPtr</a> must be used wherever it has to be guaranteed
--   that the pointer lives on - i.e., has another usage occurrence.
--   
--   To avoid subtle coding errors, hand written marshalling code should
--   preferably use <a>withForeignPtr</a> rather than combinations of
--   <a>unsafeForeignPtrToPtr</a> and <a>touchForeignPtr</a>. However, the
--   latter routines are occasionally preferred in tool generated
--   marshalling code.
unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a


-- | Reexports <a>Foreign.ForeignPtr.Unsafe.Compat</a> from a globally
--   unique namespace.
module Foreign.ForeignPtr.Unsafe.Compat.Repl

module Foreign.Marshal.Alloc.Compat

-- | Like <a>malloc</a> but memory is filled with bytes of value zero.
calloc :: Storable a => IO (Ptr a)

-- | Like <a>mallocBytes</a>, but memory is filled with bytes of value
--   zero.
callocBytes :: Int -> IO (Ptr a)


-- | Reexports <a>Foreign.Marshal.Alloc.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Alloc.Compat.Repl

module Foreign.Marshal.Array.Compat

-- | Like <a>mallocArray</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray :: Storable a => Int -> IO (Ptr a)

-- | Like <a>callocArray0</a>, but allocated memory is filled with bytes of
--   value zero.
callocArray0 :: Storable a => Int -> IO (Ptr a)


-- | Reexports <a>Foreign.Marshal.Array.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Array.Compat.Repl

module Foreign.Marshal.Safe.Compat


-- | Reexports <a>Foreign.Marshal.Safe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Safe.Compat.Repl

module Foreign.Marshal.Unsafe.Compat

-- | Sometimes an external entity is a pure function, except that it passes
--   arguments and/or results via pointers. The function
--   <tt>unsafeLocalState</tt> permits the packaging of such entities as
--   pure functions.
--   
--   The only IO operations allowed in the IO action passed to
--   <tt>unsafeLocalState</tt> are (a) local allocation (<tt>alloca</tt>,
--   <tt>allocaBytes</tt> and derived operations such as <tt>withArray</tt>
--   and <tt>withCString</tt>), and (b) pointer operations
--   (<tt>Foreign.Storable</tt> and <tt>Foreign.Ptr</tt>) on the pointers
--   to local storage, and (c) foreign functions whose only observable
--   effect is to read and/or write the locally allocated memory. Passing
--   an IO operation that does not obey these rules results in undefined
--   behaviour.
--   
--   It is expected that this operation will be replaced in a future
--   revision of Haskell.
unsafeLocalState :: IO a -> a


-- | Reexports <a>Foreign.Marshal.Unsafe.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Unsafe.Compat.Repl

module Foreign.Marshal.Utils.Compat

-- | Fill a given number of bytes in memory area with a byte value.
fillBytes :: Ptr a -> Word8 -> Int -> IO ()

module Foreign.Marshal.Compat


-- | Reexports <a>Foreign.Marshal.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Compat.Repl

module Foreign.Compat


-- | Reexports <a>Foreign.Compat</a> from a globally unique namespace.
module Foreign.Compat.Repl


-- | Reexports <a>Foreign.Marshal.Utils.Compat</a> from a globally unique
--   namespace.
module Foreign.Marshal.Utils.Compat.Repl

module Numeric.Compat

-- | Show <i>non-negative</i> <a>Integral</a> numbers in base 2.
showBin :: Integral a => a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   (e.g. <tt>245000</tt>, <tt>0.0015</tt>).
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showFFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a signed <a>RealFloat</a> value using standard decimal notation
--   for arguments whose absolute value lies between <tt>0.1</tt> and
--   <tt>9,999,999</tt>, and scientific notation otherwise.
--   
--   This behaves as <a>showFFloat</a>, except that a decimal point is
--   always guaranteed, even if not needed.
showGFloatAlt :: RealFloat a => Maybe Int -> a -> ShowS

-- | Show a floating-point value in the hexadecimal format, similar to the
--   <tt>%a</tt> specifier in C's printf.
--   
--   <pre>
--   &gt;&gt;&gt; showHFloat (212.21 :: Double) ""
--   "0x1.a86b851eb851fp7"
--   
--   &gt;&gt;&gt; showHFloat (-12.76 :: Float) ""
--   "-0x1.9851ecp3"
--   
--   &gt;&gt;&gt; showHFloat (-0 :: Double) ""
--   "-0x0p+0"
--   </pre>
showHFloat :: RealFloat a => a -> ShowS

-- | Read an unsigned number in binary notation.
--   
--   <pre>
--   &gt;&gt;&gt; readBin "10011"
--   [(19,"")]
--   </pre>
readBin :: (Eq a, Num a) => ReadS a


-- | Reexports <a>Numeric.Compat</a> from a globally unique namespace.
module Numeric.Compat.Repl

module Numeric.Natural.Compat

-- | <a>Natural</a> subtraction. Returns <a>Nothing</a>s for non-positive
--   results.
minusNaturalMaybe :: Natural -> Natural -> Maybe Natural


-- | Reexports <a>Numeric.Natural.Compat</a> from a globally unique
--   namespace.
module Numeric.Natural.Compat.Repl

module Prelude.Compat

module Data.List.Compat

-- | List index (subscript) operator, starting from 0. Returns
--   <a>Nothing</a> if the index is out of bounds
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 0
--   Just 'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 2
--   Just 'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? 3
--   Nothing
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !? (-1)
--   Nothing
--   </pre>
--   
--   This is the total variant of the partial <a>!!</a> operator.
--   
--   WARNING: This function takes linear time in the index.
(!?) :: [a] -> Int -> Maybe a
infixl 9 !?

-- | &lt;math&gt;. Decompose a list into <a>init</a> and <a>last</a>.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (xs, x)</tt>,
--   where <tt>xs</tt> is the <a>init</a>ial part of the list and
--   <tt>x</tt> is its <a>last</a> element.</li>
--   </ul>
--   
--   <i>Since: 4.19.0.0</i>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc []
--   Nothing
--   
--   &gt;&gt;&gt; unsnoc [1]
--   Just ([],1)
--   
--   &gt;&gt;&gt; unsnoc [1, 2, 3]
--   Just ([1,2],3)
--   </pre>
--   
--   Laziness:
--   
--   <pre>
--   &gt;&gt;&gt; fst &lt;$&gt; unsnoc [undefined]
--   Just []
--   
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : undefined)
--   Just *** Exception: Prelude.undefined
--   
--   &gt;&gt;&gt; head . fst &lt;$&gt; unsnoc (1 : 2 : undefined)
--   Just 1
--   </pre>
--   
--   <a>unsnoc</a> is dual to <a>uncons</a>: for a finite list <tt>xs</tt>
--   
--   <pre>
--   unsnoc xs = (\(hd, tl) -&gt; (reverse tl, hd)) &lt;$&gt; uncons (reverse xs)
--   </pre>
unsnoc :: [a] -> Maybe ([a], a)


-- | Reexports <a>Data.List.Compat</a> from a globally unique namespace.
module Data.List.Compat.Repl


-- | Reexports <a>Prelude.Compat</a> from a globally unique namespace.
module Prelude.Compat.Repl


-- | Miscellaneous information about the system environment.
module System.Environment.Compat

-- | Computation <a>getArgs</a> returns a list of the program's command
--   line arguments (not including the program name).
getArgs :: IO [String]

-- | Computation <a>getProgName</a> returns the name of the program as it
--   was invoked.
--   
--   However, this is hard-to-impossible to implement on some non-Unix
--   OSes, so instead, for maximum portability, we just return the leafname
--   of the program as invoked. Even then there are some differences
--   between platforms: on Windows, for example, a program invoked as foo
--   is probably really <tt>FOO.EXE</tt>, and that is what
--   <a>getProgName</a> will return.
getProgName :: IO String

-- | Computation <a>getEnv</a> <tt>var</tt> returns the value of the
--   environment variable <tt>var</tt>. For the inverse, the <a>setEnv</a>
--   function can be used.
--   
--   This computation may fail with:
--   
--   <ul>
--   <li><a>isDoesNotExistError</a> if the environment variable does not
--   exist.</li>
--   </ul>
getEnv :: String -> IO String

-- | Return the value of the environment variable <tt>var</tt>, or
--   <tt>Nothing</tt> if there is no such value.
--   
--   For POSIX users, this is equivalent to <a>getEnv</a>.
lookupEnv :: String -> IO (Maybe String)

-- | <tt>setEnv name value</tt> sets the specified environment variable to
--   <tt>value</tt>.
--   
--   Early versions of this function operated under the mistaken belief
--   that setting an environment variable to the <i>empty string</i> on
--   Windows removes that environment variable from the environment. For
--   the sake of compatibility, it adopted that behavior on POSIX. In
--   particular
--   
--   <pre>
--   setEnv name ""
--   </pre>
--   
--   has the same effect as
--   
--   <pre>
--   <a>unsetEnv</a> name
--   </pre>
--   
--   If you'd like to be able to set environment variables to blank
--   strings, use <a>setEnv</a>.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
setEnv :: String -> String -> IO ()

-- | <tt>unsetEnv name</tt> removes the specified environment variable from
--   the environment of the current process.
--   
--   Throws <a>IOException</a> if <tt>name</tt> is the empty string or
--   contains an equals sign.
unsetEnv :: String -> IO ()

-- | <a>withArgs</a> <tt>args act</tt> - while executing action
--   <tt>act</tt>, have <a>getArgs</a> return <tt>args</tt>.
withArgs :: [String] -> IO a -> IO a

-- | <a>withProgName</a> <tt>name act</tt> - while executing action
--   <tt>act</tt>, have <a>getProgName</a> return <tt>name</tt>.
withProgName :: String -> IO a -> IO a

-- | <a>getEnvironment</a> retrieves the entire environment as a list of
--   <tt>(key,value)</tt> pairs.
--   
--   If an environment entry does not contain an <tt>'='</tt> character,
--   the <tt>key</tt> is the whole entry and the <tt>value</tt> is the
--   empty string.
getEnvironment :: IO [(String, String)]


-- | Reexports <a>System.Environment.Compat</a> from a globally unique
--   namespace.
module System.Environment.Compat.Repl

module System.Exit.Compat

-- | Write given error message to <a>stderr</a> and terminate with
--   <a>exitFailure</a>.
die :: String -> IO a


-- | Reexports <a>System.Exit.Compat</a> from a globally unique namespace.
module System.Exit.Compat.Repl

module System.IO.Compat

-- | The <a>getContents'</a> operation returns all user input as a single
--   string, which is fully read before being returned (same as
--   <a>hGetContents'</a> <a>stdin</a>).
getContents' :: IO String

-- | The <a>hGetContents'</a> operation reads all input on the given handle
--   before returning it as a <a>String</a> and closing the handle.
hGetContents' :: Handle -> IO String

-- | The <a>readFile'</a> function reads a file and returns the contents of
--   the file as a string. The file is fully read before being returned, as
--   with <a>getContents'</a>.
readFile' :: FilePath -> IO String


-- | Reexports <a>System.IO.Compat</a> from a globally unique namespace.
module System.IO.Compat.Repl

module System.IO.Error.Compat

-- | An error indicating that the operation failed because the resource
--   vanished. See <a>resourceVanishedErrorType</a>.
isResourceVanishedError :: IOError -> Bool

-- | I/O error where the operation failed because the resource vanished.
--   This happens when, for example, attempting to write to a closed socket
--   or attempting to write to a named pipe that was deleted.
resourceVanishedErrorType :: IOErrorType

-- | I/O error where the operation failed because the resource vanished.
--   See <a>resourceVanishedErrorType</a>.
isResourceVanishedErrorType :: IOErrorType -> Bool


-- | Reexports <a>System.IO.Error.Compat</a> from a globally unique
--   namespace.
module System.IO.Error.Compat.Repl

module System.IO.Unsafe.Compat

-- | A slightly faster version of <a>fixIO</a> that may not be safe to use
--   with multiple threads. The unsafety arises when used like this:
--   
--   <pre>
--   unsafeFixIO $ \r -&gt; do
--      forkIO (print r)
--      return (...)
--   </pre>
--   
--   In this case, the child thread will receive a <tt>NonTermination</tt>
--   exception instead of waiting for the value of <tt>r</tt> to be
--   computed.
unsafeFixIO :: (a -> IO a) -> IO a

-- | This version of <a>unsafePerformIO</a> is more efficient because it
--   omits the check that the IO is only being performed by a single
--   thread. Hence, when you use <a>unsafeDupablePerformIO</a>, there is a
--   possibility that the IO action may be performed multiple times (on a
--   multiprocessor), and you should therefore ensure that it gives the
--   same results each time. It may even happen that one of the duplicated
--   IO actions is only run partially, and then interrupted in the middle
--   without an exception being raised. Therefore, functions like
--   <a>bracket</a> cannot be used safely within
--   <a>unsafeDupablePerformIO</a>.
unsafeDupablePerformIO :: IO a -> a


-- | Reexports <a>System.IO.Unsafe.Compat</a> from a globally unique
--   namespace.
module System.IO.Unsafe.Compat.Repl

module Text.Read.Compat

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class () => Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | Proposed replacement for <a>readsPrec</a> using new-style parsers (GHC
--   only).
readPrec :: Read a => ReadPrec a

-- | Proposed replacement for <a>readList</a> using new-style parsers (GHC
--   only). The default definition uses <a>readList</a>. Instances that
--   define <a>readPrec</a> should also define <a>readListPrec</a> as
--   <a>readListPrecDefault</a>.
readListPrec :: Read a => ReadPrec [a]

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String
data () => Lexeme

-- | Character literal
Char :: Char -> Lexeme

-- | String literal, with escapes interpreted
String :: String -> Lexeme

-- | Punctuation or reserved symbol, e.g. <tt>(</tt>, <tt>::</tt>
Punc :: String -> Lexeme

-- | Haskell identifier, e.g. <tt>foo</tt>, <tt>Baz</tt>
Ident :: String -> Lexeme

-- | Haskell symbol, e.g. <tt>&gt;&gt;</tt>, <tt>:%</tt>
Symbol :: String -> Lexeme

Number :: Number -> Lexeme
EOF :: Lexeme

-- | Parse a single lexeme
lexP :: ReadPrec Lexeme

-- | <tt>(parens p)</tt> parses "P", "(P0)", "((P0))", etc, where
--   <tt>p</tt> parses "P" in the current precedence context and parses
--   "P0" in precedence context zero
parens :: ReadPrec a -> ReadPrec a

-- | A possible replacement definition for the <a>readList</a> method (GHC
--   only). This is only needed for GHC, and even then only for <a>Read</a>
--   instances where <a>readListPrec</a> isn't defined as
--   <a>readListPrecDefault</a>.
readListDefault :: Read a => ReadS [a]

-- | A possible replacement definition for the <a>readListPrec</a> method,
--   defined using <a>readPrec</a> (GHC only).
readListPrecDefault :: Read a => ReadPrec [a]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result. A <a>Left</a> value indicates a parse error.
--   
--   <pre>
--   &gt;&gt;&gt; readEither "123" :: Either String Int
--   Right 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readEither "hello" :: Either String Int
--   Left "Prelude.read: no parse"
--   </pre>
readEither :: Read a => String -> Either String a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a


-- | Reexports <a>Text.Read.Compat</a> from a globally unique namespace.
module Text.Read.Compat.Repl

module Text.Read.Lex.Compat
readBinP :: (Eq a, Num a) => ReadP a


-- | Reexports <a>Text.Read.Lex.Compat</a> from a globally unique
--   namespace.
module Text.Read.Lex.Compat.Repl

module Type.Reflection.Compat

-- | Use a <a>TypeRep</a> as <a>Typeable</a> evidence.
--   
--   The <a>TypeRep</a> pattern synonym brings a <a>Typeable</a> constraint
--   into scope and can be used in place of <a>withTypeable</a>.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f rep = withTypeable {- Typeable a in scope -}
--   
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
withTypeable :: forall k (a :: k) (rep :: RuntimeRep) (r :: TYPE rep). TypeRep a -> (Typeable a => r) -> r

-- | A explicitly bidirectional pattern synonym to construct a concrete
--   representation of a type.
--   
--   As an <b>expression</b>: Constructs a singleton <tt>TypeRep a</tt>
--   given a implicit 'Typeable a' constraint:
--   
--   <pre>
--   TypeRep @a :: Typeable a =&gt; TypeRep a
--   </pre>
--   
--   As a <b>pattern</b>: Matches on an explicit <tt>TypeRep a</tt> witness
--   bringing an implicit <tt>Typeable a</tt> constraint into scope.
--   
--   <pre>
--   f :: TypeRep a -&gt; ..
--   f TypeRep = {- Typeable a in scope -}
--   </pre>
pattern TypeRep :: () => Typeable a => TypeRep a

-- | Type equality decision
--   
--   <i>Since: 4.19.0.0</i>
decTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Either ((a :~~: b) -> Void) (a :~~: b)

module Data.Typeable.Compat

-- | Extract a witness of heterogeneous equality of two types
heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => Maybe (a :~~: b)

-- | Decide an equality of two types
--   
--   <i>Since: 4.19.0.0</i>
decT :: forall a b. (Typeable a, Typeable b) => Either ((a :~: b) -> Void) (a :~: b)

-- | Decide heterogeneous equality of two types.
--   
--   <i>Since: 4.19.0.0</i>
hdecT :: forall a b. (Typeable a, Typeable b) => Either ((a :~~: b) -> Void) (a :~~: b)


-- | Reexports <a>Data.Typeable.Compat</a> from a globally unique
--   namespace.
module Data.Typeable.Compat.Repl


-- | Reexports <a>Type.Reflection.Compat</a> from a globally unique
--   namespace.
module Type.Reflection.Compat.Repl
