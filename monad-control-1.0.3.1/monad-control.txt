-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lift control operations, like exception catching, through monad transformers
--   
--   This package defines the type class <tt>MonadBaseControl</tt>, a
--   subset of <tt>MonadBase</tt> into which generic control operations
--   such as <tt>catch</tt> can be lifted from <tt>IO</tt> or any other
--   base monad. Instances are based on monad transformers in
--   <tt>MonadTransControl</tt>, which includes all standard monad
--   transformers in the <tt>transformers</tt> library except
--   <tt>ContT</tt>.
--   
--   See the <a>lifted-base</a> package which uses <tt>monad-control</tt>
--   to lift <tt>IO</tt> operations from the <tt>base</tt> library (like
--   <tt>catch</tt> or <tt>bracket</tt>) into any monad that is an instance
--   of <tt>MonadBase</tt> or <tt>MonadBaseControl</tt>.
--   
--   Note that this package is a rewrite of Anders Kaseorg's
--   <tt>monad-peel</tt> library. The main difference is that this package
--   provides CPS style operators and exploits the <tt>RankNTypes</tt> and
--   <tt>TypeFamilies</tt> language extensions to simplify and speedup most
--   definitions.
@package monad-control
@version 1.0.3.1


-- | This module defines the type class <a>MonadBaseControl</a>, a subset
--   of <a>MonadBase</a> into which generic control operations such as
--   <tt>catch</tt> can be lifted from <tt>IO</tt> or any other base monad.
--   Instances are based on monad transformers in <a>MonadTransControl</a>,
--   which includes all standard monad transformers in the
--   <tt>transformers</tt> library except <tt>ContT</tt>.
--   
--   See the <a>lifted-base</a> package which uses <tt>monad-control</tt>
--   to lift <tt>IO</tt> operations from the <tt>base</tt> library (like
--   <tt>catch</tt> or <tt>bracket</tt>) into any monad that is an instance
--   of <tt>MonadBase</tt> or <tt>MonadBaseControl</tt>.
--   
--   See the following tutorial by Michael Snoyman on how to use this
--   package:
--   
--   <a>https://www.yesodweb.com/book/monad-control</a>
--   
--   <h3>Quick implementation guide</h3>
--   
--   Given a base monad <tt>B</tt> and a stack of transformers <tt>T</tt>:
--   
--   <ul>
--   <li>Define instances <tt><a>MonadTransControl</a> T</tt> for all
--   transformers <tt>T</tt>, using the <tt><a>defaultLiftWith</a></tt> and
--   <tt><a>defaultRestoreT</a></tt> functions on the constructor and
--   deconstructor of <tt>T</tt>.</li>
--   <li>Define an instance <tt><a>MonadBaseControl</a> B B</tt> for the
--   base monad:<pre>instance MonadBaseControl B B where type StM B a = a
--   liftBaseWith f = f <a>id</a> restoreM = <a>return</a> </pre></li>
--   <li>Define instances <tt><a>MonadBaseControl</a> B m =&gt;
--   <a>MonadBaseControl</a> B (T m)</tt> for all
--   transformers:<pre>instance MonadBaseControl b m =&gt; MonadBaseControl
--   b (T m) where type StM (T m) a = <a>ComposeSt</a> T m a liftBaseWith f
--   = <a>defaultLiftBaseWith</a> restoreM = <a>defaultRestoreM</a>
--   </pre></li>
--   </ul>
module Control.Monad.Trans.Control

-- | The <tt>MonadTransControl</tt> type class is a stronger version of
--   <tt><a>MonadTrans</a></tt>:
--   
--   Instances of <tt><a>MonadTrans</a></tt> know how to
--   <tt><tt>lift</tt></tt> actions in the base monad to the transformed
--   monad. These lifted actions, however, are completely unaware of the
--   monadic state added by the transformer.
--   
--   <tt><a>MonadTransControl</a></tt> instances are aware of the monadic
--   state of the transformer and allow to save and restore this state.
--   
--   This allows to lift functions that have a monad transformer in both
--   positive and negative position. Take, for example, the function
--   
--   <pre>
--   withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO r) -&gt; IO r
--   </pre>
--   
--   <tt><a>MonadTrans</a></tt> instances can only lift the return type of
--   the <tt>withFile</tt> function:
--   
--   <pre>
--   withFileLifted :: MonadTrans t =&gt; FilePath -&gt; IOMode -&gt; (Handle -&gt; IO r) -&gt; t IO r
--   withFileLifted file mode action = lift (withFile file mode action)
--   </pre>
--   
--   However, <tt><a>MonadTrans</a></tt> is not powerful enough to make
--   <tt>withFileLifted</tt> accept a function that returns <tt>t IO</tt>.
--   The reason is that we need to take away the transformer layer in order
--   to pass the function to <tt><tt>withFile</tt></tt>.
--   <tt><a>MonadTransControl</a></tt> allows us to do this:
--   
--   <pre>
--   withFileLifted' :: (Monad (t IO), MonadTransControl t) =&gt; FilePath -&gt; IOMode -&gt; (Handle -&gt; t IO r) -&gt; t IO r
--   withFileLifted' file mode action = liftWith (\run -&gt; withFile file mode (run . action)) &gt;&gt;= restoreT . return
--   </pre>
class MonadTrans t => MonadTransControl t where {
    
    -- | Monadic state of <tt>t</tt>.
    --   
    --   The monadic state of a monad transformer is the result type of its
    --   <tt>run</tt> function, e.g.:
    --   
    --   <pre>
    --   <a>runReaderT</a> :: <a>ReaderT</a> r m a -&gt; r -&gt; m a
    --   <a>StT</a> (<a>ReaderT</a> r) a ~ a
    --   
    --   <a>runStateT</a> :: <a>StateT</a> s m a -&gt; s -&gt; m (a, s)
    --   <a>StT</a> (<a>StateT</a> s) a ~ (a, s)
    --   
    --   <a>runMaybeT</a> :: <a>MaybeT</a> m a -&gt; m (<a>Maybe</a> a)
    --   <a>StT</a> <a>MaybeT</a> a ~ <a>Maybe</a> a
    --   </pre>
    --   
    --   Provided type instances:
    --   
    --   <pre>
    --   StT <a>IdentityT</a>    a ~ a
    --   StT <a>MaybeT</a>       a ~ <a>Maybe</a> a
    --   StT (<tt>ErrorT</tt> e)   a ~ <tt>Error</tt> e =&gt; <a>Either</a> e a
    --   StT (<a>ExceptT</a> e)  a ~ <a>Either</a> e a
    --   StT <tt>ListT</tt>        a ~ [a]
    --   StT (<a>ReaderT</a> r)  a ~ a
    --   StT (<a>StateT</a> s)   a ~ (a, s)
    --   StT (<a>WriterT</a> w)  a ~ <a>Monoid</a> w =&gt; (a, w)
    --   StT (<a>RWST</a> r w s) a ~ <a>Monoid</a> w =&gt; (a, s, w)
    --   </pre>
    type StT t a :: *;
}

-- | <tt>liftWith</tt> is similar to <tt>lift</tt> in that it lifts a
--   computation from the argument monad to the constructed monad.
--   
--   Instances should satisfy similar laws as the <a>MonadTrans</a> laws:
--   
--   <pre>
--   liftWith (\_ -&gt; return a) = return a
--   </pre>
--   
--   <pre>
--   liftWith (\_ -&gt; m &gt;&gt;= f)  =  liftWith (\_ -&gt; m) &gt;&gt;= (\a -&gt; liftWith (\_ -&gt; f a))
--   </pre>
--   
--   The difference with <tt>lift</tt> is that before lifting the
--   <tt>m</tt> computation <tt>liftWith</tt> captures the state of
--   <tt>t</tt>. It then provides the <tt>m</tt> computation with a
--   <a>Run</a> function that allows running <tt>t n</tt> computations in
--   <tt>n</tt> (for all <tt>n</tt>) on the captured state, e.g.
--   
--   <pre>
--   withFileLifted :: (Monad (t IO), MonadTransControl t) =&gt; FilePath -&gt; IOMode -&gt; (Handle -&gt; t IO r) -&gt; t IO r
--   withFileLifted file mode action = liftWith (\run -&gt; withFile file mode (run . action)) &gt;&gt;= restoreT . return
--   </pre>
--   
--   If the <tt>Run</tt> function is ignored, <tt>liftWith</tt> coincides
--   with <tt>lift</tt>:
--   
--   <pre>
--   lift f = liftWith (\_ -&gt; f)
--   </pre>
--   
--   Implementations use the <tt><a>Run</a></tt> function associated with a
--   transformer:
--   
--   <pre>
--   liftWith :: <a>Monad</a> m =&gt; ((<a>Monad</a> n =&gt; <a>ReaderT</a> r n b -&gt; n b) -&gt; m a) -&gt; <a>ReaderT</a> r m a
--   liftWith f = <a>ReaderT</a> (\r -&gt; f (\action -&gt; <a>runReaderT</a> action r))
--   
--   liftWith :: <a>Monad</a> m =&gt; ((<a>Monad</a> n =&gt; <a>StateT</a> s n b -&gt; n (b, s)) -&gt; m a) -&gt; <a>StateT</a> s m a
--   liftWith f = <a>StateT</a> (\s -&gt; <a>liftM</a> (\x -&gt; (x, s)) (f (\action -&gt; <a>runStateT</a> action s)))
--   
--   liftWith :: <a>Monad</a> m =&gt; ((<a>Monad</a> n =&gt; <a>MaybeT</a> n b -&gt; n (<a>Maybe</a> b)) -&gt; m a) -&gt; <a>MaybeT</a> m a
--   liftWith f = <a>MaybeT</a> (<a>liftM</a> <tt>Just</tt> (f <a>runMaybeT</a>))
--   </pre>
liftWith :: (MonadTransControl t, Monad m) => (Run t -> m a) -> t m a

-- | Construct a <tt>t</tt> computation from the monadic state of
--   <tt>t</tt> that is returned from a <a>Run</a> function.
--   
--   Instances should satisfy:
--   
--   <pre>
--   liftWith (\run -&gt; run t) &gt;&gt;= restoreT . return = t
--   </pre>
--   
--   <tt>restoreT</tt> is usually implemented through the constructor of
--   the monad transformer:
--   
--   <pre>
--   <a>ReaderT</a>  :: (r -&gt; m a) -&gt; <a>ReaderT</a> r m a
--   restoreT ::       m a  -&gt; <a>ReaderT</a> r m a
--   restoreT action = <a>ReaderT</a> { runReaderT = <a>const</a> action }
--   
--   <a>StateT</a>   :: (s -&gt; m (a, s)) -&gt; <a>StateT</a> s m a
--   restoreT ::       m (a, s)  -&gt; <a>StateT</a> s m a
--   restoreT action = <a>StateT</a> { runStateT = <a>const</a> action }
--   
--   <a>MaybeT</a>   :: m (<a>Maybe</a> a) -&gt; <a>MaybeT</a> m a
--   restoreT :: m (<a>Maybe</a> a) -&gt; <a>MaybeT</a> m a
--   restoreT action = <a>MaybeT</a> action
--   </pre>
--   
--   Example type signatures:
--   
--   <pre>
--   restoreT :: <a>Monad</a> m             =&gt; m a            -&gt; <a>IdentityT</a> m a
--   restoreT :: <a>Monad</a> m             =&gt; m (<a>Maybe</a> a)    -&gt; <a>MaybeT</a> m a
--   restoreT :: (<a>Monad</a> m, <tt>Error</tt> e)  =&gt; m (<a>Either</a> e a) -&gt; <tt>ErrorT</tt> e m a
--   restoreT :: <a>Monad</a> m             =&gt; m (<a>Either</a> e a) -&gt; <a>ExceptT</a> e m a
--   restoreT :: <a>Monad</a> m             =&gt; m [a]          -&gt; <tt>ListT</tt> m a
--   restoreT :: <a>Monad</a> m             =&gt; m a            -&gt; <a>ReaderT</a> r m a
--   restoreT :: <a>Monad</a> m             =&gt; m (a, s)       -&gt; <a>StateT</a> s m a
--   restoreT :: (<a>Monad</a> m, <a>Monoid</a> w) =&gt; m (a, w)       -&gt; <a>WriterT</a> w m a
--   restoreT :: (<a>Monad</a> m, <a>Monoid</a> w) =&gt; m (a, s, w)    -&gt; <a>RWST</a> r w s m a
--   </pre>
restoreT :: (MonadTransControl t, Monad m) => m (StT t a) -> t m a

-- | A function that runs a transformed monad <tt>t n</tt> on the monadic
--   state that was captured by <a>liftWith</a>
--   
--   A <tt>Run t</tt> function yields a computation in <tt>n</tt> that
--   returns the monadic state of <tt>t</tt>. This state can later be used
--   to restore a <tt>t</tt> computation using <a>restoreT</a>.
--   
--   Example type equalities:
--   
--   <pre>
--   Run <a>IdentityT</a>    ~ forall n b. <a>Monad</a> n             =&gt; <a>IdentityT</a>  n b -&gt; n b
--   Run <a>MaybeT</a>       ~ forall n b. <a>Monad</a> n             =&gt; <a>MaybeT</a>     n b -&gt; n (<a>Maybe</a> b)
--   Run (<tt>ErrorT</tt> e)   ~ forall n b. (<a>Monad</a> n, <tt>Error</tt> e)  =&gt; <tt>ErrorT</tt> e   n b -&gt; n (<a>Either</a> e b)
--   Run (<a>ExceptT</a> e)  ~ forall n b. <a>Monad</a> n             =&gt; <a>ExceptT</a> e  n b -&gt; n (<a>Either</a> e b)
--   Run <tt>ListT</tt>        ~ forall n b. <a>Monad</a> n             =&gt; <tt>ListT</tt>      n b -&gt; n [b]
--   Run (<a>ReaderT</a> r)  ~ forall n b. <a>Monad</a> n             =&gt; <a>ReaderT</a> r  n b -&gt; n b
--   Run (<a>StateT</a> s)   ~ forall n b. <a>Monad</a> n             =&gt; <a>StateT</a> s   n b -&gt; n (a, s)
--   Run (<a>WriterT</a> w)  ~ forall n b. (<a>Monad</a> n, <a>Monoid</a> w) =&gt; <a>WriterT</a> w  n b -&gt; n (a, w)
--   Run (<a>RWST</a> r w s) ~ forall n b. (<a>Monad</a> n, <a>Monoid</a> w) =&gt; <a>RWST</a> r w s n b -&gt; n (a, s, w)
--   </pre>
--   
--   This type is usually satisfied by the <tt>run</tt> function of a
--   transformer:
--   
--   <pre>
--   <tt>flip</tt> <a>runReaderT</a> :: r -&gt; Run (<a>ReaderT</a> r)
--   <tt>flip</tt> <a>runStateT</a>  :: s -&gt; Run (<a>StateT</a> s)
--   <a>runMaybeT</a>       ::      Run <a>MaybeT</a>
--   </pre>
type Run t = forall n b. Monad n => t n b -> n (StT t b)

-- | A function like <a>Run</a> that runs a monad transformer <tt>t</tt>
--   which wraps the monad transformer <tt>t'</tt>. This is used in
--   <a>defaultLiftWith</a>.
type RunDefault t t' = forall n b. Monad n => t n b -> n (StT t' b)

-- | Default definition for the <a>liftWith</a> method.
defaultLiftWith :: (Monad m, MonadTransControl n) => (forall b. n m b -> t m b) -> (forall o b. t o b -> n o b) -> (RunDefault t n -> m a) -> t m a

-- | Default definition for the <a>restoreT</a> method.
defaultRestoreT :: (Monad m, MonadTransControl n) => (n m a -> t m a) -> m (StT n a) -> t m a

-- | A function like <a>Run</a> that runs a monad transformer <tt>t</tt>
--   which wraps the monad transformers <tt>n</tt> and <tt>n'</tt>. This is
--   used in <a>defaultLiftWith2</a>.
type RunDefault2 t n n' = forall m b. (Monad m, Monad (n' m)) => t m b -> m (StT n' (StT n b))

-- | Default definition for the <a>liftWith</a> method.
defaultLiftWith2 :: (Monad m, Monad (n' m), MonadTransControl n, MonadTransControl n') => (forall b. n (n' m) b -> t m b) -> (forall o b. t o b -> n (n' o) b) -> (RunDefault2 t n n' -> m a) -> t m a

-- | Default definition for the <a>restoreT</a> method for double
--   <a>MonadTransControl</a>.
defaultRestoreT2 :: (Monad m, Monad (n' m), MonadTransControl n, MonadTransControl n') => (n (n' m) a -> t m a) -> m (StT n' (StT n a)) -> t m a

-- | <h2>Writing instances</h2>
--   
--   The usual way to write a <tt><a>MonadBaseControl</a></tt> instance for
--   a transformer stack over a base monad <tt>B</tt> is to write an
--   instance <tt>MonadBaseControl B B</tt> for the base monad, and
--   <tt>MonadTransControl T</tt> instances for every transformer
--   <tt>T</tt>. Instances for <tt><a>MonadBaseControl</a></tt> are then
--   simply implemented using <tt><a>ComposeSt</a></tt>,
--   <tt><a>defaultLiftBaseWith</a></tt>, <tt><a>defaultRestoreM</a></tt>.
class MonadBase b m => MonadBaseControl b m | m -> b where {
    
    -- | Monadic state that <tt>m</tt> adds to the base monad <tt>b</tt>.
    --   
    --   For all base (non-transformed) monads, <tt>StM m a ~ a</tt>:
    --   
    --   <pre>
    --   StM <a>IO</a>         a ~ a
    --   StM <a>Maybe</a>      a ~ a
    --   StM (<a>Either</a> e) a ~ a
    --   StM []         a ~ a
    --   StM ((-&gt;) r)   a ~ a
    --   StM <a>Identity</a>   a ~ a
    --   StM <a>STM</a>        a ~ a
    --   StM (<a>ST</a> s)     a ~ a
    --   </pre>
    --   
    --   If <tt>m</tt> is a transformed monad, <tt>m ~ t b</tt>,
    --   <tt><a>StM</a></tt> is the monadic state of the transformer <tt>t</tt>
    --   (given by its <a>StT</a> from <a>MonadTransControl</a>). For a
    --   transformer stack, <tt><a>StM</a></tt> is defined recursively:
    --   
    --   <pre>
    --   StM (<a>IdentityT</a>  m) a ~ <a>ComposeSt</a> <a>IdentityT</a> m a ~ StM m a
    --   StM (<a>MaybeT</a>     m) a ~ <a>ComposeSt</a> <a>MaybeT</a>    m a ~ StM m (<a>Maybe</a> a)
    --   StM (<tt>ErrorT</tt> e   m) a ~ <a>ComposeSt</a> <tt>ErrorT</tt>    m a ~ <tt>Error</tt> e =&gt; StM m (<a>Either</a> e a)
    --   StM (<a>ExceptT</a> e  m) a ~ <a>ComposeSt</a> <a>ExceptT</a>   m a ~ StM m (<a>Either</a> e a)
    --   StM (<tt>ListT</tt>      m) a ~ <a>ComposeSt</a> <tt>ListT</tt>     m a ~ StM m [a]
    --   StM (<a>ReaderT</a> r  m) a ~ <a>ComposeSt</a> <a>ReaderT</a>   m a ~ StM m a
    --   StM (<a>StateT</a> s   m) a ~ <a>ComposeSt</a> <a>StateT</a>    m a ~ StM m (a, s)
    --   StM (<a>WriterT</a> w  m) a ~ <a>ComposeSt</a> <a>WriterT</a>   m a ~ <a>Monoid</a> w =&gt; StM m (a, w)
    --   StM (<a>RWST</a> r w s m) a ~ <a>ComposeSt</a> <a>RWST</a>      m a ~ <a>Monoid</a> w =&gt; StM m (a, s, w)
    --   </pre>
    type StM m a :: *;
}

-- | <tt>liftBaseWith</tt> is similar to <tt>liftIO</tt> and
--   <tt>liftBase</tt> in that it lifts a base computation to the
--   constructed monad.
--   
--   Instances should satisfy similar laws as the <tt>MonadIO</tt> and
--   <a>MonadBase</a> laws:
--   
--   <pre>
--   liftBaseWith (\_ -&gt; return a) = return a
--   </pre>
--   
--   <pre>
--   liftBaseWith (\_ -&gt; m &gt;&gt;= f)  =  liftBaseWith (\_ -&gt; m) &gt;&gt;= (\a -&gt; liftBaseWith (\_ -&gt; f a))
--   </pre>
--   
--   As <a>Li-yao Xia explains</a>, parametricity guarantees that
--   
--   <pre>
--   f <a>$</a> liftBaseWith q = liftBaseWith $ runInBase -&gt; f <a>$</a> q runInBase
--   </pre>
--   
--   The difference with <tt>liftBase</tt> is that before lifting the base
--   computation <tt>liftBaseWith</tt> captures the state of <tt>m</tt>. It
--   then provides the base computation with a <a>RunInBase</a> function
--   that allows running <tt>m</tt> computations in the base monad on the
--   captured state:
--   
--   <pre>
--   withFileLifted :: MonadBaseControl IO m =&gt; FilePath -&gt; IOMode -&gt; (Handle -&gt; m a) -&gt; m a
--   withFileLifted file mode action = liftBaseWith (\runInBase -&gt; withFile file mode (runInBase . action)) &gt;&gt;= restoreM
--                                -- = control $ \runInBase -&gt; withFile file mode (runInBase . action)
--                                -- = liftBaseOp (withFile file mode) action
--   </pre>
--   
--   <tt><a>liftBaseWith</a></tt> is usually not implemented directly, but
--   using <tt><a>defaultLiftBaseWith</a></tt>.
liftBaseWith :: MonadBaseControl b m => (RunInBase m b -> b a) -> m a

-- | Construct a <tt>m</tt> computation from the monadic state of
--   <tt>m</tt> that is returned from a <a>RunInBase</a> function.
--   
--   Instances should satisfy:
--   
--   <pre>
--   liftBaseWith (\runInBase -&gt; runInBase m) &gt;&gt;= restoreM = m
--   </pre>
--   
--   <tt><a>restoreM</a></tt> is usually not implemented directly, but
--   using <tt><a>defaultRestoreM</a></tt>.
restoreM :: MonadBaseControl b m => StM m a -> m a

-- | A function that runs a <tt>m</tt> computation on the monadic state
--   that was captured by <a>liftBaseWith</a>
--   
--   A <tt>RunInBase m</tt> function yields a computation in the base monad
--   of <tt>m</tt> that returns the monadic state of <tt>m</tt>. This state
--   can later be used to restore the <tt>m</tt> computation using
--   <a>restoreM</a>.
--   
--   Example type equalities:
--   
--   <pre>
--   RunInBase (<a>IdentityT</a>  m) b ~ forall a.             <a>IdentityT</a>  m a -&gt; b (<a>StM</a> m a)
--   RunInBase (<a>MaybeT</a>     m) b ~ forall a.             <a>MaybeT</a>     m a -&gt; b (<a>StM</a> m (<a>Maybe</a> a))
--   RunInBase (<tt>ErrorT</tt> e   m) b ~ forall a. <tt>Error</tt> e =&gt;  <tt>ErrorT</tt> e   m a -&gt; b (<a>StM</a> m (<a>Either</a> e a))
--   RunInBase (<a>ExceptT</a> e  m) b ~ forall a.             <a>ExceptT</a> e  m a -&gt; b (<a>StM</a> m (<a>Either</a> e a))
--   RunInBase (<tt>ListT</tt>      m) b ~ forall a.             <tt>ListT</tt>      m a -&gt; b (<a>StM</a> m [a])
--   RunInBase (<a>ReaderT</a> r  m) b ~ forall a.             <a>ReaderT</a>    m a -&gt; b (<a>StM</a> m a)
--   RunInBase (<a>StateT</a> s   m) b ~ forall a.             <a>StateT</a> s   m a -&gt; b (<a>StM</a> m (a, s))
--   RunInBase (<a>WriterT</a> w  m) b ~ forall a. <a>Monoid</a> w =&gt; <a>WriterT</a> w  m a -&gt; b (<a>StM</a> m (a, w))
--   RunInBase (<a>RWST</a> r w s m) b ~ forall a. <a>Monoid</a> w =&gt; <a>RWST</a> r w s m a -&gt; b (<a>StM</a> m (a, s, w))
--   </pre>
--   
--   For a transformed base monad <tt>m ~ t b</tt>, <tt>'RunInBase m b' ~
--   <a>Run</a> t</tt>.
type RunInBase m b = forall a. m a -> b (StM m a)

-- | Handy type synonym that composes the monadic states of <tt>t</tt> and
--   <tt>m</tt>.
--   
--   It can be used to define the <a>StM</a> for new
--   <a>MonadBaseControl</a> instances.
type ComposeSt t m a = StM m (StT t a)

-- | A function like <a>RunInBase</a> that runs a monad transformer
--   <tt>t</tt> in its base monad <tt>b</tt>. It is used in
--   <a>defaultLiftBaseWith</a>.
type RunInBaseDefault t m b = forall a. t m a -> b (ComposeSt t m a)

-- | Default definition for the <a>liftBaseWith</a> method.
--   
--   Note that it composes a <a>liftWith</a> of <tt>t</tt> with a
--   <a>liftBaseWith</a> of <tt>m</tt> to give a <a>liftBaseWith</a> of
--   <tt>t m</tt>:
--   
--   <pre>
--   defaultLiftBaseWith = \f -&gt; <a>liftWith</a> $ \run -&gt;
--                                 <a>liftBaseWith</a> $ \runInBase -&gt;
--                                   f $ runInBase . run
--   </pre>
defaultLiftBaseWith :: (MonadTransControl t, MonadBaseControl b m) => (RunInBaseDefault t m b -> b a) -> t m a

-- | Default definition for the <a>restoreM</a> method.
--   
--   Note that: <tt>defaultRestoreM = <a>restoreT</a> .
--   <a>restoreM</a></tt>
defaultRestoreM :: (MonadTransControl t, MonadBaseControl b m) => ComposeSt t m a -> t m a

-- | An often used composition: <tt>control f = <a>liftBaseWith</a> f
--   &gt;&gt;= <a>restoreM</a></tt>
--   
--   Example:
--   
--   <pre>
--   liftedBracket :: MonadBaseControl IO m =&gt; m a -&gt; (a -&gt; m b) -&gt; (a -&gt; m c) -&gt; m c
--   liftedBracket acquire release action = control $ \runInBase -&gt;
--       bracket (runInBase acquire)
--               (\saved -&gt; runInBase (restoreM saved &gt;&gt;= release))
--               (\saved -&gt; runInBase (restoreM saved &gt;&gt;= action))
--   </pre>
control :: MonadBaseControl b m => (RunInBase m b -> b (StM m a)) -> m a

-- | Lift a computation and restore the monadic state immediately:
--   <tt>controlT f = <a>liftWith</a> f &gt;&gt;= <a>restoreT</a> .
--   return</tt>.
controlT :: (MonadTransControl t, Monad (t m), Monad m) => (Run t -> m (StT t a)) -> t m a

-- | Embed a transformer function as an function in the base monad
--   returning a mutated transformer state.
embed :: MonadBaseControl b m => (a -> m c) -> m (a -> b (StM m c))

-- | Performs the same function as <a>embed</a>, but discards transformer
--   state from the embedded function.
embed_ :: MonadBaseControl b m => (a -> m ()) -> m (a -> b ())

-- | Capture the current state of a transformer
captureT :: (MonadTransControl t, Monad (t m), Monad m) => t m (StT t ())

-- | Capture the current state above the base monad
captureM :: MonadBaseControl b m => m (StM m ())

-- | <tt>liftBaseOp</tt> is a particular application of <a>liftBaseWith</a>
--   that allows lifting control operations of type:
--   
--   <pre>
--   ((a -&gt; b c) -&gt; b c)
--   </pre>
--   
--   to:
--   
--   <pre>
--   (<a>MonadBaseControl</a> b m =&gt; (a -&gt; m c) -&gt; m c)
--   </pre>
--   
--   For example:
--   
--   <pre>
--   liftBaseOp alloca :: (Storable a, <a>MonadBaseControl</a> <a>IO</a> m) =&gt; (Ptr a -&gt; m c) -&gt; m c
--   </pre>
liftBaseOp :: MonadBaseControl b m => ((a -> b (StM m c)) -> b (StM m d)) -> (a -> m c) -> m d

-- | <tt>liftBaseOp_</tt> is a particular application of
--   <a>liftBaseWith</a> that allows lifting control operations of type:
--   
--   <pre>
--   (b a -&gt; b a)
--   </pre>
--   
--   to:
--   
--   <pre>
--   (<a>MonadBaseControl</a> b m =&gt; m a -&gt; m a)
--   </pre>
--   
--   For example:
--   
--   <pre>
--   liftBaseOp_ mask_ :: <a>MonadBaseControl</a> <a>IO</a> m =&gt; m a -&gt; m a
--   </pre>
liftBaseOp_ :: MonadBaseControl b m => (b (StM m a) -> b (StM m c)) -> m a -> m c

-- | <tt>liftBaseDiscard</tt> is a particular application of
--   <a>liftBaseWith</a> that allows lifting control operations of type:
--   
--   <pre>
--   (b () -&gt; b a)
--   </pre>
--   
--   to:
--   
--   <pre>
--   (<a>MonadBaseControl</a> b m =&gt; m () -&gt; m a)
--   </pre>
--   
--   Note that, while the argument computation <tt>m ()</tt> has access to
--   the captured state, all its side-effects in <tt>m</tt> are discarded.
--   It is run only for its side-effects in the base monad <tt>b</tt>.
--   
--   For example:
--   
--   <pre>
--   liftBaseDiscard forkIO :: <a>MonadBaseControl</a> <a>IO</a> m =&gt; m () -&gt; m ThreadId
--   </pre>
liftBaseDiscard :: MonadBaseControl b m => (b () -> b a) -> m () -> m a

-- | <tt>liftBaseOpDiscard</tt> is a particular application of
--   <a>liftBaseWith</a> that allows lifting control operations of type:
--   
--   <pre>
--   ((a -&gt; b ()) -&gt; b c)
--   </pre>
--   
--   to:
--   
--   <pre>
--   (<a>MonadBaseControl</a> b m =&gt; (a -&gt; m ()) -&gt; m c)
--   </pre>
--   
--   Note that, while the argument computation <tt>m ()</tt> has access to
--   the captured state, all its side-effects in <tt>m</tt> are discarded.
--   It is run only for its side-effects in the base monad <tt>b</tt>.
--   
--   For example:
--   
--   <pre>
--   liftBaseDiscard (runServer addr port) :: <a>MonadBaseControl</a> <a>IO</a> m =&gt; m () -&gt; m ()
--   </pre>
liftBaseOpDiscard :: MonadBaseControl b m => ((a -> b ()) -> b c) -> (a -> m ()) -> m c

-- | Transform an action in <tt>t m</tt> using a transformer that operates
--   on the underlying monad <tt>m</tt>
liftThrough :: (MonadTransControl t, Monad (t m), Monad m) => (m (StT t a) -> m (StT t b)) -> t m a -> t m b
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Control.MonadBaseControl b m) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Control.MonadBaseControl b m) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Control.MonadBaseControl b m) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Control.MonadBaseControl b m) => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO GHC.Types.IO
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Maybe.Maybe GHC.Maybe.Maybe
instance Control.Monad.Trans.Control.MonadBaseControl (Data.Either.Either e) (Data.Either.Either e)
instance Control.Monad.Trans.Control.MonadBaseControl [] []
instance Control.Monad.Trans.Control.MonadBaseControl ((->) r) ((->) r)
instance Control.Monad.Trans.Control.MonadBaseControl Data.Functor.Identity.Identity Data.Functor.Identity.Identity
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Conc.Sync.STM GHC.Conc.Sync.STM
instance Control.Monad.Trans.Control.MonadBaseControl (GHC.ST.ST s) (GHC.ST.ST s)
instance Control.Monad.Trans.Control.MonadBaseControl (Control.Monad.ST.Lazy.Imp.ST s) (Control.Monad.ST.Lazy.Imp.ST s)
instance Control.Monad.Trans.Control.MonadTransControl Control.Monad.Trans.Identity.IdentityT
instance Control.Monad.Trans.Control.MonadTransControl Control.Monad.Trans.Maybe.MaybeT
instance Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.Reader.ReaderT r)
instance Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.State.Lazy.StateT s)
instance Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.State.Strict.StateT s)
instance GHC.Base.Monoid w => Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Control.Monad.Trans.Control.MonadTransControl (Control.Monad.Trans.RWS.Strict.RWST r w s)
