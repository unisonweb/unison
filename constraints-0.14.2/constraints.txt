-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constraint manipulation
--   
--   GHC 7.4 gave us the ability to talk about <tt>ConstraintKinds</tt>.
--   They stopped crashing the compiler in GHC 7.6.
--   
--   This package provides a vocabulary for working with them.
@package constraints
@version 0.14.2


-- | <tt>ConstraintKinds</tt> made type classes into types of a new kind,
--   <tt>Constraint</tt>.
--   
--   <pre>
--   <a>Eq</a> :: * -&gt; <a>Constraint</a>
--   <a>Ord</a> :: * -&gt; <a>Constraint</a>
--   <a>Monad</a> :: (* -&gt; *) -&gt; <a>Constraint</a>
--   </pre>
--   
--   The need for this extension was first publicized in the paper
--   
--   <a>Scrap your boilerplate with class: extensible generic functions</a>
--   
--   by Ralf Lämmel and Simon Peyton Jones in 2005, which shoehorned all
--   the things they needed into a custom <tt>Sat</tt> typeclass.
--   
--   With <tt>ConstraintKinds</tt> we can put into code a lot of tools for
--   manipulating these new types without such awkward workarounds.
module Data.Constraint

-- | The kind of lifted constraints
type Constraint = CONSTRAINT LiftedRep

-- | Values of type <tt><a>Dict</a> p</tt> capture a dictionary for a
--   constraint of type <tt>p</tt>.
--   
--   e.g.
--   
--   <pre>
--   <a>Dict</a> :: <a>Dict</a> (<a>Eq</a> <a>Int</a>)
--   </pre>
--   
--   captures a dictionary that proves we have an:
--   
--   <pre>
--   instance <a>Eq</a> <a>Int</a>
--   </pre>
--   
--   Pattern matching on the <a>Dict</a> constructor will bring this
--   instance into scope.
data Dict :: Constraint -> *
[Dict] :: a => Dict a

-- | Witnesses that a value of type <tt>e</tt> contains evidence of the
--   constraint <tt>c</tt>.
--   
--   Mainly intended to allow (<a>\\</a>) to be overloaded, since it's a
--   useful operator.
class HasDict c e | e -> c
evidence :: HasDict c e => e -> Dict c

-- | From a <a>Dict</a>, takes a value in an environment where the instance
--   witnessed by the <a>Dict</a> is in scope, and evaluates it.
--   
--   Essentially a deconstruction of a <a>Dict</a> into its
--   continuation-style form.
--   
--   Can also be used to deconstruct an entailment, <tt>a <a>:-</a> b</tt>,
--   using a context <tt>a</tt>.
--   
--   <pre>
--   withDict :: <a>Dict</a> c -&gt; (c =&gt; r) -&gt; r
--   withDict :: a =&gt; (a <a>:-</a> c) -&gt; (c =&gt; r) -&gt; r
--   </pre>
withDict :: HasDict c e => e -> (c => r) -> r

-- | Operator version of <a>withDict</a>, with the arguments flipped
(\\) :: HasDict c e => (c => r) -> e -> r
infixl 1 \\

-- | This is the type of entailment.
--   
--   <tt>a <a>:-</a> b</tt> is read as <tt>a</tt> "entails" <tt>b</tt>.
--   
--   With this we can actually build a category for <a>Constraint</a>
--   resolution.
--   
--   e.g.
--   
--   Because <tt><a>Eq</a> a</tt> is a superclass of <tt><a>Ord</a> a</tt>,
--   we can show that <tt><a>Ord</a> a</tt> entails <tt><a>Eq</a> a</tt>.
--   
--   Because <tt>instance <a>Ord</a> a =&gt; <a>Ord</a> [a]</tt> exists, we
--   can show that <tt><a>Ord</a> a</tt> entails <tt><a>Ord</a> [a]</tt> as
--   well.
--   
--   This relationship is captured in the <a>:-</a> entailment type here.
--   
--   Since <tt>p <a>:-</a> p</tt> and entailment composes, <a>:-</a> forms
--   the arrows of a <a>Category</a> of constraints. However,
--   <a>Category</a> only became sufficiently general to support this
--   instance in GHC 7.8, so prior to 7.8 this instance is unavailable.
--   
--   But due to the coherence of instance resolution in Haskell, this
--   <a>Category</a> has some very interesting properties. Notably, in the
--   absence of <tt>IncoherentInstances</tt>, this category is "thin",
--   which is to say that between any two objects (constraints) there is at
--   most one distinguishable arrow.
--   
--   This means that for instance, even though there are two ways to derive
--   <tt><a>Ord</a> a <a>:-</a> <a>Eq</a> [a]</tt>, the answers from these
--   two paths _must_ by construction be equal. This is a property that
--   Haskell offers that is pretty much unique in the space of languages
--   with things they call "type classes".
--   
--   What are the two ways?
--   
--   Well, we can go from <tt><a>Ord</a> a <a>:-</a> <a>Eq</a> a</tt> via
--   the superclass relationship, and then from <tt><a>Eq</a> a <a>:-</a>
--   <a>Eq</a> [a]</tt> via the instance, or we can go from <tt><a>Ord</a>
--   a <a>:-</a> <a>Ord</a> [a]</tt> via the instance then from
--   <tt><a>Ord</a> [a] <a>:-</a> <a>Eq</a> [a]</tt> through the superclass
--   relationship and this diagram by definition must "commute".
--   
--   Diagrammatically,
--   
--   <pre>
--          Ord a
--      ins /     \ cls
--         v       v
--   Ord [a]     Eq a
--      cls \     / ins
--           v   v
--          Eq [a]
--   </pre>
--   
--   This safety net ensures that pretty much anything you can write with
--   this library is sensible and can't break any assumptions on the behalf
--   of library authors.
newtype a :- b
Sub :: (a => Dict b) -> (:-) a b
infixr 9 :-

-- | Type entailment, as written with a single character.
type (⊢) = (:-)
infixr 9 ⊢

-- | The internal hom for the category of constraints.
--   
--   This version can be passed around inside Dict, whereas (a =&gt; b) is
--   impredicative
--   
--   <pre>
--   foo :: Dict (Ord a =&gt; Eq a)
--   foo = Dict
--   </pre>
--   
--   fails to typecheck due to the lack of impredicative polymorphism, but
--   
--   <pre>
--   foo :: Dict (Ord a |- Eq a)
--   foo = Dict
--   </pre>
--   
--   typechecks just fine.
class (p => q) => p |- q

-- | due to the hack for the kind of <tt>(,)</tt> in the current version of
--   GHC we can't actually make instances for <tt>(,) :: Constraint -&gt;
--   Constraint -&gt; Constraint</tt>, but we can define an equivalent
--   type, that converts back and forth to <tt>(,)</tt>, and lets you hang
--   instances.
class (p, q) => p & q

-- | Weakening a constraint product
--   
--   The category of constraints is Cartesian. We can forget information.
weaken1 :: (a, b) :- a

-- | Weakening a constraint product
--   
--   The category of constraints is Cartesian. We can forget information.
weaken2 :: (a, b) :- b

-- | Contracting a constraint / diagonal morphism
--   
--   The category of constraints is Cartesian. We can reuse information.
contract :: a :- (a, a)
strengthen1 :: Dict b -> (a :- c) -> a :- (b, c)
strengthen2 :: Dict b -> (a :- c) -> a :- (c, b)

-- | Constraint product
--   
--   <pre>
--   trans weaken1 (f &amp;&amp;&amp; g) = f
--   trans weaken2 (f &amp;&amp;&amp; g) = g
--   </pre>
(&&&) :: (a :- b) -> (a :- c) -> a :- (b, c)

-- | due to the hack for the kind of <tt>(,)</tt> in the current version of
--   GHC we can't actually make instances for <tt>(,) :: Constraint -&gt;
--   Constraint -&gt; Constraint</tt>, but <tt>(,)</tt> is a bifunctor on
--   the category of constraints. This lets us map over both sides.
(***) :: (a :- b) -> (c :- d) -> (a, c) :- (b, d)

-- | Transitivity of entailment
--   
--   If we view <tt>(<a>:-</a>)</tt> as a Constraint-indexed category, then
--   this is <tt>(<a>Category</a>)</tt>
trans :: (b :- c) -> (a :- b) -> a :- c

-- | Reflexivity of entailment
--   
--   If we view <tt>(<a>:-</a>)</tt> as a Constraint-indexed category, then
--   this is <a>Category</a>
refl :: a :- a

-- | Convert a quantified constraint into an entailment.
implied :: forall a b. (a => b) => a :- b

-- | <tt>Any</tt> inhabits every kind, including <a>Constraint</a> but is
--   uninhabited, making it impossible to define an instance.
class Any => Bottom
no :: Bottom => a

-- | Every constraint implies truth
--   
--   These are the terminal arrows of the category, and <tt>()</tt> is the
--   terminal object.
--   
--   Given any constraint there is a unique entailment of the <tt>()</tt>
--   constraint from that constraint.
top :: a :- ()

-- | This demonstrates the law of classical logic <a>"ex falso
--   quodlibet"</a>
bottom :: Bottom :- a

-- | Apply an entailment to a dictionary.
--   
--   From a category theoretic perspective <a>Dict</a> is a functor that
--   maps from the category of constraints (with arrows in <a>:-</a>) to
--   the category Hask of Haskell data types.
mapDict :: (a :- b) -> Dict a -> Dict b

-- | This functor is fully faithful, which is to say that given any
--   function you can write <tt>Dict a -&gt; Dict b</tt> there also exists
--   an entailment <tt>a :- b</tt> in the category of constraints that you
--   can build.
unmapDict :: (Dict a -> Dict b) -> a :- b

-- | Reify the relationship between a class and its superclass constraints
--   as a class
--   
--   Given a definition such as
--   
--   <pre>
--   class Foo a =&gt; Bar a
--   </pre>
--   
--   you can capture the relationship between 'Bar a' and its superclass
--   'Foo a' with
--   
--   <pre>
--   instance <a>Class</a> (Foo a) (Bar a) where <a>cls</a> = <a>Sub</a> <a>Dict</a>
--   </pre>
--   
--   Now the user can use 'cls :: Bar a :- Foo a'
class Class b h | h -> b
cls :: Class b h => h :- b

-- | Reify the relationship between an instance head and its body as a
--   class
--   
--   Given a definition such as
--   
--   <pre>
--   instance Foo a =&gt; Foo [a]
--   </pre>
--   
--   you can capture the relationship between the instance head and its
--   body with
--   
--   <pre>
--   instance Foo a <a>:=&gt;</a> Foo [a] where <a>ins</a> = <a>Sub</a> <a>Dict</a>
--   </pre>
class b :=> h | h -> b
ins :: (:=>) b h => b :- h
infixr 9 :=>
instance (Data.Typeable.Internal.Typeable p, p) => Data.Data.Data (Data.Constraint.Dict p)
instance GHC.Classes.Eq (Data.Constraint.Dict a)
instance GHC.Classes.Ord (Data.Constraint.Dict a)
instance GHC.Show.Show (Data.Constraint.Dict a)
instance a => GHC.Read.Read (Data.Constraint.Dict a)
instance Data.Constraint.Class (() :: Constraint) (b Data.Constraint.:=> a)
instance Data.Constraint.Class b a => (() :: Constraint) Data.Constraint.:=> Data.Constraint.Class b a
instance (b Data.Constraint.:=> a) => (() :: Constraint) Data.Constraint.:=> (b Data.Constraint.:=> a)
instance (() :: Constraint) Data.Constraint.:=> (() :: Constraint)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Double
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq [a]
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (GHC.Maybe.Maybe a)
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (GHC.Real.Ratio a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) Data.Constraint.:=> GHC.Classes.Eq (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) Data.Constraint.:=> GHC.Classes.Eq (Data.Either.Either a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq (Data.Constraint.Dict a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq (a Data.Constraint.:- b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Word
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Double
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Char
instance GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord (GHC.Maybe.Maybe a)
instance GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord [a]
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) Data.Constraint.:=> GHC.Classes.Ord (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) Data.Constraint.:=> GHC.Classes.Ord (Data.Either.Either a b)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Classes.Ord (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord (Data.Constraint.Dict a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord (a Data.Constraint.:- b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Word
instance GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Char
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Int
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show [a]
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (GHC.Maybe.Maybe a)
instance (GHC.Show.Show a, GHC.Show.Show b) Data.Constraint.:=> GHC.Show.Show (a, b)
instance (GHC.Show.Show a, GHC.Show.Show b) Data.Constraint.:=> GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Real.Integral a, GHC.Show.Show a) Data.Constraint.:=> GHC.Show.Show (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show (Data.Constraint.Dict a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show (a Data.Constraint.:- b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Word
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Char
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Int
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read [a]
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (GHC.Maybe.Maybe a)
instance (GHC.Read.Read a, GHC.Read.Read b) Data.Constraint.:=> GHC.Read.Read (a, b)
instance (GHC.Read.Read a, GHC.Read.Read b) Data.Constraint.:=> GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Real.Integral a, GHC.Read.Read a) Data.Constraint.:=> GHC.Read.Read (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Word
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Char
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Enum.Enum (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Word
instance GHC.Enum.Enum a Data.Constraint.:=> GHC.Enum.Enum (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Enum.Enum a Data.Constraint.:=> GHC.Enum.Enum (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Char
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) Data.Constraint.:=> GHC.Enum.Bounded (a, b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Word
instance GHC.Enum.Bounded a Data.Constraint.:=> GHC.Enum.Bounded (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Enum.Bounded a Data.Constraint.:=> GHC.Enum.Bounded (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Num.Num (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Word
instance GHC.Num.Num a Data.Constraint.:=> GHC.Num.Num (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Num.Num a Data.Constraint.:=> GHC.Num.Num (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Real (GHC.Real.Ratio a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Word
instance GHC.Real.Real a Data.Constraint.:=> GHC.Real.Real (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Real.Real a Data.Constraint.:=> GHC.Real.Real (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Types.Word
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Integral (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Integral (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Bits.Bits GHC.Types.Bool
instance (() :: Constraint) Data.Constraint.:=> GHC.Bits.Bits GHC.Types.Int
instance (() :: Constraint) Data.Constraint.:=> GHC.Bits.Bits GHC.Num.Integer.Integer
instance (() :: Constraint) Data.Constraint.:=> GHC.Bits.Bits GHC.Types.Word
instance GHC.Bits.Bits a Data.Constraint.:=> GHC.Bits.Bits (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Bits.Bits a Data.Constraint.:=> GHC.Bits.Bits (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Bits.Bits GHC.Num.Natural.Natural
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Fractional GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.Fractional GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Fractional (GHC.Real.Ratio a)
instance GHC.Real.Fractional a Data.Constraint.:=> GHC.Real.Fractional (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Real.Fractional a Data.Constraint.:=> GHC.Real.Fractional (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Float.Floating GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Float.Floating GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Float.Floating (Data.Complex.Complex a)
instance GHC.Float.Floating a Data.Constraint.:=> GHC.Float.Floating (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Float.Floating a Data.Constraint.:=> GHC.Float.Floating (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.RealFrac GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Real.RealFrac GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.RealFrac (GHC.Real.Ratio a)
instance GHC.Real.RealFrac a Data.Constraint.:=> GHC.Real.RealFrac (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Real.RealFrac a Data.Constraint.:=> GHC.Real.RealFrac (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Float.RealFloat GHC.Types.Float
instance (() :: Constraint) Data.Constraint.:=> GHC.Float.RealFloat GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Float.RealFloat (Data.Functor.Identity.Identity a)
instance forall k a (b :: k). GHC.Float.RealFloat a Data.Constraint.:=> GHC.Float.RealFloat (Data.Functor.Const.Const a b)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Semigroup ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Semigroup GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Semigroup [a]
instance GHC.Base.Semigroup a Data.Constraint.:=> GHC.Base.Semigroup (GHC.Maybe.Maybe a)
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup b) Data.Constraint.:=> GHC.Base.Semigroup (a, b)
instance forall k a (b :: k). GHC.Base.Semigroup a Data.Constraint.:=> GHC.Base.Semigroup (Data.Functor.Const.Const a b)
instance GHC.Base.Semigroup a Data.Constraint.:=> GHC.Base.Semigroup (Data.Functor.Identity.Identity a)
instance GHC.Base.Semigroup a Data.Constraint.:=> GHC.Base.Semigroup (GHC.Types.IO a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monoid ()
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monoid GHC.Types.Ordering
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monoid [a]
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Monoid (GHC.Maybe.Maybe a)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) Data.Constraint.:=> GHC.Base.Monoid (a, b)
instance forall k a (b :: k). GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Monoid (Data.Functor.Const.Const a b)
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Monoid (Data.Functor.Identity.Identity a)
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Monoid (GHC.Types.IO a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor []
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor GHC.Maybe.Maybe
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor (Data.Either.Either a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor ((->) a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor ((,) a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor GHC.Types.IO
instance GHC.Base.Monad m Data.Constraint.:=> GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor Data.Functor.Identity.Identity
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Functor (Data.Functor.Const.Const a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Applicative []
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Applicative GHC.Maybe.Maybe
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Applicative (Data.Either.Either a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Applicative ((->) a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Applicative GHC.Types.IO
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Applicative ((,) a)
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Applicative (Data.Functor.Const.Const a)
instance GHC.Base.Monad m Data.Constraint.:=> GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Alternative []
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Alternative GHC.Maybe.Maybe
instance GHC.Base.MonadPlus m Data.Constraint.:=> GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monad []
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monad ((->) a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monad (Data.Either.Either a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monad GHC.Types.IO
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Monad Data.Functor.Identity.Identity
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.MonadPlus []
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.MonadPlus GHC.Maybe.Maybe
instance a Data.Constraint.:=> GHC.Enum.Enum (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Enum.Bounded (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Read.Read (Data.Constraint.Dict a)
instance (() :: Constraint) Data.Constraint.:=> GHC.Base.Semigroup (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Base.Monoid (Data.Constraint.Dict a)
instance Data.Constraint.Class (() :: Constraint) (Data.Constraint.Class b a)
instance Data.Constraint.Class (() :: Constraint) (() :: Constraint)
instance Data.Constraint.Class (() :: Constraint) (GHC.Classes.Eq a)
instance Data.Constraint.Class (GHC.Classes.Eq a) (GHC.Classes.Ord a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Show.Show a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Read.Read a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Enum.Enum a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Enum.Bounded a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Num.Num a)
instance Data.Constraint.Class (GHC.Num.Num a, GHC.Classes.Ord a) (GHC.Real.Real a)
instance Data.Constraint.Class (GHC.Real.Real a, GHC.Enum.Enum a) (GHC.Real.Integral a)
instance Data.Constraint.Class (GHC.Classes.Eq a) (GHC.Bits.Bits a)
instance Data.Constraint.Class (GHC.Num.Num a) (GHC.Real.Fractional a)
instance Data.Constraint.Class (GHC.Real.Fractional a) (GHC.Float.Floating a)
instance Data.Constraint.Class (GHC.Real.Real a, GHC.Real.Fractional a) (GHC.Real.RealFrac a)
instance Data.Constraint.Class (GHC.Real.RealFrac a, GHC.Float.Floating a) (GHC.Float.RealFloat a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Base.Semigroup a)
instance Data.Constraint.Class (GHC.Base.Semigroup a) (GHC.Base.Monoid a)
instance Data.Constraint.Class (() :: Constraint) (GHC.Base.Functor f)
instance Data.Constraint.Class (GHC.Base.Functor f) (GHC.Base.Applicative f)
instance Data.Constraint.Class (GHC.Base.Applicative f) (GHC.Base.Alternative f)
instance Data.Constraint.Class (GHC.Base.Applicative f) (GHC.Base.Monad f)
instance Data.Constraint.Class (GHC.Base.Monad f, GHC.Base.Alternative f) (GHC.Base.MonadPlus f)
instance (p, q) => p Data.Constraint.& q
instance (p => q) => p Data.Constraint.|- q
instance a => Data.Constraint.HasDict b (a Data.Constraint.:- b)
instance (Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable q, p => q) => Data.Data.Data (p Data.Constraint.:- q)
instance Control.Category.Category (Data.Constraint.:-)
instance GHC.Classes.Eq (a Data.Constraint.:- b)
instance GHC.Classes.Ord (a Data.Constraint.:- b)
instance GHC.Show.Show (a Data.Constraint.:- b)
instance a => Control.DeepSeq.NFData (a Data.Constraint.:- b)
instance Data.Constraint.HasDict a (Data.Constraint.Dict a)
instance forall k (a :: k) (b :: k). Data.Constraint.HasDict (GHC.Types.Coercible a b) (Data.Type.Coercion.Coercion a b)
instance forall k (a :: k) (b :: k). Data.Constraint.HasDict (a GHC.Types.~ b) (a Data.Type.Equality.:~: b)
instance forall k1 k2 (a :: k1) (b :: k2). Data.Constraint.HasDict (a GHC.Types.~~ b) (a Data.Type.Equality.:~~: b)
instance forall k (a :: k). Data.Constraint.HasDict (Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable a) (Data.Typeable.Internal.TypeRep a)
instance c => Data.Boring.Boring (Data.Constraint.Dict c)
instance Control.DeepSeq.NFData (Data.Constraint.Dict c)
instance a => GHC.Enum.Enum (Data.Constraint.Dict a)
instance a => GHC.Enum.Bounded (Data.Constraint.Dict a)
instance GHC.Base.Semigroup (Data.Constraint.Dict a)
instance a => GHC.Base.Monoid (Data.Constraint.Dict a)


-- | The idea for this trick comes from Dimitrios Vytiniotis.
module Data.Constraint.Deferrable
newtype UnsatisfiedConstraint
UnsatisfiedConstraint :: String -> UnsatisfiedConstraint

-- | Allow an attempt at resolution of a constraint at a later time
class Deferrable p

-- | Resolve a <a>Deferrable</a> constraint with observable failure.
deferEither :: Deferrable p => (p => r) -> Either String r
defer :: forall p r. Deferrable p => (p => r) -> r
deferred :: forall p. Deferrable p :- p

-- | Kind heterogeneous propositional equality. Like <a>:~:</a>, <tt>a :~~:
--   b</tt> is inhabited by a terminating value if and only if <tt>a</tt>
--   is the same type as <tt>b</tt>.
data () => (a :: k1) :~~: (b :: k2)
[HRefl] :: forall {k1} (a :: k1). a :~~: a
infix 4 :~~:

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data () => (a :: k) :~: (b :: k)
[Refl] :: forall {k} (a :: k). a :~: a
infix 4 :~:
instance GHC.Show.Show Data.Constraint.Deferrable.UnsatisfiedConstraint
instance Data.Constraint.Deferrable.Deferrable (() :: Constraint)
instance forall k (a :: k) (b :: k). (Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => Data.Constraint.Deferrable.Deferrable (a GHC.Types.~ b)
instance forall i j (a :: i) (b :: j). (Data.Typeable.Internal.Typeable i, Data.Typeable.Internal.Typeable j, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => Data.Constraint.Deferrable.Deferrable (a GHC.Types.~~ b)
instance (Data.Constraint.Deferrable.Deferrable a, Data.Constraint.Deferrable.Deferrable b) => Data.Constraint.Deferrable.Deferrable (a, b)
instance (Data.Constraint.Deferrable.Deferrable a, Data.Constraint.Deferrable.Deferrable b, Data.Constraint.Deferrable.Deferrable c) => Data.Constraint.Deferrable.Deferrable (a, b, c)
instance GHC.Exception.Type.Exception Data.Constraint.Deferrable.UnsatisfiedConstraint


-- | This module uses a trick to provide quantification over constraints.
module Data.Constraint.Forall
class (forall a. p a) => Forall (p :: k -> Constraint)

-- | Instantiate a quantified <tt><a>Forall</a> p</tt> constraint at type
--   <tt>a</tt>.
inst :: forall p a. Forall p :- p a

-- | A representation of the quantified constraint <tt>forall a. p (f
--   a)</tt>.
class Forall (ComposeC p f) => ForallF (p :: k2 -> Constraint) (f :: k1 -> k2)

-- | Instantiate a quantified <tt><a>ForallF</a> p f</tt> constraint at
--   type <tt>a</tt>.
instF :: forall p f a. ForallF p f :- p (f a)
type Forall1 p = Forall p

-- | Instantiate a quantified constraint on kind <tt>* -&gt; *</tt>. This
--   is now redundant since <tt><a>inst</a></tt> became polykinded.
inst1 :: forall (p :: (* -> *) -> Constraint) (f :: * -> *). Forall p :- p f

-- | A representation of the quantified constraint <tt>forall f a. p (t f
--   a)</tt>.
class Forall (Q p t) => ForallT (p :: k4 -> Constraint) (t :: (k1 -> k2) -> k3 -> k4)

-- | Instantiate a quantified <tt><a>ForallT</a> p t</tt> constraint at
--   types <tt>f</tt> and <tt>a</tt>.
instT :: forall k1 k2 k3 k4 (p :: k4 -> Constraint) (t :: (k1 -> k2) -> k3 -> k4) (f :: k1 -> k2) (a :: k3). ForallT p t :- p (t f a)

-- | A representation of the quantified constraint <tt>forall a1 a2 ... an
--   . p a1 a2 ... an</tt>, supporting a variable number of parameters.
type family ForallV :: k -> Constraint

-- | Instantiate a quantified <tt><a>ForallV</a> p</tt> constraint as
--   <tt>c</tt>, where <tt>c ~ p a1 a2 ... an</tt>.
class InstV (p :: k) c | k c -> p
instV :: InstV p c => ForallV p :- c
forall_ :: forall p. (forall a. Dict (p a)) -> Dict (Forall p)
instance forall k (p :: k). Data.Constraint.Forall.ForallV' p => Data.Constraint.Forall.ForallV_ p
instance (p GHC.Types.~ c) => Data.Constraint.Forall.InstV p c
instance forall k (p :: k -> GHC.Types.Constraint) (a :: k) (c :: GHC.Types.Constraint). (p a GHC.Types.~ c) => Data.Constraint.Forall.InstV p c
instance forall k1 k2 k3 (p :: k1 -> k2 -> k3) (a :: k1) (c :: GHC.Types.Constraint). Data.Constraint.Forall.InstV (p a) c => Data.Constraint.Forall.InstV p c
instance forall k4 k1 k2 k3 (p :: k4 -> GHC.Types.Constraint) (t :: (k1 -> k2) -> k3 -> k4). Data.Constraint.Forall.Forall (Data.Constraint.Forall.Q p t) => Data.Constraint.Forall.ForallT p t
instance forall k3 k1 k2 (p :: k3 -> GHC.Types.Constraint) (t :: k1 -> k2 -> k3) (a :: k1). Data.Constraint.Forall.Forall (Data.Constraint.Forall.R p t a) => Data.Constraint.Forall.Q p t a
instance forall k3 k1 k2 (p :: k3 -> GHC.Types.Constraint) (t :: k1 -> k2 -> k3) (a :: k1) (b :: k2). p (t a b) => Data.Constraint.Forall.R p t a b
instance forall k2 k1 (p :: k2 -> GHC.Types.Constraint) (f :: k1 -> k2). Data.Constraint.Forall.Forall (Data.Constraint.Forall.ComposeC p f) => Data.Constraint.Forall.ForallF p f
instance forall k2 k1 (p :: k2 -> GHC.Types.Constraint) (f :: k1 -> k2) (a :: k1). p (f a) => Data.Constraint.Forall.ComposeC p f a
instance forall k (p :: k -> GHC.Types.Constraint). (forall (a :: k). p a) => Data.Constraint.Forall.Forall p

module Data.Constraint.Lifting
class Lifting p f
lifting :: Lifting p f => p a :- p (f a)
class Lifting2 p f
lifting2 :: Lifting2 p f => p a :- Lifting p (f a)
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Eq Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Ord Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Show.Show Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Read.Read Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Data.Hashable.Class.Hashable Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Data.Binary.Class.Binary Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Control.DeepSeq.NFData Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Eq (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Ord (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Show.Show (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Read.Read (,)
instance Data.Constraint.Lifting.Lifting2 Data.Hashable.Class.Hashable (,)
instance Data.Constraint.Lifting.Lifting2 Data.Binary.Class.Binary (,)
instance Data.Constraint.Lifting.Lifting2 Control.DeepSeq.NFData (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Semigroup (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Monoid (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Enum.Bounded (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Ix.Ix (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Applicative Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Alternative Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Applicative Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Alternative Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Monad Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.MonadPlus Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Control.Monad.Fix.MonadFix Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Show1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Eq1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Ord1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Read1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Show1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Eq1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Ord1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Read1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq []
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord []
instance Data.Constraint.Lifting.Lifting GHC.Show.Show []
instance Data.Constraint.Lifting.Lifting GHC.Read.Read []
instance Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable []
instance Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary []
instance Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData []
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Show.Show GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Read.Read GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Base.Semigroup GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Base.Monoid GHC.Maybe.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq GHC.Real.Ratio
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Read.Read Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Show.Show Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Base.Semigroup ((->) a)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monoid ((->) a)
instance GHC.Classes.Eq a => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Either.Either a)
instance GHC.Classes.Ord a => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Either.Either a)
instance GHC.Show.Show a => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Either.Either a)
instance GHC.Read.Read a => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Either.Either a)
instance Data.Hashable.Class.Hashable a => Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable (Data.Either.Either a)
instance Data.Binary.Class.Binary a => Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary (Data.Either.Either a)
instance Control.DeepSeq.NFData a => Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData (Data.Either.Either a)
instance GHC.Classes.Eq a => Data.Constraint.Lifting.Lifting GHC.Classes.Eq ((,) a)
instance GHC.Classes.Ord a => Data.Constraint.Lifting.Lifting GHC.Classes.Ord ((,) a)
instance GHC.Show.Show a => Data.Constraint.Lifting.Lifting GHC.Show.Show ((,) a)
instance GHC.Read.Read a => Data.Constraint.Lifting.Lifting GHC.Read.Read ((,) a)
instance Data.Hashable.Class.Hashable a => Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable ((,) a)
instance Data.Binary.Class.Binary a => Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary ((,) a)
instance Control.DeepSeq.NFData a => Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData ((,) a)
instance GHC.Base.Semigroup a => Data.Constraint.Lifting.Lifting GHC.Base.Semigroup ((,) a)
instance GHC.Base.Monoid a => Data.Constraint.Lifting.Lifting GHC.Base.Monoid ((,) a)
instance GHC.Enum.Bounded a => Data.Constraint.Lifting.Lifting GHC.Enum.Bounded ((,) a)
instance GHC.Ix.Ix a => Data.Constraint.Lifting.Lifting GHC.Ix.Ix ((,) a)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Compose.Compose f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Compose.Compose f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Compose.Compose f)
instance GHC.Base.Applicative f => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Data.Functor.Compose.Compose f)
instance GHC.Base.Alternative f => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Data.Functor.Compose.Compose f)
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Compose.Compose f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Compose.Compose f g)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Product.Product f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Product.Product f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Product.Product f)
instance GHC.Base.Applicative f => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Data.Functor.Product.Product f)
instance GHC.Base.Alternative f => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Data.Functor.Product.Product f)
instance GHC.Base.Monad f => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Data.Functor.Product.Product f)
instance Control.Monad.Fix.MonadFix f => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f)
instance GHC.Base.MonadPlus f => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Product.Product f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Product.Product f g)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Sum.Sum f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Sum.Sum f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Sum.Sum f g)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Base.Monoid e => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Show.Show e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Classes.Eq e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Classes.Ord e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Read.Read e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Except.ExceptT e)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Show.Show w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Classes.Eq w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Classes.Ord w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Read.Read w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Show.Show w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Classes.Eq w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Classes.Ord w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Read.Read w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Classes.Show1 m => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Read1 m => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Ord1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Eq1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Functor.Classes.Show1 m => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Read1 m => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Ord1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Eq1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Data.Functor.Reverse.Reverse
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Reverse.Reverse f)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Applicative.Backwards.Backwards
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Applicative.Backwards.Backwards f)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Applicative.Lift.Lift
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Applicative.Lift.Lift f)
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Show.Show Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Read.Read Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Except.ExceptT w)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Reader.ReaderT e)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Reader.ReaderT r)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Cont.ContT r')
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Reader.ReaderT r)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Cont.ContT r')


-- | Unsafe utilities used throughout <tt>constraints</tt>. As the names
--   suggest, these functions are unsafe in general and can cause your
--   program to segfault if used improperly. Handle with care.
module Data.Constraint.Unsafe

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | Unsafely create a dictionary for any constraint.
unsafeAxiom :: Dict c

-- | Coerce a dictionary unsafely from one type to another
unsafeCoerceConstraint :: a :- b

-- | Coerce a dictionary unsafely from one type to a newtype of that type
unsafeDerive :: Coercible n o => (o -> n) -> t o :- t n

-- | Coerce a dictionary unsafely from a newtype of a type to the base type
unsafeUnderive :: Coercible n o => (o -> n) -> t n :- t o

-- | Unsafely create an <a>SChar</a> value directly from a <a>Char</a>. Use
--   this function with care:
--   
--   <ul>
--   <li>The <a>Char</a> value must match the <a>Char</a> <tt>c</tt>
--   encoded in the return type <tt><a>SChar</a> c</tt>.</li>
--   <li>Be wary of using this function to create multiple values of type
--   <tt><a>SChar</a> T</tt>, where <tt>T</tt> is a type family that does
--   not reduce (e.g., <tt>Any</tt> from <a>GHC.Exts</a>). If you do, GHC
--   is liable to optimize away one of the values and replace it with the
--   other during a common subexpression elimination pass. If the two
--   values have different underlying <a>Char</a> values, this could be
--   disastrous.</li>
--   </ul>
unsafeSChar :: Char -> SChar c

-- | Unsafely create an <a>SNat</a> value directly from a <a>Natural</a>.
--   Use this function with care:
--   
--   <ul>
--   <li>The <a>Natural</a> value must match the <tt>Nat</tt> <tt>n</tt>
--   encoded in the return type <tt><a>SNat</a> n</tt>.</li>
--   <li>Be wary of using this function to create multiple values of type
--   <tt><a>SNat</a> T</tt>, where <tt>T</tt> is a type family that does
--   not reduce (e.g., <tt>Any</tt> from <a>GHC.Exts</a>). If you do, GHC
--   is liable to optimize away one of the values and replace it with the
--   other during a common subexpression elimination pass. If the two
--   values have different underlying <a>Natural</a> values, this could be
--   disastrous.</li>
--   </ul>
unsafeSNat :: Natural -> SNat n

-- | Unsafely create an <a>SSymbol</a> value directly from a <a>String</a>.
--   Use this function with care:
--   
--   <ul>
--   <li>The <a>String</a> value must match the <tt>Symbol</tt> <tt>s</tt>
--   encoded in the return type <tt><a>SSymbol</a> s</tt>.</li>
--   <li>Be wary of using this function to create multiple values of type
--   <tt><a>SSymbol</a> T</tt>, where <tt>T</tt> is a type family that does
--   not reduce (e.g., <tt>Any</tt> from <a>GHC.Exts</a>). If you do, GHC
--   is liable to optimize away one of the values and replace it with the
--   other during a common subexpression elimination pass. If the two
--   values have different underlying <a>String</a> values, this could be
--   disastrous.</li>
--   </ul>
unsafeSSymbol :: String -> SSymbol s


-- | Utilities for working with <a>KnownNat</a> constraints.
--   
--   This module is only available on GHC 8.0 or later.
module Data.Constraint.Nat
type family Min (m :: Nat) (n :: Nat) :: Nat
type family Max (m :: Nat) (n :: Nat) :: Nat
type family Lcm (m :: Nat) (n :: Nat) :: Nat
type family Gcd (m :: Nat) (n :: Nat) :: Nat
type Divides n m = n ~ Gcd n m

-- | Division (round down) of natural numbers. <tt>Div x 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Div (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Div`

-- | Modulus of natural numbers. <tt>Mod x 0</tt> is undefined (i.e., it
--   cannot be reduced).
type family Mod (a :: Natural) (b :: Natural) :: Natural
infixl 7 `Mod`

-- | Log base 2 (round down) of natural numbers. <tt>Log 0</tt> is
--   undefined (i.e., it cannot be reduced).
type family Log2 (a :: Natural) :: Natural
plusNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n + m)
minusNat :: forall n m. (KnownNat n, KnownNat m, m <= n) :- KnownNat (n - m)
timesNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n * m)
powNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (n ^ m)
minNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (Min n m)
maxNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (Max n m)
gcdNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (Gcd n m)
lcmNat :: forall n m. (KnownNat n, KnownNat m) :- KnownNat (Lcm n m)
divNat :: forall n m. (KnownNat n, KnownNat m, 1 <= m) :- KnownNat (Div n m)
modNat :: forall n m. (KnownNat n, KnownNat m, 1 <= m) :- KnownNat (Mod n m)
log2Nat :: forall n. (KnownNat n, 1 <= n) :- KnownNat (Log2 n)
plusZero :: forall n. Dict ((n + 0) ~ n)
minusZero :: forall n. Dict ((n - 0) ~ n)
timesZero :: forall n. Dict ((n * 0) ~ 0)
timesOne :: forall n. Dict ((n * 1) ~ n)
powZero :: forall n. Dict ((n ^ 0) ~ 1)
powOne :: forall n. Dict ((n ^ 1) ~ n)
maxZero :: forall n. Dict (Max n 0 ~ n)
minZero :: forall n. Dict (Min n 0 ~ 0)
gcdZero :: forall a. Dict (Gcd 0 a ~ a)
gcdOne :: forall a. Dict (Gcd 1 a ~ 1)
lcmZero :: forall a. Dict (Lcm 0 a ~ 0)
lcmOne :: forall a. Dict (Lcm 1 a ~ a)
plusAssociates :: forall m n o. Dict (((m + n) + o) ~ (m + (n + o)))
timesAssociates :: forall m n o. Dict (((m * n) * o) ~ (m * (n * o)))
minAssociates :: forall m n o. Dict (Min (Min m n) o ~ Min m (Min n o))
maxAssociates :: forall m n o. Dict (Max (Max m n) o ~ Max m (Max n o))
gcdAssociates :: forall a b c. Dict (Gcd (Gcd a b) c ~ Gcd a (Gcd b c))
lcmAssociates :: forall a b c. Dict (Lcm (Lcm a b) c ~ Lcm a (Lcm b c))
plusCommutes :: forall n m. Dict ((m + n) ~ (n + m))
timesCommutes :: forall n m. Dict ((m * n) ~ (n * m))
minCommutes :: forall n m. Dict (Min m n ~ Min n m)
maxCommutes :: forall n m. Dict (Max m n ~ Max n m)
gcdCommutes :: forall a b. Dict (Gcd a b ~ Gcd b a)
lcmCommutes :: forall a b. Dict (Lcm a b ~ Lcm b a)
plusDistributesOverTimes :: forall n m o. Dict ((n * (m + o)) ~ ((n * m) + (n * o)))
timesDistributesOverPow :: forall n m o. Dict ((n ^ (m + o)) ~ ((n ^ m) * (n ^ o)))
timesDistributesOverGcd :: forall n m o. Dict ((n * Gcd m o) ~ Gcd (n * m) (n * o))
timesDistributesOverLcm :: forall n m o. Dict ((n * Lcm m o) ~ Lcm (n * m) (n * o))
minDistributesOverPlus :: forall n m o. Dict ((n + Min m o) ~ Min (n + m) (n + o))
minDistributesOverTimes :: forall n m o. Dict ((n * Min m o) ~ Min (n * m) (n * o))
minDistributesOverPow1 :: forall n m o. Dict ((Min n m ^ o) ~ Min (n ^ o) (m ^ o))
minDistributesOverPow2 :: forall n m o. Dict ((n ^ Min m o) ~ Min (n ^ m) (n ^ o))
minDistributesOverMax :: forall n m o. Dict (Max n (Min m o) ~ Min (Max n m) (Max n o))
maxDistributesOverPlus :: forall n m o. Dict ((n + Max m o) ~ Max (n + m) (n + o))
maxDistributesOverTimes :: forall n m o. Dict ((n * Max m o) ~ Max (n * m) (n * o))
maxDistributesOverPow1 :: forall n m o. Dict ((Max n m ^ o) ~ Max (n ^ o) (m ^ o))
maxDistributesOverPow2 :: forall n m o. Dict ((n ^ Max m o) ~ Max (n ^ m) (n ^ o))
maxDistributesOverMin :: forall n m o. Dict (Min n (Max m o) ~ Max (Min n m) (Min n o))
gcdDistributesOverLcm :: forall a b c. Dict (Gcd (Lcm a b) c ~ Lcm (Gcd a c) (Gcd b c))
lcmDistributesOverGcd :: forall a b c. Dict (Lcm (Gcd a b) c ~ Gcd (Lcm a c) (Lcm b c))
minIsIdempotent :: forall n. Dict (Min n n ~ n)
maxIsIdempotent :: forall n. Dict (Max n n ~ n)
lcmIsIdempotent :: forall n. Dict (Lcm n n ~ n)
gcdIsIdempotent :: forall n. Dict (Gcd n n ~ n)
plusIsCancellative :: forall n m o. ((n + m) ~ (n + o)) :- (m ~ o)
timesIsCancellative :: forall n m o. (1 <= n, (n * m) ~ (n * o)) :- (m ~ o)
dividesPlus :: (Divides a b, Divides a c) :- Divides a (b + c)
dividesTimes :: Divides a b :- Divides a (b * c)
dividesMin :: (Divides a b, Divides a c) :- Divides a (Min b c)
dividesMax :: (Divides a b, Divides a c) :- Divides a (Max b c)
dividesPow :: (1 <= n, Divides a b) :- Divides a (b ^ n)
dividesGcd :: forall a b c. (Divides a b, Divides a c) :- Divides a (Gcd b c)
dividesLcm :: forall a b c. (Divides a c, Divides b c) :- Divides (Lcm a b) c
plusMonotone1 :: forall a b c. (a <= b) :- ((a + c) <= (b + c))
plusMonotone2 :: forall a b c. (b <= c) :- ((a + b) <= (a + c))
timesMonotone1 :: forall a b c. (a <= b) :- ((a * c) <= (b * c))
timesMonotone2 :: forall a b c. (b <= c) :- ((a * b) <= (a * c))
powMonotone1 :: forall a b c. (a <= b) :- ((a ^ c) <= (b ^ c))
powMonotone2 :: forall a b c. (b <= c) :- ((a ^ b) <= (a ^ c))
minMonotone1 :: forall a b c. (a <= b) :- (Min a c <= Min b c)
minMonotone2 :: forall a b c. (b <= c) :- (Min a b <= Min a c)
maxMonotone1 :: forall a b c. (a <= b) :- (Max a c <= Max b c)
maxMonotone2 :: forall a b c. (b <= c) :- (Max a b <= Max a c)
divMonotone1 :: forall a b c. (a <= b) :- (Div a c <= Div b c)
divMonotone2 :: forall a b c. (b <= c) :- (Div a c <= Div a b)
euclideanNat :: (1 <= c) :- (a ~ ((c * Div a c) + Mod a c))
plusMod :: forall a b c. (1 <= c) :- (Mod (a + b) c ~ Mod (Mod a c + Mod b c) c)
timesMod :: forall a b c. (1 <= c) :- (Mod (a * b) c ~ Mod (Mod a c * Mod b c) c)
modBound :: forall m n. (1 <= n) :- (Mod m n <= n)
log2Pow :: forall n. Dict (Log2 (2 ^ n) ~ n)
dividesDef :: forall a b. Divides a b :- (Mod b a ~ 0)
timesDiv :: forall a b. Dict ((a * Div b a) <= b)
eqLe :: forall (a :: Nat) (b :: Nat). (a ~ b) :- (a <= b)
leEq :: forall (a :: Nat) (b :: Nat). (a <= b, b <= a) :- (a ~ b)
leId :: forall (a :: Nat). Dict (a <= a)
leTrans :: forall (a :: Nat) (b :: Nat) (c :: Nat). (b <= c, a <= b) :- (a <= c)
leZero :: forall a. (a <= 0) :- (a ~ 0)
zeroLe :: forall (a :: Nat). Dict (0 <= a)
plusMinusInverse1 :: forall n m. Dict (((m + n) - n) ~ m)
plusMinusInverse2 :: forall n m. (m <= n) :- (((m + n) - m) ~ n)
plusMinusInverse3 :: forall n m. (n <= m) :- (((m - n) + n) ~ m)


-- | Utilities for working with <a>KnownSymbol</a> constraints.
module Data.Constraint.Symbol

-- | Concatenation of type-level symbols.
type family AppendSymbol (a :: Symbol) (b :: Symbol) :: Symbol

-- | An infix synonym for <a>AppendSymbol</a>.
type (m :: Symbol) ++ (n :: Symbol) = AppendSymbol m n
infixr 5 ++
type family Take :: Nat -> Symbol -> Symbol
type family Drop :: Nat -> Symbol -> Symbol
type family Length :: Symbol -> Nat
appendSymbol :: (KnownSymbol a, KnownSymbol b) :- KnownSymbol (AppendSymbol a b)
appendUnit1 :: forall a. Dict (AppendSymbol "" a ~ a)
appendUnit2 :: forall a. Dict (AppendSymbol a "" ~ a)
appendAssociates :: forall a b c. Dict (AppendSymbol (AppendSymbol a b) c ~ AppendSymbol a (AppendSymbol b c))
takeSymbol :: forall n a. (KnownNat n, KnownSymbol a) :- KnownSymbol (Take n a)
dropSymbol :: forall n a. (KnownNat n, KnownSymbol a) :- KnownSymbol (Drop n a)
takeAppendDrop :: forall n a. Dict (AppendSymbol (Take n a) (Drop n a) ~ a)
lengthSymbol :: forall a. KnownSymbol a :- KnownNat (Length a)
takeLength :: forall n a. (Length a <= n) :- (Take n a ~ a)
take0 :: forall a. Dict (Take 0 a ~ "")
takeEmpty :: forall n. Dict (Take n "" ~ "")
dropLength :: forall n a. (Length a <= n) :- (Drop n a ~ "")
drop0 :: forall a. Dict (Drop 0 a ~ a)
dropEmpty :: forall n. Dict (Drop n "" ~ "")
lengthTake :: forall n a. Dict (Length (Take n a) <= n)
lengthDrop :: forall n a. Dict (Length a <= (Length (Drop n a) + n))
dropDrop :: forall n m a. Dict (Drop n (Drop m a) ~ Drop (n + m) a)
takeTake :: forall n m a. Dict (Take n (Take m a) ~ Take (Min n m) a)


-- | Utilities for working with <a>KnownChar</a> constraints.
--   
--   This module is only available on GHC 9.2 or later.
module Data.Constraint.Char

-- | Convert a character to its Unicode code point (cf. <a>ord</a>)
type family CharToNat (a :: Char) :: Natural

-- | Convert a Unicode code point to a character (cf. <a>chr</a>)
type family NatToChar (a :: Natural) :: Char
charToNat :: forall c. KnownChar c :- KnownNat (CharToNat c)
natToChar :: forall n. (n <= 0x10FFFF, KnownNat n) :- KnownChar (NatToChar n)
