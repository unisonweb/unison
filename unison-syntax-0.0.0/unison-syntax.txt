-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-syntax
@version 0.0.0

module Unison.Lexer.Pos
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
[$sel:line:Pos] :: Pos -> {-# UNPACK #-} !Line
[$sel:column:Pos] :: Pos -> {-# UNPACK #-} !Column
type Line = Int
type Column = Int
instance GHC.Classes.Ord Unison.Lexer.Pos.Pos
instance GHC.Classes.Eq Unison.Lexer.Pos.Pos
instance GHC.Show.Show Unison.Lexer.Pos.Pos
instance GHC.Base.Semigroup Unison.Lexer.Pos.Pos
instance GHC.Base.Monoid Unison.Lexer.Pos.Pos

module Unison.Parser.Ann
data Ann
Intrinsic :: Ann
External :: Ann
GeneratedFrom :: Ann -> Ann
Ann :: Pos -> Pos -> Ann
[$sel:start:Intrinsic] :: Ann -> Pos
[$sel:end:Intrinsic] :: Ann -> Pos
startingLine :: Ann -> Maybe Line

-- | Checks whether an annotation contains a given position i.e. pos ∈
--   [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `contains` L.Pos 1 1
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 5
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `contains` L.Pos 0 10
--   False
--   </pre>
contains :: Ann -> Pos -> Bool

-- | Checks whether an annotation contains another annotation.
--   
--   i.e. pos ∈ [start, end)
--   
--   <pre>
--   &gt;&gt;&gt; Intrinsic `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; External `encompasses` Ann (L.Pos 1 1) (L.Pos 2 1)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 0 0) (L.Pos 0 10) `encompasses` Ann (L.Pos 0 1) (L.Pos 0 5)
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Ann (L.Pos 1 0) (L.Pos 1 10) `encompasses` Ann (L.Pos 0 0) (L.Pos 2 0)
--   Just False
--   </pre>
encompasses :: Ann -> Ann -> Maybe Bool
class Annotated a
ann :: Annotated a => a -> Ann
instance GHC.Show.Show Unison.Parser.Ann.Ann
instance GHC.Classes.Ord Unison.Parser.Ann.Ann
instance GHC.Classes.Eq Unison.Parser.Ann.Ann
instance Unison.Parser.Ann.Annotated Unison.Parser.Ann.Ann
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated [a]
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated (GHC.Base.NonEmpty a)
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated (GHC.Maybe.Maybe a)
instance Unison.Parser.Ann.Annotated GHC.Base.Void
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated (Control.Comonad.Cofree.Cofree f a)
instance GHC.Base.Monoid Unison.Parser.Ann.Ann
instance GHC.Base.Semigroup Unison.Parser.Ann.Ann

module Unison.Syntax.Lexer.Token
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
tokenP :: (Ord e, TraversableStream s, MonadParsec e s m) => m a -> m (Token a)
posP :: (Ord e, TraversableStream s, MonadParsec e s m) => m Pos
instance Data.Traversable.Traversable Unison.Syntax.Lexer.Token.Token
instance Data.Foldable.Foldable Unison.Syntax.Lexer.Token.Token
instance GHC.Base.Functor Unison.Syntax.Lexer.Token.Token
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Lexer.Token.Token a)
instance Unison.Parser.Ann.Annotated (Unison.Syntax.Lexer.Token.Token a)
instance GHC.Base.Applicative Unison.Syntax.Lexer.Token.Token
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Syntax.Lexer.Token.Token Data.Text.Internal.Text)


-- | Haskell parallel to <tt>unison/base.Doc</tt>.
--   
--   These types have two significant parameters: <tt>ident</tt> and
--   <tt>code</tt> that are expected to be parameterized by some
--   representation of identifiers and source code of the host language.
--   
--   This is much more restricted than <tt>unison/base.Doc</tt>, but it
--   covers everything we can parse from Haskell. The mismatch with Unison
--   is a problem, as someone can create a Unison Doc with explicit
--   constructors or function calls, have it rendered to a scratch file,
--   and then we can’t parse it. Changing the types here to match Unison
--   wouldn’t fix the issue. We have to modify the types and parser in
--   concert (in both Haskell and Unison) to bring them in line.
module Unison.Syntax.Parser.Doc.Data
newtype UntitledSection a
UntitledSection :: [a] -> UntitledSection a
newtype Paragraph a
Paragraph :: NonEmpty a -> Paragraph a
data List a
BulletedList :: NonEmpty (Column a) -> List a
NumberedList :: NonEmpty (Word64, Column a) -> List a
data Column a
Column :: Paragraph a -> Maybe (List a) -> Column a
data Top code leaf a
Section :: Paragraph leaf -> [a] -> Top code leaf a
Eval :: code -> Top code leaf a
ExampleBlock :: code -> Top code leaf a
CodeBlock :: String -> String -> Top code leaf a
List' :: List leaf -> Top code leaf a
Paragraph' :: Paragraph leaf -> Top code leaf a

-- | This is a deviation from the Unison Doc data model – in Unison, Doc
--   distinguishes between type and term links, but here Doc knows nothing
--   about what namespaces may exist.
data EmbedLink a
EmbedLink :: a -> EmbedLink a
newtype Transclude a
Transclude :: a -> Transclude a
newtype EmbedAnnotation ident a
EmbedAnnotation :: Either ident a -> EmbedAnnotation ident a
data SourceElement ident a
SourceElement :: EmbedLink ident -> [EmbedAnnotation ident a] -> SourceElement ident a
newtype EmbedSignatureLink a
EmbedSignatureLink :: a -> EmbedSignatureLink a
newtype Word
Word :: String -> Word
newtype Join a
Join :: NonEmpty a -> Join a
newtype Group a
Group :: Join a -> Group a
data Leaf ident code a
Link :: EmbedLink ident -> Leaf ident code a

-- | the Group always contains either a single Term/Type link or list of
--   <a>Transclude</a>s &amp; <a>Word</a>s
NamedLink :: Paragraph a -> Group a -> Leaf ident code a
Example :: code -> Leaf ident code a
Transclude' :: Transclude code -> Leaf ident code a
Bold :: Paragraph a -> Leaf ident code a
Italic :: Paragraph a -> Leaf ident code a
Strikethrough :: Paragraph a -> Leaf ident code a
Verbatim :: Word -> Leaf ident code a
Code :: Word -> Leaf ident code a
Source :: NonEmpty (SourceElement ident (Transclude code)) -> Leaf ident code a
FoldedSource :: NonEmpty (SourceElement ident (Transclude code)) -> Leaf ident code a
EvalInline :: code -> Leaf ident code a
Signature :: NonEmpty (EmbedSignatureLink ident) -> Leaf ident code a
SignatureInline :: EmbedSignatureLink ident -> Leaf ident code a
Word' :: Word -> Leaf ident code a
Group' :: Group a -> Leaf ident code a
instance GHC.Show.Show ident => Data.Functor.Classes.Show2 (Unison.Syntax.Parser.Doc.Data.Leaf ident)
instance GHC.Classes.Ord ident => Data.Functor.Classes.Ord2 (Unison.Syntax.Parser.Doc.Data.Leaf ident)
instance GHC.Classes.Eq ident => Data.Functor.Classes.Eq2 (Unison.Syntax.Parser.Doc.Data.Leaf ident)
instance (GHC.Show.Show ident, GHC.Show.Show code) => Data.Functor.Classes.Show1 (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance (GHC.Classes.Ord ident, GHC.Classes.Ord code) => Data.Functor.Classes.Ord1 (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance (GHC.Classes.Eq ident, GHC.Classes.Eq code) => Data.Functor.Classes.Eq1 (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance Data.Traversable.Traversable (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance GHC.Base.Functor (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance Data.Foldable.Foldable (Unison.Syntax.Parser.Doc.Data.Leaf ident code)
instance (GHC.Show.Show ident, GHC.Show.Show a, GHC.Show.Show code) => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Leaf ident code a)
instance (GHC.Classes.Ord ident, GHC.Classes.Ord a, GHC.Classes.Ord code) => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Leaf ident code a)
instance (GHC.Classes.Eq ident, GHC.Classes.Eq a, GHC.Classes.Eq code) => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Leaf ident code a)
instance Data.Bifunctor.Bifunctor (Unison.Syntax.Parser.Doc.Data.Leaf ident)
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.Group
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.Group
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.Group
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.Group
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.Group
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.Group
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Group a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Group a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Group a)
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.Join
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.Join
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.Join
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.EmbedSignatureLink a)
instance GHC.Show.Show Unison.Syntax.Parser.Doc.Data.Word
instance GHC.Classes.Ord Unison.Syntax.Parser.Doc.Data.Word
instance GHC.Classes.Eq Unison.Syntax.Parser.Doc.Data.Word
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.Join
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.Join
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.Join
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Join a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Join a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Join a)
instance Data.Functor.Classes.Show2 Unison.Syntax.Parser.Doc.Data.SourceElement
instance Data.Functor.Classes.Ord2 Unison.Syntax.Parser.Doc.Data.SourceElement
instance Data.Functor.Classes.Eq2 Unison.Syntax.Parser.Doc.Data.SourceElement
instance GHC.Show.Show ident => Data.Functor.Classes.Show1 (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance GHC.Classes.Ord ident => Data.Functor.Classes.Ord1 (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance GHC.Classes.Eq ident => Data.Functor.Classes.Eq1 (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance Data.Traversable.Traversable (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance GHC.Base.Functor (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance Data.Foldable.Foldable (Unison.Syntax.Parser.Doc.Data.SourceElement ident)
instance (GHC.Show.Show ident, GHC.Show.Show a) => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.SourceElement ident a)
instance (GHC.Classes.Ord ident, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.SourceElement ident a)
instance (GHC.Classes.Eq ident, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.SourceElement ident a)
instance Data.Functor.Classes.Show2 Unison.Syntax.Parser.Doc.Data.EmbedAnnotation
instance Data.Functor.Classes.Ord2 Unison.Syntax.Parser.Doc.Data.EmbedAnnotation
instance Data.Functor.Classes.Eq2 Unison.Syntax.Parser.Doc.Data.EmbedAnnotation
instance GHC.Show.Show ident => Data.Functor.Classes.Show1 (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance GHC.Classes.Ord ident => Data.Functor.Classes.Ord1 (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance GHC.Classes.Eq ident => Data.Functor.Classes.Eq1 (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance Data.Traversable.Traversable (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance GHC.Base.Functor (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance Data.Foldable.Foldable (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident)
instance (GHC.Show.Show ident, GHC.Show.Show a) => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident a)
instance (GHC.Classes.Ord ident, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident a)
instance (GHC.Classes.Eq ident, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.EmbedAnnotation ident a)
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.Transclude
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.Transclude
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.Transclude
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.Transclude
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.Transclude
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.Transclude
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Transclude a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Transclude a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Transclude a)
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.EmbedLink
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.EmbedLink
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.EmbedLink
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.EmbedLink
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.EmbedLink
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.EmbedLink
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.EmbedLink a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.EmbedLink a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.EmbedLink a)
instance GHC.Show.Show code => Data.Functor.Classes.Show2 (Unison.Syntax.Parser.Doc.Data.Top code)
instance GHC.Classes.Ord code => Data.Functor.Classes.Ord2 (Unison.Syntax.Parser.Doc.Data.Top code)
instance GHC.Classes.Eq code => Data.Functor.Classes.Eq2 (Unison.Syntax.Parser.Doc.Data.Top code)
instance (GHC.Show.Show code, GHC.Show.Show leaf) => Data.Functor.Classes.Show1 (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance (GHC.Classes.Ord code, GHC.Classes.Ord leaf) => Data.Functor.Classes.Ord1 (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance (GHC.Classes.Eq code, GHC.Classes.Eq leaf) => Data.Functor.Classes.Eq1 (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.List
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.List
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.List
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.List a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.List a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.List a)
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.Column
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.Column
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.Column
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Column a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Column a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Column a)
instance Data.Traversable.Traversable (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance GHC.Base.Functor (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance Data.Foldable.Foldable (Unison.Syntax.Parser.Doc.Data.Top code leaf)
instance (GHC.Show.Show leaf, GHC.Show.Show a, GHC.Show.Show code) => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Top code leaf a)
instance (GHC.Classes.Ord leaf, GHC.Classes.Ord a, GHC.Classes.Ord code) => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Top code leaf a)
instance (GHC.Classes.Eq leaf, GHC.Classes.Eq a, GHC.Classes.Eq code) => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Top code leaf a)
instance Data.Bifoldable.Bifoldable (Unison.Syntax.Parser.Doc.Data.Top code)
instance Data.Bifunctor.Bifunctor (Unison.Syntax.Parser.Doc.Data.Top code)
instance Data.Bitraversable.Bitraversable (Unison.Syntax.Parser.Doc.Data.Top code)
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.List
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.List
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.List
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.Column
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.Column
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.Column
instance Data.Functor.Classes.Show1 Unison.Syntax.Parser.Doc.Data.Paragraph
instance Data.Functor.Classes.Ord1 Unison.Syntax.Parser.Doc.Data.Paragraph
instance Data.Functor.Classes.Eq1 Unison.Syntax.Parser.Doc.Data.Paragraph
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.UntitledSection
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.UntitledSection
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.UntitledSection
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.UntitledSection a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.UntitledSection a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.UntitledSection a)
instance Data.Traversable.Traversable Unison.Syntax.Parser.Doc.Data.Paragraph
instance GHC.Base.Functor Unison.Syntax.Parser.Doc.Data.Paragraph
instance Data.Foldable.Foldable Unison.Syntax.Parser.Doc.Data.Paragraph
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Parser.Doc.Data.Paragraph a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Unison.Syntax.Parser.Doc.Data.Paragraph a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Unison.Syntax.Parser.Doc.Data.Paragraph a)

module Unison.Syntax.ReservedWords
keywords :: Set Text
typeModifiers :: Set Text
typeOrAbility :: Set Text
reservedOperators :: Set Text
delimiters :: Set Char


-- | Utilities related to the parsing and printing of name segments using
--   the default syntax.
module Unison.Syntax.NameSegment

-- | Convert a name segment to escaped text, for display purposes.
--   
--   <pre>
--   toEscapedText (unsafeFromText ".~") = "`.~`"
--   </pre>
toEscapedText :: NameSegment -> Text
toEscapedTextBuilder :: NameSegment -> Builder

-- | Parse text as a name segment.
--   
--   <pre>
--   parseText "foo" = Right (NameSegment "foo")
--   parseText ".~" = Left ...
--   parseText "`.~`" = Right (NameSegment ".~")
--   </pre>
parseText :: Text -> Either Text NameSegment

-- | Parse text as a name segment.
unsafeParseText :: Text -> NameSegment
isSymboly :: NameSegment -> Bool
data ParseErr
ReservedOperator :: !Text -> ParseErr
ReservedWord :: !Text -> ParseErr
renderParseErr :: ParseErr -> Text
segmentP :: Monad m => ParsecT (Token ParseErr) [Char] m NameSegment

-- | A symboly name segment parser, which consists only of symboly
--   characters.
--   
--   A symboly name segment can optionally be escaped by surrounding it
--   with backticks, which expands the list of allowed symbols to include
--   these three: . ( )
--   
--   Throws the parsed name segment as an error if it's unescaped and
--   reserved, e.g. "=".
symbolyP :: ParsecT (Token Text) [Char] m NameSegment

-- | A wordy name segment parser, which consists only of wordy characters.
--   
--   Throws the parsed name segment as an error if it's an unescaped
--   keyword, e.g. "match".
wordyP :: ParsecT (Token Text) [Char] m NameSegment
segmentStartChar :: Char -> Bool
symbolyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
wordyIdChar :: Char -> Bool
instance GHC.Classes.Ord Unison.Syntax.NameSegment.ParseErr
instance GHC.Classes.Eq Unison.Syntax.NameSegment.ParseErr


-- | Utilities related to the parsing and printing of names using the
--   default syntax.
module Unison.Syntax.Name

-- | Parse a name from a string literal.
parseText :: Text -> Maybe Name

-- | Parse a name from a string literal.
parseTextEither :: Text -> Either Text Name

-- | Unsafely parse a name from a string literal.
unsafeParseText :: HasCallStack => Text -> Name

-- | Convert a name to a string representation.
toText :: Name -> Text

-- | Unsafely parse a name from a var, by first rendering the var as a
--   string.
--   
--   See <tt>unsafeFromText</tt>.
unsafeParseVar :: Var v => v -> Name

-- | Parse a name from a var, by first rendering the var as a string.
parseVar :: Var v => v -> Maybe Name

-- | Convert a name to a string representation, then parse that as a var.
toVar :: Var v => Name -> v

-- | A name parser.
nameP :: Monad m => ParsecT (Token ParseErr) [Char] m Name

-- | A relative name parser.
relativeNameP :: forall m. Monad m => ParsecT (Token ParseErr) [Char] m Name
isSymboly :: Name -> Bool


-- | This currently contains a mix of general lexing utilities and
--   identifier-y lexers.
module Unison.Syntax.Lexer
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
type Line = Int
type Column = Int
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
[$sel:line:Pos] :: Pos -> {-# UNPACK #-} !Line
[$sel:column:Pos] :: Pos -> {-# UNPACK #-} !Column
touches :: Token a -> Token b -> Bool
wordyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
symbolyIdChar :: Char -> Bool
local :: (MonadParsec e s' m, MonadState s m) => (s -> s) -> m a -> m a
space :: MonadParsec e String m => m ()
lit :: MonadParsec e String m => String -> m String
commitAfter2 :: MonadParsec e s m => m a -> m b -> (a -> b -> m c) -> m c
(<+>) :: (Applicative f, Monoid a) => f a -> f a -> f a
infixl 2 <+>

-- | Like <a>some</a>, but returns an actual <a>NonEmpty</a>.
some' :: MonadParsec e s m => m a -> m (NonEmpty a)

-- | Like <a>someTill</a>, but returns an actual <a>NonEmpty</a>.
someTill' :: MonadParsec e s m => m a -> m end -> m (NonEmpty a)

-- | Like <a>sepBy1</a>, but returns an actual <a>NonEmpty</a>.
sepBy1' :: MonadParsec e s m => m a -> m sep -> m (NonEmpty a)
separated :: MonadParsec e s m => (Token s -> Bool) -> m a -> m a
wordySep :: Char -> Bool
pop :: [a] -> [a]
typeOrAbilityAlt :: Alternative f => (Text -> f a) -> f a
inc :: Pos -> Pos


-- | The parser for Unison’s <tt>Doc</tt> syntax.
--   
--   This is completely independent of the Unison language, and requires a
--   couple parsers to be passed in to then provide a parser for
--   <tt>Doc</tt> applied to any host language.
--   
--   <ul>
--   <li>an identifer parser</li>
--   <li>a code parser (that accepts a termination parser)</li>
--   <li>a termination parser, for this parser to know when to give up</li>
--   </ul>
--   
--   Each of those parsers is expected to satisfy <tt>(<a>Ord</a> e,
--   <a>MonadParsec</a> e <a>String</a> m)</tt>.
module Unison.Syntax.Parser.Doc
type Tree ident code = Cofree (Top code (Leaves ident code)) Ann
type Leaves ident code = Cofree (Leaf ident code) Ann
initialEnv :: ParsingEnv
doc :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m end -> m (UntitledSection (Tree ident code))

-- | This is the actual <tt>Doc</tt> lexer. Unlike <tt>doc2</tt>, it
--   doesn’t do any Unison-side lexing (i.e., it doesn’t know that Unison
--   wraps <tt>Doc</tt> literals in `}}`).
untitledSection :: MonadParsec e String m => m a -> m (UntitledSection a)
sectionElem :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> ReaderT ParsingEnv m (Top code (Leaves ident code) (Tree ident code))
leaf :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Leaf ident code (Leaves ident code))

-- | <pre>
--   ## Section title
--   
--   A paragraph under this section.
--   Part of the same paragraph. Blanklines separate paragraphs.
--   
--   ### A subsection title
--   
--   A paragraph under this subsection.
--   
--   # A section title (not a subsection)
--   </pre>
section :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> ReaderT ParsingEnv m (Top code (Leaves ident code) (Tree ident code))
eval :: MonadParsec e String m => (m () -> m code) -> m (Top code (Leaves ident code) (Tree ident code))
exampleBlock :: MonadParsec e String m => (m () -> m code) -> m (Top code (Leaves ident code) (Tree ident code))
codeBlock :: (Ord e, MonadParsec e String m) => m (Top code (Leaves ident code) (Tree ident code))

-- | Not an actual node, but this pattern is referenced in multiple places
list :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> ReaderT ParsingEnv m (List (Leaves ident code))

-- | FIXME: This should take a <tt><tt>P</tt> a</tt>
bulletedList :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> ReaderT ParsingEnv m (List (Leaves ident code))

-- | FIXME: This should take a <tt><tt>P</tt> a</tt>
numberedList :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> ReaderT ParsingEnv m (List (Leaves ident code))
paragraph :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Paragraph (Leaves ident code))
link :: (Ord e, MonadParsec e String m) => m ident -> m (Leaf ident code a)
namedLink :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Leaf ident code (Leaves ident code))
example :: MonadParsec e String m => (m () -> m code) -> m (Leaf ident code void)
transclude :: MonadParsec e String m => (m () -> m code) -> m (Transclude code)
bold :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Leaf ident code (Leaves ident code))
italic :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Leaf ident code (Leaves ident code))
strikethrough :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> m (Leaf ident code (Leaves ident code))
verbatim :: (Ord e, MonadParsec e String m) => m (Leaf ident code a)
source :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m (Leaf ident code a)
foldedSource :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m (Leaf ident code a)
evalInline :: MonadParsec e String m => (m () -> m code) -> m (Leaf ident code a)
signatures :: (Ord e, MonadParsec e String m) => m ident -> m (Leaf ident code a)
signatureInline :: (Ord e, MonadParsec e String m) => m ident -> m (Leaf ident code a)

-- | FIXME: This should just take a <tt><tt>P</tt> code</tt> and
--   <tt><tt>P</tt> a</tt>.
group :: MonadParsec e s m => m (NonEmpty (Leaves ident code)) -> m (Group (Leaves ident code))
word :: (Ord e, MonadParsec e String m) => m end -> m Word
column' :: (Ord e, MonadParsec e String m) => m ident -> (m () -> m code) -> m () -> Int -> ReaderT ParsingEnv m (Column (Leaves ident code))

-- | Not an actual node, but this pattern is referenced in multiple places
embedLink :: (Ord e, MonadParsec e s m, TraversableStream s) => m ident -> m (EmbedLink ident)
embedSignatureLink :: (Ord e, MonadParsec e String m) => m ident -> m (EmbedSignatureLink ident)

-- | FIXME: This should just take a <tt><tt>P</tt> a</tt>
join :: MonadParsec e s m => m (NonEmpty a) -> m (Join a)
instance GHC.Show.Show Unison.Syntax.Parser.Doc.ParsingEnv


-- | Utilities related to the parsing and printing of short hashes using
--   the default syntax.
module Unison.Syntax.ShortHash

-- | A short hash parser.
--   
--   Throws the parsed hash as an error if it's invalid.
shortHashP :: ParsecT (Token Text) [Char] m ShortHash


-- | Syntax-related combinators for HashQualified' (to/from string types).
module Unison.Syntax.HashQualifiedPrime
parseText :: Text -> Maybe (HashQualified Name)
unsafeParseText :: HasCallStack => Text -> HashQualified Name
toText :: HashQualified Name -> Text

-- | A hash-qualified parser.
hashQualifiedP :: Monad m => ParsecT (Token Text) [Char] m name -> ParsecT (Token Text) [Char] m (HashQualified name)

module Unison.Syntax.Lexer.Unison
data Token a
Token :: a -> !Pos -> !Pos -> Token a
[$sel:payload:Token] :: Token a -> a
[$sel:start:Token] :: Token a -> !Pos
[$sel:end:Token] :: Token a -> !Pos
type Line = Int
type Column = Int
data Err
ReservedWordyId :: String -> Err
InvalidSymbolyId :: String -> Err
ReservedSymbolyId :: String -> Err
InvalidShortHash :: String -> Err
InvalidBytesLiteral :: String -> Err
InvalidHexLiteral :: Err
InvalidOctalLiteral :: Err
InvalidBinaryLiteral :: Err
Both :: Err -> Err -> Err
MissingFractional :: String -> Err
MissingExponent :: String -> Err
UnknownLexeme :: Err
TextLiteralMissingClosingQuote :: String -> Err
InvalidEscapeCharacter :: Char -> Err
LayoutError :: Err
CloseWithoutMatchingOpen :: String -> String -> Err
UnexpectedDelimiter :: String -> Err
UnexpectedTokens :: String -> Err
data Pos
Pos :: {-# UNPACK #-} !Line -> {-# UNPACK #-} !Column -> Pos
[$sel:line:Pos] :: Pos -> {-# UNPACK #-} !Line
[$sel:column:Pos] :: Pos -> {-# UNPACK #-} !Column
data Lexeme

-- | start of a block
Open :: String -> Lexeme

-- | separator between elements of a block
Semi :: IsVirtual -> Lexeme

-- | end of a block
Close :: Lexeme

-- | reserved tokens such as `{`, `(`, `type`, `of`, etc
Reserved :: String -> Lexeme

-- | text literals, `"foo bar"`
Textual :: String -> Lexeme

-- | character literals, `?X`
Character :: Char -> Lexeme

-- | a (non-infix) identifier. invariant: last segment is wordy
WordyId :: HashQualified Name -> Lexeme

-- | an infix identifier. invariant: last segment is symboly
SymbolyId :: HashQualified Name -> Lexeme

-- | numeric literals, left unparsed
Numeric :: String -> Lexeme

-- | bytes literals
Bytes :: Bytes -> Lexeme

-- | hash literals
Hash :: ShortHash -> Lexeme
Err :: Err -> Lexeme
Doc :: UntitledSection (Tree (Token (ReferenceType, HashQualified Name)) [Token Lexeme]) -> Lexeme
lexer :: String -> String -> [Token Lexeme]

-- | This turns the lexeme stream into a tree, reordering some lexeme
--   subsequences.
preParse :: [Token Lexeme] -> BlockTree (Token Lexeme)
escapeChars :: [(Char, Char)]
debugFilePreParse :: FilePath -> IO ()
debugPreParse :: BlockTree (Token Lexeme) -> String
debugPreParse' :: String -> String
showEscapeChar :: Char -> Maybe Char
touches :: Token a -> Token b -> Bool
typeOrTerm :: Monad m => ParsecT (Token Err) String m (ReferenceType, HashQualified Name)
wordyIdChar :: Char -> Bool
wordyIdStartChar :: Char -> Bool
symbolyIdChar :: Char -> Bool
formatTrivialError :: Set String -> Set String -> [Char]
displayLexeme :: Lexeme -> String
instance GHC.Show.Show Unison.Syntax.Lexer.Unison.ParsingEnv
instance GHC.Show.Show Unison.Syntax.Lexer.Unison.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Unison.Err
instance GHC.Classes.Eq Unison.Syntax.Lexer.Unison.Err
instance GHC.Classes.Ord Unison.Syntax.Lexer.Unison.Lexeme
instance GHC.Show.Show Unison.Syntax.Lexer.Unison.Lexeme
instance GHC.Classes.Eq Unison.Syntax.Lexer.Unison.Lexeme
instance Data.Traversable.Traversable Unison.Syntax.Lexer.Unison.BlockTree
instance Data.Foldable.Foldable Unison.Syntax.Lexer.Unison.BlockTree
instance GHC.Base.Functor Unison.Syntax.Lexer.Unison.BlockTree
instance GHC.Show.Show a => GHC.Show.Show (Unison.Syntax.Lexer.Unison.BlockTree a)
instance Data.Functor.Classes.Show1 Unison.Syntax.Lexer.Unison.BlockTree
instance Text.Megaparsec.Stream.VisualStream [Unison.Syntax.Lexer.Token.Token Unison.Syntax.Lexer.Unison.Lexeme]
instance Text.Megaparsec.Error.ShowErrorComponent (Unison.Syntax.Lexer.Token.Token Unison.Syntax.Lexer.Unison.Err)


-- | Syntax-related combinators for HashQualified (to/from string types).
module Unison.Syntax.HashQualified
parseText :: Text -> Maybe (HashQualified Name)
parseTextWith :: Parsec (Token Text) [Char] name -> Text -> Maybe (HashQualified name)
unsafeParseText :: Text -> HashQualified Name
toText :: HashQualified Name -> Text
unsafeFromVar :: Var v => v -> HashQualified Name
toVar :: Var v => HashQualified Name -> v

-- | A hash-qualified parser.
hashQualifiedP :: Monad m => ParsecT (Token Text) [Char] m name -> ParsecT (Token Text) [Char] m (HashQualified name)

module Unison.Syntax.Var
namespaced :: Var v => NonEmpty v -> v

-- | Like <a>namespaced</a>, but for the common case that you have two vars
--   to join.
namespaced2 :: Var v => v -> v -> v

module Unison.UnisonFile.Error
data Error v a
UnknownType :: v -> a -> Error v a
DupDataAndAbility :: v -> a -> a -> Error v a
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Ord v, GHC.Classes.Ord a) => GHC.Classes.Ord (Unison.UnisonFile.Error.Error v a)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a) => GHC.Classes.Eq (Unison.UnisonFile.Error.Error v a)

module Unison.Syntax.Parser
class Annotated a
ann :: Annotated a => a -> Ann
type Err v = ParseError Input (Error v)
data Error v
SignatureNeedsAccompanyingBody :: Token v -> Error v
DisallowedAbsoluteName :: Token Name -> Error v
EmptyBlock :: Token String -> Error v
UnknownTerm :: Token (HashQualified Name) -> Set Referent -> Error v
UnknownType :: Token (HashQualified Name) -> Set Reference -> Error v
UnknownId :: Token (HashQualified Name) -> Set Referent -> Set Reference -> Error v
ExpectedBlockOpen :: String -> Token Lexeme -> Error v
EmptyWatch :: Ann -> Error v
UseInvalidPrefixSuffix :: Either (Token Name) (Token Name) -> Maybe [Token Name] -> Error v
UseEmpty :: Token String -> Error v
DidntExpectExpression :: Token Lexeme -> Maybe (Token Lexeme) -> Error v
TypeDeclarationErrors :: [Error v Ann] -> Error v

-- | MissingTypeModifier (type|ability) name
MissingTypeModifier :: Token String -> Token v -> Error v

-- | A type was found in a position that requires a term
TypeNotAllowed :: Token (HashQualified Name) -> Error v
ResolutionFailures :: [ResolutionFailure Ann] -> Error v
DuplicateTypeNames :: [(v, [Ann])] -> Error v
DuplicateTermNames :: [(v, [Ann])] -> Error v

-- | PatternArityMismatch expectedArity actualArity location
PatternArityMismatch :: Int -> Int -> Ann -> Error v
FloatPattern :: Ann -> Error v
newtype Input
Input :: [Token Lexeme] -> Input
[$sel:inputStream:Input] :: Input -> [Token Lexeme]
type P v m = ParsecT (Error v) Input (ReaderT (ParsingEnv m) m)
data ParsingEnv (m :: Type -> Type)
ParsingEnv :: UniqueName -> (Name -> m (Maybe Text)) -> Names -> Maybe Name -> Names -> ParsingEnv (m :: Type -> Type)
[$sel:uniqueNames:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> UniqueName

-- | Return a GUID to reuse for a unique type of the given name, if any.
--   
--   This callback is called for every `unique type` declaration that does
--   not explicitly specify a GUID.
--   
--   The name (e.g. <tt>Foo</tt> in `unique type Foo`) is passed in, and if
--   the function returns a Just, that GUID is used; otherwise, a random
--   one is generated from <a>$sel:uniqueNames:ParsingEnv</a>.
[$sel:uniqueTypeGuid:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Name -> m (Maybe Text)
[$sel:names:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Names
[$sel:maybeNamespace:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Maybe Name
[$sel:localNamespacePrefixedTypesAndConstructors:ParsingEnv] :: ParsingEnv (m :: Type -> Type) -> Names
newtype UniqueName
UniqueName :: (Pos -> Int -> Maybe Text) -> UniqueName
anyToken :: Ord v => P v m (Token Lexeme)

-- | Parse a placeholder or typed hole
blank :: Ord v => P v m (Token NameSegment)
bytesToken :: Ord v => P v m (Token Bytes)

-- | Parse <tt>p</tt> 1+ times, combining with <tt>op</tt>
chainl1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
chainr1 :: Ord v => P v m a -> P v m (a -> a -> a) -> P v m a
chainl1Accum :: (Stream u, Ord s) => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m (a, [a -> a])
character :: Ord v => P v m (Token Char)

-- | Consume the end of a block
closeBlock :: Ord v => P v m (Token ())

-- | With layout, blocks might “close” without an explicit outdent (e.g.,
--   not even a newline at the end of a <a>Transclude</a>). This allows
--   those blocks to be closed by EOF.
optionalCloseBlock :: Ord v => P v m (Token ())
doc :: Ord v => P v m (Token (UntitledSection (Tree (Token (ReferenceType, HashQualified Name)) [Token Lexeme])))
failCommitted :: Ord v => Error v -> P v m x

-- | If <tt>p</tt> would succeed, this fails uncommitted. Otherwise,
--   <tt>failIfOk</tt> used to produce the output
failureIf :: Ord v => P v m (P v m b) -> P v m a -> P v m b
hqInfixId :: Ord v => P v m (Token (HashQualified Name))
hqPrefixId :: Ord v => P v m (Token (HashQualified Name))

-- | The <a>+</a> in: use Foo.bar + as a Name
importSymbolyId :: Ord v => P v m (Token Name)

-- | Parse a wordyId as a Name, rejecting any hash
importWordyId :: Ord v => P v m (Token Name)
label :: (Ord v, Show a) => String -> P v m a -> P v m a

-- | Match a particular lexeme exactly, and consume it.
matchToken :: Ord v => Lexeme -> P v m (Token Lexeme)
mkAnn :: (Annotated a, Annotated b) => a -> b -> Ann
numeric :: Ord v => P v m (Token String)

-- | Consume a block opening and return the string that opens the block.
openBlock :: Ord v => P v m (Token String)
openBlockWith :: Ord v => String -> P v m (Token ())
peekAny :: Ord v => P v m (Token Lexeme)

-- | Gives this var an id based on its position - a useful trick to obtain
--   a variable whose id won't match any other id in the file
--   `positionalVar a Var.missingResult`
positionalVar :: (Annotated a, Var v) => a -> v -> v

-- | Parse a prefix identifier e.g. Foo or (+), discarding any hash
prefixDefinitionName :: Var v => P v m (Token v)

-- | Parse a prefix identifier e.g. Foo or (+), rejecting any hash This is
--   useful for term declarations, where type signatures and term names
--   should not have hashes.
prefixTermName :: Var v => P v m (Token v)

-- | Virtual pattern match on a lexeme.
queryToken :: Ord v => (Lexeme -> Maybe a) -> P v m (Token a)

-- | Parse a reserved word
reserved :: Ord v => String -> P v m (Token String)
root :: Ord v => P v m a -> P v m a
rootFile :: Ord v => P v m a -> P v m a
run' :: (Monad m, Ord v) => P v m a -> String -> String -> ParsingEnv m -> m (Either (Err v) a)
run :: (Monad m, Ord v) => P v m a -> String -> ParsingEnv m -> m (Either (Err v) a)

-- | Consume a virtual semicolon
semi :: Ord v => P v m (Token ())
seq :: Ord v => (Ann -> [a] -> a) -> P v m a -> P v m a
seq' :: Ord v => String -> (Ann -> [a] -> b) -> P v m a -> P v m b
sepBy :: Ord v => P v m a -> P v m b -> P v m [b]
sepBy1 :: Ord v => P v m a -> P v m b -> P v m [b]
string :: Ord v => P v m (Token Text)

-- | Parse a symboly ID like &gt;&gt;= or &amp;&amp;, discarding any hash
symbolyDefinitionName :: Var v => P v m (Token v)
tok :: (Ann -> a -> b) -> Token a -> b
tokenToPair :: Token a -> (Ann, a)

-- | Parses a tuple of <tt>a</tt>s, or a single parenthesized <tt>a</tt>
--   
--   returns the result of combining elements with <tt>pair</tt>, alongside
--   the annotation containing the full parenthesized expression.
tupleOrParenthesized :: Ord v => P v m a -> (Ann -> a) -> (a -> a -> a) -> P v m (Ann, a)
uniqueBase32Namegen :: forall gen. DRG gen => gen -> UniqueName
uniqueName :: (Monad m, Var v) => Int -> P v m Text

-- | Parse a wordy identifier e.g. Foo, discarding any hash
wordyDefinitionName :: Var v => P v m (Token v)
wordyPatternName :: Var v => P v m (Token v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Syntax.Parser.Error v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Syntax.Parser.Error v)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Syntax.Parser.Error v)
instance Text.Megaparsec.Stream.VisualStream Unison.Syntax.Parser.Input
instance Text.Megaparsec.Stream.Stream Unison.Syntax.Parser.Input
instance GHC.Show.Show Unison.Syntax.Parser.Input
instance GHC.Classes.Ord Unison.Syntax.Parser.Input
instance GHC.Classes.Eq Unison.Syntax.Parser.Input
instance GHC.Base.Semigroup Unison.Syntax.Parser.UniqueName
instance GHC.Base.Monoid Unison.Syntax.Parser.UniqueName
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated (U.Core.ABT.Term f v a)
instance Unison.Parser.Ann.Annotated a => Unison.Parser.Ann.Annotated (Unison.Pattern.Pattern a)
instance (Unison.Parser.Ann.Annotated a, Unison.Parser.Ann.Annotated b) => Unison.Parser.Ann.Annotated (Unison.Term.MatchCase a b)
