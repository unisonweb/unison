-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generically derive traversals, lenses and prisms.
--   
--   This library uses GHC.Generics to derive efficient optics (traversals,
--   lenses and prisms) for algebraic data types in a type-directed way,
--   with a focus on good type inference and error messages when possible.
--   
--   This package is the shared internal logic of the
--   <tt><a>generic-lens</a></tt> and <tt><a>generic-optics</a></tt>
--   libraries.
@package generic-lens-core
@version 2.2.1.0

module Data.Generics.Internal.Errors
type family NoGeneric (a :: Type) (ctxt :: [ErrorMessage]) :: Constraint
type family Defined (break :: Type -> Type) (err :: Constraint) (a :: k) :: k
type family Defined_list (break :: [*]) (err :: Constraint) (a :: k) :: k
type family QuoteType (typ :: k) :: ErrorMessage
type family PrettyError (ctxt :: [ErrorMessage]) :: k

module Data.Generics.Internal.Families.Changing
type Indexed t = Indexed' t 0
type family Infer (s :: *) (a' :: *) (b :: *) :: *
data PTag
PTag :: PTag
type family P :: Nat -> k -> PTag -> k
type family LookupParam (a :: k) (p :: Nat) :: Maybe Nat
type family ArgAt (t :: k) (n :: Nat) :: j
type family ArgCount (t :: k) :: Nat

-- | Ensure that the types <tt>a</tt> and <tt>b</tt> are both applications
--   of the same constructor. The arguments may be different.
class UnifyHead (a :: k) (b :: k)
instance forall k1 k2 (gb :: k1) (g :: k2 -> k1) (b :: k2) (f :: k2 -> k1) (a :: k2). (gb GHC.Types.~ g b, Data.Generics.Internal.Families.Changing.UnifyHead f g) => Data.Generics.Internal.Families.Changing.UnifyHead (f a) gb
instance forall k (a :: k) (b :: k). (a GHC.Types.~ b) => Data.Generics.Internal.Families.Changing.UnifyHead a b

module Data.Generics.Internal.Void
data Void
data Void1 a
data Void2 a b

module Data.Generics.Internal.Wrapped
type Context s t a b = (Generic s, Generic t, GWrapped (Rep s) (Rep t) a b, UnifyHead s t, UnifyHead t s, ErrorUnlessOnlyOne s (Rep s))
derived :: Context s t a b => Iso s t a b
instance Data.Generics.Internal.Wrapped.GWrapped s t a b => Data.Generics.Internal.Wrapped.GWrapped (GHC.Generics.M1 i k s) (GHC.Generics.M1 i k t) a b
instance (a GHC.Types.~ c, b GHC.Types.~ d) => Data.Generics.Internal.Wrapped.GWrapped (GHC.Generics.K1 i a) (GHC.Generics.K1 i b) c d


-- | Derive record field getters and setters generically.
module Data.Generics.Product.Internal.GLens
class GLens (pred :: Pred) (s :: Type -> Type) (t :: Type -> Type) a b | s pred -> a, t pred -> b
glens :: GLens pred s t a b => Lens (s x) (t x) a b
type GLens' pred s a = GLens pred s s a a
type TyFun a b = a -> b -> Type
type family Eval (f :: TyFun a b) (x :: a) :: b
instance Data.Generics.Product.Internal.GLens.GProductLens (Data.Generics.Product.Internal.GLens.Eval pred l) pred l r l' r' a b => Data.Generics.Product.Internal.GLens.GLens pred (l GHC.Generics.:*: r) (l' GHC.Generics.:*: r') a b
instance Data.Generics.Product.Internal.GLens.GLens pred l l' a b => Data.Generics.Product.Internal.GLens.GProductLens ('GHC.Maybe.Just x) pred l r l' r a b
instance Data.Generics.Product.Internal.GLens.GLens pred r r' a b => Data.Generics.Product.Internal.GLens.GProductLens 'GHC.Maybe.Nothing pred l r l r' a b
instance (Data.Generics.Product.Internal.GLens.GLens pred l l' a b, Data.Generics.Product.Internal.GLens.GLens pred r r' a b) => Data.Generics.Product.Internal.GLens.GLens pred (l GHC.Generics.:+: r) (l' GHC.Generics.:+: r') a b
instance Data.Generics.Product.Internal.GLens.GLens pred (GHC.Generics.K1 r a) (GHC.Generics.K1 r b) a b
instance Data.Generics.Product.Internal.GLens.GLens pred f g a b => Data.Generics.Product.Internal.GLens.GLens pred (GHC.Generics.M1 m meta f) (GHC.Generics.M1 m meta g) a b


-- | Derive an isomorphism between a product type and a flat HList.
module Data.Generics.Product.Internal.HList
class GIsList (f :: Type -> Type) (g :: Type -> Type) (as :: [Type]) (bs :: [Type]) | f -> as, g -> bs, bs f -> g, as g -> f
glist :: GIsList f g as bs => Iso (f x) (g x) (HList as) (HList bs)
class IndexList (i :: Nat) as bs a b | i as -> a, i bs -> b, i as b -> bs, i bs a -> as
point :: IndexList i as bs a b => Lens (HList as) (HList bs) a b
data HList (as :: [Type])
[Nil] :: HList '[]
[:>] :: a -> HList as -> HList (a ': as)
infixr 5 :>
type family (as :: [k]) ++ (bs :: [k]) :: [k]
class Elem (as :: [(k, Type)]) (key :: k) (i :: Nat) a | as key -> i a
class ListTuple (tuple :: Type) (tuple' :: Type) (as :: [Type]) (bs :: [Type]) | as -> tuple, bs -> tuple'
tupled :: ListTuple tuple tuple' as bs => Iso (HList as) (HList bs) tuple tuple'
tupleToList :: ListTuple tuple tuple' as bs => tuple' -> HList bs
listToTuple :: ListTuple tuple tuple' as bs => HList as -> tuple
type family TupleToList a
instance Data.Generics.Product.Internal.HList.ListTuple () () '[] '[]
instance Data.Generics.Product.Internal.HList.ListTuple a a' '[a] '[a']
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1) (a2, b2) '[a1, b1] '[a2, b2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1) (a2, b2, c2) '[a1, b1, c1] '[a2, b2, c2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1) (a2, b2, c2, d2) '[a1, b1, c1, d1] '[a2, b2, c2, d2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1) (a2, b2, c2, d2, e2) '[a1, b1, c1, d1, e1] '[a2, b2, c2, d2, e2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1) (a2, b2, c2, d2, e2, f2) '[a1, b1, c1, d1, e1, f1] '[a2, b2, c2, d2, e2, f2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1) (a2, b2, c2, d2, e2, f2, g2) '[a1, b1, c1, d1, e1, f1, g1] '[a2, b2, c2, d2, e2, f2, g2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1) (a2, b2, c2, d2, e2, f2, g2, h2) '[a1, b1, c1, d1, e1, f1, g1, h1] '[a2, b2, c2, d2, e2, f2, g2, h2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1) (a2, b2, c2, d2, e2, f2, g2, h2, j2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1, r1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2, r2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1, r1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2, r2]
instance Data.Generics.Product.Internal.HList.ListTuple (a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1) (a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2) '[a1, b1, c1, d1, e1, f1, g1, h1, j1, k1, l1, m1, n1, o1, p1, q1, r1, s1] '[a2, b2, c2, d2, e2, f2, g2, h2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2]
instance (as GHC.Types.~ (a : as'), bs GHC.Types.~ (b : as')) => Data.Generics.Product.Internal.HList.IndexList 0 as bs a b
instance (Data.Generics.Product.Internal.HList.IndexList (n GHC.TypeNats.- 1) as' bs' a b, as GHC.Types.~ (x : as'), bs GHC.Types.~ (x : bs')) => Data.Generics.Product.Internal.HList.IndexList n as bs a b
instance (Data.Generics.Product.Internal.HList.GIsList l l' as as', Data.Generics.Product.Internal.HList.GIsList r r' bs bs', Data.Generics.Product.Internal.HList.Appending as bs cs as' bs' cs', cs GHC.Types.~ (as Data.Generics.Product.Internal.HList.++ bs), cs' GHC.Types.~ (as' Data.Generics.Product.Internal.HList.++ bs')) => Data.Generics.Product.Internal.HList.GIsList (l GHC.Generics.:*: r) (l' GHC.Generics.:*: r') cs cs'
instance Data.Generics.Product.Internal.HList.Appending '[] bs bs '[] bs' bs'
instance Data.Generics.Product.Internal.HList.Appending as bs cs as' bs' cs' => Data.Generics.Product.Internal.HList.Appending (a : as) bs (a : cs) (a' : as') bs' (a' : cs')
instance Data.Generics.Product.Internal.HList.GIsList f g as bs => Data.Generics.Product.Internal.HList.GIsList (GHC.Generics.M1 t meta f) (GHC.Generics.M1 t meta g) as bs
instance Data.Generics.Product.Internal.HList.GIsList (GHC.Generics.Rec0 a) (GHC.Generics.Rec0 b) '[a] '[b]
instance Data.Generics.Product.Internal.HList.GIsList GHC.Generics.U1 GHC.Generics.U1 '[] '[]
instance forall k (pos :: GHC.Num.Natural.Natural) (a :: (k, *)) (xs :: [(k, *)]) (key :: k). (pos GHC.Types.~ 0) => Data.Generics.Product.Internal.HList.Elem (a : xs) key pos a
instance forall k1 k2 (xs :: [(k1, *)]) (key :: k1) (i :: GHC.TypeNats.Nat) (a :: k2) (pos :: GHC.Num.Natural.Natural) (x :: (k1, *)). (Data.Generics.Product.Internal.HList.Elem xs key i a, pos GHC.Types.~ (i GHC.TypeNats.+ 1)) => Data.Generics.Product.Internal.HList.Elem (x : xs) key pos a
instance GHC.Base.Semigroup (Data.Generics.Product.Internal.HList.HList '[])
instance GHC.Base.Monoid (Data.Generics.Product.Internal.HList.HList '[])
instance (GHC.Base.Semigroup a, GHC.Base.Semigroup (Data.Generics.Product.Internal.HList.HList as)) => GHC.Base.Semigroup (Data.Generics.Product.Internal.HList.HList (a : as))
instance (GHC.Base.Monoid a, GHC.Base.Monoid (Data.Generics.Product.Internal.HList.HList as)) => GHC.Base.Monoid (Data.Generics.Product.Internal.HList.HList (a : as))


module Data.Generics.Internal.Families.Has
type family HasTotalFieldP (field :: Symbol) f :: Maybe Type
type family HasTotalTypeP (typ :: Type) f :: Maybe Type
type family HasTotalPositionP (pos :: Nat) f :: Maybe Type
data Pos (p :: Nat)
type family HasPartialTypeP a f :: Bool
type family HasCtorP (ctor :: Symbol) f :: Bool
type family GTypes (rep :: Type -> Type) :: [Type]


module Data.Generics.Internal.Families.Collect
type family CollectTotalType t f :: TypeStat
type family CollectPartialType t f :: [Symbol]
type family CollectField t f :: TypeStat
type family CollectFieldsOrdered (r :: * -> *) :: [Symbol]
data TypeStat
TypeStat :: [Symbol] -> [Symbol] -> [Symbol] -> TypeStat
[_containsNone] :: TypeStat -> [Symbol]
[_containsMultiple] :: TypeStat -> [Symbol]
[_containsOne] :: TypeStat -> [Symbol]
type family (xs :: [Symbol]) \\ (ys :: [Symbol]) :: [Symbol]
infixr 5 \\


module Data.Generics.Internal.Families
type family ShowSymbols (ctors :: [Symbol]) :: ErrorMessage

module Data.Generics.Product.Internal.Fields
type Context_ field s t a b = (HasTotalFieldP field (Rep s) ~ 'Just a, HasTotalFieldP field (Rep t) ~ 'Just b, UnifyHead s t, UnifyHead t s)
type Context' field s a = (Generic s, ErrorUnless field s (CollectField field (Rep s)), GLens' (HasTotalFieldPSym field) (Rep s) a, Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic lens focusing on the " ':<>: QuoteType field ':<>: 'Text " field of type " ':<>: QuoteType a, 'Text "in " ':<>: QuoteType s]) (() :: Constraint))
type Context0 field s t a b = (Generic s, Generic t, GLens (HasTotalFieldPSym field) (Rep s) (Rep t) a b, ErrorUnless field s (CollectField field (Rep s)), Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic lens focusing on the " ':<>: QuoteType field ':<>: 'Text " field of type " ':<>: QuoteType a, 'Text "in " ':<>: QuoteType s]) (() :: Constraint))
class Context (field :: Symbol) s t a b | s field -> a, t field -> b, s field b -> t, t field a -> s
derived :: forall field s t a b. Context0 field s t a b => Lens s t a b
instance (Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep s) GHC.Types.~ 'GHC.Maybe.Just a, Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep t) GHC.Types.~ 'GHC.Maybe.Just b, Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) GHC.Types.~ 'GHC.Maybe.Just a', Data.Generics.Internal.Families.Has.HasTotalFieldP field (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) GHC.Types.~ 'GHC.Maybe.Just b', t GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer s a' b, s GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer t b' a) => Data.Generics.Product.Internal.Fields.Context field s t a b


-- | Derive positional product type getters and setters generically.
module Data.Generics.Product.Internal.Positions
type x <? y = Not (y <=? x)
infixl 4 <?
type family Size f :: Nat

-- | In-order labeling of the generic tree with the field positions
--   
--   We replace the (K1 R a) nodes with (K1 (Pos n) a), where <tt>n</tt> is
--   the position of the field in question in the data type. This is
--   convenient, because we can reuse all the existing functions as long as
--   they are polymorphic in the first parameter of <a>K1</a>.
type family CRep (a :: Type) :: G
class Context (i :: Nat) s t a b | s i -> a, t i -> b, s i b -> t, t i a -> s
type Context_ i s t a b = (ErrorUnless i s (0 <? i && i <=? Size (Rep s)), UnifyHead s t, UnifyHead t s)
type Context' (i :: Nat) s a = (Generic s, ErrorUnless i s (0 <? i && i <=? Size (Rep s)), Coercible (Rep s) (CRep s), GLens' (HasTotalPositionPSym i) (CRep s) a, Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic lens focusing on the field at", 'Text "position " ':<>: QuoteType i ':<>: 'Text " of type " ':<>: QuoteType a ':<>: 'Text " in " ':<>: QuoteType s]) (() :: Constraint))
type Context0 i s t a b = (Generic s, Generic t, GLens (HasTotalPositionPSym i) (CRep s) (CRep t) a b, Coercible (CRep s) (Rep s), Coercible (CRep t) (Rep t), Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic lens focusing on the field at", 'Text "position " ':<>: QuoteType i ':<>: 'Text " of type " ':<>: QuoteType a ':<>: 'Text " in " ':<>: QuoteType s]) (() :: Constraint))
derived0 :: forall i s t a b. Context0 i s t a b => Lens s t a b
derived' :: forall i s a. Context' i s a => Lens s s a a
instance (Data.Generics.Product.Internal.Positions.ErrorUnless i s ((0 Data.Generics.Product.Internal.Positions.<? i) Data.Type.Bool.&& (i Data.Type.Ord.<=? Data.Generics.Product.Internal.Positions.Size (GHC.Generics.Rep s))), Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep s) GHC.Types.~ 'GHC.Maybe.Just a, Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep t) GHC.Types.~ 'GHC.Maybe.Just b, Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep (Data.Generics.Internal.Families.Changing.Indexed s)) GHC.Types.~ 'GHC.Maybe.Just a', Data.Generics.Internal.Families.Has.HasTotalPositionP i (Data.Generics.Product.Internal.Positions.CRep (Data.Generics.Internal.Families.Changing.Indexed t)) GHC.Types.~ 'GHC.Maybe.Just b', t GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer s a' b, s GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer t b' a) => Data.Generics.Product.Internal.Positions.Context i s t a b


-- | Structural subtype relationships between product types.
module Data.Generics.Product.Internal.Subtype
type Context a b = (Generic a, Generic b, GSmash (Rep a) (Rep b), GUpcast (Rep a) (Rep b), CustomError a b)
class GSmash sub sup
gsmash :: GSmash sub sup => sup p -> sub p -> sub p
class GUpcast (sub :: Type -> Type) (sup :: Type -> Type)
gupcast :: GUpcast sub sup => sub p -> sup p
instance Data.Generics.Product.Internal.GLens.GLens' (Data.Generics.Product.Internal.Subtype.HasTotalFieldPSym field) sub t => Data.Generics.Product.Internal.Subtype.GUpcast sub (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) p f b) (GHC.Generics.Rec0 t))
instance Data.Generics.Product.Internal.GLens.GLens' (Data.Generics.Product.Internal.Subtype.HasTotalFieldPSym field) sup t => Data.Generics.Product.Internal.Subtype.GSmashLeaf (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) p f b) (GHC.Generics.Rec0 t)) sup ('GHC.Maybe.Just t)
instance forall k (leaf :: k -> *) (field :: GHC.Types.Symbol) (p :: GHC.Generics.SourceUnpackedness) (f :: GHC.Generics.SourceStrictness) (b :: GHC.Generics.DecidedStrictness) (t :: k -> *) (sup :: k -> *). (leaf GHC.Types.~ GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) p f b) t, Data.Generics.Product.Internal.Subtype.GSmashLeaf leaf sup (Data.Generics.Internal.Families.Has.HasTotalFieldP field sup)) => Data.Generics.Product.Internal.Subtype.GSmash (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) p f b) t) sup
instance forall k (field :: GHC.Types.Symbol) (p :: GHC.Generics.SourceUnpackedness) (f :: GHC.Generics.SourceStrictness) (b :: GHC.Generics.DecidedStrictness) t (sup :: k -> *). Data.Generics.Product.Internal.Subtype.GSmashLeaf (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) p f b) (GHC.Generics.Rec0 t)) sup 'GHC.Maybe.Nothing
instance forall k (a :: k -> *) (sup :: k -> *) (b :: k -> *). (Data.Generics.Product.Internal.Subtype.GSmash a sup, Data.Generics.Product.Internal.Subtype.GSmash b sup) => Data.Generics.Product.Internal.Subtype.GSmash (a GHC.Generics.:*: b) sup
instance forall k (sub :: k -> *) (sup :: k -> *) (c :: GHC.Generics.Meta). Data.Generics.Product.Internal.Subtype.GSmash sub sup => Data.Generics.Product.Internal.Subtype.GSmash (GHC.Generics.C1 c sub) sup
instance forall k (sub :: k -> *) (sup :: k -> *) (c :: GHC.Generics.Meta). Data.Generics.Product.Internal.Subtype.GSmash sub sup => Data.Generics.Product.Internal.Subtype.GSmash (GHC.Generics.D1 c sub) sup
instance (Data.Generics.Product.Internal.Subtype.GUpcast sub a, Data.Generics.Product.Internal.Subtype.GUpcast sub b) => Data.Generics.Product.Internal.Subtype.GUpcast sub (a GHC.Generics.:*: b)
instance Data.Generics.Product.Internal.Subtype.GUpcast sub sup => Data.Generics.Product.Internal.Subtype.GUpcast sub (GHC.Generics.C1 c sup)
instance Data.Generics.Product.Internal.Subtype.GUpcast sub sup => Data.Generics.Product.Internal.Subtype.GUpcast sub (GHC.Generics.D1 c sup)


-- | The library internals are exposed through this module. Please keep in
--   mind that everything here is subject to change irrespective of the the
--   version numbers.
module Data.GenericLens.Internal
data family Param :: Nat -> j -> k
newtype Rec (p :: Type) a x
Rec :: K1 R a x -> Rec (p :: Type) a x
[unRec] :: Rec (p :: Type) a x -> K1 R a x
class (Coercible (Rep a) (RepN a), Generic a) => GenericN (a :: Type) where {
    type RepN (a :: Type) :: Type -> Type;
    type RepN a = Rep (Indexed a 0);
}
toN :: GenericN a => RepN a x -> a
fromN :: GenericN a => a -> RepN a x
type Iso s t a b = forall p i. (Profunctor p) => p i a b -> p i s t
type Iso' s a = Iso s s a a

-- | A type and its generic representation are isomorphic
repIso :: (Generic a, Generic b) => Iso a b (Rep a x) (Rep b x)

-- | <a>M1</a> is just a wrapper around `f p` mIso :: Iso' (M1 i c f p) (f
--   p)
mIso :: Iso (M1 i c f p) (M1 i c g p) (f p) (g p)
kIso :: Iso (K1 r a p) (K1 r b p) a b
recIso :: Iso (Rec r a p) (Rec r b p) a b
sumIso :: Iso ((a :+: b) x) ((a' :+: b') x) (Either (a x) (b x)) (Either (a' x) (b' x))
prodIso :: Iso ((a :*: b) x) ((a' :*: b') x) (a x, b x) (a' x, b' x)
assoc3 :: Iso ((a, b), c) ((a', b'), c') (a, (b, c)) (a', (b', c'))
fromIso :: Iso s t a b -> Iso b a t s
iso :: (s -> a) -> (b -> t) -> Iso s t a b
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
pairing :: Iso s t a b -> Iso s' t' a' b' -> Iso (s, s') (t, t') (a, a') (b, b')
type Lens s t a b = forall p i. Strong p => p i a b -> p i s t
type LensLike p s t a b = p a b -> p s t
ravel :: (ALens a b i a b -> ALens a b i s t) -> Lens s t a b

-- | Setting
set :: ((a -> b) -> s -> t) -> (s, b) -> t
view :: Lens s s a a -> s -> a
withLensPrim :: Lens s t a b -> (forall c. (s -> (c, a)) -> ((c, b) -> t) -> r) -> r
idLens :: ALens a b i a b

-- | Lens focusing on the first element of a product
first :: Lens ((a :*: b) x) ((a' :*: b) x) (a x) (a' x)

-- | Lens focusing on the second element of a product
second :: Lens ((a :*: b) x) ((a :*: b') x) (b x) (b' x)
fork :: (a -> b) -> (a -> c) -> a -> (b, c)
data Coyoneda f b
Coyoneda :: (a -> b) -> f a -> Coyoneda f b
inj :: Functor f => Coyoneda f a -> f a
proj :: Functor f => f a -> Coyoneda f a
(??) :: Functor f => f (a -> b) -> a -> f b
assoc3L :: Lens ((a, b), c) ((a', b'), c') (a, (b, c)) (a', (b', c'))
stron :: (Either s s', b) -> Either (s, b) (s', b)
choosing :: forall s t a b s' t'. Lens s t a b -> Lens s' t' a b -> Lens (Either s s') (Either t t') a b
lens :: (s -> (c, a)) -> ((c, b) -> t) -> Lens s t a b
data ALens a b i s t
ALens :: (s -> (c, a)) -> ((c, b) -> t) -> ALens a b i s t
swap :: (a, b) -> (b, a)
type APrism i s t a b = Market a b i a b -> Market a b i s t
type Prism s t a b = forall p i. (Choice p) => p i a b -> p i s t
type Prism' s a = forall p i. (Choice p) => p i a a -> p i s s
left :: Prism ((a :+: c) x) ((b :+: c) x) (a x) (b x)
right :: Prism ((a :+: b) x) ((a :+: c) x) (b x) (c x)
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
_Left :: Prism (Either a c) (Either b c) a b
_Right :: Prism (Either c a) (Either c b) a b
prismPRavel :: APrism i s t a b -> Prism s t a b
build :: (Tagged i b b -> Tagged i t t) -> b -> t
match :: Prism s t a b -> s -> Either t a
without' :: Prism s t a b -> Prism s t c d -> Prism s t (Either a c) (Either b d)
withPrism :: APrism i s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
prism2prismp :: Market a b i s t -> Prism s t a b
idPrism :: Market a b i a b
gsum :: (a x -> c) -> (b x -> c) -> (a :+: b) x -> c

module Data.Generics.Product.Internal.Typed
type Context a s = (Generic s, ErrorUnlessOne a s (CollectTotalType a (Rep s)), Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic lens focusing on a field of type " ':<>: QuoteType a]) (() :: Constraint), GLens (HasTotalTypePSym a) (Rep s) (Rep s) a a)
derived :: forall a s. Context a s => Lens s s a a

module Data.Generics.Product.Internal.Types

-- | The children of a type are the types of its fields. The
--   <a>Children</a> type family maps a type <tt>a</tt> to its set of
--   children.
--   
--   This type family is parameterized by a symbol <tt>ch</tt> (that can be
--   declared as an empty data type). The symbol <a>ChGeneric</a> provides
--   a default definition. You can create new symbols to override the set
--   of children of abstract, non-generic types.
--   
--   The following example declares a <tt>Custom</tt> symbol to redefine
--   <a>Children</a> for some abstract types from the <tt>time</tt>
--   library.
--   
--   <pre>
--   data Custom
--   type instance <a>Children</a> Custom a = ChildrenCustom a
--   
--   type family ChildrenCustom (a :: Type) where
--     ChildrenCustom DiffTime        = '[]
--     ChildrenCustom NominalDiffTime = '[]
--     -- Add more custom mappings here.
--   
--     ChildrenCustom a = Children ChGeneric a
--   </pre>
--   
--   To use this definition, replace <tt>types</tt> with
--   <tt><tt>typesUsing</tt> @Custom</tt>.
type family Children (ch :: Type) (a :: Type) :: [Type]

-- | The default definition of <a>Children</a>. Primitive types from core
--   libraries have no children, and other types are assumed to be
--   <a>Generic</a>.
data ChGeneric
type family ChildrenDefault (a :: Type) :: [Type]
type family ChildrenGeneric (f :: k -> Type) (cs :: [Type]) :: [Type]
type Interesting (ch :: Type) (a :: Type) (t :: Type) = Defined_list (Children ch t) (NoChildren ch t) (IsNothing (Interesting' ch a '[t] (Children ch t)))
type family NoChildren (ch :: Type) (a :: Type) :: Constraint
type family Interesting' (ch :: Type) (a :: Type) (seen :: [Type]) (ts :: [Type]) :: Maybe [Type]
type family InterestingUnless (ch :: Type) (a :: Type) (seen :: [Type]) (t :: Type) (alreadySeen :: Bool) :: Maybe [Type]
type family InterestingOr (ch :: Type) (a :: Type) (seen' :: Maybe [Type]) (ts :: [Type]) :: Maybe [Type]
type family Elem a as
type family IsNothing a
class HasTypes s a
types_ :: HasTypes s a => Traversal' s a
data Void

class HasTypesUsing (ch :: Type) s t a b
typesUsing_ :: HasTypesUsing ch s t a b => Traversal s t a b

-- | By adding instances to this class, we can override the default
--   behaviour in an ad-hoc manner. For example:
--   
--   <pre>
--   instance HasTypesCustom Custom Opaque Opaque String String where
--     typesCustom f (Opaque str) = Opaque <a>$</a> f str
--   </pre>
class HasTypesCustom (ch :: Type) s t a b

-- | This function should never be used directly, only to override the
--   default traversal behaviour. To actually use the custom traversal
--   strategy, see <tt>typesUsing</tt>. This is because <tt>typesUsing</tt>
--   does additional optimisations, like ensuring that nodes with no
--   relevant members will not be traversed at runtime.
typesCustom :: HasTypesCustom ch s t a b => Traversal s t a b
class HasTypesOpt (ch :: Type) (p :: Bool) s t a b
typesOpt :: HasTypesOpt ch p s t a b => Traversal s t a b
class GHasTypes ch s t a b
gtypes_ :: GHasTypes ch s t a b => Traversal (s x) (t x) a b
instance (Data.Generics.Product.Internal.Types.GHasTypes ch (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, GHC.Generics.Generic s, GHC.Generics.Generic t, Data.Generics.Internal.Errors.Defined (GHC.Generics.Rep s) (Data.Generics.Internal.Errors.PrettyError '[ 'GHC.TypeError.Text "No instance " 'GHC.TypeError.:<>: Data.Generics.Internal.Errors.QuoteType (Data.Generics.Product.Internal.Types.HasTypesCustom ch s t a b)]) (() :: Constraint)) => Data.Generics.Product.Internal.Types.HasTypesCustom ch s t a b
instance forall k1 k2 (ch :: k1) (l :: k2 -> *) (l' :: k2 -> *) a b (r :: k2 -> *) (r' :: k2 -> *). (Data.Generics.Product.Internal.Types.GHasTypes ch l l' a b, Data.Generics.Product.Internal.Types.GHasTypes ch r r' a b) => Data.Generics.Product.Internal.Types.GHasTypes ch (l GHC.Generics.:*: r) (l' GHC.Generics.:*: r') a b
instance forall k1 k2 (ch :: k1) (l :: k2 -> *) (l' :: k2 -> *) a b (r :: k2 -> *) (r' :: k2 -> *). (Data.Generics.Product.Internal.Types.GHasTypes ch l l' a b, Data.Generics.Product.Internal.Types.GHasTypes ch r r' a b) => Data.Generics.Product.Internal.Types.GHasTypes ch (l GHC.Generics.:+: r) (l' GHC.Generics.:+: r') a b
instance forall k1 k2 (ch :: k1) (s :: k2 -> *) (t :: k2 -> *) a b m (meta :: GHC.Generics.Meta). Data.Generics.Product.Internal.Types.GHasTypes ch s t a b => Data.Generics.Product.Internal.Types.GHasTypes ch (GHC.Generics.M1 m meta s) (GHC.Generics.M1 m meta t) a b
instance Data.Generics.Product.Internal.Types.HasTypesUsing ch s t a b => Data.Generics.Product.Internal.Types.GHasTypes ch (GHC.Generics.Rec0 s) (GHC.Generics.Rec0 t) a b
instance Data.Generics.Product.Internal.Types.HasTypes b a => Data.Generics.Product.Internal.Types.GHasTypes Data.Generics.Product.Internal.Types.ChGeneric (GHC.Generics.Rec0 b) (GHC.Generics.Rec0 b) a a
instance forall k1 k2 (ch :: k1) a b. Data.Generics.Product.Internal.Types.GHasTypes ch GHC.Generics.U1 GHC.Generics.U1 a b
instance forall k1 k2 (ch :: k1) a b. Data.Generics.Product.Internal.Types.GHasTypes ch GHC.Generics.V1 GHC.Generics.V1 a b
instance Data.Generics.Product.Internal.Types.HasTypesOpt ch (Data.Generics.Product.Internal.Types.Interesting ch a s) s t a b => Data.Generics.Product.Internal.Types.HasTypesUsing ch s t a b
instance Data.Generics.Product.Internal.Types.HasTypesCustom ch s t a b => Data.Generics.Product.Internal.Types.HasTypesOpt ch 'GHC.Types.True s t a b
instance Data.Generics.Product.Internal.Types.HasTypesOpt ch 'GHC.Types.False s s a b
instance Data.Generics.Product.Internal.Types.HasTypesUsing Data.Generics.Product.Internal.Types.ChGeneric s s a a => Data.Generics.Product.Internal.Types.HasTypes s a
instance Data.Generics.Product.Internal.Types.HasTypesUsing ch Data.Generics.Product.Internal.Types.Void Data.Generics.Product.Internal.Types.Void a b
instance Data.Generics.Product.Internal.Types.HasTypesUsing ch s s Data.Generics.Product.Internal.Types.Void Data.Generics.Product.Internal.Types.Void
instance Data.Generics.Product.Internal.Types.HasTypesUsing ch a b a b
instance Data.Generics.Product.Internal.Types.HasTypes Data.Generics.Product.Internal.Types.Void a
instance Data.Generics.Product.Internal.Types.HasTypes s Data.Generics.Product.Internal.Types.Void

module Data.Generics.Product.Internal.Param
type Context n s t a b = (GenericN s, GenericN t, Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic traversal of the type parameter at position " ':<>: QuoteType n, 'Text "of type " ':<>: QuoteType a ':<>: 'Text " in " ':<>: QuoteType s]) (() :: Constraint), s ~ Infer t (P n b 'PTag) a, t ~ Infer s (P n a 'PTag) b, Error ((ArgCount s) <=? n) n (ArgCount s) s, a ~ ArgAt s n, b ~ ArgAt t n, GHasTypes ChGeneric (RepN s) (RepN t) (Param n a) (Param n b))
derived :: forall n s t a b. Context n s t a b => Traversal s t a b


-- | Derive constructor-name-based prisms generically.
module Data.Generics.Sum.Internal.Constructors

-- | As <tt>AsConstructor</tt> but over generic representations as defined
--   by <a>GHC.Generics</a>.
class GAsConstructor (ctor :: Symbol) s t a b | ctor s -> a, ctor t -> b
_GCtor :: GAsConstructor ctor s t a b => Prism (s x) (t x) a b
type GAsConstructor' ctor s a = GAsConstructor ctor s s a a
type Context' ctor s a = (Context0 ctor s s a a, ErrorUnless ctor s (HasCtorP ctor (Rep s)))
class Context (ctor :: Symbol) s t a b | ctor s -> a, ctor t -> b
class Context_ (ctor :: Symbol) s t a b
type Context0 ctor s t a b = (Generic s, Generic t, GAsConstructor ctor (Rep s) (Rep t) a b, Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic prism focusing on the " ':<>: QuoteType ctor ':<>: 'Text " constructor of type " ':<>: QuoteType a, 'Text "in " ':<>: QuoteType s]) (() :: Constraint))
derived0 :: forall ctor s t a b. Context0 ctor s t a b => Prism s t a b
instance Data.Generics.Sum.Internal.Constructors.GSumAsConstructor ctor (Data.Generics.Internal.Families.Has.HasCtorP ctor l) l r l' r' a b => Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (l GHC.Generics.:+: r) (l' GHC.Generics.:+: r') a b
instance Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor l l' a b => Data.Generics.Sum.Internal.Constructors.GSumAsConstructor ctor 'GHC.Types.True l r l' r a b
instance Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor r r' a b => Data.Generics.Sum.Internal.Constructors.GSumAsConstructor ctor 'GHC.Types.False l r l r' a b
instance (Data.Generics.Sum.Internal.Constructors.ErrorUnless ctor s (Data.Generics.Internal.Families.Has.HasCtorP ctor (GHC.Generics.Rep s)), Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep s) a, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) a', Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, t GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer s a' b, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) b', s GHC.Types.~ Data.Generics.Internal.Families.Changing.Infer t b' a) => Data.Generics.Sum.Internal.Constructors.Context ctor s t a b
instance (Data.Generics.Sum.Internal.Constructors.ErrorUnless ctor s (Data.Generics.Internal.Families.Has.HasCtorP ctor (GHC.Generics.Rep s)), Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep s) a, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed s)) a', Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.Rep s) (GHC.Generics.Rep t) a b, Data.Generics.Sum.Internal.Constructors.GAsConstructor' ctor (GHC.Generics.Rep (Data.Generics.Internal.Families.Changing.Indexed t)) b', Data.Generics.Internal.Families.Changing.UnifyHead s t, Data.Generics.Internal.Families.Changing.UnifyHead t s) => Data.Generics.Sum.Internal.Constructors.Context_ ctor s t a b
instance (Data.Generics.Product.Internal.HList.GIsList f g as bs, Data.Generics.Product.Internal.HList.ListTuple a b as bs) => Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons ctor fixity fields) f) (GHC.Generics.M1 GHC.Generics.C ('GHC.Generics.MetaCons ctor fixity fields) g) a b
instance Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor f f' a b => Data.Generics.Sum.Internal.Constructors.GAsConstructor ctor (GHC.Generics.M1 GHC.Generics.D meta f) (GHC.Generics.M1 GHC.Generics.D meta f') a b


-- | Derive constructor-field-type-based prisms generically.
module Data.Generics.Sum.Internal.Typed
type Context a s = (Generic s, ErrorUnlessOne a s (CollectPartialType (TupleToList a) (Rep s)), GAsType (Rep s) a, Defined (Rep s) (NoGeneric s '[ 'Text "arising from a generic prism focusing on a constructor of type " ':<>: QuoteType a]) (() :: Constraint))
derived :: Context a s => Prism' s a

-- | As <tt>AsType</tt> but over generic representations as defined by
--   <a>GHC.Generics</a>.
class GAsType (f :: Type -> Type) (as :: Type)
_GTyped :: GAsType f as => Prism (f x) (f x) as as
instance Data.Generics.Sum.Internal.Typed.GSumAsType (Data.Generics.Internal.Families.Has.HasPartialTypeP (Data.Generics.Product.Internal.HList.TupleToList a) l) l r a => Data.Generics.Sum.Internal.Typed.GAsType (l GHC.Generics.:+: r) a
instance Data.Generics.Sum.Internal.Typed.GAsType l a => Data.Generics.Sum.Internal.Typed.GSumAsType 'GHC.Types.True l r a
instance Data.Generics.Sum.Internal.Typed.GAsType r a => Data.Generics.Sum.Internal.Typed.GSumAsType 'GHC.Types.False l r a
instance (Data.Generics.Product.Internal.HList.GIsList f f as as, Data.Generics.Product.Internal.HList.ListTuple a a as as) => Data.Generics.Sum.Internal.Typed.GAsType (GHC.Generics.M1 GHC.Generics.C meta f) a
instance Data.Generics.Sum.Internal.Typed.GAsType f a => Data.Generics.Sum.Internal.Typed.GAsType (GHC.Generics.M1 GHC.Generics.D meta f) a


-- | Structural subtype relationships between sum types.
module Data.Generics.Sum.Internal.Subtype
type Context sub sup = (Generic sub, Generic sup, GAsSubtype (Rep sub) (Rep sup))
derived :: Context sub sup => Prism' sup sub
instance (Data.Generics.Product.Internal.HList.GIsList sup sup as as, Data.Generics.Sum.Internal.Subtype.GDowncastC (Data.Generics.Internal.Families.Has.HasPartialTypeP as sub) sub sup) => Data.Generics.Sum.Internal.Subtype.GDowncast sub (GHC.Generics.C1 m sup)
instance forall k (sub :: k -> *) (sup :: k -> *). Data.Generics.Sum.Internal.Subtype.GDowncastC 'GHC.Types.False sub sup
instance (Data.Generics.Sum.Internal.Typed.GAsType sub subl', Data.Generics.Product.Internal.HList.GIsList sup sup subl subl, Data.Generics.Product.Internal.HList.ListTuple subl' subl' subl subl) => Data.Generics.Sum.Internal.Subtype.GDowncastC 'GHC.Types.True sub sup
instance (Data.Generics.Sum.Internal.Subtype.GSplash sub sup, Data.Generics.Sum.Internal.Subtype.GDowncast sub sup) => Data.Generics.Sum.Internal.Subtype.GAsSubtype sub sup
instance forall k (sub :: k -> *) (l :: k -> *) (r :: k -> *). (Data.Generics.Sum.Internal.Subtype.GDowncast sub l, Data.Generics.Sum.Internal.Subtype.GDowncast sub r) => Data.Generics.Sum.Internal.Subtype.GDowncast sub (l GHC.Generics.:+: r)
instance forall k (sub :: k -> *) (sup :: k -> *) (m :: GHC.Generics.Meta). Data.Generics.Sum.Internal.Subtype.GDowncast sub sup => Data.Generics.Sum.Internal.Subtype.GDowncast sub (GHC.Generics.D1 m sup)
instance (Data.Generics.Sum.Internal.Subtype.GSplash a sup, Data.Generics.Sum.Internal.Subtype.GSplash b sup) => Data.Generics.Sum.Internal.Subtype.GSplash (a GHC.Generics.:+: b) sup
instance (Data.Generics.Product.Internal.HList.GIsList subf subf as as, Data.Generics.Product.Internal.HList.ListTuple as' as' as as, Data.Generics.Sum.Internal.Typed.GAsType supf as') => Data.Generics.Sum.Internal.Subtype.GSplash (GHC.Generics.C1 meta subf) supf
instance Data.Generics.Sum.Internal.Subtype.GSplash sub sup => Data.Generics.Sum.Internal.Subtype.GSplash (GHC.Generics.D1 c sub) sup
