-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic derivation of querying functions for servant
--   
--   This library lets you derive automatically Haskell functions that let
--   you query each endpoint of a <a>servant</a> webservice.
--   
--   See <a>the client section of the tutorial</a>.
--   
--   <a>CHANGELOG</a>
@package servant-client
@version 0.20

module Servant.Client.Internal.HttpClient

-- | The environment in which a request is run. The <a>baseUrl</a> and
--   <a>makeClientRequest</a> function are used to create a
--   <tt>http-client</tt> request. Cookies are then added to that request
--   if a <tt>CookieJar</tt> is set on the environment. Finally the request
--   is executed with the <a>manager</a>. The <a>makeClientRequest</a>
--   function can be used to modify the request to execute and set values
--   which are not specified on a <tt>servant</tt> <a>RequestF</a> like
--   <tt>responseTimeout</tt> or <tt>redirectCount</tt>
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> (BaseUrl -> Request -> IO Request) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | this function can be used to customize the creation of
--   <tt>http-client</tt> requests from <tt>servant</tt> requests. Default
--   value: <a>defaultMakeClientRequest</a> Note that: 1.
--   <a>makeClientRequest</a> exists to allow overriding operational
--   semantics e.g. <tt>responseTimeout</tt> per request, If you need
--   global modifications, you should use <tt>managerModifyRequest</tt> 2.
--   the <a>cookieJar</a>, if defined, is being applied after
--   <a>makeClientRequest</a> is called.
[makeClientRequest] :: ClientEnv -> BaseUrl -> Request -> IO Request

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ClientError IO) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ClientError IO) a
runClientM :: ClientM a -> ClientEnv -> IO (Either ClientError a)
performRequest :: Maybe [Status] -> Request -> ClientM Response
mkFailureResponse :: BaseUrl -> Request -> ResponseF ByteString -> ClientError
clientResponseToResponse :: (a -> b) -> Response a -> ResponseF b

-- | Create a <tt>http-client</tt> <a>Request</a> from a <tt>servant</tt>
--   <a>RequestF</a> The <a>host</a>, <a>path</a> and <a>port</a> fields
--   are extracted from the <a>BaseUrl</a> otherwise the body, headers and
--   query string are derived from the <tt>servant</tt> <a>RequestF</a>
defaultMakeClientRequest :: BaseUrl -> Request -> IO Request
catchConnectionError :: IO a -> IO (Either ClientError a)
instance Control.Monad.Catch.MonadMask Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Catch.MonadCatch Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Catch.MonadThrow Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Servant.Client.Internal.HttpClient.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.ClientM
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.ClientM


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
module Servant.Client

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
runClientM :: ClientM a -> ClientEnv -> IO (Either ClientError a)

-- | The environment in which a request is run. The <a>baseUrl</a> and
--   <a>makeClientRequest</a> function are used to create a
--   <tt>http-client</tt> request. Cookies are then added to that request
--   if a <tt>CookieJar</tt> is set on the environment. Finally the request
--   is executed with the <a>manager</a>. The <a>makeClientRequest</a>
--   function can be used to modify the request to execute and set values
--   which are not specified on a <tt>servant</tt> <a>RequestF</a> like
--   <tt>responseTimeout</tt> or <tt>redirectCount</tt>
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> (BaseUrl -> Request -> IO Request) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | this function can be used to customize the creation of
--   <tt>http-client</tt> requests from <tt>servant</tt> requests. Default
--   value: <a>defaultMakeClientRequest</a> Note that: 1.
--   <a>makeClientRequest</a> exists to allow overriding operational
--   semantics e.g. <tt>responseTimeout</tt> per request, If you need
--   global modifications, you should use <tt>managerModifyRequest</tt> 2.
--   the <a>cookieJar</a>, if defined, is being applied after
--   <a>makeClientRequest</a> is called.
[makeClientRequest] :: ClientEnv -> BaseUrl -> Request -> IO Request

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Create a <tt>http-client</tt> <a>Request</a> from a <tt>servant</tt>
--   <a>RequestF</a> The <a>host</a>, <a>path</a> and <a>port</a> fields
--   are extracted from the <a>BaseUrl</a> otherwise the body, headers and
--   query string are derived from the <tt>servant</tt> <a>RequestF</a>
defaultMakeClientRequest :: BaseUrl -> Request -> IO Request

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api

module Servant.Client.Internal.HttpClient.Streaming

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
newtype ClientM a
ClientM :: ReaderT ClientEnv (ExceptT ClientError (Codensity IO)) a -> ClientM a
[unClientM] :: ClientM a -> ReaderT ClientEnv (ExceptT ClientError (Codensity IO)) a

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likelihood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ClientError a)

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
withClientM :: ClientM a -> ClientEnv -> (Either ClientError a -> IO b) -> IO b
performRequest :: Maybe [Status] -> Request -> ClientM Response

-- | TODO: support UVerb (<tt>acceptStatus</tt> argument, like in
--   <a>performRequest</a> above).
performWithStreamingRequest :: Request -> (StreamingResponse -> IO a) -> ClientM a

-- | The environment in which a request is run. The <a>baseUrl</a> and
--   <a>makeClientRequest</a> function are used to create a
--   <tt>http-client</tt> request. Cookies are then added to that request
--   if a <tt>CookieJar</tt> is set on the environment. Finally the request
--   is executed with the <a>manager</a>. The <a>makeClientRequest</a>
--   function can be used to modify the request to execute and set values
--   which are not specified on a <tt>servant</tt> <a>RequestF</a> like
--   <tt>responseTimeout</tt> or <tt>redirectCount</tt>
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> (BaseUrl -> Request -> IO Request) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | this function can be used to customize the creation of
--   <tt>http-client</tt> requests from <tt>servant</tt> requests. Default
--   value: <a>defaultMakeClientRequest</a> Note that: 1.
--   <a>makeClientRequest</a> exists to allow overriding operational
--   semantics e.g. <tt>responseTimeout</tt> per request, If you need
--   global modifications, you should use <tt>managerModifyRequest</tt> 2.
--   the <a>cookieJar</a>, if defined, is being applied after
--   <a>makeClientRequest</a> is called.
[makeClientRequest] :: ClientEnv -> BaseUrl -> Request -> IO Request

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv
clientResponseToResponse :: (a -> b) -> Response a -> ResponseF b

-- | Create a <tt>http-client</tt> <a>Request</a> from a <tt>servant</tt>
--   <a>RequestF</a> The <a>host</a>, <a>path</a> and <a>port</a> fields
--   are extracted from the <a>BaseUrl</a> otherwise the body, headers and
--   query string are derived from the <tt>servant</tt> <a>RequestF</a>
defaultMakeClientRequest :: BaseUrl -> Request -> IO Request
catchConnectionError :: IO a -> IO (Either ClientError a)
instance Control.Monad.Error.Class.MonadError Servant.Client.Core.ClientError.ClientError Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Reader.Class.MonadReader Servant.Client.Internal.HttpClient.ClientEnv Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Generics.Generic (Servant.Client.Internal.HttpClient.Streaming.ClientM a)
instance Control.Monad.IO.Class.MonadIO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Monad Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Applicative Servant.Client.Internal.HttpClient.Streaming.ClientM
instance GHC.Base.Functor Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Control.Monad.Base.MonadBase GHC.Types.IO Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Data.Functor.Alt.Alt Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.RunClient.RunClient Servant.Client.Internal.HttpClient.Streaming.ClientM
instance Servant.Client.Core.RunClient.RunStreamingClient Servant.Client.Internal.HttpClient.Streaming.ClientM


-- | This module provides <a>client</a> which can automatically generate
--   querying functions for each endpoint just from the type representing
--   your API.
--   
--   This client supports streaming operations.
module Servant.Client.Streaming

-- | Generates a set of client functions for an API.
--   
--   Example:
--   
--   <pre>
--   type API = Capture "no" Int :&gt; Get '[JSON] Int
--          :&lt;|&gt; Get '[JSON] [Bool]
--   
--   api :: Proxy API
--   api = Proxy
--   
--   getInt :: Int -&gt; ClientM Int
--   getBools :: ClientM [Bool]
--   getInt :&lt;|&gt; getBools = client api
--   </pre>
client :: HasClient ClientM api => Proxy api -> Client ClientM api

-- | <tt>ClientM</tt> is the monad in which client functions run. Contains
--   the <a>Manager</a> and <a>BaseUrl</a> used for requests in the reader
--   environment.
data ClientM a
withClientM :: ClientM a -> ClientEnv -> (Either ClientError a -> IO b) -> IO b

-- | A <a>runClientM</a> variant for streaming client.
--   
--   It allows using this module's <a>ClientM</a> in a direct style. The
--   <a>NFData</a> constraint however prevents using this function with
--   genuine streaming response types (<tt>SourceT</tt>, <tt>Conduit</tt>,
--   pipes <a>Proxy</a> or <tt>Machine</tt>). For those you have to use
--   <a>withClientM</a>.
--   
--   <i>Note:</i> we <a>force</a> the result, so the likelihood of
--   accidentally leaking a connection is smaller. Use with care.
runClientM :: NFData a => ClientM a -> ClientEnv -> IO (Either ClientError a)

-- | The environment in which a request is run. The <a>baseUrl</a> and
--   <a>makeClientRequest</a> function are used to create a
--   <tt>http-client</tt> request. Cookies are then added to that request
--   if a <tt>CookieJar</tt> is set on the environment. Finally the request
--   is executed with the <a>manager</a>. The <a>makeClientRequest</a>
--   function can be used to modify the request to execute and set values
--   which are not specified on a <tt>servant</tt> <a>RequestF</a> like
--   <tt>responseTimeout</tt> or <tt>redirectCount</tt>
data ClientEnv
ClientEnv :: Manager -> BaseUrl -> Maybe (TVar CookieJar) -> (BaseUrl -> Request -> IO Request) -> ClientEnv
[manager] :: ClientEnv -> Manager
[baseUrl] :: ClientEnv -> BaseUrl
[cookieJar] :: ClientEnv -> Maybe (TVar CookieJar)

-- | this function can be used to customize the creation of
--   <tt>http-client</tt> requests from <tt>servant</tt> requests. Default
--   value: <a>defaultMakeClientRequest</a> Note that: 1.
--   <a>makeClientRequest</a> exists to allow overriding operational
--   semantics e.g. <tt>responseTimeout</tt> per request, If you need
--   global modifications, you should use <tt>managerModifyRequest</tt> 2.
--   the <a>cookieJar</a>, if defined, is being applied after
--   <a>makeClientRequest</a> is called.
[makeClientRequest] :: ClientEnv -> BaseUrl -> Request -> IO Request

-- | <a>ClientEnv</a> smart constructor.
mkClientEnv :: Manager -> BaseUrl -> ClientEnv

-- | Create a <tt>http-client</tt> <a>Request</a> from a <tt>servant</tt>
--   <a>RequestF</a> The <a>host</a>, <a>path</a> and <a>port</a> fields
--   are extracted from the <a>BaseUrl</a> otherwise the body, headers and
--   query string are derived from the <tt>servant</tt> <a>RequestF</a>
defaultMakeClientRequest :: BaseUrl -> Request -> IO Request

-- | Change the monad the client functions live in, by supplying a
--   conversion function (a natural transformation to be precise).
--   
--   For example, assuming you have some <tt>manager ::
--   <tt>Manager</tt></tt> and <tt>baseurl :: <a>BaseUrl</a></tt> around:
--   
--   <pre>
--   type API = Get '[JSON] Int :&lt;|&gt; Capture "n" Int :&gt; Post '[JSON] Int
--   api :: Proxy API
--   api = Proxy
--   getInt :: IO Int
--   postInt :: Int -&gt; IO Int
--   getInt :&lt;|&gt; postInt = hoistClient api (flip runClientM cenv) (client api)
--     where cenv = mkClientEnv manager baseurl
--   </pre>
hoistClient :: HasClient ClientM api => Proxy api -> (forall a. m a -> n a) -> Client m api -> Client n api
